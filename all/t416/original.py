class vertex:
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return f"{self.value}"
    
    def __repr__(self):
        return f"Vertex: {self.value}"
    
    def __hash__(self):
        return hash(self.value)
    
    def __eq__(self, v):
        return self.value == v
    
    def element(self):
        return self.value
    
class edge:
    def __init__(self, vert1, vert2, element):
        self.vert1 = vert1
        self.vert2 = vert2
        self.element = element
        
    def __str__(self):
        return f"{self.vert1} -> {self.vert2}" 
    
    def __repr__(self):
        return f"Edge: {self.vert1} -> {self.vert2}" 

    def vertices(self):
        return (self.vert1, self.vert2)
    
    def opposite(self, x):
        if self.vert1 == x:
            return self.vert2
        elif self.vert2 == x:
            return self.vert1
        
    def value(self):
        return self.element
    
    def first_vertex(self):
        return self.vert1
    
    def second_vertex(self):
        return self.vert2

class graph_am:
    def __init__(self):
        self.adjacency_map = {}

    '''
        def __str__(self):
            model_answer_result = ""
            for vertex, neighbors in self.adjacency_map.items():
                model_answer_result += f"({vertex}): {[str(neighbors[x]) for x in neighbors]}\n"
            return model_answer_result
    '''

    def __str__(self):
        # The code for this __str__ function was generated by ChatGPT, so I could represent the graph in the DOT
        # (graph description language) format. This allowed me to visualise the graphs in online programs
        
        result = "graph {\n"
        result += "  layout=neato;\n"  # Specify layout algorithm as neato
        added_edges = set()
        for vertex, neighbors in self.adjacency_map.items():
            for neighbor, edge in neighbors.items():
                if (vertex, neighbor) not in added_edges and (neighbor, vertex) not in added_edges:
                    result += f'  "{vertex}" -- "{neighbor}" [label="{edge.element}"];\n'
                    added_edges.add((vertex, neighbor))
        result += "}\n"
        return result
    
    def vertices(self):
        return self.adjacency_map.keys()
        
    def edges(self):
        edges = set()
        for vertex1 in self.adjacency_map:
            for vertex2 in self.adjacency_map[vertex1]:
                edges.add(self.adjacency_map[vertex1][vertex2])

        return edges
    
    def num_vertices(self):
        return len(self.adjacency_map.keys())
    
    def num_edges(self):
        return len(self.edges())
    
    def get_edge(self, x, y):
        return self.adjacency_map[x][y]
    
    def is_edge(self, x, y):
        return y in self.adjacency_map.get(x, {})
            
    def degree(self, x):
        return len(self.adjacency_map[x])
    
    def get_edges(self, x):
        return list(self.adjacency_map[x].values())
    
    def add_vertex(self, elt):
        v = vertex(elt)
        self.adjacency_map[v] = {}
        return v

    def add_edge(self, x, y, elt):
        if x not in self.adjacency_map or y not in self.adjacency_map:
            raise ValueError("One or more vertices not in the graph")
        new_edge = edge(x, y, elt)
        self.adjacency_map[x][y] = new_edge
        self.adjacency_map[y][x] = new_edge
        return new_edge

    def remove_vertex(self, x):
        if x not in self.adjacency_map:
            raise ValueError("Vertex not in graph")
        v = self.adjacency_map[x]
        for vertex in v:
            del self.adjacency_map[vertex][x]
        del self.adjacency_map[x]

    def remove_edge(self, e):
        del self.adjacency_map[e.vert1][e.vert2]
        del self.adjacency_map[e.vert2][e.vert1]