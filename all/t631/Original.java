import org.example.data.CustomerData;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Vector;

/**
 * BEWARE: Non-working code generated by ChatGPT based on java.io version of the code.
 *
 * A simple demo class showcasing the working of the SimpleCSVReaderWriter class.
 * It reads the data from a CSV file, transforms each row into an instance of the
 * {@link CustomerData} class and prints the list of instances.
 */
public class SimpleCSVNioDemo {

    public static void writeLine(FileChannel channel, List<String> values) throws IOException {
        boolean firstVal = true;
        StringBuilder sb = new StringBuilder();
        for (String val : values) {
            if (!firstVal) {
                sb.append(",");
            }
            sb.append("\"");
            for (int i = 0; i < val.length(); i++) {
                char ch = val.charAt(i);
                if (ch == '\"') {
                    sb.append("\"");  // extra quote
                }
                sb.append(ch);
            }
            sb.append("\"");
            firstVal = false;
        }
        sb.append("\n");
        ByteBuffer buffer = ByteBuffer.wrap(sb.toString().getBytes(StandardCharsets.UTF_8));
        channel.write(buffer);
    }

    /**
     * Returns a null when the input stream is empty
     */
    public static List<String> parseLine(FileChannel channel) throws IOException {
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        StringBuilder sb = new StringBuilder();
        int bytesRead = channel.read(buffer);

        outerloop:
        while (bytesRead > 0) {
            buffer.flip();
            while (buffer.hasRemaining()) {
                char ch = buffer.getChar();
                 if (ch == '\r') {
                    // ignore LF characters
                } else if (ch == '\n') {
                    break outerloop;
                }
                sb.append(buffer.getChar());
            }
            buffer.clear();
            bytesRead = channel.read(buffer);
        }

        if (sb.length() == 0) {
            return null;
        }

        Vector<String> store = new Vector<>();
        StringBuilder curVal = new StringBuilder();
        boolean inquotes = false;
        boolean started = false;
        for (int i = 0; i < sb.length(); i++) {
            char ch = sb.charAt(i);
            if (inquotes) {
                started = true;
                if (ch == '\"') {
                    inquotes = false;
                } else {
                    curVal.append(ch);
                }
            } else {
                if (ch == '\"') {
                    inquotes = true;
                    if (started) {
                        curVal.append('\"');
                    }
                } else if (ch == ',') {
                    store.add(curVal.toString());
                    curVal = new StringBuilder();
                    started = false;
                } else if (ch == '\r') {
                    // ignore LF characters
                } else if (ch == '\n') {
                    break;
                } else {
                    curVal.append(ch);
                }
            }
        }
        store.add(curVal.toString());
        return store;
    }

    public static void main(String[] args) throws Exception {
        Path customerDataFile = null;

        Scanner scanner = new Scanner(System.in);
        boolean validPath = false;

        while (!validPath) {
            // Prompt the user to enter a file path
            System.out.println("Please enter the file path:");
            String customerFilePath = scanner.nextLine();

            // Create a Path object with the provided path
            customerDataFile = Paths.get(customerFilePath);

            // Check if the file exists and is a file
            if (Files.exists(customerDataFile) && Files.isRegularFile(customerDataFile)) {
                validPath = true;
                System.out.println("File path: " + customerDataFile.toAbsolutePath());
            } else {
                System.out.println("The provided path is not a valid file. Please try again.");
            }
        }

        List<String> headers;
        List<CustomerData> customerCollection = new ArrayList<>();

        try (FileChannel fileChannel = FileChannel.open(customerDataFile, StandardOpenOption.READ)) {
            headers = parseLine(fileChannel);

            List<String> values = parseLine(fileChannel);
            while (values != null) {
                customerCollection.add(CustomerData.constructFromStrings(values));
                values = parseLine(fileChannel);
            }
        }

        System.out.println(headers);
        System.out.println(customerCollection);

        writeCustomers(headers, customerCollection);
    }

    private static void writeCustomers(List<String> headers, List<CustomerData> customers) throws Exception {
        Path outputCsvFile = null;
        try (Scanner scanner = new Scanner(System.in)) {
            boolean validPath = false;

            while (!validPath) {
                // Prompt the user to enter a file path
                System.out.println("Please enter the file path to save the CSV file:");
                String outputFilePath = scanner.nextLine();

                // Create a Path object with the provided path
                outputCsvFile = Paths.get(outputFilePath);

                // Check if the file exists and is a file
                if (Files.exists(outputCsvFile) && Files.isRegularFile(outputCsvFile)) {
                    System.out.println("The provided path already exists. Please give a different path.");
                } else {
                    validPath = true;
                    System.out.println("Output file path: " + outputCsvFile.toAbsolutePath());
                }
            }
        }

        try (FileChannel fileChannel = FileChannel.open(outputCsvFile, StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {
            writeLine(fileChannel, headers);

            for (CustomerData cd : customers) {
                writeLine(fileChannel, cd.toCsvLine());
            }
        }
    }
}