#ifndef CYLINDER_H
#define CYLINDER_H
#include "shape.h"
#include "vec3.h"

class cylinder : public shape {
    private:
        point3 center;
        vec3 axis;
        double radius;
        double height;

    public:
        cylinder() {}
        cylinder(const point3& center, const vec3& axis, double radius, double height) :
            center(center), axis(axis), radius(radius), height(height) {}

        point3 get_center() const {return center;}
        vec3 get_axis() const {return axis;}
        double get_radius() const {return radius;}
        double get_height() const {return height;}

        // generated by copilot, prompt: write a method for checking if a ray intersects with a cylinder
        bool intersection(const ray& r) const {
            vec3 oc = r.origin() - center;

            // not part of the original copilot output: added by copilot later once 
            // I had a different reference for cylinders with an arbitrary axis open in Chrome: oh god copilot is going to kill us all
            vec3 dir = r.direction();
            double a = dot(dir, dir) - (dot(dir, axis) * dot(dir, axis));
            double b = 2.0 * (dot(oc, dir) - (dot(oc, axis) * dot(dir, axis)));
            double c = dot(oc, oc) - (dot(oc, axis) * dot(oc, axis)) - (radius * radius);
            

            double discriminant = b*b - 4*a*c;
            if (discriminant < 0) {
                return false;
            }

            double sqrt_discriminant = sqrt(discriminant);
            double t0 = (-b - sqrt_discriminant) / (2.0 * a);
            double t1 = (-b + sqrt_discriminant) / (2.0 * a);

            // co-pilot generated, yet again: not part of the original response though
            double m1 = dot(r.direction(), axis) * t0 + dot(oc, axis);
            double m2 = dot(r.direction(), axis) * t1 + dot(oc, axis);

            return ((m1 <= height && m1 >= 0) || (m2 <= height && m2 >= 0));

            // IMPLEMENT PLANE INTERSECTIONS AT CAPS LOL
        }
};

#endif