{"task_id": 87, "code_type": "method", "original_language": "javascript", "question_type": "User interface", "summary": "Convert UNIX timestamps to a more readable time format in month-date-24h format", "language_version_list": {"python": {"code_signature": "from datetime import datetime\n\n\ndef convert_unix_timestamp_to_readable_date(unix_timestamp: int) -> str:\n    \"\"\"\n    Convert the UNIX timestamp to the string format 'MMM D, H:MM'.\n\n    Example:\n        Input: 1672531200\n        Output: 'Jan 1, 8:00'\n\n        Input: 1696516800\n        Output: 'Oct 5, 22:40'\n\n    Args:\n        unix_timestamp (int): The UNIX timestamp to convert.\n\n    Returns:\n        str: A formatted date string in the form 'MMM D, H:MM'.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestTimestampToReadableDate(unittest.TestCase):\n    def test_convert_unix_timestamp_to_readable_format(self):\n        timestamp = 1696516800\n        self.assertEqual(convert_unix_timestamp_to_readable_date(timestamp), 'Oct 5, 22:40')\n\n    def test_handle_timestamp_at_start_of_year(self):\n        timestamp = 1672531200\n        self.assertEqual(convert_unix_timestamp_to_readable_date(timestamp), 'Jan 1, 8:00')\n\n    def test_handle_timestamp_at_end_of_year(self):\n        timestamp = 1672531199\n        self.assertEqual(convert_unix_timestamp_to_readable_date(timestamp), 'Jan 1, 7:59')\n\n    def test_handle_timestamps_in_leap_year(self):\n        timestamp = 1583020800\n        self.assertEqual(convert_unix_timestamp_to_readable_date(timestamp), 'Mar 1, 8:00')\n\n    def test_convert_timestamp_to_readable_format_with_single_digit_day(self):\n        timestamp = 1675190400\n        self.assertEqual(convert_unix_timestamp_to_readable_date(timestamp), 'Feb 1, 2:40')\n\n    def test_handle_zero_unix_timestamp(self):\n        timestamp = 0\n        self.assertEqual(convert_unix_timestamp_to_readable_date(timestamp), 'Jan 1, 8:00')\n", "prompt": "please write a python function , the function signature as below from datetime import datetime\n\n\ndef convert_unix_timestamp_to_readable_date(unix_timestamp: int) -> str:\n    \"\"\"\n    Convert the UNIX timestamp to the string format 'MMM D, H:MM'.\n\n    Example:\n        Input: 1672531200\n        Output: 'Jan 1, 8:00'\n\n        Input: 1696516800\n        Output: 'Oct 5, 22:40'\n\n    Args:\n        unix_timestamp (int): The UNIX timestamp to convert.\n\n    Returns:\n        str: A formatted date string in the form 'MMM D, H:MM'.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * convert the UNIX timestamp to the string format 'Jan 1, 8: 00'.\n * for example:\n *      input: 1672531200 output: Jan 1, 8:00\n *      input: 1696516800 output: Oct 5, 22:40\n *\n * @param unixTimestamp\n */\nfunction timestampToReadableDate(unixTimestamp) {\n\n}\n", "test_code": "describe('timestampToReadableDate', () => {\n    test('should convert UNIX timestamp to readable format', () => {\n        const timestamp = 1696516800;\n        expect(timestampToReadableDate(timestamp)).toBe('Oct 5, 22:40');\n    });\n\n    test('should handle timestamp at the start of the year', () => {\n        const timestamp = 1672531200;\n        expect(timestampToReadableDate(timestamp)).toBe('Jan 1, 8:00');\n    });\n\n    test('should handle timestamp at the end of the year', () => {\n        const timestamp = 1672531199;\n        expect(timestampToReadableDate(timestamp)).toBe('Jan 1, 7:59');\n    });\n\n    test('should handle timestamps in the leap year', () => {\n        const timestamp = 1583020800;\n        expect(timestampToReadableDate(timestamp)).toBe('Mar 1, 8:00');\n    });\n\n    test('should convert timestamp to readable format with single-digit day', () => {\n        const timestamp = 1675190400;\n        expect(timestampToReadableDate(timestamp)).toBe('Feb 1, 2:40');\n    });\n\n\n    test('should handle zero UNIX timestamp', () => {\n        const timestamp = 0;\n        expect(timestampToReadableDate(timestamp)).toBe('Jan 1, 8:00');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * convert the UNIX timestamp to the string format 'Jan 1, 8: 00'.\n * for example:\n *      input: 1672531200 output: Jan 1, 8:00\n *      input: 1696516800 output: Oct 5, 22:40\n *\n * @param unixTimestamp\n */\nfunction timestampToReadableDate(unixTimestamp) {\n\n}\n", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Convert the UNIX timestamp to the string format 'Jan 1, 8:00'.\n * For example:\n *      Input: 1672531200 Output: Jan 1, 8:00\n *      Input: 1696516800 Output: Oct 5, 22:40\n *\n * @param unixTimestamp - The UNIX timestamp to convert.\n * @returns A readable date string.\n */\nfunction timestampToReadableDate(unixTimestamp: number): string {\n\n}", "test_code": "describe('timestampToReadableDate', () => {\n    test('should convert UNIX timestamp to readable format', () => {\n        const timestamp: number = 1696516800;\n        expect(timestampToReadableDate(timestamp)).toBe('Oct 5, 22:40');\n    });\n\n    test('should handle timestamp at the start of the year', () => {\n        const timestamp: number = 1672531200;\n        expect(timestampToReadableDate(timestamp)).toBe('Jan 1, 8:00');\n    });\n\n    test('should handle timestamp at the end of the year', () => {\n        const timestamp: number = 1672531199;\n        expect(timestampToReadableDate(timestamp)).toBe('Jan 1, 7:59');\n    });\n\n    test('should handle timestamps in the leap year', () => {\n        const timestamp: number = 1583020800;\n        expect(timestampToReadableDate(timestamp)).toBe('Mar 1, 8:00');\n    });\n\n    test('should convert timestamp to readable format with single-digit day', () => {\n        const timestamp: number = 1675190400;\n        expect(timestampToReadableDate(timestamp)).toBe('Feb 1, 2:40');\n    });\n\n    test('should handle zero UNIX timestamp', () => {\n        const timestamp: number = 0;\n        expect(timestampToReadableDate(timestamp)).toBe('Jan 1, 8:00');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Convert the UNIX timestamp to the string format 'Jan 1, 8:00'.\n * For example:\n *      Input: 1672531200 Output: Jan 1, 8:00\n *      Input: 1696516800 Output: Oct 5, 22:40\n *\n * @param unixTimestamp - The UNIX timestamp to convert.\n * @returns A readable date string.\n */\nfunction timestampToReadableDate(unixTimestamp: number): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * convert the UNIX timestamp to the string format 'Jan 1, 8:00 AM'.\n * for example:\n *      input: 1672531200 output: Jan 1, 8:00 AM\n *      input: 1696516800 output: Oct 5, 22:40 PM\n *\n * @param unixTimestamp\n * @return std::string\n */\nstd::string timestamp_to_readable_date(long long unixTimestamp) {}", "test_code": "TEST_CASE(\"timestampToReadableDate\", \"[timestamp]\") {\n    SECTION(\"should convert UNIX timestamp to readable format\") {\n        long long timestamp = 1696516800;\n        REQUIRE(timestamp_to_readable_date(timestamp) == \"Oct 05, 10:40 PM\");\n    }\n\n    SECTION(\"should handle timestamp at the start of the year\") {\n        long long timestamp = 1672531200;\n        REQUIRE(timestamp_to_readable_date(timestamp) == \"Jan 01, 8:00 AM\");\n    }\n\n    SECTION(\"should handle timestamp at the end of the year\") {\n        long long timestamp = 1672531199;\n        REQUIRE(timestamp_to_readable_date(timestamp) == \"Jan 01, 7:59 AM\");\n    }\n\n    SECTION(\"should handle timestamps in the leap year\") {\n        long long timestamp = 1583020800;\n        REQUIRE(timestamp_to_readable_date(timestamp) == \"Mar 01, 8:00 AM\");\n    }\n\n    SECTION(\"should convert timestamp to readable format with single-digit day\") {\n        long long timestamp = 1675190400;\n        REQUIRE(timestamp_to_readable_date(timestamp) == \"Feb 01, 2:40 AM\");\n    }\n\n    SECTION(\"should handle zero UNIX timestamp\") {\n        long long timestamp = 0;\n        REQUIRE(timestamp_to_readable_date(timestamp) == \"Jan 01, 8:00 AM\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * convert the UNIX timestamp to the string format 'Jan 1, 8:00 AM'.\n * for example:\n *      input: 1672531200 output: Jan 1, 8:00 AM\n *      input: 1696516800 output: Oct 5, 22:40 PM\n *\n * @param unixTimestamp\n * @return std::string\n */\nstd::string timestamp_to_readable_date(long long unixTimestamp) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Convert the UNIX timestamp to the string format 'Jan 1, 8:00'.\n * For example:\n *      input: 1672531200 output: Jan 1, 8:00\n *      input: 1696516800 output: Oct 5, 22:40\n *\n * @param unixTimestamp the UNIX timestamp to convert\n * @return the formatted date string\n */\npublic String timestampToReadableDate(long unixTimestamp) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.Calendar;\nimport java.util.GregorianCalendar;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    private String timestampToReadableDate(long unixTimestamp) {\n        long millis = unixTimestamp * 1000;\n        Calendar calendar = new GregorianCalendar();\n        calendar.setTimeInMillis(millis);\n        \n        String[] monthNames = {\n            \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n            \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n        };\n        \n        String month = monthNames[calendar.get(Calendar.MONTH)];\n        int day = calendar.get(Calendar.DAY_OF_MONTH);\n        int hours = calendar.get(Calendar.HOUR_OF_DAY);\n        String minutes = String.format(\"%02d\", calendar.get(Calendar.MINUTE));\n        \n        return String.format(\"%s %d, %d:%s\", month, day, hours, minutes);\n    }\n\n    @Test\n    public void testConvertUnixTimestampToReadableFormat() {\n        long timestamp = 1696516800;\n        assertEquals(\"Oct 5, 22:40\", timestampToReadableDate(timestamp));\n    }\n\n    @Test\n    public void testHandleTimestampAtStartOfYear() {\n        long timestamp = 1672531200;\n        assertEquals(\"Jan 1, 8:00\", timestampToReadableDate(timestamp));\n    }\n\n    @Test\n    public void testHandleTimestampAtEndOfYear() {\n        long timestamp = 1672531199;\n        assertEquals(\"Jan 1, 7:59\", timestampToReadableDate(timestamp));\n    }\n\n    @Test\n    public void testHandleTimestampsInLeapYear() {\n        long timestamp = 1583020800;\n        assertEquals(\"Mar 1, 8:00\", timestampToReadableDate(timestamp));\n    }\n\n    @Test\n    public void testConvertTimestampToReadableFormatWithSingleDigitDay() {\n        long timestamp = 1675190400;\n        assertEquals(\"Feb 1, 2:40\", timestampToReadableDate(timestamp));\n    }\n\n    @Test\n    public void testHandleZeroUnixTimestamp() {\n        long timestamp = 0;\n        assertEquals(\"Jan 1, 8:00\", timestampToReadableDate(timestamp));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Convert the UNIX timestamp to the string format 'Jan 1, 8:00'.\n * For example:\n *      input: 1672531200 output: Jan 1, 8:00\n *      input: 1696516800 output: Oct 5, 22:40\n *\n * @param unixTimestamp the UNIX timestamp to convert\n * @return the formatted date string\n */\npublic String timestampToReadableDate(long unixTimestamp) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 88, "code_type": "method", "original_language": "javascript", "question_type": "Configuration and deployment", "summary": "Parse a crom expression and determine whether it is between 2 a.m. and 4 a.m.\n", "language_version_list": {"python": {"code_signature": "def is_cron_between_2_and_4_am(cron_expression: str) -> bool:\n    \"\"\"\n    Parse a cron expression and determine whether it is between 2 a.m. and 4 a.m.\n\n    Args:\n        cron_expression (str): The cron expression to parse.\n\n    Returns:\n        bool: True if any hour in the cron expression is between 2 a.m. and 4 a.m., False otherwise.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsCronBetween2And4AM(unittest.TestCase):\n\n    def test_specific_hours(self):\n        \"\"\"should return true for specific hours 2, 3, and 4\"\"\"\n        self.assertTrue(is_cron_between_2_and_4_am('0 2,3,4 * * *'))\n\n    def test_range_includes_2_to_4_am(self):\n        \"\"\"should return false for range that includes 2 to 4 a.m.\"\"\"\n        self.assertTrue(is_cron_between_2_and_4_am('0 2-4 * * *'))\n\n    def test_range_excludes_2_to_4_am(self):\n        \"\"\"should return false for range that excludes 2 to 4 a.m.\"\"\"\n        self.assertFalse(is_cron_between_2_and_4_am('0 0-1,5-23 * * *'))\n\n    def test_wildcard_in_hour_field(self):\n        \"\"\"should return false for wildcard in hour field\"\"\"\n        self.assertFalse(is_cron_between_2_and_4_am('0 * * * *'))", "prompt": "please write a python function , the function signature as below def is_cron_between_2_and_4_am(cron_expression: str) -> bool:\n    \"\"\"\n    Parse a cron expression and determine whether it is between 2 a.m. and 4 a.m.\n\n    Args:\n        cron_expression (str): The cron expression to parse.\n\n    Returns:\n        bool: True if any hour in the cron expression is between 2 a.m. and 4 a.m., False otherwise.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Parse a crom expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression\n */\nfunction isCronBetween2And4AM(cronExpression) {\n\n}", "test_code": "describe('isCronBetween2And4AM', () => {\n    test('should return true for specific hours 2, 3, and 4', () => {\n        expect(isCronBetween2And4AM('0 2,3,4 * * *')).toBe(true);\n    });\n\n    test('should return false for range that includes 2 to 4 a.m.', () => {\n        expect(isCronBetween2And4AM('0 1-5 * * *')).toBe(false);\n    });\n\n    test('should return false for range that excludes 2 to 4 a.m.', () => {\n        expect(isCronBetween2And4AM('0 0-1,5-23 * * *')).toBe(false);\n    });\n\n    test('should return true for wildcard in hour field', () => {\n        expect(isCronBetween2And4AM('0 * * * *')).toBe(false);\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Parse a crom expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression\n */\nfunction isCronBetween2And4AM(cronExpression) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Parse a cron expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression - The cron expression to parse.\n * @returns True if the expression includes hours between 2 and 4 a.m., otherwise false.\n */\nfunction isCronBetween2And4AM(cronExpression: string): boolean {}", "test_code": "describe('isCronBetween2And4AM', () => {\n    test('should return true for specific hours 2, 3, and 4', () => {\n        expect(isCronBetween2And4AM('0 2,3,4 * * *')).toBe(true);\n    });\n\n    test('should return false for range that includes 2 to 4 a.m.', () => {\n        expect(isCronBetween2And4AM('0 1-5 * * *')).toBe(false);\n    });\n\n    test('should return false for range that excludes 2 to 4 a.m.', () => {\n        expect(isCronBetween2And4AM('0 0-1,5-23 * * *')).toBe(false);\n    });\n\n    test('should return false for wildcard in hour field', () => {\n        expect(isCronBetween2And4AM('0 * * * *')).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Parse a cron expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression - The cron expression to parse.\n * @returns True if the expression includes hours between 2 and 4 a.m., otherwise false.\n */\nfunction isCronBetween2And4AM(cronExpression: string): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Parse a cron expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression The cron expression to parse.\n * @return true if the expression contains hours between 2 and 4, otherwise false.\n */\nbool is_cron_between2_and4_am(const std::string& cronExpression) {}", "test_code": "TEST_CASE(\"isCronBetween2And4AM\") {\n    SECTION(\"should return true for specific hours 2, 3, and 4\") {\n        REQUIRE(is_cron_between2_and4_am(\"0 2,3,4 * * *\") == true);\n    }\n\n    SECTION(\"should return ture for range that includes 2 to 4 a.m.\") {\n        REQUIRE(is_cron_between2_and4_am(\"0 1-5 * * *\") == true);\n    }\n\n    SECTION(\"should return false for range that excludes 2 to 4 a.m.\") {\n        REQUIRE(is_cron_between2_and4_am(\"0 0-1,5-23 * * *\") == false);\n    }\n\n    SECTION(\"should return false for wildcard in hour field\") {\n        REQUIRE(is_cron_between2_and4_am(\"0 * * * *\") == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Parse a cron expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression The cron expression to parse.\n * @return true if the expression contains hours between 2 and 4, otherwise false.\n */\nbool is_cron_between2_and4_am(const std::string& cronExpression) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Parse a cron expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression the cron expression to parse\n * @return true if the hours are between 2 and 4 a.m., otherwise false\n */\npublic boolean isCronBetween2And4AM(String cronExpression) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testSpecificHours() {\n        assertTrue(isCronBetween2And4AM(\"0 2,3,4 * * *\"));\n    }\n\n    @Test\n    public void testRangeIncludes2To4AM() {\n        assertFalse(isCronBetween2And4AM(\"0 1-5 * * *\"));\n    }\n\n    @Test\n    public void testRangeExcludes2To4AM() {\n        assertFalse(isCronBetween2And4AM(\"0 0-1,5-23 * * *\"));\n    }\n\n    @Test\n    public void testWildcardInHourField() {\n        assertFalse(isCronBetween2And4AM(\"0 * * * *\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Parse a cron expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression the cron expression to parse\n * @return true if the hours are between 2 and 4 a.m., otherwise false\n */\npublic boolean isCronBetween2And4AM(String cronExpression) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 89, "code_type": "method", "original_language": "javascript", "question_type": "User interface", "summary": "calculates the elapsed time from a given start time in milliseconds and returns\nit as a formatted string in \"minutes:seconds\" format.", "language_version_list": {"python": {"code_signature": "def time_passed(start_time_in_millis: int) -> str:\n    \"\"\"\n    Calculates the elapsed time from a given start time in milliseconds and returns\n    it as a formatted string in \"minutes:seconds\" format.\n\n    Args:\n        start_time_in_millis (int): The start time in milliseconds.\n\n    Returns:\n        str: A string representing the elapsed time in minutes and seconds.\n    \"\"\"", "test_code": "import unittest\nfrom unittest.mock import patch\n\n\nclass TestTimePassed(unittest.TestCase):\n\n    @patch('time.time', return_value=1609459200)  # Mocking time to freeze at Jan 1, 2021, 00:00:00\n    def test_time_passed_one_minute_ago(self, mock_time):\n        start_time = 1609459140000  # 1 minute earlier\n        self.assertEqual(time_passed(start_time), \"1:00\")\n\n    @patch('time.time', return_value=1609459200)  # Mocking time\n    def test_time_passed_boundary_59_seconds(self, mock_time):\n        start_time = 1609459194100  # 59 seconds and 900 milliseconds earlier\n        self.assertEqual(time_passed(start_time), \"0:05\")\n\n    @patch('time.time', return_value=1609459200)  # Mocking time\n    def test_time_passed_same_as_current_time(self, mock_time):\n        self.assertEqual(time_passed(1609459200000), \"0:00\")\n\n    @patch('time.time', return_value=1609459200)  # Mocking time\n    def test_time_passed_future_start_time(self, mock_time):\n        start_time = 1609459260000  # 1 minute into the future\n        result = time_passed(start_time)\n        self.assertRegex(result, '-')  # Expecting negative output or some error handling\n\n    @patch('time.time', return_value=1609459200)  # Mocking time\n    def test_time_passed_large_time_difference(self, mock_time):\n        start_time = 1483228800000  # January 1, 2017, 00:00:00 (4 years difference)\n        self.assertEqual(time_passed(start_time), \"2103840:00\")  # Calculated minutes for 4 years\n", "prompt": "please write a python function , the function signature as below def time_passed(start_time_in_millis: int) -> str:\n    \"\"\"\n    Calculates the elapsed time from a given start time in milliseconds and returns\n    it as a formatted string in \"minutes:seconds\" format.\n\n    Args:\n        start_time_in_millis (int): The start time in milliseconds.\n\n    Returns:\n        str: A string representing the elapsed time in minutes and seconds.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param {number} startTimeInMillis - The start time in milliseconds.\n * @return {string} A string representing the elapsed time in minutes and seconds.\n */\nfunction timePassed(startTimeInMillis) {\n}", "test_code": "describe('timePassed function', () => {\n    const originalDateNow = Date.now;\n\n    beforeEach(() => {\n        // Freeze the Date.now() to a fixed timestamp\n        Date.now = jest.fn(() => 1609459200000); // January 1, 2021, 00:00:00\n    });\n\n    afterEach(() => {\n        // Restore original Date.now() function\n        Date.now = originalDateNow;\n    });\n\n    test('should correctly calculate time passed from 1 minute ago', () => {\n        const startTime = 1609459140000; // 1 minute earlier\n        expect(timePassed(startTime)).toBe(\"1:00\");\n    });\n\n    test('should handle the boundary of 59 seconds correctly', () => {\n        const startTime = 1609459194100; // 59 seconds and 900 milliseconds earlier\n        expect(timePassed(startTime)).toBe(\"0:05\");\n    });\n\n    test('should return 0:00 when start time is the same as current time', () => {\n        expect(timePassed(1609459200000)).toBe(\"0:00\");\n    });\n\n    test('should handle negative time differences (future start time)', () => {\n        const startTime = 1609459260000; // 1 minute into the future\n        expect(timePassed(startTime)).toMatch(/-/); // Expecting negative output or some error handling\n    });\n\n    test('should handle very large time differences correctly', () => {\n        const startTime = 1483228800000; // January 1, 2017, 00:00:00 (4 years difference)\n        expect(timePassed(startTime)).toBe(\"2103840:00\"); // Calculated minutes for 4 years\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param {number} startTimeInMillis - The start time in milliseconds.\n * @return {string} A string representing the elapsed time in minutes and seconds.\n */\nfunction timePassed(startTimeInMillis) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param {number} startTimeInMillis - The start time in milliseconds.\n * @return {string} A string representing the elapsed time in minutes and seconds.\n */\nfunction timePassed(startTimeInMillis: number): string {\n    // Function implementation goes here\n}", "test_code": "describe('timePassed function', () => {\n    const originalDateNow = Date.now;\n\n    beforeEach(() => {\n        // Freeze the Date.now() to a fixed timestamp\n        Date.now = jest.fn(() => 1609459200000); // January 1, 2021, 00:00:00\n    });\n\n    afterEach(() => {\n        // Restore original Date.now() function\n        Date.now = originalDateNow;\n    });\n\n    test('should correctly calculate time passed from 1 minute ago', () => {\n        const startTime = 1609459140000; // 1 minute earlier\n        expect(timePassed(startTime)).toBe(\"1:00\");\n    });\n\n    test('should handle the boundary of 59 seconds correctly', () => {\n        const startTime = 1609459194100; // 59 seconds and 900 milliseconds earlier\n        expect(timePassed(startTime)).toBe(\"0:05\");\n    });\n\n    test('should return 0:00 when start time is the same as current time', () => {\n        expect(timePassed(1609459200000)).toBe(\"0:00\");\n    });\n\n    test('should handle negative time differences (future start time)', () => {\n        const startTime = 1609459260000; // 1 minute into the future\n        expect(timePassed(startTime)).toMatch(/-/); // Expecting negative output or some error handling\n    });\n\n    test('should handle very large time differences correctly', () => {\n        const startTime = 1483228800000; // January 1, 2017, 00:00:00 (4 years difference)\n        expect(timePassed(startTime)).toBe(\"2103840:00\"); // Calculated minutes for 4 years\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param {number} startTimeInMillis - The start time in milliseconds.\n * @return {string} A string representing the elapsed time in minutes and seconds.\n */\nfunction timePassed(startTimeInMillis: number): string {\n    // Function implementation goes here\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param startTimeInMillis The start time in milliseconds.\n * @return A string representing the elapsed time in minutes and seconds.\n */\nstd::string time_passed(long long startTimeInMillis) {}", "test_code": "TEST_CASE(\"timePassed function\") {\n    SECTION(\"should correctly calculate time passed from 1 minute ago\") {\n        long long startTime = 1609459140000; // 1 minute earlier\n        REQUIRE(time_passed(startTime) == \"1:00\");\n    }\n\n    SECTION(\"should handle the boundary of 59 seconds correctly\") {\n        long long startTime = 1609459194100; // 59 seconds and 900 milliseconds earlier\n        REQUIRE(time_passed(startTime) == \"0:05\");\n    }\n\n    SECTION(\"should return 0:00 when start time is the same as current time\") {\n        REQUIRE(time_passed(1609459200000) == \"0:00\");\n    }\n\n    SECTION(\"should handle negative time differences (future start time)\") {\n        long long startTime = 1609459260000; // 1 minute into the future\n        std::string result = time_passed(startTime);\n        REQUIRE(result.find('-') != std::string::npos); // Expecting negative output or error handling\n    }\n\n    SECTION(\"should handle very large time differences correctly\") {\n        long long startTime = 1483228800000; // January 1, 2017, 00:00:00 (4 years difference)\n        REQUIRE(time_passed(startTime) == \"2103840:00\"); // Calculated minutes for 4 years\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param startTimeInMillis The start time in milliseconds.\n * @return A string representing the elapsed time in minutes and seconds.\n */\nstd::string time_passed(long long startTimeInMillis) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param startTimeInMillis The start time in milliseconds.\n * @return A string representing the elapsed time in minutes and seconds.\n */\npublic static String timePassed(long startTimeInMillis) {\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    private long fixedTimestamp;\n\n    @Before\n    public void setUp() {\n        // Freeze the current time to a fixed timestamp\n        fixedTimestamp = 1609459200000L; // January 1, 2021, 00:00:00\n    }\n    \n\n    @Test\n    public void testTimePassedOneMinuteAgo() {\n        long startTime = fixedTimestamp - 60000; // 1 minute earlier\n        assertEquals(\"1:00\", timePassed(startTime));\n    }\n\n    @Test\n    public void testTimePassedBoundaryOf59Seconds() {\n        long startTime = fixedTimestamp - 5900; // 59 seconds and 900 milliseconds earlier\n        assertEquals(\"0:05\", timePassed(startTime));\n    }\n\n    @Test\n    public void testTimePassedSameAsCurrentTime() {\n        assertEquals(\"0:00\", timePassed(fixedTimestamp));\n    }\n\n    @Test\n    public void testTimePassedFutureStartTime() {\n        long startTime = fixedTimestamp + 60000; // 1 minute into the future\n        String result = timePassed(startTime);\n        assertTrue(result.startsWith(\"-\")); // Expecting negative output or some error handling\n    }\n\n    @Test\n    public void testTimePassedLargeTimeDifference() {\n        long startTime = 1483228800000L; // January 1, 2017, 00:00:00 (4 years difference)\n        assertEquals(\"2103840:00\", timePassed(startTime)); // Calculated minutes for 4 years\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param startTimeInMillis The start time in milliseconds.\n * @return A string representing the elapsed time in minutes and seconds.\n */\npublic static String timePassed(long startTimeInMillis) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 92, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Decodes HTML entities in a given HTML string.", "language_version_list": {"python": {"code_signature": "def replace_html_entities(html_string: str) -> str:\n    \"\"\"\n    Decodes HTML entities in a given HTML string.\n\n    Args:\n        html_string (str): The HTML string containing entities to decode.\n\n    Returns:\n        str: The decoded string with HTML entities converted back to their original characters.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestReplaceHtmlEntities(unittest.TestCase):\n\n    def test_decodes_standard_html_entities(self):\n        input_string = 'The &amp; symbol should become an &quot;and&quot; sign.'\n        expected = 'The & symbol should become an \"and\" sign.'\n        self.assertEqual(replace_html_entities(input_string), expected)\n\n    def test_returns_empty_string_for_empty_input(self):\n        input_string = ''\n        expected = ''\n        self.assertEqual(replace_html_entities(input_string), expected)\n\n    def test_decodes_multiple_different_entities_in_one_string(self):\n        input_string = '&lt;div&gt;Hello &amp; Welcome to the &apos;World&apos;!&lt;/div&gt;'\n        expected = '<div>Hello & Welcome to the \\'World\\'!</div>'\n        self.assertEqual(replace_html_entities(input_string), expected)\n\n    def test_handles_strings_with_no_entities(self):\n        input_string = 'Just a normal string without entities.'\n        expected = 'Just a normal string without entities.'\n        self.assertEqual(replace_html_entities(input_string), expected)\n", "prompt": "please write a python function , the function signature as below def replace_html_entities(html_string: str) -> str:\n    \"\"\"\n    Decodes HTML entities in a given HTML string.\n\n    Args:\n        html_string (str): The HTML string containing entities to decode.\n\n    Returns:\n        str: The decoded string with HTML entities converted back to their original characters.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Decodes HTML entities in a given HTML string.\n * @param {string} htmlString - The HTML string containing entities to decode.\n * @returns {string} The decoded string with HTML entities converted back to their original characters.\n */\nconst {JSDOM} = require('jsdom');\nconst dom = new JSDOM();\nconst {document} = dom.window;\n\nfunction replaceHtmlEntities(htmlString) {\n}", "test_code": "describe('replaceHtmlEntities', () => {\n    test('decodes standard HTML entities', () => {\n        const input = 'The &amp; symbol should become an &quot;and&quot; sign.';\n        const expected = 'The & symbol should become an \"and\" sign.';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n\n    test('returns empty string for empty input', () => {\n        const input = '';\n        const expected = '';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n\n\n    test('decodes multiple different entities in one string', () => {\n        const input = '&lt;div&gt;Hello &amp; Welcome to the &apos;World&apos;!&lt;/div&gt;';\n        const expected = '<div>Hello & Welcome to the \\'World\\'!</div>';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n\n    test('handles strings with no entities', () => {\n        const input = 'Just a normal string without entities.';\n        const expected = 'Just a normal string without entities.';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Decodes HTML entities in a given HTML string.\n * @param {string} htmlString - The HTML string containing entities to decode.\n * @returns {string} The decoded string with HTML entities converted back to their original characters.\n */\nconst {JSDOM} = require('jsdom');\nconst dom = new JSDOM();\nconst {document} = dom.window;\n\nfunction replaceHtmlEntities(htmlString) {\n}", "addition_info": "/**\n * @jest-environment jsdom\n */"}, "typescript": {"code_signature": "/**\n * Decodes HTML entities in a given HTML string.\n * @param {string} htmlString - The HTML string containing entities to decode.\n * @returns {string} The decoded string with HTML entities converted back to their original characters.\n */\nimport { JSDOM } from 'jsdom';\n\nconst dom = new JSDOM();\nconst { document } = dom.window;\n\nfunction replaceHtmlEntities(htmlString: string): string {}", "test_code": "describe('replaceHtmlEntities', () => {\n    test('decodes standard HTML entities', () => {\n        const input: string = 'The &amp; symbol should become an &quot;and&quot; sign.';\n        const expected: string = 'The & symbol should become an \"and\" sign.';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n\n    test('returns empty string for empty input', () => {\n        const input: string = '';\n        const expected: string = '';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n\n    test('decodes multiple different entities in one string', () => {\n        const input: string = '&lt;div&gt;Hello &amp; Welcome to the &apos;World&apos;!&lt;/div&gt;';\n        const expected: string = '<div>Hello & Welcome to the \\'World\\'!</div>';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n\n    test('handles strings with no entities', () => {\n        const input: string = 'Just a normal string without entities.';\n        const expected: string = 'Just a normal string without entities.';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Decodes HTML entities in a given HTML string.\n * @param {string} htmlString - The HTML string containing entities to decode.\n * @returns {string} The decoded string with HTML entities converted back to their original characters.\n */\nimport { JSDOM } from 'jsdom';\n\nconst dom = new JSDOM();\nconst { document } = dom.window;\n\nfunction replaceHtmlEntities(htmlString: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Decodes HTML entities in a given HTML string.\n * @param htmlString The HTML string containing entities to decode.\n * @returns The decoded string with HTML entities converted back to their original characters.\n */\nstd::string replaceHtmlEntities(const std::string& htmlString) {\n    // Function implementation goes here\n}", "test_code": "TEST_CASE(\"replaceHtmlEntities\") {\n    SECTION(\"decodes standard HTML entities\") {\n        std::string input = \"The &amp; symbol should become an &quot;and&quot; sign.\";\n        std::string expected = \"The & symbol should become an \\\"and\\\" sign.\";\n        REQUIRE(replaceHtmlEntities(input) == expected);\n    }\n\n    SECTION(\"returns empty string for empty input\") {\n        std::string input = \"\";\n        std::string expected = \"\";\n        REQUIRE(replaceHtmlEntities(input) == expected);\n    }\n\n    SECTION(\"decodes multiple different entities in one string\") {\n        std::string input = \"&lt;div&gt;Hello &amp; Welcome to the &apos;World&apos;!&lt;/div&gt;\";\n        std::string expected = \"<div>Hello & Welcome to the 'World'!</div>\";\n        REQUIRE(replaceHtmlEntities(input) == expected);\n    }\n\n    SECTION(\"handles strings with no entities\") {\n        std::string input = \"Just a normal string without entities.\";\n        std::string expected = \"Just a normal string without entities.\";\n        REQUIRE(replaceHtmlEntities(input) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Decodes HTML entities in a given HTML string.\n * @param htmlString The HTML string containing entities to decode.\n * @returns The decoded string with HTML entities converted back to their original characters.\n */\nstd::string replaceHtmlEntities(const std::string& htmlString) {\n    // Function implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Decodes HTML entities in a given HTML string.\n * @param htmlString The HTML string containing entities to decode.\n * @return The decoded string with HTML entities converted back to their original characters.\n */\npublic static String replaceHtmlEntities(String htmlString) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testDecodesStandardHtmlEntities() {\n        String input = \"The &amp; symbol should become an &quot;and&quot; sign.\";\n        String expected = \"The & symbol should become an \\\"and\\\" sign.\";\n        assertEquals(expected, replaceHtmlEntities(input));\n    }\n\n    @Test\n    public void testReturnsEmptyStringForEmptyInput() {\n        String input = \"\";\n        String expected = \"\";\n        assertEquals(expected, replaceHtmlEntities(input));\n    }\n\n    @Test\n    public void testDecodesMultipleDifferentEntitiesInOneString() {\n        String input = \"&lt;div&gt;Hello &amp; Welcome to the &apos;World&apos;!&lt;/div&gt;\";\n        String expected = \"<div>Hello & Welcome to the 'World'!</div>\";\n        assertEquals(expected, replaceHtmlEntities(input));\n    }\n\n    @Test\n    public void testHandlesStringsWithNoEntities() {\n        String input = \"Just a normal string without entities.\";\n        String expected = \"Just a normal string without entities.\";\n        assertEquals(expected, replaceHtmlEntities(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Decodes HTML entities in a given HTML string.\n * @param htmlString The HTML string containing entities to decode.\n * @return The decoded string with HTML entities converted back to their original characters.\n */\npublic static String replaceHtmlEntities(String htmlString) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 93, "code_type": "method", "original_language": "javascript", "question_type": "Algorithm and data structure", "summary": "produces a character array of length 52 containing all lowercase uppercase letters in alphabetical order", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef get_all_alphabets() -> List[str]:\n    \"\"\"\n    Produces a list of length 52 containing all lowercase and uppercase letters in alphabetical order.\n\n    Returns:\n        list[str]: A list of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGetAllAlphabets(unittest.TestCase):\n\n    def test_return_length(self):\n        result = get_all_alphabets()\n        self.assertEqual(len(result), 52)\n\n    def test_lowercase_alphabets(self):\n        result = get_all_alphabets()\n        lowercase_alphabets = result[:26]\n        self.assertEqual(lowercase_alphabets, [\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n        ])\n\n    def test_uppercase_alphabets(self):\n        result = get_all_alphabets()\n        uppercase_alphabets = result[26:]\n        self.assertEqual(uppercase_alphabets, [\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'\n        ])\n\n    def test_first_element(self):\n        result = get_all_alphabets()\n        self.assertEqual(result[0], 'a')\n\n    def test_last_element(self):\n        result = get_all_alphabets()\n        self.assertEqual(result[-1], 'Z')\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef get_all_alphabets() -> List[str]:\n    \"\"\"\n    Produces a list of length 52 containing all lowercase and uppercase letters in alphabetical order.\n\n    Returns:\n        list[str]: A list of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * produces a character array of length 52 containing all lowercase uppercase letters in alphabetical order\n *\n * @returns {string[]} An array of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\nfunction getAllAlphabets(){\n\n}", "test_code": "describe('getAllAlphabets', () => {\n    test('should return an array of 52 characters', () => {\n        const result = getAllAlphabets();\n        expect(result).toHaveLength(52);\n    });\n\n    test('should start with lowercase letters from a to z', () => {\n        const result = getAllAlphabets();\n        const lowercaseAlphabets = result.slice(0, 26);\n        expect(lowercaseAlphabets).toEqual([\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n        ]);\n    });\n\n    test('should end with uppercase letters from A to Z', () => {\n        const result = getAllAlphabets();\n        const uppercaseAlphabets = result.slice(26);\n        expect(uppercaseAlphabets).toEqual([\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'\n        ]);\n    });\n\n    test('should return \"a\" as the first element', () => {\n        const result = getAllAlphabets();\n        expect(result[0]).toBe('a');\n    });\n\n    test('should return \"Z\" as the last element', () => {\n        const result = getAllAlphabets();\n        expect(result[result.length - 1]).toBe('Z');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * produces a character array of length 52 containing all lowercase uppercase letters in alphabetical order\n *\n * @returns {string[]} An array of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\nfunction getAllAlphabets(){\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Produces a character array of length 52 containing all lowercase and uppercase letters in alphabetical order.\n *\n * @returns {string[]} An array of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\nfunction getAllAlphabets(): string[] {\n\n}", "test_code": "describe('getAllAlphabets', () => {\n    test('should return an array of 52 characters', () => {\n        const result: string[] = getAllAlphabets();\n        expect(result).toHaveLength(52);\n    });\n\n    test('should start with lowercase letters from a to z', () => {\n        const result: string[] = getAllAlphabets();\n        const lowercaseAlphabets = result.slice(0, 26);\n        expect(lowercaseAlphabets).toEqual([\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n        ]);\n    });\n\n    test('should end with uppercase letters from A to Z', () => {\n        const result: string[] = getAllAlphabets();\n        const uppercaseAlphabets = result.slice(26);\n        expect(uppercaseAlphabets).toEqual([\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'\n        ]);\n    });\n\n    test('should return \"a\" as the first element', () => {\n        const result: string[] = getAllAlphabets();\n        expect(result[0]).toBe('a');\n    });\n\n    test('should return \"Z\" as the last element', () => {\n        const result: string[] = getAllAlphabets();\n        expect(result[result.length - 1]).toBe('Z');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Produces a character array of length 52 containing all lowercase and uppercase letters in alphabetical order.\n *\n * @returns {string[]} An array of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\nfunction getAllAlphabets(): string[] {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * produces a character array of length 52 containing all lowercase and uppercase letters in alphabetical order\n *\n * @returns std::vector<char> A vector of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\nstd::vector<char> getAllAlphabets() {\n    // Function implementation goes here\n}", "test_code": "TEST_CASE(\"getAllAlphabets\") {\n    SECTION(\"should return a vector of 52 characters\") {\n        auto result = getAllAlphabets();\n        REQUIRE(result.size() == 52);\n    }\n\n    SECTION(\"should start with lowercase letters from a to z\") {\n        auto result = getAllAlphabets();\n        std::vector<char> lowercaseAlphabets(result.begin(), result.begin() + 26);\n        std::vector<char> expected = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n                                       'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};\n        REQUIRE(lowercaseAlphabets == expected);\n    }\n\n    SECTION(\"should end with uppercase letters from A to Z\") {\n        auto result = getAllAlphabets();\n        std::vector<char> uppercaseAlphabets(result.begin() + 26, result.end());\n        std::vector<char> expected = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n                                       'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};\n        REQUIRE(uppercaseAlphabets == expected);\n    }\n\n    SECTION(\"should return 'a' as the first element\") {\n        auto result = getAllAlphabets();\n        REQUIRE(result[0] == 'a');\n    }\n\n    SECTION(\"should return 'Z' as the last element\") {\n        auto result = getAllAlphabets();\n        REQUIRE(result.back() == 'Z');\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * produces a character array of length 52 containing all lowercase and uppercase letters in alphabetical order\n *\n * @returns std::vector<char> A vector of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\nstd::vector<char> getAllAlphabets() {\n    // Function implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Produces a character array of length 52 containing all lowercase and uppercase letters in alphabetical order.\n *\n * @return An array of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\npublic static char[] getAllAlphabets() {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testGetAllAlphabetsLength() {\n        char[] result =getAllAlphabets();\n        assertEquals(52, result.length);\n    }\n\n    @Test\n    public void testGetAllAlphabetsLowercase() {\n        char[] result =getAllAlphabets();\n        char[] lowercaseAlphabets = new char[26];\n        System.arraycopy(result, 0, lowercaseAlphabets, 0, 26);\n\n        char[] expected = {\n                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n                'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n                'u', 'v', 'w', 'x', 'y', 'z'\n        };\n\n        assertArrayEquals(expected, lowercaseAlphabets);\n    }\n\n    @Test\n    public void testGetAllAlphabetsUppercase() {\n        char[] result =getAllAlphabets();\n        char[] uppercaseAlphabets = new char[26];\n        System.arraycopy(result, 26, uppercaseAlphabets, 0, 26);\n\n        char[] expected = {\n                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n                'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n                'U', 'V', 'W', 'X', 'Y', 'Z'\n        };\n\n        assertArrayEquals(expected, uppercaseAlphabets);\n    }\n\n    @Test\n    public void testGetAllAlphabetsFirstElement() {\n        char[] result =getAllAlphabets();\n        assertEquals('a', result[0]);\n    }\n\n    @Test\n    public void testGetAllAlphabetsLastElement() {\n        char[] result =getAllAlphabets();\n        assertEquals('Z', result[result.length - 1]);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Produces a character array of length 52 containing all lowercase and uppercase letters in alphabetical order.\n *\n * @return An array of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\npublic static char[] getAllAlphabets() {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 94, "code_type": "method", "original_language": "javascript", "question_type": "Algorithm and data structure", "summary": "generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef create_circle_of_fifths(starting_note: str) -> List[str]:\n    \"\"\"\n    Generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note.\n\n    Args:\n        starting_note (str): The musical note to start the Circle of Fifths from (e.g., \"C\").\n\n    Returns:\n        List[str]: A list representing the Circle of Fifths.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCreateCircleOfFifths(unittest.TestCase):\n    def test_should_return_12_notes_in_the_circle(self):\n        result = create_circle_of_fifths('C')\n        self.assertEqual(len(result), 12)\n\n    def test_should_start_with_the_given_starting_note(self):\n        starting_note = 'G'\n        result = create_circle_of_fifths(starting_note)\n        self.assertEqual(result[0], starting_note)\n\n    def test_should_correctly_generate_the_circle_of_fifths_starting_from_C(self):\n        result = create_circle_of_fifths('C')\n        expected_circle = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#']\n        self.assertEqual(result, expected_circle)\n\n    def test_should_correctly_generate_the_circle_of_fifths_starting_from_G(self):\n        result = create_circle_of_fifths('G')\n        expected_circle = ['G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#', 'B#']\n        self.assertEqual(result, expected_circle)\n\n    def test_should_correctly_generate_the_circle_of_fifths_starting_from_F(self):\n        result = create_circle_of_fifths('F')\n        expected_circle = ['F', 'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#']\n        self.assertEqual(result, expected_circle)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef create_circle_of_fifths(starting_note: str) -> List[str]:\n    \"\"\"\n    Generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note.\n\n    Args:\n        starting_note (str): The musical note to start the Circle of Fifths from (e.g., \"C\").\n\n    Returns:\n        List[str]: A list representing the Circle of Fifths.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note\n *\n * @param {string} startingNote - The musical note to start the Circle of Fifths from (e.g., \"C\").\n * @returns {string[]} An array representing the Circle of Fifths.\n */\nfunction createCircleOfFifths(startingNote) {\n\n}", "test_code": "describe('createCircleOfFifths', () => {\n    test('should return 12 notes in the circle', () => {\n        const result = createCircleOfFifths('C');\n        expect(result).toHaveLength(12);\n    });\n\n    test('should start with the given starting note', () => {\n        const startingNote = 'G';\n        const result = createCircleOfFifths(startingNote);\n        expect(result[0]).toBe(startingNote);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from C', () => {\n        const result = createCircleOfFifths('C');\n        const expectedCircle = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#'];\n        expect(result).toEqual(expectedCircle);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from G', () => {\n        const result = createCircleOfFifths('G');\n        const expectedCircle = ['G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#', 'B#'];\n        expect(result).toEqual(expectedCircle);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from F', () => {\n        const result = createCircleOfFifths('F');\n        const expectedCircle = ['F', 'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#'];\n        expect(result).toEqual(expectedCircle);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note\n *\n * @param {string} startingNote - The musical note to start the Circle of Fifths from (e.g., \"C\").\n * @returns {string[]} An array representing the Circle of Fifths.\n */\nfunction createCircleOfFifths(startingNote) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note.\n *\n * @param {string} startingNote - The musical note to start the Circle of Fifths from (e.g., \"C\").\n * @returns {string[]} An array representing the Circle of Fifths.\n */\nfunction createCircleOfFifths(startingNote: string): string[] {\n\n}", "test_code": "describe('createCircleOfFifths', () => {\n    test('should return 12 notes in the circle', () => {\n        const result: string[] = createCircleOfFifths('C');\n        expect(result).toHaveLength(12);\n    });\n\n    test('should start with the given starting note', () => {\n        const startingNote: string = 'G';\n        const result: string[] = createCircleOfFifths(startingNote);\n        expect(result[0]).toBe(startingNote);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from C', () => {\n        const result: string[] = createCircleOfFifths('C');\n        const expectedCircle: string[] = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#'];\n        expect(result).toEqual(expectedCircle);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from G', () => {\n        const result: string[] = createCircleOfFifths('G');\n        const expectedCircle: string[] = ['G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#', 'B#'];\n        expect(result).toEqual(expectedCircle);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from F', () => {\n        const result: string[] = createCircleOfFifths('F');\n        const expectedCircle: string[] = ['F', 'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#'];\n        expect(result).toEqual(expectedCircle);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note.\n *\n * @param {string} startingNote - The musical note to start the Circle of Fifths from (e.g., \"C\").\n * @returns {string[]} An array representing the Circle of Fifths.\n */\nfunction createCircleOfFifths(startingNote: string): string[] {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 95, "code_type": "method", "original_language": "javascript", "question_type": "Algorithm and data structure", "summary": "finds the matching elements and their indices in the input array according to the specified comparison function", "language_version_list": {"python": {"code_signature": "from typing import List, Any, Callable, Dict\n\n\ndef find_matching_elements(arr: List[Any], comparison_fn: Callable[[Any], bool]) -> List[Dict[str, Any]]:\n    \"\"\"\n    Finds matching elements and their indices in the input array\n    based on the specified comparison function.\n    Args:\n        arr (str): The input array to search through.\n        comparison_fn (): The comparison function to determine matches.\n\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries, each containing the matched element and its index.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFindMatchingElements(unittest.TestCase):\n\n    def test_empty_input_array(self):\n        result = find_matching_elements([], lambda el: el > 0)\n        self.assertEqual(result, [])\n\n    def test_matching_elements_and_indices(self):\n        input_array = [1, 2, 3, 4, 5]\n        comparison_function = lambda num: num > 3\n        result = find_matching_elements(input_array, comparison_function)\n        self.assertEqual(result, [\n            {'element': 4, 'index': 3},\n            {'element': 5, 'index': 4},\n        ])\n\n    def test_string_matching_condition(self):\n        input_array = ['apple', 'banana', 'cherry', 'date']\n        comparison_function = lambda fruit: fruit.startswith('b')\n        result = find_matching_elements(input_array, comparison_function)\n        self.assertEqual(result, [\n            {'element': 'banana', 'index': 1},\n        ])\n\n    def test_multiple_elements_with_same_value(self):\n        input_array = [1, 2, 2, 3, 2, 4]\n        comparison_function = lambda num: num == 2\n        result = find_matching_elements(input_array, comparison_function)\n        self.assertEqual(result, [\n            {'element': 2, 'index': 1},\n            {'element': 2, 'index': 2},\n            {'element': 2, 'index': 4},\n        ])\n\n    def test_matching_objects_based_on_property(self):\n        input_array = [\n            {'name': 'Alice', 'age': 25},\n            {'name': 'Bob', 'age': 30},\n            {'name': 'Charlie', 'age': 30},\n        ]\n        comparison_function = lambda person: person['age'] == 30\n        result = find_matching_elements(input_array, comparison_function)\n        self.assertEqual(result, [\n            {'element': {'name': 'Bob', 'age': 30}, 'index': 1},\n            {'element': {'name': 'Charlie', 'age': 30}, 'index': 2},\n        ])\n\n    def test_no_elements_if_no_matches_found(self):\n        input_array = [1, 3, 5, 7]\n        comparison_function = lambda num: num % 2 == 0  # looking for even numbers\n        result = find_matching_elements(input_array, comparison_function)\n        self.assertEqual(result, [])\n\n    def test_negative_numbers_condition(self):\n        input_array = [-1, -2, 0, 1, 2]\n        comparison_function = lambda num: num < 0\n        result = find_matching_elements(input_array, comparison_function)\n        self.assertEqual(result, [\n            {'element': -1, 'index': 0},\n            {'element': -2, 'index': 1},\n        ])\n", "prompt": "please write a python function , the function signature as below from typing import List, Any, Callable, Dict\n\n\ndef find_matching_elements(arr: List[Any], comparison_fn: Callable[[Any], bool]) -> List[Dict[str, Any]]:\n    \"\"\"\n    Finds matching elements and their indices in the input array\n    based on the specified comparison function.\n    Args:\n        arr (str): The input array to search through.\n        comparison_fn (): The comparison function to determine matches.\n\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries, each containing the matched element and its index.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Finds matching elements and their indices in the input array\n * based on the specified comparison function.\n *\n * @param {Array} arr - The input array to search through.\n * @param {Function} comparisonFn - The comparison function to determine matches.\n * @returns {Array} - An array of objects, each containing the matched element and its index.\n */\nfunction findMatchingElements(arr, comparisonFn) {\n}", "test_code": "describe('findMatchingElements', () => {\n    test('should return an empty array for an empty input array', () => {\n        const result = findMatchingElements([], (el) => el > 0);\n        expect(result).toEqual([]);\n    });\n\n    test('should return matching elements and their indices', () => {\n        const inputArray = [1, 2, 3, 4, 5];\n        const comparisonFunction = (num) => num > 3;\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            {element: 4, index: 3},\n            {element: 5, index: 4},\n        ]);\n    });\n\n    test('should return elements that are strings matching a specific condition', () => {\n        const inputArray = ['apple', 'banana', 'cherry', 'date'];\n        const comparisonFunction = (fruit) => fruit.startsWith('b');\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            {element: 'banana', index: 1},\n        ]);\n    });\n\n    test('should return multiple elements with the same value', () => {\n        const inputArray = [1, 2, 2, 3, 2, 4];\n        const comparisonFunction = (num) => num === 2;\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            {element: 2, index: 1},\n            {element: 2, index: 2},\n            {element: 2, index: 4},\n        ]);\n    });\n\n    test('should return matching objects based on a property', () => {\n        const inputArray = [\n            {name: 'Alice', age: 25},\n            {name: 'Bob', age: 30},\n            {name: 'Charlie', age: 30},\n        ];\n        const comparisonFunction = (person) => person.age === 30;\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            {element: {name: 'Bob', age: 30}, index: 1},\n            {element: {name: 'Charlie', age: 30}, index: 2},\n        ]);\n    });\n\n    test('should return no elements if no matches found', () => {\n        const inputArray = [1, 3, 5, 7];\n        const comparisonFunction = (num) => num % 2 === 0; // looking for even numbers\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([]);\n    });\n\n    test('should work with a comparison function that checks for negative numbers', () => {\n        const inputArray = [-1, -2, 0, 1, 2];\n        const comparisonFunction = (num) => num < 0;\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            {element: -1, index: 0},\n            {element: -2, index: 1},\n        ]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Finds matching elements and their indices in the input array\n * based on the specified comparison function.\n *\n * @param {Array} arr - The input array to search through.\n * @param {Function} comparisonFn - The comparison function to determine matches.\n * @returns {Array} - An array of objects, each containing the matched element and its index.\n */\nfunction findMatchingElements(arr, comparisonFn) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Finds matching elements and their indices in the input array\n * based on the specified comparison function.\n *\n * @param {Array<T>} arr - The input array to search through.\n * @param {(element: T) => boolean} comparisonFn - The comparison function to determine matches.\n * @returns {Array<{ element: T; index: number }>} - An array of objects, each containing the matched element and its index.\n */\nfunction findMatchingElements<T>(arr: T[], comparisonFn: (element: T) => boolean): Array<{ element: T; index: number }> {\n}", "test_code": "describe('findMatchingElements', () => {\n    test('should return an empty array for an empty input array', () => {\n        const result = findMatchingElements<number>([], (el) => el > 0);\n        expect(result).toEqual([]);\n    });\n\n    test('should return matching elements and their indices', () => {\n        const inputArray: number[] = [1, 2, 3, 4, 5];\n        const comparisonFunction = (num: number) => num > 3;\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            { element: 4, index: 3 },\n            { element: 5, index: 4 },\n        ]);\n    });\n\n    test('should return elements that are strings matching a specific condition', () => {\n        const inputArray: string[] = ['apple', 'banana', 'cherry', 'date'];\n        const comparisonFunction = (fruit: string) => fruit.startsWith('b');\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            { element: 'banana', index: 1 },\n        ]);\n    });\n\n    test('should return multiple elements with the same value', () => {\n        const inputArray: number[] = [1, 2, 2, 3, 2, 4];\n        const comparisonFunction = (num: number) => num === 2;\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            { element: 2, index: 1 },\n            { element: 2, index: 2 },\n            { element: 2, index: 4 },\n        ]);\n    });\n\n    test('should return matching objects based on a property', () => {\n        const inputArray: { name: string; age: number }[] = [\n            { name: 'Alice', age: 25 },\n            { name: 'Bob', age: 30 },\n            { name: 'Charlie', age: 30 },\n        ];\n        const comparisonFunction = (person: { name: string; age: number }) => person.age === 30;\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            { element: { name: 'Bob', age: 30 }, index: 1 },\n            { element: { name: 'Charlie', age: 30 }, index: 2 },\n        ]);\n    });\n\n    test('should return no elements if no matches found', () => {\n        const inputArray: number[] = [1, 3, 5, 7];\n        const comparisonFunction = (num: number) => num % 2 === 0; // looking for even numbers\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([]);\n    });\n\n    test('should work with a comparison function that checks for negative numbers', () => {\n        const inputArray: number[] = [-1, -2, 0, 1, 2];\n        const comparisonFunction = (num: number) => num < 0;\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            { element: -1, index: 0 },\n            { element: -2, index: 1 },\n        ]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Finds matching elements and their indices in the input array\n * based on the specified comparison function.\n *\n * @param {Array<T>} arr - The input array to search through.\n * @param {(element: T) => boolean} comparisonFn - The comparison function to determine matches.\n * @returns {Array<{ element: T; index: number }>} - An array of objects, each containing the matched element and its index.\n */\nfunction findMatchingElements<T>(arr: T[], comparisonFn: (element: T) => boolean): Array<{ element: T; index: number }> {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Finds matching elements and their indices in the input array\n * based on the specified comparison function.\n *\n * @param arr - The input array to search through.\n * @param comparisonFn - The comparison function to determine matches.\n * @returns A vector of Match structs, each containing the matched element and its index.\n */\nstd::vector<Match> findMatchingElements(const std::vector<int>& arr, std::function<bool(int)> comparisonFn) {\n}", "test_code": "TEST_CASE(\"findMatchingElements\") {\n    \n    SECTION(\"should return an empty array for an empty input array\") {\n        auto result = findMatchingElements({}, [](const std::string&) { return false; });\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"should return matching elements and their indices\") {\n        std::vector<int> inputArray = {1, 2, 3, 4, 5};\n        auto comparisonFunction = [](int num) { return num > 3; };\n        auto result = findMatchingElements(inputArray, comparisonFunction);\n        REQUIRE(result == std::vector<Match>{{4, 3}, {5, 4}});\n    }\n\n    SECTION(\"should return elements that are strings matching a specific condition\") {\n        std::vector<std::string> inputArray = {\"apple\", \"banana\", \"cherry\", \"date\"};\n        auto comparisonFunction = [](const std::string& fruit) { return fruit.starts_with('b'); };\n        auto result = findMatchingElements(inputArray, comparisonFunction);\n        REQUIRE(result == std::vector<Match>{{\"banana\", 1}});\n    }\n\n    SECTION(\"should return multiple elements with the same value\") {\n        std::vector<int> inputArray = {1, 2, 2, 3, 2, 4};\n        auto comparisonFunction = [](int num) { return num == 2; };\n        auto result = findMatchingElements(inputArray, comparisonFunction);\n        REQUIRE(result == std::vector<Match>{{2, 1}, {2, 2}, {2, 4}});\n    }\n\n    SECTION(\"should return matching objects based on a property\") {\n        std::vector<std::map<std::string, int>> inputArray = {\n            {\"name\", 25},\n            {\"name\", 30},\n            {\"name\", 30},\n        };\n        auto comparisonFunction = [](const auto& person) { return person.at(\"age\") == 30; };\n        auto result = findMatchingElements(inputArray, comparisonFunction);\n        REQUIRE(result == std::vector<Match>{{{\"Bob\", 30}, 1}, {{\"Charlie\", 30}, 2}});\n    }\n\n    SECTION(\"should return no elements if no matches found\") {\n        std::vector<int> inputArray = {1, 3, 5, 7};\n        auto comparisonFunction = [](int num) { return num % 2 == 0; }; // looking for even numbers\n        auto result = findMatchingElements(inputArray, comparisonFunction);\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"should work with a comparison function that checks for negative numbers\") {\n        std::vector<int> inputArray = {-1, -2, 0, 1, 2};\n        auto comparisonFunction = [](int num) { return num < 0; };\n        auto result = findMatchingElements(inputArray, comparisonFunction);\n        REQUIRE(result == std::vector<Match>{{-1, 0}, {-2, 1}});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Finds matching elements and their indices in the input array\n * based on the specified comparison function.\n *\n * @param arr - The input array to search through.\n * @param comparisonFn - The comparison function to determine matches.\n * @returns A vector of Match structs, each containing the matched element and its index.\n */\nstd::vector<Match> findMatchingElements(const std::vector<int>& arr, std::function<bool(int)> comparisonFn) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds matching elements and their indices in the input array\n * based on the specified comparison function.\n *\n * @param arr - The input array to search through.\n * @param comparisonFn - The comparison function to determine matches.\n * @return - A list of objects, each containing the matched element and its index.\n */\npublic static class MatchResult {\n    private Object element;\n    private int index;\n\n    public MatchResult(Object element, int index) {\n        this.element = element;\n        this.index = index;\n    }\n\n    public Object getElement() {\n        return element;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n}\npublic static List<MatchResult> findMatchingElements(Object[] arr, Predicate<Object> comparisonFn) {\n    \n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.List;\nimport java.util.function.Predicate;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.findMatchingElements;\n\npublic class Tester {\n\n    @Test\n    public void testEmptyArray() {\n        List<Answer.MatchResult> result = findMatchingElements(new Object[]{}, el -> false);\n        assertEquals(0, result.size());\n    }\n\n    @Test\n    public void testMatchingElementsAndIndices() {\n        Object[] inputArray = {1, 2, 3, 4, 5};\n        Predicate<Object> comparisonFunction = num -> (Integer) num > 3;\n        List<Answer.MatchResult> result = findMatchingElements(inputArray, comparisonFunction);\n        assertEquals(2, result.size());\n        assertEquals(4, result.get(0).getElement());\n        assertEquals(3, result.get(0).getIndex());\n        assertEquals(5, result.get(1).getElement());\n        assertEquals(4, result.get(1).getIndex());\n    }\n\n    @Test\n    public void testStringMatchingCondition() {\n        Object[] inputArray = {\"apple\", \"banana\", \"cherry\", \"date\"};\n        Predicate<Object> comparisonFunction = fruit -> ((String) fruit).startsWith(\"b\");\n        List<Answer.MatchResult> result = findMatchingElements(inputArray, comparisonFunction);\n        assertEquals(1, result.size());\n        assertEquals(\"banana\", result.get(0).getElement());\n        assertEquals(1, result.get(0).getIndex());\n    }\n\n    @Test\n    public void testMultipleElementsWithSameValue() {\n        Object[] inputArray = {1, 2, 2, 3, 2, 4};\n        Predicate<Object> comparisonFunction = num -> (Integer) num == 2;\n        List<Answer.MatchResult> result = findMatchingElements(inputArray, comparisonFunction);\n        assertEquals(3, result.size());\n        assertEquals(2, result.get(0).getElement());\n        assertEquals(1, result.get(0).getIndex());\n        assertEquals(2, result.get(1).getElement());\n        assertEquals(2, result.get(1).getIndex());\n        assertEquals(2, result.get(2).getElement());\n        assertEquals(4, result.get(2).getIndex());\n    }\n\n    @Test\n    public void testMatchingObjectsByProperty() {\n        Object[] inputArray = {\n                new Person(\"Alice\", 25),\n                new Person(\"Bob\", 30),\n                new Person(\"Charlie\", 30)\n        };\n        Predicate<Object> comparisonFunction = person -> ((Person) person).getAge() == 30;\n        List<Answer.MatchResult> result = findMatchingElements(inputArray, comparisonFunction);\n        assertEquals(2, result.size());\n        assertEquals(\"Bob\", ((Person) result.get(0).getElement()).getName());\n        assertEquals(1, result.get(0).getIndex());\n        assertEquals(\"Charlie\", ((Person) result.get(1).getElement()).getName());\n        assertEquals(2, result.get(1).getIndex());\n    }\n\n    @Test\n    public void testNoMatchesFound() {\n        Object[] inputArray = {1, 3, 5, 7};\n        Predicate<Object> comparisonFunction = num -> (Integer) num % 2 == 0;\n        List<Answer.MatchResult> result = findMatchingElements(inputArray, comparisonFunction);\n        assertEquals(0, result.size());\n    }\n\n    @Test\n    public void testNegativeNumbers() {\n        Object[] inputArray = {-1, -2, 0, 1, 2};\n        Predicate<Object> comparisonFunction = num -> (Integer) num < 0;\n        List<Answer.MatchResult> result = findMatchingElements(inputArray, comparisonFunction);\n        assertEquals(2, result.size());\n        assertEquals(-1, result.get(0).getElement());\n        assertEquals(0, result.get(0).getIndex());\n        assertEquals(-2, result.get(1).getElement());\n        assertEquals(1, result.get(1).getIndex());\n    }\n\n    // Simple Person class for testing\n    public static class Person {\n        private String name;\n        private int age;\n\n        public Person(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public int getAge() {\n            return age;\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds matching elements and their indices in the input array\n * based on the specified comparison function.\n *\n * @param arr - The input array to search through.\n * @param comparisonFn - The comparison function to determine matches.\n * @return - A list of objects, each containing the matched element and its index.\n */\npublic static class MatchResult {\n    private Object element;\n    private int index;\n\n    public MatchResult(Object element, int index) {\n        this.element = element;\n        this.index = index;\n    }\n\n    public Object getElement() {\n        return element;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n}\npublic static List<MatchResult> findMatchingElements(Object[] arr, Predicate<Object> comparisonFn) {\n    \n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 96, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K:), or \"bass\" if no clef is specified", "language_version_list": {"python": {"code_signature": "def insert_clef(abc: str, clef: str = \"bass\") -> str:\n    \"\"\"\n    Modify the ABC string by inserting the specified clef (e.g., \"clef=bass\")\n    after the tone line (K:), or \"bass\" if no clef is specified.\n\n    Args:\n        abc (str): The ABC notation string.\n        clef (str): The clef to set (default is \"bass\").\n\n    Returns:\n        str: The updated ABC notation string with the new clef.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestChangedClef(unittest.TestCase):\n\n    def test_default_clef_insertion(self):\n        abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\"\n        result = insert_clef(abc)\n        expected = \"X:1\\nT:Test Tune\\nK:C clef=bass\\nC D E F|G A B c|\\n\"\n        self.assertEqual(result, expected)\n\n    def test_specific_clef_insertion(self):\n        abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\"\n        result = insert_clef(abc, \"treble\")\n        expected = \"X:1\\nT:Test Tune\\nK:C clef=treble\\nC D E F|G A B c|\\n\"\n        self.assertEqual(result, expected)\n\n    def test_no_newline_after_key_signature(self):\n        abc = \"X:1\\nT:Test Tune\\nK:C\"\n        result = insert_clef(abc, \"alto\")\n        expected = \"X:1\\nT:Test Tune\\nK:C clef=alto\"\n        self.assertEqual(result, expected)\n\n    def test_no_key_signature_found(self):\n        abc = \"X:1\\nT:Test Tune\\nC D E F|G A B c|\\n\"\n        result = insert_clef(abc, \"tenor\")\n        self.assertEqual(result, abc)  # Expect the original string to be returned unchanged\n\n    def test_multiple_key_signatures(self):\n        abc = \"X:1\\nT:Test Tune\\nK:G\\nG A B c|\\nK:D\\nD E F# G|\\n\"\n        result = insert_clef(abc, \"baritone\")\n        expected = \"X:1\\nT:Test Tune\\nK:G clef=baritone\\nG A B c|\\nK:D\\nD E F# G|\\n\"\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def insert_clef(abc: str, clef: str = \"bass\") -> str:\n    \"\"\"\n    Modify the ABC string by inserting the specified clef (e.g., \"clef=bass\")\n    after the tone line (K:), or \"bass\" if no clef is specified.\n\n    Args:\n        abc (str): The ABC notation string.\n        clef (str): The clef to set (default is \"bass\").\n\n    Returns:\n        str: The updated ABC notation string with the new clef.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K: ), or \"bass\" if no clef is specified.\n *\n * @param {string} abc - The ABC notation string.\n * @param {string} [clef=\"bass\"] - The clef to set (default is \"bass\").\n * @returns {string} - The updated ABC notation string with the new clef.\n */\nfunction changedClef(abc, clef = \"bass\") {\n\n}", "test_code": "describe('changedClef', () => {\n    test('should insert the clef at the correct position when the clef is not specified (default to \"bass\")', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc);\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=bass\\nC D E F|G A B c|\\n\";\n        expect(result).toBe(expected);\n    });\n\n    test('should insert the clef at the correct position when a specific clef is provided', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc, \"treble\");\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=treble\\nC D E F|G A B c|\\n\";\n        expect(result).toBe(expected);\n    });\n\n    test('should handle cases where there is no newline after the key signature.js.py.py.py', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\";\n        const result = changedClef(abc, \"alto\");\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=alto\";\n        expect(result).toBe(expected);\n    });\n\n    test('should not alter the ABC notation if the key signature.js.py.py.py is not found', () => {\n        const abc = \"X:1\\nT:Test Tune\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc, \"tenor\");\n        expect(result).toBe(abc); // Expect the original string to be returned unchanged\n    });\n\n    test('should correctly handle ABC notation with multiple key signatures', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:G\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        const result = changedClef(abc, \"baritone\");\n        const expected = \"X:1\\nT:Test Tune\\nK:G clef=baritone\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        expect(result).toBe(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K: ), or \"bass\" if no clef is specified.\n *\n * @param {string} abc - The ABC notation string.\n * @param {string} [clef=\"bass\"] - The clef to set (default is \"bass\").\n * @returns {string} - The updated ABC notation string with the new clef.\n */\nfunction changedClef(abc, clef = \"bass\") {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") \n * after the tone line (K: ), or \"bass\" if no clef is specified.\n *\n * @param {string} abc - The ABC notation string.\n * @param {string} [clef=\"bass\"] - The clef to set (default is \"bass\").\n * @returns {string} - The updated ABC notation string with the new clef.\n */\nfunction changedClef(abc: string, clef: string = \"bass\"): string {\n\n}", "test_code": "describe('changedClef', () => {\n    test('should insert the clef at the correct position when the clef is not specified (default to \"bass\")', () => {\n        const abc: string = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        const result: string = changedClef(abc);\n        const expected: string = \"X:1\\nT:Test Tune\\nK:C clef=bass\\nC D E F|G A B c|\\n\";\n        expect(result).toBe(expected);\n    });\n\n    test('should insert the clef at the correct position when a specific clef is provided', () => {\n        const abc: string = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        const result: string = changedClef(abc, \"treble\");\n        const expected: string = \"X:1\\nT:Test Tune\\nK:C clef=treble\\nC D E F|G A B c|\\n\";\n        expect(result).toBe(expected);\n    });\n\n    test('should handle cases where there is no newline after the key signature', () => {\n        const abc: string = \"X:1\\nT:Test Tune\\nK:C\";\n        const result: string = changedClef(abc, \"alto\");\n        const expected: string = \"X:1\\nT:Test Tune\\nK:C clef=alto\";\n        expect(result).toBe(expected);\n    });\n\n    test('should not alter the ABC notation if the key signature is not found', () => {\n        const abc: string = \"X:1\\nT:Test Tune\\nC D E F|G A B c|\\n\";\n        const result: string = changedClef(abc, \"tenor\");\n        expect(result).toBe(abc); // Expect the original string to be returned unchanged\n    });\n\n    test('should correctly handle ABC notation with multiple key signatures', () => {\n        const abc: string = \"X:1\\nT:Test Tune\\nK:G\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        const result: string = changedClef(abc, \"baritone\");\n        const expected: string = \"X:1\\nT:Test Tune\\nK:G clef=baritone\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        expect(result).toBe(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") \n * after the tone line (K: ), or \"bass\" if no clef is specified.\n *\n * @param {string} abc - The ABC notation string.\n * @param {string} [clef=\"bass\"] - The clef to set (default is \"bass\").\n * @returns {string} - The updated ABC notation string with the new clef.\n */\nfunction changedClef(abc: string, clef: string = \"bass\"): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K:), \n * or \"bass\" if no clef is specified.\n *\n * @param abc - The ABC notation string.\n * @param clef - The clef to set (default is \"bass\").\n * @returns - The updated ABC notation string with the new clef.\n */\nstd::string changedClef(const std::string& abc, const std::string& clef = \"bass\");", "test_code": "TEST_CASE(\"changedClef\", \"[changedClef]\") {\n    SECTION(\"should insert the clef at the correct position when the clef is not specified (default to 'bass')\") {\n        std::string abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        std::string result = changedClef(abc);\n        std::string expected = \"X:1\\nT:Test Tune\\nK:C clef=bass\\nC D E F|G A B c|\\n\";\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"should insert the clef at the correct position when a specific clef is provided\") {\n        std::string abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        std::string result = changedClef(abc, \"treble\");\n        std::string expected = \"X:1\\nT:Test Tune\\nK:C clef=treble\\nC D E F|G A B c|\\n\";\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"should handle cases where there is no newline after the key signature\") {\n        std::string abc = \"X:1\\nT:Test Tune\\nK:C\";\n        std::string result = changedClef(abc, \"alto\");\n        std::string expected = \"X:1\\nT:Test Tune\\nK:C clef=alto\";\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"should not alter the ABC notation if the key signature is not found\") {\n        std::string abc = \"X:1\\nT:Test Tune\\nC D E F|G A B c|\\n\";\n        std::string result = changedClef(abc, \"tenor\");\n        REQUIRE(result == abc); // Expect the original string to be returned unchanged\n    }\n\n    SECTION(\"should correctly handle ABC notation with multiple key signatures\") {\n        std::string abc = \"X:1\\nT:Test Tune\\nK:G\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        std::string result = changedClef(abc, \"baritone\");\n        std::string expected = \"X:1\\nT:Test Tune\\nK:G clef=baritone\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K:), \n * or \"bass\" if no clef is specified.\n *\n * @param abc - The ABC notation string.\n * @param clef - The clef to set (default is \"bass\").\n * @returns - The updated ABC notation string with the new clef.\n */\nstd::string changedClef(const std::string& abc, const std::string& clef = \"bass\");", "addition_info": ""}, "java": {"code_signature": "/**\n * Modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") \n * after the tone line (K:), or \"bass\" if no clef is specified.\n *\n * @param abc   The ABC notation string.\n * @param clef  The clef to set (default is \"bass\").\n * @return      The updated ABC notation string with the new clef.\n */\npublic static String changedClef(String abc, String clef) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testInsertClefDefault() {\n        String abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        String result = changedClef(abc, null);\n        String expected = \"X:1\\nT:Test Tune\\nK:C clef=bass\\nC D E F|G A B c|\\n\";\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testInsertClefSpecific() {\n        String abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        String result = changedClef(abc, \"treble\");\n        String expected = \"X:1\\nT:Test Tune\\nK:C clef=treble\\nC D E F|G A B c|\\n\";\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testNoNewlineAfterKeySignature() {\n        String abc = \"X:1\\nT:Test Tune\\nK:C\";\n        String result = changedClef(abc, \"alto\");\n        String expected = \"X:1\\nT:Test Tune\\nK:C clef=alto\";\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testNoKeySignatureFound() {\n        String abc = \"X:1\\nT:Test Tune\\nC D E F|G A B c|\\n\";\n        String result = changedClef(abc, \"tenor\");\n        assertEquals(abc, result); // Expect the original string to be returned unchanged\n    }\n\n    @Test\n    public void testMultipleKeySignatures() {\n        String abc = \"X:1\\nT:Test Tune\\nK:G\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        String result = changedClef(abc, \"baritone\");\n        String expected = \"X:1\\nT:Test Tune\\nK:G clef=baritone\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") \n * after the tone line (K:), or \"bass\" if no clef is specified.\n *\n * @param abc   The ABC notation string.\n * @param clef  The clef to set (default is \"bass\").\n * @return      The updated ABC notation string with the new clef.\n */\npublic static String changedClef(String abc, String clef) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 97, "code_type": "class", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "realize the basic functions of the data structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements", "language_version_list": {"python": {"code_signature": "class Queue:\n    def __init__(self):\n        \"\"\"Initialize an empty queue.\"\"\"\n        self.items = []\n\n    def enqueue(self, element):\n        \"\"\"Adds an element to the end of the queue.\n\n        Args:\n            element: The element to be added to the queue.\n        \"\"\"\n\n    def dequeue(self):\n        \"\"\"Removes and returns the element from the front of the queue.\n\n        Returns:\n            The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n        \"\"\"\n\n    def front(self):\n        \"\"\"Returns the front element of the queue without removing it.\n\n        Returns:\n            The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n        \"\"\"\n\n    def is_empty(self):\n        \"\"\"Checks if the queue is empty.\n\n        Returns:\n            True if the queue is empty, otherwise False.\n        \"\"\"\n        return len(self.items) == 0\n\n    def print_queue(self):\n        \"\"\"Returns a string representation of all the elements in the queue.\n\n        Returns:\n            A string containing all elements in the queue, separated by spaces.\n        \"\"\"", "test_code": "import unittest\n\n\nclass TestQueue(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Initialize an empty queue before each test.\"\"\"\n        self.queue = Queue()\n\n    def test_initialize_empty_queue(self):\n        \"\"\"Test if the queue is initialized empty.\"\"\"\n        self.assertTrue(self.queue.is_empty())\n\n    def test_enqueue_elements(self):\n        \"\"\"Test enqueueing elements into the queue.\"\"\"\n        self.queue.enqueue(1)\n        self.queue.enqueue(2)\n        self.queue.enqueue(3)\n        self.assertFalse(self.queue.is_empty())\n\n    def test_dequeue_elements(self):\n        \"\"\"Test dequeueing elements from the queue.\"\"\"\n        self.queue.enqueue(1)\n        self.queue.enqueue(2)\n        dequeued_element = self.queue.dequeue()\n        self.assertEqual(dequeued_element, 1)\n\n    def test_front_element(self):\n        \"\"\"Test getting the front element without removing it.\"\"\"\n        self.queue.enqueue(10)\n        self.queue.enqueue(20)\n        front_element = self.queue.front()\n        self.assertEqual(front_element, 10)\n\n    def test_check_empty_queue(self):\n        \"\"\"Test checking if the queue is empty.\"\"\"\n        self.assertTrue(self.queue.is_empty())\n        self.queue.enqueue(5)\n        self.assertFalse(self.queue.is_empty())\n        self.queue.dequeue()\n        self.assertTrue(self.queue.is_empty())\n", "prompt": "please write a python class , the class signature as below class Queue:\n    def __init__(self):\n        \"\"\"Initialize an empty queue.\"\"\"\n        self.items = []\n\n    def enqueue(self, element):\n        \"\"\"Adds an element to the end of the queue.\n\n        Args:\n            element: The element to be added to the queue.\n        \"\"\"\n\n    def dequeue(self):\n        \"\"\"Removes and returns the element from the front of the queue.\n\n        Returns:\n            The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n        \"\"\"\n\n    def front(self):\n        \"\"\"Returns the front element of the queue without removing it.\n\n        Returns:\n            The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n        \"\"\"\n\n    def is_empty(self):\n        \"\"\"Checks if the queue is empty.\n\n        Returns:\n            True if the queue is empty, otherwise False.\n        \"\"\"\n        return len(self.items) == 0\n\n    def print_queue(self):\n        \"\"\"Returns a string representation of all the elements in the queue.\n\n        Returns:\n            A string containing all elements in the queue, separated by spaces.\n        \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * realize the basic functions of the question structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements\n */\nclass Queue {\n    constructor() {\n        this.items = [];\n    }\n\n    /**\n     * Adds an element to the end of the queue.\n     * @param {*} element - The element to be added to the queue.\n     */\n    enqueue(element) {\n    }\n\n    /**\n     * Removes and returns the element from the front of the queue.\n     * @returns {*} The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n     */\n    dequeue() {\n    }\n\n    /**\n     * Returns the front element of the queue without removing it.\n     * @returns {*} The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n     */\n    front() {\n    }\n\n    /**\n     * Checks if the queue is empty.\n     * @returns {boolean} True if the queue is empty, otherwise false.\n     */\n    isEmpty() {\n    }\n\n\n    /**\n     * Returns a string representation of all the elements in the queue.\n     * @returns {string} A string containing all elements in the queue, separated by spaces.\n     */\n    printQueue() {\n    }\n}", "test_code": "describe('Queue Class', () => {\n    let queue;\n\n    beforeEach(() => {\n        queue = new Queue();\n    });\n\n    test('should initialize an empty queue', () => {\n        expect(queue.isEmpty()).toBe(true);\n    });\n\n    test('should enqueue elements to the queue', () => {\n        queue.enqueue(1);\n        queue.enqueue(2);\n        queue.enqueue(3);\n        expect(queue.printQueue()).toBe('1 2 3');\n        expect(queue.isEmpty()).toBe(false);\n    });\n\n    test('should dequeue elements from the queue', () => {\n        queue.enqueue(1);\n        queue.enqueue(2);\n        const dequeuedElement = queue.dequeue();\n        expect(dequeuedElement).toBe(1);\n    });\n\n\n    test('should return the front element without removing it', () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        const frontElement = queue.front();\n        expect(frontElement).toBe(10);\n    });\n\n    test('should check if the queue is empty', () => {\n        expect(queue.isEmpty()).toBe(true);\n        queue.enqueue(5);\n        expect(queue.isEmpty()).toBe(false);\n        queue.dequeue();\n        expect(queue.isEmpty()).toBe(true);\n    });\n});", "prompt": "please write a javascript class , the class signature as below /**\n * realize the basic functions of the question structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements\n */\nclass Queue {\n    constructor() {\n        this.items = [];\n    }\n\n    /**\n     * Adds an element to the end of the queue.\n     * @param {*} element - The element to be added to the queue.\n     */\n    enqueue(element) {\n    }\n\n    /**\n     * Removes and returns the element from the front of the queue.\n     * @returns {*} The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n     */\n    dequeue() {\n    }\n\n    /**\n     * Returns the front element of the queue without removing it.\n     * @returns {*} The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n     */\n    front() {\n    }\n\n    /**\n     * Checks if the queue is empty.\n     * @returns {boolean} True if the queue is empty, otherwise false.\n     */\n    isEmpty() {\n    }\n\n\n    /**\n     * Returns a string representation of all the elements in the queue.\n     * @returns {string} A string containing all elements in the queue, separated by spaces.\n     */\n    printQueue() {\n    }\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * realize the basic functions of the question structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements\n */\nclass Queue<T> {\n    private items: T[];\n\n    constructor() {\n        this.items = [];\n    }\n\n    /**\n     * Adds an element to the end of the queue.\n     * @param element - The element to be added to the queue.\n     */\n    enqueue(element: T): void {\n    }\n\n    /**\n     * Removes and returns the element from the front of the queue.\n     * @returns The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n     */\n    dequeue(): T | string {\n    }\n\n    /**\n     * Returns the front element of the queue without removing it.\n     * @returns The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n     */\n    front(): T | string {\n    }\n\n    /**\n     * Checks if the queue is empty.\n     * @returns True if the queue is empty, otherwise false.\n     */\n    isEmpty(): boolean {\n    }\n\n    /**\n     * Returns a string representation of all the elements in the queue.\n     * @returns A string containing all elements in the queue, separated by spaces.\n     */\n    printQueue(): string {\n    }\n}", "test_code": "describe('Queue Class', () => {\n    let queue: Queue<number>;\n\n    beforeEach(() => {\n        queue = new Queue<number>();\n    });\n\n    test('should initialize an empty queue', () => {\n        expect(queue.isEmpty()).toBe(true);\n    });\n\n    test('should enqueue elements to the queue', () => {\n        queue.enqueue(1);\n        queue.enqueue(2);\n        queue.enqueue(3);\n        expect(queue.printQueue()).toBe('1 2 3');\n        expect(queue.isEmpty()).toBe(false);\n    });\n\n    test('should dequeue elements from the queue', () => {\n        queue.enqueue(1);\n        queue.enqueue(2);\n        const dequeuedElement = queue.dequeue();\n        expect(dequeuedElement).toBe(1);\n    });\n\n    test('should return the front element without removing it', () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        const frontElement = queue.front();\n        expect(frontElement).toBe(10);\n    });\n\n    test('should check if the queue is empty', () => {\n        expect(queue.isEmpty()).toBe(true);\n        queue.enqueue(5);\n        expect(queue.isEmpty()).toBe(false);\n        queue.dequeue();\n        expect(queue.isEmpty()).toBe(true);\n    });\n});", "prompt": "please write a typescript class , the class signature as below /**\n * realize the basic functions of the question structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements\n */\nclass Queue<T> {\n    private items: T[];\n\n    constructor() {\n        this.items = [];\n    }\n\n    /**\n     * Adds an element to the end of the queue.\n     * @param element - The element to be added to the queue.\n     */\n    enqueue(element: T): void {\n    }\n\n    /**\n     * Removes and returns the element from the front of the queue.\n     * @returns The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n     */\n    dequeue(): T | string {\n    }\n\n    /**\n     * Returns the front element of the queue without removing it.\n     * @returns The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n     */\n    front(): T | string {\n    }\n\n    /**\n     * Checks if the queue is empty.\n     * @returns True if the queue is empty, otherwise false.\n     */\n    isEmpty(): boolean {\n    }\n\n    /**\n     * Returns a string representation of all the elements in the queue.\n     * @returns A string containing all elements in the queue, separated by spaces.\n     */\n    printQueue(): string {\n    }\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * realize the basic functions of the question structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements\n */\nclass Queue {\nprivate:\n    std::vector<int> items; // Change type as needed\n\npublic:\n    /**\n     * Adds an element to the end of the queue.\n     * @param element - The element to be added to the queue.\n     */\n    void enqueue(int element);\n\n    /**\n     * Removes and returns the element from the front of the queue.\n     * @returns The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n     */\n    std::string dequeue();\n\n    /**\n     * Returns the front element of the queue without removing it.\n     * @returns The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n     */\n    std::string front();\n\n    /**\n     * Checks if the queue is empty.\n     * @returns True if the queue is empty, otherwise false.\n     */\n    bool isEmpty();\n\n    /**\n     * Returns a string representation of all the elements in the queue.\n     * @returns A string containing all elements in the queue, separated by spaces.\n     */\n    std::string printQueue();\n};", "test_code": "TEST_CASE(\"Queue Class\", \"[queue]\") {\n    Queue queue;\n\n    SECTION(\"should initialize an empty queue\") {\n        REQUIRE(queue.isEmpty() == true);\n    }\n\n    SECTION(\"should enqueue elements to the queue\") {\n        queue.enqueue(1);\n        queue.enqueue(2);\n        queue.enqueue(3);\n        REQUIRE(queue.printQueue() == \"1 2 3\");\n        REQUIRE(queue.isEmpty() == false);\n    }\n\n    SECTION(\"should dequeue elements from the queue\") {\n        queue.enqueue(1);\n        queue.enqueue(2);\n        std::string dequeuedElement = queue.dequeue();\n        REQUIRE(dequeuedElement == \"1\");\n    }\n\n    SECTION(\"should return the front element without removing it\") {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        std::string frontElement = queue.front();\n        REQUIRE(frontElement == \"10\");\n    }\n\n    SECTION(\"should check if the queue is empty\") {\n        REQUIRE(queue.isEmpty() == true);\n        queue.enqueue(5);\n        REQUIRE(queue.isEmpty() == false);\n        queue.dequeue();\n        REQUIRE(queue.isEmpty() == true);\n    }\n}", "prompt": "please write a cpp class , the class signature as below /**\n * realize the basic functions of the question structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements\n */\nclass Queue {\nprivate:\n    std::vector<int> items; // Change type as needed\n\npublic:\n    /**\n     * Adds an element to the end of the queue.\n     * @param element - The element to be added to the queue.\n     */\n    void enqueue(int element);\n\n    /**\n     * Removes and returns the element from the front of the queue.\n     * @returns The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n     */\n    std::string dequeue();\n\n    /**\n     * Returns the front element of the queue without removing it.\n     * @returns The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n     */\n    std::string front();\n\n    /**\n     * Checks if the queue is empty.\n     * @returns True if the queue is empty, otherwise false.\n     */\n    bool isEmpty();\n\n    /**\n     * Returns a string representation of all the elements in the queue.\n     * @returns A string containing all elements in the queue, separated by spaces.\n     */\n    std::string printQueue();\n};", "addition_info": ""}, "java": {"code_signature": "\n\npublic class Answer{\nstatic class Queue {\n    private LinkedList<Object> items;\n\n    public Queue() {\n        this.items = new LinkedList<>();\n    }\n\n    /**\n     * Adds an element to the end of the queue.\n     * @param element The element to be added to the queue.\n     */\n    public void enqueue(Object element) {\n    }\n\n    /**\n     * Removes and returns the element from the front of the queue.\n     * @returns The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n     */\n    public Object dequeue() {\n    }\n\n    /**\n     * Returns the front element of the queue without removing it.\n     * @returns The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n     */\n    public Object front() {\n    }\n\n    /**\n     * Checks if the queue is empty.\n     * @returns True if the queue is empty, otherwise false.\n     */\n    public boolean isEmpty() {\n    }\n\n    /**\n     * Returns a string representation of all the elements in the queue.\n     * @returns A string containing all elements in the queue, separated by spaces.\n     */\n    public String printQueue() {\n    }\n}\n}\n\n\n", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n    private Queue queue;\n\n    @Before\n    public void setUp() {\n        queue = new Queue();\n    }\n\n    @Test\n    public void shouldInitializeAnEmptyQueue() {\n        assertTrue(queue.isEmpty());\n    }\n\n    @Test\n    public void shouldEnqueueElementsToTheQueue() {\n        queue.enqueue(1);\n        queue.enqueue(2);\n        queue.enqueue(3);\n        assertEquals(\"1 2 3\", queue.printQueue());\n        assertFalse(queue.isEmpty());\n    }\n\n    @Test\n    public void shouldDequeueElementsFromTheQueue() {\n        queue.enqueue(1);\n        queue.enqueue(2);\n        Object dequeuedElement = queue.dequeue();\n        assertEquals(1, dequeuedElement);\n    }\n\n    @Test\n    public void shouldReturnTheFrontElementWithoutRemovingIt() {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        Object frontElement = queue.front();\n        assertEquals(10, frontElement);\n    }\n\n    @Test\n    public void shouldCheckIfTheQueueIsEmpty() {\n        assertTrue(queue.isEmpty());\n        queue.enqueue(5);\n        assertFalse(queue.isEmpty());\n        queue.dequeue();\n        assertTrue(queue.isEmpty());\n    }\n}", "prompt": "please write a java class , the function signature as below \n\npublic class Answer{\nstatic class Queue {\n    private LinkedList<Object> items;\n\n    public Queue() {\n        this.items = new LinkedList<>();\n    }\n\n    /**\n     * Adds an element to the end of the queue.\n     * @param element The element to be added to the queue.\n     */\n    public void enqueue(Object element) {\n    }\n\n    /**\n     * Removes and returns the element from the front of the queue.\n     * @returns The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n     */\n    public Object dequeue() {\n    }\n\n    /**\n     * Returns the front element of the queue without removing it.\n     * @returns The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n     */\n    public Object front() {\n    }\n\n    /**\n     * Checks if the queue is empty.\n     * @returns True if the queue is empty, otherwise false.\n     */\n    public boolean isEmpty() {\n    }\n\n    /**\n     * Returns a string representation of all the elements in the queue.\n     * @returns A string containing all elements in the queue, separated by spaces.\n     */\n    public String printQueue() {\n    }\n}\n}\n\n\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 99, "code_type": "method", "original_language": "javascript", "question_type": "Algorithm and data structure", "summary": "Calculates the sum of all the numbers in a numeric array and returns it as a result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef calculate_sum(arr: List[int]):\n    \"\"\"\n    Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result.\n    For example, if you enter [1, 2, 3, 4, 5], the return value is 15.\n\n    Args:\n        arr (List[int]): The array of numbers to sum.\n\n    Returns:\n        int: The sum of all the numbers in the array.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSumFunction(unittest.TestCase):\n\n    def test_sum_of_positive_numbers(self):\n        \"\"\"Test the sum of a normal array of positive numbers.\"\"\"\n        self.assertEqual(calculate_sum([1, 2, 3, 4, 5]), 15)\n\n    def test_sum_of_negative_numbers(self):\n        \"\"\"Test the sum of an array containing negative numbers.\"\"\"\n        self.assertEqual(calculate_sum([-1, -2, -3, -4, -5]), -15)\n\n    def test_sum_of_empty_array(self):\n        \"\"\"Test that the sum of an empty array is 0.\"\"\"\n        self.assertEqual(calculate_sum([]), 0)\n\n    def test_sum_of_mixed_numbers(self):\n        \"\"\"Test the sum of an array containing both positive and negative numbers.\"\"\"\n        self.assertEqual(calculate_sum([10, -10, 5, -5, 15]), 15)\n\n    def test_sum_of_floating_point_numbers(self):\n        \"\"\"Test the sum of an array with floating point numbers.\"\"\"\n        self.assertAlmostEqual(calculate_sum([1.5, 2.5, 3.5]), 7.5)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef calculate_sum(arr: List[int]):\n    \"\"\"\n    Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result.\n    For example, if you enter [1, 2, 3, 4, 5], the return value is 15.\n\n    Args:\n        arr (List[int]): The array of numbers to sum.\n\n    Returns:\n        int: The sum of all the numbers in the array.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param {number[]} arr - The array of numbers to sum.\n */\nfunction sum(arr) {\n    \n}\n", "test_code": "describe('Sum Function Tests', () => {\n    test('should return the sum of a normal array of positive numbers', () => {\n        expect(sum([1, 2, 3, 4, 5])).toBe(15);\n    });\n\n    test('should return the sum of an array containing negative numbers', () => {\n        expect(sum([-1, -2, -3, -4, -5])).toBe(-15);\n    });\n\n    test('should return 0 for an empty array', () => {\n        expect(sum([])).toBe(0);\n    });\n\n    test('should return the sum of an array containing both positive and negative numbers', () => {\n        expect(sum([10, -10, 5, -5, 15])).toBe(15);\n    });\n\n    test('should return the sum of an array with floating point numbers', () => {\n        expect(sum([1.5, 2.5, 3.5])).toBe(7.5);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param {number[]} arr - The array of numbers to sum.\n */\nfunction sum(arr) {\n    \n}\n", "addition_info": ""}, "typescript": {"code_signature": "/** \n * Calculates the sum of all elements in an array.\n * \n * @param {number[]} arr - The array of numbers to sum.\n * @returns {number} The sum of all elements of the array.\n */\nfunction sum(arr: number[]): number {}", "test_code": "describe('Sum Function Tests', () => {\n    test('should return the sum of a normal array of positive numbers', () => {\n        expect(sum([1, 2, 3, 4, 5])).toBe(15);\n    });\n\n    test('should return the sum of an array containing negative numbers', () => {\n        expect(sum([-1, -2, -3, -4, -5])).toBe(-15);\n    });\n\n    test('should return 0 for an empty array', () => {\n        expect(sum([])).toBe(0);\n    });\n\n    test('should return the sum of an array containing both positive and negative numbers', () => {\n        expect(sum([10, -10, 5, -5, 15])).toBe(15);\n    });\n\n    test('should return the sum of an array with floating point numbers', () => {\n        expect(sum([1.5, 2.5, 3.5])).toBe(7.5);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /** \n * Calculates the sum of all elements in an array.\n * \n * @param {number[]} arr - The array of numbers to sum.\n * @returns {number} The sum of all elements of the array.\n */\nfunction sum(arr: number[]): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param arr - The vector of numbers to sum.\n */\nint sum(const std::vector<int>& arr) {\n    // Function implementation will go here\n}", "test_code": "TEST_CASE(\"Sum Function Tests\") {\n    SECTION(\"should return the sum of a normal array of positive numbers\") {\n        REQUIRE(sum({1, 2, 3, 4, 5}) == 15);\n    }\n\n    SECTION(\"should return the sum of an array containing negative numbers\") {\n        REQUIRE(sum({-1, -2, -3, -4, -5}) == -15);\n    }\n\n    SECTION(\"should return 0 for an empty array\") {\n        REQUIRE(sum({}) == 0);\n    }\n\n    SECTION(\"should return the sum of an array containing both positive and negative numbers\") {\n        REQUIRE(sum({10, -10, 5, -5, 15}) == 15);\n    }\n\n    SECTION(\"should return the sum of an array with floating point numbers\") {\n        REQUIRE(sum({1.5, 2.5, 3.5}) == Approx(7.5)); // Using Approx for floating-point comparison\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param arr - The vector of numbers to sum.\n */\nint sum(const std::vector<int>& arr) {\n    // Function implementation will go here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param arr The array of numbers to sum.\n */\npublic static int sum(int[] arr) {\n    \n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testSumNormalArray() {\n        assertEquals(15, sum(new int[]{1, 2, 3, 4, 5}));\n    }\n\n    @Test\n    public void testSumNegativeArray() {\n        assertEquals(-15, sum(new int[]{-1, -2, -3, -4, -5}));\n    }\n\n    @Test\n    public void testSumEmptyArray() {\n        assertEquals(0, sum(new int[]{}));\n    }\n\n    @Test\n    public void testSumMixedArray() {\n        assertEquals(15, sum(new int[]{10, -10, 5, -5, 15}));\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param arr The array of numbers to sum.\n */\npublic static int sum(int[] arr) {\n    \n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 100, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "The function is to convert the ISO 8601 duration format to string format, for example PT2H5M is converted to 2h5m", "language_version_list": {"python": {"code_signature": "def convert_time(duration: str) -> str:\n    \"\"\"\n    Converts an ISO 8601 duration string into a more readable format.\n\n    Args:\n        duration (str): The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n\n    Returns:\n        str: A human-readable duration string (e.g., \"1h23m45s678ms\").\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestConvertTimeFunction(unittest.TestCase):\n\n    def test_full_iso_duration(self):\n        \"\"\"Test converting full ISO 8601 duration with hours, minutes, seconds, and milliseconds.\"\"\"\n        self.assertEqual(convert_time('PT1H23M45.678S'), '1h23m45s678ms')\n\n    def test_duration_with_seconds_and_milliseconds(self):\n        \"\"\"Test converting duration with only seconds and milliseconds.\"\"\"\n        self.assertEqual(convert_time('PT45.5S'), '45s500ms')\n\n    def test_duration_with_hours_and_minutes_no_seconds(self):\n        \"\"\"Test converting duration with hours and minutes, but no seconds.\"\"\"\n        self.assertEqual(convert_time('PT2H5M'), '2h5m')\n\n    def test_duration_with_only_seconds_no_milliseconds(self):\n        \"\"\"Test converting duration with only seconds, no milliseconds.\"\"\"\n        self.assertEqual(convert_time('PT20S'), '20s')\n", "prompt": "please write a python function , the function signature as below def convert_time(duration: str) -> str:\n    \"\"\"\n    Converts an ISO 8601 duration string into a more readable format.\n\n    Args:\n        duration (str): The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n\n    Returns:\n        str: A human-readable duration string (e.g., \"1h23m45s678ms\").\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param {string} duration - The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns {string} A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\nfunction convertTime(duration) {\n    const regex = /PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(\\.\\d+)?S)?/;\n    const matches = duration.match(regex);\n\n    if (!matches) return ''; // Return an empty string if the input doesn't match the expected format\n\n    const [ , hours, minutes, seconds, fractionalSeconds ] = matches;\n    let convertedTime = '';\n\n    if (hours) {\n        convertedTime += `${hours}h`;\n    }\n\n    if (minutes) {\n        convertedTime += `${minutes}m`;\n    }\n\n    if (seconds) {\n        convertedTime += `${seconds}s`;\n    }\n\n    if (fractionalSeconds) {\n        const milliseconds = Math.round(parseFloat(fractionalSeconds) * 1000);\n        if (milliseconds > 0) {\n            convertedTime += `${milliseconds}ms`;\n        }\n    }\n\n    return convertedTime;\n}\n", "test_code": "describe('ConvertTime Function Tests', () => {\n    test('should correctly convert full ISO 8601 duration with hours, minutes, seconds, and milliseconds', () => {\n        expect(convertTime('PT1H23M45.678S')).toBe('1h23m45s678ms');\n    });\n\n    test('should correctly convert duration with only seconds and milliseconds', () => {\n        expect(convertTime('PT45.5S')).toBe('45s500ms');\n    });\n\n    test('should correctly convert duration with hours and minutes, but no seconds', () => {\n        expect(convertTime('PT2H5M')).toBe('2h5m');\n    });\n\n    test('should correctly convert duration with only seconds, no milliseconds', () => {\n        expect(convertTime('PT20S')).toBe('20s');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param {string} duration - The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns {string} A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\nfunction convertTime(duration) {\n    const regex = /PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(\\.\\d+)?S)?/;\n    const matches = duration.match(regex);\n\n    if (!matches) return ''; // Return an empty string if the input doesn't match the expected format\n\n    const [ , hours, minutes, seconds, fractionalSeconds ] = matches;\n    let convertedTime = '';\n\n    if (hours) {\n        convertedTime += `${hours}h`;\n    }\n\n    if (minutes) {\n        convertedTime += `${minutes}m`;\n    }\n\n    if (seconds) {\n        convertedTime += `${seconds}s`;\n    }\n\n    if (fractionalSeconds) {\n        const milliseconds = Math.round(parseFloat(fractionalSeconds) * 1000);\n        if (milliseconds > 0) {\n            convertedTime += `${milliseconds}ms`;\n        }\n    }\n\n    return convertedTime;\n}\n", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param {string} duration - The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns {string} A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\nfunction convertTime(duration: string): string {}", "test_code": "describe('ConvertTime Function Tests', () => {\n    test('should correctly convert full ISO 8601 duration with hours, minutes, seconds, and milliseconds', () => {\n        expect(convertTime('PT1H23M45.678S')).toBe('1h23m45s678ms');\n    });\n\n    test('should correctly convert duration with only seconds and milliseconds', () => {\n        expect(convertTime('PT45.5S')).toBe('45s500ms');\n    });\n\n    test('should correctly convert duration with hours and minutes, but no seconds', () => {\n        expect(convertTime('PT2H5M')).toBe('2h5m');\n    });\n\n    test('should correctly convert duration with only seconds, no milliseconds', () => {\n        expect(convertTime('PT20S')).toBe('20s');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param {string} duration - The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns {string} A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\nfunction convertTime(duration: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <regex>\n#include <string>\n\n/**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param duration The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\nstd::string convertTime(const std::string& duration) {\n    std::regex regex(R\"(PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(\\.\\d+)?S)?)\");\n    std::smatch matches;\n\n    if (!std::regex_match(duration, matches, regex)) return \"\"; // Return an empty string if the input doesn't match\n\n    std::string convertedTime;\n    if (matches[1].length() > 0) {\n        convertedTime += matches[1].str() + \"h\";\n    }\n    if (matches[2].length() > 0) {\n        convertedTime += matches[2].str() + \"m\";\n    }\n    if (matches[3].length() > 0) {\n        convertedTime += matches[3].str() + \"s\";\n    }\n    if (matches[4].length() > 0) {\n        int milliseconds = static_cast<int>(std::round(std::stod(matches[4].str()) * 1000));\n        if (milliseconds > 0) {\n            convertedTime += std::to_string(milliseconds) + \"ms\";\n        }\n    }\n\n    return convertedTime;\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\nstd::string convertTime(const std::string& duration); // Forward declaration\n\nTEST_CASE(\"ConvertTime Function Tests\") {\n    SECTION(\"should correctly convert full ISO 8601 duration with hours, minutes, seconds, and milliseconds\") {\n        REQUIRE(convertTime(\"PT1H23M45.678S\") == \"1h23m45s678ms\");\n    }\n\n    SECTION(\"should correctly convert duration with only seconds and milliseconds\") {\n        REQUIRE(convertTime(\"PT45.5S\") == \"45s500ms\");\n    }\n\n    SECTION(\"should correctly convert duration with hours and minutes, but no seconds\") {\n        REQUIRE(convertTime(\"PT2H5M\") == \"2h5m\");\n    }\n\n    SECTION(\"should correctly convert duration with only seconds, no milliseconds\") {\n        REQUIRE(convertTime(\"PT20S\") == \"20s\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <regex>\n#include <string>\n\n/**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param duration The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\nstd::string convertTime(const std::string& duration) {\n    std::regex regex(R\"(PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(\\.\\d+)?S)?)\");\n    std::smatch matches;\n\n    if (!std::regex_match(duration, matches, regex)) return \"\"; // Return an empty string if the input doesn't match\n\n    std::string convertedTime;\n    if (matches[1].length() > 0) {\n        convertedTime += matches[1].str() + \"h\";\n    }\n    if (matches[2].length() > 0) {\n        convertedTime += matches[2].str() + \"m\";\n    }\n    if (matches[3].length() > 0) {\n        convertedTime += matches[3].str() + \"s\";\n    }\n    if (matches[4].length() > 0) {\n        int milliseconds = static_cast<int>(std::round(std::stod(matches[4].str()) * 1000));\n        if (milliseconds > 0) {\n            convertedTime += std::to_string(milliseconds) + \"ms\";\n        }\n    }\n\n    return convertedTime;\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param duration The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\npublic class TimeConverter {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testConvertTimeFullDuration() {\n        assertEquals(\"1h23m45s678ms\", convertTime(\"PT1H23M45.678S\"));\n    }\n\n    @Test\n    public void testConvertTimeOnlySecondsAndMilliseconds() {\n        assertEquals(\"45s500ms\", convertTime(\"PT45.5S\"));\n    }\n\n    @Test\n    public void testConvertTimeHoursAndMinutesNoSeconds() {\n        assertEquals(\"2h5m\", convertTime(\"PT2H5M\"));\n    }\n\n    @Test\n    public void testConvertTimeOnlySecondsNoMilliseconds() {\n        assertEquals(\"20s\", convertTime(\"PT20S\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param duration The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\npublic class TimeConverter {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 101, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Determine whether the current time is within the specified time range (i.e., whether it is a break)\n", "language_version_list": {"python": {"code_signature": "def is_break_time(start_time: str, end_time: str, current_time: str) -> None:\n    \"\"\"\n    Determine whether the current time is within the specified time range (i.e., whether it is a break).\n\n    Args:\n        start_time (str): The start time of the break in HH:MM format.\n        end_time (str): The end time of the break in HH:MM format.\n        current_time (str): The current time in HH:MM format.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsBreakTime(unittest.TestCase):\n    def test_current_time_at_start(self):\n        self.assertTrue(is_break_time(\"09:00\", \"10:00\", \"09:00\"))\n\n    def test_current_time_within_range(self):\n        self.assertTrue(is_break_time(\"09:00\", \"10:00\", \"09:30\"))\n\n    def test_current_time_exceeds_end_time(self):\n        self.assertFalse(is_break_time(\"09:00\", \"10:00\", \"20:00\"))\n\n    def test_current_time_before_break_time(self):\n        self.assertFalse(is_break_time(\"09:00\", \"10:00\", \"08:59\"))\n\n    def test_current_time_after_break_time(self):\n        self.assertFalse(is_break_time(\"09:00\", \"10:00\", \"10:01\"))\n", "prompt": "please write a python function , the function signature as below def is_break_time(start_time: str, end_time: str, current_time: str) -> None:\n    \"\"\"\n    Determine whether the current time is within the specified time range (i.e., whether it is a break).\n\n    Args:\n        start_time (str): The start time of the break in HH:MM format.\n        end_time (str): The end time of the break in HH:MM format.\n        current_time (str): The current time in HH:MM format.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param {string} startTime - The start time of the break in HH:MM format.\n * @param {string} endTime - The end time of the break in HH:MM format.\n * @param {string} currentTime - The current time in HH:MM format.\n */\nfunction isBreakTime(startTime, endTime, currentTime) {\n    \n}\n", "test_code": "describe('isBreakTime Function Tests', () => {\n    test('should return true when current time is exactly at the start time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"09:00\")).toBe(true);\n    });\n\n    test('should return true when current time is within the break time range', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"09:30\")).toBe(true);\n    });\n\n    test('should return false when current time is exactly exceed the end time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"20:00\")).toBe(false);\n    });\n\n    test('should return false when current time is before the break time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"08:59\")).toBe(false);\n    });\n\n    test('should return false when current time is after the break time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"10:01\")).toBe(false);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param {string} startTime - The start time of the break in HH:MM format.\n * @param {string} endTime - The end time of the break in HH:MM format.\n * @param {string} currentTime - The current time in HH:MM format.\n */\nfunction isBreakTime(startTime, endTime, currentTime) {\n    \n}\n", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param {string} startTime - The start time of the break in HH:MM format.\n * @param {string} endTime - The end time of the break in HH:MM format.\n * @param {string} currentTime - The current time in HH:MM format.\n */\nfunction isBreakTime(startTime: string, endTime: string, currentTime: string): void {\n    // Implementation goes here\n}", "test_code": "describe('isBreakTime Function Tests', () => {\n    test('should return true when current time is exactly at the start time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"09:00\")).toBe(true);\n    });\n\n    test('should return true when current time is within the break time range', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"09:30\")).toBe(true);\n    });\n\n    test('should return false when current time exactly exceeds the end time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"10:00\")).toBe(true);\n    });\n\n    test('should return false when current time is before the break time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"08:59\")).toBe(false);\n    });\n\n    test('should return false when current time is after the break time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"10:01\")).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param {string} startTime - The start time of the break in HH:MM format.\n * @param {string} endTime - The end time of the break in HH:MM format.\n * @param {string} currentTime - The current time in HH:MM format.\n */\nfunction isBreakTime(startTime: string, endTime: string, currentTime: string): void {\n    // Implementation goes here\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param startTime - The start time of the break in HH:MM format.\n * @param endTime - The end time of the break in HH:MM format.\n * @param currentTime - The current time in HH:MM format.\n * @return true if the current time is within the break time range, false otherwise.\n */\nbool isBreakTime(const std::string& startTime, const std::string& endTime, const std::string& currentTime) {\n    // Function implementation goes here\n}", "test_code": "TEST_CASE(\"isBreakTime Function Tests\") {\n    SECTION(\"should return true when current time is exactly at the start time\") {\n        REQUIRE(isBreakTime(\"09:00\", \"10:00\", \"09:00\") == true);\n    }\n\n    SECTION(\"should return true when current time is within the break time range\") {\n        REQUIRE(isBreakTime(\"09:00\", \"10:00\", \"09:30\") == true);\n    }\n\n    SECTION(\"should return false when current time exactly exceeds the end time\") {\n        REQUIRE(isBreakTime(\"09:00\", \"10:00\", \"10:00\") == false);\n    }\n\n    SECTION(\"should return false when current time is before the break time\") {\n        REQUIRE(isBreakTime(\"09:00\", \"10:00\", \"08:59\") == false);\n    }\n\n    SECTION(\"should return false when current time is after the break time\") {\n        REQUIRE(isBreakTime(\"09:00\", \"10:00\", \"10:01\") == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param startTime - The start time of the break in HH:MM format.\n * @param endTime - The end time of the break in HH:MM format.\n * @param currentTime - The current time in HH:MM format.\n * @return true if the current time is within the break time range, false otherwise.\n */\nbool isBreakTime(const std::string& startTime, const std::string& endTime, const std::string& currentTime) {\n    // Function implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param startTime - The start time of the break in HH:MM format.\n * @param endTime - The end time of the break in HH:MM format.\n * @param currentTime - The current time in HH:MM format.\n */\npublic static void isBreakTime(String startTime, String endTime, String currentTime) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testIsBreakTime_StartTime() {\n        assertTrue(isBreakTime(\"09:00\", \"10:00\", \"09:00\"));\n    }\n\n    @Test\n    public void testIsBreakTime_WithinRange() {\n        assertTrue(isBreakTime(\"09:00\", \"10:00\", \"09:30\"));\n    }\n\n    @Test\n    public void testIsBreakTime_ExceedEndTime() {\n        assertFalse(isBreakTime(\"09:00\", \"10:00\", \"20:00\"));\n    }\n\n    @Test\n    public void testIsBreakTime_BeforeStart() {\n        assertFalse(isBreakTime(\"09:00\", \"10:00\", \"08:59\"));\n    }\n\n    @Test\n    public void testIsBreakTime_AfterEnd() {\n        assertFalse(isBreakTime(\"09:00\", \"10:00\", \"10:01\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param startTime - The start time of the break in HH:MM format.\n * @param endTime - The end time of the break in HH:MM format.\n * @param currentTime - The current time in HH:MM format.\n */\npublic static void isBreakTime(String startTime, String endTime, String currentTime) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 103, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "\nTruncate the string to the specified length, if the string exceeds the specified length, the excess part is used with an ellipsis (...) replace", "language_version_list": {"python": {"code_signature": "def truncate_string_with_replacement(s: str, max_length: int) -> str:\n    \"\"\"\n    Truncate a string to the specified length, replacing the excess part with an ellipsis.\n\n    Args:\n        s (str): The string to truncate.\n        max_length (int): The maximum length of the resulting string.\n\n    Returns:\n        str: The truncated string with ellipsis if applicable.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestTruncateStringWithReplacement(unittest.TestCase):\n\n    def test_should_return_original_string_if_shorter_than_max_length(self):\n        result = truncate_string_with_replacement('Hello World', 20)\n        self.assertEqual(result, 'Hello World')\n\n    def test_should_truncate_string_and_replace_excess_with_ellipsis(self):\n        result = truncate_string_with_replacement('This is a long string that needs to be truncated.', 20)\n        self.assertEqual(result, 'This is a long str...')\n\n    def test_should_truncate_string_at_max_length_and_add_ellipsis(self):\n        result = truncate_string_with_replacement('Short string', 10)\n        self.assertEqual(result, 'Short str...')\n\n    def test_should_handle_empty_string_correctly(self):\n        result = truncate_string_with_replacement('', 10)\n        self.assertEqual(result, '')\n\n    def test_should_return_original_string_when_max_length_equals_string_length(self):\n        result = truncate_string_with_replacement('Exact length', 12)\n        self.assertEqual(result, 'Exact length')\n\n    def test_should_replace_excess_with_ellipsis_in_string_with_special_characters(self):\n        result = truncate_string_with_replacement('This string has special characters: !@#$%^&*()', 30)\n        self.assertEqual(result, 'This string has special c...')\n\n    def test_should_return_ellipsis_only_when_max_length_is_0(self):\n        result = truncate_string_with_replacement('Hello, world!', 0)\n        self.assertEqual(result, '...')\n", "prompt": "please write a python function , the function signature as below def truncate_string_with_replacement(s: str, max_length: int) -> str:\n    \"\"\"\n    Truncate a string to the specified length, replacing the excess part with an ellipsis.\n\n    Args:\n        s (str): The string to truncate.\n        max_length (int): The maximum length of the resulting string.\n\n    Returns:\n        str: The truncated string with ellipsis if applicable.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Truncate a string to the specified length, replacing the excess part with an ellipsis.\n *\n * @param {string} str - The string to truncate.\n * @param {number} maxLength - The maximum length of the resulting string.\n * @returns {string} - The truncated string with ellipsis if applicable.\n */\nfunction truncateStringWithReplacement(str, maxLength) {\n}", "test_code": "describe('truncateStringWithReplacement', () => {\n    test('should return the original string if it is shorter than maxLength', () => {\n        const result = truncateStringWithReplacement('Hello World', 20);\n        expect(result).toBe('Hello World');\n    });\n\n    test('should truncate the string and replace the excess with ellipsis when longer than maxLength', () => {\n        const result = truncateStringWithReplacement('This is a long string that needs to be truncated.', 20);\n        expect(result).toBe('This is a long str...');\n    });\n\n    test('should truncate the string at maxLength and add ellipsis', () => {\n        const result = truncateStringWithReplacement('Short string', 10);\n        expect(result).toBe('Short str...');\n    });\n\n    test('should handle empty string correctly', () => {\n        const result = truncateStringWithReplacement('', 10);\n        expect(result).toBe('');\n    });\n\n    test('should return the original string when maxLength is equal to string length', () => {\n        const result = truncateStringWithReplacement('Exact length', 12);\n        expect(result).toBe('Exact length');\n    });\n\n    test('should replace excess part with ellipsis in a string with special characters', () => {\n        const result = truncateStringWithReplacement('This string has special characters: !@#$%^&*()', 30);\n        expect(result).toBe('This string has special c...');\n    });\n\n    test('should return ellipsis only when the maxLength is 0', () => {\n        const result = truncateStringWithReplacement('Hello, world!', 0);\n        expect(result).toBe('...');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Truncate a string to the specified length, replacing the excess part with an ellipsis.\n *\n * @param {string} str - The string to truncate.\n * @param {number} maxLength - The maximum length of the resulting string.\n * @returns {string} - The truncated string with ellipsis if applicable.\n */\nfunction truncateStringWithReplacement(str, maxLength) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Truncate a string to the specified length, replacing the excess part with an ellipsis.\n *\n * @param {string} str - The string to truncate.\n * @param {number} maxLength - The maximum length of the resulting string.\n * @returns {string} - The truncated string with ellipsis if applicable.\n */\nfunction truncateStringWithReplacement(str: string, maxLength: number): string {\n}", "test_code": "describe('truncateStringWithReplacement', () => {\n    test('should return the original string if it is shorter than maxLength', () => {\n        const result = truncateStringWithReplacement('Hello World', 20);\n        expect(result).toBe('Hello World');\n    });\n\n    test('should truncate the string and replace the excess with ellipsis when longer than maxLength', () => {\n        const result = truncateStringWithReplacement('This is a long string that needs to be truncated.', 20);\n        expect(result).toBe('This is a long str...');\n    });\n\n    test('should truncate the string at maxLength and add ellipsis', () => {\n        const result = truncateStringWithReplacement('Short string', 10);\n        expect(result).toBe('Short str...');\n    });\n\n    test('should handle empty string correctly', () => {\n        const result = truncateStringWithReplacement('', 10);\n        expect(result).toBe('');\n    });\n\n    test('should return the original string when maxLength is equal to string length', () => {\n        const result = truncateStringWithReplacement('Exact length', 12);\n        expect(result).toBe('Exact length');\n    });\n\n    test('should replace excess part with ellipsis in a string with special characters', () => {\n        const result = truncateStringWithReplacement('This string has special characters: !@#$%^&*()', 30);\n        expect(result).toBe('This string has special c...');\n    });\n\n    test('should return ellipsis only when the maxLength is 0', () => {\n        const result = truncateStringWithReplacement('Hello, world!', 0);\n        expect(result).toBe('...');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Truncate a string to the specified length, replacing the excess part with an ellipsis.\n *\n * @param {string} str - The string to truncate.\n * @param {number} maxLength - The maximum length of the resulting string.\n * @returns {string} - The truncated string with ellipsis if applicable.\n */\nfunction truncateStringWithReplacement(str: string, maxLength: number): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Truncate a string to the specified length, replacing the excess part with an ellipsis.\n *\n * @param str - The string to truncate.\n * @param maxLength - The maximum length of the resulting string.\n * @returns - The truncated string with ellipsis if applicable.\n */\nstd::string truncateStringWithReplacement(const std::string& str, size_t maxLength) {\n}", "test_code": "TEST_CASE(\"truncateStringWithReplacement\") {\n    SECTION(\"should return the original string if it is shorter than maxLength\") {\n        REQUIRE(truncateStringWithReplacement(\"Hello World\", 20) == \"Hello World\");\n    }\n\n    SECTION(\"should truncate the string and replace the excess with ellipsis when longer than maxLength\") {\n        REQUIRE(truncateStringWithReplacement(\"This is a long string that needs to be truncated.\", 20) == \"This is a long str...\");\n    }\n\n    SECTION(\"should truncate the string at maxLength and add ellipsis\") {\n        REQUIRE(truncateStringWithReplacement(\"Short string\", 10) == \"Short str...\");\n    }\n\n    SECTION(\"should handle empty string correctly\") {\n        REQUIRE(truncateStringWithReplacement(\"\", 10) == \"\");\n    }\n\n    SECTION(\"should return the original string when maxLength is equal to string length\") {\n        REQUIRE(truncateStringWithReplacement(\"Exact length\", 12) == \"Exact length\");\n    }\n\n    SECTION(\"should replace excess part with ellipsis in a string with special characters\") {\n        REQUIRE(truncateStringWithReplacement(\"This string has special characters: !@#$%^&*()\", 30) == \"This string has special c...\");\n    }\n\n    SECTION(\"should return ellipsis only when the maxLength is 0\") {\n        REQUIRE(truncateStringWithReplacement(\"Hello, world!\", 0) == \"...\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Truncate a string to the specified length, replacing the excess part with an ellipsis.\n *\n * @param str - The string to truncate.\n * @param maxLength - The maximum length of the resulting string.\n * @returns - The truncated string with ellipsis if applicable.\n */\nstd::string truncateStringWithReplacement(const std::string& str, size_t maxLength) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Truncate a string to the specified length, replacing the excess part with an ellipsis.\n *\n * @param str - The string to truncate.\n * @param maxLength - The maximum length of the resulting string.\n * @return - The truncated string with ellipsis if applicable.\n */\npublic static String truncateStringWithReplacement(String str, int maxLength) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testOriginalStringShorterThanMaxLength() {\n        String result = truncateStringWithReplacement(\"Hello World\", 20);\n        assertEquals(\"Hello World\", result);\n    }\n\n\n    @Test\n    public void testHandleEmptyString() {\n        String result = truncateStringWithReplacement(\"\", 10);\n        assertEquals(\"\", result);\n    }\n\n    @Test\n    public void testOriginalStringEqualToMaxLength() {\n        String result = truncateStringWithReplacement(\"Exact length\", 12);\n        assertEquals(\"Exact length\", result);\n    }\n\n\n    @Test\n    public void testMaxLengthZeroReturnsEllipsis() {\n        String result = truncateStringWithReplacement(\"Hello, world!\", 0);\n        assertEquals(\"...\", result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Truncate a string to the specified length, replacing the excess part with an ellipsis.\n *\n * @param str - The string to truncate.\n * @param maxLength - The maximum length of the resulting string.\n * @return - The truncated string with ellipsis if applicable.\n */\npublic static String truncateStringWithReplacement(String str, int maxLength) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 104, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "The incoming thread object is converted into a JSON file, which is represented as a Blob object.", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * The incoming thread object is converted into a JSON file, which is represented as a Blob object.\n * \n * @param {Object} thread - The thread object to be converted.\n */\nfunction convertThreadToJSONFile(thread) {\n    \n}\n", "test_code": "describe('convertThreadToJSONFile Function Tests', () => {\n    test('should return a Blob object for a basic thread object', () => {\n        const thread1 = { id: 1, title: \"First Thread\", content: \"This is the first thread.\" };\n        const blob1 = convertThreadToJSONFile(thread1);\n        expect(blob1 instanceof Blob).toBe(true);\n        expect(blob1.type).toBe(\"application/json\");\n    });\n\n    test('should return a Blob object for an empty thread object', () => {\n        const thread2 = {};\n        const blob2 = convertThreadToJSONFile(thread2);\n        expect(blob2 instanceof Blob).toBe(true);\n        expect(blob2.size).toBe(2); // \"{}\" has a size of 2 bytes\n    });\n\n    test('should return a Blob object for a thread object with nested objects', () => {\n        const thread3 = { id: 2, title: \"Second Thread\", comments: [{ user: \"Alice\", comment: \"Great post!\" }] };\n        const blob3 = convertThreadToJSONFile(thread3);\n        expect(blob3 instanceof Blob).toBe(true);\n    });\n\n    test('should return a Blob object for a thread object with special characters', () => {\n        const thread4 = { id: 3, title: \"Thread & Special <Characters>\", content: 'This is a thread with special characters: <, >, &, \".' };\n        const blob4 = convertThreadToJSONFile(thread4);\n        expect(blob4 instanceof Blob).toBe(true);\n    });\n\n    test('should return a Blob object for a thread object with arrays', () => {\n        const thread5 = { id: 4, title: \"Thread with Array\", tags: [\"JavaScript\", \"JSON\", \"Blob\"] };\n        const blob5 = convertThreadToJSONFile(thread5);\n        expect(blob5 instanceof Blob).toBe(true);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * The incoming thread object is converted into a JSON file, which is represented as a Blob object.\n * \n * @param {Object} thread - The thread object to be converted.\n */\nfunction convertThreadToJSONFile(thread) {\n    \n}\n", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 106, "code_type": "method", "original_language": "javascript", "question_type": "File operations and I/O operation", "summary": "Checks if the provided image data is a valid Base64 encoded image string.", "language_version_list": {"python": {"code_signature": "def is_base64_image(image_data: str) -> None:\n    \"\"\"\n    Checks if the provided image data is a valid Base64 encoded image string.\n\n    Args:\n        image_data (str): The image data string to be validated.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsBase64Image(unittest.TestCase):\n\n    def test_valid_png(self):\n        valid_png = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA'\n        self.assertTrue(is_base64_image(valid_png))\n\n    def test_valid_jpeg(self):\n        valid_jpeg = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAAAAAA'\n        self.assertTrue(is_base64_image(valid_jpeg))\n\n    def test_invalid_format(self):\n        invalid_format = 'data:text/plain;base64,SGVsbG8gd29ybGQ='\n        self.assertFalse(is_base64_image(invalid_format))\n\n    def test_invalid_base64_characters(self):\n        invalid_base64 = 'data:image/png;base64,invalidBase64String@#%'\n        self.assertFalse(is_base64_image(invalid_base64))\n\n    def test_empty_string(self):\n        self.assertFalse(is_base64_image(''))\n", "prompt": "please write a python function , the function signature as below def is_base64_image(image_data: str) -> None:\n    \"\"\"\n    Checks if the provided image data is a valid Base64 encoded image string.\n\n    Args:\n        image_data (str): The image data string to be validated.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param {string} imageData - The image question string to be validated.\n */\nfunction isBase64Image(imageData) {\n    \n}\n", "test_code": "describe('isBase64Image', () => {\n    test('should return true for a valid PNG Base64 image string', () => {\n        const validPng = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA';\n        expect(isBase64Image(validPng)).toBe(true);\n    });\n\n    test('should return true for a valid JPEG Base64 image string', () => {\n        const validJpeg = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAAAAAA';\n        expect(isBase64Image(validJpeg)).toBe(true);\n    });\n\n    test('should return false for a string without the image data prefix', () => {\n        const invalidFormat = 'data:text/plain;base64,SGVsbG8gd29ybGQ=';\n        expect(isBase64Image(invalidFormat)).toBe(false);\n    });\n\n    test('should return false for a string with invalid Base64 characters', () => {\n        const invalidBase64 = 'data:image/png;base64,invalidBase64String@#%';\n        expect(isBase64Image(invalidBase64)).toBe(false);\n    });\n\n    test('should return false for an empty string', () => {\n        expect(isBase64Image('')).toBe(false);\n    });\n\n    test('should return false for a null input', () => {\n        expect(isBase64Image(null)).toBe(false);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param {string} imageData - The image question string to be validated.\n */\nfunction isBase64Image(imageData) {\n    \n}\n", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param {string} imageData - The image question string to be validated.\n */\nfunction isBase64Image(imageData: string): void {\n    \n}", "test_code": "describe('isBase64Image', () => {\n    test('should return true for a valid PNG Base64 image string', () => {\n        const validPng: string = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA';\n        expect(isBase64Image(validPng)).toBe(true);\n    });\n\n    test('should return true for a valid JPEG Base64 image string', () => {\n        const validJpeg: string = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAAAAAA';\n        expect(isBase64Image(validJpeg)).toBe(true);\n    });\n\n    test('should return false for a string without the image data prefix', () => {\n        const invalidFormat: string = 'data:text/plain;base64,SGVsbG8gd29ybGQ=';\n        expect(isBase64Image(invalidFormat)).toBe(false);\n    });\n\n    test('should return false for a string with invalid Base64 characters', () => {\n        const invalidBase64: string = 'data:image/png;base64,invalidBase64String@#%';\n        expect(isBase64Image(invalidBase64)).toBe(false);\n    });\n\n    test('should return false for an empty string', () => {\n        expect(isBase64Image('')).toBe(false);\n    });\n\n    test('should return false for a null input', () => {\n        expect(isBase64Image(null as any)).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param {string} imageData - The image question string to be validated.\n */\nfunction isBase64Image(imageData: string): void {\n    \n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param imageData - The image data string to be validated.\n */\nbool isBase64Image(const std::string& imageData) {\n    \n}", "test_code": "TEST_CASE(\"isBase64Image\") {\n    SECTION(\"should return true for a valid PNG Base64 image string\") {\n        std::string validPng = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\";\n        REQUIRE(isBase64Image(validPng) == true);\n    }\n\n    SECTION(\"should return true for a valid JPEG Base64 image string\") {\n        std::string validJpeg = \"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAAAAAA\";\n        REQUIRE(isBase64Image(validJpeg) == true);\n    }\n\n    SECTION(\"should return false for a string without the image data prefix\") {\n        std::string invalidFormat = \"data:text/plain;base64,SGVsbG8gd29ybGQ=\";\n        REQUIRE(isBase64Image(invalidFormat) == false);\n    }\n\n    SECTION(\"should return false for a string with invalid Base64 characters\") {\n        std::string invalidBase64 = \"data:image/png;base64,invalidBase64String@#%\";\n        REQUIRE(isBase64Image(invalidBase64) == false);\n    }\n\n    SECTION(\"should return false for an empty string\") {\n        REQUIRE(isBase64Image(\"\") == false);\n    }\n\n    SECTION(\"should return false for a null input\") {\n        // Since we can't pass nullptr for a std::string, we can check with an empty string or modify the function to handle nullptr\n        REQUIRE(isBase64Image(\"\") == false);  // Adjust as necessary for null handling\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param imageData - The image data string to be validated.\n */\nbool isBase64Image(const std::string& imageData) {\n    \n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param imageData - The image data string to be validated.\n */\npublic static boolean isBase64Image(String imageData) {\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.real.temp.Answer.*;\n\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testValidPngBase64() {\n        String validPng = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\";\n        assertTrue(isBase64Image(validPng));\n    }\n\n    @Test\n    public void testValidJpegBase64() {\n        String validJpeg = \"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAAAAAA\";\n        assertTrue(isBase64Image(validJpeg));\n    }\n\n    @Test\n    public void testInvalidFormat() {\n        String invalidFormat = \"data:text/plain;base64,SGVsbG8gd29ybGQ=\";\n        assertFalse(isBase64Image(invalidFormat));\n    }\n\n    @Test\n    public void testInvalidBase64Characters() {\n        String invalidBase64 = \"data:image/png;base64,invalidBase64String@#%\";\n        assertFalse(isBase64Image(invalidBase64));\n    }\n\n    @Test\n    public void testEmptyString() {\n        assertFalse(isBase64Image(\"\"));\n    }\n\n    @Test\n    public void testNullInput() {\n        assertFalse(isBase64Image(null));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param imageData - The image data string to be validated.\n */\npublic static boolean isBase64Image(String imageData) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 107, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Finds the median of a given array of numbers.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef find_median(arr: List[int]) -> float:\n    \"\"\"\n    Finds the median of a given array of numbers.\n\n    Args:\n        arr (list of int): The array of numbers to find the median of.\n\n    Returns:\n        float: The median of the array.\n    \"\"\"\n", "test_code": "import random\nimport unittest\n\n\nclass TestFindMedian(unittest.TestCase):\n\n    # Test Case 1: Check median for large array\n    def test_large_array_median(self):\n        large_array = [random.randint(0, 9999) for _ in range(10001)]\n        median_large_array = find_median(large_array)\n        # Test passes if the median is a number\n        self.assertIsInstance(median_large_array, (int, float))\n\n    # Test Case 2: Odd number of elements\n    def test_odd_number_of_elements(self):\n        arr = [3, 1, 4, 1, 5, 9, 2]\n        median = find_median(arr)\n        self.assertEqual(median, 3)\n\n    # Test Case 3: Even number of elements\n    def test_even_number_of_elements(self):\n        arr = [10, 2, 3, 5, 7, 8]\n        median = find_median(arr)\n        self.assertEqual(median, 6)\n\n    # Test Case 4: Array with duplicate elements\n    def test_array_with_duplicates(self):\n        arr = [1, 2, 2, 2, 3]\n        median = find_median(arr)\n        self.assertEqual(median, 2)\n\n    # Test Case 5: Array with negative numbers\n    def test_array_with_negative_numbers(self):\n        arr = [-5, -10, 0, 5, 10]\n        median = find_median(arr)\n        self.assertEqual(median, 0)\n\n    # Test Case 6: Array with a single element\n    def test_single_element_array(self):\n        arr = [42]\n        median = find_median(arr)\n        self.assertEqual(median, 42)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_median(arr: List[int]) -> float:\n    \"\"\"\n    Finds the median of a given array of numbers.\n\n    Args:\n        arr (list of int): The array of numbers to find the median of.\n\n    Returns:\n        float: The median of the array.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Finds the median of a given array of numbers.\n * \n * @param {number[]} arr - The array of numbers to find the median of.\n * \n */\nfunction findMedian(arr) {\n\n}\n", "test_code": "describe('findMedian', () => {\n    // Example usage with a large array\n    test('should find the median of a large array with 10001 random elements', () => {\n        const largeArray = Array.from({ length: 10001 }, () => Math.floor(Math.random() * 10000));\n        const medianLargeArray = findMedian(largeArray);\n        // It's difficult to assert the exact median here due to randomness,\n        // but this test can check if the function completes without error\n        expect(typeof medianLargeArray).toBe('number');\n    });\n\n    // Test Case 1: Odd number of elements\n    test('should return 3 for an array with odd number of elements', () => {\n        const arr1 = [3, 1, 4, 1, 5, 9, 2];\n        const median1 = findMedian(arr1);\n        expect(median1).toBe(3);\n    });\n\n    // Test Case 2: Even number of elements\n    test('should return 6 for an array with even number of elements', () => {\n        const arr2 = [10, 2, 3, 5, 7, 8];\n        const median2 = findMedian(arr2);\n        expect(median2).toBe(6);\n    });\n\n    // Test Case 3: Array with duplicate elements\n    test('should return 2 for an array with duplicate elements', () => {\n        const arr3 = [1, 2, 2, 2, 3];\n        const median3 = findMedian(arr3);\n        expect(median3).toBe(2);\n    });\n\n    // Test Case 4: Array with negative numbers\n    test('should return 0 for an array with negative and positive numbers', () => {\n        const arr4 = [-5, -10, 0, 5, 10];\n        const median4 = findMedian(arr4);\n        expect(median4).toBe(0);\n    });\n\n    // Test Case 5: Array with a single element\n    test('should return the only element for an array with a single element', () => {\n        const arr5 = [42];\n        const median5 = findMedian(arr5);\n        expect(median5).toBe(42);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Finds the median of a given array of numbers.\n * \n * @param {number[]} arr - The array of numbers to find the median of.\n * \n */\nfunction findMedian(arr) {\n\n}\n", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Finds the median of a given array of numbers.\n * \n * @param {number[]} arr - The array of numbers to find the median of.\n * \n */\nfunction findMedian(arr: number[]): void {\n\n}", "test_code": "describe('findMedian', () => {\n    // Example usage with a large array\n    test('should find the median of a large array with 10001 random elements', () => {\n        const largeArray: number[] = Array.from({ length: 10001 }, () => Math.floor(Math.random() * 10000));\n        const medianLargeArray: number = findMedian(largeArray);\n        // It's difficult to assert the exact median here due to randomness,\n        // but this test can check if the function completes without error\n        expect(typeof medianLargeArray).toBe('number');\n    });\n\n    // Test Case 1: Odd number of elements\n    test('should return 3 for an array with odd number of elements', () => {\n        const arr1: number[] = [3, 1, 4, 1, 5, 9, 2];\n        const median1: number = findMedian(arr1);\n        expect(median1).toBe(3);\n    });\n\n    // Test Case 2: Even number of elements\n    test('should return 6 for an array with even number of elements', () => {\n        const arr2: number[] = [10, 2, 3, 5, 7, 8];\n        const median2: number = findMedian(arr2);\n        expect(median2).toBe(6);\n    });\n\n    // Test Case 3: Array with duplicate elements\n    test('should return 2 for an array with duplicate elements', () => {\n        const arr3: number[] = [1, 2, 2, 2, 3];\n        const median3: number = findMedian(arr3);\n        expect(median3).toBe(2);\n    });\n\n    // Test Case 4: Array with negative numbers\n    test('should return 0 for an array with negative and positive numbers', () => {\n        const arr4: number[] = [-5, -10, 0, 5, 10];\n        const median4: number = findMedian(arr4);\n        expect(median4).toBe(0);\n    });\n\n    // Test Case 5: Array with a single element\n    test('should return the only element for an array with a single element', () => {\n        const arr5: number[] = [42];\n        const median5: number = findMedian(arr5);\n        expect(median5).toBe(42);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Finds the median of a given array of numbers.\n * \n * @param {number[]} arr - The array of numbers to find the median of.\n * \n */\nfunction findMedian(arr: number[]): void {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Finds the median of a given array of numbers.\n * \n * @param arr - The vector of integers to find the median of.\n */\ndouble findMedian(std::vector<int>& arr) {\n\n}", "test_code": "TEST_CASE(\"findMedian\", \"[median]\") {\n    // Example usage with a large array\n    SECTION(\"should find the median of a large array with 10001 random elements\") {\n        std::vector<int> largeArray(10001);\n        std::generate(largeArray.begin(), largeArray.end(), []() {\n            return rand() % 10000; // Random number between 0 and 9999\n        });\n        double medianLargeArray = findMedian(largeArray);\n        // Check if the result is a number (not NaN)\n        REQUIRE(!std::isnan(medianLargeArray));\n    }\n\n    // Test Case 1: Odd number of elements\n    SECTION(\"should return 3 for an array with odd number of elements\") {\n        std::vector<int> arr1 = {3, 1, 4, 1, 5, 9, 2};\n        double median1 = findMedian(arr1);\n        REQUIRE(median1 == 3);\n    }\n\n    // Test Case 2: Even number of elements\n    SECTION(\"should return 6 for an array with even number of elements\") {\n        std::vector<int> arr2 = {10, 2, 3, 5, 7, 8};\n        double median2 = findMedian(arr2);\n        REQUIRE(median2 == 6);\n    }\n\n    // Test Case 3: Array with duplicate elements\n    SECTION(\"should return 2 for an array with duplicate elements\") {\n        std::vector<int> arr3 = {1, 2, 2, 2, 3};\n        double median3 = findMedian(arr3);\n        REQUIRE(median3 == 2);\n    }\n\n    // Test Case 4: Array with negative numbers\n    SECTION(\"should return 0 for an array with negative and positive numbers\") {\n        std::vector<int> arr4 = {-5, -10, 0, 5, 10};\n        double median4 = findMedian(arr4);\n        REQUIRE(median4 == 0);\n    }\n\n    // Test Case 5: Array with a single element\n    SECTION(\"should return the only element for an array with a single element\") {\n        std::vector<int> arr5 = {42};\n        double median5 = findMedian(arr5);\n        REQUIRE(median5 == 42);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Finds the median of a given array of numbers.\n * \n * @param arr - The vector of integers to find the median of.\n */\ndouble findMedian(std::vector<int>& arr) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds the median of a given array of numbers.\n * \n * @param arr - The array of numbers to find the median of.\n */\npublic static double findMedian(int[] arr) {\n    \n}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\nimport org.junit.Test;\n\npublic class Tester {\n\n\n    @Test\n    public void testFindMedianOddElements() {\n        // Test Case 1: Odd number of elements\n        int[] arr1 = {3, 1, 4, 1, 5, 9, 2};\n        double median1 = findMedian(arr1);\n        assertEquals(3, median1, 0.001);\n    }\n\n    @Test\n    public void testFindMedianEvenElements() {\n        // Test Case 2: Even number of elements\n        int[] arr2 = {10, 2, 3, 5, 7, 8};\n        double median2 = findMedian(arr2);\n        assertEquals(6, median2, 0.001);\n    }\n\n    @Test\n    public void testFindMedianDuplicates() {\n        // Test Case 3: Array with duplicate elements\n        int[] arr3 = {1, 2, 2, 2, 3};\n        double median3 = findMedian(arr3);\n        assertEquals(2, median3, 0.001);\n    }\n\n    @Test\n    public void testFindMedianNegativeNumbers() {\n        // Test Case 4: Array with negative numbers\n        int[] arr4 = {-5, -10, 0, 5, 10};\n        double median4 = findMedian(arr4);\n        assertEquals(0, median4, 0.001);\n    }\n\n    @Test\n    public void testFindMedianSingleElement() {\n        // Test Case 5: Array with a single element\n        int[] arr5 = {42};\n        double median5 = findMedian(arr5);\n        assertEquals(42, median5, 0.001);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds the median of a given array of numbers.\n * \n * @param arr - The array of numbers to find the median of.\n */\npublic static double findMedian(int[] arr) {\n    \n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 108, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Sort the images in ascending order based on their scores and return the reordered image score, name, and ID", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef reorder_data(image_scores: List[int], image_names: List[str], image_ids: List[str]) -> dict:\n    \"\"\"\n    Sort the images in ascending order based on their scores and return the reordered image score, name, and ID.\n\n    Args:\n        image_scores (list[int]): Array of image scores.\n        image_names (list[str]): Array of image names corresponding to the scores.\n        image_ids (list[str]): Array of image IDs corresponding to the scores.\n\n    Returns:\n        dict: A dictionary containing the sorted scores, names, and IDs.\n              For example: {'resultScores': sorted_scores, 'resultNames': sorted_names, 'resultIDs': sorted_ids}\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestReorderData(unittest.TestCase):\n    def test_reorder_scores_ascending(self):\n        imageScores = [90, 85, 95]\n        imageNames = [\"image1.png\", \"image2.png\", \"image3.png\"]\n        imageIDs = [\"id1\", \"id2\", \"id3\"]\n        result = reorder_data(imageScores, imageNames, imageIDs)\n        self.assertEqual(result['resultScores'], [85, 90, 95])\n        self.assertEqual(result['resultNames'], [\"image2.png\", \"image1.png\", \"image3.png\"])\n        self.assertEqual(result['resultIDs'], [\"id2\", \"id1\", \"id3\"])\n\n    def test_scores_already_in_order(self):\n        imageScores = [70, 75, 80]\n        imageNames = [\"imageA.png\", \"imageB.png\", \"imageC.png\"]\n        imageIDs = [\"idA\", \"idB\", \"idC\"]\n        result = reorder_data(imageScores, imageNames, imageIDs)\n        self.assertEqual(result['resultScores'], [70, 75, 80])\n        self.assertEqual(result['resultNames'], [\"imageA.png\", \"imageB.png\", \"imageC.png\"])\n        self.assertEqual(result['resultIDs'], [\"idA\", \"idB\", \"idC\"])\n\n    def test_single_element(self):\n        imageScores = [50]\n        imageNames = [\"imageSingle.png\"]\n        imageIDs = [\"idSingle\"]\n        result = reorder_data(imageScores, imageNames, imageIDs)\n        self.assertEqual(result['resultScores'], [50])\n        self.assertEqual(result['resultNames'], [\"imageSingle.png\"])\n        self.assertEqual(result['resultIDs'], [\"idSingle\"])\n\n    def test_empty_array(self):\n        imageScores = []\n        imageNames = []\n        imageIDs = []\n        result = reorder_data(imageScores, imageNames, imageIDs)\n        self.assertEqual(result['resultScores'], [])\n        self.assertEqual(result['resultNames'], [])\n        self.assertEqual(result['resultIDs'], [])\n\n    def test_duplicate_scores(self):\n        imageScores = [88, 88, 92]\n        imageNames = [\"image1.png\", \"image2.png\", \"image3.png\"]\n        imageIDs = [\"id1\", \"id2\", \"id3\"]\n        result = reorder_data(imageScores, imageNames, imageIDs)\n        self.assertEqual(result['resultScores'], [88, 88, 92])\n        self.assertEqual(result['resultNames'], [\"image1.png\", \"image2.png\", \"image3.png\"])\n        self.assertEqual(result['resultIDs'], [\"id1\", \"id2\", \"id3\"])", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef reorder_data(image_scores: List[int], image_names: List[str], image_ids: List[str]) -> dict:\n    \"\"\"\n    Sort the images in ascending order based on their scores and return the reordered image score, name, and ID.\n\n    Args:\n        image_scores (list[int]): Array of image scores.\n        image_names (list[str]): Array of image names corresponding to the scores.\n        image_ids (list[str]): Array of image IDs corresponding to the scores.\n\n    Returns:\n        dict: A dictionary containing the sorted scores, names, and IDs.\n              For example: {'resultScores': sorted_scores, 'resultNames': sorted_names, 'resultIDs': sorted_ids}\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param {number[]} imageScores - Array of image scores.\n * @param {string[]} imageNames - Array of image names corresponding to the scores.\n * @param {string[]} imageIDs - Array of image IDs corresponding to the scores.\n * @returns {Object} An object containing the sorted scores, names, and IDs.for example { resultScores, resultNames, resultIDs }\n */\nfunction reorderData(imageScores, imageNames, imageIDs) {\n\n}", "test_code": "describe('reorderData', () => {\n\n    test('should reorder the question based on scores in ascending order', () => {\n        const imageScores = [90, 85, 95];\n        const imageNames = [\"image1.png\", \"image2.png\", \"image3.png\"];\n        const imageIDs = [\"id1\", \"id2\", \"id3\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([85, 90, 95]);\n        expect(result.resultNames).toEqual([\"image2.png\", \"image1.png\", \"image3.png\"]);\n        expect(result.resultIDs).toEqual([\"id2\", \"id1\", \"id3\"]);\n    });\n\n    test('should return the same order if scores are already in ascending order', () => {\n        const imageScores = [70, 75, 80];\n        const imageNames = [\"imageA.png\", \"imageB.png\", \"imageC.png\"];\n        const imageIDs = [\"idA\", \"idB\", \"idC\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([70, 75, 80]);\n        expect(result.resultNames).toEqual([\"imageA.png\", \"imageB.png\", \"imageC.png\"]);\n        expect(result.resultIDs).toEqual([\"idA\", \"idB\", \"idC\"]);\n    });\n\n    test('should handle an array with only one element', () => {\n        const imageScores = [50];\n        const imageNames = [\"imageSingle.png\"];\n        const imageIDs = [\"idSingle\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([50]);\n        expect(result.resultNames).toEqual([\"imageSingle.png\"]);\n        expect(result.resultIDs).toEqual([\"idSingle\"]);\n    });\n\n    test('should handle an empty array', () => {\n        const imageScores = [];\n        const imageNames = [];\n        const imageIDs = [];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([]);\n        expect(result.resultNames).toEqual([]);\n        expect(result.resultIDs).toEqual([]);\n    });\n\n    test('should reorder correctly when there are duplicate scores', () => {\n        const imageScores = [88, 88, 92];\n        const imageNames = [\"image1.png\", \"image2.png\", \"image3.png\"];\n        const imageIDs = [\"id1\", \"id2\", \"id3\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([88, 88, 92]);\n        expect(result.resultNames).toEqual([\"image1.png\", \"image2.png\", \"image3.png\"]);\n        expect(result.resultIDs).toEqual([\"id1\", \"id2\", \"id3\"]);\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param {number[]} imageScores - Array of image scores.\n * @param {string[]} imageNames - Array of image names corresponding to the scores.\n * @param {string[]} imageIDs - Array of image IDs corresponding to the scores.\n * @returns {Object} An object containing the sorted scores, names, and IDs.for example { resultScores, resultNames, resultIDs }\n */\nfunction reorderData(imageScores, imageNames, imageIDs) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param {number[]} imageScores - Array of image scores.\n * @param {string[]} imageNames - Array of image names corresponding to the scores.\n * @param {string[]} imageIDs - Array of image IDs corresponding to the scores.\n * @returns {Object} An object containing the sorted scores, names, and IDs for example { resultScores, resultNames, resultIDs }\n */\nfunction reorderData(\n    imageScores: number[],\n    imageNames: string[],\n    imageIDs: string[]\n): { resultScores: number[]; resultNames: string[]; resultIDs: string[] } {\n\n}", "test_code": "describe('reorderData', () => {\n    test('should reorder the question based on scores in ascending order', () => {\n        const imageScores: number[] = [90, 85, 95];\n        const imageNames: string[] = [\"image1.png\", \"image2.png\", \"image3.png\"];\n        const imageIDs: string[] = [\"id1\", \"id2\", \"id3\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([85, 90, 95]);\n        expect(result.resultNames).toEqual([\"image2.png\", \"image1.png\", \"image3.png\"]);\n        expect(result.resultIDs).toEqual([\"id2\", \"id1\", \"id3\"]);\n    });\n\n    test('should return the same order if scores are already in ascending order', () => {\n        const imageScores: number[] = [70, 75, 80];\n        const imageNames: string[] = [\"imageA.png\", \"imageB.png\", \"imageC.png\"];\n        const imageIDs: string[] = [\"idA\", \"idB\", \"idC\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([70, 75, 80]);\n        expect(result.resultNames).toEqual([\"imageA.png\", \"imageB.png\", \"imageC.png\"]);\n        expect(result.resultIDs).toEqual([\"idA\", \"idB\", \"idC\"]);\n    });\n\n    test('should handle an array with only one element', () => {\n        const imageScores: number[] = [50];\n        const imageNames: string[] = [\"imageSingle.png\"];\n        const imageIDs: string[] = [\"idSingle\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([50]);\n        expect(result.resultNames).toEqual([\"imageSingle.png\"]);\n        expect(result.resultIDs).toEqual([\"idSingle\"]);\n    });\n\n    test('should handle an empty array', () => {\n        const imageScores: number[] = [];\n        const imageNames: string[] = [];\n        const imageIDs: string[] = [];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([]);\n        expect(result.resultNames).toEqual([]);\n        expect(result.resultIDs).toEqual([]);\n    });\n\n    test('should reorder correctly when there are duplicate scores', () => {\n        const imageScores: number[] = [88, 88, 92];\n        const imageNames: string[] = [\"image1.png\", \"image2.png\", \"image3.png\"];\n        const imageIDs: string[] = [\"id1\", \"id2\", \"id3\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([88, 88, 92]);\n        expect(result.resultNames).toEqual([\"image1.png\", \"image2.png\", \"image3.png\"]);\n        expect(result.resultIDs).toEqual([\"id1\", \"id2\", \"id3\"]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param {number[]} imageScores - Array of image scores.\n * @param {string[]} imageNames - Array of image names corresponding to the scores.\n * @param {string[]} imageIDs - Array of image IDs corresponding to the scores.\n * @returns {Object} An object containing the sorted scores, names, and IDs for example { resultScores, resultNames, resultIDs }\n */\nfunction reorderData(\n    imageScores: number[],\n    imageNames: string[],\n    imageIDs: string[]\n): { resultScores: number[]; resultNames: string[]; resultIDs: string[] } {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param const std::vector<int>& imageScores - Array of image scores.\n * @param const std::vector<std::string>& imageNames - Array of image names corresponding to the scores.\n * @param const std::vector<std::string>& imageIDs - Array of image IDs corresponding to the scores.\n * @returns std::tuple<std::vector<int>, std::vector<std::string>, std::vector<std::string>> - A tuple containing the sorted scores, names, and IDs.\n */\nstd::tuple<std::vector<int>, std::vector<std::string>, std::vector<std::string>> reorderData(\n\n) {\n\n}", "test_code": "TEST_CASE(\"reorderData\") {\n\n    SECTION(\"should reorder the question based on scores in ascending order\") {\n        std::vector<int> imageScores = {90, 85, 95};\n        std::vector<std::string> imageNames = {\"image1.png\", \"image2.png\", \"image3.png\"};\n        std::vector<std::string> imageIDs = {\"id1\", \"id2\", \"id3\"};\n\n        auto [resultScores, resultNames, resultIDs] = reorderData(imageScores, imageNames, imageIDs);\n\n        REQUIRE(resultScores == std::vector<int>{85, 90, 95});\n        REQUIRE(resultNames == std::vector<std::string>{\"image2.png\", \"image1.png\", \"image3.png\"});\n        REQUIRE(resultIDs == std::vector<std::string>{\"id2\", \"id1\", \"id3\"});\n    }\n\n    SECTION(\"should return the same order if scores are already in ascending order\") {\n        std::vector<int> imageScores = {70, 75, 80};\n        std::vector<std::string> imageNames = {\"imageA.png\", \"imageB.png\", \"imageC.png\"};\n        std::vector<std::string> imageIDs = {\"idA\", \"idB\", \"idC\"};\n\n        auto [resultScores, resultNames, resultIDs] = reorderData(imageScores, imageNames, imageIDs);\n\n        REQUIRE(resultScores == std::vector<int>{70, 75, 80});\n        REQUIRE(resultNames == std::vector<std::string>{\"imageA.png\", \"imageB.png\", \"imageC.png\"});\n        REQUIRE(resultIDs == std::vector<std::string>{\"idA\", \"idB\", \"idC\"});\n    }\n\n    SECTION(\"should handle an array with only one element\") {\n        std::vector<int> imageScores = {50};\n        std::vector<std::string> imageNames = {\"imageSingle.png\"};\n        std::vector<std::string> imageIDs = {\"idSingle\"};\n\n        auto [resultScores, resultNames, resultIDs] = reorderData(imageScores, imageNames, imageIDs);\n\n        REQUIRE(resultScores == std::vector<int>{50});\n        REQUIRE(resultNames == std::vector<std::string>{\"imageSingle.png\"});\n        REQUIRE(resultIDs == std::vector<std::string>{\"idSingle\"});\n    }\n\n    SECTION(\"should handle an empty array\") {\n        std::vector<int> imageScores = {};\n        std::vector<std::string> imageNames = {};\n        std::vector<std::string> imageIDs = {};\n\n        auto [resultScores, resultNames, resultIDs] = reorderData(imageScores, imageNames, imageIDs);\n\n        REQUIRE(resultScores == std::vector<int>{});\n        REQUIRE(resultNames == std::vector<std::string>{});\n        REQUIRE(resultIDs == std::vector<std::string>{});\n    }\n\n    SECTION(\"should reorder correctly when there are duplicate scores\") {\n        std::vector<int> imageScores = {88, 88, 92};\n        std::vector<std::string> imageNames = {\"image1.png\", \"image2.png\", \"image3.png\"};\n        std::vector<std::string> imageIDs = {\"id1\", \"id2\", \"id3\"};\n\n        auto [resultScores, resultNames, resultIDs] = reorderData(imageScores, imageNames, imageIDs);\n\n        REQUIRE(resultScores == std::vector<int>{88, 88, 92});\n        REQUIRE(resultNames == std::vector<std::string>{\"image1.png\", \"image2.png\", \"image3.png\"});\n        REQUIRE(resultIDs == std::vector<std::string>{\"id1\", \"id2\", \"id3\"});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param const std::vector<int>& imageScores - Array of image scores.\n * @param const std::vector<std::string>& imageNames - Array of image names corresponding to the scores.\n * @param const std::vector<std::string>& imageIDs - Array of image IDs corresponding to the scores.\n * @returns std::tuple<std::vector<int>, std::vector<std::string>, std::vector<std::string>> - A tuple containing the sorted scores, names, and IDs.\n */\nstd::tuple<std::vector<int>, std::vector<std::string>, std::vector<std::string>> reorderData(\n\n) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param imageScores Array of image scores.\n * @param imageNames Array of image names corresponding to the scores.\n * @param imageIDs Array of image IDs corresponding to the scores.\n * @return A map containing the sorted scores, names, and IDs, for example { \"resultScores\", \"resultNames\", \"resultIDs\" }\n */\npublic Map<String, Object> reorderData(int[] imageScores, String[] imageNames, String[] imageIDs) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.Map;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testReorderData_ShouldReorderBasedOnScoresInAscendingOrder() {\n        int[] imageScores = {90, 85, 95};\n        String[] imageNames = {\"image1.png\", \"image2.png\", \"image3.png\"};\n        String[] imageIDs = {\"id1\", \"id2\", \"id3\"};\n\n        Map<String, Object> result = reorderData(imageScores, imageNames, imageIDs);\n\n        assertArrayEquals(new int[]{85, 90, 95}, (int[]) result.get(\"resultScores\"));\n        assertArrayEquals(new String[]{\"image2.png\", \"image1.png\", \"image3.png\"}, (String[]) result.get(\"resultNames\"));\n        assertArrayEquals(new String[]{\"id2\", \"id1\", \"id3\"}, (String[]) result.get(\"resultIDs\"));\n    }\n\n    @Test\n    public void testReorderData_ShouldReturnSameOrderIfScoresAlreadyAscending() {\n        int[] imageScores = {70, 75, 80};\n        String[] imageNames = {\"imageA.png\", \"imageB.png\", \"imageC.png\"};\n        String[] imageIDs = {\"idA\", \"idB\", \"idC\"};\n\n        Map<String, Object> result = reorderData(imageScores, imageNames, imageIDs);\n\n        assertArrayEquals(new int[]{70, 75, 80}, (int[]) result.get(\"resultScores\"));\n        assertArrayEquals(new String[]{\"imageA.png\", \"imageB.png\", \"imageC.png\"}, (String[]) result.get(\"resultNames\"));\n        assertArrayEquals(new String[]{\"idA\", \"idB\", \"idC\"}, (String[]) result.get(\"resultIDs\"));\n    }\n\n    @Test\n    public void testReorderData_ShouldHandleSingleElementArray() {\n        int[] imageScores = {50};\n        String[] imageNames = {\"imageSingle.png\"};\n        String[] imageIDs = {\"idSingle\"};\n\n        Map<String, Object> result = reorderData(imageScores, imageNames, imageIDs);\n\n        assertArrayEquals(new int[]{50}, (int[]) result.get(\"resultScores\"));\n        assertArrayEquals(new String[]{\"imageSingle.png\"}, (String[]) result.get(\"resultNames\"));\n        assertArrayEquals(new String[]{\"idSingle\"}, (String[]) result.get(\"resultIDs\"));\n    }\n\n    @Test\n    public void testReorderData_ShouldHandleEmptyArray() {\n        int[] imageScores = {};\n        String[] imageNames = {};\n        String[] imageIDs = {};\n\n        Map<String, Object> result = reorderData(imageScores, imageNames, imageIDs);\n\n        assertArrayEquals(new int[]{}, (int[]) result.get(\"resultScores\"));\n        assertArrayEquals(new String[]{}, (String[]) result.get(\"resultNames\"));\n        assertArrayEquals(new String[]{}, (String[]) result.get(\"resultIDs\"));\n    }\n\n    @Test\n    public void testReorderData_ShouldReorderCorrectlyWithDuplicateScores() {\n        int[] imageScores = {88, 88, 92};\n        String[] imageNames = {\"image1.png\", \"image2.png\", \"image3.png\"};\n        String[] imageIDs = {\"id1\", \"id2\", \"id3\"};\n\n        Map<String, Object> result = reorderData(imageScores, imageNames, imageIDs);\n\n        assertArrayEquals(new int[]{88, 88, 92}, (int[]) result.get(\"resultScores\"));\n        assertArrayEquals(new String[]{\"image1.png\", \"image2.png\", \"image3.png\"}, (String[]) result.get(\"resultNames\"));\n        assertArrayEquals(new String[]{\"id1\", \"id2\", \"id3\"}, (String[]) result.get(\"resultIDs\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param imageScores Array of image scores.\n * @param imageNames Array of image names corresponding to the scores.\n * @param imageIDs Array of image IDs corresponding to the scores.\n * @return A map containing the sorted scores, names, and IDs, for example { \"resultScores\", \"resultNames\", \"resultIDs\" }\n */\npublic Map<String, Object> reorderData(int[] imageScores, String[] imageNames, String[] imageIDs) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 109, "code_type": "method", "original_language": "javascript", "question_type": "Algorithm and data structure", "summary": "Returns the object from the list with the given ID, or null if it is not present", "language_version_list": {"python": {"code_signature": "from typing import Union, List, Dict, Optional\n\n\ndef get_object_by_id(id: Union[str, int], obj_list: List[Dict]) -> Optional[Dict]:\n    \"\"\"\n    Returns the object from the list with the given ID, or None if it is not present.\n\n    Args:\n        id (Union[str, int]): The `id` to search for in the list.\n        obj_list (List[Dict]): The list of objects to search through.\n\n    Returns:\n        Optional[Dict]: The object with the matching `id`, or None if no match is found.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGetObjectById(unittest.TestCase):\n\n    def test_should_return_object_with_matching_id(self):\n        obj_list = [\n            {'id': 1, 'name': 'Object 1'},\n            {'id': 2, 'name': 'Object 2'},\n            {'id': 3, 'name': 'Object 3'}\n        ]\n        result = get_object_by_id(2, obj_list)\n        self.assertEqual(result, {'id': 2, 'name': 'Object 2'})\n\n    def test_should_return_none_if_no_object_with_matching_id(self):\n        obj_list = [\n            {'id': 1, 'name': 'Object 1'},\n            {'id': 2, 'name': 'Object 2'},\n            {'id': 3, 'name': 'Object 3'}\n        ]\n        result = get_object_by_id(4, obj_list)\n        self.assertIsNone(result)\n\n    def test_should_return_none_if_list_is_empty(self):\n        obj_list = []\n        result = get_object_by_id(1, obj_list)\n        self.assertIsNone(result)\n\n    def test_should_return_none_if_objects_do_not_have_id_property(self):\n        obj_list = [\n            {'name': 'Object 1'},\n            {'name': 'Object 2'},\n            {'name': 'Object 3'}\n        ]\n        result = get_object_by_id(1, obj_list)\n        self.assertIsNone(result)\n\n    def test_should_return_correct_object_when_id_is_string(self):\n        obj_list = [\n            {'id': 'a', 'name': 'Object A'},\n            {'id': 'b', 'name': 'Object B'},\n            {'id': 'c', 'name': 'Object C'}\n        ]\n        result = get_object_by_id('b', obj_list)\n        self.assertEqual(result, {'id': 'b', 'name': 'Object B'})\n", "prompt": "please write a python function , the function signature as below from typing import Union, List, Dict, Optional\n\n\ndef get_object_by_id(id: Union[str, int], obj_list: List[Dict]) -> Optional[Dict]:\n    \"\"\"\n    Returns the object from the list with the given ID, or None if it is not present.\n\n    Args:\n        id (Union[str, int]): The `id` to search for in the list.\n        obj_list (List[Dict]): The list of objects to search through.\n\n    Returns:\n        Optional[Dict]: The object with the matching `id`, or None if no match is found.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Returns the object from the list with the given ID, or null if it is not present\n *\n * @param {string|number} id - The `id` to search for in the list.\n * @param {Array<Object>} list - The list of objects to search through.\n * @returns {Object|null} The object with the matching `id`, or `null` if no match is found.\n */\nfunction getObjectById(id, list) {\n\n}", "test_code": "describe('getObjectById', () => {\n\n    test('should return the object with the matching id', () => {\n        const list = [\n            { id: 1, name: 'Object 1' },\n            { id: 2, name: 'Object 2' },\n            { id: 3, name: 'Object 3' }\n        ];\n        const result = getObjectById(2, list);\n        expect(result).toEqual({ id: 2, name: 'Object 2' });\n    });\n\n    test('should return null if no object with the matching id is found', () => {\n        const list = [\n            { id: 1, name: 'Object 1' },\n            { id: 2, name: 'Object 2' },\n            { id: 3, name: 'Object 3' }\n        ];\n        const result = getObjectById(4, list);\n        expect(result).toBeNull();\n    });\n\n    test('should return null if the list is empty', () => {\n        const list = [];\n        const result = getObjectById(1, list);\n        expect(result).toBeNull();\n    });\n\n    test('should return null if objects in the list do not have an id property', () => {\n        const list = [\n            { name: 'Object 1' },\n            { name: 'Object 2' },\n            { name: 'Object 3' }\n        ];\n        const result = getObjectById(1, list);\n        expect(result).toBeNull();\n    });\n\n    test('should return the correct object when id is a string', () => {\n        const list = [\n            { id: 'a', name: 'Object A' },\n            { id: 'b', name: 'Object B' },\n            { id: 'c', name: 'Object C' }\n        ];\n        const result = getObjectById('b', list);\n        expect(result).toEqual({ id: 'b', name: 'Object B' });\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Returns the object from the list with the given ID, or null if it is not present\n *\n * @param {string|number} id - The `id` to search for in the list.\n * @param {Array<Object>} list - The list of objects to search through.\n * @returns {Object|null} The object with the matching `id`, or `null` if no match is found.\n */\nfunction getObjectById(id, list) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Returns the object from the list with the given ID, or null if it is not present.\n *\n * @param {string | number} id - The `id` to search for in the list.\n * @param {Array<Record<string, any>>} list - The list of objects to search through.\n * @returns {Record<string, any> | null} The object with the matching `id`, or `null` if no match is found.\n */\nfunction getObjectById(id: string | number, list: Array<Record<string, any>>): Record<string, any> | null {\n\n}", "test_code": "describe('getObjectById', () => {\n    test('should return the object with the matching id', () => {\n        const list: Array<{ id: number; name: string }> = [\n            { id: 1, name: 'Object 1' },\n            { id: 2, name: 'Object 2' },\n            { id: 3, name: 'Object 3' }\n        ];\n        const result = getObjectById(2, list);\n        expect(result).toEqual({ id: 2, name: 'Object 2' });\n    });\n\n    test('should return null if no object with the matching id is found', () => {\n        const list: Array<{ id: number; name: string }> = [\n            { id: 1, name: 'Object 1' },\n            { id: 2, name: 'Object 2' },\n            { id: 3, name: 'Object 3' }\n        ];\n        const result = getObjectById(4, list);\n        expect(result).toBeNull();\n    });\n\n    test('should return null if the list is empty', () => {\n        const list: Array<{ id: number; name: string }> = [];\n        const result = getObjectById(1, list);\n        expect(result).toBeNull();\n    });\n\n    test('should return null if objects in the list do not have an id property', () => {\n        const list: Array<{ name: string }> = [\n            { name: 'Object 1' },\n            { name: 'Object 2' },\n            { name: 'Object 3' }\n        ];\n        const result = getObjectById(1, list);\n        expect(result).toBeNull();\n    });\n\n    test('should return the correct object when id is a string', () => {\n        const list: Array<{ id: string; name: string }> = [\n            { id: 'a', name: 'Object A' },\n            { id: 'b', name: 'Object B' },\n            { id: 'c', name: 'Object C' }\n        ];\n        const result = getObjectById('b', list);\n        expect(result).toEqual({ id: 'b', name: 'Object B' });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Returns the object from the list with the given ID, or null if it is not present.\n *\n * @param {string | number} id - The `id` to search for in the list.\n * @param {Array<Record<string, any>>} list - The list of objects to search through.\n * @returns {Record<string, any> | null} The object with the matching `id`, or `null` if no match is found.\n */\nfunction getObjectById(id: string | number, list: Array<Record<string, any>>): Record<string, any> | null {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 110, "code_type": "method", "original_language": "javascript", "question_type": "Algorithm and data structure", "summary": "Generate a random UUID of length 36", "language_version_list": {"python": {"code_signature": "def generate_uuid() -> str:\n    \"\"\"\n    Generate a random UUID of length 36.\n\n    The UUID contains at least one uppercase letter, at least one lowercase letter, and at least one digit.\n\n    Returns:\n        str: A 36-character UUID string.\n    \"\"\"", "test_code": "import re\nimport unittest\n\n\nclass TestGenerateUUID(unittest.TestCase):\n\n    def test_should_return_a_string(self):\n        result = generate_uuid()\n        self.assertIsInstance(result, str)\n\n    def test_should_return_a_string_of_length_36(self):\n        result = generate_uuid()\n        self.assertEqual(len(result), 36)\n\n    def test_should_generate_different_UUIDs_on_consecutive_calls(self):\n        uuid1 = generate_uuid()\n        uuid2 = generate_uuid()\n        self.assertNotEqual(uuid1, uuid2)\n\n    def test_should_generate_UUIDs_that_include_uppercase(self):\n        result = generate_uuid()\n        self.assertTrue(re.search(r'[A-Z]', result) is not None)  # At least one uppercase letter\n\n    def test_should_generate_UUIDs_that_include_lowercase(self):\n        result = generate_uuid()\n        self.assertTrue(re.search(r'[a-z]', result) is not None)  # At least one lowercase letter\n\n    def test_should_generate_UUIDs_that_include_digits(self):\n        result = generate_uuid()\n        self.assertTrue(re.search(r'[0-9]', result) is not None)  # At least one digit\n", "prompt": "please write a python function , the function signature as below def generate_uuid() -> str:\n    \"\"\"\n    Generate a random UUID of length 36.\n\n    The UUID contains at least one uppercase letter, at least one lowercase letter, and at least one digit.\n\n    Returns:\n        str: A 36-character UUID string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Generate a random UUID of length 36\n * The UUID At least one uppercase letter,At least one lowercase letter,At least one digit\n *\n * @returns {string} A 36-character UUID string.\n */\nfunction generateUUID() {\n\n}", "test_code": "describe('generateUUID', () => {\n\n    test('should return a string', () => {\n        const result = generateUUID();\n        expect(typeof result).toBe('string');\n    });\n\n    test('should return a string of length 36', () => {\n        const result = generateUUID();\n        expect(result.length).toBe(36);\n    });\n\n\n    test('should generate different UUIDs on consecutive calls', () => {\n        const uuid1 = generateUUID();\n        const uuid2 = generateUUID();\n        expect(uuid1).not.toBe(uuid2);\n    });\n\n    test('should generate UUIDs that include uppercase', () => {\n        const result = generateUUID();\n        expect(/[A-Z]/.test(result)).toBe(true); // At least one uppercase letter\n    });\n    test('should generate UUIDs that include  lowercase letters', () => {\n        const result = generateUUID();\n        expect(/[a-z]/.test(result)).toBe(true); // At least one lowercase letter\n    });\n    test('should generate UUIDs that include digits', () => {\n        const result = generateUUID();\n        expect(/[0-9]/.test(result)).toBe(true); // At least one digit\n    });\n\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Generate a random UUID of length 36\n * The UUID At least one uppercase letter,At least one lowercase letter,At least one digit\n *\n * @returns {string} A 36-character UUID string.\n */\nfunction generateUUID() {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Generate a random UUID of length 36\n * The UUID has at least one uppercase letter, one lowercase letter, and one digit.\n *\n * @returns {string} A 36-character UUID string.\n */\nfunction generateUUID(): string {\n\n}", "test_code": "describe('generateUUID', () => {\n\n    test('should return a string', () => {\n        const result: string = generateUUID();\n        expect(typeof result).toBe('string');\n    });\n\n    test('should return a string of length 36', () => {\n        const result: string = generateUUID();\n        expect(result.length).toBe(36);\n    });\n\n    test('should generate different UUIDs on consecutive calls', () => {\n        const uuid1: string = generateUUID();\n        const uuid2: string = generateUUID();\n        expect(uuid1).not.toBe(uuid2);\n    });\n\n    test('should generate UUIDs that include uppercase', () => {\n        const result: string = generateUUID();\n        expect(/[A-Z]/.test(result)).toBe(true); // At least one uppercase letter\n    });\n\n    test('should generate UUIDs that include lowercase letters', () => {\n        const result: string = generateUUID();\n        expect(/[a-z]/.test(result)).toBe(true); // At least one lowercase letter\n    });\n\n    test('should generate UUIDs that include digits', () => {\n        const result: string = generateUUID();\n        expect(/[0-9]/.test(result)).toBe(true); // At least one digit\n    });\n\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Generate a random UUID of length 36\n * The UUID has at least one uppercase letter, one lowercase letter, and one digit.\n *\n * @returns {string} A 36-character UUID string.\n */\nfunction generateUUID(): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Generate a random UUID of length 36\n * The UUID contains at least one uppercase letter, at least one lowercase letter, and at least one digit\n *\n * @returns A 36-character UUID string.\n */\nstd::string generateUUID() {\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n#include <regex>\n\n// Assume generateUUID() is defined elsewhere\n\nTEST_CASE(\"generateUUID\") {\n\n    SECTION(\"should return a string\") {\n        std::string result = generateUUID();\n        REQUIRE(!result.empty());\n    }\n\n    SECTION(\"should return a string of length 36\") {\n        std::string result = generateUUID();\n        REQUIRE(result.length() == 36);\n    }\n\n    SECTION(\"should generate different UUIDs on consecutive calls\") {\n        std::string uuid1 = generateUUID();\n        std::string uuid2 = generateUUID();\n        REQUIRE(uuid1 != uuid2);\n    }\n\n    SECTION(\"should generate UUIDs that include uppercase\") {\n        std::string result = generateUUID();\n        REQUIRE(std::regex_search(result, std::regex(\"[A-Z]\"))); // At least one uppercase letter\n    }\n\n    SECTION(\"should generate UUIDs that include lowercase letters\") {\n        std::string result = generateUUID();\n        REQUIRE(std::regex_search(result, std::regex(\"[a-z]\"))); // At least one lowercase letter\n    }\n\n    SECTION(\"should generate UUIDs that include digits\") {\n        std::string result = generateUUID();\n        REQUIRE(std::regex_search(result, std::regex(\"[0-9]\"))); // At least one digit\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Generate a random UUID of length 36\n * The UUID contains at least one uppercase letter, at least one lowercase letter, and at least one digit\n *\n * @returns A 36-character UUID string.\n */\nstd::string generateUUID() {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Generate a random UUID of length 36\n * The UUID includes at least one uppercase letter, one lowercase letter, and one digit.\n *\n * @return A 36-character UUID string.\n */\npublic static String generateUUID() {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testGenerateUUIDShouldReturnAString() {\n        String result = generateUUID();\n        assertTrue(result instanceof String);\n    }\n\n    @Test\n    public void testGenerateUUIDShouldReturnStringOfLength36() {\n        String result = generateUUID();\n        assertEquals(36, result.length());\n    }\n\n    @Test\n    public void testGenerateUUIDShouldGenerateDifferentUUIDsOnConsecutiveCalls() {\n        String uuid1 = generateUUID();\n        String uuid2 = generateUUID();\n        assertNotEquals(uuid1, uuid2);\n    }\n\n    @Test\n    public void testGenerateUUIDShouldIncludeUppercase() {\n        String result = generateUUID();\n        assertTrue(result.matches(\".*[A-Z].*\")); // At least one uppercase letter\n    }\n\n    @Test\n    public void testGenerateUUIDShouldIncludeLowercase() {\n        String result = generateUUID();\n        assertTrue(result.matches(\".*[a-z].*\")); // At least one lowercase letter\n    }\n\n    @Test\n    public void testGenerateUUIDShouldIncludeDigits() {\n        String result = generateUUID();\n        assertTrue(result.matches(\".*[0-9].*\")); // At least one digit\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Generate a random UUID of length 36\n * The UUID includes at least one uppercase letter, one lowercase letter, and one digit.\n *\n * @return A 36-character UUID string.\n */\npublic static String generateUUID() {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 111, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Convert the chat logs to Markdown format and generate a Blob object containing them", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Convert the chat logs to Markdown format and generate a Blob object containing them\n *\n * @param {string[]} chat - The chat conversation as an array of strings.\n * @param {string} [title=\"ChatGPT Conversation\"] - The optional title for the conversation.\n * @returns {Blob} A Blob containing the Markdown formatted string of the conversation.\n */\nfunction convertChatToMarkdown(chat, title = \"ChatGPT Conversation\") {\n\n}", "test_code": "describe('convertChatToMarkdown', () => {\n\n    test('should include the default title when no title is provided', () => {\n        const chat = [\"Hello\", \"Hi there!\"];\n        const blob = convertChatToMarkdown(chat);\n        const expectedStart = \"# ChatGPT Conversation\\n\\n**Human:**\\nHello\\n\\n***\\n\\n**Assistant:**\\nHi there!\\n\\n***\\n\\nExported on \";\n        return blob.text().then(text => {\n            expect(text.startsWith(expectedStart)).toBe(true);\n        });\n    });\n\n    test('should include the custom title when a title is provided', () => {\n        const chat = [\"How are you?\", \"I'm doing well, thank you!\"];\n        const title = \"Friendly Chat\";\n        const blob = convertChatToMarkdown(chat, title);\n        const expectedStart = \"# Friendly Chat\\n\\n**Human:**\\nHow are you?\\n\\n***\\n\\n**Assistant:**\\nI'm doing well, thank you!\\n\\n***\\n\\nExported on \";\n        return blob.text().then(text => {\n            expect(text.startsWith(expectedStart)).toBe(true);\n        });\n    });\n\n    test('should correctly alternate speakers between Human and Assistant', () => {\n        const chat = [\"Question?\", \"Answer.\", \"Another question?\", \"Another answer.\"];\n        const blob = convertChatToMarkdown(chat);\n        const expectedContent = `**Human:**\\nQuestion?\\n\\n***\\n\\n**Assistant:**\\nAnswer.\\n\\n***\\n\\n**Human:**\\nAnother question?\\n\\n***\\n\\n**Assistant:**\\nAnother answer.\\n\\n***\\n\\nExported on `;\n        return blob.text().then(text => {\n            expect(text.includes(expectedContent)).toBe(true);\n        });\n    });\n\n    test('should include the correct timestamp using getDate and getTime', () => {\n        const chat = [\"What's the time?\", \"It's now.\"];\n        const mockedDate = new Date(\"2024-01-01 12:00:00\");\n        global.Date = jest.fn(() => mockedDate);\n\n        const blob = convertChatToMarkdown(chat);\n        const expectedEnd = `Exported on 2024-01-01 12:00:00.`;\n        return blob.text().then(text => {\n            expect(text.endsWith(expectedEnd)).toBe(true);\n        });\n    });\n\n    test('should return a Blob of type text/markdown', () => {\n        const chat = [\"This is a test.js.\", \"Yes, it is.\"];\n        const blob = convertChatToMarkdown(chat);\n        expect(blob.type).toBe('text/markdown');\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Convert the chat logs to Markdown format and generate a Blob object containing them\n *\n * @param {string[]} chat - The chat conversation as an array of strings.\n * @param {string} [title=\"ChatGPT Conversation\"] - The optional title for the conversation.\n * @returns {Blob} A Blob containing the Markdown formatted string of the conversation.\n */\nfunction convertChatToMarkdown(chat, title = \"ChatGPT Conversation\") {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 112, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Convert H1-H6 tags in HTML to corresponding paragraphs 1 through 6 in markdown, for example h1 xxx to # xxx", "language_version_list": {"python": {"code_signature": "def convert_html_headings_to_markdown(html: str) -> str:\n    \"\"\"\n    Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n\n    Args:\n        html (str): The HTML string containing headings.\n\n    Returns:\n        str: The converted Markdown string.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestConvertHtmlHeadingsToMarkdown(unittest.TestCase):\n\n    def test_convert_h1_to_markdown(self):\n        input_html = '<h1>This is a Heading 1</h1>'\n        expected_output = '# This is a Heading 1'\n        self.assertEqual(convert_html_headings_to_markdown(input_html), expected_output)\n\n    def test_convert_h2_to_markdown(self):\n        input_html = '<h2>This is a Heading 2</h2>'\n        expected_output = '## This is a Heading 2'\n        self.assertEqual(convert_html_headings_to_markdown(input_html), expected_output)\n\n    def test_convert_h3_to_markdown(self):\n        input_html = '<h3>This is a Heading 3</h3>'\n        expected_output = '### This is a Heading 3'\n        self.assertEqual(convert_html_headings_to_markdown(input_html), expected_output)\n\n    def test_convert_h4_to_markdown(self):\n        input_html = '<h4>This is a Heading 4</h4>'\n        expected_output = '#### This is a Heading 4'\n        self.assertEqual(convert_html_headings_to_markdown(input_html), expected_output)\n\n    def test_convert_h5_to_markdown(self):\n        input_html = '<h5>This is a Heading 5</h5>'\n        expected_output = '##### This is a Heading 5'\n        self.assertEqual(convert_html_headings_to_markdown(input_html), expected_output)\n\n    def test_convert_h6_to_markdown(self):\n        input_html = '<h6>This is a Heading 6</h6>'\n        expected_output = '###### This is a Heading 6'\n        self.assertEqual(convert_html_headings_to_markdown(input_html), expected_output)\n", "prompt": "please write a python function , the function signature as below def convert_html_headings_to_markdown(html: str) -> str:\n    \"\"\"\n    Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n\n    Args:\n        html (str): The HTML string containing headings.\n\n    Returns:\n        str: The converted Markdown string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n *\n * @param {string} html - The HTML string containing headings.\n * @returns {string} - The converted Markdown string.\n */\nfunction convertHtmlHeadingsToMarkdown(html) {}", "test_code": "describe('convertHtmlHeadingsToMarkdown', () => {\n    test('should convert <h1> to #', () => {\n        const input = '<h1>This is a Heading 1</h1>';\n        const output = '# This is a Heading 1';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h2> to ##', () => {\n        const input = '<h2>This is a Heading 2</h2>';\n        const output = '## This is a Heading 2';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h3> to ###', () => {\n        const input = '<h3>This is a Heading 3</h3>';\n        const output = '### This is a Heading 3';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h4> to ####', () => {\n        const input = '<h4>This is a Heading 4</h4>';\n        const output = '#### This is a Heading 4';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h5> to #####', () => {\n        const input = '<h5>This is a Heading 5</h5>';\n        const output = '##### This is a Heading 5';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h6> to ######', () => {\n        const input = '<h6>This is a Heading 6</h6>';\n        const output = '###### This is a Heading 6';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n *\n * @param {string} html - The HTML string containing headings.\n * @returns {string} - The converted Markdown string.\n */\nfunction convertHtmlHeadingsToMarkdown(html) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n *\n * @param {string} html - The HTML string containing headings.\n * @returns {string} - The converted Markdown string.\n */\nfunction convertHtmlHeadingsToMarkdown(html: string): string {\n\n}", "test_code": "describe('convertHtmlHeadingsToMarkdown', () => {\n    test('should convert <h1> to #', () => {\n        const input: string = '<h1>This is a Heading 1</h1>';\n        const output: string = '# This is a Heading 1';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h2> to ##', () => {\n        const input: string = '<h2>This is a Heading 2</h2>';\n        const output: string = '## This is a Heading 2';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h3> to ###', () => {\n        const input: string = '<h3>This is a Heading 3</h3>';\n        const output: string = '### This is a Heading 3';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h4> to ####', () => {\n        const input: string = '<h4>This is a Heading 4</h4>';\n        const output: string = '#### This is a Heading 4';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h5> to #####', () => {\n        const input: string = '<h5>This is a Heading 5</h5>';\n        const output: string = '##### This is a Heading 5';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h6> to ######', () => {\n        const input: string = '<h6>This is a Heading 6</h6>';\n        const output: string = '###### This is a Heading 6';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n *\n * @param {string} html - The HTML string containing headings.\n * @returns {string} - The converted Markdown string.\n */\nfunction convertHtmlHeadingsToMarkdown(html: string): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n *\n * @param html - The HTML string containing headings.\n * @returns The converted Markdown string.\n */\nstd::string convertHtmlHeadingsToMarkdown(const std::string& html){\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\n// Function prototype (assuming it's defined elsewhere)\nstd::string convertHtmlHeadingsToMarkdown(const std::string& html);\n\nTEST_CASE(\"convertHtmlHeadingsToMarkdown\") {\n    SECTION(\"should convert <h1> to #\") {\n        std::string input = \"<h1>This is a Heading 1</h1>\";\n        std::string output = \"# This is a Heading 1\";\n        REQUIRE(convertHtmlHeadingsToMarkdown(input) == output);\n    }\n\n    SECTION(\"should convert <h2> to ##\") {\n        std::string input = \"<h2>This is a Heading 2</h2>\";\n        std::string output = \"## This is a Heading 2\";\n        REQUIRE(convertHtmlHeadingsToMarkdown(input) == output);\n    }\n\n    SECTION(\"should convert <h3> to ###\") {\n        std::string input = \"<h3>This is a Heading 3</h3>\";\n        std::string output = \"### This is a Heading 3\";\n        REQUIRE(convertHtmlHeadingsToMarkdown(input) == output);\n    }\n\n    SECTION(\"should convert <h4> to ####\") {\n        std::string input = \"<h4>This is a Heading 4</h4>\";\n        std::string output = \"#### This is a Heading 4\";\n        REQUIRE(convertHtmlHeadingsToMarkdown(input) == output);\n    }\n\n    SECTION(\"should convert <h5> to #####\") {\n        std::string input = \"<h5>This is a Heading 5</h5>\";\n        std::string output = \"##### This is a Heading 5\";\n        REQUIRE(convertHtmlHeadingsToMarkdown(input) == output);\n    }\n\n    SECTION(\"should convert <h6> to ######\") {\n        std::string input = \"<h6>This is a Heading 6</h6>\";\n        std::string output = \"###### This is a Heading 6\";\n        REQUIRE(convertHtmlHeadingsToMarkdown(input) == output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n *\n * @param html - The HTML string containing headings.\n * @returns The converted Markdown string.\n */\nstd::string convertHtmlHeadingsToMarkdown(const std::string& html){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n *\n * @param html - The HTML string containing headings.\n * @return - The converted Markdown string.\n */\npublic static String convertHtmlHeadingsToMarkdown(String html) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testConvertH1ToMarkdown() {\n        String input = \"<h1>This is a Heading 1</h1>\";\n        String output = \"# This is a Heading 1\";\n        assertEquals(output, convertHtmlHeadingsToMarkdown(input));\n    }\n\n    @Test\n    public void testConvertH2ToMarkdown() {\n        String input = \"<h2>This is a Heading 2</h2>\";\n        String output = \"## This is a Heading 2\";\n        assertEquals(output, convertHtmlHeadingsToMarkdown(input));\n    }\n\n    @Test\n    public void testConvertH3ToMarkdown() {\n        String input = \"<h3>This is a Heading 3</h3>\";\n        String output = \"### This is a Heading 3\";\n        assertEquals(output, convertHtmlHeadingsToMarkdown(input));\n    }\n\n    @Test\n    public void testConvertH4ToMarkdown() {\n        String input = \"<h4>This is a Heading 4</h4>\";\n        String output = \"#### This is a Heading 4\";\n        assertEquals(output, convertHtmlHeadingsToMarkdown(input));\n    }\n\n    @Test\n    public void testConvertH5ToMarkdown() {\n        String input = \"<h5>This is a Heading 5</h5>\";\n        String output = \"##### This is a Heading 5\";\n        assertEquals(output, convertHtmlHeadingsToMarkdown(input));\n    }\n\n    @Test\n    public void testConvertH6ToMarkdown() {\n        String input = \"<h6>This is a Heading 6</h6>\";\n        String output = \"###### This is a Heading 6\";\n        assertEquals(output, convertHtmlHeadingsToMarkdown(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n *\n * @param html - The HTML string containing headings.\n * @return - The converted Markdown string.\n */\npublic static String convertHtmlHeadingsToMarkdown(String html) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 113, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Extract all the CSS rules from a given CSSStyleSheet and concatenate them into a string\n", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extract all the CSS rules from a given CSSStyleSheet and concatenate them into a string\n *\n * @param {CSSStyleSheet} sheet - The stylesheet object from which to extract CSS rules.\n * @returns {string} A single string containing all CSS rules, or an empty string if the sheet is invalid or inaccessible.\n */\nfunction getCSSFromSheet(sheet) {\n}", "test_code": "describe('getCSSFromSheet', () => {\n    let styleSheet;\n\n    beforeEach(() => {\n        // Create a style element with some CSS rules for testing\n        const style = document.createElement('style');\n        style.appendChild(document.createTextNode(`\n            body { background-color: red; }\n            p { color: blue; }\n        `));\n        document.head.appendChild(style);\n        styleSheet = style.sheet;\n    });\n\n    afterEach(() => {\n        // Clean up the document after each test\n        document.head.innerHTML = '';\n    });\n\n\n    test('Empty Stylesheet: should return an empty string', () => {\n        const emptyStyle = document.createElement('style');\n        document.head.appendChild(emptyStyle);\n        const emptyStyleSheet = emptyStyle.sheet;\n\n        const cssText = getCSSFromSheet(emptyStyleSheet);\n        expect(cssText).toBe('');\n    });\n\n    test('Invalid Input: should return an empty string for non-CSSStyleSheet input', () => {\n        expect(getCSSFromSheet(null)).toBe('');\n        expect(getCSSFromSheet({})).toBe('');\n        expect(getCSSFromSheet('not a stylesheet')).toBe('');\n    });\n\n    test('Cross-Origin Restrictions: should handle restricted stylesheets gracefully', () => {\n        // Simulate a cross-origin stylesheet\n        const link = document.createElement('link');\n        link.rel = 'stylesheet';\n        link.href = 'http://example.com/style.css';\n        document.head.appendChild(link);\n\n        // Accessing cssRules of a cross-origin stylesheet should throw an error\n        const restrictedSheet = link.sheet;\n\n        expect(() => {\n            getCSSFromSheet(restrictedSheet);\n        }).not.toThrow();  // The function should not throw an error\n\n        // Simulate behavior by returning an empty string\n        const cssText = getCSSFromSheet(restrictedSheet);\n        expect(cssText).toBe('');\n    });\n\n    test('Style Element with Inline CSS: should return CSS from inline style element', () => {\n        const styleElement = document.createElement('style');\n        styleElement.textContent = 'div { font-size: 16px; }';\n        document.head.appendChild(styleElement);\n\n        const cssText = getCSSFromSheet(styleElement.sheet);\n        expect(cssText).toBe('div {font-size: 16px;}');\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Extract all the CSS rules from a given CSSStyleSheet and concatenate them into a string\n *\n * @param {CSSStyleSheet} sheet - The stylesheet object from which to extract CSS rules.\n * @returns {string} A single string containing all CSS rules, or an empty string if the sheet is invalid or inaccessible.\n */\nfunction getCSSFromSheet(sheet) {\n}", "addition_info": "/**\n * @jest-environment jsdom\n */"}, "typescript": {"code_signature": "/**\n * Extract all the CSS rules from a given CSSStyleSheet and concatenate them into a string\n *\n * @param {CSSStyleSheet} sheet - The stylesheet object from which to extract CSS rules.\n * @returns {string} A single string containing all CSS rules, or an empty string if the sheet is invalid or inaccessible.\n */\nfunction getCSSFromSheet(sheet: CSSStyleSheet): string {\n}", "test_code": "describe('getCSSFromSheet', () => {\n    let styleSheet;\n\n    beforeEach(() => {\n        // Create a style element with some CSS rules for testing\n        const style = document.createElement('style');\n        style.appendChild(document.createTextNode(`\n            body { background-color: red; }\n            p { color: blue; }\n        `));\n        document.head.appendChild(style);\n        styleSheet = style.sheet;\n    });\n\n    afterEach(() => {\n        // Clean up the document after each test\n        document.head.innerHTML = '';\n    });\n\n\n    test('Empty Stylesheet: should return an empty string', () => {\n        const emptyStyle = document.createElement('style');\n        document.head.appendChild(emptyStyle);\n        const emptyStyleSheet = emptyStyle.sheet;\n\n        const cssText = getCSSFromSheet(emptyStyleSheet);\n        expect(cssText).toBe('');\n    });\n\n    test('Invalid Input: should return an empty string for non-CSSStyleSheet input', () => {\n        expect(getCSSFromSheet(null)).toBe('');\n        expect(getCSSFromSheet({})).toBe('');\n        expect(getCSSFromSheet('not a stylesheet')).toBe('');\n    });\n\n    test('Cross-Origin Restrictions: should handle restricted stylesheets gracefully', () => {\n        // Simulate a cross-origin stylesheet\n        const link = document.createElement('link');\n        link.rel = 'stylesheet';\n        link.href = 'http://example.com/style.css';\n        document.head.appendChild(link);\n\n        // Accessing cssRules of a cross-origin stylesheet should throw an error\n        const restrictedSheet = link.sheet;\n\n        expect(() => {\n            getCSSFromSheet(restrictedSheet);\n        }).not.toThrow();  // The function should not throw an error\n\n        // Simulate behavior by returning an empty string\n        const cssText = getCSSFromSheet(restrictedSheet);\n        expect(cssText).toBe('');\n    });\n\n    test('Style Element with Inline CSS: should return CSS from inline style element', () => {\n        const styleElement = document.createElement('style');\n        styleElement.textContent = 'div { font-size: 16px; }';\n        document.head.appendChild(styleElement);\n\n        const cssText = getCSSFromSheet(styleElement.sheet);\n        expect(cssText).toBe('div {font-size: 16px;}');\n    });\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Extract all the CSS rules from a given CSSStyleSheet and concatenate them into a string\n *\n * @param {CSSStyleSheet} sheet - The stylesheet object from which to extract CSS rules.\n * @returns {string} A single string containing all CSS rules, or an empty string if the sheet is invalid or inaccessible.\n */\nfunction getCSSFromSheet(sheet: CSSStyleSheet): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 114, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Sort the array of objects that contain timestamps based on the timestamp value\n", "language_version_list": {"python": {"code_signature": "from typing import List, Dict\n\n\ndef sort_by_timestamp(array: List[Dict]) -> List[Dict]:\n    \"\"\"\n    Sorts a list of dictionaries by the 'timestamp' property.\n\n    Args:\n        array (List[Dict]): The list of dictionaries to be sorted.\n\n    Returns:\n        List[Dict]: The sorted list, based on the 'timestamp' property.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestSortByTimestamp(unittest.TestCase):\n\n    def test_empty_array(self):\n        self.assertEqual(sort_by_timestamp([]), [])\n\n    def test_single_element_array(self):\n        single_element_array = [{'id': 1, 'timestamp': \"2021-07-03T12:00:00Z\"}]\n        self.assertEqual(sort_by_timestamp(single_element_array), [{'id': 1, 'timestamp': \"2021-07-03T12:00:00Z\"}])\n\n    def test_sort_multiple_elements(self):\n        test_data = [\n            {'id': 3, 'timestamp': \"2021-07-01T09:45:00Z\"},\n            {'id': 1, 'timestamp': \"2021-07-03T12:00:00Z\"},\n            {'id': 2, 'timestamp': \"2021-07-02T15:30:00Z\"}\n        ]\n        expected = [\n            {'id': 3, 'timestamp': \"2021-07-01T09:45:00Z\"},\n            {'id': 2, 'timestamp': \"2021-07-02T15:30:00Z\"},\n            {'id': 1, 'timestamp': \"2021-07-03T12:00:00Z\"}\n        ]\n        self.assertEqual(sort_by_timestamp(test_data), expected)\n\n    def test_already_sorted_array(self):\n        sorted_array = [\n            {'id': 1, 'timestamp': \"2021-07-01T09:45:00Z\"},\n            {'id': 2, 'timestamp': \"2021-07-02T15:30:00Z\"},\n            {'id': 3, 'timestamp': \"2021-07-03T12:00:00Z\"}\n        ]\n        self.assertEqual(sort_by_timestamp(sorted_array), sorted_array)\n\n    def test_mixed_format_timestamps(self):\n        mixed_formats = [\n            {'id': 1, 'timestamp': \"2021-07-03T12:00:00Z\"},\n            {'id': 2, 'timestamp': \"2021-07-02T15:30:00Z\"},\n            {'id': 3, 'timestamp': \"2021-07-01T09:45:00Z\"}\n        ]\n        expected = [\n            {'id': 3, 'timestamp': \"2021-07-01T09:45:00Z\"},\n            {'id': 2, 'timestamp': \"2021-07-02T15:30:00Z\"},\n            {'id': 1, 'timestamp': \"2021-07-03T12:00:00Z\"}\n        ]\n        self.assertEqual(sort_by_timestamp(mixed_formats), expected)", "prompt": "please write a python function , the function signature as below from typing import List, Dict\n\n\ndef sort_by_timestamp(array: List[Dict]) -> List[Dict]:\n    \"\"\"\n    Sorts a list of dictionaries by the 'timestamp' property.\n\n    Args:\n        array (List[Dict]): The list of dictionaries to be sorted.\n\n    Returns:\n        List[Dict]: The sorted list, based on the 'timestamp' property.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * sorts an array of objects by the timestamp property.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @returns {Object[]} The sorted array, based on the timestamp property.\n */\nfunction sortByTimestamp(array) {}", "test_code": "describe('sortByTimestamp function', () => {\n    test('should return an empty array when input is empty', () => {\n        expect(sortByTimestamp([])).toEqual([]);\n    });\n\n    test('should correctly handle an array with a single element', () => {\n        const singleElementArray = [{ id: 1, timestamp: \"2021-07-03T12:00:00Z\" }];\n        expect(sortByTimestamp(singleElementArray)).toEqual([{ id: 1, timestamp: \"2021-07-03T12:00:00Z\" }]);\n    });\n\n    test('should sort an array of objects by timestamps correctly', () => {\n        const testData = [\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 1, timestamp: \"2021-07-03T12:00:00Z\" },\n            { id: 2, timestamp: \"2021-07-02T15:30:00Z\" }\n        ];\n        const expected = [\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 2, timestamp: \"2021-07-02T15:30:00Z\" },\n            { id: 1, timestamp: \"2021-07-03T12:00:00Z\" }\n        ];\n        expect(sortByTimestamp(testData)).toEqual(expected);\n    });\n\n    test('should not alter array if already sorted', () => {\n        const sortedArray = [\n            { id: 1, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 2, timestamp: \"2021-07-02T15:30:00Z\" },\n            { id: 3, timestamp: \"2021-07-03T12:00:00Z\" }\n        ];\n        expect(sortByTimestamp(sortedArray)).toEqual(sortedArray);\n    });\n\n    test('should handle mixed format timestamps correctly', () => {\n        const mixedFormats = [\n            { id: 1, timestamp: \"2021/07/03 12:00:00\" },\n            { id: 2, timestamp: \"July 2, 2021 15:30:00\" },\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" }\n        ];\n        const expected = [\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 2, timestamp: \"July 2, 2021 15:30:00\" },\n            { id: 1, timestamp: \"2021/07/03 12:00:00\" }\n        ];\n        expect(sortByTimestamp(mixedFormats)).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * sorts an array of objects by the timestamp property.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @returns {Object[]} The sorted array, based on the timestamp property.\n */\nfunction sortByTimestamp(array) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Sorts an array of objects by the timestamp property.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @returns {Object[]} The sorted array, based on the timestamp property.\n */\nfunction sortByTimestamp(array: Array<{ timestamp: string }>): Array<{ timestamp: string }> {\n\n}\n", "test_code": "describe('sortByTimestamp function', () => {\n    test('should return an empty array when input is empty', () => {\n        expect(sortByTimestamp([])).toEqual([]);\n    });\n\n    test('should correctly handle an array with a single element', () => {\n        const singleElementArray: Array<{ id: number; timestamp: string }> = [{ id: 1, timestamp: \"2021-07-03T12:00:00Z\" }];\n        expect(sortByTimestamp(singleElementArray)).toEqual([{ id: 1, timestamp: \"2021-07-03T12:00:00Z\" }]);\n    });\n\n    test('should sort an array of objects by timestamps correctly', () => {\n        const testData: Array<{ id: number; timestamp: string }> = [\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 1, timestamp: \"2021-07-03T12:00:00Z\" },\n            { id: 2, timestamp: \"2021-07-02T15:30:00Z\" }\n        ];\n        const expected: Array<{ id: number; timestamp: string }> = [\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 2, timestamp: \"2021-07-02T15:30:00Z\" },\n            { id: 1, timestamp: \"2021-07-03T12:00:00Z\" }\n        ];\n        expect(sortByTimestamp(testData)).toEqual(expected);\n    });\n\n    test('should not alter array if already sorted', () => {\n        const sortedArray: Array<{ id: number; timestamp: string }> = [\n            { id: 1, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 2, timestamp: \"2021-07-02T15:30:00Z\" },\n            { id: 3, timestamp: \"2021-07-03T12:00:00Z\" }\n        ];\n        expect(sortByTimestamp(sortedArray)).toEqual(sortedArray);\n    });\n\n    test('should handle mixed format timestamps correctly', () => {\n        const mixedFormats: Array<{ id: number; timestamp: string }> = [\n            { id: 1, timestamp: \"2021/07/03 12:00:00\" },\n            { id: 2, timestamp: \"July 2, 2021 15:30:00\" },\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" }\n        ];\n        const expected: Array<{ id: number; timestamp: string }> = [\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 2, timestamp: \"July 2, 2021 15:30:00\" },\n            { id: 1, timestamp: \"2021/07/03 12:00:00\" }\n        ];\n        expect(sortByTimestamp(mixedFormats)).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Sorts an array of objects by the timestamp property.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @returns {Object[]} The sorted array, based on the timestamp property.\n */\nfunction sortByTimestamp(array: Array<{ timestamp: string }>): Array<{ timestamp: string }> {\n\n}\n", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 115, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "sort the array of objects alphabetically by the specified key\n", "language_version_list": {"python": {"code_signature": "from typing import List, Dict\n\n\ndef sort_by_key(array: List[Dict], key: str) -> List[Dict]:\n    \"\"\"\n    Sorts a list of dictionaries alphabetically by a specified key.\n\n    Args:\n        array (List[Dict]):  The list of dictionaries to be sorted.\n        key (str): The key in the dictionaries to sort by.\n\n    Returns:\n        List[Dict]: The sorted list based on the specified key.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSortByKey(unittest.TestCase):\n\n    def test_empty_array(self):\n        result = sort_by_key([], 'name')\n        self.assertEqual(result, [])\n\n    def test_single_element(self):\n        single_element_array = [{'name': 'Apple'}]\n        self.assertEqual(sort_by_key(single_element_array, 'name'), [{'name': 'Apple'}])\n\n    def test_sort_by_key(self):\n        test_data = [\n            {'name': 'banana'},\n            {'name': 'apple'},\n            {'name': 'orange'}\n        ]\n        expected = [\n            {'name': 'apple'},\n            {'name': 'banana'},\n            {'name': 'orange'}\n        ]\n        self.assertEqual(sort_by_key(test_data, 'name'), expected)\n\n    def test_case_insensitive_sorting(self):\n        mixed_case_array = [\n            {'name': 'banana'},\n            {'name': 'Apple'},\n            {'name': 'orange'}\n        ]\n        expected = [\n            {'name': 'Apple'},\n            {'name': 'banana'},\n            {'name': 'orange'}\n        ]\n        self.assertEqual(sort_by_key(mixed_case_array, 'name'), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List, Dict\n\n\ndef sort_by_key(array: List[Dict], key: str) -> List[Dict]:\n    \"\"\"\n    Sorts a list of dictionaries alphabetically by a specified key.\n\n    Args:\n        array (List[Dict]):  The list of dictionaries to be sorted.\n        key (str): The key in the dictionaries to sort by.\n\n    Returns:\n        List[Dict]: The sorted list based on the specified key.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Sorts an array of objects alphabetically by a specified key.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @param {string} key - The key in the objects to sort by.\n * @returns {Object[]} The sorted array based on the specified key.\n */\nfunction sortByKey(array, key) {\n\n}", "test_code": "describe('sortByKey function', () => {\n    test('should return an empty array when input is empty', () => {\n        const result = sortByKey([], 'name');\n        expect(result).toEqual([]);\n    });\n\n    test('should correctly handle an array with a single element', () => {\n        const singleElementArray = [{ name: 'Apple' }];\n        expect(sortByKey(singleElementArray, 'name')).toEqual([{ name: 'Apple' }]);\n    });\n\n    test('should sort an array of objects by the specified key', () => {\n        const testData = [\n            { name: 'banana' },\n            { name: 'apple' },\n            { name: 'orange' }\n        ];\n        const expected = [\n            { name: 'apple' },\n            { name: 'banana' },\n            { name: 'orange' }\n        ];\n        expect(sortByKey(testData, 'name')).toEqual(expected);\n    });\n\n    test('should perform case-insensitive sorting', () => {\n        const mixedCaseArray = [\n            { name: 'banana' },\n            { name: 'Apple' },\n            { name: 'orange' }\n        ];\n        const expected = [\n            { name: 'Apple' },\n            { name: 'banana' },\n            { name: 'orange' }\n        ];\n        expect(sortByKey(mixedCaseArray, 'name')).toEqual(expected);\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Sorts an array of objects alphabetically by a specified key.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @param {string} key - The key in the objects to sort by.\n * @returns {Object[]} The sorted array based on the specified key.\n */\nfunction sortByKey(array, key) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Sorts an array of objects alphabetically by a specified key.\n *\n * @param {Array<Record<string, any>>} array - The array of objects to be sorted.\n * @param {string} key - The key in the objects to sort by.\n * @returns {Array<Record<string, any>>} The sorted array based on the specified key.\n */\nfunction sortByKey(array: Array<Record<string, any>>, key: string): Array<Record<string, any>> {\n\n}", "test_code": "describe('sortByKey function', () => {\n    test('should return an empty array when input is empty', () => {\n        const result = sortByKey([], 'name');\n        expect(result).toEqual([]);\n    });\n\n    test('should correctly handle an array with a single element', () => {\n        const singleElementArray: Array<Record<string, any>> = [{ name: 'Apple' }];\n        expect(sortByKey(singleElementArray, 'name')).toEqual([{ name: 'Apple' }]);\n    });\n\n    test('should sort an array of objects by the specified key', () => {\n        const testData: Array<Record<string, any>> = [\n            { name: 'banana' },\n            { name: 'apple' },\n            { name: 'orange' }\n        ];\n        const expected: Array<Record<string, any>> = [\n            { name: 'apple' },\n            { name: 'banana' },\n            { name: 'orange' }\n        ];\n        expect(sortByKey(testData, 'name')).toEqual(expected);\n    });\n\n    test('should perform case-insensitive sorting', () => {\n        const mixedCaseArray: Array<Record<string, any>> = [\n            { name: 'banana' },\n            { name: 'Apple' },\n            { name: 'orange' }\n        ];\n        const expected: Array<Record<string, any>> = [\n            { name: 'Apple' },\n            { name: 'banana' },\n            { name: 'orange' }\n        ];\n        expect(sortByKey(mixedCaseArray, 'name')).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Sorts an array of objects alphabetically by a specified key.\n *\n * @param {Array<Record<string, any>>} array - The array of objects to be sorted.\n * @param {string} key - The key in the objects to sort by.\n * @returns {Array<Record<string, any>>} The sorted array based on the specified key.\n */\nfunction sortByKey(array: Array<Record<string, any>>, key: string): Array<Record<string, any>> {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 116, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Calculates the toroidal difference between two points", "language_version_list": {"python": {"code_signature": "from typing import Dict, List\n\n\ndef calculate_toroidal_difference(point_a: Dict[str, float], point_b: Dict[str, float], width: float, height: float) -> List[float]:\n    \"\"\"\n    Calculates the toroidal difference between two points in a wrap-around space.\n\n    Args:\n        point_a (Dict[str, float]): The first point with keys 'x' and 'y'.\n        point_b (Dict[str, float]): The second point with keys 'x' and 'y'.\n        width (float): The width of the toroidal space.\n        height (float): The height of the toroidal space.\n\n    Returns:\n        List[float]: A list containing the x and y differences, accounting for wrap-around.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestToroidalDiff(unittest.TestCase):\n\n    def test_no_wrapping(self):\n        this_point = {'x': 2, 'y': 3}\n        other_point = {'x': 5, 'y': 6}\n        width = 10\n        height = 10\n        result = calculate_toroidal_difference(this_point, other_point, width, height)\n        self.assertEqual(result, [-3, -3])\n\n    def test_wrapping_x_dimension(self):\n        this_point = {'x': 9, 'y': 5}\n        other_point = {'x': 1, 'y': 5}\n        width = 10\n        height = 10\n        result = calculate_toroidal_difference(this_point, other_point, width, height)\n        self.assertEqual(result, [-2, 0])  # dx wraps around the toroidal boundary\n\n    def test_wrapping_y_dimension(self):\n        this_point = {'x': 4, 'y': 9}\n        other_point = {'x': 4, 'y': 1}\n        width = 10\n        height = 10\n        result = calculate_toroidal_difference(this_point, other_point, width, height)\n        self.assertEqual(result, [0, -2])  # dy wraps around the toroidal boundary\n\n    def test_wrapping_both_dimensions(self):\n        this_point = {'x': 9, 'y': 9}\n        other_point = {'x': 1, 'y': 1}\n        width = 10\n        height = 10\n        result = calculate_toroidal_difference(this_point, other_point, width, height)\n        self.assertEqual(result, [-2, -2])  # Both dx and dy wrap around\n\n    def test_same_position(self):\n        this_point = {'x': 5, 'y': 5}\n        other_point = {'x': 5, 'y': 5}\n        width = 10\n        height = 10\n        result = calculate_toroidal_difference(this_point, other_point, width, height)\n        self.assertEqual(result, [0, 0])  # No difference\n", "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef calculate_toroidal_difference(point_a: Dict[str, float], point_b: Dict[str, float], width: float, height: float) -> List[float]:\n    \"\"\"\n    Calculates the toroidal difference between two points in a wrap-around space.\n\n    Args:\n        point_a (Dict[str, float]): The first point with keys 'x' and 'y'.\n        point_b (Dict[str, float]): The second point with keys 'x' and 'y'.\n        width (float): The width of the toroidal space.\n        height (float): The height of the toroidal space.\n\n    Returns:\n        List[float]: A list containing the x and y differences, accounting for wrap-around.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculates the toroidal difference between two points.\n *\n * @param {Object} thisPoint - The first point with properties x and y.\n * @param {Object} otherPoint - The second point with properties x and y.\n * @param {number} width - The width of the toroidal space.\n * @param {number} height - The height of the toroidal space.\n * @returns {Array} - An array containing the x and y differences, accounting for wrap-around.\n */\nfunction toroidalDiff(thisPoint, otherPoint, width, height) {\n}", "test_code": "describe('toroidalDiff', () => {\n    test('should return the direct difference when no wrapping is needed', () => {\n        const thisPoint = { x: 2, y: 3 };\n        const otherPoint = { x: 5, y: 6 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([-3, -3]);\n    });\n\n    test('should handle wrapping around the x dimension', () => {\n        const thisPoint = { x: 9, y: 5 };\n        const otherPoint = { x: 1, y: 5 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([-2, 0]); // dx wraps around the toroidal boundary\n    });\n\n    test('should handle wrapping around the y dimension', () => {\n        const thisPoint = { x: 4, y: 9 };\n        const otherPoint = { x: 4, y: 1 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([0, -2]); // dy wraps around the toroidal boundary\n    });\n\n    test('should handle wrapping around both x and y dimensions', () => {\n        const thisPoint = { x: 9, y: 9 };\n        const otherPoint = { x: 1, y: 1 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([-2, -2]); // Both dx and dy wrap around\n    });\n\n    test('should return the direct difference for points at the same position', () => {\n        const thisPoint = { x: 5, y: 5 };\n        const otherPoint = { x: 5, y: 5 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([0, 0]); // No difference\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the toroidal difference between two points.\n *\n * @param {Object} thisPoint - The first point with properties x and y.\n * @param {Object} otherPoint - The second point with properties x and y.\n * @param {number} width - The width of the toroidal space.\n * @param {number} height - The height of the toroidal space.\n * @returns {Array} - An array containing the x and y differences, accounting for wrap-around.\n */\nfunction toroidalDiff(thisPoint, otherPoint, width, height) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the toroidal difference between two points.\n *\n * @param {Point} thisPoint - The first point with properties x and y.\n * @param {Point} otherPoint - The second point with properties x and y.\n * @param {number} width - The width of the toroidal space.\n * @param {number} height - The height of the toroidal space.\n * @returns {[number, number]} - An array containing the x and y differences, accounting for wrap-around.\n */\nfunction toroidalDiff(thisPoint: Point, otherPoint: Point, width: number, height: number): [number, number] {}", "test_code": "describe('toroidalDiff', () => {\n    test('should return the direct difference when no wrapping is needed', () => {\n        const thisPoint: Point = { x: 2, y: 3 };\n        const otherPoint: Point = { x: 5, y: 6 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([-3, -3]);\n    });\n\n    test('should handle wrapping around the x dimension', () => {\n        const thisPoint: Point = { x: 9, y: 5 };\n        const otherPoint: Point = { x: 1, y: 5 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([-2, 0]); // dx wraps around the toroidal boundary\n    });\n\n    test('should handle wrapping around the y dimension', () => {\n        const thisPoint: Point = { x: 4, y: 9 };\n        const otherPoint: Point = { x: 4, y: 1 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([0, -2]); // dy wraps around the toroidal boundary\n    });\n\n    test('should handle wrapping around both x and y dimensions', () => {\n        const thisPoint: Point = { x: 9, y: 9 };\n        const otherPoint: Point = { x: 1, y: 1 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([-2, -2]); // Both dx and dy wrap around\n    });\n\n    test('should return the direct difference for points at the same position', () => {\n        const thisPoint: Point = { x: 5, y: 5 };\n        const otherPoint: Point = { x: 5, y: 5 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([0, 0]); // No difference\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the toroidal difference between two points.\n *\n * @param {Point} thisPoint - The first point with properties x and y.\n * @param {Point} otherPoint - The second point with properties x and y.\n * @param {number} width - The width of the toroidal space.\n * @param {number} height - The height of the toroidal space.\n * @returns {[number, number]} - An array containing the x and y differences, accounting for wrap-around.\n */\nfunction toroidalDiff(thisPoint: Point, otherPoint: Point, width: number, height: number): [number, number] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculates the toroidal difference between two points.\n *\n * @param std::pair<double, double> thisPoint - The first point with properties x and y.\n * @param std::pair<double, double> otherPoint - The second point with properties x and y.\n * @param double width - The width of the toroidal space.\n * @param double height - The height of the toroidal space.\n * @returns std::vector<double> - A vector containing the x and y differences, accounting for wrap-around.\n */\nstd::vector<double> toroidalDiff(const std::pair<double, double>& thisPoint, const std::pair<double, double>& otherPoint, double width, double height) {\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <vector>\n#include <utility>\n\n// Assume toroidalDiff function is defined here\n\nTEST_CASE(\"toroidalDiff\", \"[toroidalDiff]\") {\n    SECTION(\"should return the direct difference when no wrapping is needed\") {\n        std::pair<double, double> thisPoint = {2, 3};\n        std::pair<double, double> otherPoint = {5, 6};\n        double width = 10;\n        double height = 10;\n        auto result = toroidalDiff(thisPoint, otherPoint, width, height);\n        REQUIRE(result == std::vector<double>{-3, -3});\n    }\n\n    SECTION(\"should handle wrapping around the x dimension\") {\n        std::pair<double, double> thisPoint = {9, 5};\n        std::pair<double, double> otherPoint = {1, 5};\n        double width = 10;\n        double height = 10;\n        auto result = toroidalDiff(thisPoint, otherPoint, width, height);\n        REQUIRE(result == std::vector<double>{-2, 0}); // dx wraps around the toroidal boundary\n    }\n\n    SECTION(\"should handle wrapping around the y dimension\") {\n        std::pair<double, double> thisPoint = {4, 9};\n        std::pair<double, double> otherPoint = {4, 1};\n        double width = 10;\n        double height = 10;\n        auto result = toroidalDiff(thisPoint, otherPoint, width, height);\n        REQUIRE(result == std::vector<double>{0, -2}); // dy wraps around the toroidal boundary\n    }\n\n    SECTION(\"should handle wrapping around both x and y dimensions\") {\n        std::pair<double, double> thisPoint = {9, 9};\n        std::pair<double, double> otherPoint = {1, 1};\n        double width = 10;\n        double height = 10;\n        auto result = toroidalDiff(thisPoint, otherPoint, width, height);\n        REQUIRE(result == std::vector<double>{-2, -2}); // Both dx and dy wrap around\n    }\n\n    SECTION(\"should return the direct difference for points at the same position\") {\n        std::pair<double, double> thisPoint = {5, 5};\n        std::pair<double, double> otherPoint = {5, 5};\n        double width = 10;\n        double height = 10;\n        auto result = toroidalDiff(thisPoint, otherPoint, width, height);\n        REQUIRE(result == std::vector<double>{0, 0}); // No difference\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculates the toroidal difference between two points.\n *\n * @param std::pair<double, double> thisPoint - The first point with properties x and y.\n * @param std::pair<double, double> otherPoint - The second point with properties x and y.\n * @param double width - The width of the toroidal space.\n * @param double height - The height of the toroidal space.\n * @returns std::vector<double> - A vector containing the x and y differences, accounting for wrap-around.\n */\nstd::vector<double> toroidalDiff(const std::pair<double, double>& thisPoint, const std::pair<double, double>& otherPoint, double width, double height) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the toroidal difference between two points.\n *\n * @param thisPoint - The first point with properties x and y.\n * @param otherPoint - The second point with properties x and y.\n * @param width - The width of the toroidal space.\n * @param height - The height of the toroidal space.\n * @returns - An array containing the x and y differences, accounting for wrap-around.\n */\npublic static class Point {\n    public double x;\n    public double y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\npublic static double[] toroidalDiff(Point thisPoint, Point otherPoint, double width, double height) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testDirectDifferenceNoWrapping() {\n        Point thisPoint = new Point(2, 3);\n        Point otherPoint = new Point(5, 6);\n        double width = 10;\n        double height = 10;\n        double[] result = toroidalDiff(thisPoint, otherPoint, width, height);\n        assertArrayEquals(new double[]{-3, -3}, result, 0.0001);\n    }\n\n    @Test\n    public void testWrappingAroundXDimension() {\n        Point thisPoint = new Point(9, 5);\n        Point otherPoint = new Point(1, 5);\n        double width = 10;\n        double height = 10;\n        double[] result = toroidalDiff(thisPoint, otherPoint, width, height);\n        assertArrayEquals(new double[]{-2, 0}, result, 0.0001); // dx wraps around the toroidal boundary\n    }\n\n    @Test\n    public void testWrappingAroundYDimension() {\n        Point thisPoint = new Point(4, 9);\n        Point otherPoint = new Point(4, 1);\n        double width = 10;\n        double height = 10;\n        double[] result = toroidalDiff(thisPoint, otherPoint, width, height);\n        assertArrayEquals(new double[]{0, -2}, result, 0.0001); // dy wraps around the toroidal boundary\n    }\n\n    @Test\n    public void testWrappingAroundBothDimensions() {\n        Point thisPoint = new Point(9, 9);\n        Point otherPoint = new Point(1, 1);\n        double width = 10;\n        double height = 10;\n        double[] result = toroidalDiff(thisPoint, otherPoint, width, height);\n        assertArrayEquals(new double[]{-2, -2}, result, 0.0001); // Both dx and dy wrap around\n    }\n\n    @Test\n    public void testSamePosition() {\n        Point thisPoint = new Point(5, 5);\n        Point otherPoint = new Point(5, 5);\n        double width = 10;\n        double height = 10;\n        double[] result = toroidalDiff(thisPoint, otherPoint, width, height);\n        assertArrayEquals(new double[]{0, 0}, result, 0.0001); // No difference\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the toroidal difference between two points.\n *\n * @param thisPoint - The first point with properties x and y.\n * @param otherPoint - The second point with properties x and y.\n * @param width - The width of the toroidal space.\n * @param height - The height of the toroidal space.\n * @returns - An array containing the x and y differences, accounting for wrap-around.\n */\npublic static class Point {\n    public double x;\n    public double y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\npublic static double[] toroidalDiff(Point thisPoint, Point otherPoint, double width, double height) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 117, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "convert RGB colors to HSL color values\n", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef rgb_to_hsl(r: int, g: int, b: int) -> Dict:\n    \"\"\"\n    Converts an RGB color value to HSL.\n\n    Args:\n        r (int): The red component (0-255).\n        g (int): The green component (0-255).\n        b (int): The blue component (0-255).\n\n    Returns:\n        Dict: A dictionary containing the HSL values.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestRgbToHsl(unittest.TestCase):\n\n    def test_converts_pure_red_to_hsl(self):\n        self.assertEqual(rgb_to_hsl(255, 0, 0), {'h': 0, 's': 100, 'l': 50})\n\n    def test_converts_black_to_hsl(self):\n        self.assertEqual(rgb_to_hsl(0, 0, 0), {'h': 0, 's': 0, 'l': 0})\n\n    def test_converts_white_to_hsl(self):\n        self.assertEqual(rgb_to_hsl(255, 255, 255), {'h': 0, 's': 0, 'l': 100})\n\n    def test_converts_a_color_on_edge_of_rgb_range(self):\n        self.assertEqual(rgb_to_hsl(0, 255, 255), {'h': 180, 's': 100, 'l': 50})\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef rgb_to_hsl(r: int, g: int, b: int) -> Dict:\n    \"\"\"\n    Converts an RGB color value to HSL.\n\n    Args:\n        r (int): The red component (0-255).\n        g (int): The green component (0-255).\n        b (int): The blue component (0-255).\n\n    Returns:\n        Dict: A dictionary containing the HSL values.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts an RGB color value to HSL.\n *\n * @param {number} r - The red component (0-255).\n * @param {number} g - The green component (0-255).\n * @param {number} b - The blue component (0-255).\n * @returns {Object} An object containing the HSL values.\n */\nfunction rgbToHsl(r, g, b) {\n}", "test_code": "describe('rgbToHsl function', () => {\n    test('converts pure red to HSL', () => {\n        expect(rgbToHsl(255, 0, 0)).toEqual({h: 0, s: 100, l: 50});\n    });\n\n    test('converts black to HSL', () => {\n        expect(rgbToHsl(0, 0, 0)).toEqual({h: 0, s: 0, l: 0});\n    });\n\n    test('converts white to HSL', () => {\n        expect(rgbToHsl(255, 255, 255)).toEqual({h: 0, s: 0, l: 100});\n    });\n\n    test('converts a color on the edge of RGB range', () => {\n        expect(rgbToHsl(0, 255, 255)).toEqual({h: 180, s: 100, l: 50});\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts an RGB color value to HSL.\n *\n * @param {number} r - The red component (0-255).\n * @param {number} g - The green component (0-255).\n * @param {number} b - The blue component (0-255).\n * @returns {Object} An object containing the HSL values.\n */\nfunction rgbToHsl(r, g, b) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts an RGB color value to HSL.\n *\n * @param {number} r - The red component (0-255).\n * @param {number} g - The green component (0-255).\n * @param {number} b - The blue component (0-255).\n * @returns {{ h: number; s: number; l: number }} An object containing the HSL values.\n */\nfunction rgbToHsl(r: number, g: number, b: number): { h: number; s: number; l: number } {\n}", "test_code": "describe('rgbToHsl function', () => {\n    test('converts pure red to HSL', () => {\n        expect(rgbToHsl(255, 0, 0)).toEqual({ h: 0, s: 100, l: 50 });\n    });\n\n    test('converts black to HSL', () => {\n        expect(rgbToHsl(0, 0, 0)).toEqual({ h: 0, s: 0, l: 0 });\n    });\n\n    test('converts white to HSL', () => {\n        expect(rgbToHsl(255, 255, 255)).toEqual({ h: 0, s: 0, l: 100 });\n    });\n\n    test('converts a color on the edge of RGB range', () => {\n        expect(rgbToHsl(0, 255, 255)).toEqual({ h: 180, s: 100, l: 50 });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts an RGB color value to HSL.\n *\n * @param {number} r - The red component (0-255).\n * @param {number} g - The green component (0-255).\n * @param {number} b - The blue component (0-255).\n * @returns {{ h: number; s: number; l: number }} An object containing the HSL values.\n */\nfunction rgbToHsl(r: number, g: number, b: number): { h: number; s: number; l: number } {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts an RGB color value to HSL.\n *\n * @param r - The red component (0-255).\n * @param g - The green component (0-255).\n * @param b - The blue component (0-255).\n * @returns An object containing the HSL values.\n */\nHSL rgbToHsl(int r, int g, int b) {\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n\nHSL rgbToHsl(int r, int g, int b); // Function prototype\n\nTEST_CASE(\"rgbToHsl function\") {\n    SECTION(\"converts pure red to HSL\") {\n        REQUIRE(rgbToHsl(255, 0, 0) == HSL{0, 100, 50});\n    }\n\n    SECTION(\"converts black to HSL\") {\n        REQUIRE(rgbToHsl(0, 0, 0) == HSL{0, 0, 0});\n    }\n\n    SECTION(\"converts white to HSL\") {\n        REQUIRE(rgbToHsl(255, 255, 255) == HSL{0, 0, 100});\n    }\n\n    SECTION(\"converts a color on the edge of RGB range\") {\n        REQUIRE(rgbToHsl(0, 255, 255) == HSL{180, 100, 50});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts an RGB color value to HSL.\n *\n * @param r - The red component (0-255).\n * @param g - The green component (0-255).\n * @param b - The blue component (0-255).\n * @returns An object containing the HSL values.\n */\nHSL rgbToHsl(int r, int g, int b) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts an RGB color value to HSL.\n *\n * @param r The red component (0-255).\n * @param g The green component (0-255).\n * @param b The blue component (0-255).\n * @return An array containing the HSL values.\n */\npublic static int[] rgbToHsl(int r, int g, int b) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testRgbToHslPureRed() {\n        assertArrayEquals(new int[]{0, 100, 50}, rgbToHsl(255, 0, 0));\n    }\n\n    @Test\n    public void testRgbToHslBlack() {\n        assertArrayEquals(new int[]{0, 0, 0}, rgbToHsl(0, 0, 0));\n    }\n\n    @Test\n    public void testRgbToHslWhite() {\n        assertArrayEquals(new int[]{0, 0, 100}, rgbToHsl(255, 255, 255));\n    }\n\n    @Test\n    public void testRgbToHslCyan() {\n        assertArrayEquals(new int[]{0, 100, 50}, rgbToHsl(0, 255, 255));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts an RGB color value to HSL.\n *\n * @param r The red component (0-255).\n * @param g The green component (0-255).\n * @param b The blue component (0-255).\n * @return An array containing the HSL values.\n */\npublic static int[] rgbToHsl(int r, int g, int b) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 118, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "convert HSL color values to RGB color values\n", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef hsl_to_rgb(h: int, s: int, l: int) -> Dict:\n    \"\"\"\n    Converts HSL color values to RGB.\n\n    Args:\n        h (int): Hue (0-360 degrees).\n        s (int): Saturation (0-100%).\n        l (int): Lightness (0-100%).\n\n    Returns:\n        Dict: A dictionary containing the RGB values.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestHSLToRGB(unittest.TestCase):\n\n    def test_converts_pure_red_hue_correctly(self):\n        self.assertEqual(hsl_to_rgb(0, 100, 50), {'r': 255, 'g': 0, 'b': 0})\n\n    def test_returns_gray_for_zero_saturation(self):\n        self.assertEqual(hsl_to_rgb(240, 0, 50), {'r': 128, 'g': 128, 'b': 128})\n\n    def test_returns_white_for_full_lightness(self):\n        self.assertEqual(hsl_to_rgb(120, 50, 100), {'r': 255, 'g': 255, 'b': 255})\n\n    def test_converts_full_saturation_and_mid_lightness_blue_correctly(self):\n        self.assertEqual(hsl_to_rgb(240, 100, 50), {'r': 0, 'g': 0, 'b': 255})\n\n    def test_handles_edge_hue_at_360_degrees_correctly(self):\n        self.assertEqual(hsl_to_rgb(360, 100, 50), {'r': 0, 'g': 0, 'b': 0})  # Should be the same as hue 0\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef hsl_to_rgb(h: int, s: int, l: int) -> Dict:\n    \"\"\"\n    Converts HSL color values to RGB.\n\n    Args:\n        h (int): Hue (0-360 degrees).\n        s (int): Saturation (0-100%).\n        l (int): Lightness (0-100%).\n\n    Returns:\n        Dict: A dictionary containing the RGB values.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts HSL color values to RGB.\n *\n * @param {number} h - Hue (0-360 degrees).\n * @param {number} s - Saturation (0-100%).\n * @param {number} l - Lightness (0-100%).\n * @returns {Object} An object containing the RGB values.\n */\nfunction hslToRgb(h, s, l) {}", "test_code": "describe('hslToRgb function', () => {\n    test('converts pure red hue correctly', () => {\n        expect(hslToRgb(0, 100, 50)).toEqual({ r: 255, g: 0, b: 0 });\n    });\n\n    test('returns gray for zero saturation', () => {\n        expect(hslToRgb(240, 0, 50)).toEqual({ r: 128, g: 128, b: 128 });\n    });\n\n    test('returns white for full lightness', () => {\n        expect(hslToRgb(120, 50, 100)).toEqual({ r: 255, g: 255, b: 255 });\n    });\n\n    test('converts full saturation and mid lightness blue correctly', () => {\n        expect(hslToRgb(240, 100, 50)).toEqual({ r: 0, g: 0, b: 255 });\n    });\n\n    test('handles edge hue at 360 degrees correctly', () => {\n        expect(hslToRgb(360, 100, 50)).toEqual({ r: 255, g: 0, b: 0 }); // Should be the same as hue 0\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts HSL color values to RGB.\n *\n * @param {number} h - Hue (0-360 degrees).\n * @param {number} s - Saturation (0-100%).\n * @param {number} l - Lightness (0-100%).\n * @returns {Object} An object containing the RGB values.\n */\nfunction hslToRgb(h, s, l) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts HSL color values to RGB.\n *\n * @param {number} h - Hue (0-360 degrees).\n * @param {number} s - Saturation (0-100%).\n * @param {number} l - Lightness (0-100%).\n * @returns {{ r: number, g: number, b: number }} An object containing the RGB values.\n */\nfunction hslToRgb(h: number, s: number, l: number): { r: number, g: number, b: number } {\n\n}\n", "test_code": "describe('hslToRgb function', () => {\n    test('converts pure red hue correctly', () => {\n        expect(hslToRgb(0, 100, 50)).toEqual({ r: 255, g: 0, b: 0 });\n    });\n\n    test('returns gray for zero saturation', () => {\n        expect(hslToRgb(240, 0, 50)).toEqual({ r: 128, g: 128, b: 128 });\n    });\n\n    test('returns white for full lightness', () => {\n        expect(hslToRgb(120, 50, 100)).toEqual({ r: 255, g: 255, b: 255 });\n    });\n\n    test('converts full saturation and mid lightness blue correctly', () => {\n        expect(hslToRgb(240, 100, 50)).toEqual({ r: 0, g: 0, b: 255 });\n    });\n\n    test('handles edge hue at 360 degrees correctly', () => {\n        expect(hslToRgb(360, 100, 50)).toEqual({ r: 0, g: 0, b: 0 }); // Should be the same as hue 0\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts HSL color values to RGB.\n *\n * @param {number} h - Hue (0-360 degrees).\n * @param {number} s - Saturation (0-100%).\n * @param {number} l - Lightness (0-100%).\n * @returns {{ r: number, g: number, b: number }} An object containing the RGB values.\n */\nfunction hslToRgb(h: number, s: number, l: number): { r: number, g: number, b: number } {\n\n}\n", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts HSL color values to RGB.\n *\n * @param h - Hue (0-360 degrees).\n * @param s - Saturation (0-100%).\n * @param l - Lightness (0-100%).\n * @returns A tuple containing the RGB values.\n */\nstd::tuple<int, int, int> hslToRgb(double h, double s, double l) {\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <tuple>\n\n// Assuming hslToRgb function is defined somewhere above or in an included header\n\nTEST_CASE(\"hslToRgb function\", \"[color]\") {\n    SECTION(\"converts pure red hue correctly\") {\n        auto [r, g, b] = hslToRgb(0, 100, 50);\n        REQUIRE(r == 255);\n        REQUIRE(g == 0);\n        REQUIRE(b == 0);\n    }\n\n    SECTION(\"returns gray for zero saturation\") {\n        auto [r, g, b] = hslToRgb(240, 0, 50);\n        REQUIRE(r == 128);\n        REQUIRE(g == 128);\n        REQUIRE(b == 128);\n    }\n\n    SECTION(\"returns white for full lightness\") {\n        auto [r, g, b] = hslToRgb(120, 50, 100);\n        REQUIRE(r == 255);\n        REQUIRE(g == 255);\n        REQUIRE(b == 255);\n    }\n\n    SECTION(\"converts full saturation and mid lightness blue correctly\") {\n        auto [r, g, b] = hslToRgb(240, 100, 50);\n        REQUIRE(r == 0);\n        REQUIRE(g == 0);\n        REQUIRE(b == 255);\n    }\n\n    SECTION(\"handles edge hue at 360 degrees correctly\") {\n        auto [r, g, b] = hslToRgb(360, 100, 50);\n        REQUIRE(r == 255);\n        REQUIRE(g == 0);\n        REQUIRE(b == 0); // Should be the same as hue 0\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts HSL color values to RGB.\n *\n * @param h - Hue (0-360 degrees).\n * @param s - Saturation (0-100%).\n * @param l - Lightness (0-100%).\n * @returns A tuple containing the RGB values.\n */\nstd::tuple<int, int, int> hslToRgb(double h, double s, double l) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts HSL color values to RGB.\n *\n * @param h - Hue (0-360 degrees).\n * @param s - Saturation (0-100%).\n * @param l - Lightness (0-100%).\n * @returns An RGB object containing the RGB values.\n */\npublic static class RGB {\n    public int r, g, b;\n\n    public RGB(int r, int g, int b) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n    }\n}\npublic static RGB hslToRgb(double h, double s, double l) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testConvertsPureRedHueCorrectly() {\n        RGB result = hslToRgb(0, 100, 50);\n        assertEquals(255, result.r);\n        assertEquals(0, result.g);\n        assertEquals(0, result.b);\n    }\n\n    @Test\n    public void testReturnsGrayForZeroSaturation() {\n        RGB result = hslToRgb(240, 0, 50);\n        assertEquals(128, result.r);\n        assertEquals(128, result.g);\n        assertEquals(128, result.b);\n    }\n\n    @Test\n    public void testReturnsWhiteForFullLightness() {\n        RGB result = hslToRgb(120, 50, 100);\n        assertEquals(255, result.r);\n        assertEquals(255, result.g);\n        assertEquals(255, result.b);\n    }\n\n    @Test\n    public void testConvertsFullSaturationMidLightnessBlueCorrectly() {\n        RGB result = hslToRgb(240, 100, 50);\n        assertEquals(0, result.r);\n        assertEquals(0, result.g);\n        assertEquals(255, result.b);\n    }\n\n    @Test\n    public void testHandlesEdgeHueAt360DegreesCorrectly() {\n        RGB result = hslToRgb(360, 100, 50);\n        assertEquals(0, result.r);\n        assertEquals(0, result.g);\n        assertEquals(0, result.b); // Should be the same as hue 0\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts HSL color values to RGB.\n *\n * @param h - Hue (0-360 degrees).\n * @param s - Saturation (0-100%).\n * @param l - Lightness (0-100%).\n * @returns An RGB object containing the RGB values.\n */\npublic static class RGB {\n    public int r, g, b;\n\n    public RGB(int r, int g, int b) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n    }\n}\npublic static RGB hslToRgb(double h, double s, double l) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 119, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "gets the cookie value for the specified name from the cookie in the browser. The format of the cookie is key=value;key=value;key=value\n", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * gets the cookie value for the specified name from the cookie in the browser. The format of the cookie is key=value;key=value;key=value\n * @param name cookie key name\n */\nfunction getCookie(name) {\n\n}", "test_code": "describe('getCookie function tests', () => {\n    beforeEach(() => {\n        // Clear cookies before each test\n        Object.defineProperty(window.document, 'cookie', {\n            writable: true,\n            value: '',\n        });\n    });\n\n    test('returns correct cookie value for existing cookie', () => {\n        document.cookie = \"username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        expect(getCookie('username')).toBe('JohnDoe');\n    });\n\n    test('returns undefined if cookie does not exist', () => {\n        document.cookie = \"username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        expect(getCookie('user')).toBeFalsy();\n    });\n\n\n    test('returns undefined when no cookies are set', () => {\n        expect(getCookie('username')).toBeFalsy();\n    });\n\n    test('handles multiple cookies and retrieves the correct one', () => {\n        document.cookie = \"user=JaneDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        document.cookie = \"username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        expect(getCookie('username')).toBe('JohnDoe');\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * gets the cookie value for the specified name from the cookie in the browser. The format of the cookie is key=value;key=value;key=value\n * @param name cookie key name\n */\nfunction getCookie(name) {\n\n}", "addition_info": "/**\n * @jest-environment jsdom\n */"}, "typescript": {"code_signature": "/**\n * Gets the cookie value for the specified name from the cookie in the browser.\n * The format of the cookie is key=value;key=value;key=value.\n * @param name cookie key name\n * @returns cookie value or null if not found\n */\nfunction getCookie(name: string): string | null {\n\n}", "test_code": "describe('getCookie function tests', () => {\n    beforeEach(() => {\n        // Clear cookies before each test\n        Object.defineProperty(window.document, 'cookie', {\n            writable: true,\n            value: '',\n        });\n    });\n\n    test('returns correct cookie value for existing cookie', () => {\n        document.cookie = \"username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        expect(getCookie('username')).toBe('JohnDoe');\n    });\n\n    test('returns undefined if cookie does not exist', () => {\n        document.cookie = \"username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        expect(getCookie('user')).toBeFalsy();\n    });\n\n\n    test('returns undefined when no cookies are set', () => {\n        expect(getCookie('username')).toBeFalsy();\n    });\n\n    test('handles multiple cookies and retrieves the correct one', () => {\n        document.cookie = \"user=JaneDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        document.cookie = \"username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        expect(getCookie('username')).toBe('JohnDoe');\n    });\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Gets the cookie value for the specified name from the cookie in the browser.\n * The format of the cookie is key=value;key=value;key=value.\n * @param name cookie key name\n * @returns cookie value or null if not found\n */\nfunction getCookie(name: string): string | null {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 120, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Extract table data from a document object containing HTML tables and return the data organized as a two-dimensional array.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef extract_csv_data_from_html(html_content: str) -> List[List[str]]:\n    \"\"\"\n    Extract table question from an HTML string containing tables and return the question organized as a two-dimensional array.\n\n    Args:\n        html_content (str): A string containing HTML content.\n\n    Returns:\n        List[List[str]]: A two-dimensional array of strings representing the table data.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestHTMLToCSVExtraction(unittest.TestCase):\n\n    def test_table_with_multiple_rows_and_columns(self):\n        test_case_html = \"\"\"\n        <table class=\"waffle\">\n            <tbody>\n                <tr><td>Cell 1</td><td>Cell 2</td></tr>\n                <tr><td>Cell 3</td><td>Cell 4</td></tr>\n            </tbody>\n        </table>\n        \"\"\"\n        expected = [[\"Cell 1\", \"Cell 2\"], [\"Cell 3\", \"Cell 4\"]]\n        self.assertEqual(extract_csv_data_from_html(test_case_html), expected)\n\n    def test_table_with_empty_cells(self):\n        test_case_html = \"\"\"\n        <table class=\"waffle\">\n            <tbody>\n                <tr><td>Cell 1</td><td></td></tr>\n                <tr><td></td><td>Cell 4</td></tr>\n            </tbody>\n        </table>\n        \"\"\"\n        expected = [[\"Cell 1\", \"\"], [\"\", \"Cell 4\"]]\n        self.assertEqual(extract_csv_data_from_html(test_case_html), expected)\n\n    def test_table_with_only_one_row(self):\n        test_case_html = \"\"\"\n        <table class=\"waffle\">\n            <tbody>\n                <tr><td>Single Cell 1</td><td>Single Cell 2</td></tr>\n            </tbody>\n        </table>\n        \"\"\"\n        expected = [[\"Single Cell 1\", \"Single Cell 2\"]]\n        self.assertEqual(extract_csv_data_from_html(test_case_html), expected)\n\n    def test_table_with_only_one_column(self):\n        test_case_html = \"\"\"\n        <table class=\"waffle\">\n            <tbody>\n                <tr><td>Column Cell 1</td></tr>\n                <tr><td>Column Cell 2</td></tr>\n            </tbody>\n        </table>\n        \"\"\"\n        expected = [[\"Column Cell 1\"], [\"Column Cell 2\"]]\n        self.assertEqual(extract_csv_data_from_html(test_case_html), expected)\n\n    def test_no_table_with_class_waffle_present(self):\n        test_case_html = \"\"\"\n        <div>\n            <p>No table here!</p>\n        </div>\n        \"\"\"\n        expected = []\n        self.assertEqual(extract_csv_data_from_html(test_case_html), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef extract_csv_data_from_html(html_content: str) -> List[List[str]]:\n    \"\"\"\n    Extract table question from an HTML string containing tables and return the question organized as a two-dimensional array.\n\n    Args:\n        html_content (str): A string containing HTML content.\n\n    Returns:\n        List[List[str]]: A two-dimensional array of strings representing the table data.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extract table question from a document object containing HTML tables and return the question organized as a two-dimensional array.\n * @param {document} document\n */\n\nfunction extractCSVDataFromHTML(document) {\n    \n}\n  ", "test_code": "const { JSDOM } = require('jsdom');\n\ndescribe('HTML to CSV Extraction Tests', () => {\n  const createMockDocument = (html) => {\n    const dom = new JSDOM(html);\n    return dom.window.document;\n  };\n\n  const extractCSVDataFromHTML = (document) => {\n    const rows = document.querySelectorAll('table.waffle tbody tr');\n    return Array.from(rows).map(row =>\n      Array.from(row.cells).map(cell => cell.textContent || \"\")\n    );\n  };\n\n  test('Table with multiple rows and columns', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Cell 1</td><td>Cell 2</td></tr>\n          <tr><td>Cell 3</td><td>Cell 4</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Cell 1\", \"Cell 2\"], [\"Cell 3\", \"Cell 4\"]]);\n  });\n\n  test('Table with empty cells', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Cell 1</td><td></td></tr>\n          <tr><td></td><td>Cell 4</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Cell 1\", \"\"], [\"\", \"Cell 4\"]]);\n  });\n\n  test('Table with only one row', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Single Cell 1</td><td>Single Cell 2</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Single Cell 1\", \"Single Cell 2\"]]);\n  });\n\n  test('Table with only one column', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Column Cell 1</td></tr>\n          <tr><td>Column Cell 2</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Column Cell 1\"], [\"Column Cell 2\"]]);\n  });\n\n  test('No table with the class \"waffle\" present', () => {\n    const testCaseHTML = `\n      <div>\n        <p>No table here!</p>\n      </div>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([]);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Extract table question from a document object containing HTML tables and return the question organized as a two-dimensional array.\n * @param {document} document\n */\n\nfunction extractCSVDataFromHTML(document) {\n    \n}\n  ", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Extract table data from a document object containing HTML tables and return the data organized as a two-dimensional array.\n * @param {Document} document - The document object to extract data from.\n * @returns {string[][]} The extracted data organized as a two-dimensional array.\n */\nfunction extractCSVDataFromHTML(document: Document): string[][] {\n\n}", "test_code": "import { JSDOM } from 'jsdom';\n\ndescribe('HTML to CSV Extraction Tests', () => {\n  const createMockDocument = (html: string): Document => {\n    const dom = new JSDOM(html);\n    return dom.window.document;\n  };\n\n  const extractCSVDataFromHTML = (document: Document): string[][] => {\n    const rows = document.querySelectorAll('table.waffle tbody tr');\n    return Array.from(rows).map(row =>\n      Array.from(row.cells).map(cell => cell.textContent || \"\")\n    );\n  };\n\n  test('Table with multiple rows and columns', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Cell 1</td><td>Cell 2</td></tr>\n          <tr><td>Cell 3</td><td>Cell 4</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Cell 1\", \"Cell 2\"], [\"Cell 3\", \"Cell 4\"]]);\n  });\n\n  test('Table with empty cells', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Cell 1</td><td></td></tr>\n          <tr><td></td><td>Cell 4</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Cell 1\", \"\"], [\"\", \"Cell 4\"]]);\n  });\n\n  test('Table with only one row', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Single Cell 1</td><td>Single Cell 2</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Single Cell 1\", \"Single Cell 2\"]]);\n  });\n\n  test('Table with only one column', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Column Cell 1</td></tr>\n          <tr><td>Column Cell 2</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Column Cell 1\"], [\"Column Cell 2\"]]);\n  });\n\n  test('No table with the class \"waffle\" present', () => {\n    const testCaseHTML = `\n      <div>\n        <p>No table here!</p>\n      </div>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([]);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Extract table data from a document object containing HTML tables and return the data organized as a two-dimensional array.\n * @param {Document} document - The document object to extract data from.\n * @returns {string[][]} The extracted data organized as a two-dimensional array.\n */\nfunction extractCSVDataFromHTML(document: Document): string[][] {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 121, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Adjust the length of the input array according to the given target length (number). If the current length of the array is longer than the target length, the first part of the array is intercepted to match the target length; If the current length of the array is shorter than the target length, the elements in the array are repeated until the target length is reached.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef adjust_array_length(target_length: int, array: List) -> List:\n    \"\"\"\n    Adjust the length of the input array according to the given target length.\n    If the current length of the array is longer than the target length,\n    the first part of the array is intercepted to match the target length.\n    If the current length of the array is shorter than the target length,\n    the elements in the array are repeated until the target length is reached.\n\n    Args:\n        target_length (int): The desired length for the array.\n        array (List): The input array to be adjusted.\n\n    Returns:\n        List: A new array that has been adjusted to the target length.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestAdjustArrayLength(unittest.TestCase):\n\n    def test_array_length_equal_to_target_length(self):\n        result = adjust_array_length(5, [1, 2, 3, 4, 5])\n        self.assertEqual(result, [1, 2, 3, 4, 5])\n\n    def test_array_length_shorter_than_target_length(self):\n        result = adjust_array_length(8, [1, 2, 3])\n        self.assertEqual(result, [1, 2, 3, 1, 2, 3, 1, 2])\n\n    def test_array_length_shorter_than_target_length_multiple(self):\n        result = adjust_array_length(6, [10, 20])\n        self.assertEqual(result, [10, 20, 10, 20, 10, 20])\n\n    def test_array_length_shorter_than_target_length_not_multiple(self):\n        result = adjust_array_length(7, [7, 14, 21])\n        self.assertEqual(result, [7, 14, 21, 7, 14, 21, 7])\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef adjust_array_length(target_length: int, array: List) -> List:\n    \"\"\"\n    Adjust the length of the input array according to the given target length.\n    If the current length of the array is longer than the target length,\n    the first part of the array is intercepted to match the target length.\n    If the current length of the array is shorter than the target length,\n    the elements in the array are repeated until the target length is reached.\n\n    Args:\n        target_length (int): The desired length for the array.\n        array (List): The input array to be adjusted.\n\n    Returns:\n        List: A new array that has been adjusted to the target length.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Adjust the length of the input array according to the given target length (number). If the current length of the array is longer than the target length, the first part of the array is intercepted to match the target length; If the current length of the array is shorter than the target length, the elements in the array are repeated until the target length is reached.\n * \n * @param {number} targetLength - The desired length for the array.\n * @param {Array} array - The input array to be adjusted.\n * @returns {Array} - A new array that has been adjusted to the target length.\n */\nfunction adjustArrayLength(targetLength, array) {\n    // function implementation\n}\n", "test_code": "describe('adjustArrayLength function tests', () => {\n    test('Array length equal to the target length', () => {\n        const result = adjustArrayLength(5, [1, 2, 3, 4, 5]);\n        expect(result).toEqual([1, 2, 3, 4, 5]);\n    });\n\n    test('Array length shorter than the target length', () => {\n        const result = adjustArrayLength(8, [1, 2, 3]);\n        expect(result).toEqual([1, 2, 3, 1, 2, 3, 1, 2]);\n    });\n\n    test('Array length shorter than the target length, target length is a multiple of array length', () => {\n        const result = adjustArrayLength(6, [10, 20]);\n        expect(result).toEqual([10, 20, 10, 20, 10, 20]);\n    });\n\n    test('Array length shorter than the target length, target length is not a multiple of array length', () => {\n        const result = adjustArrayLength(7, [7, 14, 21]);\n        expect(result).toEqual([7, 14, 21, 7, 14, 21, 7]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Adjust the length of the input array according to the given target length (number). If the current length of the array is longer than the target length, the first part of the array is intercepted to match the target length; If the current length of the array is shorter than the target length, the elements in the array are repeated until the target length is reached.\n * \n * @param {number} targetLength - The desired length for the array.\n * @param {Array} array - The input array to be adjusted.\n * @returns {Array} - A new array that has been adjusted to the target length.\n */\nfunction adjustArrayLength(targetLength, array) {\n    // function implementation\n}\n", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Adjust the length of the input array according to the given target length (number). If the current length of the array is longer than the target length, the first part of the array is intercepted to match the target length; If the current length of the array is shorter than the target length, the elements in the array are repeated until the target length is reached.\n *\n * @param {number} targetLength - The desired length for the array.\n * @param {Array<any>} array - The input array to be adjusted.\n * @returns {Array<any>} - A new array that has been adjusted to the target length.\n */\nfunction adjustArrayLength<T>(targetLength: number, array: T[]): T[] {}", "test_code": "describe('adjustArrayLength function tests', () => {\n    test('Array length equal to the target length', () => {\n        const result = adjustArrayLength(5, [1, 2, 3, 4, 5]);\n        expect(result).toEqual([1, 2, 3, 4, 5]);\n    });\n\n    test('Array length shorter than the target length', () => {\n        const result = adjustArrayLength(8, [1, 2, 3]);\n        expect(result).toEqual([1, 2, 3, 1, 2, 3, 1, 2]);\n    });\n\n    test('Array length shorter than the target length, target length is a multiple of array length', () => {\n        const result = adjustArrayLength(6, [10, 20]);\n        expect(result).toEqual([10, 20, 10, 20, 10, 20]);\n    });\n\n    test('Array length shorter than the target length, target length is not a multiple of array length', () => {\n        const result = adjustArrayLength(7, [7, 14, 21]);\n        expect(result).toEqual([7, 14, 21, 7, 14, 21, 7]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Adjust the length of the input array according to the given target length (number). If the current length of the array is longer than the target length, the first part of the array is intercepted to match the target length; If the current length of the array is shorter than the target length, the elements in the array are repeated until the target length is reached.\n *\n * @param {number} targetLength - The desired length for the array.\n * @param {Array<any>} array - The input array to be adjusted.\n * @returns {Array<any>} - A new array that has been adjusted to the target length.\n */\nfunction adjustArrayLength<T>(targetLength: number, array: T[]): T[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Adjust the length of the input array according to the given target length (number).\n * If the current length of the array is longer than the target length, the first part\n * of the array is intercepted to match the target length; If the current length of the\n * array is shorter than the target length, the elements in the array are repeated until\n * the target length is reached.\n *\n * @param targetLength - The desired length for the array.\n * @param array - The input array to be adjusted.\n * @returns A new vector<int> that has been adjusted to the target length.\n */\nstd::vector<int> adjustArrayLength(int targetLength, const std::vector<int>& array) {\n    // function implementation\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <vector>\n\n// Function prototype\nstd::vector<int> adjustArrayLength(int targetLength, const std::vector<int>& array);\n\nTEST_CASE(\"adjustArrayLength function tests\") {\n    SECTION(\"Array length equal to the target length\") {\n        auto result = adjustArrayLength(5, {1, 2, 3, 4, 5});\n        REQUIRE(result == std::vector<int>{1, 2, 3, 4, 5});\n    }\n\n    SECTION(\"Array length shorter than the target length\") {\n        auto result = adjustArrayLength(8, {1, 2, 3});\n        REQUIRE(result == std::vector<int>{1, 2, 3, 1, 2, 3, 1, 2});\n    }\n\n    SECTION(\"Array length shorter than the target length, target length is a multiple of array length\") {\n        auto result = adjustArrayLength(6, {10, 20});\n        REQUIRE(result == std::vector<int>{10, 20, 10, 20, 10, 20});\n    }\n\n    SECTION(\"Array length shorter than the target length, target length is not a multiple of array length\") {\n        auto result = adjustArrayLength(7, {7, 14, 21});\n        REQUIRE(result == std::vector<int>{7, 14, 21, 7, 14, 21, 7});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Adjust the length of the input array according to the given target length (number).\n * If the current length of the array is longer than the target length, the first part\n * of the array is intercepted to match the target length; If the current length of the\n * array is shorter than the target length, the elements in the array are repeated until\n * the target length is reached.\n *\n * @param targetLength - The desired length for the array.\n * @param array - The input array to be adjusted.\n * @returns A new vector<int> that has been adjusted to the target length.\n */\nstd::vector<int> adjustArrayLength(int targetLength, const std::vector<int>& array) {\n    // function implementation\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Adjusts the length of the input array according to the given target length (int).\n * If the current length of the array is longer than the target length,\n * the first part of the array is intercepted to match the target length.\n * If the current length of the array is shorter than the target length,\n * the elements in the array are repeated until the target length is reached.\n *\n * @param targetLength - The desired length for the array.\n * @param array - The input array to be adjusted.\n * @returns A new array that has been adjusted to the target length.\n */\npublic static int[] adjustArrayLength(int targetLength, int[] array) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testArrayLengthEqualToTargetLength() {\n        int[] result = adjustArrayLength(5, new int[]{1, 2, 3, 4, 5});\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5}, result);\n    }\n\n    @Test\n    public void testArrayLengthShorterThanTargetLength() {\n        int[] result = adjustArrayLength(8, new int[]{1, 2, 3});\n        assertArrayEquals(new int[]{1, 2, 3, 1, 2, 3, 1, 2}, result);\n    }\n\n    @Test\n    public void testArrayLengthShorterThanTargetLengthMultiple() {\n        int[] result = adjustArrayLength(6, new int[]{10, 20});\n        assertArrayEquals(new int[]{10, 20, 10, 20, 10, 20}, result);\n    }\n\n    @Test\n    public void testArrayLengthShorterThanTargetLengthNotMultiple() {\n        int[] result = adjustArrayLength(7, new int[]{7, 14, 21});\n        assertArrayEquals(new int[]{7, 14, 21, 7, 14, 21, 7}, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Adjusts the length of the input array according to the given target length (int).\n * If the current length of the array is longer than the target length,\n * the first part of the array is intercepted to match the target length.\n * If the current length of the array is shorter than the target length,\n * the elements in the array are repeated until the target length is reached.\n *\n * @param targetLength - The desired length for the array.\n * @param array - The input array to be adjusted.\n * @returns A new array that has been adjusted to the target length.\n */\npublic static int[] adjustArrayLength(int targetLength, int[] array) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 122, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Safely splices an array by removing a specified number of elements from a given index,\n and optionally replaces them with a new element.", "language_version_list": {"python": {"code_signature": "def safe_splice(input_array:list, amount_to_remove, index_to_remove, replace_with=None):\n    \"\"\"\n    Safely splices an array by removing a specified number of elements from a given index,\n    and optionally replaces them with a new element.\n\n    Args:\n        input_array (list): The original array to be modified.\n        amount_to_remove (int): The number of elements to remove from the array.\n        index_to_remove (int): The index at which to start removing elements.\n        replace_with (any, optional): The element to replace the removed elements with.\n\n    Returns:\n        list: A new array with the specified elements removed and optionally replaced.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestSafeSplice(unittest.TestCase):\n\n    def test_replaces_removed_elements_with_a_new_element(self):\n        input_array = ['a', 'b', 'c', 'd', 'e']\n        expected = ['a', 'z', 'e']\n        result = safe_splice(input_array, 3, 1, 'z')\n        self.assertEqual(result, expected)\n\n    def test_removes_specified_elements_and_replaces_with_new_element(self):\n        input_array = [1, 2, 3, 4, 5]\n        amount_to_remove = 2\n        index_to_remove = 1\n        replace_with = 99\n        result = safe_splice(input_array, amount_to_remove, index_to_remove, replace_with)\n        self.assertEqual(result, [1, 99, 4, 5])\n\n    def test_handles_removing_elements_from_the_end_of_the_array(self):\n        input_array = [1, 2, 3, 4, 5]\n        amount_to_remove = 2\n        index_to_remove = 3\n        result = safe_splice(input_array, amount_to_remove, index_to_remove)\n        self.assertEqual(result, [1, 2, 3])\n\n    def test_handles_case_where_no_elements_are_removed(self):\n        input_array = [1, 2, 3, 4, 5]\n        amount_to_remove = 0\n        index_to_remove = 2\n        replace_with = 99\n        result = safe_splice(input_array, amount_to_remove, index_to_remove, replace_with)\n        self.assertEqual(result, [1, 2, 99, 3, 4, 5])\n\n    def test_handles_edge_case_with_empty_input_array(self):\n        input_array = []\n        amount_to_remove = 1\n        index_to_remove = 0\n        replace_with = 99\n        result = safe_splice(input_array, amount_to_remove, index_to_remove, replace_with)\n        self.assertEqual(result, [99])\n", "prompt": "please write a python function , the function signature as below def safe_splice(input_array:list, amount_to_remove, index_to_remove, replace_with=None):\n    \"\"\"\n    Safely splices an array by removing a specified number of elements from a given index,\n    and optionally replaces them with a new element.\n\n    Args:\n        input_array (list): The original array to be modified.\n        amount_to_remove (int): The number of elements to remove from the array.\n        index_to_remove (int): The index at which to start removing elements.\n        replace_with (any, optional): The element to replace the removed elements with.\n\n    Returns:\n        list: A new array with the specified elements removed and optionally replaced.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Safely splices an array by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n * \n * @param {Array} inputArray - The original array to be modified.\n * @param {number} amountToRemove - The number of elements to remove from the array.\n * @param {number} indexToRemove - The index at which to start removing elements.\n * @param {*} [replaceWith] - Optional. The element to replace the removed elements with.\n * @returns {Array} - A new array with the specified elements removed and optionally replaced.\n */\nfunction safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith) {\n    // function implementation\n}\n", "test_code": "describe('safeSplice', () => {\n    test('replaces removed elements with a new element', () => {\n        const inputArray = ['a', 'b', 'c', 'd', 'e'];\n        const expected = ['a', 'z', 'e'];\n        expect(safeSplice(inputArray, 3, 1, 'z')).toEqual(expected);\n    });\n    test('should remove specified elements and replace with new element', () => {\n        const inputArray = [1, 2, 3, 4, 5];\n        const amountToRemove = 2;\n        const indexToRemove = 1;\n        const replaceWith = 99;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        expect(result).toEqual([1, 99, 4, 5]);\n    });\n\n    test('should handle removing elements from the end of the array', () => {\n        const inputArray = [1, 2, 3, 4, 5];\n        const amountToRemove = 2;\n        const indexToRemove = 3;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove);\n        expect(result).toEqual([1, 2, 3]);\n    });\n\n    test('should handle the case where no elements are removed', () => {\n        const inputArray = [1, 2, 3, 4, 5];\n        const amountToRemove = 0;\n        const indexToRemove = 2;\n        const replaceWith = 99;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        expect(result).toEqual([1, 2, 99, 3, 4, 5]);\n    });\n\n    test('should handle edge case with an empty input array', () => {\n        const inputArray = [];\n        const amountToRemove = 1;\n        const indexToRemove = 0;\n        const replaceWith = 99;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        expect(result).toEqual([99]);\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Safely splices an array by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n * \n * @param {Array} inputArray - The original array to be modified.\n * @param {number} amountToRemove - The number of elements to remove from the array.\n * @param {number} indexToRemove - The index at which to start removing elements.\n * @param {*} [replaceWith] - Optional. The element to replace the removed elements with.\n * @returns {Array} - A new array with the specified elements removed and optionally replaced.\n */\nfunction safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith) {\n    // function implementation\n}\n", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Safely splices an array by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n *\n * @param {T[]} inputArray - The original array to be modified.\n * @param {number} amountToRemove - The number of elements to remove from the array.\n * @param {number} indexToRemove - The index at which to start removing elements.\n * @param {T} [replaceWith] - Optional. The element to replace the removed elements with.\n * @returns {T[]} - A new array with the specified elements removed and optionally replaced.\n */\nfunction safeSplice<T>(\n    inputArray: T[],\n    amountToRemove: number,\n    indexToRemove: number,\n    replaceWith?: T\n): T[] {}", "test_code": "describe('safeSplice', () => {\n    test('replaces removed elements with a new element', () => {\n        const inputArray: string[] = ['a', 'b', 'c', 'd', 'e'];\n        const expected: string[] = ['a', 'z', 'e'];\n        expect(safeSplice(inputArray, 3, 1, 'z')).toEqual(expected);\n    });\n\n    test('should remove specified elements and replace with new element', () => {\n        const inputArray: number[] = [1, 2, 3, 4, 5];\n        const amountToRemove: number = 2;\n        const indexToRemove: number = 1;\n        const replaceWith: number = 99;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        expect(result).toEqual([1, 99, 4, 5]);\n    });\n\n    test('should handle removing elements from the end of the array', () => {\n        const inputArray: number[] = [1, 2, 3, 4, 5];\n        const amountToRemove: number = 2;\n        const indexToRemove: number = 3;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove);\n        expect(result).toEqual([1, 2, 3]);\n    });\n\n    test('should handle the case where no elements are removed', () => {\n        const inputArray: number[] = [1, 2, 3, 4, 5];\n        const amountToRemove: number = 0;\n        const indexToRemove: number = 2;\n        const replaceWith: number = 99;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        expect(result).toEqual([1, 2, 99, 3, 4, 5]);\n    });\n\n    test('should handle edge case with an empty input array', () => {\n        const inputArray: number[] = [];\n        const amountToRemove: number = 1;\n        const indexToRemove: number = 0;\n        const replaceWith: number = 99;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        expect(result).toEqual([99]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Safely splices an array by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n *\n * @param {T[]} inputArray - The original array to be modified.\n * @param {number} amountToRemove - The number of elements to remove from the array.\n * @param {number} indexToRemove - The index at which to start removing elements.\n * @param {T} [replaceWith] - Optional. The element to replace the removed elements with.\n * @returns {T[]} - A new array with the specified elements removed and optionally replaced.\n */\nfunction safeSplice<T>(\n    inputArray: T[],\n    amountToRemove: number,\n    indexToRemove: number,\n    replaceWith?: T\n): T[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Safely splices a vector by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n *\n * @param std::vector<int> inputArray - The original vector to be modified.\n * @param int amountToRemove - The number of elements to remove from the vector.\n * @param int indexToRemove - The index at which to start removing elements.\n * @param std::optional<int> replaceWith - Optional. The element to replace the removed elements with.\n * @returns std::vector<int> - A new vector with the specified elements removed and optionally replaced.\n */\nstd::vector<int> safeSplice(const std::vector<int>& inputArray, int amountToRemove, int indexToRemove, std::optional<int> replaceWith){\n\n}\n", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <vector>\n#include <optional>\n\n// Assuming safeSplice function is declared here\n\nTEST_CASE(\"safeSplice\", \"[splice]\") {\n    SECTION(\"replaces removed elements with a new element\") {\n        std::vector<std::string> inputArray = {\"a\", \"b\", \"c\", \"d\", \"e\"};\n        std::vector<std::string> expected = {\"a\", \"z\", \"e\"};\n        REQUIRE(safeSplice(inputArray, 3, 1, \"z\") == expected);\n    }\n\n    SECTION(\"should remove specified elements and replace with new element\") {\n        std::vector<int> inputArray = {1, 2, 3, 4, 5};\n        int amountToRemove = 2;\n        int indexToRemove = 1;\n        int replaceWith = 99;\n        std::vector<int> result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        REQUIRE(result == std::vector<int>{1, 99, 4, 5});\n    }\n\n    SECTION(\"should handle removing elements from the end of the array\") {\n        std::vector<int> inputArray = {1, 2, 3, 4, 5};\n        int amountToRemove = 2;\n        int indexToRemove = 3;\n        std::vector<int> result = safeSplice(inputArray, amountToRemove, indexToRemove);\n        REQUIRE(result == std::vector<int>{1, 2, 3});\n    }\n\n    SECTION(\"should handle the case where no elements are removed\") {\n        std::vector<int> inputArray = {1, 2, 3, 4, 5};\n        int amountToRemove = 0;\n        int indexToRemove = 2;\n        int replaceWith = 99;\n        std::vector<int> result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        REQUIRE(result == std::vector<int>{1, 2, 99, 3, 4, 5});\n    }\n\n    SECTION(\"should handle edge case with an empty input array\") {\n        std::vector<int> inputArray = {};\n        int amountToRemove = 1;\n        int indexToRemove = 0;\n        int replaceWith = 99;\n        std::vector<int> result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        REQUIRE(result == std::vector<int>{99});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Safely splices a vector by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n *\n * @param std::vector<int> inputArray - The original vector to be modified.\n * @param int amountToRemove - The number of elements to remove from the vector.\n * @param int indexToRemove - The index at which to start removing elements.\n * @param std::optional<int> replaceWith - Optional. The element to replace the removed elements with.\n * @returns std::vector<int> - A new vector with the specified elements removed and optionally replaced.\n */\nstd::vector<int> safeSplice(const std::vector<int>& inputArray, int amountToRemove, int indexToRemove, std::optional<int> replaceWith){\n\n}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Safely splices a list by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n *\n * @param inputArray - The original list to be modified.\n * @param amountToRemove - The number of elements to remove from the list.\n * @param indexToRemove - The index at which to start removing elements.\n * @param replaceWith - Optional. The element to replace the removed elements with.\n * @return A new list with the specified elements removed and optionally replaced.\n */\npublic static List<Object> safeSplice(List<Object> inputArray, int amountToRemove, int indexToRemove, Object replaceWith) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertArrayEquals;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testReplacesRemovedElementsWithNewElement() {\n        List<Object> inputArray = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\");\n        List<Object> expected = Arrays.asList(\"a\", \"z\", \"e\");\n        assertArrayEquals(expected.toArray(), safeSplice(inputArray, 3, 1, \"z\").toArray());\n    }\n\n    @Test\n    public void testShouldRemoveSpecifiedElementsAndReplaceWithNewElement() {\n        List<Object> inputArray = Arrays.asList(1, 2, 3, 4, 5);\n        List<Object> expected = Arrays.asList(1, 99, 4, 5);\n        assertArrayEquals(expected.toArray(), safeSplice(inputArray, 2, 1, 99).toArray());\n    }\n\n    @Test\n    public void testShouldHandleRemovingElementsFromEnd() {\n        List<Object> inputArray = Arrays.asList(1, 2, 3, 4, 5);\n        List<Object> expected = Arrays.asList(1, 2, 3);\n        assertArrayEquals(expected.toArray(), safeSplice(inputArray, 2, 3, null).toArray());\n    }\n\n    @Test\n    public void testShouldHandleNoElementsRemoved() {\n        List<Object> inputArray = Arrays.asList(1, 2, 3, 4, 5);\n        List<Object> expected = Arrays.asList(1, 2, 99, 3, 4, 5);\n        assertArrayEquals(expected.toArray(), safeSplice(inputArray, 0, 2, 99).toArray());\n    }\n    \n}", "prompt": "please write a java function , the function signature as below /**\n * Safely splices a list by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n *\n * @param inputArray - The original list to be modified.\n * @param amountToRemove - The number of elements to remove from the list.\n * @param indexToRemove - The index at which to start removing elements.\n * @param replaceWith - Optional. The element to replace the removed elements with.\n * @return A new list with the specified elements removed and optionally replaced.\n */\npublic static List<Object> safeSplice(List<Object> inputArray, int amountToRemove, int indexToRemove, Object replaceWith) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 123, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Scale the values in an array from one range to another. To ensure that the values in the input array do not exceed the given minimum and maximum values, we can add checks to filter out values that are out of range", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef scale_to_range(input_array: List, input_min: float, input_max: float, output_min: float, output_max: float) -> List[\n    float]:\n    \"\"\"\n    Scales the values in an array from one range to another.\n    Args:\n        input_array (List): The array of input values to be scaled.\n        input_min (float): The minimum value in the input range.\n        input_max (float): The maximum value in the input range.\n        output_min (float): The minimum value in the output range.\n        output_max (float): The maximum value in the output range.\n\n    Returns:\n        List[float]: A new array with values scaled to the output range\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestScaleToRange(unittest.TestCase):\n    def test_simple_scaling(self):\n        result = scale_to_range([1, 2, 3, 4, 5], 1, 5, 10, 50)\n        self.assertEqual(result, [10, 20, 30, 40, 50])\n\n    def test_scaling_with_negative_input_range(self):\n        result = scale_to_range([-5, 0, 5], -5, 5, 0, 100)\n        self.assertEqual(result, [0, 50, 100])\n\n    def test_scaling_with_negative_output_range(self):\n        result = scale_to_range([0, 50, 100], 0, 100, -100, 100)\n        self.assertEqual(result, [-100, 0, 100])\n\n    def test_input_array_containing_the_same_value(self):\n        result = scale_to_range([2, 2, 2], 1, 3, 0, 10)\n        self.assertEqual(result, [5, 5, 5])\n\n    def test_input_value_out_of_range_should_throw_an_error(self):\n        with self.assertRaises(ValueError):\n            scale_to_range([1, 2, 3, 6], 1, 5, 0, 10)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef scale_to_range(input_array: List, input_min: float, input_max: float, output_min: float, output_max: float) -> List[\n    float]:\n    \"\"\"\n    Scales the values in an array from one range to another.\n    Args:\n        input_array (List): The array of input values to be scaled.\n        input_min (float): The minimum value in the input range.\n        input_max (float): The maximum value in the input range.\n        output_min (float): The minimum value in the output range.\n        output_max (float): The maximum value in the output range.\n\n    Returns:\n        List[float]: A new array with values scaled to the output range\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Scales the values in an array from one range to another.\n * \n * @param {number[]} inputArray - The array of input values to be scaled.\n * @param {number} inputMin - The minimum value in the input range.\n * @param {number} inputMax - The maximum value in the input range.\n * @param {number} outputMin - The minimum value in the output range.\n * @param {number} outputMax - The maximum value in the output range.\n * @returns {number[]} - A new array with values scaled to the output range.\n * @throws {Error} - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\nfunction scaleToRange(inputArray, inputMin, inputMax, outputMin, outputMax) {\n    // function implementation\n}\n", "test_code": "describe('scaleToRange function tests', () => {\n    test('simple scaling', () => {\n        const result = scaleToRange([1, 2, 3, 4, 5], 1, 5, 10, 50);\n        expect(result).toEqual([10, 20, 30, 40, 50]);\n    });\n\n    test('scaling with negative input range', () => {\n        const result = scaleToRange([-5, 0, 5], -5, 5, 0, 100);\n        expect(result).toEqual([0, 50, 100]);\n    });\n\n    test('scaling with negative output range', () => {\n        const result = scaleToRange([0, 50, 100], 0, 100, -100, 100);\n        expect(result).toEqual([-100, 0, 100]);\n    });\n\n    test('input array containing the same value', () => {\n        const result = scaleToRange([2, 2, 2], 1, 3, 0, 10);\n        expect(result).toEqual([5, 5, 5]);\n    });\n\n    test('input value out of range should throw an error', () => {\n        expect(() => {\n            scaleToRange([1, 2, 3, 6], 1, 5, 0, 10);\n        }).toThrow();\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Scales the values in an array from one range to another.\n * \n * @param {number[]} inputArray - The array of input values to be scaled.\n * @param {number} inputMin - The minimum value in the input range.\n * @param {number} inputMax - The maximum value in the input range.\n * @param {number} outputMin - The minimum value in the output range.\n * @param {number} outputMax - The maximum value in the output range.\n * @returns {number[]} - A new array with values scaled to the output range.\n * @throws {Error} - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\nfunction scaleToRange(inputArray, inputMin, inputMax, outputMin, outputMax) {\n    // function implementation\n}\n", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Scales the values in an array from one range to another.\n *\n * @param {number[]} inputArray - The array of input values to be scaled.\n * @param {number} inputMin - The minimum value in the input range.\n * @param {number} inputMax - The maximum value in the input range.\n * @param {number} outputMin - The minimum value in the output range.\n * @param {number} outputMax - The maximum value in the output range.\n * @returns {number[]} - A new array with values scaled to the output range.\n * @throws {Error} - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\nfunction scaleToRange(\n    inputArray: number[],\n    inputMin: number,\n    inputMax: number,\n    outputMin: number,\n    outputMax: number\n): number[] {\n    // function implementation\n}", "test_code": "describe('scaleToRange function tests', () => {\n    test('simple scaling', () => {\n        const result = scaleToRange([1, 2, 3, 4, 5], 1, 5, 10, 50);\n        expect(result).toEqual([10, 20, 30, 40, 50]);\n    });\n\n    test('scaling with negative input range', () => {\n        const result = scaleToRange([-5, 0, 5], -5, 5, 0, 100);\n        expect(result).toEqual([0, 50, 100]);\n    });\n\n    test('scaling with negative output range', () => {\n        const result = scaleToRange([0, 50, 100], 0, 100, -100, 100);\n        expect(result).toEqual([-100, 0, 100]);\n    });\n\n    test('input array containing the same value', () => {\n        const result = scaleToRange([2, 2, 2], 1, 3, 0, 10);\n        expect(result).toEqual([5, 5, 5]);\n    });\n\n    test('input value out of range should throw an error', () => {\n        expect(() => {\n            scaleToRange([1, 2, 3, 6], 1, 5, 0, 10);\n        }).toThrow();\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Scales the values in an array from one range to another.\n *\n * @param {number[]} inputArray - The array of input values to be scaled.\n * @param {number} inputMin - The minimum value in the input range.\n * @param {number} inputMax - The maximum value in the input range.\n * @param {number} outputMin - The minimum value in the output range.\n * @param {number} outputMax - The maximum value in the output range.\n * @returns {number[]} - A new array with values scaled to the output range.\n * @throws {Error} - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\nfunction scaleToRange(\n    inputArray: number[],\n    inputMin: number,\n    inputMax: number,\n    outputMin: number,\n    outputMax: number\n): number[] {\n    // function implementation\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Scales the values in an array from one range to another.\n *\n * @param inputArray - The array of input values to be scaled.\n * @param inputMin - The minimum value in the input range.\n * @param inputMax - The maximum value in the input range.\n * @param outputMin - The minimum value in the output range.\n * @param outputMax - The maximum value in the output range.\n * @returns A new vector with values scaled to the output range.\n * @throws std::invalid_argument - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\nstd::vector<double> scaleToRange(const std::vector<double>& inputArray, double inputMin, double inputMax, double outputMin, double outputMax) {\n    // function implementation\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <vector>\n#include <stdexcept>\n\nstd::vector<double> scaleToRange(const std::vector<double>& inputArray, double inputMin, double inputMax, double outputMin, double outputMax);\n\nTEST_CASE(\"scaleToRange function tests\") {\n    SECTION(\"simple scaling\") {\n        auto result = scaleToRange({1, 2, 3, 4, 5}, 1, 5, 10, 50);\n        REQUIRE(result == std::vector<double>({10, 20, 30, 40, 50}));\n    }\n\n    SECTION(\"scaling with negative input range\") {\n        auto result = scaleToRange({-5, 0, 5}, -5, 5, 0, 100);\n        REQUIRE(result == std::vector<double>({0, 50, 100}));\n    }\n\n    SECTION(\"scaling with negative output range\") {\n        auto result = scaleToRange({0, 50, 100}, 0, 100, -100, 100);\n        REQUIRE(result == std::vector<double>({-100, 0, 100}));\n    }\n\n    SECTION(\"input array containing the same value\") {\n        auto result = scaleToRange({2, 2, 2}, 1, 3, 0, 10);\n        REQUIRE(result == std::vector<double>({5, 5, 5}));\n    }\n\n    SECTION(\"input value out of range should throw an error\") {\n        REQUIRE_THROWS_AS(scaleToRange({1, 2, 3, 6}, 1, 5, 0, 10), std::invalid_argument);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Scales the values in an array from one range to another.\n *\n * @param inputArray - The array of input values to be scaled.\n * @param inputMin - The minimum value in the input range.\n * @param inputMax - The maximum value in the input range.\n * @param outputMin - The minimum value in the output range.\n * @param outputMax - The maximum value in the output range.\n * @returns A new vector with values scaled to the output range.\n * @throws std::invalid_argument - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\nstd::vector<double> scaleToRange(const std::vector<double>& inputArray, double inputMin, double inputMax, double outputMin, double outputMax) {\n    // function implementation\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Scales the values in an array from one range to another.\n *\n * @param inputArray - The array of input values to be scaled.\n * @param inputMin - The minimum value in the input range.\n * @param inputMax - The maximum value in the input range.\n * @param outputMin - The minimum value in the output range.\n * @param outputMax - The maximum value in the output range.\n * @return A new array with values scaled to the output range.\n * @throws IllegalArgumentException - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\npublic static double[] scaleToRange(double[] inputArray, double inputMin, double inputMax, double outputMin, double outputMax) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\n\nimport org.junit.Test;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testSimpleScaling() {\n        double[] result = scaleToRange(new double[]{1, 2, 3, 4, 5}, 1, 5, 10, 50);\n        assertArrayEquals(new double[]{10, 20, 30, 40, 50}, result, 0.001);\n    }\n\n    @Test\n    public void testScalingWithNegativeInputRange() {\n        double[] result = scaleToRange(new double[]{-5, 0, 5}, -5, 5, 0, 100);\n        assertArrayEquals(new double[]{0, 50, 100}, result, 0.001);\n    }\n\n    @Test\n    public void testScalingWithNegativeOutputRange() {\n        double[] result = scaleToRange(new double[]{0, 50, 100}, 0, 100, -100, 100);\n        assertArrayEquals(new double[]{-100, 0, 100}, result, 0.001);\n    }\n\n    @Test\n    public void testInputArrayContainingSameValue() {\n        double[] result = scaleToRange(new double[]{2, 2, 2}, 1, 3, 0, 10);\n        assertArrayEquals(new double[]{5, 5, 5}, result, 0.001);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testInputValueOutOfRangeShouldThrowError() {\n        scaleToRange(new double[]{1, 2, 3, 6}, 1, 5, 0, 10);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Scales the values in an array from one range to another.\n *\n * @param inputArray - The array of input values to be scaled.\n * @param inputMin - The minimum value in the input range.\n * @param inputMax - The maximum value in the input range.\n * @param outputMin - The minimum value in the output range.\n * @param outputMax - The maximum value in the output range.\n * @return A new array with values scaled to the output range.\n * @throws IllegalArgumentException - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\npublic static double[] scaleToRange(double[] inputArray, double inputMin, double inputMax, double outputMin, double outputMax) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 124, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Randomly sort the input array, that is, rearrange the elements of the array in a random order.", "language_version_list": {"python": {"code_signature": "def shuffle(array: list) -> list:\n    \"\"\"\n    Randomly shuffles the elements of the input list in place.\n\n    Args:\n        array (list): The list of elements to be shuffled.\n\n    Returns:\n        list: The shuffled list with its elements in random order.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestShuffleFunction(unittest.TestCase):\n\n    def test_shuffles_array_of_numbers(self):\n        array = [1, 2, 3, 4, 5]\n        shuffled_array = shuffle(array.copy())\n        self.assertEqual(len(shuffled_array), len(array))\n        self.assertTrue(all(item in array for item in shuffled_array))\n        self.assertEqual(len(set(shuffled_array)), len(set(array)))  # Ensure no duplicates\n\n    def test_shuffles_array_of_strings(self):\n        array = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"]\n        shuffled_array = shuffle(array.copy())\n        self.assertEqual(len(shuffled_array), len(array))\n        self.assertTrue(all(item in array for item in shuffled_array))\n\n    def test_shuffles_array_with_duplicate_elements(self):\n        array = [1, 1, 2, 2, 3, 3]\n        shuffled_array = shuffle(array.copy())\n        self.assertEqual(len(shuffled_array), len(array))\n        self.assertTrue(all(item in array for item in shuffled_array))\n\n    def test_shuffles_array_with_single_element(self):\n        array = [42]\n        shuffled_array = shuffle(array.copy())\n        self.assertEqual(shuffled_array, array)\n\n    def test_shuffles_empty_array(self):\n        array = []\n        shuffled_array = shuffle(array.copy())\n        self.assertEqual(len(shuffled_array), 0)\n", "prompt": "please write a python function , the function signature as below def shuffle(array: list) -> list:\n    \"\"\"\n    Randomly shuffles the elements of the input list in place.\n\n    Args:\n        array (list): The list of elements to be shuffled.\n\n    Returns:\n        list: The shuffled list with its elements in random order.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Randomly shuffles the elements of the input array in place.\n *\n * @param {Array} array - The array of elements to be shuffled.\n * @returns {Array} - The shuffled array with its elements in random order.\n */\nfunction shuffle(array) {\n    // function implementation\n}\n", "test_code": "describe('shuffle function tests', () => {\n    test('shuffles an array of numbers', () => {\n        const array = [1, 2, 3, 4, 5];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(array.length);\n        expect(shuffledArray.every(item => array.includes(item))).toBeTruthy();\n        expect(new Set(shuffledArray).size).toEqual(new Set(array).size); // Ensure no duplicates\n    });\n\n    test('shuffles an array of strings', () => {\n        const array = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(array.length);\n        expect(shuffledArray.every(item => array.includes(item))).toBeTruthy();\n    });\n\n    test('shuffles an array with duplicate elements', () => {\n        const array = [1, 1, 2, 2, 3, 3];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(array.length);\n        expect(shuffledArray.every(item => array.includes(item))).toBeTruthy();\n    });\n\n    test('shuffles an array with a single element', () => {\n        const array = [42];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray).toEqual(array);\n    });\n\n    test('shuffles an empty array', () => {\n        const array = [];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(0);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Randomly shuffles the elements of the input array in place.\n *\n * @param {Array} array - The array of elements to be shuffled.\n * @returns {Array} - The shuffled array with its elements in random order.\n */\nfunction shuffle(array) {\n    // function implementation\n}\n", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Randomly shuffles the elements of the input array in place.\n *\n * @param {T[]} array - The array of elements to be shuffled.\n * @returns {T[]} - The shuffled array with its elements in random order.\n */\nfunction shuffle<T>(array: T[]): T[] {}", "test_code": "describe('shuffle function tests', () => {\n    test('shuffles an array of numbers', () => {\n        const array: number[] = [1, 2, 3, 4, 5];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(array.length);\n        expect(shuffledArray.every(item => array.includes(item))).toBeTruthy();\n        expect(new Set(shuffledArray).size).toEqual(new Set(array).size); // Ensure no duplicates\n    });\n\n    test('shuffles an array of strings', () => {\n        const array: string[] = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(array.length);\n        expect(shuffledArray.every(item => array.includes(item))).toBeTruthy();\n    });\n\n    test('shuffles an array with duplicate elements', () => {\n        const array: number[] = [1, 1, 2, 2, 3, 3];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(array.length);\n        expect(shuffledArray.every(item => array.includes(item))).toBeTruthy();\n    });\n\n    test('shuffles an array with a single element', () => {\n        const array: number[] = [42];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray).toEqual(array);\n    });\n\n    test('shuffles an empty array', () => {\n        const array: any[] = [];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(0);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Randomly shuffles the elements of the input array in place.\n *\n * @param {T[]} array - The array of elements to be shuffled.\n * @returns {T[]} - The shuffled array with its elements in random order.\n */\nfunction shuffle<T>(array: T[]): T[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Randomly shuffles the elements of the input vector in place.\n *\n * @param std::vector<int>& array - The vector of elements to be shuffled.\n * @returns std::vector<int> - The shuffled vector with its elements in random order.\n */\nstd::vector<int> shuffle(std::vector<int>& array) {\n    // function implementation\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n\nstd::vector<int> shuffle(std::vector<int>& array); // Declaration of the shuffle function\n\nTEST_CASE(\"shuffle function tests\") {\n    SECTION(\"shuffles an array of numbers\") {\n        std::vector<int> array = {1, 2, 3, 4, 5};\n        std::vector<int> shuffledArray = array;\n        shuffle(shuffledArray);\n\n        REQUIRE(shuffledArray.size() == array.size());\n        REQUIRE(std::all_of(shuffledArray.begin(), shuffledArray.end(), [&](int item) {\n            return std::find(array.begin(), array.end(), item) != array.end();\n        }));\n        REQUIRE(std::set<int>(shuffledArray.begin(), shuffledArray.end()).size() ==\n                std::set<int>(array.begin(), array.end()).size()); // Ensure no duplicates\n    }\n\n    SECTION(\"shuffles an array of strings\") {\n        std::vector<std::string> array = {\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"};\n        std::vector<std::string> shuffledArray = array;\n        shuffle(shuffledArray);\n\n        REQUIRE(shuffledArray.size() == array.size());\n        REQUIRE(std::all_of(shuffledArray.begin(), shuffledArray.end(), [&](const std::string& item) {\n            return std::find(array.begin(), array.end(), item) != array.end();\n        }));\n    }\n\n    SECTION(\"shuffles an array with duplicate elements\") {\n        std::vector<int> array = {1, 1, 2, 2, 3, 3};\n        std::vector<int> shuffledArray = array;\n        shuffle(shuffledArray);\n\n        REQUIRE(shuffledArray.size() == array.size());\n        REQUIRE(std::all_of(shuffledArray.begin(), shuffledArray.end(), [&](int item) {\n            return std::find(array.begin(), array.end(), item) != array.end();\n        }));\n    }\n\n    SECTION(\"shuffles an array with a single element\") {\n        std::vector<int> array = {42};\n        std::vector<int> shuffledArray = array;\n        shuffle(shuffledArray);\n\n        REQUIRE(shuffledArray == array);\n    }\n\n    SECTION(\"shuffles an empty array\") {\n        std::vector<int> array = {};\n        std::vector<int> shuffledArray = array;\n        shuffle(shuffledArray);\n\n        REQUIRE(shuffledArray.size() == 0);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Randomly shuffles the elements of the input vector in place.\n *\n * @param std::vector<int>& array - The vector of elements to be shuffled.\n * @returns std::vector<int> - The shuffled vector with its elements in random order.\n */\nstd::vector<int> shuffle(std::vector<int>& array) {\n    // function implementation\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Randomly shuffles the elements of the input array in place.\n *\n * @param array - The array of elements to be shuffled.\n * @return - The shuffled array with its elements in random order.\n */\npublic static int[] shuffle(int[] array) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testShuffleNumbers() {\n        int[] array = {1, 2, 3, 4, 5};\n        int[] shuffledArray = shuffle(Arrays.copyOf(array, array.length));\n        assertEquals(array.length, shuffledArray.length);\n        assertTrue(Arrays.stream(shuffledArray).allMatch(i -> Arrays.stream(array).anyMatch(j -> j == i)));\n        assertEquals(new HashSet<>(Arrays.asList(Arrays.stream(shuffledArray).boxed().toArray(Integer[]::new))).size(),\n                new HashSet<>(Arrays.asList(Arrays.stream(array).boxed().toArray(Integer[]::new))).size());\n    }\n\n    @Test\n    public void testShuffleStrings() {\n        String[] array = {\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"};\n        String[] shuffledArray = {\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"};\n        assertEquals(array.length, shuffledArray.length);\n        assertTrue(Arrays.stream(shuffledArray).allMatch(i -> Arrays.stream(array).anyMatch(j -> j.equals(i))));\n    }\n\n    @Test\n    public void testShuffleDuplicates() {\n        int[] array = {1, 1, 2, 2, 3, 3};\n        int[] shuffledArray = shuffle(Arrays.copyOf(array, array.length));\n        assertEquals(array.length, shuffledArray.length);\n        assertTrue(Arrays.stream(shuffledArray).allMatch(i -> Arrays.stream(array).anyMatch(j -> j == i)));\n    }\n\n    @Test\n    public void testShuffleSingleElement() {\n        int[] array = {42};\n        int[] shuffledArray = shuffle(Arrays.copyOf(array, array.length));\n        assertArrayEquals(array, shuffledArray);\n    }\n\n    @Test\n    public void testShuffleEmptyArray() {\n        int[] array = {};\n        int[] shuffledArray = shuffle(Arrays.copyOf(array, array.length));\n        assertEquals(0, shuffledArray.length);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Randomly shuffles the elements of the input array in place.\n *\n * @param array - The array of elements to be shuffled.\n * @return - The shuffled array with its elements in random order.\n */\npublic static int[] shuffle(int[] array) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 125, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Compressing HTML strings removes unexpected whitespace and newlines from strings in tags", "language_version_list": {"python": {"code_signature": "def compress_html(html_string: str) -> str:\n    \"\"\"\n    Compresses an HTML string by removing unnecessary whitespace without disrupting\n    the integrity of content within <pre>, <div>, <script>, and <style> tags.\n\n    For example:\n        input: '   <div>   Content  </div>   '\n        output: '<div> Content </div>'\n\n    Args:\n        html_string (str): The HTML content to compress.\n\n    Returns:\n        str: The compressed HTML content.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCompressHTML(unittest.TestCase):\n\n    def test_remove_leading_and_trailing_spaces_around_tags(self):\n        input_html = '  <div>  <p>Test</p>  </div>  '\n        expected = '<div><p>Test</p></div>'\n        self.assertEqual(compress_html(input_html), expected)\n\n    def test_replace_multiple_newlines_with_single_space(self):\n        input_html = '<div>\\n\\n<p>Test</p>\\n\\n</div>'\n        expected = '<div> <p>Test</p> </div>'\n        self.assertEqual(compress_html(input_html), expected)\n\n    def test_remove_unnecessary_spaces_within_text(self):\n        input_html = '<p>This    is a test</p>'\n        expected = '<p>This is a test</p>'\n        self.assertEqual(compress_html(input_html), expected)\n\n    def test_handle_empty_strings(self):\n        input_html = ''\n        expected = ''\n        self.assertEqual(compress_html(input_html), expected)\n\n    def test_process_complex_nested_html_correctly(self):\n        input_html = '<div>   <span>    Text <i>    Italic </i> more text </span>   </div>'\n        expected = '<div><span>Text <i>Italic</i> more text</span></div>'\n        self.assertEqual(compress_html(input_html), expected)\n\n    def test_not_disrupt_content_within_pre_and_textarea_tags(self):\n        input_html = '<pre>\\n    function example() {\\n        console.log(\"example\");\\n    }\\n</pre>'\n        expected = '<pre>\\n    function example() {\\n        console.log(\"example\");\\n    }\\n</pre>'\n        self.assertEqual(compress_html(input_html), expected)\n\n    def test_handle_html_with_attributes_correctly(self):\n        input_html = '<a href=\"http://example.com\"    title=\"Example\" >Link</a>'\n        expected = '<a href=\"http://example.com\" title=\"Example\">Link</a>'\n        self.assertEqual(compress_html(input_html), expected)\n", "prompt": "please write a python function , the function signature as below def compress_html(html_string: str) -> str:\n    \"\"\"\n    Compresses an HTML string by removing unnecessary whitespace without disrupting\n    the integrity of content within <pre>, <div>, <script>, and <style> tags.\n\n    For example:\n        input: '   <div>   Content  </div>   '\n        output: '<div> Content </div>'\n\n    Args:\n        html_string (str): The HTML content to compress.\n\n    Returns:\n        str: The compressed HTML content.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <div>, <script>, and <style> tags.\n * For example:\n *      input: '   <div>   Content  </div>   '\n *      output: '<div> Content </div>'\n *\n * @param {string} htmlString - The HTML content to compress.\n * @returns {string} The compressed HTML content.\n */\nfunction compressHTML(htmlString) {\n\n}", "test_code": "describe('compressHTML', () => {\n    test('should remove leading and trailing spaces around tags', () => {\n        const input = '  <div>  <p>Test</p>  </div>  ';\n        const expected = '<div><p>Test</p></div>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should replace multiple newlines with a single space', () => {\n        const input = '<div>\\n\\n<p>Test</p>\\n\\n</div>';\n        const expected = '<div> <p>Test</p> </div>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should remove unnecessary spaces within text', () => {\n        const input = '<p>This    is a test</p>';\n        const expected = '<p>This is a test</p>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should handle empty strings', () => {\n        const input = '';\n        const expected = '';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should process complex nested HTML correctly', () => {\n        const input = '<div>   <span>    Text <i>    Italic </i> more text </span>   </div>';\n        const expected = '<div><span>Text <i>Italic</i> more text</span></div>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should not disrupt content within <pre> and <textarea> tags', () => {\n        const input = '<pre>\\n    function example() {\\n        console.log(\"example\");\\n    }\\n</pre>';\n        const expected = '<pre>\\n    function example() {\\n        console.log(\"example\");\\n    }\\n</pre>'; // assuming no changes in <pre> and <textarea>\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should handle HTML with attributes correctly', () => {\n        const input = '<a href=\"http://example.com\"    title=\"Example\" >Link</a>';\n        const expected = '<a href=\"http://example.com\" title=\"Example\">Link</a>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <div>, <script>, and <style> tags.\n * For example:\n *      input: '   <div>   Content  </div>   '\n *      output: '<div> Content </div>'\n *\n * @param {string} htmlString - The HTML content to compress.\n * @returns {string} The compressed HTML content.\n */\nfunction compressHTML(htmlString) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <div>, <script>, and <style> tags.\n * For example:\n *      input: '   <div>   Content  </div>   '\n *      output: '<div> Content </div>'\n *\n * @param {string} htmlString - The HTML content to compress.\n * @returns {string} The compressed HTML content.\n */\nfunction compressHTML(htmlString: string): string {\n\n}", "test_code": "describe('compressHTML', () => {\n    test('should remove leading and trailing spaces around tags', () => {\n        const input: string = '  <div>  <p>Test</p>  </div>  ';\n        const expected: string = '<div><p>Test</p></div>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should replace multiple newlines with a single space', () => {\n        const input: string = '<div>\\n\\n<p>Test</p>\\n\\n</div>';\n        const expected: string = '<div> <p>Test</p> </div>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should remove unnecessary spaces within text', () => {\n        const input: string = '<p>This    is a test</p>';\n        const expected: string = '<p>This is a test</p>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should handle empty strings', () => {\n        const input: string = '';\n        const expected: string = '';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should process complex nested HTML correctly', () => {\n        const input: string = '<div>   <span>    Text <i>    Italic </i> more text </span>   </div>';\n        const expected: string = '<div><span>Text <i>Italic</i> more text</span></div>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should not disrupt content within <pre> and <textarea> tags', () => {\n        const input: string = '<pre>\\n    function example() {\\n        console.log(\"example\");\\n    }\\n</pre>';\n        const expected: string = '<pre>\\n    function example() {\\n        console.log(\"example\");\\n    }\\n</pre>'; // assuming no changes in <pre> and <textarea>\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should handle HTML with attributes correctly', () => {\n        const input: string = '<a href=\"http://example.com\"    title=\"Example\" >Link</a>';\n        const expected: string = '<a href=\"http://example.com\" title=\"Example\">Link</a>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <div>, <script>, and <style> tags.\n * For example:\n *      input: '   <div>   Content  </div>   '\n *      output: '<div> Content </div>'\n *\n * @param {string} htmlString - The HTML content to compress.\n * @returns {string} The compressed HTML content.\n */\nfunction compressHTML(htmlString: string): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <div>, <script>, and <style> tags.\n * For example:\n *      input: '   <div>   Content  </div>   '\n *      output: '<div> Content </div>'\n *\n * @param htmlString - The HTML content to compress.\n * @returns The compressed HTML content.\n */\nstd::string compressHTML(const std::string& htmlString) {\n    // Implementation goes here\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\n// Assume compressHTML is defined elsewhere\nstd::string compressHTML(const std::string& htmlString);\n\nTEST_CASE(\"compressHTML\") {\n    SECTION(\"should remove leading and trailing spaces around tags\") {\n        std::string input = \"  <div>  <p>Test</p>  </div>  \";\n        std::string expected = \"<div><p>Test</p></div>\";\n        REQUIRE(compressHTML(input) == expected);\n    }\n\n    SECTION(\"should replace multiple newlines with a single space\") {\n        std::string input = \"<div>\\n\\n<p>Test</p>\\n\\n</div>\";\n        std::string expected = \"<div> <p>Test</p> </div>\";\n        REQUIRE(compressHTML(input) == expected);\n    }\n\n    SECTION(\"should remove unnecessary spaces within text\") {\n        std::string input = \"<p>This    is a test</p>\";\n        std::string expected = \"<p>This is a test</p>\";\n        REQUIRE(compressHTML(input) == expected);\n    }\n\n    SECTION(\"should handle empty strings\") {\n        std::string input = \"\";\n        std::string expected = \"\";\n        REQUIRE(compressHTML(input) == expected);\n    }\n\n    SECTION(\"should process complex nested HTML correctly\") {\n        std::string input = \"<div>   <span>    Text <i>    Italic </i> more text </span>   </div>\";\n        std::string expected = \"<div><span>Text <i>Italic</i> more text</span></div>\";\n        REQUIRE(compressHTML(input) == expected);\n    }\n\n    SECTION(\"should not disrupt content within <pre> and <textarea> tags\") {\n        std::string input = \"<pre>\\n    function example() {\\n        console.log(\\\"example\\\");\\n    }\\n</pre>\";\n        std::string expected = \"<pre>\\n    function example() {\\n        console.log(\\\"example\\\");\\n    }\\n</pre>\"; // assuming no changes in <pre> and <textarea>\n        REQUIRE(compressHTML(input) == expected);\n    }\n\n    SECTION(\"should handle HTML with attributes correctly\") {\n        std::string input = \"<a href=\\\"http://example.com\\\"    title=\\\"Example\\\" >Link</a>\";\n        std::string expected = \"<a href=\\\"http://example.com\\\" title=\\\"Example\\\">Link</a>\";\n        REQUIRE(compressHTML(input) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <div>, <script>, and <style> tags.\n * For example:\n *      input: '   <div>   Content  </div>   '\n *      output: '<div> Content </div>'\n *\n * @param htmlString - The HTML content to compress.\n * @returns The compressed HTML content.\n */\nstd::string compressHTML(const std::string& htmlString) {\n    // Implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <div>, <script>, and <style> tags.\n * For example:\n *      input: '   <div>   Content  </div>   '\n *      output: '<div> Content </div>'\n *\n * @param htmlString The HTML content to compress.\n * @return The compressed HTML content.\n */\npublic static String compressHTML(String htmlString) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testRemoveLeadingAndTrailingSpacesAroundTags() {\n        String input = \"  <div>  <p>Test</p>  </div>  \";\n        String expected = \"<div><p>Test</p></div>\";\n        assertEquals(expected, compressHTML(input));\n    }\n\n    @Test\n    public void testReplaceMultipleNewlinesWithSingleSpace() {\n        String input = \"<div>\\n\\n<p>Test</p>\\n\\n</div>\";\n        String expected = \"<div> <p>Test</p> </div>\";\n        assertEquals(expected, compressHTML(input));\n    }\n\n    @Test\n    public void testRemoveUnnecessarySpacesWithinText() {\n        String input = \"<p>This    is a test</p>\";\n        String expected = \"<p>This is a test</p>\";\n        assertEquals(expected, compressHTML(input));\n    }\n\n    @Test\n    public void testHandleEmptyStrings() {\n        String input = \"\";\n        String expected = \"\";\n        assertEquals(expected, compressHTML(input));\n    }\n\n    @Test\n    public void testProcessComplexNestedHTMLCorrectly() {\n        String input = \"<div>   <span>    Text <i>    Italic </i> more text </span>   </div>\";\n        String expected = \"<div><span>Text <i>Italic</i> more text</span></div>\";\n        assertEquals(expected, compressHTML(input));\n    }\n\n    @Test\n    public void testDoNotDisruptContentWithinPreAndTextareaTags() {\n        String input = \"<pre>\\n    function example() {\\n        console.log(\\\"example\\\");\\n    }\\n</pre>\";\n        String expected = \"<pre>\\n    function example() {\\n        console.log(\\\"example\\\");\\n    }\\n</pre>\"; // assuming no changes in <pre> and <textarea>\n        assertEquals(expected, compressHTML(input));\n    }\n\n    @Test\n    public void testHandleHTMLWithAttributesCorrectly() {\n        String input = \"<a href=\\\"http://example.com\\\"    title=\\\"Example\\\" >Link</a>\";\n        String expected = \"<a href=\\\"http://example.com\\\" title=\\\"Example\\\">Link</a>\";\n        assertEquals(expected, compressHTML(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <div>, <script>, and <style> tags.\n * For example:\n *      input: '   <div>   Content  </div>   '\n *      output: '<div> Content </div>'\n *\n * @param htmlString The HTML content to compress.\n * @return The compressed HTML content.\n */\npublic static String compressHTML(String htmlString) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 127, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Splits a list of MIDI note numbers into separate arrays of octaves and root notes.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef separate_octave_and_root(midi_notes: List[int])->dict:\n    \"\"\"\n    Splits a list of MIDI note numbers into separate lists of octaves and root notes.\n\n    Args:\n        midi_notes (List[int]): A list of MIDI note numbers.\n\n    Returns:\n        dict: A dictionary containing lists of octaves and root notes.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSeparateOctaveAndRoot(unittest.TestCase):\n\n    def test_correctly_separates_midi_notes(self):\n        midi_notes = [60, 61, 62]  # C4, C#4, D4\n        expected = {\n            'octaveNotes': [5, 5, 5],  # All notes are in the 5th octave\n            'rootNotes': [0, 1, 2]     # Root notes are C, C#, D\n        }\n        self.assertEqual(separate_octave_and_root(midi_notes), expected)\n\n    def test_handles_single_midi_note_input(self):\n        midi_notes = [24]  # C1\n        expected = {\n            'octaveNotes': [2],  # 2nd octave\n            'rootNotes': [0]     # C note\n        }\n        self.assertEqual(separate_octave_and_root(midi_notes), expected)\n\n    def test_returns_empty_arrays_for_empty_input_array(self):\n        midi_notes = []\n        expected = {\n            'octaveNotes': [],\n            'rootNotes': []\n        }\n        self.assertEqual(separate_octave_and_root(midi_notes), expected)\n\n    def test_throws_error_for_invalid_input_types(self):\n        invalid_inputs = [\"not an array\", [3.14]]\n        for invalid_input in invalid_inputs:\n            with self.assertRaises(TypeError):\n                separate_octave_and_root(invalid_input)\n\n    def test_handles_midi_notes_from_different_octaves(self):\n        midi_notes = [12, 25, 37]  # C1, C#2, D#3\n        expected = {\n            'octaveNotes': [1, 2, 3],  # 1st, 2nd, and 3rd octaves\n            'rootNotes': [0, 1, 1]     # Root notes are C, C#, D#\n        }\n        self.assertEqual(separate_octave_and_root(midi_notes), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef separate_octave_and_root(midi_notes: List[int])->dict:\n    \"\"\"\n    Splits a list of MIDI note numbers into separate lists of octaves and root notes.\n\n    Args:\n        midi_notes (List[int]): A list of MIDI note numbers.\n\n    Returns:\n        dict: A dictionary containing lists of octaves and root notes.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Splits a list of MIDI note numbers into separate arrays of octaves and root notes.\n *\n * @param {number[]} midiNotes - An array of MIDI note numbers.\n * @returns {Object} An object containing arrays of octaves and root notes.\n */\nfunction separateOctaveAndRoot(midiNotes) {\n\n}", "test_code": "describe('separateOctaveAndRoot', () => {\n    test('correctly separates MIDI notes into octaves and root notes', () => {\n        const midiNotes = [60, 61, 62];  // C4, C#4, D4\n        const expected = {\n            octaveNotes: [5, 5, 5],  // All notes are in the 5th octave\n            rootNotes: [0, 1, 2]     // Root notes are C, C#, D\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n\n    test('handles single MIDI note input', () => {\n        const midiNotes = [24];  // C1\n        const expected = {\n            octaveNotes: [2],  // 2nd octave\n            rootNotes: [0]     // C note\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n\n    test('returns empty arrays for an empty input array', () => {\n        const midiNotes = [];\n        const expected = {\n            octaveNotes: [],\n            rootNotes: []\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n\n    test('throws an error for invalid input types', () => {\n        const invalidInput = \"not an array\";\n        expect(() => separateOctaveAndRoot(invalidInput)).toThrow(TypeError);\n        expect(() => separateOctaveAndRoot([3.14])).toThrow(TypeError);\n    });\n\n    test('handles MIDI notes from different octaves', () => {\n        const midiNotes = [12, 25, 37];  // C1, C#2, D#3\n        const expected = {\n            octaveNotes: [1, 2, 3],  // 1st, 2nd, and 3rd octaves\n            rootNotes: [0, 1, 1]     // Root notes are C, C#, D#\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Splits a list of MIDI note numbers into separate arrays of octaves and root notes.\n *\n * @param {number[]} midiNotes - An array of MIDI note numbers.\n * @returns {Object} An object containing arrays of octaves and root notes.\n */\nfunction separateOctaveAndRoot(midiNotes) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Splits a list of MIDI note numbers into separate arrays of octaves and root notes.\n *\n * @param {number[]} midiNotes - An array of MIDI note numbers.\n * @returns {Object} An object containing arrays of octaves and root notes.\n */\nfunction separateOctaveAndRoot(midiNotes: number[]): { octaveNotes: number[]; rootNotes: number[] } {}", "test_code": "describe('separateOctaveAndRoot', () => {\n    test('correctly separates MIDI notes into octaves and root notes', () => {\n        const midiNotes: number[] = [60, 61, 62];  // C4, C#4, D4\n        const expected = {\n            octaveNotes: [5, 5, 5],  // All notes are in the 5th octave\n            rootNotes: [0, 1, 2]     // Root notes are C, C#, D\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n\n    test('handles single MIDI note input', () => {\n        const midiNotes: number[] = [24];  // C1\n        const expected = {\n            octaveNotes: [2],  // 2nd octave\n            rootNotes: [0]     // C note\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n\n    test('returns empty arrays for an empty input array', () => {\n        const midiNotes: number[] = [];\n        const expected = {\n            octaveNotes: [],\n            rootNotes: []\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n\n    test('throws an error for invalid input types', () => {\n        const invalidInput = \"not an array\";\n        expect(() => separateOctaveAndRoot(invalidInput as any)).toThrow(TypeError);\n        expect(() => separateOctaveAndRoot([3.14] as any)).toThrow(TypeError);\n    });\n\n    test('handles MIDI notes from different octaves', () => {\n        const midiNotes: number[] = [12, 25, 37];  // C1, C#2, D#3\n        const expected = {\n            octaveNotes: [1, 2, 3],  // 1st, 2nd, and 3rd octaves\n            rootNotes: [0, 1, 1]     // Root notes are C, C#, D#\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Splits a list of MIDI note numbers into separate arrays of octaves and root notes.\n *\n * @param {number[]} midiNotes - An array of MIDI note numbers.\n * @returns {Object} An object containing arrays of octaves and root notes.\n */\nfunction separateOctaveAndRoot(midiNotes: number[]): { octaveNotes: number[]; rootNotes: number[] } {}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 129, "code_type": "method", "original_language": "javascript", "question_type": "User interface", "summary": "Validates a URL string using a simplified and more comprehensive regular expression.", "language_version_list": {"python": {"code_signature": "def is_valid_url(url: str) -> bool:\n    \"\"\"\n    Validates a URL string using a simplified and comprehensive regular expression.\n\n    Args:\n        url (str): The URL string to validate.\n\n    Returns:\n        bool: True if the URL is valid, False otherwise.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestValidURL(unittest.TestCase):\n\n    def test_validates_standard_http_url(self):\n        url = 'http://www.example.com'\n        self.assertTrue(is_valid_url(url))\n\n    def test_validates_secure_https_url(self):\n        url = 'https://www.example.com'\n        self.assertTrue(is_valid_url(url))\n\n    def test_rejects_malformed_url(self):\n        url = 'htp:/www.example.com'\n        self.assertFalse(is_valid_url(url))\n", "prompt": "please write a python function , the function signature as below def is_valid_url(url: str) -> bool:\n    \"\"\"\n    Validates a URL string using a simplified and comprehensive regular expression.\n\n    Args:\n        url (str): The URL string to validate.\n\n    Returns:\n        bool: True if the URL is valid, False otherwise.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param {string} str - The URL string to validate.\n * @returns {boolean} True if the URL is valid, false otherwise.\n */\nfunction validURL(str) {\n\n}", "test_code": "describe('validURL', () => {\n    test('validates a standard HTTP URL', () => {\n        const url = 'http://www.example.com';\n        expect(validURL(url)).toBe(true);\n    });\n\n    test('validates a secure HTTPS URL', () => {\n        const url = 'https://www.example.com';\n        expect(validURL(url)).toBe(true);\n    });\n\n    test('rejects a malformed URL', () => {\n        const url = 'htp:/www.example.com';\n        expect(validURL(url)).toBe(false);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param {string} str - The URL string to validate.\n * @returns {boolean} True if the URL is valid, false otherwise.\n */\nfunction validURL(str) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param {string} str - The URL string to validate.\n * @returns {boolean} True if the URL is valid, false otherwise.\n */\nfunction validURL(str: string): boolean {}", "test_code": "describe('validURL', () => {\n    test('validates a standard HTTP URL', () => {\n        const url: string = 'http://www.example.com';\n        expect(validURL(url)).toBe(true);\n    });\n\n    test('validates a secure HTTPS URL', () => {\n        const url: string = 'https://www.example.com';\n        expect(validURL(url)).toBe(true);\n    });\n\n    test('rejects a malformed URL', () => {\n        const url: string = 'htp:/www.example.com';\n        expect(validURL(url)).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param {string} str - The URL string to validate.\n * @returns {boolean} True if the URL is valid, false otherwise.\n */\nfunction validURL(str: string): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param str - The URL string to validate.\n * @returns True if the URL is valid, false otherwise.\n */\nbool validURL(const std::string& str) {\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\n// Assuming the validURL function is defined somewhere\nbool validURL(const std::string& str);\n\nTEST_CASE(\"validURL\", \"[url]\") {\n    SECTION(\"validates a standard HTTP URL\") {\n        std::string url = \"http://www.example.com\";\n        REQUIRE(validURL(url) == true);\n    }\n\n    SECTION(\"validates a secure HTTPS URL\") {\n        std::string url = \"https://www.example.com\";\n        REQUIRE(validURL(url) == true);\n    }\n\n    SECTION(\"rejects a malformed URL\") {\n        std::string url = \"htp:/www.example.com\";\n        REQUIRE(validURL(url) == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param str - The URL string to validate.\n * @returns True if the URL is valid, false otherwise.\n */\nbool validURL(const std::string& str) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param str The URL string to validate.\n * @return True if the URL is valid, false otherwise.\n */\npublic static boolean validURL(String str) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void validatesAStandardHttpUrl() {\n        String url = \"http://www.example.com\";\n        assertTrue(validURL(url));\n    }\n\n    @Test\n    public void validatesASecureHttpsUrl() {\n        String url = \"https://www.example.com\";\n        assertTrue(validURL(url));\n    }\n\n    @Test\n    public void rejectsAMalformedUrl() {\n        String url = \"htp:/www.example.com\";\n        assertFalse(validURL(url));\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param str The URL string to validate.\n * @return True if the URL is valid, false otherwise.\n */\npublic static boolean validURL(String str) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 130, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library decimal.js", "language_version_list": {"python": {"code_signature": "def compute_pi(digits: int) -> str:\n    \"\"\"\n    Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library.\n\n    Args:\n        digits (int): The number of decimal digits to compute \u03c0 to.\n\n    Returns:\n        str: The value of \u03c0 to the specified number of digits.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestComputePi(unittest.TestCase):\n\n    def test_calculate_pi_5_decimal_places(self):\n        digits = 5\n        expected = '3.14159'\n        result = compute_pi(digits)\n        self.assertEqual(result, expected)\n\n    def test_calculate_pi_10_decimal_places(self):\n        digits = 10\n        expected = '3.1415926535'\n        result = compute_pi(digits)\n        self.assertEqual(result, expected)\n\n    def test_calculate_pi_15_decimal_places(self):\n        digits = 15\n        expected = '3.141592653589793'\n        result = compute_pi(digits)\n        self.assertEqual(result, expected)\n\n    def test_calculate_pi_20_decimal_places(self):\n        digits = 20\n        expected = '3.14159265358979323846'\n        result = compute_pi(digits)\n        self.assertEqual(result, expected)\n\n    def test_calculate_pi_30_decimal_places(self):\n        digits = 30\n        expected = '3.141592653589793238462643383279'\n        result = compute_pi(digits)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def compute_pi(digits: int) -> str:\n    \"\"\"\n    Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library.\n\n    Args:\n        digits (int): The number of decimal digits to compute \u03c0 to.\n\n    Returns:\n        str: The value of \u03c0 to the specified number of digits.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library decimal.js\n *\n * @param {number} digits - The number of decimal digits to compute \u03c0 to.\n * @returns {string} - The value of \u03c0 to the specified number of digits.\n */\nfunction computePi(digits) {\n\n}", "test_code": "describe('computePi', () => {\n    test('should calculate pi to 5 decimal places correctly', () => {\n        const digits = 5;\n        const expected = '3.14159';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 10 decimal places correctly', () => {\n        const digits = 10;\n        const expected = '3.1415926536';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 15 decimal places correctly', () => {\n        const digits = 15;\n        const expected = '3.141592653589793';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 20 decimal places correctly', () => {\n        const digits = 20;\n        const expected = '3.14159265358979323846';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 30 decimal places correctly', () => {\n        const digits = 30;\n        const expected = '3.141592653589793238462643383280';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library decimal.js\n *\n * @param {number} digits - The number of decimal digits to compute \u03c0 to.\n * @returns {string} - The value of \u03c0 to the specified number of digits.\n */\nfunction computePi(digits) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library decimal.js\n *\n * @param {number} digits - The number of decimal digits to compute \u03c0 to.\n * @returns {string} - The value of \u03c0 to the specified number of digits.\n */\nfunction computePi(digits: number): string {\n\n}", "test_code": "describe('computePi', () => {\n    test('should calculate pi to 5 decimal places correctly', () => {\n        const digits: number = 5;\n        const expected: string = '3.14159';\n        const result: string = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 10 decimal places correctly', () => {\n        const digits: number = 10;\n        const expected: string = '3.1415926536';\n        const result: string = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 15 decimal places correctly', () => {\n        const digits: number = 15;\n        const expected: string = '3.141592653589793';\n        const result: string = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 20 decimal places correctly', () => {\n        const digits: number = 20;\n        const expected: string = '3.14159265358979323846';\n        const result: string = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 30 decimal places correctly', () => {\n        const digits: number = 30;\n        const expected: string = '3.141592653589793238462643383280';\n        const result: string = computePi(digits);\n        expect(result).toBe(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library decimal.js\n *\n * @param {number} digits - The number of decimal digits to compute \u03c0 to.\n * @returns {string} - The value of \u03c0 to the specified number of digits.\n */\nfunction computePi(digits: number): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library\n *\n * @param digits - The number of decimal digits to compute \u03c0 to.\n * @returns - The value of \u03c0 to the specified number of digits as a string.\n */\nstd::string computePi(int digits) {\n    // Implementation goes here\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\n// Assuming computePi is defined elsewhere\nstd::string computePi(int digits);\n\nTEST_CASE(\"computePi\", \"[pi]\") {\n    SECTION(\"should calculate pi to 5 decimal places correctly\") {\n        int digits = 5;\n        std::string expected = \"3.14159\";\n        std::string result = computePi(digits);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"should calculate pi to 10 decimal places correctly\") {\n        int digits = 10;\n        std::string expected = \"3.1415926536\";\n        std::string result = computePi(digits);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"should calculate pi to 15 decimal places correctly\") {\n        int digits = 15;\n        std::string expected = \"3.141592653589793\";\n        std::string result = computePi(digits);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"should calculate pi to 20 decimal places correctly\") {\n        int digits = 20;\n        std::string expected = \"3.14159265358979323846\";\n        std::string result = computePi(digits);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"should calculate pi to 30 decimal places correctly\") {\n        int digits = 30;\n        std::string expected = \"3.141592653589793238462643383280\";\n        std::string result = computePi(digits);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library\n *\n * @param digits - The number of decimal digits to compute \u03c0 to.\n * @returns - The value of \u03c0 to the specified number of digits as a string.\n */\nstd::string computePi(int digits) {\n    // Implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic.\n *\n * @param digits - The number of decimal digits to compute \u03c0 to.\n * @return - The value of \u03c0 to the specified number of digits.\n */\npublic static String computePi(int digits) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testComputePiTo5DecimalPlaces() {\n        int digits = 5;\n        String expected = \"3.14159\";\n        String result = computePi(digits);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testComputePiTo10DecimalPlaces() {\n        int digits = 10;\n        String expected = \"3.1415926535\";\n        String result = computePi(digits);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testComputePiTo15DecimalPlaces() {\n        int digits = 15;\n        String expected = \"3.141592653589793\";\n        String result = computePi(digits);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testComputePiTo20DecimalPlaces() {\n        int digits = 20;\n        String expected = \"3.14159265358979323846\";\n        String result = computePi(digits);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testComputePiTo30DecimalPlaces() {\n        int digits = 30;\n        String expected = \"3.141592653589793238462643383279\";\n        String result = computePi(digits);\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic.\n *\n * @param digits - The number of decimal digits to compute \u03c0 to.\n * @return - The value of \u03c0 to the specified number of digits.\n */\npublic static String computePi(int digits) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 131, "code_type": "method", "original_language": "javascript", "question_type": "User interface", "summary": "Add a CSS rule to the HTML document to highlight search results", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Add a CSS rule to the HTML document to highlight search results\n */\nfunction checkCSSHighlightAndAdd() {\n\n}", "test_code": "describe('checkCSSHighlightAndAdd', () => {\n    beforeEach(() => {\n        // Clean up the document head and ensure at least one style sheet exists before each test\n        document.head.innerHTML = '<style></style>';\n    });\n\n    test('should add a new style element with the highlight CSS rule if it does not exist', () => {\n        checkCSSHighlightAndAdd();\n\n        // Check that the style element contains the correct CSS rule\n        const styleElement = document.querySelector('style');\n        expect(styleElement.sheet.cssRules[0].cssText).toContain(\"background-color: yellow;\");\n    });\n\n    test('should not add a new CSS rule if the CSS rule already exists', () => {\n        // Manually add the rule to simulate existing condition\n        document.styleSheets[0].insertRule(\".highlight { background-color: yellow; }\", 0);\n\n        checkCSSHighlightAndAdd();\n\n        // Check that only one rule is present\n        expect(document.styleSheets[0].cssRules.length).toBe(2);\n    });\n\n    test('should add only one rule even if called multiple times', () => {\n        checkCSSHighlightAndAdd();\n        checkCSSHighlightAndAdd();  // Call the function again\n\n        // Check that only one rule is present\n        expect(document.styleSheets[0].cssRules.length).toBe(2);\n    });\n\n    test('should correctly append the style element to the document head', () => {\n        checkCSSHighlightAndAdd();\n\n        // Check that the style element is indeed appended to the head\n        const styleElement = document.head.querySelector('style');\n        expect(document.head.contains(styleElement)).toBe(true);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Add a CSS rule to the HTML document to highlight search results\n */\nfunction checkCSSHighlightAndAdd() {\n\n}", "addition_info": "/**\n * @jest-environment jsdom\n */"}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 132, "code_type": "method", "original_language": "javascript", "question_type": "Configuration and deployment", "summary": "Use ESM syntax to import the file system module and define the file read and write operation functions", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Use ESM syntax to import the file system module and define the file read and write operation functions\n */\n\n/**\n * Reads the content of a file synchronously and returns it as a string.\n *\n * @param {string} filePath - The path to the file to be read.\n * @returns {string} - The content of the file as a UTF-8 encoded string.\n * @throws {Error} - Throws an error if the file cannot be read.\n */\nfunction readFile(filePath) {\n\n}\n\n/**\n * Writes question to a file synchronously.\n *\n * @param {string} filePath - The path to the file where question will be written.\n * @param {string} data - The question to be written to the file.\n * @throws {Error} - Throws an error if the file cannot be written.\n */\nfunction writeFile(filePath, data) {\n\n}", "test_code": "// Mock fs in your Jest tests\njest.mock('fs');\n\ndescribe('File Utility Functions', () => {\n    afterEach(() => {\n        jest.clearAllMocks();\n    });\n\n    test('readFile should return file content as a string', () => {\n        const mockContent = 'Hello, world!';\n        fs.readFileSync.mockReturnValue(mockContent);\n\n        const result = readFile('/path/to/file.txt');\n        expect(result).toBe(mockContent);\n        expect(fs.readFileSync).toHaveBeenCalledWith('/path/to/file.txt', 'utf8');\n    });\n\n    test('readFile should return an empty string for an empty file', () => {\n        const mockContent = '';\n        fs.readFileSync.mockReturnValue(mockContent);\n\n        const result = readFile('/path/to/emptyfile.txt');\n        expect(result).toBe(mockContent);\n        expect(fs.readFileSync).toHaveBeenCalledWith('/path/to/emptyfile.txt', 'utf8');\n    });\n\n    test('readFile should throw an error if file cannot be read', () => {\n        fs.readFileSync.mockImplementation(() => {\n            throw new Error('File not found');\n        });\n\n        expect(() => readFile('/invalid/path.txt')).toThrow();\n    });\n\n    test('writeFile should throw an error if file cannot be written', () => {\n        fs.writeFileSync.mockImplementation(() => {\n            throw new Error('Permission denied');\n        });\n\n        expect(() => writeFile('/invalid/path.txt', 'data')).toThrow();\n    });\n    test('readFile should handle large files correctly', () => {\n        const mockContent = 'a'.repeat(10000); // 10,000 characters long string\n        fs.readFileSync.mockReturnValue(mockContent);\n\n        const result = readFile('/path/to/largefile.txt');\n        expect(result).toBe(mockContent);\n        expect(fs.readFileSync).toHaveBeenCalledWith('/path/to/largefile.txt', 'utf8');\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Use ESM syntax to import the file system module and define the file read and write operation functions\n */\n\n/**\n * Reads the content of a file synchronously and returns it as a string.\n *\n * @param {string} filePath - The path to the file to be read.\n * @returns {string} - The content of the file as a UTF-8 encoded string.\n * @throws {Error} - Throws an error if the file cannot be read.\n */\nfunction readFile(filePath) {\n\n}\n\n/**\n * Writes question to a file synchronously.\n *\n * @param {string} filePath - The path to the file where question will be written.\n * @param {string} data - The question to be written to the file.\n * @throws {Error} - Throws an error if the file cannot be written.\n */\nfunction writeFile(filePath, data) {\n\n}", "addition_info": "const fs = require('fs');"}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 133, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Verify that the input string is a significant number between 5 and 18 in length\n", "language_version_list": {"python": {"code_signature": "def is_significant_number(input_value: str) -> bool:\n    \"\"\"\n    Check if the given input is a significant number.\n\n    A significant number is defined as a string that:\n    - Has a length between 5 and 18 characters (inclusive).\n    - Contains only digit characters.\n    - Cannot start with '0' if its length is greater than 1.\n    Args:\n        input_value (str): The input value to be checked.\n\n    Returns:\n        bool: True if the input is a significant number, False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestIsSignificantNumber(unittest.TestCase):\n\n    def test_valid_significant_number_with_exactly_5_digits(self):\n        self.assertTrue(is_significant_number(\"12345\"))\n\n    def test_number_with_leading_zero(self):\n        self.assertFalse(is_significant_number(\"01234\"))\n\n    def test_valid_significant_number_with_exactly_18_digits(self):\n        self.assertTrue(is_significant_number(\"123456789012345678\"))\n\n    def test_number_with_less_than_5_digits(self):\n        self.assertFalse(is_significant_number(\"123\"))\n\n    def test_number_with_more_than_18_digits(self):\n        self.assertFalse(is_significant_number(\"1234567890123456789\"))\n\n    def test_number_containing_non_digit_characters(self):\n        self.assertFalse(is_significant_number(\"1234a\"))\n\n    def test_single_zero(self):\n        self.assertFalse(is_significant_number(\"0\"))\n\n    def test_non_string_input(self):\n        self.assertFalse(is_significant_number(12345))\n", "prompt": "please write a python function , the function signature as below def is_significant_number(input_value: str) -> bool:\n    \"\"\"\n    Check if the given input is a significant number.\n\n    A significant number is defined as a string that:\n    - Has a length between 5 and 18 characters (inclusive).\n    - Contains only digit characters.\n    - Cannot start with '0' if its length is greater than 1.\n    Args:\n        input_value (str): The input value to be checked.\n\n    Returns:\n        bool: True if the input is a significant number, False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Checks if the input string is a significant number.\n * A significant number is defined as a string that:\n * - Is between 5 and 18 characters in length.\n * - Consists only of digits (0-9).\n * - Does not start with '0' if its length is greater than 1.\n *\n * @param {string} input - The input string to check.\n * @returns {boolean} - Returns true if the input is a significant number; otherwise, false.\n */\nfunction isSignificantNumber(input) {}", "test_code": "describe('isSignificantNumber', () => {\n    test('should return true for a valid significant number with exactly 5 digits', () => {\n        expect(isSignificantNumber(\"12345\")).toBe(true);\n    });\n\n    test('should return false for a number with leading zero', () => {\n        expect(isSignificantNumber(\"01234\")).toBe(false);\n    });\n\n    test('should return true for a valid significant number with exactly 18 digits', () => {\n        expect(isSignificantNumber(\"123456789012345678\")).toBe(true);\n    });\n\n    test('should return false for a number with less than 5 digits', () => {\n        expect(isSignificantNumber(\"123\")).toBe(false);\n    });\n\n    test('should return false for a number with more than 18 digits', () => {\n        expect(isSignificantNumber(\"1234567890123456789\")).toBe(false);\n    });\n\n    test('should return false for a number containing non-digit characters', () => {\n        expect(isSignificantNumber(\"1234a\")).toBe(false);\n    });\n\n    test('should return false for a single zero', () => {\n        expect(isSignificantNumber(\"0\")).toBe(false);\n    });\n\n    test('should return false for non-string input', () => {\n        expect(isSignificantNumber(12345)).toBe(false);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Checks if the input string is a significant number.\n * A significant number is defined as a string that:\n * - Is between 5 and 18 characters in length.\n * - Consists only of digits (0-9).\n * - Does not start with '0' if its length is greater than 1.\n *\n * @param {string} input - The input string to check.\n * @returns {boolean} - Returns true if the input is a significant number; otherwise, false.\n */\nfunction isSignificantNumber(input) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Checks if the input string is a significant number.\n * A significant number is defined as a string that:\n * - Is between 5 and 18 characters in length.\n * - Consists only of digits (0-9).\n * - Does not start with '0' if its length is greater than 1.\n *\n * @param {string} input - The input string to check.\n * @returns {boolean} - Returns true if the input is a significant number; otherwise, false.\n */\nfunction isSignificantNumber(input: string): boolean {}", "test_code": "describe('isSignificantNumber', () => {\n    test('should return true for a valid significant number with exactly 5 digits', () => {\n        expect(isSignificantNumber(\"12345\")).toBe(true);\n    });\n\n    test('should return false for a number with leading zero', () => {\n        expect(isSignificantNumber(\"01234\")).toBe(false);\n    });\n\n    test('should return true for a valid significant number with exactly 18 digits', () => {\n        expect(isSignificantNumber(\"123456789012345678\")).toBe(true);\n    });\n\n    test('should return false for a number with less than 5 digits', () => {\n        expect(isSignificantNumber(\"123\")).toBe(false);\n    });\n\n    test('should return false for a number with more than 18 digits', () => {\n        expect(isSignificantNumber(\"1234567890123456789\")).toBe(false);\n    });\n\n    test('should return false for a number containing non-digit characters', () => {\n        expect(isSignificantNumber(\"1234a\")).toBe(false);\n    });\n\n    test('should return false for a single zero', () => {\n        expect(isSignificantNumber(\"0\")).toBe(false);\n    });\n\n    test('should return false for non-string input', () => {\n        expect(isSignificantNumber(12345 as any)).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Checks if the input string is a significant number.\n * A significant number is defined as a string that:\n * - Is between 5 and 18 characters in length.\n * - Consists only of digits (0-9).\n * - Does not start with '0' if its length is greater than 1.\n *\n * @param {string} input - The input string to check.\n * @returns {boolean} - Returns true if the input is a significant number; otherwise, false.\n */\nfunction isSignificantNumber(input: string): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Checks if the input string is a significant number.\n * A significant number is defined as a string that:\n * - Is between 5 and 18 characters in length.\n * - Consists only of digits (0-9).\n * - Does not start with '0' if its length is greater than 1.\n *\n * @param input - The input string to check.\n * @returns true if the input is a significant number; otherwise, false.\n */\nbool isSignificantNumber(const std::string& input){}", "test_code": "TEST_CASE(\"isSignificantNumber\") {\n    SECTION(\"should return true for a valid significant number with exactly 5 digits\") {\n        REQUIRE(isSignificantNumber(\"12345\") == true);\n    }\n\n    SECTION(\"should return false for a number with leading zero\") {\n        REQUIRE(isSignificantNumber(\"01234\") == false);\n    }\n\n    SECTION(\"should return true for a valid significant number with exactly 18 digits\") {\n        REQUIRE(isSignificantNumber(\"123456789012345678\") == true);\n    }\n\n    SECTION(\"should return false for a number with less than 5 digits\") {\n        REQUIRE(isSignificantNumber(\"123\") == false);\n    }\n\n    SECTION(\"should return false for a number with more than 18 digits\") {\n        REQUIRE(isSignificantNumber(\"1234567890123456789\") == false);\n    }\n\n    SECTION(\"should return false for a number containing non-digit characters\") {\n        REQUIRE(isSignificantNumber(\"1234a\") == false);\n    }\n\n    SECTION(\"should return false for a single zero\") {\n        REQUIRE(isSignificantNumber(\"0\") == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Checks if the input string is a significant number.\n * A significant number is defined as a string that:\n * - Is between 5 and 18 characters in length.\n * - Consists only of digits (0-9).\n * - Does not start with '0' if its length is greater than 1.\n *\n * @param input - The input string to check.\n * @returns true if the input is a significant number; otherwise, false.\n */\nbool isSignificantNumber(const std::string& input){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks if the input string is a significant number.\n * A significant number is defined as a string that:\n * - Is between 5 and 18 characters in length.\n * - Consists only of digits (0-9).\n * - Does not start with '0' if its length is greater than 1.\n *\n * @param input The input string to check.\n * @return Returns true if the input is a significant number; otherwise, false.\n */\npublic static boolean isSignificantNumber(String input) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testValidSignificantNumberWithFiveDigits() {\n        assertTrue(isSignificantNumber(\"12345\"));\n    }\n\n    @Test\n    public void testLeadingZero() {\n        assertFalse(isSignificantNumber(\"01234\"));\n    }\n\n    @Test\n    public void testValidSignificantNumberWithEighteenDigits() {\n        assertTrue(isSignificantNumber(\"123456789012345678\"));\n    }\n\n    @Test\n    public void testLessThanFiveDigits() {\n        assertFalse(isSignificantNumber(\"123\"));\n    }\n\n    @Test\n    public void testMoreThanEighteenDigits() {\n        assertFalse(isSignificantNumber(\"1234567890123456789\"));\n    }\n\n    @Test\n    public void testNonDigitCharacters() {\n        assertFalse(isSignificantNumber(\"1234a\"));\n    }\n\n    @Test\n    public void testSingleZero() {\n        assertFalse(isSignificantNumber(\"0\"));\n    }\n    \n}", "prompt": "please write a java function , the function signature as below /**\n * Checks if the input string is a significant number.\n * A significant number is defined as a string that:\n * - Is between 5 and 18 characters in length.\n * - Consists only of digits (0-9).\n * - Does not start with '0' if its length is greater than 1.\n *\n * @param input The input string to check.\n * @return Returns true if the input is a significant number; otherwise, false.\n */\npublic static boolean isSignificantNumber(String input) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 134, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Checks whether the username is a string of length 5 to 16 that contains only alphanumeric Spaces", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef is_valid_username(username: str) -> bool:\n    \"\"\"\n    Checks whether the provided username is valid.\n    A valid username is defined as a string that:\n    - Has a length between 5 and 16 characters (inclusive).\n    - Contains only alphanumeric characters (letters and digits) and spaces.\n\n    Args:\n        username (str): The username to validate.\n\n    Returns:\n        bool: Returns True if the username is valid; otherwise, False.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestIsValidUsername(unittest.TestCase):\n\n    def test_valid_username_with_alphanumeric_characters(self):\n        self.assertTrue(is_valid_username('User123'))\n\n    def test_valid_username_with_spaces(self):\n        self.assertTrue(is_valid_username('User 123'))\n\n    def test_invalid_username_that_is_too_short(self):\n        self.assertFalse(is_valid_username('User'))\n\n    def test_invalid_username_that_is_too_long(self):\n        self.assertFalse(is_valid_username('ThisIsAVeryLongUsername'))\n\n    def test_invalid_username_with_special_characters(self):\n        self.assertFalse(is_valid_username('User!'))\n\n    def test_invalid_username_with_only_spaces(self):\n        self.assertFalse(is_valid_username('     '))\n\n    def test_invalid_input_type_number(self):\n        self.assertFalse(is_valid_username(12345))", "prompt": "please write a python function , the function signature as below import re\n\n\ndef is_valid_username(username: str) -> bool:\n    \"\"\"\n    Checks whether the provided username is valid.\n    A valid username is defined as a string that:\n    - Has a length between 5 and 16 characters (inclusive).\n    - Contains only alphanumeric characters (letters and digits) and spaces.\n\n    Args:\n        username (str): The username to validate.\n\n    Returns:\n        bool: Returns True if the username is valid; otherwise, False.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Checks whether the provided username is valid.\n * A valid username is defined as a string that:\n * - Has a length between 5 and 16 characters (inclusive).\n * - Contains only alphanumeric characters (letters and digits) and spaces.\n *\n * @param {string} username - The username to validate.\n * @returns {boolean} - Returns true if the username is valid; otherwise, false.\n */\nfunction isValidUsername(username) {}", "test_code": "describe('isValidUsername', () => {\n    test('valid username with alphanumeric characters', () => {\n        expect(isValidUsername('User123')).toBe(true);\n    });\n\n    test('valid username with spaces', () => {\n        expect(isValidUsername('User 123')).toBe(true);\n    });\n\n    test('invalid username that is too short', () => {\n        expect(isValidUsername('User')).toBe(false);\n    });\n\n    test('invalid username that is too long', () => {\n        expect(isValidUsername('ThisIsAVeryLongUsername')).toBe(false);\n    });\n\n    test('invalid username with special characters', () => {\n        expect(isValidUsername('User!')).toBe(false);\n    });\n\n    test('invalid username with only spaces', () => {\n        expect(isValidUsername('     ')).toBe(false);\n    });\n\n    test('invalid input type (number)', () => {\n        expect(isValidUsername(12345)).toBe(false);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Checks whether the provided username is valid.\n * A valid username is defined as a string that:\n * - Has a length between 5 and 16 characters (inclusive).\n * - Contains only alphanumeric characters (letters and digits) and spaces.\n *\n * @param {string} username - The username to validate.\n * @returns {boolean} - Returns true if the username is valid; otherwise, false.\n */\nfunction isValidUsername(username) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Checks whether the provided username is valid.\n * A valid username is defined as a string that:\n * - Has a length between 5 and 16 characters (inclusive).\n * - Contains only alphanumeric characters (letters and digits) and spaces.\n *\n * @param {string} username - The username to validate.\n * @returns {boolean} - Returns true if the username is valid; otherwise, false.\n */\nfunction isValidUsername(username: string): boolean {}", "test_code": "describe('isValidUsername', () => {\n    test('valid username with alphanumeric characters', () => {\n        expect(isValidUsername('User123')).toBe(true);\n    });\n\n    test('valid username with spaces', () => {\n        expect(isValidUsername('User 123')).toBe(true);\n    });\n\n    test('invalid username that is too short', () => {\n        expect(isValidUsername('User')).toBe(false);\n    });\n\n    test('invalid username that is too long', () => {\n        expect(isValidUsername('ThisIsAVeryLongUsername')).toBe(false);\n    });\n\n    test('invalid username with special characters', () => {\n        expect(isValidUsername('User!')).toBe(false);\n    });\n\n    test('invalid username with only spaces', () => {\n        expect(isValidUsername('     ')).toBe(false);\n    });\n\n    test('invalid input type (number)', () => {\n        expect(isValidUsername(12345 as any)).toBe(false); // Using 'as any' to bypass type check\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Checks whether the provided username is valid.\n * A valid username is defined as a string that:\n * - Has a length between 5 and 16 characters (inclusive).\n * - Contains only alphanumeric characters (letters and digits) and spaces.\n *\n * @param {string} username - The username to validate.\n * @returns {boolean} - Returns true if the username is valid; otherwise, false.\n */\nfunction isValidUsername(username: string): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Checks whether the provided username is valid.\n * A valid username is defined as a string that:\n * - Has a length between 5 and 16 characters (inclusive).\n * - Contains only alphanumeric characters (letters and digits) and spaces.\n *\n * @param username - The username to validate.\n * @returns true if the username is valid; otherwise, false.\n */\nbool isValidUsername(const std::string& username){}", "test_code": "TEST_CASE(\"isValidUsername\") {\n    SECTION(\"valid username with alphanumeric characters\") {\n        REQUIRE(isValidUsername(\"User123\") == true);\n    }\n\n    SECTION(\"valid username with spaces\") {\n        REQUIRE(isValidUsername(\"User 123\") == true);\n    }\n\n    SECTION(\"invalid username that is too short\") {\n        REQUIRE(isValidUsername(\"User\") == false);\n    }\n\n    SECTION(\"invalid username that is too long\") {\n        REQUIRE(isValidUsername(\"ThisIsAVeryLongUsername\") == false);\n    }\n\n    SECTION(\"invalid username with special characters\") {\n        REQUIRE(isValidUsername(\"User!\") == false);\n    }\n\n    SECTION(\"invalid username with only spaces\") {\n        REQUIRE(isValidUsername(\"     \") == false);\n    }\n\n    SECTION(\"invalid input type (number)\") {\n        // C++ does not allow passing an int to a string parameter directly.\n        // Assuming isValidUsername has a proper overload or handles this internally.\n        REQUIRE(isValidUsername(std::to_string(12345)) == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Checks whether the provided username is valid.\n * A valid username is defined as a string that:\n * - Has a length between 5 and 16 characters (inclusive).\n * - Contains only alphanumeric characters (letters and digits) and spaces.\n *\n * @param username - The username to validate.\n * @returns true if the username is valid; otherwise, false.\n */\nbool isValidUsername(const std::string& username){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks whether the provided username is valid.\n * A valid username is defined as a string that:\n * - Has a length between 5 and 16 characters (inclusive).\n * - Contains only alphanumeric characters (letters and digits) and spaces.\n *\n * @param username - The username to validate.\n * @return Returns true if the username is valid; otherwise, false.\n */\npublic static boolean isValidUsername(String username) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void validUsernameWithAlphanumericCharacters() {\n        assertTrue(isValidUsername(\"User123\"));\n    }\n\n    @Test\n    public void validUsernameWithSpaces() {\n        assertTrue(isValidUsername(\"User 123\"));\n    }\n\n    @Test\n    public void invalidUsernameThatIsTooShort() {\n        assertFalse(isValidUsername(\"User\"));\n    }\n\n    @Test\n    public void invalidUsernameThatIsTooLong() {\n        assertFalse(isValidUsername(\"ThisIsAVeryLongUsername\"));\n    }\n\n    @Test\n    public void invalidUsernameWithSpecialCharacters() {\n        assertFalse(isValidUsername(\"User!\"));\n    }\n\n    @Test\n    public void invalidUsernameWithOnlySpaces() {\n        assertFalse(isValidUsername(\"     \"));\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks whether the provided username is valid.\n * A valid username is defined as a string that:\n * - Has a length between 5 and 16 characters (inclusive).\n * - Contains only alphanumeric characters (letters and digits) and spaces.\n *\n * @param username - The username to validate.\n * @return Returns true if the username is valid; otherwise, false.\n */\npublic static boolean isValidUsername(String username) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 135, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Verify that the port number is within a valid range\n", "language_version_list": {"python": {"code_signature": "def is_valid_port_number(port: int) -> bool:\n    \"\"\"Checks if the provided port number is within the valid range of TCP/UDP ports.\n    \n    Valid TCP/UDP port numbers range from 1 to 65535.\n\n    Args:\n        port (int): The port number to verify.\n\n    Returns:\n        bool: Returns True if the port number is valid, False otherwise.\n\n    Raises:\n        TypeError: If the port number is not an integer.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsValidPortNumber(unittest.TestCase):\n\n    def test_valid_port_number_middle(self):\n        \"\"\"Returns true for a valid port number in the middle of the range.\"\"\"\n        self.assertTrue(is_valid_port_number(8080))\n\n    def test_lowest_valid_port_number(self):\n        \"\"\"Returns true for the lowest valid port number.\"\"\"\n        self.assertTrue(is_valid_port_number(1))\n\n    def test_highest_valid_port_number(self):\n        \"\"\"Returns true for the highest valid port number.\"\"\"\n        self.assertTrue(is_valid_port_number(65535))\n\n    def test_below_valid_range(self):\n        \"\"\"Returns false for a port number below the valid range.\"\"\"\n        self.assertFalse(is_valid_port_number(0))\n\n    def test_above_valid_range(self):\n        \"\"\"Returns false for a port number above the valid range.\"\"\"\n        self.assertFalse(is_valid_port_number(65536))\n", "prompt": "please write a python function , the function signature as below def is_valid_port_number(port: int) -> bool:\n    \"\"\"Checks if the provided port number is within the valid range of TCP/UDP ports.\n    \n    Valid TCP/UDP port numbers range from 1 to 65535.\n\n    Args:\n        port (int): The port number to verify.\n\n    Returns:\n        bool: Returns True if the port number is valid, False otherwise.\n\n    Raises:\n        TypeError: If the port number is not an integer.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param {number} port - The port number to verify.\n * @returns {boolean} Returns true if the port number is valid, false otherwise.\n */\nfunction isValidPortNumber(port) {\n\n}", "test_code": "describe('isValidPortNumber', () => {\n    test('returns true for a valid port number in the middle of the range', () => {\n        expect(isValidPortNumber(8080)).toBe(true);\n    });\n\n    test('returns true for the lowest valid port number', () => {\n        expect(isValidPortNumber(1)).toBe(true);\n    });\n\n    test('returns true for the highest valid port number', () => {\n        expect(isValidPortNumber(65535)).toBe(true);\n    });\n\n    test('returns false for a port number below the valid range', () => {\n        expect(isValidPortNumber(0)).toBe(false);\n    });\n\n    test('returns false for a port number above the valid range', () => {\n        expect(isValidPortNumber(65536)).toBe(false);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param {number} port - The port number to verify.\n * @returns {boolean} Returns true if the port number is valid, false otherwise.\n */\nfunction isValidPortNumber(port) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param {number} port - The port number to verify.\n * @returns {boolean} Returns true if the port number is valid, false otherwise.\n */\nfunction isValidPortNumber(port: number): boolean {}", "test_code": "describe('isValidPortNumber', () => {\n    test('returns true for a valid port number in the middle of the range', () => {\n        expect(isValidPortNumber(8080)).toBe(true);\n    });\n\n    test('returns true for the lowest valid port number', () => {\n        expect(isValidPortNumber(1)).toBe(true);\n    });\n\n    test('returns true for the highest valid port number', () => {\n        expect(isValidPortNumber(65535)).toBe(true);\n    });\n\n    test('returns false for a port number below the valid range', () => {\n        expect(isValidPortNumber(0)).toBe(false);\n    });\n\n    test('returns false for a port number above the valid range', () => {\n        expect(isValidPortNumber(65536)).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param {number} port - The port number to verify.\n * @returns {boolean} Returns true if the port number is valid, false otherwise.\n */\nfunction isValidPortNumber(port: number): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param port - The port number to verify.\n * @returns true if the port number is valid, false otherwise.\n */\nbool isValidPortNumber(int port){}", "test_code": "TEST_CASE(\"isValidPortNumber\") {\n    SECTION(\"returns true for a valid port number in the middle of the range\") {\n        REQUIRE(isValidPortNumber(8080) == true);\n    }\n\n    SECTION(\"returns true for the lowest valid port number\") {\n        REQUIRE(isValidPortNumber(1) == true);\n    }\n\n    SECTION(\"returns true for the highest valid port number\") {\n        REQUIRE(isValidPortNumber(65535) == true);\n    }\n\n    SECTION(\"returns false for a port number below the valid range\") {\n        REQUIRE_THROWS_AS(isValidPortNumber(0), std::invalid_argument);\n    }\n\n    SECTION(\"returns false for a port number above the valid range\") {\n        REQUIRE_THROWS_AS(isValidPortNumber(65536), std::invalid_argument);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param port - The port number to verify.\n * @returns true if the port number is valid, false otherwise.\n */\nbool isValidPortNumber(int port){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param port The port number to verify.\n * @return Returns true if the port number is valid, false otherwise.\n */\npublic static boolean isValidPortNumber(int port) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void testValidPortNumber_MiddleOfRange() {\n        assertTrue(isValidPortNumber(8080));\n    }\n\n    @Test\n    public void testValidPortNumber_Lowest() {\n        assertTrue(isValidPortNumber(1));\n    }\n\n    @Test\n    public void testValidPortNumber_Highest() {\n        assertTrue(isValidPortNumber(65535));\n    }\n\n    @Test\n    public void testValidPortNumber_BelowRange() {\n        assertFalse(isValidPortNumber(0));\n    }\n\n    @Test\n    public void testValidPortNumber_AboveRange() {\n        assertFalse(isValidPortNumber(65536));\n    }\n\n    // The method to be tested\n    public static boolean isValidPortNumber(int port) {\n        return port >= 1 && port <= 65535;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param port The port number to verify.\n * @return Returns true if the port number is valid, false otherwise.\n */\npublic static boolean isValidPortNumber(int port) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 137, "code_type": "method", "original_language": "javascript", "question_type": "User interface", "summary": "Merges two objects into one object\n", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Merges two objects into one, with properties from the second object\n * potentially overwriting those from the first if there are conflicts.\n *\n * @param {Object} obj1 - The first object.\n * @param {Object} obj2 - The second object.\n * @returns {Object} - The resulting object after merging.\n */\nfunction mergeObjects(obj1, obj2) {\n\n}", "test_code": "describe('mergeObjects', () => {\n    test('correctly merges two objects with non-conflicting keys', () => {\n        const obj1 = { name: \"Alice\" };\n        const obj2 = { age: 30 };\n        const expected = { name: \"Alice\", age: 30 };\n        expect(mergeObjects(obj1, obj2)).toEqual(expected);\n    });\n\n    test('properties from the second object overwrite properties from the first', () => {\n        const obj1 = { name: \"Alice\", age: 25 };\n        const obj2 = { age: 30 };\n        const expected = { name: \"Alice\", age: 30 };\n        expect(mergeObjects(obj1, obj2)).toEqual(expected);\n    });\n\n    test('merges objects with nested structures correctly', () => {\n        const obj1 = { user: { name: \"Alice\", age: 25 } };\n        const obj2 = { user: { age: 30 } };\n        const expected = { user: { age: 30 } };  // Note: obj2 does not merge deeply, it replaces the entire 'user' object\n        expect(mergeObjects(obj1, obj2)).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Merges two objects into one, with properties from the second object\n * potentially overwriting those from the first if there are conflicts.\n *\n * @param {Object} obj1 - The first object.\n * @param {Object} obj2 - The second object.\n * @returns {Object} - The resulting object after merging.\n */\nfunction mergeObjects(obj1, obj2) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Merges two objects into one, with properties from the second object\n * potentially overwriting those from the first if there are conflicts.\n *\n * @param {Record<string, any>} obj1 - The first object.\n * @param {Record<string, any>} obj2 - The second object.\n * @returns {Record<string, any>} - The resulting object after merging.\n */\nfunction mergeObjects(obj1: Record<string, any>, obj2: Record<string, any>): Record<string, any> {}", "test_code": "describe('mergeObjects', () => {\n    test('correctly merges two objects with non-conflicting keys', () => {\n        const obj1: Record<string, any> = { name: \"Alice\" };\n        const obj2: Record<string, any> = { age: 30 };\n        const expected: Record<string, any> = { name: \"Alice\", age: 30 };\n        expect(mergeObjects(obj1, obj2)).toEqual(expected);\n    });\n\n    test('properties from the second object overwrite properties from the first', () => {\n        const obj1: Record<string, any> = { name: \"Alice\", age: 25 };\n        const obj2: Record<string, any> = { age: 30 };\n        const expected: Record<string, any> = { name: \"Alice\", age: 30 };\n        expect(mergeObjects(obj1, obj2)).toEqual(expected);\n    });\n\n    test('merges objects with nested structures correctly', () => {\n        const obj1: Record<string, any> = { user: { name: \"Alice\", age: 25 } };\n        const obj2: Record<string, any> = { user: { age: 30 } };\n        const expected: Record<string, any> = { user: { age: 30 } };  // Note: obj2 does not merge deeply, it replaces the entire 'user' object\n        expect(mergeObjects(obj1, obj2)).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Merges two objects into one, with properties from the second object\n * potentially overwriting those from the first if there are conflicts.\n *\n * @param {Record<string, any>} obj1 - The first object.\n * @param {Record<string, any>} obj2 - The second object.\n * @returns {Record<string, any>} - The resulting object after merging.\n */\nfunction mergeObjects(obj1: Record<string, any>, obj2: Record<string, any>): Record<string, any> {}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 138, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "removes all punctuation from a given string, converts the string to lowercase,\nand trims whitespace from both ends. ", "language_version_list": {"python": {"code_signature": "def remove_punctuation(s: str) -> str:\n    \"\"\"\n    Removes all punctuation from a given string, converts the string to lowercase,\n    and trims whitespace from both ends.\n\n    Args:\n        s (str): The string from which to remove punctuation.\n\n    Returns:\n        str: The cleaned and formatted string.\n    \"\"\"", "test_code": "import unittest\nimport re\n\nclass TestRemovePunctuation(unittest.TestCase):\n\n    def test_removes_punctuation_from_simple_sentence(self):\n        input_string = \"Hello, world!\"\n        expected = \"hello world\"\n        self.assertEqual(remove_punctuation(input_string), expected)\n\n    def test_handles_string_with_no_punctuation(self):\n        input_string = \"Hello world\"\n        expected = \"hello world\"\n        self.assertEqual(remove_punctuation(input_string), expected)\n\n    def test_converts_mixed_case_letters_to_lowercase(self):\n        input_string = \"HeLLo WoRLd!\"\n        expected = \"hello world\"\n        self.assertEqual(remove_punctuation(input_string), expected)\n\n    def test_removes_a_variety_of_punctuation(self):\n        input_string = \"Life, in a nutshell: eat, sleep, code!\"\n        expected = \"life in a nutshell eat sleep code\"\n        self.assertEqual(remove_punctuation(input_string), expected)\n\n    def test_trims_whitespace_from_ends(self):\n        input_string = \"   What a wonderful world!   \"\n        expected = \"what a wonderful world\"\n        self.assertEqual(remove_punctuation(input_string), expected)", "prompt": "please write a python function , the function signature as below def remove_punctuation(s: str) -> str:\n    \"\"\"\n    Removes all punctuation from a given string, converts the string to lowercase,\n    and trims whitespace from both ends.\n\n    Args:\n        s (str): The string from which to remove punctuation.\n\n    Returns:\n        str: The cleaned and formatted string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param {string} str - The string from which to remove punctuation.\n * @returns {string} The cleaned and formatted string.\n */\nfunction removePunctuation(str) {\n\n}", "test_code": "describe('removePunctuation', () => {\n    test('removes punctuation from a simple sentence', () => {\n        const input = \"Hello, world!\";\n        const expected = \"hello world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('handles a string with no punctuation', () => {\n        const input = \"Hello world\";\n        const expected = \"hello world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('converts mixed case letters to lowercase', () => {\n        const input = \"HeLLo WoRLd!\";\n        const expected = \"hello world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('removes a variety of punctuation', () => {\n        const input = \"Life, in a nutshell: eat, sleep, code!\";\n        const expected = \"life in a nutshell eat sleep code\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('trims whitespace from the ends of the string', () => {\n        const input = \"   What a wonderful world!   \";\n        const expected = \"what a wonderful world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param {string} str - The string from which to remove punctuation.\n * @returns {string} The cleaned and formatted string.\n */\nfunction removePunctuation(str) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param {string} str - The string from which to remove punctuation.\n * @returns {string} The cleaned and formatted string.\n */\nfunction removePunctuation(str: string): string {}", "test_code": "describe('removePunctuation', () => {\n    test('removes punctuation from a simple sentence', () => {\n        const input: string = \"Hello, world!\";\n        const expected: string = \"hello world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('handles a string with no punctuation', () => {\n        const input: string = \"Hello world\";\n        const expected: string = \"hello world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('converts mixed case letters to lowercase', () => {\n        const input: string = \"HeLLo WoRLd!\";\n        const expected: string = \"hello world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('removes a variety of punctuation', () => {\n        const input: string = \"Life, in a nutshell: eat, sleep, code!\";\n        const expected: string = \"life in a nutshell eat sleep code\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('trims whitespace from the ends of the string', () => {\n        const input: string = \"   What a wonderful world!   \";\n        const expected: string = \"what a wonderful world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param {string} str - The string from which to remove punctuation.\n * @returns {string} The cleaned and formatted string.\n */\nfunction removePunctuation(str: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param str The string from which to remove punctuation.\n * @returns The cleaned and formatted string.\n */\nstd::string removePunctuation(const std::string& str) {}", "test_code": "TEST_CASE(\"removePunctuation\", \"[string]\") {\n    SECTION(\"removes punctuation from a simple sentence\") {\n        std::string input = \"Hello, world!\";\n        std::string expected = \"hello world\";\n        REQUIRE(removePunctuation(input) == expected);\n    }\n\n    SECTION(\"handles a string with no punctuation\") {\n        std::string input = \"Hello world\";\n        std::string expected = \"hello world\";\n        REQUIRE(removePunctuation(input) == expected);\n    }\n\n    SECTION(\"converts mixed case letters to lowercase\") {\n        std::string input = \"HeLLo WoRLd!\";\n        std::string expected = \"hello world\";\n        REQUIRE(removePunctuation(input) == expected);\n    }\n\n    SECTION(\"removes a variety of punctuation\") {\n        std::string input = \"Life, in a nutshell: eat, sleep, code!\";\n        std::string expected = \"life in a nutshell eat sleep code\";\n        REQUIRE(removePunctuation(input) == expected);\n    }\n\n    SECTION(\"trims whitespace from the ends of the string\") {\n        std::string input = \"   What a wonderful world!   \";\n        std::string expected = \"what a wonderful world\";\n        REQUIRE(removePunctuation(input) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param str The string from which to remove punctuation.\n * @returns The cleaned and formatted string.\n */\nstd::string removePunctuation(const std::string& str) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param str The string from which to remove punctuation.\n * @return The cleaned and formatted string.\n */\npublic static String removePunctuation(String str) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testRemovesPunctuationFromSimpleSentence() {\n        String input = \"Hello, world!\";\n        String expected = \"hello world\";\n        assertEquals(expected, removePunctuation(input));\n    }\n\n    @Test\n    public void testHandlesStringWithNoPunctuation() {\n        String input = \"Hello world\";\n        String expected = \"hello world\";\n        assertEquals(expected, removePunctuation(input));\n    }\n\n    @Test\n    public void testConvertsMixedCaseLettersToLowercase() {\n        String input = \"HeLLo WoRLd!\";\n        String expected = \"hello world\";\n        assertEquals(expected, removePunctuation(input));\n    }\n\n    @Test\n    public void testRemovesVarietyOfPunctuation() {\n        String input = \"Life, in a nutshell: eat, sleep, code!\";\n        String expected = \"life in a nutshell eat sleep code\";\n        assertEquals(expected, removePunctuation(input));\n    }\n\n    @Test\n    public void testTrimsWhitespaceFromEndsOfString() {\n        String input = \"   What a wonderful world!   \";\n        String expected = \"what a wonderful world\";\n        assertEquals(expected, removePunctuation(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param str The string from which to remove punctuation.\n * @return The cleaned and formatted string.\n */\npublic static String removePunctuation(String str) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 139, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Extract Categories from the summary string, the first complete sentence", "language_version_list": {"python": {"code_signature": "def parse_categories_from_summary(summarized_output: str = '') -> dict:\n    \"\"\"\n    Extracts categories from a summarized output string and returns the cleaned summary and categories.\n\n    The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n\n    Args:\n        summarized_output (str): The summary text potentially containing categorized question.\n\n    Returns:\n        dict: A dictionary containing the cleaned summary text and a list of categories.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestParseCategoriesFromSummary(unittest.TestCase):\n    def test_extracts_categories_and_cleans_the_summary_correctly(self):\n        input_data = \"This is a summary. Categories: [Technology, Health]\"\n        expected = {\n            'summary': \"This is a summary.\",\n            'categories': [\"Technology\", \"Health\"]\n        }\n        self.assertEqual(parse_categories_from_summary(input_data), expected)\n\n    def test_returns_empty_categories_and_original_summary_when_no_categories_are_present(self):\n        input_data = \"This is a summary without categories.\"\n        expected = {\n            'summary': \"This is a summary without categories.\",\n            'categories': []\n        }\n        self.assertEqual(parse_categories_from_summary(input_data), expected)\n\n    def test_ignores_case_of_the_category_prefix(self):\n        input_data = \"Summary text. categories: [Education, Science]\"\n        expected = {\n            'summary': \"Summary text.\",\n            'categories': [\"Education\", \"Science\"]\n        }\n        self.assertEqual(parse_categories_from_summary(input_data), expected)\n\n    def test_handles_extra_spaces_and_malformed_category_strings_correctly(self):\n        input_data = \"Details follow. Categories: [ Business ,  , Finance]\"\n        expected = {\n            'summary': \"Details follow.\",\n            'categories': [\"Business\", \"Finance\"]\n        }\n        self.assertEqual(parse_categories_from_summary(input_data), expected)\n\n    def test_removes_the_category_string_correctly_even_if_it_appears_in_the_middle_of_the_summary(self):\n        input_data = \"Beginning of summary. Categories: [Art, Design] Continuation of summary.\"\n        expected = {\n            'summary': \"Beginning of summary. Continuation of summary.\",\n            'categories': [\"Art\", \"Design\"]\n        }\n        self.assertEqual(parse_categories_from_summary(input_data), expected)", "prompt": "please write a python function , the function signature as below def parse_categories_from_summary(summarized_output: str = '') -> dict:\n    \"\"\"\n    Extracts categories from a summarized output string and returns the cleaned summary and categories.\n\n    The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n\n    Args:\n        summarized_output (str): The summary text potentially containing categorized question.\n\n    Returns:\n        dict: A dictionary containing the cleaned summary text and a list of categories.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param {string} summarizedOutput - The summary text potentially containing categorized question.\n * @returns {object} An object containing the cleaned summary text and an array of categories.\n */\nfunction parseCategoriesFromSummary(summarizedOutput = '') {\n\n}", "test_code": "describe('parseCategoriesFromSummary', () => {\n    test('extracts categories and cleans the summary correctly', () => {\n        const input = \"This is a summary. Categories: [Technology, Health]\";\n        const expected = {\n            summary: \"This is a summary.\",\n            categories: [\"Technology\", \"Health\"]\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('returns empty categories and original summary when no categories are present', () => {\n        const input = \"This is a summary without categories.\";\n        const expected = {\n            summary: \"This is a summary without categories.\",\n            categories: []\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('ignores case of the category prefix', () => {\n        const input = \"Summary text. categories: [Education, Science]\";\n        const expected = {\n            summary: \"Summary text.\",\n            categories: [\"Education\", \"Science\"]\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('handles extra spaces and malformed category strings correctly', () => {\n        const input = \"Details follow. Categories: [ Business ,  , Finance]\";\n        const expected = {\n            summary: \"Details follow.\",\n            categories: [\"Business\", \"Finance\"]  // Note the removal of an empty string due to extra commas\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('removes the category string correctly even if it appears in the middle of the summary', () => {\n        const input = \"Beginning of summary. Categories: [Art, Design] Continuation of summary.\";\n        const expected = {\n            summary: \"Beginning of summary. Continuation of summary.\",\n            categories: [\"Art\", \"Design\"]\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param {string} summarizedOutput - The summary text potentially containing categorized question.\n * @returns {object} An object containing the cleaned summary text and an array of categories.\n */\nfunction parseCategoriesFromSummary(summarizedOutput = '') {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param {string} summarizedOutput - The summary text potentially containing categorized question.\n * @returns {object} An object containing the cleaned summary text and an array of categories.\n */\nfunction parseCategoriesFromSummary(summarizedOutput: string = ''): { summary: string; categories: string[] } {}", "test_code": "describe('parseCategoriesFromSummary', () => {\n    test('extracts categories and cleans the summary correctly', () => {\n        const input: string = \"This is a summary. Categories: [Technology, Health]\";\n        const expected = {\n            summary: \"This is a summary.\",\n            categories: [\"Technology\", \"Health\"]\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('returns empty categories and original summary when no categories are present', () => {\n        const input: string = \"This is a summary without categories.\";\n        const expected = {\n            summary: \"This is a summary without categories.\",\n            categories: []\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('ignores case of the category prefix', () => {\n        const input: string = \"Summary text. categories: [Education, Science]\";\n        const expected = {\n            summary: \"Summary text.\",\n            categories: [\"Education\", \"Science\"]\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('handles extra spaces and malformed category strings correctly', () => {\n        const input: string = \"Details follow. Categories: [ Business ,  , Finance]\";\n        const expected = {\n            summary: \"Details follow.\",\n            categories: [\"Business\", \"Finance\"]  // Note the removal of an empty string due to extra commas\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('removes the category string correctly even if it appears in the middle of the summary', () => {\n        const input: string = \"Beginning of summary. Categories: [Art, Design] Continuation of summary.\";\n        const expected = {\n            summary: \"Beginning of summary. Continuation of summary.\",\n            categories: [\"Art\", \"Design\"]\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param {string} summarizedOutput - The summary text potentially containing categorized question.\n * @returns {object} An object containing the cleaned summary text and an array of categories.\n */\nfunction parseCategoriesFromSummary(summarizedOutput: string = ''): { summary: string; categories: string[] } {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param summarizedOutput - The summary text potentially containing categorized question.\n * @returns A SummaryResult struct containing the cleaned summary text and a vector of categories.\n */\nSummaryResult parseCategoriesFromSummary(const std::string& summarizedOutput){}", "test_code": "TEST_CASE(\"parseCategoriesFromSummary\") {\n    SECTION(\"extracts categories and cleans the summary correctly\") {\n        std::string input = \"This is a summary. Categories: [Technology, Health]\";\n        SummaryResult expected = {\"This is a summary.\", {\"Technology\", \"Health\"}};\n        REQUIRE(parseCategoriesFromSummary(input) == expected);\n    }\n\n    SECTION(\"returns empty categories and original summary when no categories are present\") {\n        std::string input = \"This is a summary without categories.\";\n        SummaryResult expected = {\"This is a summary without categories.\", {}};\n        REQUIRE(parseCategoriesFromSummary(input) == expected);\n    }\n\n    SECTION(\"ignores case of the category prefix\") {\n        std::string input = \"Summary text. categories: [Education, Science]\";\n        SummaryResult expected = {\"Summary text.\", {\"Education\", \"Science\"}};\n        REQUIRE(parseCategoriesFromSummary(input) == expected);\n    }\n\n    SECTION(\"handles extra spaces and malformed category strings correctly\") {\n        std::string input = \"Details follow. Categories: [ Business ,  , Finance]\";\n        SummaryResult expected = {\"Details follow.\", {\"Business\", \"Finance\"}};\n        REQUIRE(parseCategoriesFromSummary(input) == expected);\n    }\n\n    SECTION(\"removes the category string correctly even if it appears in the middle of the summary\") {\n        std::string input = \"Beginning of summary. Categories: [Art, Design] Continuation of summary.\";\n        SummaryResult expected = {\"Beginning of summary. Continuation of summary.\", {\"Art\", \"Design\"}};\n        REQUIRE(parseCategoriesFromSummary(input) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param summarizedOutput - The summary text potentially containing categorized question.\n * @returns A SummaryResult struct containing the cleaned summary text and a vector of categories.\n */\nSummaryResult parseCategoriesFromSummary(const std::string& summarizedOutput){}", "addition_info": "struct SummaryResult {\n    std::string summary;\n    std::vector<std::string> categories;\n};"}, "java": {"code_signature": "/**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param summarizedOutput The summary text potentially containing categorized question.\n * @return A Result object containing the cleaned summary text and a list of categories.\n */\npublic static class Result {\n    public final String summary;\n    public final List<String> categories;\n\n    public Result(String summary, List<String> categories) {\n        this.summary = summary;\n        this.categories = categories;\n    }\n}\npublic static Result parseCategoriesFromSummary(String summarizedOutput) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testExtractsCategoriesAndCleansTheSummaryCorrectly() {\n        String input = \"This is a summary. Categories: [Technology, Health]\";\n        Result expected = new Result(\"This is a summary.\", Arrays.asList(\"Technology\", \"Health\"));\n        assertEquals(expected.summary, parseCategoriesFromSummary(input).summary);\n        assertEquals(expected.categories, parseCategoriesFromSummary(input).categories);\n    }\n\n    @Test\n    public void testReturnsEmptyCategoriesAndOriginalSummaryWhenNoCategoriesArePresent() {\n        String input = \"This is a summary without categories.\";\n        Result expected = new Result(\"This is a summary without categories.\", Arrays.asList());\n        assertEquals(expected.summary, parseCategoriesFromSummary(input).summary);\n        assertEquals(expected.categories, parseCategoriesFromSummary(input).categories);\n    }\n\n    @Test\n    public void testIgnoresCaseOfTheCategoryPrefix() {\n        String input = \"Summary text. categories: [Education, Science]\";\n        Result expected = new Result(\"Summary text.\", Arrays.asList(\"Education\", \"Science\"));\n        assertEquals(expected.summary, parseCategoriesFromSummary(input).summary);\n        assertEquals(expected.categories, parseCategoriesFromSummary(input).categories);\n    }\n\n    @Test\n    public void testHandlesExtraSpacesAndMalformedCategoryStringsCorrectly() {\n        String input = \"Details follow. Categories: [ Business ,  , Finance]\";\n        Result expected = new Result(\"Details follow.\", Arrays.asList(\"Business\", \"Finance\"));\n        assertEquals(expected.summary, parseCategoriesFromSummary(input).summary);\n        assertEquals(expected.categories, parseCategoriesFromSummary(input).categories);\n    }\n\n    @Test\n    public void testRemovesTheCategoryStringCorrectlyEvenIfItAppearsInTheMiddleOfTheSummary() {\n        String input = \"Beginning of summary. Categories: [Art, Design] Continuation of summary.\";\n        Result expected = new Result(\"Beginning of summary. Continuation of summary.\", Arrays.asList(\"Art\", \"Design\"));\n        assertEquals(expected.summary, parseCategoriesFromSummary(input).summary);\n        assertEquals(expected.categories, parseCategoriesFromSummary(input).categories);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param summarizedOutput The summary text potentially containing categorized question.\n * @return A Result object containing the cleaned summary text and a list of categories.\n */\npublic static class Result {\n    public final String summary;\n    public final List<String> categories;\n\n    public Result(String summary, List<String> categories) {\n        this.summary = summary;\n        this.categories = categories;\n    }\n}\npublic static Result parseCategoriesFromSummary(String summarizedOutput) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 292, "code_type": "method", "original_language": "javascript", "question_type": "Algorithm and data structure", "summary": "Calculate the monthly payment on the loan", "language_version_list": {"python": {"code_signature": "def calculate_remaining_payment(principal: float, interest_rate: float, number_of_payments: int) -> float:\n    \"\"\"\n    Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n\n    Args:\n        principal (float): The initial amount of the debt.\n        interest_rate (float): The monthly interest rate as a decimal.\n        number_of_payments (int): The total number of payments.\n\n    Returns:\n        float: The calculated remaining payment.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestCalculateRemainingPayment(unittest.TestCase):\n\n    def test_typical_loan_conditions(self):\n        self.assertAlmostEqual(calculate_remaining_payment(10000, 0.005, 24), 0, places=2)\n\n    def test_high_interest_rate(self):\n        self.assertAlmostEqual(calculate_remaining_payment(10000, 0.1, 12), 0, places=2)\n\n    def test_low_interest_rate(self):\n        self.assertAlmostEqual(calculate_remaining_payment(10000, 0.001, 60), 0, places=2)\n\n    def test_very_short_term(self):\n        self.assertAlmostEqual(calculate_remaining_payment(10000, 0.005, 1), 0, places=2)\n\n    def test_no_payments(self):\n        self.assertAlmostEqual(calculate_remaining_payment(10000, 0.005, 0), 10000, places=2)\n\n    def test_long_term(self):\n        self.assertAlmostEqual(calculate_remaining_payment(10000, 0.005, 360), 0, places=2)\n", "prompt": "please write a python function , the function signature as below def calculate_remaining_payment(principal: float, interest_rate: float, number_of_payments: int) -> float:\n    \"\"\"\n    Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n\n    Args:\n        principal (float): The initial amount of the debt.\n        interest_rate (float): The monthly interest rate as a decimal.\n        number_of_payments (int): The total number of payments.\n\n    Returns:\n        float: The calculated remaining payment.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param {number} principal - The initial amount of the debt.\n * @param {number} interestRate - The monthly interest rate as a decimal.\n * @param {number} numberOfPayments - The total number of payments.\n * @returns {number} - The calculated remaining payment.\n */\nfunction calculateRemainingPayment(principal, interestRate, numberOfPayments) {\n}", "test_code": "describe('calculateRemainingPayment', () => {\n  test('calculates remaining balance for typical loan conditions', () => {\n    expect(calculateRemainingPayment(10000, 0.005, 24)).toBeCloseTo(0);\n  });\n\n  test('calculates remaining balance for high interest rate', () => {\n    expect(calculateRemainingPayment(10000, 0.1, 12)).toBeCloseTo(0);\n  });\n\n  test('calculates remaining balance for low interest rate', () => {\n    expect(calculateRemainingPayment(10000, 0.001, 60)).toBeCloseTo(0);\n  });\n\n  test('calculates remaining balance for very short term', () => {\n    expect(calculateRemainingPayment(10000, 0.005, 1)).toBeCloseTo(0);\n  });\n\n\n  test('calculates remaining balance with no payments', () => {\n    expect(calculateRemainingPayment(10000, 0.005, 0)).toBeCloseTo(10000);\n  });\n\n  test('calculates remaining balance for a long term', () => {\n    expect(calculateRemainingPayment(10000, 0.005, 360)).toBeCloseTo(0);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param {number} principal - The initial amount of the debt.\n * @param {number} interestRate - The monthly interest rate as a decimal.\n * @param {number} numberOfPayments - The total number of payments.\n * @returns {number} - The calculated remaining payment.\n */\nfunction calculateRemainingPayment(principal, interestRate, numberOfPayments) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param {number} principal - The initial amount of the debt.\n * @param {number} interestRate - The monthly interest rate as a decimal.\n * @param {number} numberOfPayments - The total number of payments.\n * @returns {number} - The calculated remaining payment.\n */\nfunction calculateRemainingPayment(\n    principal: number,\n    interestRate: number,\n    numberOfPayments: number\n): number {}", "test_code": "describe('calculateRemainingPayment', () => {\n    test('calculates remaining balance for typical loan conditions', () => {\n      expect(calculateRemainingPayment(10000, 0.005, 24)).toBeCloseTo(0);\n    });\n  \n    test('calculates remaining balance for high interest rate', () => {\n      expect(calculateRemainingPayment(10000, 0.1, 12)).toBeCloseTo(0);\n    });\n  \n    test('calculates remaining balance for low interest rate', () => {\n      expect(calculateRemainingPayment(10000, 0.001, 60)).toBeCloseTo(0);\n    });\n  \n    test('calculates remaining balance for very short term', () => {\n      expect(calculateRemainingPayment(10000, 0.005, 1)).toBeCloseTo(0);\n    });\n  \n    test('calculates remaining balance with no payments', () => {\n      expect(calculateRemainingPayment(10000, 0.005, 0)).toBeCloseTo(10000);\n    });\n  \n    test('calculates remaining balance for a long term', () => {\n      expect(calculateRemainingPayment(10000, 0.005, 360)).toBeCloseTo(0);\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param {number} principal - The initial amount of the debt.\n * @param {number} interestRate - The monthly interest rate as a decimal.\n * @param {number} numberOfPayments - The total number of payments.\n * @returns {number} - The calculated remaining payment.\n */\nfunction calculateRemainingPayment(\n    principal: number,\n    interestRate: number,\n    numberOfPayments: number\n): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param principal - The initial amount of the debt.\n * @param interestRate - The monthly interest rate as a decimal.\n * @param numberOfPayments - The total number of payments.\n * @returns - The calculated remaining payment.\n */\ndouble calculateRemainingPayment(double principal, double interestRate, int numberOfPayments) {}", "test_code": "TEST_CASE(\"calculateRemainingPayment\") {\n    SECTION(\"calculates remaining balance for typical loan conditions\") {\n        REQUIRE(calculateRemainingPayment(10000, 0.005, 24) == Catch::Approx(0).margin(0.01));\n    }\n\n    SECTION(\"calculates remaining balance for high interest rate\") {\n        REQUIRE(calculateRemainingPayment(10000, 0.1, 12) == Catch::Approx(0).margin(0.01));\n    }\n\n    SECTION(\"calculates remaining balance for low interest rate\") {\n        REQUIRE(calculateRemainingPayment(10000, 0.001, 60) == Catch::Approx(0).margin(0.01));\n    }\n\n    SECTION(\"calculates remaining balance for very short term\") {\n        REQUIRE(calculateRemainingPayment(10000, 0.005, 1) == Catch::Approx(0).margin(0.01));\n    }\n\n    SECTION(\"calculates remaining balance with no payments\") {\n        REQUIRE(calculateRemainingPayment(10000, 0.005, 0) == Catch::Approx(10000).margin(0.01));\n    }\n\n    SECTION(\"calculates remaining balance for a long term\") {\n        REQUIRE(calculateRemainingPayment(10000, 0.005, 360) == Catch::Approx(0).margin(0.01));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param principal - The initial amount of the debt.\n * @param interestRate - The monthly interest rate as a decimal.\n * @param numberOfPayments - The total number of payments.\n * @returns - The calculated remaining payment.\n */\ndouble calculateRemainingPayment(double principal, double interestRate, int numberOfPayments) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param principal - The initial amount of the debt.\n * @param interestRate - The monthly interest rate as a decimal.\n * @param numberOfPayments - The total number of payments.\n * @return - The calculated remaining payment.\n */\npublic static double calculateRemainingPayment(double principal, double interestRate, int numberOfPayments) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testCalculateRemainingPaymentTypicalLoan() {\n        assertEquals(0, calculateRemainingPayment(10000, 0.005, 24), 0.01);\n    }\n\n    @Test\n    public void testCalculateRemainingPaymentHighInterest() {\n        assertEquals(0, calculateRemainingPayment(10000, 0.1, 12), 0.01);\n    }\n\n    @Test\n    public void testCalculateRemainingPaymentLowInterest() {\n        assertEquals(0, calculateRemainingPayment(10000, 0.001, 60), 0.01);\n    }\n\n    @Test\n    public void testCalculateRemainingPaymentVeryShortTerm() {\n        assertEquals(0, calculateRemainingPayment(10000, 0.005, 1), 0.01);\n    }\n\n    @Test\n    public void testCalculateRemainingPaymentNoPayments() {\n        assertEquals(10000, calculateRemainingPayment(10000, 0.005, 0), 0.01);\n    }\n\n    @Test\n    public void testCalculateRemainingPaymentLongTerm() {\n        assertEquals(0, calculateRemainingPayment(10000, 0.005, 360), 0.01);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param principal - The initial amount of the debt.\n * @param interestRate - The monthly interest rate as a decimal.\n * @param numberOfPayments - The total number of payments.\n * @return - The calculated remaining payment.\n */\npublic static double calculateRemainingPayment(double principal, double interestRate, int numberOfPayments) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 293, "code_type": "method", "original_language": "javascript", "question_type": "Algorithm and data structure", "summary": "Sort image names and ids based on their scores. Specifically, it accepts three arrays as input: an array of image cores, an array of image names, and an array of image ids. The function then combines these arrays, sorts the image data in ascending order based on imageScores, and returns the sorted array of scores, names, and ids.", "language_version_list": {"python": {"code_signature": "from typing import List, Union\n\n\ndef reorder_data(image_scores: List[float], image_names: List[str], image_ids: List[Union[str,float]]) -> dict:\n    \"\"\"\n    Reorders image questions based on scores in ascending order.\n\n    Args:\n        image_scores (list[float]): An array of numerical scores for the images.\n        image_names (list[str]): An array of image names corresponding to the scores.\n        image_ids (list[str | float]): An array of image IDs corresponding to the scores.\n\n    Returns:\n        dict: A dictionary containing the sorted scores, names, and IDs.\n            - resultScores (list[float]): A list of sorted numerical scores.\n            - resultNames (list[str]): A list of sorted image names.\n            - resultIDs (list[str | float]): A list of sorted image IDs.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestReorderData(unittest.TestCase):\n    \n    def test_sorts_question_correctly_for_basic_inputs(self):\n        scores = [3, 1, 2]\n        names = ['Image3', 'Image1', 'Image2']\n        ids = [103, 101, 102]\n        expected = {\n            'resultScores': [1, 2, 3],\n            'resultNames': ['Image1', 'Image2', 'Image3'],\n            'resultIDs': [101, 102, 103]\n        }\n        self.assertEqual(reorder_data(scores, names, ids), expected)\n\n    def test_sorts_question_correctly_with_mixed_scores(self):\n        scores = [5, 1, 3, 5, 2]\n        names = ['Image5', 'Image1', 'Image3', 'Image6', 'Image2']\n        ids = [105, 101, 103, 106, 102]\n        expected = {\n            'resultScores': [1, 2, 3, 5, 5],\n            'resultNames': ['Image1', 'Image2', 'Image3', 'Image5', 'Image6'],\n            'resultIDs': [101, 102, 103, 105, 106]\n        }\n        self.assertEqual(reorder_data(scores, names, ids), expected)\n\n    def test_handles_duplicate_scores(self):\n        scores = [2, 2, 1]\n        names = ['Image2', 'Image3', 'Image1']\n        ids = [102, 103, 101]\n        expected = {\n            'resultScores': [1, 2, 2],\n            'resultNames': ['Image1', 'Image2', 'Image3'],\n            'resultIDs': [101, 102, 103]\n        }\n        self.assertEqual(reorder_data(scores, names, ids), expected)\n\n    def test_handles_empty_arrays(self):\n        scores = []\n        names = []\n        ids = []\n        expected = {\n            'resultScores': [],\n            'resultNames': [],\n            'resultIDs': []\n        }\n        self.assertEqual(reorder_data(scores, names, ids), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List, Union\n\n\ndef reorder_data(image_scores: List[float], image_names: List[str], image_ids: List[Union[str,float]]) -> dict:\n    \"\"\"\n    Reorders image questions based on scores in ascending order.\n\n    Args:\n        image_scores (list[float]): An array of numerical scores for the images.\n        image_names (list[str]): An array of image names corresponding to the scores.\n        image_ids (list[str | float]): An array of image IDs corresponding to the scores.\n\n    Returns:\n        dict: A dictionary containing the sorted scores, names, and IDs.\n            - resultScores (list[float]): A list of sorted numerical scores.\n            - resultNames (list[str]): A list of sorted image names.\n            - resultIDs (list[str | float]): A list of sorted image IDs.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Reorders image question based on scores in ascending order.\n *\n * @param {number[]} imageScores - An array of numerical scores for the images.\n * @param {string[]} imageNames - An array of image names corresponding to the scores.\n * @param {string[]|number[]} imageIDs - An array of image IDs corresponding to the scores.\n * @returns {{resultScores: number[], resultNames: string[], resultIDs: (string[]|number[])}} - An object containing the sorted scores, names, and IDs.\n */\nfunction reorderData(imageScores, imageNames, imageIDs) {}\n", "test_code": "describe('reorderData', () => {\n    test('sorts question correctly for basic inputs', () => {\n        const scores = [3, 1, 2];\n        const names = ['Image3', 'Image1', 'Image2'];\n        const ids = [103, 101, 102];\n        const expected = {\n            resultScores: [1, 2, 3],\n            resultNames: ['Image1', 'Image2', 'Image3'],\n            resultIDs: [101, 102, 103]\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n    test('sorts question correctly with mixed scores', () => {\n        const scores = [5, 1, 3, 5, 2];\n        const names = ['Image5', 'Image1', 'Image3', 'Image6', 'Image2'];\n        const ids = [105, 101, 103, 106, 102];\n        const expected = {\n            resultScores: [1, 2, 3, 5, 5],\n            resultNames: ['Image1', 'Image2', 'Image3', 'Image5', 'Image6'],\n            resultIDs: [101, 102, 103, 105, 106]\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n    test('handles duplicate scores', () => {\n        const scores = [2, 2, 1];\n        const names = ['Image2', 'Image3', 'Image1'];\n        const ids = [102, 103, 101];\n        const expected = {\n            resultScores: [1, 2, 2],\n            resultNames: ['Image1', 'Image2', 'Image3'],\n            resultIDs: [101, 102, 103]\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n    test('handles empty arrays', () => {\n        const scores = [];\n        const names = [];\n        const ids = [];\n        const expected = {\n            resultScores: [],\n            resultNames: [],\n            resultIDs: []\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Reorders image question based on scores in ascending order.\n *\n * @param {number[]} imageScores - An array of numerical scores for the images.\n * @param {string[]} imageNames - An array of image names corresponding to the scores.\n * @param {string[]|number[]} imageIDs - An array of image IDs corresponding to the scores.\n * @returns {{resultScores: number[], resultNames: string[], resultIDs: (string[]|number[])}} - An object containing the sorted scores, names, and IDs.\n */\nfunction reorderData(imageScores, imageNames, imageIDs) {}\n", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Reorders image question based on scores in ascending order.\n *\n * @param {number[]} imageScores - An array of numerical scores for the images.\n * @param {string[]} imageNames - An array of image names corresponding to the scores.\n * @param {string[]|number[]} imageIDs - An array of image IDs corresponding to the scores.\n * @returns {{resultScores: number[], resultNames: string[], resultIDs: (string[]|number[])}} - An object containing the sorted scores, names, and IDs.\n */\nfunction reorderData(\n    imageScores: number[], \n    imageNames: string[], \n    imageIDs: (string[] | number[])\n): { resultScores: number[], resultNames: string[], resultIDs: (string[] | number[]) } {}", "test_code": "describe('reorderData', () => {\n    test('sorts question correctly for basic inputs', () => {\n        const scores: number[] = [3, 1, 2];\n        const names: string[] = ['Image3', 'Image1', 'Image2'];\n        const ids: (string | number)[] = [103, 101, 102];\n        const expected = {\n            resultScores: [1, 2, 3],\n            resultNames: ['Image1', 'Image2', 'Image3'],\n            resultIDs: [101, 102, 103]\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n    test('sorts question correctly with mixed scores', () => {\n        const scores: number[] = [5, 1, 3, 5, 2];\n        const names: string[] = ['Image5', 'Image1', 'Image3', 'Image6', 'Image2'];\n        const ids: (string | number)[] = [105, 101, 103, 106, 102];\n        const expected = {\n            resultScores: [1, 2, 3, 5, 5],\n            resultNames: ['Image1', 'Image2', 'Image3', 'Image5', 'Image6'],\n            resultIDs: [101, 102, 103, 105, 106]\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n    test('handles duplicate scores', () => {\n        const scores: number[] = [2, 2, 1];\n        const names: string[] = ['Image2', 'Image3', 'Image1'];\n        const ids: (string | number)[] = [102, 103, 101];\n        const expected = {\n            resultScores: [1, 2, 2],\n            resultNames: ['Image1', 'Image2', 'Image3'],\n            resultIDs: [101, 102, 103]\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n    test('handles empty arrays', () => {\n        const scores: number[] = [];\n        const names: string[] = [];\n        const ids: (string | number)[] = [];\n        const expected = {\n            resultScores: [],\n            resultNames: [],\n            resultIDs: []\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Reorders image question based on scores in ascending order.\n *\n * @param {number[]} imageScores - An array of numerical scores for the images.\n * @param {string[]} imageNames - An array of image names corresponding to the scores.\n * @param {string[]|number[]} imageIDs - An array of image IDs corresponding to the scores.\n * @returns {{resultScores: number[], resultNames: string[], resultIDs: (string[]|number[])}} - An object containing the sorted scores, names, and IDs.\n */\nfunction reorderData(\n    imageScores: number[], \n    imageNames: string[], \n    imageIDs: (string[] | number[])\n): { resultScores: number[], resultNames: string[], resultIDs: (string[] | number[]) } {}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 298, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Converts a numeric value to a format string with a thousand ('k') or million ('m') suffix to represent large values more concisely.", "language_version_list": {"python": {"code_signature": "from typing import Union\n\n\ndef set_eur_value(value: Union[str, int, float]) -> str:\n    \"\"\"\n    Converts a numerical value into a string representation with appropriate\n    suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n    if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n\n    Args:\n        value (Union[str, int, float]): The value to convert.\n\n    Returns:\n        str: The formatted string or an empty string if the input is invalid.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSetEurValue(unittest.TestCase):\n\n    def test_formats_standard_values_correctly(self):\n        self.assertEqual(set_eur_value('250'), '250')\n        self.assertEqual(set_eur_value('2500'), '2.5k')\n\n    def test_handles_boundary_values_accurately(self):\n        self.assertEqual(set_eur_value('999'), '999')\n        self.assertEqual(set_eur_value('1000'), '1.0k')\n        self.assertEqual(set_eur_value('999999'), '999.9k')  # Corrected from '1000.0k' to '999.9k'\n        self.assertEqual(set_eur_value('1000000'), '1.0m')\n\n    def test_returns_correct_format_for_zero_and_negative_inputs(self):\n        self.assertEqual(set_eur_value('0'), '0')\n\n    def test_returns_empty_string_for_invalid_inputs(self):\n        self.assertEqual(set_eur_value('hello'), '')\n        self.assertEqual(set_eur_value(None), '')\n        self.assertEqual(set_eur_value('undefined'), '')  # In JS, 'undefined' is not the same as None in Python\n\n    def test_ensures_precision_for_large_numbers(self):\n        self.assertEqual(set_eur_value('10000000'), '10.0m')\n        self.assertEqual(set_eur_value('987654321'), '987.7m')\n", "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef set_eur_value(value: Union[str, int, float]) -> str:\n    \"\"\"\n    Converts a numerical value into a string representation with appropriate\n    suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n    if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n\n    Args:\n        value (Union[str, int, float]): The value to convert.\n\n    Returns:\n        str: The formatted string or an empty string if the input is invalid.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param {string|number} value - The value to convert.\n * @returns {string} - The formatted string or an empty string if the input is invalid.\n */\nfunction setEurValue(value) {\n}", "test_code": "describe('setEurValue', () => {\n    test('formats standard values correctly', () => {\n        expect(setEurValue('250')).toBe('250');\n        expect(setEurValue('2500')).toBe('2.5k');\n    });\n\n    test('handles boundary values accurately', () => {\n        expect(setEurValue('999')).toBe('999');\n        expect(setEurValue('1000')).toBe('1.0k');\n        expect(setEurValue('999999')).toBe('1000.0k');\n        expect(setEurValue('1000000')).toBe('1.0m');\n    });\n\n    test('returns correct format for zero and negative inputs', () => {\n        expect(setEurValue('0')).toBe('0');\n    });\n\n    test('returns an empty string for invalid inputs', () => {\n        expect(setEurValue('hello')).toBe('');\n        expect(setEurValue(null)).toBe('');\n        expect(setEurValue(undefined)).toBe('');\n    });\n\n    test('ensures precision for large numbers', () => {\n        expect(setEurValue('10000000')).toBe('10.0m');\n        expect(setEurValue('987654321')).toBe('987.7m');\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param {string|number} value - The value to convert.\n * @returns {string} - The formatted string or an empty string if the input is invalid.\n */\nfunction setEurValue(value) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param {string | number} value - The value to convert.\n * @returns {string} - The formatted string or an empty string if the input is invalid.\n */\nfunction setEurValue(value: string | number): string {}", "test_code": "describe('setEurValue', () => {\n    test('formats standard values correctly', () => {\n        expect(setEurValue('250')).toBe('250');\n        expect(setEurValue('2500')).toBe('2.5k');\n    });\n\n    test('handles boundary values accurately', () => {\n        expect(setEurValue('999')).toBe('999');\n        expect(setEurValue('1000')).toBe('1.0k');\n        expect(setEurValue('999999')).toBe('999.9k'); // Corrected from '1000.0k'\n        expect(setEurValue('1000000')).toBe('1.0m');\n    });\n\n    test('returns correct format for zero and negative inputs', () => {\n        expect(setEurValue('0')).toBe('0');\n        expect(setEurValue('-100')).toBe('-100'); // Handling negative inputs if needed\n    });\n\n    test('returns an empty string for invalid inputs', () => {\n        expect(setEurValue('hello')).toBe('');\n        expect(setEurValue(null)).toBe('');\n        expect(setEurValue(undefined)).toBe('');\n    });\n\n    test('ensures precision for large numbers', () => {\n        expect(setEurValue('10000000')).toBe('10.0m');\n        expect(setEurValue('987654321')).toBe('987.7m');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param {string | number} value - The value to convert.\n * @returns {string} - The formatted string or an empty string if the input is invalid.\n */\nfunction setEurValue(value: string | number): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param value - The value to convert (string representation of a number).\n * @returns The formatted string or an empty string if the input is invalid.\n */\nstd::string setEurValue(const std::string& value){}", "test_code": "TEST_CASE(\"setEurValue\") {\n    SECTION(\"formats standard values correctly\") {\n        REQUIRE(setEurValue(\"250\") == \"250\");\n        REQUIRE(setEurValue(\"2500\") == \"2.5k\");\n    }\n\n    SECTION(\"handles boundary values accurately\") {\n        REQUIRE(setEurValue(\"999\") == \"999\");\n        REQUIRE(setEurValue(\"1000\") == \"1.0k\");\n        REQUIRE(setEurValue(\"999999\") == \"999.9k\"); // Note: Fixed to '999.9k'\n        REQUIRE(setEurValue(\"1000000\") == \"1.0m\");\n    }\n\n    SECTION(\"returns correct format for zero and negative inputs\") {\n        REQUIRE(setEurValue(\"0\") == \"0\");\n    }\n\n    SECTION(\"returns an empty string for invalid inputs\") {\n        REQUIRE(setEurValue(\"hello\") == \"\");\n        REQUIRE(setEurValue(\"\") == \"\"); // Handling empty string instead of null/undefined\n    }\n\n    SECTION(\"ensures precision for large numbers\") {\n        REQUIRE(setEurValue(\"10000000\") == \"10.0m\");\n        REQUIRE(setEurValue(\"987654321\") == \"987.7m\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param value - The value to convert (string representation of a number).\n * @returns The formatted string or an empty string if the input is invalid.\n */\nstd::string setEurValue(const std::string& value){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param value - The value to convert. Can be a String or any Object.\n * @return - The formatted string or an empty string if the input is invalid.\n */\npublic static String setEurValue(Object value) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testFormatsStandardValuesCorrectly() {\n        assertEquals(\"250\", setEurValue(\"250\"));\n        assertEquals(\"2.5k\", setEurValue(\"2500\"));\n    }\n\n    @Test\n    public void testHandlesBoundaryValuesAccurately() {\n        assertEquals(\"999\", setEurValue(\"999\"));\n        assertEquals(\"1.0k\", setEurValue(\"1000\"));\n        assertEquals(\"1000.0k\", setEurValue(\"999999\"));\n        assertEquals(\"1.0m\", setEurValue(\"1000000\"));\n    }\n\n    @Test\n    public void testReturnsCorrectFormatForZeroAndNegativeInputs() {\n        assertEquals(\"0\", setEurValue(\"0\"));\n    }\n\n\n    @Test\n    public void testEnsuresPrecisionForLargeNumbers() {\n        assertEquals(\"10.0m\", setEurValue(\"10000000\"));\n        assertEquals(\"987.7m\", setEurValue(\"987654321\"));\n    }\n    \n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param value - The value to convert. Can be a String or any Object.\n * @return - The formatted string or an empty string if the input is invalid.\n */\npublic static String setEurValue(Object value) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 299, "code_type": "method", "original_language": "javascript", "question_type": "Algorithm and data structure", "summary": "Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.", "language_version_list": {"python": {"code_signature": "def calculate_age(birth_date_string: str) -> str:\n    \"\"\"\n    Calculates the age from the given birth date string and returns a string containing\n    the original birth date and the calculated age. If the entered date string is invalid\n    or empty, the function returns an empty string.\n\n    Args:\n        birth_date_string (str): The birth date as a string in a recognizable date format\n                                  (e.g., 'YYYY-MM-DD').\n\n    Returns:\n        str: A string that includes the original birth date and the calculated age in the\n             format 'birth_date_string (age)', or an empty string if the input is invalid.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCalculateAge(unittest.TestCase):\n\n    def test_birthday_today(self):\n        self.assertEqual(calculate_age('2000-08-23'), '2000-08-23 (24)')\n\n    def test_birthday_passed_this_year(self):\n        self.assertEqual(calculate_age('1990-01-15'), '1990-01-15 (34)')\n\n    def test_birthday_at_end_of_year(self):\n        self.assertEqual(calculate_age('1985-12-31'), '1985-12-31 (38)')\n\n    def test_recently_turned_one_year_old(self):\n        self.assertEqual(calculate_age('2023-05-05'), '2023-05-05 (1)')\n\n    def test_invalid_date_input(self):\n        self.assertEqual(calculate_age('invalid-date'), '')\n", "prompt": "please write a python function , the function signature as below def calculate_age(birth_date_string: str) -> str:\n    \"\"\"\n    Calculates the age from the given birth date string and returns a string containing\n    the original birth date and the calculated age. If the entered date string is invalid\n    or empty, the function returns an empty string.\n\n    Args:\n        birth_date_string (str): The birth date as a string in a recognizable date format\n                                  (e.g., 'YYYY-MM-DD').\n\n    Returns:\n        str: A string that includes the original birth date and the calculated age in the\n             format 'birth_date_string (age)', or an empty string if the input is invalid.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.\n *\n * @param {string} birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @returns {string} - A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', or an empty string if the input is invalid.\n */\nfunction calculateAge(birthDateString) {\n}\n", "test_code": "describe('setEurValue', () => {\n    test('Birthday today, should be 24 years old', () => {\n        expect(calculateAge('2000-08-23')).toBe('2000-08-23 (24)')\n    });\n\n    test('Birthday has passed this year, should be 34 years old', () => {\n        expect(calculateAge('1990-01-15')).toBe('1990-01-15 (34)')\n    });\n\n    test('Birthday at the end of the year, should be 38 years old', () => {\n        expect(calculateAge('1985-12-31')).toBe('1985-12-31 (38)')\n    });\n\n    test('Recently turned 1 year old this year', () => {\n        expect(calculateAge('2023-05-05')).toBe('2023-05-05 (1)')\n    });\n\n\n    test('Invalid date input should return an empty string', () => {\n        expect(calculateAge('invalid-date')).toBe('')\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.\n *\n * @param {string} birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @returns {string} - A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', or an empty string if the input is invalid.\n */\nfunction calculateAge(birthDateString) {\n}\n", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.\n *\n * @param {string} birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @returns {string} - A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', or an empty string if the input is invalid.\n */\nfunction calculateAge(birthDateString: string): string {}", "test_code": "describe('calculateAge', () => {\n    test('Birthday today, should be 24 years old', () => {\n        expect(calculateAge('2000-08-23')).toBe('2000-08-23 (24)');\n    });\n\n    test('Birthday has passed this year, should be 34 years old', () => {\n        expect(calculateAge('1990-01-15')).toBe('1990-01-15 (34)');\n    });\n\n    test('Birthday at the end of the year, should be 38 years old', () => {\n        expect(calculateAge('1985-12-31')).toBe('1985-12-31 (38)');\n    });\n\n    test('Recently turned 1 year old this year', () => {\n        expect(calculateAge('2023-05-05')).toBe('2023-05-05 (1)');\n    });\n\n    test('Invalid date input should return an empty string', () => {\n        expect(calculateAge('invalid-date')).toBe('');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.\n *\n * @param {string} birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @returns {string} - A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', or an empty string if the input is invalid.\n */\nfunction calculateAge(birthDateString: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.\n *\n * @param birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @returns A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', or an empty string if the input is invalid.\n */\nstd::string calculateAge(const std::string& birthDateString) {}", "test_code": "TEST_CASE(\"calculateAge\") {\n    SECTION(\"Birthday today, should be 24 years old\") {\n        REQUIRE(calculateAge(\"2000-08-23\") == \"2000-08-23 (24)\");\n    }\n\n    SECTION(\"Birthday has passed this year, should be 34 years old\") {\n        REQUIRE(calculateAge(\"1990-01-15\") == \"1990-01-15 (34)\");\n    }\n\n    SECTION(\"Birthday at the end of the year, should be 38 years old\") {\n        REQUIRE(calculateAge(\"1985-12-31\") == \"1985-12-31 (38)\");\n    }\n\n    SECTION(\"Recently turned 1 year old this year\") {\n        REQUIRE(calculateAge(\"2023-05-05\") == \"2023-05-05 (1)\");\n    }\n\n    SECTION(\"Invalid date input should return an empty string\") {\n        REQUIRE(calculateAge(\"invalid-date\") == \"\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.\n *\n * @param birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @returns A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', or an empty string if the input is invalid.\n */\nstd::string calculateAge(const std::string& birthDateString) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. \n * If the entered date string is invalid or empty, the method returns an empty string.\n *\n * @param birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @return A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', \n *         or an empty string if the input is invalid.\n */\npublic static String calculateAge(String birthDateString) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testBirthdayToday() {\n        assertEquals(\"2000-08-23 (24)\", calculateAge(\"2000-08-23\"));\n    }\n\n    @Test\n    public void testBirthdayHasPassed() {\n        assertEquals(\"1990-01-15 (34)\", calculateAge(\"1990-01-15\"));\n    }\n\n    @Test\n    public void testBirthdayAtEndOfYear() {\n        assertEquals(\"1985-12-31 (38)\", calculateAge(\"1985-12-31\"));\n    }\n\n    @Test\n    public void testRecentlyTurnedOne() {\n        assertEquals(\"2023-05-05 (1)\", calculateAge(\"2023-05-05\"));\n    }\n\n    @Test\n    public void testInvalidDateInput() {\n        assertEquals(\"\", calculateAge(\"invalid-date\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. \n * If the entered date string is invalid or empty, the method returns an empty string.\n *\n * @param birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @return A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', \n *         or an empty string if the input is invalid.\n */\npublic static String calculateAge(String birthDateString) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 300, "code_type": "method", "original_language": "javascript", "question_type": "User interface", "summary": "Iterate over list items on a web page and remove ads that contain a specific class name", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Iterate over list items on a web page and remove ads that contain a specific class name\n */\nfunction removeAds() {\n\n}", "test_code": "describe('removeAds', () => {\n    beforeEach(() => {\n        // Reset the DOM before each test.js\n        document.body.innerHTML = '';\n    });\n\n    test('removes a single sponsored product', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li><span class=\"css-16lshh0\">Sponsored</span></li>\n                <li>Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n        expect(listItems[0].textContent).toBe('Sponsored');\n    });\n\n    test('removes multiple sponsored products', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li><span class=\"css-16lshh0\">Sponsored</span></li>\n                <li>Regular Item</li>\n                <li><span class=\"css-16lshh0\">Sponsored</span></li>\n                <li>Another Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(4);\n        expect(listItems[0].textContent).toBe('Sponsored');\n        expect(listItems[1].textContent).toBe('Regular Item');\n    });\n\n    test('does not remove any items if there are no sponsored products', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li>Regular Item</li>\n                <li>Another Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n        expect(listItems[0].textContent).toBe('Regular Item');\n        expect(listItems[1].textContent).toBe('Another Regular Item');\n    });\n\n    test('removes items with nested sponsored indicators', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li>\n                    <div>\n                        <span class=\"css-16lshh0\">Sponsored</span>\n                    </div>\n                </li>\n                <li>Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n    });\n\n    test('does not remove items with similar but non-sponsored class names', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li><span class=\"css-16lshh1\">Not Sponsored</span></li>\n                <li>Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n        expect(listItems[0].textContent).toBe('Not Sponsored');\n        expect(listItems[1].textContent).toBe('Regular Item');\n    });\n});\n\n", "prompt": "please write a javascript function , the function signature as below /**\n * Iterate over list items on a web page and remove ads that contain a specific class name\n */\nfunction removeAds() {\n\n}", "addition_info": "/**\n * @jest-environment jsdom\n */"}, "typescript": {"code_signature": "/**\n * Iterate over list items on a web page and remove ads that contain a specific class name\n */\nfunction removeAds(): void {}", "test_code": "describe('removeAds', () => {\n    beforeEach(() => {\n        // Reset the DOM before each test.js\n        document.body.innerHTML = '';\n    });\n\n    test('removes a single sponsored product', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li><span class=\"css-16lshh0\">Sponsored</span></li>\n                <li>Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n        expect(listItems[0].textContent).toBe('Sponsored');\n    });\n\n    test('removes multiple sponsored products', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li><span class=\"css-16lshh0\">Sponsored</span></li>\n                <li>Regular Item</li>\n                <li><span class=\"css-16lshh0\">Sponsored</span></li>\n                <li>Another Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(4);\n        expect(listItems[0].textContent).toBe('Sponsored');\n        expect(listItems[1].textContent).toBe('Regular Item');\n    });\n\n    test('does not remove any items if there are no sponsored products', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li>Regular Item</li>\n                <li>Another Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n        expect(listItems[0].textContent).toBe('Regular Item');\n        expect(listItems[1].textContent).toBe('Another Regular Item');\n    });\n\n    test('removes items with nested sponsored indicators', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li>\n                    <div>\n                        <span class=\"css-16lshh0\">Sponsored</span>\n                    </div>\n                </li>\n                <li>Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n    });\n\n    test('does not remove items with similar but non-sponsored class names', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li><span class=\"css-16lshh1\">Not Sponsored</span></li>\n                <li>Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n        expect(listItems[0].textContent).toBe('Not Sponsored');\n        expect(listItems[1].textContent).toBe('Regular Item');\n    });\n});\n\n", "prompt": "please write a typescript function , the function signature as below /**\n * Iterate over list items on a web page and remove ads that contain a specific class name\n */\nfunction removeAds(): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 305, "code_type": "class", "original_language": "javascript", "question_type": "Algorithm and data structure", "summary": "Define a class called SeededRandom for generating pseudorandom numbers with a specific seed", "language_version_list": {"python": {"code_signature": "class SeededRandom:\n    \"\"\"\n    Define a class called SeededRandom for generating pseudorandom numbers with a specific seed.\n    \"\"\"\n\n    def __init__(self, seed):\n        \"\"\"\n        Initializes a new instance of the SeededRandom class with a given seed.\n\n        :param seed: The initial seed value for the random number generator.\n        \"\"\"\n\n    def rand(self):\n        \"\"\"\n        Generates a random number between 0 and 1 using a Linear Congruential Generator (LCG) algorithm.\n\n        :returns: A pseudo-random number between 0 (inclusive) and 1 (exclusive).\n        \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSeededRandom(unittest.TestCase):\n\n    def test_consistent_numbers_with_same_seed(self):\n        \"\"\"Generates consistent numbers with the same seed.\"\"\"\n        seeded_rand1 = SeededRandom(42)\n        seeded_rand2 = SeededRandom(42)\n        self.assertAlmostEqual(seeded_rand1.rand(), seeded_rand2.rand(), places=10)\n        self.assertAlmostEqual(seeded_rand1.rand(), seeded_rand2.rand(), places=10)\n        self.assertAlmostEqual(seeded_rand1.rand(), seeded_rand2.rand(), places=10)\n\n    def test_different_numbers_with_different_seeds(self):\n        \"\"\"Generates different numbers with different seeds.\"\"\"\n        seeded_rand1 = SeededRandom(42)\n        seeded_rand2 = SeededRandom(24)\n        self.assertNotAlmostEqual(seeded_rand1.rand(), seeded_rand2.rand(), places=10)\n\n    def test_returns_numbers_between_0_and_1(self):\n        \"\"\"Returns numbers between 0 and 1.\"\"\"\n        seeded_rand = SeededRandom(123456)\n        for _ in range(1000):\n            rand_value = seeded_rand.rand()\n            self.assertGreaterEqual(rand_value, 0)\n            self.assertLess(rand_value, 1)\n\n    def test_different_sequences_with_different_seeds(self):\n        \"\"\"Produces different sequences with different seeds.\"\"\"\n        seeded_rand1 = SeededRandom(123)\n        seeded_rand2 = SeededRandom(456)\n        sequence1 = [seeded_rand1.rand() for _ in range(5)]\n        sequence2 = [seeded_rand2.rand() for _ in range(5)]\n        self.assertNotEqual(sequence1, sequence2)\n\n    def test_consistent_sequence_with_same_seed(self):\n        \"\"\"Consistent sequence with the same seed over multiple calls.\"\"\"\n        seeded_rand = SeededRandom(987654321)\n        sequence1 = [seeded_rand.rand() for _ in range(3)]\n        seeded_rand2 = SeededRandom(987654321)\n        sequence2 = [seeded_rand2.rand() for _ in range(3)]\n        self.assertEqual(sequence1, sequence2)\n", "prompt": "please write a python class , the class signature as below class SeededRandom:\n    \"\"\"\n    Define a class called SeededRandom for generating pseudorandom numbers with a specific seed.\n    \"\"\"\n\n    def __init__(self, seed):\n        \"\"\"\n        Initializes a new instance of the SeededRandom class with a given seed.\n\n        :param seed: The initial seed value for the random number generator.\n        \"\"\"\n\n    def rand(self):\n        \"\"\"\n        Generates a random number between 0 and 1 using a Linear Congruential Generator (LCG) algorithm.\n\n        :returns: A pseudo-random number between 0 (inclusive) and 1 (exclusive).\n        \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Define a class called SeededRandom for generating pseudorandom numbers with a specific seed\n */\nclass SeededRandom {\n    /**\n     * Initializes a new instance of the SeededRandom class with a given seed.\n     * @param {number} seed - The initial seed value for the random number generator.\n     */\n    constructor(seed) {\n\n    }\n\n    /**\n     * Generates a random number between 0 and 1 using a Linear Congruential Generator (LCG) algorithm.\n     * @returns {number} A pseudo-random number between 0 (inclusive) and 1 (exclusive).\n     */\n    rand() {\n\n    }\n}", "test_code": "describe('SeededRandom', () => {\n    test('generates consistent numbers with the same seed', () => {\n        const seededRand1 = new SeededRandom(42);\n        const seededRand2 = new SeededRandom(42);\n\n        expect(seededRand1.rand()).toBeCloseTo(seededRand2.rand(), 10);\n        expect(seededRand1.rand()).toBeCloseTo(seededRand2.rand(), 10);\n        expect(seededRand1.rand()).toBeCloseTo(seededRand2.rand(), 10);\n    });\n\n    test('generates different numbers with different seeds', () => {\n        const seededRand1 = new SeededRandom(42);\n        const seededRand2 = new SeededRandom(24);\n\n        expect(seededRand1.rand()).not.toBeCloseTo(seededRand2.rand(), 10);\n    });\n\n    test('returns numbers between 0 and 1', () => {\n        const seededRand = new SeededRandom(123456);\n\n        for (let i = 0; i < 1000; i++) {\n            const randValue = seededRand.rand();\n            expect(randValue).toBeGreaterThanOrEqual(0);\n            expect(randValue).toBeLessThan(1);\n        }\n    });\n\n    test('produces different sequences with different seeds', () => {\n        const seededRand1 = new SeededRandom(123);\n        const seededRand2 = new SeededRandom(456);\n\n        const sequence1 = Array.from({ length: 5 }, () => seededRand1.rand());\n        const sequence2 = Array.from({ length: 5 }, () => seededRand2.rand());\n\n        expect(sequence1).not.toEqual(sequence2);\n    });\n\n    test('consistent sequence with the same seed over multiple calls', () => {\n        const seededRand = new SeededRandom(987654321);\n\n        const sequence1 = [seededRand.rand(), seededRand.rand(), seededRand.rand()];\n\n        // Re-initialize with the same seed to test.js consistency\n        const seededRand2 = new SeededRandom(987654321);\n        const sequence2 = [seededRand2.rand(), seededRand2.rand(), seededRand2.rand()];\n\n        expect(sequence1).toEqual(sequence2);\n    });\n});\n", "prompt": "please write a javascript class , the class signature as below /**\n * Define a class called SeededRandom for generating pseudorandom numbers with a specific seed\n */\nclass SeededRandom {\n    /**\n     * Initializes a new instance of the SeededRandom class with a given seed.\n     * @param {number} seed - The initial seed value for the random number generator.\n     */\n    constructor(seed) {\n\n    }\n\n    /**\n     * Generates a random number between 0 and 1 using a Linear Congruential Generator (LCG) algorithm.\n     * @returns {number} A pseudo-random number between 0 (inclusive) and 1 (exclusive).\n     */\n    rand() {\n\n    }\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Define a class called SeededRandom for generating pseudorandom numbers with a specific seed\n */\nclass SeededRandom {\n    /**\n     * Initializes a new instance of the SeededRandom class with a given seed.\n     * @param seed - The initial seed value for the random number generator.\n     */\n    constructor(seed: number) {\n\n    }\n\n    /**\n     * Generates a random number between 0 and 1 using a Linear Congruential Generator (LCG) algorithm.\n     * @returns A pseudo-random number between 0 (inclusive) and 1 (exclusive).\n     */\n    rand(): number {\n\n    }\n}", "test_code": "describe('SeededRandom', () => {\n    test('generates consistent numbers with the same seed', () => {\n        const seededRand1 = new SeededRandom(42);\n        const seededRand2 = new SeededRandom(42);\n\n        expect(seededRand1.rand()).toBeCloseTo(seededRand2.rand(), 10);\n        expect(seededRand1.rand()).toBeCloseTo(seededRand2.rand(), 10);\n        expect(seededRand1.rand()).toBeCloseTo(seededRand2.rand(), 10);\n    });\n\n    test('generates different numbers with different seeds', () => {\n        const seededRand1 = new SeededRandom(42);\n        const seededRand2 = new SeededRandom(24);\n\n        expect(seededRand1.rand()).not.toBeCloseTo(seededRand2.rand(), 10);\n    });\n\n    test('returns numbers between 0 and 1', () => {\n        const seededRand = new SeededRandom(123456);\n\n        for (let i = 0; i < 1000; i++) {\n            const randValue = seededRand.rand();\n            expect(randValue).toBeGreaterThanOrEqual(0);\n            expect(randValue).toBeLessThan(1);\n        }\n    });\n\n    test('produces different sequences with different seeds', () => {\n        const seededRand1 = new SeededRandom(123);\n        const seededRand2 = new SeededRandom(456);\n\n        const sequence1 = Array.from({ length: 5 }, () => seededRand1.rand());\n        const sequence2 = Array.from({ length: 5 }, () => seededRand2.rand());\n\n        expect(sequence1).not.toEqual(sequence2);\n    });\n\n    test('consistent sequence with the same seed over multiple calls', () => {\n        const seededRand = new SeededRandom(987654321);\n\n        const sequence1 = [seededRand.rand(), seededRand.rand(), seededRand.rand()];\n\n        // Re-initialize with the same seed to test consistency\n        const seededRand2 = new SeededRandom(987654321);\n        const sequence2 = [seededRand2.rand(), seededRand2.rand(), seededRand2.rand()];\n\n        expect(sequence1).toEqual(sequence2);\n    });\n});", "prompt": "please write a typescript class , the class signature as below /**\n * Define a class called SeededRandom for generating pseudorandom numbers with a specific seed\n */\nclass SeededRandom {\n    /**\n     * Initializes a new instance of the SeededRandom class with a given seed.\n     * @param seed - The initial seed value for the random number generator.\n     */\n    constructor(seed: number) {\n\n    }\n\n    /**\n     * Generates a random number between 0 and 1 using a Linear Congruential Generator (LCG) algorithm.\n     * @returns A pseudo-random number between 0 (inclusive) and 1 (exclusive).\n     */\n    rand(): number {\n\n    }\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 306, "code_type": "method", "original_language": "javascript", "question_type": "Algorithm and data structure", "summary": "The recipe ID is hashed to produce a price in the specified range", "language_version_list": {"python": {"code_signature": "def get_price(recipe_id: str, min_val: float = 10, max_val: float = 30) -> float:\n    \"\"\"\n    The recipe ID is hashed to produce a price in the specified range.\n    Args:\n        recipe_id (str): The ID of the recipe to hash.\n        min_val (float): The minimum value of the price range (default is 10).\n        max_val (float): The maximum value of the price range (default is 30).\n\n    Returns:\n        float: The hashed price, mapped to the specified range with two decimal places.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGetPrice(unittest.TestCase):\n\n    def test_default_range(self):\n        price = get_price('recipe123')\n        self.assertGreaterEqual(price, 10)\n        self.assertLessEqual(price, 30)\n\n    def test_same_price_for_same_id(self):\n        price1 = get_price('recipe123')\n        price2 = get_price('recipe123')\n        self.assertEqual(price1, price2)\n\n    def test_different_prices_for_different_ids(self):\n        price1 = get_price('recipe123')\n        price2 = get_price('recipe456')\n        self.assertNotEqual(price1, price2)\n\n    def test_custom_range(self):\n        min_val = 20\n        max_val = 50\n        price = get_price('recipe789', min_val, max_val)\n        self.assertGreaterEqual(price, min_val)\n        self.assertLessEqual(price, max_val)\n\n    def test_long_recipe_id(self):\n        long_recipe_id = 'recipe' + 'A' * 1000\n        price = get_price(long_recipe_id)\n        self.assertGreaterEqual(price, 10)\n        self.assertLessEqual(price, 30)\n", "prompt": "please write a python function , the function signature as below def get_price(recipe_id: str, min_val: float = 10, max_val: float = 30) -> float:\n    \"\"\"\n    The recipe ID is hashed to produce a price in the specified range.\n    Args:\n        recipe_id (str): The ID of the recipe to hash.\n        min_val (float): The minimum value of the price range (default is 10).\n        max_val (float): The maximum value of the price range (default is 30).\n\n    Returns:\n        float: The hashed price, mapped to the specified range with two decimal places.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * The recipe ID is hashed to produce a price in the specified range\n *\n * @param {string} recipeId - The ID of the recipe to hash.\n * @param {number} [minVal=10] - The minimum value of the price range.\n * @param {number} [maxVal=30] - The maximum value of the price range.\n * @returns {number} - The hashed price, mapped to the specified range with two decimal places.\n */\nfunction getPrice(recipeId, minVal = 10, maxVal = 30) {\n\n}", "test_code": "describe('getPrice', () => {\n    test('should return a number within the default range for a given recipe ID', () => {\n        const price = getPrice('recipe123');\n        expect(price).toBeGreaterThanOrEqual(10);\n        expect(price).toBeLessThanOrEqual(30);\n    });\n\n    test('should return the same price for the same recipe ID', () => {\n        const price1 = getPrice('recipe123');\n        const price2 = getPrice('recipe123');\n        expect(price1).toBe(price2);\n    });\n\n    test('should return different prices for different recipe IDs', () => {\n        const price1 = getPrice('recipe123');\n        const price2 = getPrice('recipe456');\n        expect(price1).not.toBe(price2);\n    });\n\n    test('should return a price within a custom range', () => {\n        const minVal = 20;\n        const maxVal = 50;\n        const price = getPrice('recipe789', minVal, maxVal);\n        expect(price).toBeGreaterThanOrEqual(minVal);\n        expect(price).toBeLessThanOrEqual(maxVal);\n    });\n\n    test('should handle very long recipe IDs without error', () => {\n        const longRecipeId = 'recipe' + 'A'.repeat(1000);\n        const price = getPrice(longRecipeId);\n        expect(price).toBeGreaterThanOrEqual(10);\n        expect(price).toBeLessThanOrEqual(30);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * The recipe ID is hashed to produce a price in the specified range\n *\n * @param {string} recipeId - The ID of the recipe to hash.\n * @param {number} [minVal=10] - The minimum value of the price range.\n * @param {number} [maxVal=30] - The maximum value of the price range.\n * @returns {number} - The hashed price, mapped to the specified range with two decimal places.\n */\nfunction getPrice(recipeId, minVal = 10, maxVal = 30) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * The recipe ID is hashed to produce a price in the specified range\n *\n * @param {string} recipeId - The ID of the recipe to hash.\n * @param {number} [minVal=10] - The minimum value of the price range.\n * @param {number} [maxVal=30] - The maximum value of the price range.\n * @returns {number} - The hashed price, mapped to the specified range with two decimal places.\n */\nfunction getPrice(recipeId: string, minVal: number = 10, maxVal: number = 30): number {}", "test_code": "describe('getPrice', () => {\n    test('should return a number within the default range for a given recipe ID', () => {\n        const price: number = getPrice('recipe123');\n        expect(price).toBeGreaterThanOrEqual(10);\n        expect(price).toBeLessThanOrEqual(30);\n    });\n\n    test('should return the same price for the same recipe ID', () => {\n        const price1: number = getPrice('recipe123');\n        const price2: number = getPrice('recipe123');\n        expect(price1).toBe(price2);\n    });\n\n    test('should return different prices for different recipe IDs', () => {\n        const price1: number = getPrice('recipe123');\n        const price2: number = getPrice('recipe456');\n        expect(price1).not.toBe(price2);\n    });\n\n    test('should return a price within a custom range', () => {\n        const minVal: number = 20;\n        const maxVal: number = 50;\n        const price: number = getPrice('recipe789', minVal, maxVal);\n        expect(price).toBeGreaterThanOrEqual(minVal);\n        expect(price).toBeLessThanOrEqual(maxVal);\n    });\n\n    test('should handle very long recipe IDs without error', () => {\n        const longRecipeId: string = 'recipe' + 'A'.repeat(1000);\n        const price: number = getPrice(longRecipeId);\n        expect(price).toBeGreaterThanOrEqual(10);\n        expect(price).toBeLessThanOrEqual(30);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * The recipe ID is hashed to produce a price in the specified range\n *\n * @param {string} recipeId - The ID of the recipe to hash.\n * @param {number} [minVal=10] - The minimum value of the price range.\n * @param {number} [maxVal=30] - The maximum value of the price range.\n * @returns {number} - The hashed price, mapped to the specified range with two decimal places.\n */\nfunction getPrice(recipeId: string, minVal: number = 10, maxVal: number = 30): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 308, "code_type": "method", "original_language": "javascript", "question_type": "Program input code", "summary": "Gets the current date and returns it as YYYY-MM-DD", "language_version_list": {"python": {"code_signature": "def get_current_date() -> str:\n    \"\"\"Gets the current date and returns it as YYYY-MM-DD.\n\n    Returns:\n        str: The current date formatted as YYYY-MM-DD.\n    \"\"\"", "test_code": "import unittest\nfrom datetime import datetime\n\n\nclass TestGetCurrentDate(unittest.TestCase):\n\n    def test_should_return_a_string_in_the_format_YYYY_MM_DD(self):\n        \"\"\"Test that the return value is a string in the format YYYY-MM-DD.\"\"\"\n        date = get_current_date()\n        self.assertIsInstance(date, str)\n        self.assertRegex(date, r'^\\d{4}-\\d{2}-\\d{2}$')\n\n    def test_should_return_the_correct_date_for_today(self):\n        \"\"\"Test that the returned date is today's date in YYYY-MM-DD format.\"\"\"\n        expected_date = datetime.now().strftime('%Y-%m-%d')\n        actual_date = get_current_date()\n        self.assertEqual(actual_date, expected_date)\n\n    def test_should_return_the_correct_year_part_in_YYYY_MM_DD(self):\n        \"\"\"Test that the returned date has the correct year part (YYYY).\"\"\"\n        current_year = datetime.now().year\n        actual_date = get_current_date()\n        self.assertTrue(actual_date.startswith(str(current_year)))\n\n    def test_should_return_the_correct_month_part_in_YYYY_MM_DD(self):\n        \"\"\"Test that the returned date has the correct month part (MM).\"\"\"\n        current_month = datetime.now().strftime('%m')  # Zero-padded month\n        actual_date = get_current_date()\n        self.assertEqual(actual_date[5:7], current_month)\n\n    def test_should_return_the_correct_day_part_in_YYYY_MM_DD(self):\n        \"\"\"Test that the returned date has the correct day part (DD).\"\"\"\n        current_day = datetime.now().strftime('%d')  # Zero-padded day\n        actual_date = get_current_date()\n        self.assertEqual(actual_date[8:10], current_day)\n", "prompt": "please write a python function , the function signature as below def get_current_date() -> str:\n    \"\"\"Gets the current date and returns it as YYYY-MM-DD.\n\n    Returns:\n        str: The current date formatted as YYYY-MM-DD.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Gets the current date and returns it as YYYY-MM-DD\n *\n * @returns {string} The current date formatted as YYYY-MM-DD.\n */\nfunction getCurrentDate() {\n\n}", "test_code": "describe('getCurrentDate', () => {\n    test('should return a string in the format YYYY-MM-DD', () => {\n        const date = getCurrentDate();\n        expect(typeof date).toBe('string');\n        expect(date).toMatch(/^\\d{4}-\\d{2}-\\d{2}$/);\n    });\n\n    test('should return the correct date for today', () => {\n        const expectedDate = new Date().toISOString().split('T')[0];\n        const actualDate = getCurrentDate();\n        expect(actualDate).toBe(expectedDate);\n    });\n\n    test('should return the correct year part in YYYY-MM-DD', () => {\n        const currentYear = new Date().getFullYear().toString();\n        const actualDate = getCurrentDate();\n        expect(actualDate.startsWith(currentYear)).toBe(true);\n    });\n\n    test('should return the correct month part in YYYY-MM-DD', () => {\n        const currentMonth = (`0${new Date().getMonth() + 1}`).slice(-2); // Add leading zero if needed\n        const actualDate = getCurrentDate();\n        expect(actualDate.slice(5, 7)).toBe(currentMonth);\n    });\n\n    test('should return the correct day part in YYYY-MM-DD', () => {\n        const currentDay = (`0${new Date().getDate()}`).slice(-2); // Add leading zero if needed\n        const actualDate = getCurrentDate();\n        expect(actualDate.slice(8, 10)).toBe(currentDay);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Gets the current date and returns it as YYYY-MM-DD\n *\n * @returns {string} The current date formatted as YYYY-MM-DD.\n */\nfunction getCurrentDate() {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Gets the current date and returns it as YYYY-MM-DD\n *\n * @returns {string} The current date formatted as YYYY-MM-DD.\n */\nfunction getCurrentDate(): string {}", "test_code": "describe('getCurrentDate', () => {\n    test('should return a string in the format YYYY-MM-DD', () => {\n        const date: string = getCurrentDate();\n        expect(typeof date).toBe('string');\n        expect(date).toMatch(/^\\d{4}-\\d{2}-\\d{2}$/);\n    });\n\n    test('should return the correct date for today', () => {\n        const expectedDate: string = new Date().toISOString().split('T')[0];\n        const actualDate: string = getCurrentDate();\n        expect(actualDate).toBe(expectedDate);\n    });\n\n    test('should return the correct year part in YYYY-MM-DD', () => {\n        const currentYear: string = new Date().getFullYear().toString();\n        const actualDate: string = getCurrentDate();\n        expect(actualDate.startsWith(currentYear)).toBe(true);\n    });\n\n    test('should return the correct month part in YYYY-MM-DD', () => {\n        const currentMonth: string = (`0${new Date().getMonth() + 1}`).slice(-2); // Add leading zero if needed\n        const actualDate: string = getCurrentDate();\n        expect(actualDate.slice(5, 7)).toBe(currentMonth);\n    });\n\n    test('should return the correct day part in YYYY-MM-DD', () => {\n        const currentDay: string = (`0${new Date().getDate()}`).slice(-2); // Add leading zero if needed\n        const actualDate: string = getCurrentDate();\n        expect(actualDate.slice(8, 10)).toBe(currentDay);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Gets the current date and returns it as YYYY-MM-DD\n *\n * @returns {string} The current date formatted as YYYY-MM-DD.\n */\nfunction getCurrentDate(): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Gets the current date and returns it as YYYY-MM-DD\n *\n * @returns The current date formatted as YYYY-MM-DD.\n */\nstd::string getCurrentDate() {}", "test_code": "TEST_CASE(\"getCurrentDate\", \"[date]\") {\n    SECTION(\"should return a string in the format YYYY-MM-DD\") {\n        std::string date = getCurrentDate();\n        REQUIRE(!date.empty());\n        REQUIRE(std::regex_match(date, std::regex(\"^\\\\d{4}-\\\\d{2}-\\\\d{2}$\")));\n    }\n\n    SECTION(\"should return the correct date for today\") {\n        std::string expectedDate = getCurrentDate(); // Get the current date using the function\n        std::time_t now = std::time(0);\n        std::tm* tm_now = std::localtime(&now);\n        std::ostringstream oss;\n        oss << std::put_time(tm_now, \"%Y-%m-%d\");\n        std::string actualDate = oss.str();\n        REQUIRE(actualDate == expectedDate);\n    }\n\n    SECTION(\"should return the correct year part in YYYY-MM-DD\") {\n        std::time_t now = std::time(0);\n        std::tm* tm_now = std::localtime(&now);\n        std::string currentYear = std::to_string(tm_now->tm_year + 1900);\n        std::string actualDate = getCurrentDate();\n        REQUIRE(actualDate.starts_with(currentYear));\n    }\n\n    SECTION(\"should return the correct month part in YYYY-MM-DD\") {\n        std::time_t now = std::time(0);\n        std::tm* tm_now = std::localtime(&now);\n        std::string currentMonth = std::to_string(tm_now->tm_mon + 1);\n        if (currentMonth.length() < 2) {\n            currentMonth = \"0\" + currentMonth; // Add leading zero if needed\n        }\n        std::string actualDate = getCurrentDate();\n        REQUIRE(actualDate.substr(5, 2) == currentMonth);\n    }\n\n    SECTION(\"should return the correct day part in YYYY-MM-DD\") {\n        std::time_t now = std::time(0);\n        std::tm* tm_now = std::localtime(&now);\n        std::string currentDay = std::to_string(tm_now->tm_mday);\n        if (currentDay.length() < 2) {\n            currentDay = \"0\" + currentDay; // Add leading zero if needed\n        }\n        std::string actualDate = getCurrentDate();\n        REQUIRE(actualDate.substr(8, 2) == currentDay);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Gets the current date and returns it as YYYY-MM-DD\n *\n * @returns The current date formatted as YYYY-MM-DD.\n */\nstd::string getCurrentDate() {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 313, "code_type": "method", "original_language": "javascript", "question_type": NaN, "summary": "Detecting the light or dark state of the background element of a major element of a web page and returning the corresponding description string", "language_version_list": {"python": {"code_signature": "def is_background_too_dark_or_bright(computed_style):\n    \"\"\"Detecting the light or dark state of the background element and returning the corresponding description string.\n\n    Args:\n        computed_style (str): The computed background color in 'rgb(r, g, b)' format.\n\n    Returns:\n        str: \"dark\" if the background is too dark, \"bright\" if it is too bright, or \"normal\" if it is neither.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestBackgroundBrightness(unittest.TestCase):\n    def test_dark_background(self):\n        \"\"\"Test for a dark background color.\"\"\"\n        background_color = 'rgb(30, 30, 30)'\n        result = is_background_too_dark_or_bright(background_color)\n        self.assertEqual(result, 'dark')\n\n    def test_bright_background(self):\n        \"\"\"Test for a bright background color.\"\"\"\n        background_color = 'rgb(250, 250, 250)'\n        result = is_background_too_dark_or_bright(background_color)\n        self.assertEqual(result, 'bright')\n\n    def test_normal_background(self):\n        \"\"\"Test for a background color with normal brightness.\"\"\"\n        background_color = 'rgb(150, 150, 150)'\n        result = is_background_too_dark_or_bright(background_color)\n        self.assertEqual(result, 'normal')\n\n    def test_high_red_component(self):\n        \"\"\"Test for a bright color with a high red component.\"\"\"\n        background_color = 'rgb(255, 100, 100)'\n        result = is_background_too_dark_or_bright(background_color)\n        self.assertEqual(result, 'normal')\n\n    def test_low_green_and_blue(self):\n        \"\"\"Test for a dark color with low green and blue components.\"\"\"\n        background_color = 'rgb(10, 10, 100)'\n        result = is_background_too_dark_or_bright(background_color)\n        self.assertEqual(result, 'dark')\n", "prompt": "please write a python function , the function signature as below def is_background_too_dark_or_bright(computed_style):\n    \"\"\"Detecting the light or dark state of the background element and returning the corresponding description string.\n\n    Args:\n        computed_style (str): The computed background color in 'rgb(r, g, b)' format.\n\n    Returns:\n        str: \"dark\" if the background is too dark, \"bright\" if it is too bright, or \"normal\" if it is neither.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Detecting the light or dark state of the background element of a major element of a web page and returning the corresponding description string\n *\n * @returns {string} - Returns \"dark\" if the background is too dark, \"bright\" if it is too bright, or \"normal\" if it is neither.\n */\nfunction isBackgroundTooDarkOrBright() {\n\n}", "test_code": "/**\n * @jest-environment jsdom\n */\n\ndescribe('isBackgroundTooDarkOrBright', () => {\n    let mainElement;\n\n    beforeEach(() => {\n        // Create a 'main' element and append it to the document body\n        mainElement = document.createElement('main');\n        document.body.appendChild(mainElement);\n    });\n\n    afterEach(() => {\n        // Clean up by removing the 'main' element after each test.js\n        document.body.removeChild(mainElement);\n    });\n\n    test('should return \"dark\" for a dark background color', () => {\n        // Set a dark background color\n        mainElement.style.backgroundColor = 'rgb(30, 30, 30)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('dark');\n    });\n\n    test('should return \"bright\" for a bright background color', () => {\n        // Set a bright background color\n        mainElement.style.backgroundColor = 'rgb(250, 250, 250)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('bright');\n    });\n\n    test('should return \"normal\" for a background color with normal brightness', () => {\n        // Set a background color with normal brightness\n        mainElement.style.backgroundColor = 'rgb(150, 150, 150)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('normal');\n    });\n\n    test('should correctly handle a bright color with high red component', () => {\n        // Set a bright color with a high red component\n        mainElement.style.backgroundColor = 'rgb(255, 100, 100)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('normal');\n    });\n\n    test('should correctly handle a dark color with low green and blue components', () => {\n        // Set a dark color with low green and blue components\n        mainElement.style.backgroundColor = 'rgb(10, 10, 100)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('dark');\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Detecting the light or dark state of the background element of a major element of a web page and returning the corresponding description string\n *\n * @returns {string} - Returns \"dark\" if the background is too dark, \"bright\" if it is too bright, or \"normal\" if it is neither.\n */\nfunction isBackgroundTooDarkOrBright() {\n\n}", "addition_info": "/**\n * @jest-environment jsdom\n */"}, "typescript": {"code_signature": "/**\n * Detecting the light or dark state of the background element of a major element of a web page and returning the corresponding description string.\n *\n * @returns {string} - Returns \"dark\" if the background is too dark, \"bright\" if it is too bright, or \"normal\" if it is neither.\n */\nfunction isBackgroundTooDarkOrBright(): string {}", "test_code": "describe('isBackgroundTooDarkOrBright', () => {\n    let mainElement: HTMLElement;\n\n    beforeEach(() => {\n        // Create a 'main' element and append it to the document body\n        mainElement = document.createElement('main');\n        document.body.appendChild(mainElement);\n    });\n\n    afterEach(() => {\n        // Clean up by removing the 'main' element after each test\n        document.body.removeChild(mainElement);\n    });\n\n    test('should return \"dark\" for a dark background color', () => {\n        // Set a dark background color\n        mainElement.style.backgroundColor = 'rgb(30, 30, 30)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('dark');\n    });\n\n    test('should return \"bright\" for a bright background color', () => {\n        // Set a bright background color\n        mainElement.style.backgroundColor = 'rgb(250, 250, 250)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('bright');\n    });\n\n    test('should return \"normal\" for a background color with normal brightness', () => {\n        // Set a background color with normal brightness\n        mainElement.style.backgroundColor = 'rgb(150, 150, 150)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('normal');\n    });\n\n    test('should correctly handle a bright color with high red component', () => {\n        // Set a bright color with a high red component\n        mainElement.style.backgroundColor = 'rgb(255, 100, 100)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('normal');\n    });\n\n    test('should correctly handle a dark color with low green and blue components', () => {\n        // Set a dark color with low green and blue components\n        mainElement.style.backgroundColor = 'rgb(10, 10, 100)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('dark');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Detecting the light or dark state of the background element of a major element of a web page and returning the corresponding description string.\n *\n * @returns {string} - Returns \"dark\" if the background is too dark, \"bright\" if it is too bright, or \"normal\" if it is neither.\n */\nfunction isBackgroundTooDarkOrBright(): string {}", "addition_info": "/**\n * @jest-environment jsdom\n */"}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 315, "code_type": "method", "original_language": "javascript", "question_type": "User interface", "summary": "extract the file name from the given URL\n", "language_version_list": {"python": {"code_signature": "def get_file_id_from_url(url: str) -> str:\n    \"\"\"Extract the file ID from the given URL query args.\n\n    If not found, return None.\n\n    Args:\n        url (str): The URL from which the file ID is to be extracted.\n\n    Returns:\n        str: The extracted file ID if present, otherwise None if the URL does not conform to the expected format.\n\n    Example:\n        Input: \"https://example.com/download?fileId=12345\"\n        Output: \"12345\"\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGetFileIdFromUrl(unittest.TestCase):\n    def test_valid_url_with_fileId(self):\n        url = 'https://example.com/download?fileId=12345'\n        self.assertEqual(get_file_id_from_url(url), '12345')\n\n    def test_missing_fileId_parameter(self):\n        url = 'https://example.com/download'\n        self.assertIsNone(get_file_id_from_url(url))\n\n    def test_empty_fileId_parameter(self):\n        url = 'https://example.com/download?fileId='\n        self.assertIsNone(get_file_id_from_url(url))\n\n    def test_malformed_url(self):\n        url = 'https://example.com/download?fileId=12345&otherParam'\n        self.assertEqual(get_file_id_from_url(url), '12345')  # Adjust based on the actual implementation\n", "prompt": "please write a python function , the function signature as below def get_file_id_from_url(url: str) -> str:\n    \"\"\"Extract the file ID from the given URL query args.\n\n    If not found, return None.\n\n    Args:\n        url (str): The URL from which the file ID is to be extracted.\n\n    Returns:\n        str: The extracted file ID if present, otherwise None if the URL does not conform to the expected format.\n\n    Example:\n        Input: \"https://example.com/download?fileId=12345\"\n        Output: \"12345\"\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extract the fileid from the given URL query args.If not find return null\n * For example:\n *      input: https://example.com/download?fileId=12345\n *      output: 12345\n *\n * @param {string} url - The URL from which the file ID is to be extracted.\n * @returns {string|null} - The extracted file ID if present, otherwise null if the URL does not conform to the expected format.\n */\nfunction getFileIdFromUrl(url) {\n}", "test_code": "describe('getFileIdFromUrl', () => {\n    test('should return the file ID when a valid URL with fileId is provided', () => {\n        const url = 'https://example.com/download?fileId=12345';\n        expect(getFileIdFromUrl(url)).toBe('12345');\n    });\n\n    test('should return null when the fileId query parameter is missing', () => {\n        const url = 'https://example.com/download';\n        expect(getFileIdFromUrl(url)).toBeNull();\n    });\n\n    test('should return null when the fileId query parameter is empty', () => {\n        const url = 'https://example.com/download?fileId=';\n        expect(getFileIdFromUrl(url)).toBeNull();\n    });\n\n\n\n    test('should return null for a malformed URL', () => {\n        const url = 'https://example.com/download?fileId=12345&otherParam';\n        expect(getFileIdFromUrl(url)).toBe('12345'); // Adjust this depending on your needs; the function should still work correctly.\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Extract the fileid from the given URL query args.If not find return null\n * For example:\n *      input: https://example.com/download?fileId=12345\n *      output: 12345\n *\n * @param {string} url - The URL from which the file ID is to be extracted.\n * @returns {string|null} - The extracted file ID if present, otherwise null if the URL does not conform to the expected format.\n */\nfunction getFileIdFromUrl(url) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Extract the file ID from the given URL query args. If not found, return null.\n * For example:\n *      input: https://example.com/download?fileId=12345\n *      output: 12345\n *\n * @param {string} url - The URL from which the file ID is to be extracted.\n * @returns {string | null} - The extracted file ID if present, otherwise null if the URL does not conform to the expected format.\n */\nfunction getFileIdFromUrl(url: string): string | null {}", "test_code": "describe('getFileIdFromUrl', () => {\n    test('should return the file ID when a valid URL with fileId is provided', () => {\n        const url: string = 'https://example.com/download?fileId=12345';\n        expect(getFileIdFromUrl(url)).toBe('12345');\n    });\n\n    test('should return null when the fileId query parameter is missing', () => {\n        const url: string = 'https://example.com/download';\n        expect(getFileIdFromUrl(url)).toBeNull();\n    });\n\n    test('should return null when the fileId query parameter is empty', () => {\n        const url: string = 'https://example.com/download?fileId=';\n        expect(getFileIdFromUrl(url)).toBeNull();\n    });\n\n    test('should return null for a malformed URL', () => {\n        const url: string = 'https://example.com/download?fileId=12345&otherParam';\n        expect(getFileIdFromUrl(url)).toBe('12345'); // Adjust this depending on your needs; the function should still work correctly.\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Extract the file ID from the given URL query args. If not found, return null.\n * For example:\n *      input: https://example.com/download?fileId=12345\n *      output: 12345\n *\n * @param {string} url - The URL from which the file ID is to be extracted.\n * @returns {string | null} - The extracted file ID if present, otherwise null if the URL does not conform to the expected format.\n */\nfunction getFileIdFromUrl(url: string): string | null {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Extract the fileId from the given URL query args. If not found, return an empty string.\n * For example:\n *      input: https://example.com/download?fileId=12345\n *      output: 12345\n *\n * @param std::string url - The URL from which the file ID is to be extracted.\n * @returns std::string - The extracted file ID if present, otherwise an empty string if the URL does not conform to the expected format.\n */\nstd::string getFileIdFromUrl(const std::string& url){}", "test_code": "TEST_CASE(\"getFileIdFromUrl\", \"[getFileIdFromUrl]\") {\n    SECTION(\"should return the file ID when a valid URL with fileId is provided\") {\n        std::string url = \"https://example.com/download?fileId=12345\";\n        REQUIRE(getFileIdFromUrl(url) == \"12345\");\n    }\n\n    SECTION(\"should return empty string when the fileId query parameter is missing\") {\n        std::string url = \"https://example.com/download\";\n        REQUIRE(getFileIdFromUrl(url) == \"\");\n    }\n\n    SECTION(\"should return empty string when the fileId query parameter is empty\") {\n        std::string url = \"https://example.com/download?fileId=\";\n        REQUIRE(getFileIdFromUrl(url) == \"\");\n    }\n\n    SECTION(\"should return the file ID for a malformed URL\") {\n        std::string url = \"https://example.com/download?fileId=12345&otherParam\";\n        REQUIRE(getFileIdFromUrl(url) == \"12345\"); // Adjust this depending on your needs; the function should still work correctly.\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Extract the fileId from the given URL query args. If not found, return an empty string.\n * For example:\n *      input: https://example.com/download?fileId=12345\n *      output: 12345\n *\n * @param std::string url - The URL from which the file ID is to be extracted.\n * @returns std::string - The extracted file ID if present, otherwise an empty string if the URL does not conform to the expected format.\n */\nstd::string getFileIdFromUrl(const std::string& url){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Extract the file ID from the given URL query args. If not found, return null.\n * For example:\n *      input: https://example.com/download?fileId=12345\n *      output: 12345\n *\n * @param url - The URL from which the file ID is to be extracted.\n * @return - The extracted file ID if present, otherwise null if the URL does not conform to the expected format.\n */\npublic static String getFileIdFromUrl(String url) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testValidUrlWithFileId() {\n        String url = \"https://example.com/download?fileId=12345\";\n        assertEquals(\"12345\", getFileIdFromUrl(url));\n    }\n\n    @Test\n    public void testMissingFileIdParameter() {\n        String url = \"https://example.com/download\";\n        assertEquals(null, getFileIdFromUrl(url));\n    }\n\n    @Test\n    public void testEmptyFileIdParameter() {\n        String url = \"https://example.com/download?fileId=\";\n        assertEquals(null, getFileIdFromUrl(url));\n    }\n\n    @Test\n    public void testMalformedUrl() {\n        String url = \"https://example.com/download?fileId=12345&otherParam\";\n        assertEquals(\"12345\", getFileIdFromUrl(url)); // Adjust as necessary\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extract the file ID from the given URL query args. If not found, return null.\n * For example:\n *      input: https://example.com/download?fileId=12345\n *      output: 12345\n *\n * @param url - The URL from which the file ID is to be extracted.\n * @return - The extracted file ID if present, otherwise null if the URL does not conform to the expected format.\n */\npublic static String getFileIdFromUrl(String url) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 317, "code_type": "method", "original_language": "javascript", "question_type": "Program input code", "summary": "count the number of letters in a string\n", "language_version_list": {"python": {"code_signature": "def count_letters(s: str) -> int:\n    \"\"\"Count the number of letters in a string.\n\n    Args:\n        s (str): The input string from which to count letters.\n\n    Returns:\n        int: The count of letters in the string.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCountLetters(unittest.TestCase):\n\n    def test_hello_world(self):\n        self.assertEqual(count_letters(\"Hello, World!\"), 10)\n\n    def test_no_letters(self):\n        self.assertEqual(count_letters(\"12345\"), 0)\n\n    def test_abc_123_xyz(self):\n        self.assertEqual(count_letters(\"abc 123 xyz!\"), 6)\n\n    def test_empty_string(self):\n        self.assertEqual(count_letters(\"\"), 0)\n\n    def test_A1B2C3(self):\n        self.assertEqual(count_letters(\"A1B2C3!@#\"), 3)\n\n    def test_mixed_case(self):\n        self.assertEqual(count_letters(\"AbCdE\"), 5)", "prompt": "please write a python function , the function signature as below def count_letters(s: str) -> int:\n    \"\"\"Count the number of letters in a string.\n\n    Args:\n        s (str): The input string from which to count letters.\n\n    Returns:\n        int: The count of letters in the string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Count the number of letters in a string.\n *\n * @param {string} str - The input string from which to count letters.\n * @returns {number} - The count of letters in the string.\n */\nfunction countLetters(str) {}", "test_code": "describe('countLetters', () => {\n    test('should return 10 for the string \"Hello, World!\"', () => {\n        expect(countLetters(\"Hello, World!\")).toBe(10);\n    });\n\n    test('should return 0 for a string with no letters \"12345\"', () => {\n        expect(countLetters(\"12345\")).toBe(0);\n    });\n\n    test('should return 6 for the string \"abc 123 xyz!\"', () => {\n        expect(countLetters(\"abc 123 xyz!\")).toBe(6);\n    });\n\n    test('should return 0 for an empty string', () => {\n        expect(countLetters(\"\")).toBe(0);\n    });\n\n    test('should return 3 for the string \"A1B2C3!@#\"', () => {\n        expect(countLetters(\"A1B2C3!@#\")).toBe(3);\n    });\n\n    test('should return 5 for a string with mixed case \"AbCdE\"', () => {\n        expect(countLetters(\"AbCdE\")).toBe(5);\n    });\n\n    test('should return 8 for a string with special characters \"Hello@2024!\"', () => {\n        expect(countLetters(\"Hello@2024!\")).toBe(5);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Count the number of letters in a string.\n *\n * @param {string} str - The input string from which to count letters.\n * @returns {number} - The count of letters in the string.\n */\nfunction countLetters(str) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Count the number of letters in a string.\n *\n * @param {string} str - The input string from which to count letters.\n * @returns {number} - The count of letters in the string.\n */\nfunction countLetters(str: string): number {}", "test_code": "describe('countLetters', () => {\n    test('should return 10 for the string \"Hello, World!\"', () => {\n        expect(countLetters(\"Hello, World!\")).toBe(10);\n    });\n\n    test('should return 0 for a string with no letters \"12345\"', () => {\n        expect(countLetters(\"12345\")).toBe(0);\n    });\n\n    test('should return 6 for the string \"abc 123 xyz!\"', () => {\n        expect(countLetters(\"abc 123 xyz!\")).toBe(6);\n    });\n\n    test('should return 0 for an empty string', () => {\n        expect(countLetters(\"\")).toBe(0);\n    });\n\n    test('should return 3 for the string \"A1B2C3!@#\"', () => {\n        expect(countLetters(\"A1B2C3!@#\")).toBe(3);\n    });\n\n    test('should return 5 for a string with mixed case \"AbCdE\"', () => {\n        expect(countLetters(\"AbCdE\")).toBe(5);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Count the number of letters in a string.\n *\n * @param {string} str - The input string from which to count letters.\n * @returns {number} - The count of letters in the string.\n */\nfunction countLetters(str: string): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Count the number of letters in a string.\n *\n * @param str - The input string from which to count letters.\n * @returns The count of letters in the string.\n */\nint countLetters(const std::string& str){}", "test_code": "TEST_CASE(\"countLetters\", \"[countLetters]\") {\n    SECTION(\"should return 10 for the string 'Hello, World!'\") {\n        REQUIRE(countLetters(\"Hello, World!\") == 10);\n    }\n\n    SECTION(\"should return 0 for a string with no letters '12345'\") {\n        REQUIRE(countLetters(\"12345\") == 0);\n    }\n\n    SECTION(\"should return 6 for the string 'abc 123 xyz!'\") {\n        REQUIRE(countLetters(\"abc 123 xyz!\") == 6);\n    }\n\n    SECTION(\"should return 0 for an empty string\") {\n        REQUIRE(countLetters(\"\") == 0);\n    }\n\n    SECTION(\"should return 3 for the string 'A1B2C3!@#'\") {\n        REQUIRE(countLetters(\"A1B2C3!@#\") == 3);\n    }\n\n    SECTION(\"should return 5 for a string with mixed case 'AbCdE'\") {\n        REQUIRE(countLetters(\"AbCdE\") == 5);\n    }\n\n    SECTION(\"should return 5 for a string with special characters 'Hello@2024!'\") {\n        REQUIRE(countLetters(\"Hello@2024!\") == 5);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Count the number of letters in a string.\n *\n * @param str - The input string from which to count letters.\n * @returns The count of letters in the string.\n */\nint countLetters(const std::string& str){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Count the number of letters in a string.\n *\n * @param str - The input string from which to count letters.\n * @return - The count of letters in the string.\n */\npublic static int countLetters(String str) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testCountLetters_HelloWorld() {\n        assertEquals(10, countLetters(\"Hello, World!\"));\n    }\n\n    @Test\n    public void testCountLetters_NoLetters() {\n        assertEquals(0, countLetters(\"12345\"));\n    }\n\n    @Test\n    public void testCountLetters_ABC123XYZ() {\n        assertEquals(6, countLetters(\"abc 123 xyz!\"));\n    }\n\n    @Test\n    public void testCountLetters_EmptyString() {\n        assertEquals(0, countLetters(\"\"));\n    }\n\n    @Test\n    public void testCountLetters_MixedCharacters() {\n        assertEquals(3, countLetters(\"A1B2C3!@#\"));\n    }\n\n    @Test\n    public void testCountLetters_MixedCase() {\n        assertEquals(5, countLetters(\"AbCdE\"));\n    }\n\n    @Test\n    public void testCountLetters_SpecialCharacters() {\n        assertEquals(5, countLetters(\"Hello@2024!\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Count the number of letters in a string.\n *\n * @param str - The input string from which to count letters.\n * @return - The count of letters in the string.\n */\npublic static int countLetters(String str) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 318, "code_type": "method", "original_language": "javascript", "question_type": "Program input code", "summary": "count the number of numbers in a string\n", "language_version_list": {"python": {"code_signature": "def count_numbers(s: str) -> int:\n    \"\"\"Count the number of numeric digits in a string.\n\n    Args:\n        s (str): The string from which to count numeric digits.\n\n    Returns:\n        int: The total count of numeric digits found in the string.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCountNumbers(unittest.TestCase):\n\n    def test_multiple_numbers(self):\n        result = count_numbers('There are 123 numbers in this string.')\n        self.assertEqual(result, 3)  # '123' contains three numeric characters\n\n    def test_no_numbers(self):\n        result = count_numbers('No numbers here!')\n        self.assertEqual(result, 0)  # No numeric characters in 'No numbers here!'\n\n    def test_mixed_characters(self):\n        result = count_numbers('Room 101 and Room 102')\n        self.assertEqual(result, 6)  # '101' and '102' together contain six numeric characters\n\n    def test_only_numbers(self):\n        result = count_numbers('1234567890')\n        self.assertEqual(result, 10)  # '1234567890' contains ten numeric characters\n\n    def test_empty_string(self):\n        result = count_numbers('')\n        self.assertEqual(result, 0)  # An empty string contains no numeric characters\n", "prompt": "please write a python function , the function signature as below def count_numbers(s: str) -> int:\n    \"\"\"Count the number of numeric digits in a string.\n\n    Args:\n        s (str): The string from which to count numeric digits.\n\n    Returns:\n        int: The total count of numeric digits found in the string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * count the number of numbers in a string\n *\n * @param {string} str - The string from which to count numeric digits.\n * @returns {number} - The total count of numeric digits found in the string.\n */\nfunction countNumbers(str) {\n}", "test_code": "// Jest test cases for countNumbers function\ndescribe('countNumbers', () => {\n    test('should return the correct count for a string with multiple numbers', () => {\n        const result = countNumbers('There are 123 numbers in this string.');\n        expect(result).toBe(3); // '123' contains three numeric characters\n    });\n\n    test('should return 0 for a string with no numbers', () => {\n        const result = countNumbers('No numbers here!');\n        expect(result).toBe(0); // No numeric characters in 'No numbers here!'\n    });\n\n    test('should return the correct count for a string with mixed characters', () => {\n        const result = countNumbers('Room 101 and Room 102');\n        expect(result).toBe(6); // '101' and '102' together contain six numeric characters\n    });\n\n    test('should return the correct count for a string with only numbers', () => {\n        const result = countNumbers('1234567890');\n        expect(result).toBe(10); // '1234567890' contains ten numeric characters\n    });\n\n    test('should return 0 for an empty string', () => {\n        const result = countNumbers('');\n        expect(result).toBe(0); // An empty string contains no numeric characters\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * count the number of numbers in a string\n *\n * @param {string} str - The string from which to count numeric digits.\n * @returns {number} - The total count of numeric digits found in the string.\n */\nfunction countNumbers(str) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * count the number of numbers in a string\n *\n * @param {string} str - The string from which to count numeric digits.\n * @returns {number} - The total count of numeric digits found in the string.\n */\nfunction countNumbers(str: string): number {}", "test_code": "describe('countNumbers', () => {\n    test('should return the correct count for a string with multiple numbers', () => {\n        const result: number = countNumbers('There are 123 numbers in this string.');\n        expect(result).toBe(3); // '123' contains three numeric characters\n    });\n\n    test('should return 0 for a string with no numbers', () => {\n        const result: number = countNumbers('No numbers here!');\n        expect(result).toBe(0); // No numeric characters in 'No numbers here!'\n    });\n\n    test('should return the correct count for a string with mixed characters', () => {\n        const result: number = countNumbers('Room 101 and Room 102');\n        expect(result).toBe(6); // '101' and '102' together contain six numeric characters\n    });\n\n    test('should return the correct count for a string with only numbers', () => {\n        const result: number = countNumbers('1234567890');\n        expect(result).toBe(10); // '1234567890' contains ten numeric characters\n    });\n\n    test('should return 0 for an empty string', () => {\n        const result: number = countNumbers('');\n        expect(result).toBe(0); // An empty string contains no numeric characters\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * count the number of numbers in a string\n *\n * @param {string} str - The string from which to count numeric digits.\n * @returns {number} - The total count of numeric digits found in the string.\n */\nfunction countNumbers(str: string): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Count the number of numbers in a string.\n *\n * @param str - The string from which to count numeric digits.\n * @returns The total count of numeric digits found in the string.\n */\nint countNumbers(const std::string& str) {}", "test_code": "TEST_CASE(\"countNumbers\") {\n    SECTION(\"should return the correct count for a string with multiple numbers\") {\n        REQUIRE(countNumbers(\"There are 123 numbers in this string.\") == 3); // '123' contains three numeric characters\n    }\n\n    SECTION(\"should return 0 for a string with no numbers\") {\n        REQUIRE(countNumbers(\"No numbers here!\") == 0); // No numeric characters in 'No numbers here!'\n    }\n\n    SECTION(\"should return the correct count for a string with mixed characters\") {\n        REQUIRE(countNumbers(\"Room 101 and Room 102\") == 6); // '101' and '102' together contain six numeric characters\n    }\n\n    SECTION(\"should return the correct count for a string with only numbers\") {\n        REQUIRE(countNumbers(\"1234567890\") == 10); // '1234567890' contains ten numeric characters\n    }\n\n    SECTION(\"should return 0 for an empty string\") {\n        REQUIRE(countNumbers(\"\") == 0); // An empty string contains no numeric characters\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Count the number of numbers in a string.\n *\n * @param str - The string from which to count numeric digits.\n * @returns The total count of numeric digits found in the string.\n */\nint countNumbers(const std::string& str) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Count the number of numeric digits in a string.\n *\n * @param str The string from which to count numeric digits.\n * @returns The total count of numeric digits found in the string.\n */\npublic static int countNumbers(String str) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testCountNumbers_MultipleNumbers() {\n        int result = countNumbers(\"There are 123 numbers in this string.\");\n        assertEquals(3, result); // '123' contains three numeric characters\n    }\n\n    @Test\n    public void testCountNumbers_NoNumbers() {\n        int result = countNumbers(\"No numbers here!\");\n        assertEquals(0, result); // No numeric characters in 'No numbers here!'\n    }\n\n    @Test\n    public void testCountNumbers_MixedCharacters() {\n        int result = countNumbers(\"Room 101 and Room 102\");\n        assertEquals(6, result); // '101' and '102' together contain six numeric characters\n    }\n\n    @Test\n    public void testCountNumbers_OnlyNumbers() {\n        int result = countNumbers(\"1234567890\");\n        assertEquals(10, result); // '1234567890' contains ten numeric characters\n    }\n\n    @Test\n    public void testCountNumbers_EmptyString() {\n        int result = countNumbers(\"\");\n        assertEquals(0, result); // An empty string contains no numeric characters\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Count the number of numeric digits in a string.\n *\n * @param str The string from which to count numeric digits.\n * @returns The total count of numeric digits found in the string.\n */\npublic static int countNumbers(String str) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 319, "code_type": "method", "original_language": "javascript", "question_type": "Program input code", "summary": "count the number of dashes in a string\n", "language_version_list": {"python": {"code_signature": "def count_dashes(s: str) -> int:\n    \"\"\"Count the number of dashes in a string.\n\n    Args:\n        s (str): The string from which to count dash characters.\n\n    Returns:\n        int: The total count of dash characters found in the string.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCountDashes(unittest.TestCase):\n\n    def test_no_dashes(self):\n        \"\"\"Should return 0 for a string with no dashes.\"\"\"\n        result = count_dashes('hello world')\n        self.assertEqual(result, 0)  # 'hello world' contains no dashes\n\n    def test_one_dash(self):\n        \"\"\"Should return 1 for a string with one dash.\"\"\"\n        result = count_dashes('hello-world')\n        self.assertEqual(result, 1)  # 'hello-world' contains one dash\n\n    def test_multiple_dashes(self):\n        \"\"\"Should return 4 for a string with multiple dashes.\"\"\"\n        result = count_dashes('a-b-c-d-e')\n        self.assertEqual(result, 4)  # 'a-b-c-d-e' contains four dashes\n\n    def test_dashes_at_ends(self):\n        \"\"\"Should return 3 for a string with dashes at the beginning and end.\"\"\"\n        result = count_dashes('-start-end-')\n        self.assertEqual(result, 3)  # '-start-end-' contains three dashes\n\n    def test_empty_string(self):\n        \"\"\"Should return 0 for an empty string.\"\"\"\n        result = count_dashes('')\n        self.assertEqual(result, 0)  # An empty string contains no dashes\n", "prompt": "please write a python function , the function signature as below def count_dashes(s: str) -> int:\n    \"\"\"Count the number of dashes in a string.\n\n    Args:\n        s (str): The string from which to count dash characters.\n\n    Returns:\n        int: The total count of dash characters found in the string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * count the number of dashes in a string\n *\n * @param {string} str - The string from which to count dash characters.\n * @returns {number} - The total count of dash characters found in the string.\n */\nfunction countDashes(str) {\n}", "test_code": "describe('countDashes', () => {\n    test('should return 0 for a string with no dashes', () => {\n        const result = countDashes('hello world');\n        expect(result).toBe(0); // 'hello world' contains no dashes\n    });\n\n    test('should return 1 for a string with one dash', () => {\n        const result = countDashes('hello-world');\n        expect(result).toBe(1); // 'hello-world' contains one dash\n    });\n\n    test('should return 4 for a string with multiple dashes', () => {\n        const result = countDashes('a-b-c-d-e');\n        expect(result).toBe(4); // 'a-b-c-d-e' contains four dashes\n    });\n\n    test('should return 2 for a string with dashes at the beginning and end', () => {\n        const result = countDashes('-start-end-');\n        expect(result).toBe(3); // '-start-end-' contains two dashes\n    });\n\n    test('should return 0 for an empty string', () => {\n        const result = countDashes('');\n        expect(result).toBe(0); // An empty string contains no dashes\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * count the number of dashes in a string\n *\n * @param {string} str - The string from which to count dash characters.\n * @returns {number} - The total count of dash characters found in the string.\n */\nfunction countDashes(str) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * count the number of dashes in a string\n *\n * @param {string} str - The string from which to count dash characters.\n * @returns {number} - The total count of dash characters found in the string.\n */\nfunction countDashes(str: string): number {\n}", "test_code": "describe('countDashes', () => {\n    test('should return 0 for a string with no dashes', () => {\n        const result: number = countDashes('hello world');\n        expect(result).toBe(0); // 'hello world' contains no dashes\n    });\n\n    test('should return 1 for a string with one dash', () => {\n        const result: number = countDashes('hello-world');\n        expect(result).toBe(1); // 'hello-world' contains one dash\n    });\n\n    test('should return 4 for a string with multiple dashes', () => {\n        const result: number = countDashes('a-b-c-d-e');\n        expect(result).toBe(4); // 'a-b-c-d-e' contains four dashes\n    });\n\n    test('should return 3 for a string with dashes at the beginning and end', () => {\n        const result: number = countDashes('-start-end-');\n        expect(result).toBe(3); // '-start-end-' contains three dashes\n    });\n\n    test('should return 0 for an empty string', () => {\n        const result: number = countDashes('');\n        expect(result).toBe(0); // An empty string contains no dashes\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * count the number of dashes in a string\n *\n * @param {string} str - The string from which to count dash characters.\n * @returns {number} - The total count of dash characters found in the string.\n */\nfunction countDashes(str: string): number {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Count the number of dashes in a string.\n *\n * @param str The string from which to count dash characters.\n * @returns The total count of dash characters found in the string.\n */\nint countDashes(const std::string& str) {\n}", "test_code": "TEST_CASE(\"countDashes\") {\n    SECTION(\"should return 0 for a string with no dashes\") {\n        REQUIRE(countDashes(\"hello world\") == 0); // 'hello world' contains no dashes\n    }\n\n    SECTION(\"should return 1 for a string with one dash\") {\n        REQUIRE(countDashes(\"hello-world\") == 1); // 'hello-world' contains one dash\n    }\n\n    SECTION(\"should return 4 for a string with multiple dashes\") {\n        REQUIRE(countDashes(\"a-b-c-d-e\") == 4); // 'a-b-c-d-e' contains four dashes\n    }\n\n    SECTION(\"should return 3 for a string with dashes at the beginning and end\") {\n        REQUIRE(countDashes(\"-start-end-\") == 3); // '-start-end-' contains three dashes\n    }\n\n    SECTION(\"should return 0 for an empty string\") {\n        REQUIRE(countDashes(\"\") == 0); // An empty string contains no dashes\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Count the number of dashes in a string.\n *\n * @param str The string from which to count dash characters.\n * @returns The total count of dash characters found in the string.\n */\nint countDashes(const std::string& str) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Count the number of dashes in a string.\n *\n * @param str The string from which to count dash characters.\n * @return The total count of dash characters found in the string.\n */\npublic static int countDashes(String str) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testCountDashes_NoDashes() {\n        int result = countDashes(\"hello world\");\n        assertEquals(0, result); // 'hello world' contains no dashes\n    }\n\n    @Test\n    public void testCountDashes_OneDash() {\n        int result = countDashes(\"hello-world\");\n        assertEquals(1, result); // 'hello-world' contains one dash\n    }\n\n    @Test\n    public void testCountDashes_MultipleDashes() {\n        int result = countDashes(\"a-b-c-d-e\");\n        assertEquals(4, result); // 'a-b-c-d-e' contains four dashes\n    }\n\n    @Test\n    public void testCountDashes_DashesAtEnds() {\n        int result = countDashes(\"-start-end-\");\n        assertEquals(3, result); // '-start-end-' contains three dashes\n    }\n\n    @Test\n    public void testCountDashes_EmptyString() {\n        int result = countDashes(\"\");\n        assertEquals(0, result); // An empty string contains no dashes\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Count the number of dashes in a string.\n *\n * @param str The string from which to count dash characters.\n * @return The total count of dash characters found in the string.\n */\npublic static int countDashes(String str) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 320, "code_type": "method", "original_language": "javascript", "question_type": "Program input code", "summary": "calculate the average of an array of numbers\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef get_array_average(array: List[float]) -> float:\n    \"\"\"\n    Calculate the average of an array of numbers.\n    Args:\n        array (List[float]): A list of numbers for which the average is to be calculated.\n\n    Returns:\n        float: The average (mean) of the array's elements, or float('nan') if the array is empty.\n    \"\"\"\n", "test_code": "import math\nimport unittest\n\n\nclass TestGetArrayAverage(unittest.TestCase):\n\n    def test_average_of_positive_integers(self):\n        result = get_array_average([1, 2, 3, 4, 5])\n        self.assertEqual(result, 3)  # (1 + 2 + 3 + 4 + 5) / 5 = 3\n\n    def test_average_with_negative_numbers(self):\n        result = get_array_average([-1, -2, -3, -4, -5])\n        self.assertEqual(result, -3)  # (-1 + -2 + -3 + -4 + -5) / 5 = -3\n\n    def test_average_with_mixed_numbers(self):\n        result = get_array_average([1, -1, 2, -2, 3, -3])\n        self.assertEqual(result, 0)  # (1 + -1 + 2 + -2 + 3 + -3) / 6 = 0\n\n\n    def test_single_element_array(self):\n        result = get_array_average([7])\n        self.assertEqual(result, 7)  # The average of [7] is 7\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef get_array_average(array: List[float]) -> float:\n    \"\"\"\n    Calculate the average of an array of numbers.\n    Args:\n        array (List[float]): A list of numbers for which the average is to be calculated.\n\n    Returns:\n        float: The average (mean) of the array's elements, or float('nan') if the array is empty.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * calculate the average of an array of numbers\n *\n * @param {number[]} array - An array of numbers for which the average is to be calculated.\n * @returns {number} - The average (mean) of the array's elements, or NaN if the array is empty.\n */\nfunction getArrayAverage(array) {\n}", "test_code": "describe('getArrayAverage', () => {\n    test('should return the average of an array of positive integers', () => {\n        const result = getArrayAverage([1, 2, 3, 4, 5]);\n        expect(result).toBe(3); // (1 + 2 + 3 + 4 + 5) / 5 = 3\n    });\n\n    test('should return the average of an array with negative numbers', () => {\n        const result = getArrayAverage([-1, -2, -3, -4, -5]);\n        expect(result).toBe(-3); // (-1 + -2 + -3 + -4 + -5) / 5 = -3\n    });\n\n    test('should return the average of an array with mixed positive and negative numbers', () => {\n        const result = getArrayAverage([1, -1, 2, -2, 3, -3]);\n        expect(result).toBe(0); // (1 + -1 + 2 + -2 + 3 + -3) / 6 = 0\n    });\n\n    test('should handle an empty array (edge case)', () => {\n        const result = getArrayAverage([]);\n        expect(result).toBeNaN(); // Division by zero, expected model_answer_result is NaN\n    });\n\n    test('should return the single element when the array contains one item', () => {\n        const result = getArrayAverage([7]);\n        expect(result).toBe(7); // The average of [7] is 7\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * calculate the average of an array of numbers\n *\n * @param {number[]} array - An array of numbers for which the average is to be calculated.\n * @returns {number} - The average (mean) of the array's elements, or NaN if the array is empty.\n */\nfunction getArrayAverage(array) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * calculate the average of an array of numbers\n *\n * @param {number[]} array - An array of numbers for which the average is to be calculated.\n * @returns {number} - The average (mean) of the array's elements, or NaN if the array is empty.\n */\nfunction getArrayAverage(array: number[]): number {\n}", "test_code": "describe('getArrayAverage', () => {\n    test('should return the average of an array of positive integers', () => {\n        const result = getArrayAverage([1, 2, 3, 4, 5]);\n        expect(result).toBe(3); // (1 + 2 + 3 + 4 + 5) / 5 = 3\n    });\n\n    test('should return the average of an array with negative numbers', () => {\n        const result = getArrayAverage([-1, -2, -3, -4, -5]);\n        expect(result).toBe(-3); // (-1 + -2 + -3 + -4 + -5) / 5 = -3\n    });\n\n    test('should return the average of an array with mixed positive and negative numbers', () => {\n        const result = getArrayAverage([1, -1, 2, -2, 3, -3]);\n        expect(result).toBe(0); // (1 + -1 + 2 + -2 + 3 + -3) / 6 = 0\n    });\n\n    test('should handle an empty array (edge case)', () => {\n        const result = getArrayAverage([]);\n        expect(result).toBeNaN(); // Division by zero, expected result is NaN\n    });\n\n    test('should return the single element when the array contains one item', () => {\n        const result = getArrayAverage([7]);\n        expect(result).toBe(7); // The average of [7] is 7\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * calculate the average of an array of numbers\n *\n * @param {number[]} array - An array of numbers for which the average is to be calculated.\n * @returns {number} - The average (mean) of the array's elements, or NaN if the array is empty.\n */\nfunction getArrayAverage(array: number[]): number {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * calculate the average of an array of numbers\n *\n * @param array - A vector of doubles for which the average is to be calculated.\n * @returns - The average (mean) of the vector's elements, or NaN if the vector is empty.\n */\ndouble getArrayAverage(const std::vector<double>& array) {}", "test_code": "TEST_CASE(\"getArrayAverage\") {\n    SECTION(\"should return the average of an array of positive integers\") {\n        REQUIRE(getArrayAverage({1, 2, 3, 4, 5}) == Approx(3)); // (1 + 2 + 3 + 4 + 5) / 5 = 3\n    }\n\n    SECTION(\"should return the average of an array with negative numbers\") {\n        REQUIRE(getArrayAverage({-1, -2, -3, -4, -5}) == Approx(-3)); // (-1 + -2 + -3 + -4 + -5) / 5 = -3\n    }\n\n    SECTION(\"should return the average of an array with mixed positive and negative numbers\") {\n        REQUIRE(getArrayAverage({1, -1, 2, -2, 3, -3}) == Approx(0)); // (1 + -1 + 2 + -2 + 3 + -3) / 6 = 0\n    }\n\n    SECTION(\"should handle an empty array (edge case)\") {\n        REQUIRE(std::isnan(getArrayAverage({}))); // Division by zero, expected result is NaN\n    }\n\n    SECTION(\"should return the single element when the array contains one item\") {\n        REQUIRE(getArrayAverage({7}) == Approx(7)); // The average of [7] is 7\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * calculate the average of an array of numbers\n *\n * @param array - A vector of doubles for which the average is to be calculated.\n * @returns - The average (mean) of the vector's elements, or NaN if the vector is empty.\n */\ndouble getArrayAverage(const std::vector<double>& array) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * calculate the average of an array of numbers\n *\n * @param array An array of integers for which the average is to be calculated.\n * @returns The average (mean) of the array's elements, or NaN if the array is empty.\n */\npublic static double getArrayAverage(int[] array) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testAverageOfPositiveIntegers() {\n        double result = getArrayAverage(new int[]{1, 2, 3, 4, 5});\n        assertEquals(3, result, 0.0001); // (1 + 2 + 3 + 4 + 5) / 5 = 3\n    }\n\n    @Test\n    public void testAverageWithNegativeNumbers() {\n        double result = getArrayAverage(new int[]{-1, -2, -3, -4, -5});\n        assertEquals(-3, result, 0.0001); // (-1 + -2 + -3 + -4 + -5) / 5 = -3\n    }\n\n    @Test\n    public void testAverageWithMixedNumbers() {\n        double result = getArrayAverage(new int[]{1, -1, 2, -2, 3, -3});\n        assertEquals(0, result, 0.0001); // (1 + -1 + 2 + -2 + 3 + -3) / 6 = 0\n    }\n\n    @Test\n    public void testEmptyArray() {\n        double result = getArrayAverage(new int[]{});\n        assertTrue(Double.isNaN(result)); // Division by zero, expected result is NaN\n    }\n\n    @Test\n    public void testSingleElementArray() {\n        double result = getArrayAverage(new int[]{7});\n        assertEquals(7, result, 0.0001); // The average of [7] is 7\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * calculate the average of an array of numbers\n *\n * @param array An array of integers for which the average is to be calculated.\n * @returns The average (mean) of the array's elements, or NaN if the array is empty.\n */\npublic static double getArrayAverage(int[] array) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 322, "code_type": "method", "original_language": "javascript", "question_type": "User interface", "summary": "verify that a string is a valid email address\n", "language_version_list": {"python": {"code_signature": "def is_valid_email(email: str) -> bool:\n    \"\"\"\n    Verify that a string is a valid email address.\n\n    Args:\n        email (str): The email address to be validated.\n\n    Returns:\n        bool: True if the email matches the regex pattern, indicating it is valid,or False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestIsValidEmail(unittest.TestCase):\n\n    def test_valid_simple_email(self):\n        result = is_valid_email('test@example.com')\n        self.assertTrue(result)  # 'test@example.com' is a valid email\n\n    def test_valid_email_with_subdomain(self):\n        result = is_valid_email('user@mail.example.com')\n        self.assertTrue(result)  # 'user@mail.example.com' is a valid email\n\n    def test_invalid_email_missing_at_symbol(self):\n        result = is_valid_email('invalid-email.com')\n        self.assertFalse(result)  # 'invalid-email.com' is missing the @ symbol\n\n    def test_invalid_email_missing_domain_part(self):\n        result = is_valid_email('user@.com')\n        self.assertFalse(result)  # 'user@.com' is missing a valid domain name\n\n    def test_invalid_email_with_spaces(self):\n        result = is_valid_email('user name@example.com')\n        self.assertFalse(result)  # 'user name@example.com' contains spaces\n", "prompt": "please write a python function , the function signature as below def is_valid_email(email: str) -> bool:\n    \"\"\"\n    Verify that a string is a valid email address.\n\n    Args:\n        email (str): The email address to be validated.\n\n    Returns:\n        bool: True if the email matches the regex pattern, indicating it is valid,or False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * verify that a string is a valid email address\n *\n * @param {string} email - The email address to be validated.\n * @returns {boolean} - Returns true if the email matches the regex pattern, indicating it is valid,\n *                      or false otherwise.\n */\nfunction isValidEmail(email) {\n}", "test_code": "describe('isValidEmail', () => {\n    test('should return true for a valid simple email', () => {\n        const result = isValidEmail('test@example.com');\n        expect(result).toBe(true); // 'test@example.com' is a valid email\n    });\n\n    test('should return true for a valid email with subdomain', () => {\n        const result = isValidEmail('user@mail.example.com');\n        expect(result).toBe(true); // 'user@mail.example.com' is a valid email\n    });\n\n    test('should return false for an email missing the @ symbol', () => {\n        const result = isValidEmail('invalid-email.com');\n        expect(result).toBe(false); // 'invalid-email.com' is missing the @ symbol\n    });\n\n    test('should return false for an email missing the domain part', () => {\n        const result = isValidEmail('user@.com');\n        expect(result).toBe(false); // 'user@.com' is missing a valid domain name\n    });\n\n    test('should return false for an email with spaces', () => {\n        const result = isValidEmail('user name@example.com');\n        expect(result).toBe(false); // 'user name@example.com' contains spaces\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * verify that a string is a valid email address\n *\n * @param {string} email - The email address to be validated.\n * @returns {boolean} - Returns true if the email matches the regex pattern, indicating it is valid,\n *                      or false otherwise.\n */\nfunction isValidEmail(email) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * verify that a string is a valid email address\n *\n * @param {string} email - The email address to be validated.\n * @returns {boolean} - Returns true if the email matches the regex pattern, indicating it is valid,\n *                      or false otherwise.\n */\nfunction isValidEmail(email: string): boolean {}", "test_code": "describe('isValidEmail', () => {\n    test('should return true for a valid simple email', () => {\n        const result: boolean = isValidEmail('test@example.com');\n        expect(result).toBe(true); // 'test@example.com' is a valid email\n    });\n\n    test('should return true for a valid email with subdomain', () => {\n        const result: boolean = isValidEmail('user@mail.example.com');\n        expect(result).toBe(true); // 'user@mail.example.com' is a valid email\n    });\n\n    test('should return false for an email missing the @ symbol', () => {\n        const result: boolean = isValidEmail('invalid-email.com');\n        expect(result).toBe(false); // 'invalid-email.com' is missing the @ symbol\n    });\n\n    test('should return false for an email missing the domain part', () => {\n        const result: boolean = isValidEmail('user@.com');\n        expect(result).toBe(false); // 'user@.com' is missing a valid domain name\n    });\n\n    test('should return false for an email with spaces', () => {\n        const result: boolean = isValidEmail('user name@example.com');\n        expect(result).toBe(false); // 'user name@example.com' contains spaces\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * verify that a string is a valid email address\n *\n * @param {string} email - The email address to be validated.\n * @returns {boolean} - Returns true if the email matches the regex pattern, indicating it is valid,\n *                      or false otherwise.\n */\nfunction isValidEmail(email: string): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * verify that a string is a valid email address\n *\n * @param email - The email address to be validated.\n * @returns true if the email matches the regex pattern, indicating it is valid,\n *          or false otherwise.\n */\nbool isValidEmail(const std::string& email) {}", "test_code": "TEST_CASE(\"isValidEmail\") {\n    SECTION(\"should return true for a valid simple email\") {\n        REQUIRE(isValidEmail(\"test@example.com\") == true); // 'test@example.com' is a valid email\n    }\n\n    SECTION(\"should return true for a valid email with subdomain\") {\n        REQUIRE(isValidEmail(\"user@mail.example.com\") == true); // 'user@mail.example.com' is a valid email\n    }\n\n    SECTION(\"should return false for an email missing the @ symbol\") {\n        REQUIRE(isValidEmail(\"invalid-email.com\") == false); // 'invalid-email.com' is missing the @ symbol\n    }\n\n    SECTION(\"should return false for an email missing the domain part\") {\n        REQUIRE(isValidEmail(\"user@.com\") == false); // 'user@.com' is missing a valid domain name\n    }\n\n    SECTION(\"should return false for an email with spaces\") {\n        REQUIRE(isValidEmail(\"user name@example.com\") == false); // 'user name@example.com' contains spaces\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * verify that a string is a valid email address\n *\n * @param email - The email address to be validated.\n * @returns true if the email matches the regex pattern, indicating it is valid,\n *          or false otherwise.\n */\nbool isValidEmail(const std::string& email) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Verify that a string is a valid email address.\n *\n * @param email The email address to be validated.\n * @return Returns true if the email matches the regex pattern, indicating it is valid,\n *         or false otherwise.\n */\npublic static boolean isValidEmail(String email) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testValidSimpleEmail() {\n        boolean result = isValidEmail(\"test@example.com\");\n        assertTrue(result); // 'test@example.com' is a valid email\n    }\n\n    @Test\n    public void testValidEmailWithSubdomain() {\n        boolean result = isValidEmail(\"user@mail.example.com\");\n        assertTrue(result); // 'user@mail.example.com' is a valid email\n    }\n\n    @Test\n    public void testEmailMissingAtSymbol() {\n        boolean result = isValidEmail(\"invalid-email.com\");\n        assertFalse(result); // 'invalid-email.com' is missing the @ symbol\n    }\n\n    @Test\n    public void testEmailMissingDomainPart() {\n        boolean result = isValidEmail(\"user@.com\");\n        assertFalse(result); // 'user@.com' is missing a valid domain name\n    }\n\n    @Test\n    public void testEmailWithSpaces() {\n        boolean result = isValidEmail(\"user name@example.com\");\n        assertFalse(result); // 'user name@example.com' contains spaces\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Verify that a string is a valid email address.\n *\n * @param email The email address to be validated.\n * @return Returns true if the email matches the regex pattern, indicating it is valid,\n *         or false otherwise.\n */\npublic static boolean isValidEmail(String email) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 323, "code_type": "method", "original_language": "javascript", "question_type": "User interface", "summary": "verify that a string is a valid username and check that the username contains only letters, numbers, and underscores\n", "language_version_list": {"python": {"code_signature": "def is_valid_username(username: str) -> bool:\n    \"\"\"\n    Verify that a string is a valid username and check that the username contains only letters, numbers, and underscores.\n\n    Args:\n        username (str): The username to be validated.\n\n    Returns:\n        bool: True if the username matches the regex pattern, indicating it is valid;False if the username contains any characters outside of letters, numbers, and underscores.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestUsernameValidation(unittest.TestCase):\n\n    def test_valid_username_with_letters_numbers_and_underscores(self):\n        result = is_valid_username('user_123')\n        self.assertEqual(result, True)  # 'user_123' is a valid username\n\n    def test_valid_username_with_only_letters(self):\n        result = is_valid_username('username')\n        self.assertEqual(result, True)  # 'username' is a valid username\n\n    def test_invalid_username_with_special_characters(self):\n        result = is_valid_username('user-name')\n        self.assertEqual(result, False)  # 'user-name' contains a hyphen\n\n    def test_invalid_username_with_spaces(self):\n        result = is_valid_username('user name')\n        self.assertEqual(result, False)  # 'user name' contains spaces\n\n    def test_valid_username_with_only_numbers(self):\n        result = is_valid_username('12345')\n        self.assertEqual(result, True)  # '12345' is a valid username\n", "prompt": "please write a python function , the function signature as below def is_valid_username(username: str) -> bool:\n    \"\"\"\n    Verify that a string is a valid username and check that the username contains only letters, numbers, and underscores.\n\n    Args:\n        username (str): The username to be validated.\n\n    Returns:\n        bool: True if the username matches the regex pattern, indicating it is valid;False if the username contains any characters outside of letters, numbers, and underscores.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * verify that a string is a valid username and check that the username contains only letters, numbers, and underscores\n *\n * @param {string} username - The username to be validated.\n * @returns {boolean} - Returns true if the username matches the regex pattern, indicating it is valid;\n *                      returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\nfunction isValidUsername(username) {\n}\n", "test_code": "describe('isValidUsername', () => {\n    test('should return true for a valid username with letters, numbers, and underscores', () => {\n        const result = isValidUsername('user_123');\n        expect(result).toBe(true); // 'user_123' is a valid username\n    });\n\n    test('should return true for a valid username with only letters', () => {\n        const result = isValidUsername('username');\n        expect(result).toBe(true); // 'username' is a valid username\n    });\n\n    test('should return false for a username with special characters', () => {\n        const result = isValidUsername('user-name');\n        expect(result).toBe(false); // 'user-name' contains a hyphen\n    });\n\n    test('should return false for a username with spaces', () => {\n        const result = isValidUsername('user name');\n        expect(result).toBe(false); // 'user name' contains spaces\n    });\n\n    test('should return true for a valid username with only numbers', () => {\n        const result = isValidUsername('12345');\n        expect(result).toBe(true); // '12345' is a valid username\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * verify that a string is a valid username and check that the username contains only letters, numbers, and underscores\n *\n * @param {string} username - The username to be validated.\n * @returns {boolean} - Returns true if the username matches the regex pattern, indicating it is valid;\n *                      returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\nfunction isValidUsername(username) {\n}\n", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Verify that a string is a valid username and check that the username contains only letters, numbers, and underscores\n *\n * @param {string} username - The username to be validated.\n * @returns {boolean} - Returns true if the username matches the regex pattern, indicating it is valid;\n *                      returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\nfunction isValidUsername(username: string): boolean {}", "test_code": "describe('isValidUsername', () => {\n    test('should return true for a valid username with letters, numbers, and underscores', () => {\n        const result: boolean = isValidUsername('user_123');\n        expect(result).toBe(true); // 'user_123' is a valid username\n    });\n\n    test('should return true for a valid username with only letters', () => {\n        const result: boolean = isValidUsername('username');\n        expect(result).toBe(true); // 'username' is a valid username\n    });\n\n    test('should return false for a username with special characters', () => {\n        const result: boolean = isValidUsername('user-name');\n        expect(result).toBe(false); // 'user-name' contains a hyphen\n    });\n\n    test('should return false for a username with spaces', () => {\n        const result: boolean = isValidUsername('user name');\n        expect(result).toBe(false); // 'user name' contains spaces\n    });\n\n    test('should return true for a valid username with only numbers', () => {\n        const result: boolean = isValidUsername('12345');\n        expect(result).toBe(true); // '12345' is a valid username\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Verify that a string is a valid username and check that the username contains only letters, numbers, and underscores\n *\n * @param {string} username - The username to be validated.\n * @returns {boolean} - Returns true if the username matches the regex pattern, indicating it is valid;\n *                      returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\nfunction isValidUsername(username: string): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Verify that a string is a valid username and check that the username contains only letters, numbers, and underscores.\n *\n * @param username - The username to be validated.\n * @returns true if the username matches the regex pattern, indicating it is valid;\n *          returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\nbool isValidUsername(const std::string& username) {}", "test_code": "TEST_CASE(\"isValidUsername\", \"[username]\") {\n    SECTION(\"should return true for a valid username with letters, numbers, and underscores\") {\n        REQUIRE(isValidUsername(\"user_123\") == true); // 'user_123' is a valid username\n    }\n\n    SECTION(\"should return true for a valid username with only letters\") {\n        REQUIRE(isValidUsername(\"username\") == true); // 'username' is a valid username\n    }\n\n    SECTION(\"should return false for a username with special characters\") {\n        REQUIRE(isValidUsername(\"user-name\") == false); // 'user-name' contains a hyphen\n    }\n\n    SECTION(\"should return false for a username with spaces\") {\n        REQUIRE(isValidUsername(\"user name\") == false); // 'user name' contains spaces\n    }\n\n    SECTION(\"should return true for a valid username with only numbers\") {\n        REQUIRE(isValidUsername(\"12345\") == true); // '12345' is a valid username\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Verify that a string is a valid username and check that the username contains only letters, numbers, and underscores.\n *\n * @param username - The username to be validated.\n * @returns true if the username matches the regex pattern, indicating it is valid;\n *          returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\nbool isValidUsername(const std::string& username) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Verify that a string is a valid username and check that the username contains only letters, numbers, and underscores.\n *\n * @param username The username to be validated.\n * @return Returns true if the username matches the regex pattern, indicating it is valid;\n *         returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\npublic static boolean isValidUsername(String username) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testValidUsernameWithLettersNumbersAndUnderscores() {\n        boolean result = isValidUsername(\"user_123\");\n        assertTrue(result); // 'user_123' is a valid username\n    }\n\n    @Test\n    public void testValidUsernameWithOnlyLetters() {\n        boolean result = isValidUsername(\"username\");\n        assertTrue(result); // 'username' is a valid username\n    }\n\n    @Test\n    public void testUsernameWithSpecialCharacters() {\n        boolean result = isValidUsername(\"user-name\");\n        assertFalse(result); // 'user-name' contains a hyphen\n    }\n\n    @Test\n    public void testUsernameWithSpaces() {\n        boolean result = isValidUsername(\"user name\");\n        assertFalse(result); // 'user name' contains spaces\n    }\n\n    @Test\n    public void testValidUsernameWithOnlyNumbers() {\n        boolean result = isValidUsername(\"12345\");\n        assertTrue(result); // '12345' is a valid username\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Verify that a string is a valid username and check that the username contains only letters, numbers, and underscores.\n *\n * @param username The username to be validated.\n * @return Returns true if the username matches the regex pattern, indicating it is valid;\n *         returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\npublic static boolean isValidUsername(String username) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 326, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Calculates the time difference between a given date and the current date, returning how many days, hours, and minutes elapsed between the two times", "language_version_list": {"python": {"code_signature": "def calculate_time_difference(given_date: str) -> dict:\n    \"\"\"\n    Calculates the time difference between a given date and the current date.\n\n    Args:\n        given_date (str): The date to compare against the current date.\n\n    Returns:\n        dict: A dictionary containing days, hours, and minutes elapsed.\n              {\n                  'days': days,\n                  'hours': remaining_hours,\n                  'minutes': remaining_minutes,\n              }\n    \"\"\"", "test_code": "import unittest\nfrom datetime import timedelta, datetime\n\n\nclass TestCalculateTimeDifference(unittest.TestCase):\n\n    def test_should_return_correct_time_difference_for_a_date_in_the_past(self):\n        past_date = datetime.now() - timedelta(days=3, minutes=5)  # 3 days and 5 minutes ago\n        result = calculate_time_difference(past_date)\n        self.assertEqual(result, {'days': 3, 'hours': 0, 'minutes': 5})\n\n    def test_should_return_correct_time_difference_for_a_date_that_is_exactly_now(self):\n        now = datetime.now()\n        result = calculate_time_difference(now)\n        self.assertEqual(result, {'days': 0, 'hours': 0, 'minutes': 0})\n\n    def test_should_return_correct_time_difference_for_a_date_just_seconds_ago(self):\n        just_now = datetime.now() - timedelta(seconds=45)  # 45 seconds ago\n        result = calculate_time_difference(just_now)\n        self.assertEqual(result, {'days': 0, 'hours': 0, 'minutes': 0})\n\n    def test_should_return_correct_time_difference_for_a_date_with_only_hours_difference(self):\n        hours_ago = datetime.now() - timedelta(hours=7)  # 7 hours ago\n        result = calculate_time_difference(hours_ago)\n        self.assertEqual(result, {'days': 0, 'hours': 7, 'minutes': 0})\n\n    def test_should_return_correct_time_difference_for_a_date_with_hours_and_minutes_difference(self):\n        hours_and_minutes_ago = datetime.now() - timedelta(days=1, minutes=3)  # 1 day and 3 minutes ago\n        result = calculate_time_difference(hours_and_minutes_ago)\n        self.assertEqual(result, {'days': 1, 'hours': 0, 'minutes': 3})\n", "prompt": "please write a python function , the function signature as below def calculate_time_difference(given_date: str) -> dict:\n    \"\"\"\n    Calculates the time difference between a given date and the current date.\n\n    Args:\n        given_date (str): The date to compare against the current date.\n\n    Returns:\n        dict: A dictionary containing days, hours, and minutes elapsed.\n              {\n                  'days': days,\n                  'hours': remaining_hours,\n                  'minutes': remaining_minutes,\n              }\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculates the time difference between a given date and the current date.\n *\n * @param {Date | string} givenDate - The date to compare against the current date.\n * @returns {Object} - An object containing days, hours, and minutes elapsed.\n * {\n *         days: days,\n *         hours: remainingHours,\n *         minutes: remainingMinutes,\n * }\n */\nfunction calculateTimeDifference(givenDate) {\n}", "test_code": "describe('calculateTimeDifference', () => {\n    test('should return correct time difference for a date in the past', () => {\n        const pastDate = new Date(Date.now() - 3 * 24 * 60 * 60 * 1000 - 5 * 60 * 1000); // 3 days and 5 minutes ago\n        const result = calculateTimeDifference(pastDate);\n        expect(result).toEqual({ days: 3, hours: 0, minutes: 5 });\n    });\n\n    test('should return correct time difference for a date that is exactly now', () => {\n        const now = new Date();\n        const result = calculateTimeDifference(now);\n        expect(result).toEqual({ days: 0, hours: 0, minutes: 0 });\n    });\n\n    test('should return correct time difference for a date just seconds ago', () => {\n        const justNow = new Date(Date.now() - 45 * 1000); // 45 seconds ago\n        const result = calculateTimeDifference(justNow);\n        expect(result).toEqual({ days: 0, hours: 0, minutes: 0 });\n    });\n\n\n    test('should return correct time difference for a date with only hours difference', () => {\n        const hoursAgo = new Date(Date.now() - 7 * 60 * 60 * 1000); // 7 hours ago\n        const result = calculateTimeDifference(hoursAgo);\n        expect(result).toEqual({ days: 0, hours: 7, minutes: 0 });\n    });\n\n    test('should return correct time difference for a date with hours and minutes difference', () => {\n        const hoursAndMinutesAgo = new Date(Date.now() - (1 * 24 * 60 * 60 * 1000 + 3 * 60 * 1000)); // 1 day and 3 minutes ago\n        const result = calculateTimeDifference(hoursAndMinutesAgo);\n        expect(result).toEqual({ days: 1, hours: 0, minutes: 3 });\n    });\n\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the time difference between a given date and the current date.\n *\n * @param {Date | string} givenDate - The date to compare against the current date.\n * @returns {Object} - An object containing days, hours, and minutes elapsed.\n * {\n *         days: days,\n *         hours: remainingHours,\n *         minutes: remainingMinutes,\n * }\n */\nfunction calculateTimeDifference(givenDate) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the time difference between a given date and the current date.\n *\n * @param {Date | string} givenDate - The date to compare against the current date.\n * @returns {Object} - An object containing days, hours, and minutes elapsed.\n * {\n *         days: number,\n *         hours: number,\n *         minutes: number,\n * }\n */\nfunction calculateTimeDifference(givenDate: Date | string): { days: number; hours: number; minutes: number } {}", "test_code": "describe('calculateTimeDifference', () => {\n    test('should return correct time difference for a date in the past', () => {\n        const pastDate = new Date(Date.now() - 3 * 24 * 60 * 60 * 1000 - 5 * 60 * 1000); // 3 days and 5 minutes ago\n        const result = calculateTimeDifference(pastDate);\n        expect(result).toEqual({ days: 3, hours: 0, minutes: 5 });\n    });\n\n    test('should return correct time difference for a date that is exactly now', () => {\n        const now = new Date();\n        const result = calculateTimeDifference(now);\n        expect(result).toEqual({ days: 0, hours: 0, minutes: 0 });\n    });\n\n    test('should return correct time difference for a date just seconds ago', () => {\n        const justNow = new Date(Date.now() - 45 * 1000); // 45 seconds ago\n        const result = calculateTimeDifference(justNow);\n        expect(result).toEqual({ days: 0, hours: 0, minutes: 0 });\n    });\n\n    test('should return correct time difference for a date with only hours difference', () => {\n        const hoursAgo = new Date(Date.now() - 7 * 60 * 60 * 1000); // 7 hours ago\n        const result = calculateTimeDifference(hoursAgo);\n        expect(result).toEqual({ days: 0, hours: 7, minutes: 0 });\n    });\n\n    test('should return correct time difference for a date with hours and minutes difference', () => {\n        const hoursAndMinutesAgo = new Date(Date.now() - (1 * 24 * 60 * 60 * 1000 + 3 * 60 * 1000)); // 1 day and 3 minutes ago\n        const result = calculateTimeDifference(hoursAndMinutesAgo);\n        expect(result).toEqual({ days: 1, hours: 0, minutes: 3 });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the time difference between a given date and the current date.\n *\n * @param {Date | string} givenDate - The date to compare against the current date.\n * @returns {Object} - An object containing days, hours, and minutes elapsed.\n * {\n *         days: number,\n *         hours: number,\n *         minutes: number,\n * }\n */\nfunction calculateTimeDifference(givenDate: Date | string): { days: number; hours: number; minutes: number } {}", "addition_info": ""}, "c&cpp": {"code_signature": "struct TimeDifference {\n    int days;\n    int hours;\n    int minutes;\n};\n/**\n * Calculates the time difference between a given date and the current date.\n *\n * @param givenDate - The date to compare against the current date.\n * @returns - A struct containing days, hours, and minutes elapsed.\n * {\n *         int days;\n *         int hours;\n *         int minutes;\n * }\n */\nTimeDifference calculateTimeDifference(const std::string& givenDate){}", "test_code": "TEST_CASE(\"calculateTimeDifference\") {\n    SECTION(\"should return correct time difference for a date in the past\") {\n        auto pastDate = std::chrono::system_clock::now() - std::chrono::hours(3 * 24 + 5 / 60);\n        std::time_t pastTime = std::chrono::system_clock::to_time_t(pastDate);\n        std::tm* tmPast = std::localtime(&pastTime);\n        char buffer[20];\n        std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", tmPast);\n        \n        TimeDifference result = calculateTimeDifference(buffer);\n        REQUIRE(result.days == 3);\n        REQUIRE(result.hours == 0);\n        REQUIRE(result.minutes == 5);\n    }\n\n    SECTION(\"should return correct time difference for a date that is exactly now\") {\n        auto now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());\n        std::tm* tmNow = std::localtime(&now);\n        char buffer[20];\n        std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", tmNow);\n\n        TimeDifference result = calculateTimeDifference(buffer);\n        REQUIRE(result.days == 0);\n        REQUIRE(result.hours == 0);\n        REQUIRE(result.minutes == 0);\n    }\n\n    SECTION(\"should return correct time difference for a date just seconds ago\") {\n        auto justNow = std::chrono::system_clock::now() - std::chrono::seconds(45);\n        std::time_t justNowTime = std::chrono::system_clock::to_time_t(justNow);\n        std::tm* tmJustNow = std::localtime(&justNowTime);\n        char buffer[20];\n        std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", tmJustNow);\n        \n        TimeDifference result = calculateTimeDifference(buffer);\n        REQUIRE(result.days == 0);\n        REQUIRE(result.hours == 0);\n        REQUIRE(result.minutes == 0);\n    }\n\n    SECTION(\"should return correct time difference for a date with only hours difference\") {\n        auto hoursAgo = std::chrono::system_clock::now() - std::chrono::hours(7);\n        std::time_t hoursAgoTime = std::chrono::system_clock::to_time_t(hoursAgo);\n        std::tm* tmHoursAgo = std::localtime(&hoursAgoTime);\n        char buffer[20];\n        std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", tmHoursAgo);\n\n        TimeDifference result = calculateTimeDifference(buffer);\n        REQUIRE(result.days == 0);\n        REQUIRE(result.hours == 7);\n        REQUIRE(result.minutes == 0);\n    }\n\n    SECTION(\"should return correct time difference for a date with hours and minutes difference\") {\n        auto hoursAndMinutesAgo = std::chrono::system_clock::now() - std::chrono::hours(24) - std::chrono::minutes(3);\n        std::time_t hoursAndMinutesAgoTime = std::chrono::system_clock::to_time_t(hoursAndMinutesAgo);\n        std::tm* tmHoursAndMinutesAgo = std::localtime(&hoursAndMinutesAgoTime);\n        char buffer[20];\n        std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", tmHoursAndMinutesAgo);\n\n        TimeDifference result = calculateTimeDifference(buffer);\n        REQUIRE(result.days == 1);\n        REQUIRE(result.hours == 0);\n        REQUIRE(result.minutes == 3);\n    }\n}", "prompt": "please write a cpp function , the function signature as below struct TimeDifference {\n    int days;\n    int hours;\n    int minutes;\n};\n/**\n * Calculates the time difference between a given date and the current date.\n *\n * @param givenDate - The date to compare against the current date.\n * @returns - A struct containing days, hours, and minutes elapsed.\n * {\n *         int days;\n *         int hours;\n *         int minutes;\n * }\n */\nTimeDifference calculateTimeDifference(const std::string& givenDate){}", "addition_info": "struct TimeDifference {\n    int days;\n    int hours;\n    int minutes;\n};"}, "java": {"code_signature": "    public static class TimeDifference {\n        public long days;\n        public long hours;\n        public long minutes;\n\n        public TimeDifference(long days, long hours, long minutes) {\n            this.days = days;\n            this.hours = hours;\n            this.minutes = minutes;\n        }\n    }\n/**\n * Calculates the time difference between a given date and the current date.\n *\n * @param givenDate - The date to compare against the current date.\n * @returns TimeDifference - An object containing days, hours, and minutes elapsed.\n */\npublic static TimeDifference calculateTimeDifference(String givenDate) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testCalculateTimeDifferenceForPastDate() {\n        long pastDateMillis = System.currentTimeMillis() - (3 * 24 * 60 * 60 * 1000 + 5 * 60 * 1000); // 3 days and 5 minutes ago\n        TimeDifference result = TimeDifferenceCalculator.calculateTimeDifference(new Date(pastDateMillis));\n        assertEquals(3, result.days);\n        assertEquals(0, result.hours);\n        assertEquals(5, result.minutes);\n    }\n\n    @Test\n    public void testCalculateTimeDifferenceForNow() {\n        Date now = new Date();\n        TimeDifference result = TimeDifferenceCalculator.calculateTimeDifference(now);\n        assertEquals(0, result.days);\n        assertEquals(0, result.hours);\n        assertEquals(0, result.minutes);\n    }\n\n    @Test\n    public void testCalculateTimeDifferenceForJustSecondsAgo() {\n        long justNowMillis = System.currentTimeMillis() - 45 * 1000; // 45 seconds ago\n        TimeDifference result = TimeDifferenceCalculator.calculateTimeDifference(new Date(justNowMillis));\n        assertEquals(0, result.days);\n        assertEquals(0, result.hours);\n        assertEquals(0, result.minutes);\n    }\n\n    @Test\n    public void testCalculateTimeDifferenceForHoursDifference() {\n        long hoursAgoMillis = System.currentTimeMillis() - 7 * 60 * 60 * 1000; // 7 hours ago\n        TimeDifference result = TimeDifferenceCalculator.calculateTimeDifference(new Date(hoursAgoMillis));\n        assertEquals(0, result.days);\n        assertEquals(7, result.hours);\n        assertEquals(0, result.minutes);\n    }\n\n    @Test\n    public void testCalculateTimeDifferenceForHoursAndMinutesDifference() {\n        long hoursAndMinutesAgoMillis = System.currentTimeMillis() - (1 * 24 * 60 * 60 * 1000 + 3 * 60 * 1000); // 1 day and 3 minutes ago\n        TimeDifference result = TimeDifferenceCalculator.calculateTimeDifference(new Date(hoursAndMinutesAgoMillis));\n        assertEquals(1, result.days);\n        assertEquals(0, result.hours);\n        assertEquals(3, result.minutes);\n    }\n\n    public static class TimeDifference {\n        public long days;\n        public long hours;\n        public long minutes;\n\n        public TimeDifference(long days, long hours, long minutes) {\n            this.days = days;\n            this.hours = hours;\n            this.minutes = minutes;\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below     public static class TimeDifference {\n        public long days;\n        public long hours;\n        public long minutes;\n\n        public TimeDifference(long days, long hours, long minutes) {\n            this.days = days;\n            this.hours = hours;\n            this.minutes = minutes;\n        }\n    }\n/**\n * Calculates the time difference between a given date and the current date.\n *\n * @param givenDate - The date to compare against the current date.\n * @returns TimeDifference - An object containing days, hours, and minutes elapsed.\n */\npublic static TimeDifference calculateTimeDifference(String givenDate) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 447, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Calculate age based on the birth date string entered by the user\n", "language_version_list": {"python": {"code_signature": "from typing import Union\n\n\ndef calculate_age(birth_date_string: str) -> Union[str,int]:\n    \"\"\"\n    Calculate age based on the birth date string entered by the user.\n\n    Input birth_date_string format such as \"2000-01-01\".\n\n    Args:\n        birth_date_string (str): The birth date in string format.\n\n    Returns:\n        str | int: The age as an integer or an error message as a string\n                    if the date format is invalid.\n    \"\"\"", "test_code": "from datetime import datetime, timedelta\nimport unittest\n\n\nclass TestCalculateAge(unittest.TestCase):\n\n    def test_calculates_age_correctly_for_a_birth_date_in_the_past(self):\n        self.assertEqual(calculate_age('2000-01-01'), datetime.now().year - 2000)\n\n    def test_calculates_age_correctly_for_a_birth_date_in_the_long_past(self):\n        self.assertEqual(calculate_age('1000-01-01'), datetime.now().year - 1000)\n\n    def test_calculates_age_correctly_for_a_birth_date_today(self):\n        today = datetime.now().strftime('%Y-%m-%d')  # Get today's date in YYYY-MM-DD format\n        self.assertEqual(calculate_age(today), 0)\n\n    def test_calculates_age_correctly_for_a_person_born_yesterday(self):\n        yesterday = datetime.now() - timedelta(days=1)  # Set to yesterday\n        birth_date_string = yesterday.strftime('%Y-%m-%d')  # Format as YYYY-MM-DD\n        self.assertEqual(calculate_age(birth_date_string), 0)\n", "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef calculate_age(birth_date_string: str) -> Union[str,int]:\n    \"\"\"\n    Calculate age based on the birth date string entered by the user.\n\n    Input birth_date_string format such as \"2000-01-01\".\n\n    Args:\n        birth_date_string (str): The birth date in string format.\n\n    Returns:\n        str | int: The age as an integer or an error message as a string\n                    if the date format is invalid.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculate age based on the birth date string entered by the user.Input birthDateString format such as 2000-01-01\n * @param birthDateString\n * @returns {string|number}\n */\nfunction calculateAge(birthDateString) {\n}\n", "test_code": "describe('calculateAge', () => {\n    test('calculates age correctly for a birth date in the past', () => {\n        expect(calculateAge('2000-01-01')).toBe(new Date().getFullYear() - 2000);\n    });\n\n    test('calculates age correctly for a birth date in the long past', () => {\n        expect(calculateAge('1000-01-01')).toBe(new Date().getFullYear() - 1000);\n    });\n\n\n    test('calculates age correctly for a birth date today', () => {\n        const today = new Date().toISOString().split('T')[0]; // Get today's date in YYYY-MM-DD format\n        expect(calculateAge(today)).toBe(0);\n    });\n\n\n    test('calculates age correctly for a person born yesterday', () => {\n        const yesterday = new Date();\n        yesterday.setDate(yesterday.getDate() - 1); // Set to yesterday\n        const birthDateString = yesterday.toISOString().split('T')[0];\n        expect(calculateAge(birthDateString)).toBe(0);\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Calculate age based on the birth date string entered by the user.Input birthDateString format such as 2000-01-01\n * @param birthDateString\n * @returns {string|number}\n */\nfunction calculateAge(birthDateString) {\n}\n", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculate age based on the birth date string entered by the user. Input birthDateString format such as 2000-01-01\n * @param birthDateString - The birth date as a string\n * @returns {string | number} - The calculated age or an error message\n */\nfunction calculateAge(birthDateString: string): string | number {\n}", "test_code": "describe('calculateAge', () => {\n    test('calculates age correctly for a birth date in the past', () => {\n        expect(calculateAge('2000-01-01')).toBe(new Date().getFullYear() - 2000);\n    });\n\n    test('calculates age correctly for a birth date in the long past', () => {\n        expect(calculateAge('1000-01-01')).toBe(new Date().getFullYear() - 1000);\n    });\n\n    test('calculates age correctly for a birth date today', () => {\n        const today = new Date().toISOString().split('T')[0]; // Get today's date in YYYY-MM-DD format\n        expect(calculateAge(today)).toBe(0);\n    });\n\n    test('calculates age correctly for a person born yesterday', () => {\n        const yesterday = new Date();\n        yesterday.setDate(yesterday.getDate() - 1); // Set to yesterday\n        const birthDateString = yesterday.toISOString().split('T')[0];\n        expect(calculateAge(birthDateString)).toBe(0);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculate age based on the birth date string entered by the user. Input birthDateString format such as 2000-01-01\n * @param birthDateString - The birth date as a string\n * @returns {string | number} - The calculated age or an error message\n */\nfunction calculateAge(birthDateString: string): string | number {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate age based on the birth date string entered by the user. Input birthDateString format such as 2000-01-01\n * @param birthDateString\n * @returns int\n */\nint calculateAge(const std::string& birthDateString) {\n}", "test_code": "TEST_CASE(\"calculateAge\", \"[age]\") {\n    SECTION(\"calculates age correctly for a birth date in the past\") {\n        REQUIRE(calculateAge(\"2000-01-01\") == (std::time(0) / (365.25 * 24 * 60 * 60)) - 2000);\n    }\n\n    SECTION(\"calculates age correctly for a birth date in the long past\") {\n        REQUIRE(calculateAge(\"1000-01-01\") == (std::time(0) / (365.25 * 24 * 60 * 60)) - 1000);\n    }\n\n    SECTION(\"calculates age correctly for a birth date today\") {\n        std::time_t now = std::time(0);\n        std::tm* today = std::localtime(&now);\n        std::ostringstream oss;\n        oss << std::put_time(today, \"%Y-%m-%d\");\n        REQUIRE(calculateAge(oss.str()) == 0);\n    }\n\n    SECTION(\"calculates age correctly for a person born yesterday\") {\n        std::time_t now = std::time(0);\n        std::tm* yesterday = std::localtime(&now);\n        yesterday->tm_mday--; // Set to yesterday\n        std::mktime(yesterday); // Normalize the structure\n        std::ostringstream oss;\n        oss << std::put_time(yesterday, \"%Y-%m-%d\");\n        REQUIRE(calculateAge(oss.str()) == 0);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate age based on the birth date string entered by the user. Input birthDateString format such as 2000-01-01\n * @param birthDateString\n * @returns int\n */\nint calculateAge(const std::string& birthDateString) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate age based on the birth date string entered by the user. Input birthDateString format such as 2000-01-01\n * @param birthDateString the birth date in string format\n * @return the age as a string or a message indicating an invalid date\n */\npublic static String calculateAge(String birthDateString) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class Tester {\n\n    @Test\n    public void testCalculateAgeForBirthDateInThePast() {\n        assertEquals(new Date().getYear() + 1900 - 2000, Integer.parseInt(calculateAge(\"2000-01-01\")));\n    }\n\n    @Test\n    public void testCalculateAgeForBirthDateInTheLongPast() {\n        assertEquals(new Date().getYear() + 1900 - 1000, Integer.parseInt(calculateAge(\"1000-01-01\")));\n    }\n\n    @Test\n    public void testCalculateAgeForBirthDateToday() {\n        String today = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n        assertEquals(0, Integer.parseInt(calculateAge(today)));\n    }\n\n    @Test\n    public void testCalculateAgeForPersonBornYesterday() {\n        Calendar yesterday = Calendar.getInstance();\n        yesterday.add(Calendar.DAY_OF_MONTH, -1); // Set to yesterday\n        String birthDateString = new SimpleDateFormat(\"yyyy-MM-dd\").format(yesterday.getTime());\n        assertEquals(0, Integer.parseInt(calculateAge(birthDateString)));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculate age based on the birth date string entered by the user. Input birthDateString format such as 2000-01-01\n * @param birthDateString the birth date in string format\n * @return the age as a string or a message indicating an invalid date\n */\npublic static String calculateAge(String birthDateString) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 449, "code_type": "method", "original_language": "javascript", "question_type": "Algorithm and data structure", "summary": "Convert Buffer to Base64 encoding", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a string to Base64 encoding.\n *\n * @param {string} input - The string to be converted to Base64.\n * @returns {string} The Base64 encoded string.\n */\nfunction convertToBase64(input) {\n}", "test_code": "describe('Base64 Encoding Tests', () => {\n    test('Convert simple string to Base64', () => {\n        expect(convertToBase64(\"Hello, World!\")).toBe(\"SGVsbG8sIFdvcmxkIQ==\");\n    });\n\n    test('Convert empty string to Base64', () => {\n        expect(convertToBase64(\"\")).toBe(\"\");\n    });\n\n    test('Convert string with spaces to Base64', () => {\n        expect(convertToBase64(\"Test String with Spaces\")).toBe(\"VGVzdCBTdHJpbmcgd2l0aCBTcGFjZXM=\");\n    });\n\n    test('Convert string with special characters to Base64', () => {\n        expect(convertToBase64(\"Special characters: @#&*()\")).toBe(\"U3BlY2lhbCBjaGFyYWN0ZXJzOiBAIyYqKCk=\");\n    });\n\n    test('Convert string with non-ASCII characters to Base64', () => {\n        expect(convertToBase64(\"\u4f60\u597d\uff0c\u4e16\u754c\uff01\")).toBe(\"5L2g5aW977yM5LiW55WM77yB\");\n    });\n\n    test('Convert long string to Base64', () => {\n        const longString = \"This is a very long string that exceeds normal lengths for testing purposes.\";\n        expect(convertToBase64(longString)).toBe(\"VGhpcyBpcyBhIHZlcnkgbG9uZyBzdHJpbmcgdGhhdCBleGNlZWRzIG5vcm1hbCBsZW5ndGhzIGZvciB0ZXN0aW5nIHB1cnBvc2VzLg==\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a string to Base64 encoding.\n *\n * @param {string} input - The string to be converted to Base64.\n * @returns {string} The Base64 encoded string.\n */\nfunction convertToBase64(input) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a string to Base64 encoding.\n *\n * @param {string} input - The string to be converted to Base64.\n * @returns {string} The Base64 encoded string.\n */\nfunction convertToBase64(input: string): string {\n}", "test_code": "describe('Base64 Encoding Tests', () => {\n    test('Convert simple string to Base64', () => {\n        expect(convertToBase64(\"Hello, World!\")).toBe(\"SGVsbG8sIFdvcmxkIQ==\");\n    });\n\n    test('Convert empty string to Base64', () => {\n        expect(convertToBase64(\"\")).toBe(\"\");\n    });\n\n    test('Convert string with spaces to Base64', () => {\n        expect(convertToBase64(\"Test String with Spaces\")).toBe(\"VGVzdCBTdHJpbmcgd2l0aCBTcGFjZXM=\");\n    });\n\n    test('Convert string with special characters to Base64', () => {\n        expect(convertToBase64(\"Special characters: @#&*()\")).toBe(\"U3BlY2lhbCBjaGFyYWN0ZXJzOiBAIyYqKCk=\");\n    });\n\n    test('Convert string with non-ASCII characters to Base64', () => {\n        expect(convertToBase64(\"\u4f60\u597d\uff0c\u4e16\u754c\uff01\")).toBe(\"5L2g5aW977yM5LiW55WM77yB\");\n    });\n\n    test('Convert long string to Base64', () => {\n        const longString: string = \"This is a very long string that exceeds normal lengths for testing purposes.\";\n        expect(convertToBase64(longString)).toBe(\"VGhpcyBpcyBhIHZlcnkgbG9uZyBzdHJpbmcgdGhhdCBleGNlZWRzIG5vcm1hbCBsZW5ndGhzIGZvciB0ZXN0aW5nIHB1cnBvc2VzLg==\");\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a string to Base64 encoding.\n *\n * @param {string} input - The string to be converted to Base64.\n * @returns {string} The Base64 encoded string.\n */\nfunction convertToBase64(input: string): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 450, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Check whether the password string meets format requirements: contains at least one number.\nContain at least one lowercase letter.\nContain at least one uppercase letter.\nThe value contains at least 8 characters. Contains at least one punctuation mark", "language_version_list": {"python": {"code_signature": "def is_valid_password(password: str) -> bool:\n    \"\"\"\n    Checks whether the provided password meets the specified format requirements:\n    - At least one number\n    - At least one lowercase letter\n    - At least one uppercase letter\n    - At least one punctuation mark\n    - Minimum length of 8 characters\n\n    Args:\n        password (str): The password string to validate.\n\n    Returns:\n        bool: Returns True if the password meets all requirements; otherwise, False.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestPasswordValidator(unittest.TestCase):\n\n    def test_valid_password(self):\n        self.assertTrue(is_valid_password(\"Password1!\"))\n\n    def test_password_without_number(self):\n        self.assertFalse(is_valid_password(\"Password!\"))\n\n    def test_password_without_uppercase(self):\n        self.assertFalse(is_valid_password(\"password1!\"))\n\n    def test_password_without_lowercase(self):\n        self.assertFalse(is_valid_password(\"PASSWORD1!\"))\n\n    def test_password_without_punctuation(self):\n        self.assertFalse(is_valid_password(\"Password1\"))\n\n    def test_password_shorter_than_8_characters(self):\n        self.assertFalse(is_valid_password(\"Pass1!\"))\n", "prompt": "please write a python function , the function signature as below def is_valid_password(password: str) -> bool:\n    \"\"\"\n    Checks whether the provided password meets the specified format requirements:\n    - At least one number\n    - At least one lowercase letter\n    - At least one uppercase letter\n    - At least one punctuation mark\n    - Minimum length of 8 characters\n\n    Args:\n        password (str): The password string to validate.\n\n    Returns:\n        bool: Returns True if the password meets all requirements; otherwise, False.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Checks whether the provided password meets the specified format requirements:\n * - At least one number\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one punctuation mark\n * - Minimum length of 8 characters\n *\n * @param {string} password - The password string to validate\n * @returns {boolean} Returns true if the password meets all requirements; otherwise, false.\n */\nfunction isValidPassword(password) {\n}", "test_code": "describe('Password Validator Tests', () => {\n    test('Valid password', () => {\n        expect(isValidPassword(\"Password1!\")).toBe(true);\n    });\n\n    test('Password without a number', () => {\n        expect(isValidPassword(\"Password!\")).toBe(false);\n    });\n\n    test('Password without an uppercase letter', () => {\n        expect(isValidPassword(\"password1!\")).toBe(false);\n    });\n\n    test('Password without a lowercase letter', () => {\n        expect(isValidPassword(\"PASSWORD1!\")).toBe(false);\n    });\n\n    test('Password without a punctuation mark', () => {\n        expect(isValidPassword(\"Password1\")).toBe(false);\n    });\n\n    test('Password shorter than 8 characters', () => {\n        expect(isValidPassword(\"Pass1!\")).toBe(false);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Checks whether the provided password meets the specified format requirements:\n * - At least one number\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one punctuation mark\n * - Minimum length of 8 characters\n *\n * @param {string} password - The password string to validate\n * @returns {boolean} Returns true if the password meets all requirements; otherwise, false.\n */\nfunction isValidPassword(password) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Checks whether the provided password meets the specified format requirements:\n * - At least one number\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one punctuation mark\n * - Minimum length of 8 characters\n *\n * @param {string} password - The password string to validate\n * @returns {boolean} Returns true if the password meets all requirements; otherwise, false.\n */\nfunction isValidPassword(password: string): boolean {\n}", "test_code": "describe('Password Validator Tests', () => {\n    test('Valid password', () => {\n        expect(isValidPassword(\"Password1!\")).toBe(true);\n    });\n\n    test('Password without a number', () => {\n        expect(isValidPassword(\"Password!\")).toBe(false);\n    });\n\n    test('Password without an uppercase letter', () => {\n        expect(isValidPassword(\"password1!\")).toBe(false);\n    });\n\n    test('Password without a lowercase letter', () => {\n        expect(isValidPassword(\"PASSWORD1!\")).toBe(false);\n    });\n\n    test('Password without a punctuation mark', () => {\n        expect(isValidPassword(\"Password1\")).toBe(false);\n    });\n\n    test('Password shorter than 8 characters', () => {\n        expect(isValidPassword(\"Pass1!\")).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Checks whether the provided password meets the specified format requirements:\n * - At least one number\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one punctuation mark\n * - Minimum length of 8 characters\n *\n * @param {string} password - The password string to validate\n * @returns {boolean} Returns true if the password meets all requirements; otherwise, false.\n */\nfunction isValidPassword(password: string): boolean {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Checks whether the provided password meets the specified format requirements:\n * - At least one number\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one punctuation mark\n * - Minimum length of 8 characters\n *\n * @param password - The password string to validate\n * @returns true if the password meets all requirements; otherwise, false.\n */\nbool isValidPassword(const std::string& password) {}", "test_code": "TEST_CASE(\"Password Validator Tests\") {\n    SECTION(\"Valid password\") {\n        REQUIRE(isValidPassword(\"Password1!\") == true);\n    }\n\n    SECTION(\"Password without a number\") {\n        REQUIRE(isValidPassword(\"Password!\") == false);\n    }\n\n    SECTION(\"Password without an uppercase letter\") {\n        REQUIRE(isValidPassword(\"password1!\") == false);\n    }\n\n    SECTION(\"Password without a lowercase letter\") {\n        REQUIRE(isValidPassword(\"PASSWORD1!\") == false);\n    }\n\n    SECTION(\"Password without a punctuation mark\") {\n        REQUIRE(isValidPassword(\"Password1\") == false);\n    }\n\n    SECTION(\"Password shorter than 8 characters\") {\n        REQUIRE(isValidPassword(\"Pass1!\") == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Checks whether the provided password meets the specified format requirements:\n * - At least one number\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one punctuation mark\n * - Minimum length of 8 characters\n *\n * @param password - The password string to validate\n * @returns true if the password meets all requirements; otherwise, false.\n */\nbool isValidPassword(const std::string& password) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks whether the provided password meets the specified format requirements:\n * - At least one number\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one punctuation mark\n * - Minimum length of 8 characters\n *\n * @param password - The password string to validate\n * @return Returns true if the password meets all requirements; otherwise, false.\n */\npublic static boolean isValidPassword(String password) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testValidPassword() {\n        assertTrue(isValidPassword(\"Password1!\"));\n    }\n\n    @Test\n    public void testPasswordWithoutNumber() {\n        assertFalse(isValidPassword(\"Password!\"));\n    }\n\n    @Test\n    public void testPasswordWithoutUppercase() {\n        assertFalse(isValidPassword(\"password1!\"));\n    }\n\n    @Test\n    public void testPasswordWithoutLowercase() {\n        assertFalse(isValidPassword(\"PASSWORD1!\"));\n    }\n\n    @Test\n    public void testPasswordWithoutPunctuation() {\n        assertFalse(isValidPassword(\"Password1\"));\n    }\n\n    @Test\n    public void testPasswordShorterThan8Characters() {\n        assertFalse(isValidPassword(\"Pass1!\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks whether the provided password meets the specified format requirements:\n * - At least one number\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one punctuation mark\n * - Minimum length of 8 characters\n *\n * @param password - The password string to validate\n * @return Returns true if the password meets all requirements; otherwise, false.\n */\npublic static boolean isValidPassword(String password) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 528, "code_type": "method", "original_language": "javascript", "question_type": "File operations and I/O operation", "summary": "Searches for Markdown files in the specified directory and returns the path of the files as an array\n", "language_version_list": {"python": {"code_signature": "def find_markdown_files(dir_path: str) -> list:\n    \"\"\"\n    Searches for Markdown files in the specified directory and returns the paths of the files as a list.\n\n    Args:\n        dir_path (str): The directory path to search in.\n\n    Returns:\n        list: A list of paths to Markdown files.\n    \"\"\"", "test_code": "import unittest\nfrom unittest.mock import patch\n\n\nclass TestFindMarkdownFiles(unittest.TestCase):\n\n    @patch('os.listdir')\n    @patch('os.path.isdir')\n    def test_empty_directory(self, mock_isdir, mock_listdir):\n        mock_listdir.return_value = []\n        mock_isdir.return_value = False\n\n        result = find_markdown_files('emptyDir')\n        self.assertEqual(result, [])\n\n    @patch('os.listdir')\n    @patch('os.path.isdir')\n    def test_one_markdown_file(self, mock_isdir, mock_listdir):\n        mock_listdir.return_value = ['file1.md']\n        mock_isdir.return_value = False\n\n        result = find_markdown_files('dir')\n        self.assertEqual(result, ['dir/file1.md'])\n\n    @patch('os.listdir')\n    @patch('os.path.isdir')\n    def test_multiple_markdown_files(self, mock_isdir, mock_listdir):\n        mock_listdir.return_value = ['file1.md', 'file2.md']\n        mock_isdir.return_value = False\n\n        result = find_markdown_files('dir')\n        self.assertEqual(result, ['dir/file1.md', 'dir/file2.md'])\n\n    @patch('os.listdir')\n    @patch('os.path.isdir')\n    def test_ignore_non_markdown_files(self, mock_isdir, mock_listdir):\n        mock_listdir.return_value = ['file1.txt', 'file2.md', 'file3.doc']\n        mock_isdir.return_value = False\n\n        result = find_markdown_files('dir')\n        self.assertEqual(result, ['dir/file2.md'])\n\n    @patch('os.listdir')\n    @patch('os.path.isdir')\n    def test_only_non_markdown_files(self, mock_isdir, mock_listdir):\n        mock_listdir.return_value = ['file1.txt', 'file2.doc']\n        mock_isdir.return_value = False\n\n        result = find_markdown_files('dir')\n        self.assertEqual(result, [])\n", "prompt": "please write a python function , the function signature as below def find_markdown_files(dir_path: str) -> list:\n    \"\"\"\n    Searches for Markdown files in the specified directory and returns the paths of the files as a list.\n\n    Args:\n        dir_path (str): The directory path to search in.\n\n    Returns:\n        list: A list of paths to Markdown files.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "const fs = require('fs');\nconst path = require('path');\n\n/**\n * Searches for Markdown files in the specified directory and returns the path of the files as an array\n *\n * @param {string} dir - The directory path to search in.\n * @returns {string[]} - An array of paths to Markdown files.\n */\nfunction findMarkdownFiles(dir) {\n}", "test_code": "const fs = require('fs');\nconst path = require('path');\n\njest.mock('fs');\n\ndescribe('findMarkdownFiles', () => {\n    beforeEach(() => {\n        jest.clearAllMocks();\n    });\n\n    test('should return an empty array for an empty directory', () => {\n        fs.readdirSync.mockReturnValue([]);\n        fs.statSync.mockImplementation(() => ({isDirectory: () => false}));\n\n        const result = findMarkdownFiles('emptyDir');\n        expect(result).toEqual([]);\n    });\n\n    test('should return an array with one Markdown file', () => {\n        fs.readdirSync.mockReturnValue(['file1.md']);\n        fs.statSync.mockImplementation(file => ({\n            isDirectory: () => false,\n        }));\n\n        const result = findMarkdownFiles('dir');\n        expect(result).toEqual(['dir\\\\file1.md']);\n    });\n\n    test('should return an array with multiple Markdown files in the same directory', () => {\n        fs.readdirSync.mockReturnValue(['file1.md', 'file2.md']);\n        fs.statSync.mockImplementation(file => ({\n            isDirectory: () => false,\n        }));\n\n        const result = findMarkdownFiles('dir');\n        expect(result).toEqual(['dir\\\\file1.md', 'dir\\\\file2.md']);\n    });\n\n\n    test('should return Markdown files while ignoring non-Markdown files', () => {\n        fs.readdirSync.mockReturnValue(['file1.txt', 'file2.md', 'file3.doc']);\n        fs.statSync.mockImplementation(file => ({\n            isDirectory: () => false,\n        }));\n\n        const result = findMarkdownFiles('dir');\n        expect(result).toEqual(['dir\\\\file2.md']);\n    });\n\n\n    test('should handle a directory with only non-Markdown files', () => {\n        fs.readdirSync.mockReturnValue(['file1.txt', 'file2.doc']);\n        fs.statSync.mockImplementation(file => ({\n            isDirectory: () => false,\n        }));\n\n        const result = findMarkdownFiles('dir');\n        expect(result).toEqual([]);\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below const fs = require('fs');\nconst path = require('path');\n\n/**\n * Searches for Markdown files in the specified directory and returns the path of the files as an array\n *\n * @param {string} dir - The directory path to search in.\n * @returns {string[]} - An array of paths to Markdown files.\n */\nfunction findMarkdownFiles(dir) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Searches for Markdown files in the specified directory and returns the path of the files as an array\n *\n * @param {string} dir - The directory path to search in.\n * @returns {string[]} - An array of paths to Markdown files.\n */\nfunction findMarkdownFiles(dir: string): string[] {}", "test_code": "import * as fs from 'fs';\n\njest.mock('fs');\n\ndescribe('findMarkdownFiles', () => {\n    beforeEach(() => {\n        jest.clearAllMocks();\n    });\n\n    test('should return an empty array for an empty directory', () => {\n        (fs.readdirSync as jest.Mock).mockReturnValue([]);\n        (fs.statSync as jest.Mock).mockImplementation(() => ({ isDirectory: () => false }));\n\n        const result = findMarkdownFiles('emptyDir');\n        expect(result).toEqual([]);\n    });\n\n    test('should return an array with one Markdown file', () => {\n        (fs.readdirSync as jest.Mock).mockReturnValue(['file1.md']);\n        (fs.statSync as jest.Mock).mockImplementation(() => ({ isDirectory: () => false }));\n\n        const result = findMarkdownFiles('dir');\n        expect(result).toEqual(['dir\\\\file1.md']);\n    });\n\n    test('should return an array with multiple Markdown files in the same directory', () => {\n        (fs.readdirSync as jest.Mock).mockReturnValue(['file1.md', 'file2.md']);\n        (fs.statSync as jest.Mock).mockImplementation(() => ({ isDirectory: () => false }));\n\n        const result = findMarkdownFiles('dir');\n        expect(result).toEqual(['dir\\\\file1.md', 'dir\\\\file2.md']);\n    });\n\n    test('should return Markdown files while ignoring non-Markdown files', () => {\n        (fs.readdirSync as jest.Mock).mockReturnValue(['file1.txt', 'file2.md', 'file3.doc']);\n        (fs.statSync as jest.Mock).mockImplementation(() => ({ isDirectory: () => false }));\n\n        const result = findMarkdownFiles('dir');\n        expect(result).toEqual(['dir\\\\file2.md']);\n    });\n\n    test('should handle a directory with only non-Markdown files', () => {\n        (fs.readdirSync as jest.Mock).mockReturnValue(['file1.txt', 'file2.doc']);\n        (fs.statSync as jest.Mock).mockImplementation(() => ({ isDirectory: () => false }));\n\n        const result = findMarkdownFiles('dir');\n        expect(result).toEqual([]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Searches for Markdown files in the specified directory and returns the path of the files as an array\n *\n * @param {string} dir - The directory path to search in.\n * @returns {string[]} - An array of paths to Markdown files.\n */\nfunction findMarkdownFiles(dir: string): string[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Searches for Markdown files in the specified directory and returns the path of the files as a vector.\n *\n * @param dir - The directory path to search in.\n * @returns A vector of paths to Markdown files.\n */\nstd::vector<std::string> findMarkdownFiles(const fs::path& dir) {}", "test_code": "namespace fs {\n    std::vector<std::string> readdirSync(const std::string& dir) {\n        // Placeholder for mocking\n        return {};\n    }\n\n    bool isDirectory(const std::string& path) {\n        // Placeholder for mocking\n        return false;\n    }\n\n    void mockReaddirSync(const std::vector<std::string>& files) {\n        readdirSync = [files](const std::string&) { return files; };\n    }\n\n    void mockStatSync(const std::function<bool(const std::string&)>& statFunc) {\n        isDirectory = [statFunc](const std::string& path) { return statFunc(path); };\n    }\n}\n\n\nTEST_CASE(\"findMarkdownFiles tests\", \"[findMarkdownFiles]\") {\n    // Test for an empty directory\n    SECTION(\"should return an empty array for an empty directory\") {\n        fs::mockReaddirSync({});\n        fs::mockStatSync([](const std::string&) { return false; });\n\n        auto result = findMarkdownFiles(\"emptyDir\");\n        REQUIRE(result == std::vector<std::string>{});\n    }\n\n    // Test for one Markdown file\n    SECTION(\"should return an array with one Markdown file\") {\n        fs::mockReaddirSync({\"file1.md\"});\n        fs::mockStatSync([](const std::string&) { return false; });\n\n        auto result = findMarkdownFiles(\"dir\");\n        REQUIRE(result == std::vector<std::string>{\"file1.md\"});\n    }\n\n    // Test for multiple Markdown files in the same directory\n    SECTION(\"should return an array with multiple Markdown files in the same directory\") {\n        fs::mockReaddirSync({\"file1.md\", \"file2.md\"});\n        fs::mockStatSync([](const std::string&) { return false; });\n\n        auto result = findMarkdownFiles(\"dir\");\n        REQUIRE(result == std::vector<std::string>{\"file1.md\", \"file2.md\"});\n    }\n\n    // Test for ignoring non-Markdown files\n    SECTION(\"should return Markdown files while ignoring non-Markdown files\") {\n        fs::mockReaddirSync({\"file1.txt\", \"file2.md\", \"file3.doc\"});\n        fs::mockStatSync([](const std::string&) { return false; });\n\n        auto result = findMarkdownFiles(\"dir\");\n        REQUIRE(result == std::vector<std::string>{\"file2.md\"});\n    }\n\n    // Test for a directory with only non-Markdown files\n    SECTION(\"should handle a directory with only non-Markdown files\") {\n        fs::mockReaddirSync({\"file1.txt\", \"file2.doc\"});\n        fs::mockStatSync([](const std::string&) { return false; });\n\n        auto result = findMarkdownFiles(\"dir\");\n        REQUIRE(result == std::vector<std::string>{});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Searches for Markdown files in the specified directory and returns the path of the files as a vector.\n *\n * @param dir - The directory path to search in.\n * @returns A vector of paths to Markdown files.\n */\nstd::vector<std::string> findMarkdownFiles(const fs::path& dir) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Searches for Markdown files in the specified directory and returns the path of the files as a list.\n *\n * @param dir - The directory path to search in.\n * @return - A list of paths to Markdown files.\n */\npublic static List<String> findMarkdownFiles(String dir) {}", "test_code": "package org.real.temp;\n\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Mockito;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Tester {\n\n    @Before\n    public void setUp() {\n        // Clear all mocks before each test\n        Mockito.reset();\n    }\n\n    @Test\n    public void shouldReturnEmptyListForEmptyDirectory() {\n        File mockDir = mock(File.class);\n        when(mockDir.listFiles()).thenReturn(new File[0]);\n\n        List<String> result = MarkdownFinder.findMarkdownFiles(mockDir.getAbsolutePath());\n        assertEquals(Collections.emptyList(), result);\n    }\n\n    @Test\n    public void shouldReturnListWithOneMarkdownFile() {\n        File mockDir = mock(File.class);\n        File mockFile = mock(File.class);\n        when(mockDir.listFiles()).thenReturn(new File[]{mockFile});\n        when(mockFile.getName()).thenReturn(\"file1.md\");\n        when(mockFile.isDirectory()).thenReturn(false);\n\n        List<String> result = MarkdownFinder.findMarkdownFiles(mockDir.getAbsolutePath());\n        assertEquals(Arrays.asList(\"dir\\\\file1.md\"), result);\n    }\n\n    @Test\n    public void shouldReturnListWithMultipleMarkdownFilesInSameDirectory() {\n        File mockDir = mock(File.class);\n        File mockFile1 = mock(File.class);\n        File mockFile2 = mock(File.class);\n        when(mockDir.listFiles()).thenReturn(new File[]{mockFile1, mockFile2});\n        when(mockFile1.getName()).thenReturn(\"file1.md\");\n        when(mockFile2.getName()).thenReturn(\"file2.md\");\n        when(mockFile1.isDirectory()).thenReturn(false);\n        when(mockFile2.isDirectory()).thenReturn(false);\n\n        List<String> result = MarkdownFinder.findMarkdownFiles(mockDir.getAbsolutePath());\n        assertEquals(Arrays.asList(\"dir\\\\file1.md\", \"dir\\\\file2.md\"), result);\n    }\n\n    @Test\n    public void shouldReturnMarkdownFilesIgnoringNonMarkdownFiles() {\n        File mockDir = mock(File.class);\n        File mockFile1 = mock(File.class);\n        File mockFile2 = mock(File.class);\n        File mockFile3 = mock(File.class);\n        when(mockDir.listFiles()).thenReturn(new File[]{mockFile1, mockFile2, mockFile3});\n        when(mockFile1.getName()).thenReturn(\"file1.txt\");\n        when(mockFile2.getName()).thenReturn(\"file2.md\");\n        when(mockFile3.getName()).thenReturn(\"file3.doc\");\n        when(mockFile1.isDirectory()).thenReturn(false);\n        when(mockFile2.isDirectory()).thenReturn(false);\n        when(mockFile3.isDirectory()).thenReturn(false);\n\n        List<String> result = MarkdownFinder.findMarkdownFiles(mockDir.getAbsolutePath());\n        assertEquals(Arrays.asList(\"dir\\\\file2.md\"), result);\n    }\n\n    @Test\n    public void shouldHandleDirectoryWithOnlyNonMarkdownFiles() {\n        File mockDir = mock(File.class);\n        File mockFile1 = mock(File.class);\n        File mockFile2 = mock(File.class);\n        when(mockDir.listFiles()).thenReturn(new File[]{mockFile1, mockFile2});\n        when(mockFile1.getName()).thenReturn(\"file1.txt\");\n        when(mockFile2.getName()).thenReturn(\"file2.doc\");\n        when(mockFile1.isDirectory()).thenReturn(false);\n        when(mockFile2.isDirectory()).thenReturn(false);\n\n        List<String> result = MarkdownFinder.findMarkdownFiles(mockDir.getAbsolutePath());\n        assertEquals(Collections.emptyList(), result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Searches for Markdown files in the specified directory and returns the path of the files as a list.\n *\n * @param dir - The directory path to search in.\n * @return - A list of paths to Markdown files.\n */\npublic static List<String> findMarkdownFiles(String dir) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 529, "code_type": "method", "original_language": "javascript", "question_type": "File operations and I/O operation", "summary": "Converts the  data object to JSON format and saves it to the specified file path\n", "language_version_list": {"python": {"code_signature": "def save_as_json(data: dict, output_file_path: str) -> None:\n    \"\"\"\n    Converts the data object to JSON format and saves it to the specified file path.\n\n    Args:\n        data (dict): The data object to be converted to JSON.\n        output_file_path (str): The file path where the JSON will be saved.\n    \"\"\"", "test_code": "import json\nimport os\nimport unittest\nfrom io import StringIO\n\n\nclass TestSaveAsJSON(unittest.TestCase):\n    mock_file_path = 'test.json'\n\n    def setUp(self):\n        # Redirect console output\n        self.console_output = StringIO()\n        self.original_stdout = redirect_stdout(self.console_output)\n        self.original_stdout.__enter__()\n\n    def tearDown(self):\n        # Clean up after each test\n        if os.path.exists(self.mock_file_path):\n            os.remove(self.mock_file_path)  # Remove test file if it exists\n\n        self.original_stdout.__exit__(None, None, None)\n\n    def test_save_valid_object_to_json_file(self):\n        data = {\"name\": \"Alice\", \"age\": 25}\n        save_as_json(data, self.mock_file_path)\n        with open(self.mock_file_path, 'r', encoding='utf-8') as json_file:\n            saved_data = json_file.read()\n        self.assertEqual(saved_data, json.dumps(data, indent=2))\n\n    def test_handle_empty_object(self):\n        data = {}\n        save_as_json(data, self.mock_file_path)\n        with open(self.mock_file_path, 'r', encoding='utf-8') as json_file:\n            saved_data = json_file.read()\n        self.assertEqual(saved_data, json.dumps(data, indent=2))\n\n    def test_save_nested_object_to_json_file(self):\n        data = {\"user\": {\"name\": \"Bob\", \"age\": 30}, \"active\": True}\n        save_as_json(data, self.mock_file_path)\n        with open(self.mock_file_path, 'r', encoding='utf-8') as json_file:\n            saved_data = json_file.read()\n        self.assertEqual(saved_data, json.dumps(data, indent=2))\n\n    def test_save_array_of_objects_to_json_file(self):\n        data = [\n            {\"product\": {\"id\": 1, \"name\": \"Laptop\", \"price\": 999.99}, \"inStock\": True},\n            {\"product\": {\"id\": 2, \"name\": \"Phone\", \"price\": 499.99}, \"inStock\": False}\n        ]\n        save_as_json(data, self.mock_file_path)\n        with open(self.mock_file_path, 'r', encoding='utf-8') as json_file:\n            saved_data = json_file.read()\n        self.assertEqual(saved_data, json.dumps(data, indent=2))\n\n    def test_save_object_with_mixed_data_types_to_json_file(self):\n        data = {\n            \"title\": \"Shopping List\",\n            \"items\": [\"Milk\", \"Eggs\", \"Bread\"],\n            \"total\": 3.50,\n            \"completed\": False\n        }\n        save_as_json(data, self.mock_file_path)\n        with open(self.mock_file_path, 'r', encoding='utf-8') as json_file:\n            saved_data = json_file.read()\n        self.assertEqual(saved_data, json.dumps(data, indent=2))\n\n    def test_save_deeply_nested_object_to_json_file(self):\n        data = {\n            \"company\": {\n                \"name\": \"TechCorp\",\n                \"employees\": [\n                    {\n                        \"id\": 1,\n                        \"name\": \"Alice\",\n                        \"role\": \"Developer\",\n                        \"contact\": {\"email\": \"alice@techcorp.com\", \"phone\": \"123-456-7890\"}\n                    },\n                    {\n                        \"id\": 2,\n                        \"name\": \"Bob\",\n                        \"role\": \"Designer\",\n                        \"contact\": {\"email\": \"bob@techcorp.com\", \"phone\": \"098-765-4321\"}\n                    }\n                ]\n            },\n            \"established\": 2010\n        }\n        save_as_json(data, self.mock_file_path)\n        with open(self.mock_file_path, 'r', encoding='utf-8') as json_file:\n            saved_data = json_file.read()\n        self.assertEqual(saved_data, json.dumps(data, indent=2))\n", "prompt": "please write a python function , the function signature as below def save_as_json(data: dict, output_file_path: str) -> None:\n    \"\"\"\n    Converts the data object to JSON format and saves it to the specified file path.\n\n    Args:\n        data (dict): The data object to be converted to JSON.\n        output_file_path (str): The file path where the JSON will be saved.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "const fs = require('fs');\n\n/**\n * Converts the data object to JSON format and saves it to the specified file path.\n * @param {Object} data - The data object to be converted to JSON.\n * @param {string} outputFilePath - The file path where the JSON will be saved.\n */\nfunction saveAsJSON(data, outputFilePath) {\n}", "test_code": "describe('saveAsJSON', () => {\n    const mockFilePath = 'test.json';\n    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();\n    const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();\n\n    afterEach(() => {\n        // Clean up after each test\n        jest.clearAllMocks();\n        if (fs.existsSync(mockFilePath)) {\n            fs.unlinkSync(mockFilePath); // Remove test file if it exists\n        }\n    });\n\n    test('should save valid object to JSON file', () => {\n        const data = {name: \"Alice\", age: 25};\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should handle empty object', () => {\n        const data = {};\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should save nested object to JSON file', () => {\n        const data = {user: {name: \"Bob\", age: 30}, active: true};\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should save array of objects to JSON file', () => {\n        const data = [\n            {product: {id: 1, name: \"Laptop\", price: 999.99}, inStock: true},\n            {product: {id: 2, name: \"Phone\", price: 499.99}, inStock: false}\n        ];\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should save object with mixed data types to JSON file', () => {\n        const data = {title: \"Shopping List\", items: [\"Milk\", \"Eggs\", \"Bread\"], total: 3.50, completed: false};\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should save deeply nested object to JSON file', () => {\n        const data = {\n            company: {\n                name: \"TechCorp\",\n                employees: [\n                    {\n                        id: 1,\n                        name: \"Alice\",\n                        role: \"Developer\",\n                        contact: {email: \"alice@techcorp.com\", phone: \"123-456-7890\"}\n                    },\n                    {id: 2, name: \"Bob\", role: \"Designer\", contact: {email: \"bob@techcorp.com\", phone: \"098-765-4321\"}}\n                ]\n            },\n            established: 2010\n        };\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below const fs = require('fs');\n\n/**\n * Converts the data object to JSON format and saves it to the specified file path.\n * @param {Object} data - The data object to be converted to JSON.\n * @param {string} outputFilePath - The file path where the JSON will be saved.\n */\nfunction saveAsJSON(data, outputFilePath) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts the data object to JSON format and saves it to the specified file path.\n * @param {Object} data - The data object to be converted to JSON.\n * @param {string} outputFilePath - The file path where the JSON will be saved.\n */\nfunction saveAsJSON(data: object, outputFilePath: string): void {}", "test_code": "describe('saveAsJSON', () => {\n    const mockFilePath = 'test.json';\n    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();\n    const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();\n\n    afterEach(() => {\n        // Clean up after each test\n        jest.clearAllMocks();\n        if (fs.existsSync(mockFilePath)) {\n            fs.unlinkSync(mockFilePath); // Remove test file if it exists\n        }\n    });\n\n    test('should save valid object to JSON file', () => {\n        const data = { name: \"Alice\", age: 25 };\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should handle empty object', () => {\n        const data = {};\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should save nested object to JSON file', () => {\n        const data = { user: { name: \"Bob\", age: 30 }, active: true };\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should save array of objects to JSON file', () => {\n        const data = [\n            { product: { id: 1, name: \"Laptop\", price: 999.99 }, inStock: true },\n            { product: { id: 2, name: \"Phone\", price: 499.99 }, inStock: false }\n        ];\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should save object with mixed data types to JSON file', () => {\n        const data = { title: \"Shopping List\", items: [\"Milk\", \"Eggs\", \"Bread\"], total: 3.50, completed: false };\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should save deeply nested object to JSON file', () => {\n        const data = {\n            company: {\n                name: \"TechCorp\",\n                employees: [\n                    {\n                        id: 1,\n                        name: \"Alice\",\n                        role: \"Developer\",\n                        contact: { email: \"alice@techcorp.com\", phone: \"123-456-7890\" }\n                    },\n                    { id: 2, name: \"Bob\", role: \"Designer\", contact: { email: \"bob@techcorp.com\", phone: \"098-765-4321\" } }\n                ]\n            },\n            established: 2010\n        };\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts the data object to JSON format and saves it to the specified file path.\n * @param {Object} data - The data object to be converted to JSON.\n * @param {string} outputFilePath - The file path where the JSON will be saved.\n */\nfunction saveAsJSON(data: object, outputFilePath: string): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts the data object to JSON format and saves it to the specified file path.\n * @param data - The data object to be converted to JSON.\n * @param outputFilePath - The file path where the JSON will be saved.\n */\nvoid saveAsJSON(const nlohmann::json& data, const std::string& outputFilePath) {}", "test_code": "TEST_CASE(\"saveAsJSON\", \"[json]\") {\n    const std::string mockFilePath = \"test.json\";\n\n    // Clean up after each test\n    auto cleanup = [&]() {\n        if (std::filesystem::exists(mockFilePath)) {\n            std::filesystem::remove(mockFilePath);\n        }\n    };\n\n    // Run cleanup after each test case\n    SECTION(\"Cleanup\") { cleanup(); }\n\n    SECTION(\"should save valid object to JSON file\") {\n        nlohmann::json data = {{\"name\", \"Alice\"}, {\"age\", 25}};\n        saveAsJSON(data, mockFilePath);\n        std::ifstream savedFile(mockFilePath);\n        std::string savedData((std::istreambuf_iterator<char>(savedFile)), std::istreambuf_iterator<char>());\n        REQUIRE(savedData == data.dump(2));\n        cleanup();\n    }\n\n    SECTION(\"should handle empty object\") {\n        nlohmann::json data = {};\n        saveAsJSON(data, mockFilePath);\n        std::ifstream savedFile(mockFilePath);\n        std::string savedData((std::istreambuf_iterator<char>(savedFile)), std::istreambuf_iterator<char>());\n        REQUIRE(savedData == data.dump(2));\n        cleanup();\n    }\n\n    SECTION(\"should save nested object to JSON file\") {\n        nlohmann::json data = {{\"user\", {{\"name\", \"Bob\"}, {\"age\", 30}}}, {\"active\", true}};\n        saveAsJSON(data, mockFilePath);\n        std::ifstream savedFile(mockFilePath);\n        std::string savedData((std::istreambuf_iterator<char>(savedFile)), std::istreambuf_iterator<char>());\n        REQUIRE(savedData == data.dump(2));\n        cleanup();\n    }\n\n    SECTION(\"should save array of objects to JSON file\") {\n        nlohmann::json data = {\n            {{\"product\", {{\"id\", 1}, {\"name\", \"Laptop\"}, {\"price\", 999.99}}}, {\"inStock\", true}},\n            {{\"product\", {{\"id\", 2}, {\"name\", \"Phone\"}, {\"price\", 499.99}}}, {\"inStock\", false}}\n        };\n        saveAsJSON(data, mockFilePath);\n        std::ifstream savedFile(mockFilePath);\n        std::string savedData((std::istreambuf_iterator<char>(savedFile)), std::istreambuf_iterator<char>());\n        REQUIRE(savedData == data.dump(2));\n        cleanup();\n    }\n\n    SECTION(\"should save object with mixed data types to JSON file\") {\n        nlohmann::json data = {{\"title\", \"Shopping List\"}, {\"items\", {\"Milk\", \"Eggs\", \"Bread\"}}, {\"total\", 3.50}, {\"completed\", false}};\n        saveAsJSON(data, mockFilePath);\n        std::ifstream savedFile(mockFilePath);\n        std::string savedData((std::istreambuf_iterator<char>(savedFile)), std::istreambuf_iterator<char>());\n        REQUIRE(savedData == data.dump(2));\n        cleanup();\n    }\n\n    SECTION(\"should save deeply nested object to JSON file\") {\n        nlohmann::json data = {\n            {\"company\", {\n                {\"name\", \"TechCorp\"},\n                {\"employees\", {\n                    {{\"id\", 1}, {\"name\", \"Alice\"}, {\"role\", \"Developer\"}, {\"contact\", {{\"email\", \"alice@techcorp.com\"}, {\"phone\", \"123-456-7890\"}}}},\n                    {{\"id\", 2}, {\"name\", \"Bob\"}, {\"role\", \"Designer\"}, {\"contact\", {{\"email\", \"bob@techcorp.com\"}, {\"phone\", \"098-765-4321\"}}}}\n                }}\n            }},\n            {\"established\", 2010}\n        };\n        saveAsJSON(data, mockFilePath);\n        std::ifstream savedFile(mockFilePath);\n        std::string savedData((std::istreambuf_iterator<char>(savedFile)), std::istreambuf_iterator<char>());\n        REQUIRE(savedData == data.dump(2));\n        cleanup();\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts the data object to JSON format and saves it to the specified file path.\n * @param data - The data object to be converted to JSON.\n * @param outputFilePath - The file path where the JSON will be saved.\n */\nvoid saveAsJSON(const nlohmann::json& data, const std::string& outputFilePath) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts the data object to JSON format and saves it to the specified file path.\n * @param data - The data object to be converted to JSON.\n * @param outputFilePath - The file path where the JSON will be saved.\n */\npublic static void saveAsJSON(Object data, String outputFilePath) {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class Tester {\n\n    private final String mockFilePath = \"test.json\";\n\n    @After\n    public void tearDown() throws Exception {\n        // Clean up after each test\n        File file = new File(mockFilePath);\n        if (file.exists()) {\n            file.delete(); // Remove test file if it exists\n        }\n    }\n\n    @Test\n    public void shouldSaveValidObjectToJSONFile() throws Exception {\n        Object data = new Object() {\n            String name = \"Alice\";\n            int age = 25;\n        };\n        saveAsJSON(data, mockFilePath);\n        String savedData = new String(Files.readAllBytes(Paths.get(mockFilePath)));\n        assertEquals(new Gson().toJson(data, null, 2), savedData);\n    }\n\n    @Test\n    public void shouldHandleEmptyObject() throws Exception {\n        Object data = new Object() {};\n        saveAsJSON(data, mockFilePath);\n        String savedData = new String(Files.readAllBytes(Paths.get(mockFilePath)));\n        assertEquals(new Gson().toJson(data, null, 2), savedData);\n    }\n\n    @Test\n    public void shouldSaveNestedObjectToJSONFile() throws Exception {\n        Object data = new Object() {\n            Object user = new Object() {\n                String name = \"Bob\";\n                int age = 30;\n            };\n            boolean active = true;\n        };\n        saveAsJSON(data, mockFilePath);\n        String savedData = new String(Files.readAllBytes(Paths.get(mockFilePath)));\n        assertEquals(new Gson().toJson(data, null, 2), savedData);\n    }\n\n    @Test\n    public void shouldSaveArrayOfObjectsToJSONFile() throws Exception {\n        Object data = new Object[] {\n            new Object() {\n                Object product = new Object() {\n                    int id = 1;\n                    String name = \"Laptop\";\n                    double price = 999.99;\n                };\n                boolean inStock = true;\n            },\n            new Object() {\n                Object product = new Object() {\n                    int id = 2;\n                    String name = \"Phone\";\n                    double price = 499.99;\n                };\n                boolean inStock = false;\n            }\n        };\n        saveAsJSON(data, mockFilePath);\n        String savedData = new String(Files.readAllBytes(Paths.get(mockFilePath)));\n        assertEquals(new Gson().toJson(data, null, 2), savedData);\n    }\n\n    @Test\n    public void shouldSaveObjectWithMixedDataTypesToJSONFile() throws Exception {\n        Object data = new Object() {\n            String title = \"Shopping List\";\n            String[] items = {\"Milk\", \"Eggs\", \"Bread\"};\n            double total = 3.50;\n            boolean completed = false;\n        };\n        saveAsJSON(data, mockFilePath);\n        String savedData = new String(Files.readAllBytes(Paths.get(mockFilePath)));\n        assertEquals(new Gson().toJson(data, null, 2), savedData);\n    }\n\n    @Test\n    public void shouldSaveDeeplyNestedObjectToJSONFile() throws Exception {\n        Object data = new Object() {\n            Object company = new Object() {\n                String name = \"TechCorp\";\n                Object[] employees = new Object[] {\n                    new Object() {\n                        int id = 1;\n                        String name = \"Alice\";\n                        String role = \"Developer\";\n                        Object contact = new Object() {\n                            String email = \"alice@techcorp.com\";\n                            String phone = \"123-456-7890\";\n                        };\n                    },\n                    new Object() {\n                        int id = 2;\n                        String name = \"Bob\";\n                        String role = \"Designer\";\n                        Object contact = new Object() {\n                            String email = \"bob@techcorp.com\";\n                            String phone = \"098-765-4321\";\n                        };\n                    }\n                };\n            };\n            int established = 2010;\n        };\n        saveAsJSON(data, mockFilePath);\n        String savedData = new String(Files.readAllBytes(Paths.get(mockFilePath)));\n        assertEquals(new Gson().toJson(data, null, 2), savedData);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts the data object to JSON format and saves it to the specified file path.\n * @param data - The data object to be converted to JSON.\n * @param outputFilePath - The file path where the JSON will be saved.\n */\npublic static void saveAsJSON(Object data, String outputFilePath) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 530, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Creates a matrix with the specified number of rows and columns,\nfilled with the given initial value.", "language_version_list": {"python": {"code_signature": "def create_matrix(rows: int, columns: int, initial_value: any) -> list:\n    \"\"\"Creates a matrix with the specified number of rows and columns,\n    filled with the given initial value.\n\n    Args:\n        rows (int): The number of rows in the matrix.\n        columns (int): The number of columns in the matrix.\n        initial_value (any): The value to fill the matrix with.\n                             It can be of any type (number, string, object, etc.).\n\n    Returns:\n        list: A two-dimensional list (matrix) filled with the initial value.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCreateMatrix(unittest.TestCase):\n\n    def test_create_2x2_matrix_filled_with_zeros(self):\n        result = create_matrix(2, 2, 0)\n        self.assertEqual(result, [[0, 0], [0, 0]])\n\n    def test_create_3x3_matrix_filled_with_ones(self):\n        result = create_matrix(3, 3, 1)\n        self.assertEqual(result, [[1, 1, 1], [1, 1, 1], [1, 1, 1]])\n\n    def test_create_4x5_matrix_filled_with_string(self):\n        result = create_matrix(4, 5, 'test')\n        self.assertEqual(result, [['test'] * 5 for _ in range(4)])\n\n    def test_create_0x0_matrix(self):\n        result = create_matrix(0, 0, None)\n        self.assertEqual(result, [])\n\n    def test_create_1x1_matrix_with_boolean(self):\n        result = create_matrix(1, 1, True)\n        self.assertEqual(result, [[True]])\n\n    def test_create_5x5_matrix_filled_with_negative_numbers(self):\n        result = create_matrix(5, 5, -1)\n        self.assertEqual(result, [[-1] * 5 for _ in range(5)])\n", "prompt": "please write a python function , the function signature as below def create_matrix(rows: int, columns: int, initial_value: any) -> list:\n    \"\"\"Creates a matrix with the specified number of rows and columns,\n    filled with the given initial value.\n\n    Args:\n        rows (int): The number of rows in the matrix.\n        columns (int): The number of columns in the matrix.\n        initial_value (any): The value to fill the matrix with.\n                             It can be of any type (number, string, object, etc.).\n\n    Returns:\n        list: A two-dimensional list (matrix) filled with the initial value.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Creates a matrix with the specified number of rows and columns,\n * filled with the given initial value.\n *\n * @param {number} rows - The number of rows in the matrix.\n * @param {number} columns - The number of columns in the matrix.\n * @param {*} initialValue - The value to fill the matrix with.\n *                          It can be of any type (number, string, object, etc.).\n * @returns {Array} A two-dimensional array (matrix) filled with the initial value.\n */\nfunction createMatrix(rows, columns, initialValue) {\n}", "test_code": "describe('createMatrix', () => {\n    test('should create a 2x2 matrix filled with zeros', () => {\n        const result = createMatrix(2, 2, 0);\n        expect(result).toEqual([[0, 0], [0, 0]]);\n    });\n\n    test('should create a 3x3 matrix filled with ones', () => {\n        const result = createMatrix(3, 3, 1);\n        expect(result).toEqual([[1, 1, 1], [1, 1, 1], [1, 1, 1]]);\n    });\n\n    test('should create a 4x5 matrix filled with a string', () => {\n        const result = createMatrix(4, 5, 'test');\n        expect(result).toEqual([\n            ['test', 'test', 'test', 'test', 'test'],\n            ['test', 'test', 'test', 'test', 'test'],\n            ['test', 'test', 'test', 'test', 'test'],\n            ['test', 'test', 'test', 'test', 'test'],\n        ]);\n    });\n\n    test('should create a 0x0 matrix', () => {\n        const result = createMatrix(0, 0, null);\n        expect(result).toEqual([]);\n    });\n\n    test('should create a 1x1 matrix with a boolean', () => {\n        const result = createMatrix(1, 1, true);\n        expect(result).toEqual([[true]]);\n    });\n    test('should create a 5x5 matrix filled with negative numbers', () => {\n        const result = createMatrix(5, 5, -1);\n        expect(result).toEqual([\n            [-1, -1, -1, -1, -1],\n            [-1, -1, -1, -1, -1],\n            [-1, -1, -1, -1, -1],\n            [-1, -1, -1, -1, -1],\n            [-1, -1, -1, -1, -1],\n        ]);\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Creates a matrix with the specified number of rows and columns,\n * filled with the given initial value.\n *\n * @param {number} rows - The number of rows in the matrix.\n * @param {number} columns - The number of columns in the matrix.\n * @param {*} initialValue - The value to fill the matrix with.\n *                          It can be of any type (number, string, object, etc.).\n * @returns {Array} A two-dimensional array (matrix) filled with the initial value.\n */\nfunction createMatrix(rows, columns, initialValue) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Creates a matrix with the specified number of rows and columns,\n * filled with the given initial value.\n *\n * @param {number} rows - The number of rows in the matrix.\n * @param {number} columns - The number of columns in the matrix.\n * @param {*} initialValue - The value to fill the matrix with.\n *                          It can be of any type (number, string, object, etc.).\n * @returns {Array} A two-dimensional array (matrix) filled with the initial value.\n */\nfunction createMatrix(rows: number, columns: number, initialValue: any): any[][] {}", "test_code": "describe('createMatrix', () => {\n    test('should create a 2x2 matrix filled with zeros', () => {\n        const result = createMatrix(2, 2, 0);\n        expect(result).toEqual([[0, 0], [0, 0]]);\n    });\n\n    test('should create a 3x3 matrix filled with ones', () => {\n        const result = createMatrix(3, 3, 1);\n        expect(result).toEqual([[1, 1, 1], [1, 1, 1], [1, 1, 1]]);\n    });\n\n    test('should create a 4x5 matrix filled with a string', () => {\n        const result = createMatrix(4, 5, 'test');\n        expect(result).toEqual([\n            ['test', 'test', 'test', 'test', 'test'],\n            ['test', 'test', 'test', 'test', 'test'],\n            ['test', 'test', 'test', 'test', 'test'],\n            ['test', 'test', 'test', 'test', 'test'],\n        ]);\n    });\n\n    test('should create a 0x0 matrix', () => {\n        const result = createMatrix(0, 0, null);\n        expect(result).toEqual([]);\n    });\n\n    test('should create a 1x1 matrix with a boolean', () => {\n        const result = createMatrix(1, 1, true);\n        expect(result).toEqual([[true]]);\n    });\n\n    test('should create a 5x5 matrix filled with negative numbers', () => {\n        const result = createMatrix(5, 5, -1);\n        expect(result).toEqual([\n            [-1, -1, -1, -1, -1],\n            [-1, -1, -1, -1, -1],\n            [-1, -1, -1, -1, -1],\n            [-1, -1, -1, -1, -1],\n            [-1, -1, -1, -1, -1],\n        ]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Creates a matrix with the specified number of rows and columns,\n * filled with the given initial value.\n *\n * @param {number} rows - The number of rows in the matrix.\n * @param {number} columns - The number of columns in the matrix.\n * @param {*} initialValue - The value to fill the matrix with.\n *                          It can be of any type (number, string, object, etc.).\n * @returns {Array} A two-dimensional array (matrix) filled with the initial value.\n */\nfunction createMatrix(rows: number, columns: number, initialValue: any): any[][] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Creates a matrix with the specified number of rows and columns,\n * filled with the given initial value.\n *\n * @param int rows - The number of rows in the matrix.\n * @param int columns - The number of columns in the matrix.\n * @param int initialValue - The value to fill the matrix with.\n *                          It can be of any type (int, std::string, etc.).\n * @returns std::vector<std::vector<int>> A two-dimensional vector (matrix) filled with the initial value.\n */\nstd::vector<std::vector<int>> createMatrix(int rows, int columns, int initialValue) {}", "test_code": "TEST_CASE(\"createMatrix\", \"[matrix]\") {\n    SECTION(\"should create a 2x2 matrix filled with zeros\") {\n        auto result = createMatrix(2, 2, 0);\n        REQUIRE(result == std::vector<std::vector<int>>{{0, 0}, {0, 0}});\n    }\n\n    SECTION(\"should create a 3x3 matrix filled with ones\") {\n        auto result = createMatrix(3, 3, 1);\n        REQUIRE(result == std::vector<std::vector<int>>{{1, 1, 1}, {1, 1, 1}, {1, 1, 1}});\n    }\n\n    SECTION(\"should create a 4x5 matrix filled with a string\") {\n        auto result = createMatrix(4, 5, std::string(\"test\"));\n        REQUIRE(result == std::vector<std::vector<std::string>>{\n            {\"test\", \"test\", \"test\", \"test\", \"test\"},\n            {\"test\", \"test\", \"test\", \"test\", \"test\"},\n            {\"test\", \"test\", \"test\", \"test\", \"test\"},\n            {\"test\", \"test\", \"test\", \"test\", \"test\"},\n        });\n    }\n\n    SECTION(\"should create a 0x0 matrix\") {\n        auto result = createMatrix(0, 0, 0);\n        REQUIRE(result == std::vector<std::vector<int>>{});\n    }\n\n    SECTION(\"should create a 1x1 matrix with a boolean\") {\n        auto result = createMatrix(1, 1, true);\n        REQUIRE(result == std::vector<std::vector<bool>>{{true}});\n    }\n\n    SECTION(\"should create a 5x5 matrix filled with negative numbers\") {\n        auto result = createMatrix(5, 5, -1);\n        REQUIRE(result == std::vector<std::vector<int>>{\n            {-1, -1, -1, -1, -1},\n            {-1, -1, -1, -1, -1},\n            {-1, -1, -1, -1, -1},\n            {-1, -1, -1, -1, -1},\n            {-1, -1, -1, -1, -1},\n        });\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Creates a matrix with the specified number of rows and columns,\n * filled with the given initial value.\n *\n * @param int rows - The number of rows in the matrix.\n * @param int columns - The number of columns in the matrix.\n * @param int initialValue - The value to fill the matrix with.\n *                          It can be of any type (int, std::string, etc.).\n * @returns std::vector<std::vector<int>> A two-dimensional vector (matrix) filled with the initial value.\n */\nstd::vector<std::vector<int>> createMatrix(int rows, int columns, int initialValue) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Creates a matrix with the specified number of rows and columns,\n * filled with the given initial value.\n *\n * @param rows - The number of rows in the matrix.\n * @param columns - The number of columns in the matrix.\n * @param initialValue - The value to fill the matrix with.\n *                      It can be of any type (number, string, object, etc.).\n * @returns A two-dimensional array (matrix) filled with the initial value.\n */\npublic static Object[][] createMatrix(int rows, int columns, Object initialValue) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\n\npublic class Tester {\n\n    @Test\n    public void testCreate2x2MatrixFilledWithZeros() {\n        Object[][] result = MatrixCreator.createMatrix(2, 2, 0);\n        assertArrayEquals(new Object[][]{{0, 0}, {0, 0}}, result);\n    }\n\n    @Test\n    public void testCreate3x3MatrixFilledWithOnes() {\n        Object[][] result = MatrixCreator.createMatrix(3, 3, 1);\n        assertArrayEquals(new Object[][]{{1, 1, 1}, {1, 1, 1}, {1, 1, 1}}, result);\n    }\n\n    @Test\n    public void testCreate4x5MatrixFilledWithString() {\n        Object[][] result = MatrixCreator.createMatrix(4, 5, \"test\");\n        assertArrayEquals(new Object[][]{\n            {\"test\", \"test\", \"test\", \"test\", \"test\"},\n            {\"test\", \"test\", \"test\", \"test\", \"test\"},\n            {\"test\", \"test\", \"test\", \"test\", \"test\"},\n            {\"test\", \"test\", \"test\", \"test\", \"test\"},\n        }, result);\n    }\n\n    @Test\n    public void testCreate0x0Matrix() {\n        Object[][] result = MatrixCreator.createMatrix(0, 0, null);\n        assertArrayEquals(new Object[0][0], result);\n    }\n\n    @Test\n    public void testCreate1x1MatrixWithBoolean() {\n        Object[][] result = MatrixCreator.createMatrix(1, 1, true);\n        assertArrayEquals(new Object[][]{{true}}, result);\n    }\n\n    @Test\n    public void testCreate5x5MatrixFilledWithNegativeNumbers() {\n        Object[][] result = MatrixCreator.createMatrix(5, 5, -1);\n        assertArrayEquals(new Object[][]{\n            {-1, -1, -1, -1, -1},\n            {-1, -1, -1, -1, -1},\n            {-1, -1, -1, -1, -1},\n            {-1, -1, -1, -1, -1},\n            {-1, -1, -1, -1, -1},\n        }, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Creates a matrix with the specified number of rows and columns,\n * filled with the given initial value.\n *\n * @param rows - The number of rows in the matrix.\n * @param columns - The number of columns in the matrix.\n * @param initialValue - The value to fill the matrix with.\n *                      It can be of any type (number, string, object, etc.).\n * @returns A two-dimensional array (matrix) filled with the initial value.\n */\npublic static Object[][] createMatrix(int rows, int columns, Object initialValue) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 532, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Counts the occurrences of consecutive identical letters in a given string.", "language_version_list": {"python": {"code_signature": "def count_letter_changes(input_string: str) -> list:\n    \"\"\"Counts the occurrences of consecutive identical letters in a given string.\n\n    Args:\n        input_string (str): The string to analyze for letter changes.\n\n    Returns:\n        list: A list of counts representing the number of consecutive\n              identical letters before a different letter is found.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCountLetterChanges(unittest.TestCase):\n\n    def test_count_consecutive_letters_correctly(self):\n        result = count_letter_changes(\"aaabbcdeee\")\n        self.assertEqual(result, [3, 2, 1, 1, 3])\n\n    def test_single_character_count(self):\n        result = count_letter_changes(\"a\")\n        self.assertEqual(result, [1])\n\n    def test_no_consecutive_letters(self):\n        result = count_letter_changes(\"abcdef\")\n        self.assertEqual(result, [1, 1, 1, 1, 1, 1])\n\n    def test_identical_letters(self):\n        result = count_letter_changes(\"rrrrrr\")\n        self.assertEqual(result, [6])\n\n    def test_long_string_random_letters(self):\n        result = count_letter_changes(\"xxxyyyzzzaaaab\")\n        self.assertEqual(result, [3, 3, 3, 4, 1])\n\n    def test_numeric_characters(self):\n        result = count_letter_changes(\"1122334455\")\n        self.assertEqual(result, [2, 2, 2, 2, 2])\n", "prompt": "please write a python function , the function signature as below def count_letter_changes(input_string: str) -> list:\n    \"\"\"Counts the occurrences of consecutive identical letters in a given string.\n\n    Args:\n        input_string (str): The string to analyze for letter changes.\n\n    Returns:\n        list: A list of counts representing the number of consecutive\n              identical letters before a different letter is found.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Counts the occurrences of consecutive identical letters in a given string.\n *\n * @param {string} inputString - The string to analyze for letter changes.\n * @returns {Array<number>} An array of counts representing the number of consecutive\n *                          identical letters before a different letter is found.\n */\nfunction countLetterChanges(inputString) {\n}", "test_code": "describe('countLetterChanges', () => {\n    test('should count consecutive letters correctly', () => {\n        const result = countLetterChanges(\"aaabbcdeee\");\n        expect(result).toEqual([3, 2, 1, 1, 3]);\n    });\n\n    test('should return an array with one count for a single character', () => {\n        const result = countLetterChanges(\"a\");\n        expect(result).toEqual([1]);\n    });\n\n    test('should return counts for a string with no consecutive letters', () => {\n        const result = countLetterChanges(\"abcdef\");\n        expect(result).toEqual([1, 1, 1, 1, 1, 1]);\n    });\n\n    test('should handle a string with only identical letters', () => {\n        const result = countLetterChanges(\"rrrrrr\");\n        expect(result).toEqual([6]);\n    });\n\n    test('should handle a long string with random letters', () => {\n        const result = countLetterChanges(\"xxxyyyzzzaaaab\");\n        expect(result).toEqual([3, 3, 3, 4, 1]);\n    });\n\n    test('should handle numeric characters in the string', () => {\n        const result = countLetterChanges(\"1122334455\");\n        expect(result).toEqual([2, 2, 2, 2, 2]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Counts the occurrences of consecutive identical letters in a given string.\n *\n * @param {string} inputString - The string to analyze for letter changes.\n * @returns {Array<number>} An array of counts representing the number of consecutive\n *                          identical letters before a different letter is found.\n */\nfunction countLetterChanges(inputString) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Counts the occurrences of consecutive identical letters in a given string.\n *\n * @param {string} inputString - The string to analyze for letter changes.\n * @returns {Array<number>} An array of counts representing the number of consecutive\n *                          identical letters before a different letter is found.\n */\nfunction countLetterChanges(inputString: string): number[] {\n}", "test_code": "describe('countLetterChanges', () => {\n    test('should count consecutive letters correctly', () => {\n        const result: number[] = countLetterChanges(\"aaabbcdeee\");\n        expect(result).toEqual([3, 2, 1, 1, 3]);\n    });\n\n    test('should return an array with one count for a single character', () => {\n        const result: number[] = countLetterChanges(\"a\");\n        expect(result).toEqual([1]);\n    });\n\n    test('should return counts for a string with no consecutive letters', () => {\n        const result: number[] = countLetterChanges(\"abcdef\");\n        expect(result).toEqual([1, 1, 1, 1, 1, 1]);\n    });\n\n    test('should handle a string with only identical letters', () => {\n        const result: number[] = countLetterChanges(\"rrrrrr\");\n        expect(result).toEqual([6]);\n    });\n\n    test('should handle a long string with random letters', () => {\n        const result: number[] = countLetterChanges(\"xxxyyyzzzaaaab\");\n        expect(result).toEqual([3, 3, 3, 4, 1]);\n    });\n\n    test('should handle numeric characters in the string', () => {\n        const result: number[] = countLetterChanges(\"1122334455\");\n        expect(result).toEqual([2, 2, 2, 2, 2]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Counts the occurrences of consecutive identical letters in a given string.\n *\n * @param {string} inputString - The string to analyze for letter changes.\n * @returns {Array<number>} An array of counts representing the number of consecutive\n *                          identical letters before a different letter is found.\n */\nfunction countLetterChanges(inputString: string): number[] {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Counts the occurrences of consecutive identical letters in a given string.\n *\n * @param inputString - The string to analyze for letter changes.\n * @returns A vector of counts representing the number of consecutive\n *          identical letters before a different letter is found.\n */\nstd::vector<int> countLetterChanges(const std::string& inputString) {}", "test_code": "TEST_CASE(\"countLetterChanges\", \"[countLetterChanges]\") {\n    SECTION(\"should count consecutive letters correctly\") {\n        auto result = countLetterChanges(\"aaabbcdeee\");\n        REQUIRE(result == std::vector<int>{3, 2, 1, 1, 3});\n    }\n\n    SECTION(\"should return an array with one count for a single character\") {\n        auto result = countLetterChanges(\"a\");\n        REQUIRE(result == std::vector<int>{1});\n    }\n\n    SECTION(\"should return counts for a string with no consecutive letters\") {\n        auto result = countLetterChanges(\"abcdef\");\n        REQUIRE(result == std::vector<int>{1, 1, 1, 1, 1, 1});\n    }\n\n    SECTION(\"should handle a string with only identical letters\") {\n        auto result = countLetterChanges(\"rrrrrr\");\n        REQUIRE(result == std::vector<int>{6});\n    }\n\n    SECTION(\"should handle a long string with random letters\") {\n        auto result = countLetterChanges(\"xxxyyyzzzaaaab\");\n        REQUIRE(result == std::vector<int>{3, 3, 3, 4, 1});\n    }\n\n    SECTION(\"should handle numeric characters in the string\") {\n        auto result = countLetterChanges(\"1122334455\");\n        REQUIRE(result == std::vector<int>{2, 2, 2, 2, 2});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Counts the occurrences of consecutive identical letters in a given string.\n *\n * @param inputString - The string to analyze for letter changes.\n * @returns A vector of counts representing the number of consecutive\n *          identical letters before a different letter is found.\n */\nstd::vector<int> countLetterChanges(const std::string& inputString) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Counts the occurrences of consecutive identical letters in a given string.\n *\n * @param inputString The string to analyze for letter changes.\n * @returns A list of counts representing the number of consecutive\n *          identical letters before a different letter is found.\n */\npublic static List<Integer> countLetterChanges(String inputString) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testCountConsecutiveLettersCorrectly() {\n        List<Integer> result = countLetterChanges(\"aaabbcdeee\");\n        assertEquals(Arrays.asList(3, 2, 1, 1, 3), result);\n    }\n\n    @Test\n    public void testSingleCharacter() {\n        List<Integer> result = countLetterChanges(\"a\");\n        assertEquals(Arrays.asList(1), result);\n    }\n\n    @Test\n    public void testNoConsecutiveLetters() {\n        List<Integer> result = countLetterChanges(\"abcdef\");\n        assertEquals(Arrays.asList(1, 1, 1, 1, 1, 1), result);\n    }\n\n    @Test\n    public void testIdenticalLetters() {\n        List<Integer> result = countLetterChanges(\"rrrrrr\");\n        assertEquals(Arrays.asList(6), result);\n    }\n\n    @Test\n    public void testLongStringWithRandomLetters() {\n        List<Integer> result = countLetterChanges(\"xxxyyyzzzaaaab\");\n        assertEquals(Arrays.asList(3, 3, 3, 4, 1), result);\n    }\n\n    @Test\n    public void testNumericCharactersInString() {\n        List<Integer> result = countLetterChanges(\"1122334455\");\n        assertEquals(Arrays.asList(2, 2, 2, 2, 2), result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Counts the occurrences of consecutive identical letters in a given string.\n *\n * @param inputString The string to analyze for letter changes.\n * @returns A list of counts representing the number of consecutive\n *          identical letters before a different letter is found.\n */\npublic static List<Integer> countLetterChanges(String inputString) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 533, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Shuffles the characters in a given string randomly.", "language_version_list": {"python": {"code_signature": "def shuffle_string(input_string: str) -> str:\n    \"\"\"Shuffles the characters in a given string randomly.\n\n    Args:\n        input_string (str): The string to shuffle.\n\n    Returns:\n        str: A new string with the characters shuffled.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestShuffleString(unittest.TestCase):\n\n    def test_same_length(self):\n        input_string = \"abcdef\"\n        result = shuffle_string(input_string)\n        self.assertEqual(len(result), len(input_string))\n\n    def test_shuffle_characters(self):\n        input_string = \"hello\"\n        result = shuffle_string(input_string)\n        self.assertNotEqual(result, input_string)  # It should be different most of the time\n\n    def test_empty_string(self):\n        input_string = \"\"\n        result = shuffle_string(input_string)\n        self.assertEqual(result, \"\")  # Should return an empty string\n\n    def test_single_character(self):\n        input_string = \"a\"\n        result = shuffle_string(input_string)\n        self.assertEqual(result, \"a\")  # Should return the same single character\n\n    def test_identical_characters(self):\n        input_string = \"aaaaa\"\n        result = shuffle_string(input_string)\n        self.assertEqual(result, \"aaaaa\")  # Should return the same string\n\n    def test_long_string(self):\n        input_string = \"abcdefghijklmnopqrstuvwxyz\"\n        result = shuffle_string(input_string)\n        self.assertNotEqual(result, input_string)  # It should be different most of the time\n        self.assertEqual(len(result), len(input_string))  # Length should be the same\n\n    def test_same_string_characters(self):\n        input_string = \"111111\"\n        result = shuffle_string(input_string)\n        self.assertEqual(result, \"111111\")  # Should return the same string\n\n    def test_special_characters(self):\n        input_string = \"a!@#$%^&*()_+\"\n        result = shuffle_string(input_string)\n        self.assertEqual(len(result), len(input_string))  # Length should be the same\n        self.assertNotEqual(result, input_string)  # It should be different most of the time\n", "prompt": "please write a python function , the function signature as below def shuffle_string(input_string: str) -> str:\n    \"\"\"Shuffles the characters in a given string randomly.\n\n    Args:\n        input_string (str): The string to shuffle.\n\n    Returns:\n        str: A new string with the characters shuffled.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Shuffles the characters in a given string randomly.\n *\n * @param {string} inputString - The string to shuffle.\n * @returns {string} A new string with the characters shuffled.\n */\nfunction shuffleString(inputString) {\n}", "test_code": "describe('shuffleString', () => {\n    test('should return a string of the same length as the input', () => {\n        const input = \"abcdef\";\n        const result = shuffleString(input);\n        expect(result.length).toBe(input.length);\n    });\n\n    test('should shuffle the characters in the string', () => {\n        const input = \"hello\";\n        const result = shuffleString(input);\n        expect(result).not.toBe(input); // It should be different most of the time\n    });\n\n    test('should return an empty string when given an empty string', () => {\n        const input = \"\";\n        const result = shuffleString(input);\n        expect(result).toBe(\"\"); // Should return an empty string\n    });\n\n    test('should handle a single character string', () => {\n        const input = \"a\";\n        const result = shuffleString(input);\n        expect(result).toBe(\"a\"); // Should return the same single character\n    });\n\n    test('should handle strings with identical characters', () => {\n        const input = \"aaaaa\";\n        const result = shuffleString(input);\n        expect(result).toBe(\"aaaaa\"); // Should return the same string\n    });\n\n    test('should return a shuffled string for longer strings', () => {\n        const input = \"abcdefghijklmnopqrstuvwxyz\";\n        const result = shuffleString(input);\n        expect(result).not.toBe(input); // It should be different most of the time\n        expect(result.length).toBe(input.length); // Length should be the same\n    });\n\n    test('should return the same string if all characters are the same', () => {\n        const input = \"111111\";\n        const result = shuffleString(input);\n        expect(result).toBe(\"111111\"); // Should return the same string\n    });\n\n    test('should shuffle a string containing special characters', () => {\n        const input = \"a!@#$%^&*()_+\";\n        const result = shuffleString(input);\n        expect(result.length).toBe(input.length); // Length should be the same\n        expect(result).not.toBe(input); // It should be different most of the time\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Shuffles the characters in a given string randomly.\n *\n * @param {string} inputString - The string to shuffle.\n * @returns {string} A new string with the characters shuffled.\n */\nfunction shuffleString(inputString) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Shuffles the characters in a given string randomly.\n *\n * @param {string} inputString - The string to shuffle.\n * @returns {string} A new string with the characters shuffled.\n */\nfunction shuffleString(inputString: string): string {\n}", "test_code": "describe('shuffleString', () => {\n    test('should return a string of the same length as the input', () => {\n        const input: string = \"abcdef\";\n        const result: string = shuffleString(input);\n        expect(result.length).toBe(input.length);\n    });\n\n    test('should shuffle the characters in the string', () => {\n        const input: string = \"hello\";\n        const result: string = shuffleString(input);\n        expect(result).not.toBe(input); // It should be different most of the time\n    });\n\n    test('should return an empty string when given an empty string', () => {\n        const input: string = \"\";\n        const result: string = shuffleString(input);\n        expect(result).toBe(\"\"); // Should return an empty string\n    });\n\n    test('should handle a single character string', () => {\n        const input: string = \"a\";\n        const result: string = shuffleString(input);\n        expect(result).toBe(\"a\"); // Should return the same single character\n    });\n\n    test('should handle strings with identical characters', () => {\n        const input: string = \"aaaaa\";\n        const result: string = shuffleString(input);\n        expect(result).toBe(\"aaaaa\"); // Should return the same string\n    });\n\n    test('should return a shuffled string for longer strings', () => {\n        const input: string = \"abcdefghijklmnopqrstuvwxyz\";\n        const result: string = shuffleString(input);\n        expect(result).not.toBe(input); // It should be different most of the time\n        expect(result.length).toBe(input.length); // Length should be the same\n    });\n\n    test('should return the same string if all characters are the same', () => {\n        const input: string = \"111111\";\n        const result: string = shuffleString(input);\n        expect(result).toBe(\"111111\"); // Should return the same string\n    });\n\n    test('should shuffle a string containing special characters', () => {\n        const input: string = \"a!@#$%^&*()_+\";\n        const result: string = shuffleString(input);\n        expect(result.length).toBe(input.length); // Length should be the same\n        expect(result).not.toBe(input); // It should be different most of the time\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Shuffles the characters in a given string randomly.\n *\n * @param {string} inputString - The string to shuffle.\n * @returns {string} A new string with the characters shuffled.\n */\nfunction shuffleString(inputString: string): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Shuffles the characters in a given string randomly.\n *\n * @param inputString The string to shuffle.\n * @returns A new string with the characters shuffled.\n */\nstd::string shuffleString(const std::string& inputString) {}", "test_code": "TEST_CASE(\"shuffleString\") {\n    SECTION(\"should return a string of the same length as the input\") {\n        std::string input = \"abcdef\";\n        std::string result = shuffleString(input);\n        REQUIRE(result.length() == input.length());\n    }\n\n    SECTION(\"should shuffle the characters in the string\") {\n        std::string input = \"hello\";\n        std::string result = shuffleString(input);\n        REQUIRE(result != input); // It should be different most of the time\n    }\n\n    SECTION(\"should return an empty string when given an empty string\") {\n        std::string input = \"\";\n        std::string result = shuffleString(input);\n        REQUIRE(result == \"\"); // Should return an empty string\n    }\n\n    SECTION(\"should handle a single character string\") {\n        std::string input = \"a\";\n        std::string result = shuffleString(input);\n        REQUIRE(result == \"a\"); // Should return the same single character\n    }\n\n    SECTION(\"should handle strings with identical characters\") {\n        std::string input = \"aaaaa\";\n        std::string result = shuffleString(input);\n        REQUIRE(result == \"aaaaa\"); // Should return the same string\n    }\n\n    SECTION(\"should return a shuffled string for longer strings\") {\n        std::string input = \"abcdefghijklmnopqrstuvwxyz\";\n        std::string result = shuffleString(input);\n        REQUIRE(result != input); // It should be different most of the time\n        REQUIRE(result.length() == input.length()); // Length should be the same\n    }\n\n    SECTION(\"should return the same string if all characters are the same\") {\n        std::string input = \"111111\";\n        std::string result = shuffleString(input);\n        REQUIRE(result == \"111111\"); // Should return the same string\n    }\n\n    SECTION(\"should shuffle a string containing special characters\") {\n        std::string input = \"a!@#$%^&*()_+\";\n        std::string result = shuffleString(input);\n        REQUIRE(result.length() == input.length()); // Length should be the same\n        REQUIRE(result != input); // It should be different most of the time\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Shuffles the characters in a given string randomly.\n *\n * @param inputString The string to shuffle.\n * @returns A new string with the characters shuffled.\n */\nstd::string shuffleString(const std::string& inputString) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Shuffles the characters in a given string randomly.\n *\n * @param inputString The string to shuffle.\n * @return A new string with the characters shuffled.\n */\npublic static String shuffleString(String inputString) {}\n", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testShuffleStringLength() {\n        String input = \"abcdef\";\n        String result = shuffleString(input);\n        assertEquals(input.length(), result.length());\n    }\n\n    @Test\n    public void testShuffleStringCharacters() {\n        String input = \"hello\";\n        String result = shuffleString(input);\n        assertNotEquals(input, result); // It should be different most of the time\n    }\n\n    @Test\n    public void testShuffleStringEmpty() {\n        String input = \"\";\n        String result = shuffleString(input);\n        assertEquals(\"\", result); // Should return an empty string\n    }\n\n    @Test\n    public void testShuffleStringSingleCharacter() {\n        String input = \"a\";\n        String result = shuffleString(input);\n        assertEquals(\"a\", result); // Should return the same single character\n    }\n\n    @Test\n    public void testShuffleStringIdenticalCharacters() {\n        String input = \"aaaaa\";\n        String result = shuffleString(input);\n        assertEquals(\"aaaaa\", result); // Should return the same string\n    }\n\n    @Test\n    public void testShuffleStringLongerString() {\n        String input = \"abcdefghijklmnopqrstuvwxyz\";\n        String result = shuffleString(input);\n        assertNotEquals(input, result); // It should be different most of the time\n        assertEquals(input.length(), result.length()); // Length should be the same\n    }\n\n    @Test\n    public void testShuffleStringSameCharacters() {\n        String input = \"111111\";\n        String result = shuffleString(input);\n        assertEquals(\"111111\", result); // Should return the same string\n    }\n\n    @Test\n    public void testShuffleStringSpecialCharacters() {\n        String input = \"a!@#$%^&*()_+\";\n        String result = shuffleString(input);\n        assertEquals(input.length(), result.length()); // Length should be the same\n        assertNotEquals(input, result); // It should be different most of the time\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Shuffles the characters in a given string randomly.\n *\n * @param inputString The string to shuffle.\n * @return A new string with the characters shuffled.\n */\npublic static String shuffleString(String inputString) {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 534, "code_type": "method", "original_language": "javascript", "question_type": "Algorithm and data structure", "summary": "Removes the first occurrence of a specified element from an array.", "language_version_list": {"python": {"code_signature": "def remove_element_in_array(array:list, element)->list:\n    \"\"\"\n    Removes the first occurrence of a specified element from a list.\n\n    Args:\n        array (list): The list from which to remove the element.\n        element: The element to remove from the list.\n\n    Returns:\n        list: A new list with the element removed, or the original list if the element is not found.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestRemoveElementInArray(unittest.TestCase):\n\n    def test_returns_original_array_when_element_not_found(self):\n        result = remove_element_in_array([1, 2, 3, 4], 5)\n        self.assertEqual(result, [1, 2, 3, 4])\n\n    def test_handles_empty_array_correctly(self):\n        result = remove_element_in_array([], 1)\n        self.assertEqual(result, [])\n\n    def test_removes_element_from_array_of_objects(self):\n        obj1 = {'id': 1}\n        obj2 = {'id': 2}\n        obj3 = {'id': 3}\n        result = remove_element_in_array([obj1, obj2, obj3], obj2)\n        self.assertEqual(result, [obj1, obj3])\n\n    def test_does_not_modify_original_array(self):\n        original_array = [1, 2, 3]\n        result = remove_element_in_array(original_array, 2)\n        self.assertEqual(original_array, [1, 2, 3])\n        self.assertEqual(result, [1, 3])\n", "prompt": "please write a python function , the function signature as below def remove_element_in_array(array:list, element)->list:\n    \"\"\"\n    Removes the first occurrence of a specified element from a list.\n\n    Args:\n        array (list): The list from which to remove the element.\n        element: The element to remove from the list.\n\n    Returns:\n        list: A new list with the element removed, or the original list if the element is not found.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Removes the first occurrence of a specified element from an array.\n *\n * @param {Array} array - The array from which to remove the element.\n * @param {*} element - The element to remove from the array.\n * @returns {Array} A new array with the element removed, or the original array if the element is not found.\n */\nfunction removeElementInArray(array, element) {\n\n}", "test_code": "describe('removeElementInArray', () => {\n    test('returns the original array when the element is not found', () => {\n        const result = removeElementInArray([1, 2, 3, 4], 5);\n        expect(result).toEqual([1, 2, 3, 4]);\n    });\n\n\n    test('handles an empty array correctly', () => {\n        const result = removeElementInArray([], 1);\n        expect(result).toEqual([]);\n    });\n\n    test('removes an element from an array of objects', () => {\n        const obj1 = {id: 1};\n        const obj2 = {id: 2};\n        const obj3 = {id: 3};\n        const result = removeElementInArray([obj1, obj2, obj3], obj2);\n        expect(result).toEqual([obj1, obj3]);\n    });\n\n    test('does not modify the original array', () => {\n        const originalArray = [1, 2, 3];\n        const result = removeElementInArray(originalArray, 2);\n        expect(originalArray).toEqual([1, 2, 3]);\n        expect(result).toEqual([1, 3]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Removes the first occurrence of a specified element from an array.\n *\n * @param {Array} array - The array from which to remove the element.\n * @param {*} element - The element to remove from the array.\n * @returns {Array} A new array with the element removed, or the original array if the element is not found.\n */\nfunction removeElementInArray(array, element) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Removes the first occurrence of a specified element from an array.\n *\n * @param {Array<T>} array - The array from which to remove the element.\n * @param {T} element - The element to remove from the array.\n * @returns {Array<T>} A new array with the element removed, or the original array if the element is not found.\n */\nfunction removeElementInArray<T>(array: Array<T>, element: T): Array<T> {\n\n}", "test_code": "describe('removeElementInArray', () => {\n    test('returns the original array when the element is not found', () => {\n        const result = removeElementInArray([1, 2, 3, 4], 5);\n        expect(result).toEqual([1, 2, 3, 4]);\n    });\n\n    test('handles an empty array correctly', () => {\n        const result = removeElementInArray([], 1);\n        expect(result).toEqual([]);\n    });\n\n    test('removes an element from an array of objects', () => {\n        const obj1 = { id: 1 };\n        const obj2 = { id: 2 };\n        const obj3 = { id: 3 };\n        const result = removeElementInArray([obj1, obj2, obj3], obj2);\n        expect(result).toEqual([obj1, obj3]);\n    });\n\n    test('does not modify the original array', () => {\n        const originalArray = [1, 2, 3];\n        const result = removeElementInArray(originalArray, 2);\n        expect(originalArray).toEqual([1, 2, 3]);\n        expect(result).toEqual([1, 3]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Removes the first occurrence of a specified element from an array.\n *\n * @param {Array<T>} array - The array from which to remove the element.\n * @param {T} element - The element to remove from the array.\n * @returns {Array<T>} A new array with the element removed, or the original array if the element is not found.\n */\nfunction removeElementInArray<T>(array: Array<T>, element: T): Array<T> {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Removes the first occurrence of a specified element from a vector.\n *\n * @param {std::vector<int>} array - The vector from which to remove the element.\n * @param {int} element - The element to remove from the vector.\n * @returns {std::vector<int>} A new vector with the element removed, or the original vector if the element is not found.\n */\nstd::vector<int> removeElementInArray(const std::vector<int>& array, int element) {\n    \n}", "test_code": "TEST_CASE(\"removeElementInArray\", \"[removeElementInArray]\") {\n    SECTION(\"returns the original array when the element is not found\") {\n        std::vector<int> result = removeElementInArray({1, 2, 3, 4}, 5);\n        REQUIRE(result == std::vector<int>({1, 2, 3, 4}));\n    }\n\n    SECTION(\"handles an empty array correctly\") {\n        std::vector<int> result = removeElementInArray({}, 1);\n        REQUIRE(result == std::vector<int>({}));\n    }\n\n    SECTION(\"removes an element from a vector of objects\") {\n        struct Obj {\n            int id;\n            bool operator==(const Obj& other) const {\n                return id == other.id;\n            }\n        };\n        \n        Obj obj1{1}, obj2{2}, obj3{3};\n        std::vector<Obj> result = removeElementInArray({obj1, obj2, obj3}, obj2);\n        REQUIRE(result == std::vector<Obj>({obj1, obj3}));\n    }\n\n    SECTION(\"does not modify the original array\") {\n        std::vector<int> originalArray = {1, 2, 3};\n        std::vector<int> result = removeElementInArray(originalArray, 2);\n        REQUIRE(originalArray == std::vector<int>({1, 2, 3}));\n        REQUIRE(result == std::vector<int>({1, 3}));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Removes the first occurrence of a specified element from a vector.\n *\n * @param {std::vector<int>} array - The vector from which to remove the element.\n * @param {int} element - The element to remove from the vector.\n * @returns {std::vector<int>} A new vector with the element removed, or the original vector if the element is not found.\n */\nstd::vector<int> removeElementInArray(const std::vector<int>& array, int element) {\n    \n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Removes the first occurrence of a specified element from a list.\n *\n * @param list - The list from which to remove the element.\n * @param element - The element to remove from the list.\n * @return A new list with the element removed, or the original list if the element is not found.\n */\npublic static <T> List<T> removeElementInArray(List<T> list, T element) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testReturnsOriginalArrayWhenElementNotFound() {\n        List<Integer> result = Answer.removeElementInArray(List.of(1, 2, 3, 4), 5);\n        assertEquals(List.of(1, 2, 3, 4), result);\n    }\n\n    @Test\n    public void testHandlesEmptyArrayCorrectly() {\n        List<Integer> result = Answer.removeElementInArray(new ArrayList<>(), 1);\n        assertEquals(new ArrayList<>(), result);\n    }\n\n    @Test\n    public void testRemovesElementFromArrayOfObjects() {\n        Object obj1 = new MyObject(1);\n        Object obj2 = new MyObject(2);\n        Object obj3 = new MyObject(3);\n        List<Object> result = Answer.removeElementInArray(List.of(obj1, obj2, obj3), obj2);\n        assertEquals(List.of(obj1, obj3), result);\n    }\n\n    @Test\n    public void testDoesNotModifyOriginalArray() {\n        List<Integer> originalArray = new ArrayList<>(List.of(1, 2, 3));\n        List<Integer> result = Answer.removeElementInArray(originalArray, 2);\n        assertEquals(List.of(1, 2, 3), originalArray);\n        assertEquals(List.of(1, 3), result);\n    }\n\n    private static class MyObject {\n        private int id;\n\n        public MyObject(int id) {\n            this.id = id;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            MyObject myObject = (MyObject) obj;\n            return id == myObject.id;\n        }\n\n        @Override\n        public int hashCode() {\n            return Integer.hashCode(id);\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Removes the first occurrence of a specified element from a list.\n *\n * @param list - The list from which to remove the element.\n * @param element - The element to remove from the list.\n * @return A new list with the element removed, or the original list if the element is not found.\n */\npublic static <T> List<T> removeElementInArray(List<T> list, T element) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 535, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Compresses an HTML string by removing unnecessary whitespace,\nincluding newlines, tabs, and extra spaces,\nwhile preserving the structure of the HTML.", "language_version_list": {"python": {"code_signature": "def compress_html(html: str) -> str:\n    \"\"\"\n    Compresses an HTML string by removing unnecessary whitespace,\n    including newlines, tabs, and extra spaces,\n    while preserving the structure of the HTML.\n\n    Args:\n        html (str): The input HTML string to be compressed.\n\n    Returns:\n        str: The compressed HTML string with reduced whitespace.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCompressHtml(unittest.TestCase):\n\n    def test_remove_newlines_and_tabs(self):\n        input_html = \"\"\"            <div>                <p>Test paragraph.</p>            </div>        \"\"\"\n        expected_output = '<div><p>Test paragraph.</p></div>'\n        self.assertEqual(compress_html(input_html), expected_output)\n\n    def test_replace_multiple_spaces(self):\n        input_html = '<div>    <p>     Test with     multiple spaces.   </p></div>'\n        expected_output = '<div><p> Test with multiple spaces. </p></div>'\n        self.assertEqual(compress_html(input_html), expected_output)\n\n    def test_remove_spaces_between_tags(self):\n        input_html = '<div> <p>Test</p> </div>'\n        expected_output = '<div><p>Test</p></div>'\n        self.assertEqual(compress_html(input_html), expected_output)\n\n    def test_handle_empty_input(self):\n        input_html = ''\n        expected_output = ''\n        self.assertEqual(compress_html(input_html), expected_output)\n\n    def test_handle_html_with_only_spaces_and_newlines(self):\n        input_html = \"\"\"            <div>                  </div>        \"\"\"\n        expected_output = '<div></div>'\n        self.assertEqual(compress_html(input_html), expected_output)\n", "prompt": "please write a python function , the function signature as below def compress_html(html: str) -> str:\n    \"\"\"\n    Compresses an HTML string by removing unnecessary whitespace,\n    including newlines, tabs, and extra spaces,\n    while preserving the structure of the HTML.\n\n    Args:\n        html (str): The input HTML string to be compressed.\n\n    Returns:\n        str: The compressed HTML string with reduced whitespace.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace,\n * including newlines, tabs, and extra spaces,\n * while preserving the structure of the HTML.\n *\n * @param {string} html - The input HTML string to be compressed.\n * @returns {string} - The compressed HTML string with reduced whitespace.\n */\nfunction compressHtml(html) {\n}", "test_code": "describe('compressHtml', () => {\n    it('should remove newlines and tabs', () => {\n        const input = `\n            <div>\n                <p>Test paragraph.</p>\n            </div>\n        `;\n        const expectedOutput = '<div><p>Test paragraph.</p></div>';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n\n    it('should replace multiple spaces with a single space', () => {\n        const input = '<div>    <p>     Test with     multiple spaces.   </p></div>';\n        const expectedOutput = '<div><p> Test with multiple spaces. </p></div>';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n\n    it('should remove spaces between HTML tags', () => {\n        const input = '<div> <p>Test</p> </div>';\n        const expectedOutput = '<div><p>Test</p></div>';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n\n    it('should handle empty input', () => {\n        const input = '';\n        const expectedOutput = '';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n\n    it('should handle HTML with only spaces and newlines', () => {\n        const input = `\n            <div>      \n            </div>\n        `;\n        const expectedOutput = '<div></div>';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace,\n * including newlines, tabs, and extra spaces,\n * while preserving the structure of the HTML.\n *\n * @param {string} html - The input HTML string to be compressed.\n * @returns {string} - The compressed HTML string with reduced whitespace.\n */\nfunction compressHtml(html) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace,\n * including newlines, tabs, and extra spaces,\n * while preserving the structure of the HTML.\n *\n * @param {string} html - The input HTML string to be compressed.\n * @returns {string} - The compressed HTML string with reduced whitespace.\n */\nfunction compressHtml(html: string): string {}", "test_code": "describe('compressHtml', () => {\n    it('should remove newlines and tabs', () => {\n        const input: string = `\n            <div>\n                <p>Test paragraph.</p>\n            </div>\n        `;\n        const expectedOutput: string = '<div><p>Test paragraph.</p></div>';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n\n    it('should replace multiple spaces with a single space', () => {\n        const input: string = '<div>    <p>     Test with     multiple spaces.   </p></div>';\n        const expectedOutput: string = '<div><p> Test with multiple spaces. </p></div>';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n\n    it('should remove spaces between HTML tags', () => {\n        const input: string = '<div> <p>Test</p> </div>';\n        const expectedOutput: string = '<div><p>Test</p></div>';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n\n    it('should handle empty input', () => {\n        const input: string = '';\n        const expectedOutput: string = '';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n\n    it('should handle HTML with only spaces and newlines', () => {\n        const input: string = `\n            <div>      \n            </div>\n        `;\n        const expectedOutput: string = '<div></div>';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace,\n * including newlines, tabs, and extra spaces,\n * while preserving the structure of the HTML.\n *\n * @param {string} html - The input HTML string to be compressed.\n * @returns {string} - The compressed HTML string with reduced whitespace.\n */\nfunction compressHtml(html: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace,\n * including newlines, tabs, and extra spaces,\n * while preserving the structure of the HTML.\n *\n * @param std::string html - The input HTML string to be compressed.\n * @returns std::string - The compressed HTML string with reduced whitespace.\n */\nstd::string compressHtml(const std::string& html) {\n}", "test_code": "TEST_CASE(\"compressHtml\", \"[html]\") {\n    SECTION(\"should remove newlines and tabs\") {\n        std::string input = R\"(\n            <div>\n                <p>Test paragraph.</p>\n            </div>\n        )\";\n        std::string expectedOutput = \"<div><p>Test paragraph.</p></div>\";\n        REQUIRE(compressHtml(input) == expectedOutput);\n    }\n\n    SECTION(\"should replace multiple spaces with a single space\") {\n        std::string input = \"<div>    <p>     Test with     multiple spaces.   </p></div>\";\n        std::string expectedOutput = \"<div><p> Test with multiple spaces. </p></div>\";\n        REQUIRE(compressHtml(input) == expectedOutput);\n    }\n\n    SECTION(\"should remove spaces between HTML tags\") {\n        std::string input = \"<div> <p>Test</p> </div>\";\n        std::string expectedOutput = \"<div><p>Test</p></div>\";\n        REQUIRE(compressHtml(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle empty input\") {\n        std::string input = \"\";\n        std::string expectedOutput = \"\";\n        REQUIRE(compressHtml(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle HTML with only spaces and newlines\") {\n        std::string input = R\"(\n            <div>      \n            </div>\n        )\";\n        std::string expectedOutput = \"<div></div>\";\n        REQUIRE(compressHtml(input) == expectedOutput);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace,\n * including newlines, tabs, and extra spaces,\n * while preserving the structure of the HTML.\n *\n * @param std::string html - The input HTML string to be compressed.\n * @returns std::string - The compressed HTML string with reduced whitespace.\n */\nstd::string compressHtml(const std::string& html) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace,\n * including newlines, tabs, and extra spaces,\n * while preserving the structure of the HTML.\n *\n * @param html The input HTML string to be compressed.\n * @return The compressed HTML string with reduced whitespace.\n */\npublic static String compressHtml(String html) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testRemoveNewlinesAndTabs() {\n        String input = \"\\n            <div>\\n                <p>Test paragraph.</p>\\n            </div>\\n        \";\n        String expectedOutput = \"<div><p>Test paragraph.</p></div>\";\n        assertEquals(expectedOutput, Answer.compressHtml(input));\n    }\n\n    @Test\n    public void testReplaceMultipleSpaces() {\n        String input = \"<div>    <p>     Test with     multiple spaces.   </p></div>\";\n        String expectedOutput = \"<div><p> Test with multiple spaces. </p></div>\";\n        assertEquals(expectedOutput, Answer.compressHtml(input));\n    }\n\n    @Test\n    public void testRemoveSpacesBetweenTags() {\n        String input = \"<div> <p>Test</p> </div>\";\n        String expectedOutput = \"<div><p>Test</p></div>\";\n        assertEquals(expectedOutput, Answer.compressHtml(input));\n    }\n\n    @Test\n    public void testHandleEmptyInput() {\n        String input = \"\";\n        String expectedOutput = \"\";\n        assertEquals(expectedOutput, Answer.compressHtml(input));\n    }\n\n    @Test\n    public void testHandleSpacesAndNewlines() {\n        String input = \"\\n            <div>      \\n            </div>\\n        \";\n        String expectedOutput = \"<div></div>\";\n        assertEquals(expectedOutput, Answer.compressHtml(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace,\n * including newlines, tabs, and extra spaces,\n * while preserving the structure of the HTML.\n *\n * @param html The input HTML string to be compressed.\n * @return The compressed HTML string with reduced whitespace.\n */\npublic static String compressHtml(String html) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 536, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Gets the current date formatted as 'Month Day, Year'.", "language_version_list": {"python": {"code_signature": "def get_date() -> str:\n    \"\"\"\n    Gets the current date formatted as 'Month Day, Year'.\n\n    Returns:\n        str: The formatted date string.\n    \"\"\"", "test_code": "import unittest\nfrom datetime import datetime\nfrom unittest.mock import patch\n\n\nclass TestGetDate(unittest.TestCase):\n\n    @patch('datetime.datetime')\n    def setUp(self, mock_datetime):\n        # Mock the datetime to return a specific date\n        mock_datetime.now.return_value = datetime(2024, 10, 1)\n\n    def test_returns_date_in_format(self):\n        result = get_date()\n        self.assertEqual(result, 'October 1, 2024')\n\n    def test_returns_correct_year(self):\n        result = get_date()\n        self.assertIn('2024', result)\n\n    def test_returns_correct_month(self):\n        result = get_date()\n        self.assertIn('October', result)\n\n    def test_returns_correct_day(self):\n        result = get_date()\n        self.assertIn('1', result)\n\n    def test_returns_date_as_string(self):\n        result = get_date()\n        self.assertIsInstance(result, str)\n\n    def test_does_not_return_none(self):\n        result = get_date()\n        self.assertIsNotNone(result)\n", "prompt": "please write a python function , the function signature as below def get_date() -> str:\n    \"\"\"\n    Gets the current date formatted as 'Month Day, Year'.\n\n    Returns:\n        str: The formatted date string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Gets the current date formatted as 'Month Day, Year'.\n *\n * @returns {string} The formatted date string.\n */\nfunction getDate() {\n}", "test_code": "describe('getDate', () => {\n    // Mock the Date object to control the current date for testing\n    const mockDate = new Date('2024-10-01T00:00:00Z');\n\n    beforeAll(() => {\n        // Mock the global Date object\n        jest.spyOn(global, 'Date').mockImplementation(() => mockDate);\n    });\n\n    afterAll(() => {\n        // Restore the original Date object\n        global.Date.mockRestore();\n    });\n\n    test('returns date in \"Month Day, Year\" format', () => {\n        const result = getDate();\n        expect(result).toBe('October 1, 2024');\n    });\n\n    test('returns correct year', () => {\n        const result = getDate();\n        expect(result).toMatch(/2024/);\n    });\n\n    test('returns correct month', () => {\n        const result = getDate();\n        expect(result).toMatch(/October/);\n    });\n\n    test('returns correct day', () => {\n        const result = getDate();\n        expect(result).toMatch(/1/);\n    });\n\n\n    test('returns date as a string', () => {\n        const result = getDate();\n        expect(typeof result).toBe('string');\n    });\n\n    test('does not return undefined', () => {\n        const result = getDate();\n        expect(result).not.toBeUndefined();\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Gets the current date formatted as 'Month Day, Year'.\n *\n * @returns {string} The formatted date string.\n */\nfunction getDate() {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Gets the current date formatted as 'Month Day, Year'.\n *\n * @returns {string} The formatted date string.\n */\nfunction getDate(): string {}", "test_code": "describe('getDate', () => {\n    // Mock the Date object to control the current date for testing\n    const mockDate: Date = new Date('2024-10-01T00:00:00Z');\n\n    beforeAll(() => {\n        // Mock the global Date object\n        jest.spyOn(global, 'Date').mockImplementation(() => mockDate as any);\n    });\n\n    afterAll(() => {\n        // Restore the original Date object\n        (global.Date as jest.Mock).mockRestore();\n    });\n\n    test('returns date in \"Month Day, Year\" format', () => {\n        const result: string = getDate();\n        expect(result).toBe('October 1, 2024');\n    });\n\n    test('returns correct year', () => {\n        const result: string = getDate();\n        expect(result).toMatch(/2024/);\n    });\n\n    test('returns correct month', () => {\n        const result: string = getDate();\n        expect(result).toMatch(/October/);\n    });\n\n    test('returns correct day', () => {\n        const result: string = getDate();\n        expect(result).toMatch(/1/);\n    });\n\n    test('returns date as a string', () => {\n        const result: string = getDate();\n        expect(typeof result).toBe('string');\n    });\n\n    test('does not return undefined', () => {\n        const result: string = getDate();\n        expect(result).not.toBeUndefined();\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Gets the current date formatted as 'Month Day, Year'.\n *\n * @returns {string} The formatted date string.\n */\nfunction getDate(): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Gets the current date formatted as 'Month Day, Year'.\n *\n * @returns A string containing the formatted date.\n */\nstd::string getDate() {}", "test_code": "std::string getDate() {\n    // Normally would return the actual date; here we simulate for testing\n    return \"October 1, 2024\"; \n}\n\nTEST_CASE(\"getDate\", \"[date]\") {\n    SECTION(\"returns date in 'Month Day, Year' format\") {\n        REQUIRE(getDate() == \"October 1, 2024\");\n    }\n\n    SECTION(\"returns correct year\") {\n        REQUIRE(getDate().find(\"2024\") != std::string::npos);\n    }\n\n    SECTION(\"returns correct month\") {\n        REQUIRE(getDate().find(\"October\") != std::string::npos);\n    }\n\n    SECTION(\"returns correct day\") {\n        REQUIRE(getDate().find(\"1\") != std::string::npos);\n    }\n\n    SECTION(\"returns date as a string\") {\n        REQUIRE(typeid(getDate()).name() == typeid(std::string).name());\n    }\n\n    SECTION(\"does not return undefined\") {\n        REQUIRE_FALSE(getDate().empty());\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Gets the current date formatted as 'Month Day, Year'.\n *\n * @returns A string containing the formatted date.\n */\nstd::string getDate() {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Gets the current date formatted as 'Month Day, Year'.\n *\n * @return The formatted date string.\n */\npublic static String getDate() {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\npublic class Tester {\n    private Date originalDate;\n\n    @Before\n    public void setUp() {\n        // Mock the current date\n        originalDate = new Date();\n        System.setProperty(\"current.test.date\", \"2024-10-01T00:00:00Z\");\n    }\n\n    @After\n    public void tearDown() {\n        // Restore the original date if needed\n        System.clearProperty(\"current.test.date\");\n    }\n\n    private String getDate() {\n        // Get the mocked date\n        String testDate = System.getProperty(\"current.test.date\");\n        Date currentDate = new Date(testDate);\n        \n        // Define the date format\n        SimpleDateFormat formatter = new SimpleDateFormat(\"MMMM d, yyyy\", Locale.ENGLISH);\n        \n        // Return the formatted date string\n        return formatter.format(currentDate);\n    }\n\n    @Test\n    public void testReturnsDateInMonthDayYearFormat() {\n        String result = getDate();\n        assertEquals(\"October 1, 2024\", result);\n    }\n\n    @Test\n    public void testReturnsCorrectYear() {\n        String result = getDate();\n        assertTrue(result.matches(\".*2024.*\"));\n    }\n\n    @Test\n    public void testReturnsCorrectMonth() {\n        String result = getDate();\n        assertTrue(result.matches(\".*October.*\"));\n    }\n\n    @Test\n    public void testReturnsCorrectDay() {\n        String result = getDate();\n        assertTrue(result.matches(\".*1.*\"));\n    }\n\n    @Test\n    public void testReturnsDateAsString() {\n        String result = getDate();\n        assertTrue(result instanceof String);\n    }\n\n    @Test\n    public void testDoesNotReturnUndefined() {\n        String result = getDate();\n        assertNotNull(result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Gets the current date formatted as 'Month Day, Year'.\n *\n * @return The formatted date string.\n */\npublic static String getDate() {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 537, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Gets the current time formatted as 'hh:mm AM/PM'.", "language_version_list": {"python": {"code_signature": "def get_time() -> str:\n    \"\"\"\n    Gets the current time formatted as 'hh:mm AM/PM'.\n\n    Returns:\n        str: The formatted time string.\n    \"\"\"", "test_code": "import unittest\nfrom datetime import datetime\nfrom unittest.mock import patch\n\n\nclass TestGetTime(unittest.TestCase):\n\n    def mock_datetime(self, date_string):\n        \"\"\"Mock the datetime to return a specific date.\"\"\"\n        class MockDate(datetime):\n            @classmethod\n            def now(cls):\n                return datetime.strptime(date_string, '%Y-%m-%dT%H:%M:%S')\n\n        return MockDate\n\n    @patch('datetime.datetime', new_callable=lambda: datetime)\n    def test_should_return_a_string(self, mock_datetime):\n        mock_datetime.now = self.mock_datetime('2024-10-01T10:30:00').now\n        result = get_time()\n        self.assertIsInstance(result, str)\n\n    @patch('datetime.datetime', new_callable=lambda: datetime)\n    def test_should_return_formatted_time_string_including_AM_PM(self, mock_datetime):\n        mock_datetime.now = self.mock_datetime('2024-10-01T15:45:00').now\n        result = get_time()\n        self.assertRegex(result, r'^\\d{1,2}:\\d{2} (AM|PM)$')\n\n    @patch('datetime.datetime', new_callable=lambda: datetime)\n    def test_should_return_correct_time_during_AM_hours(self, mock_datetime):\n        mock_datetime.now = self.mock_datetime('2024-10-01T08:15:00').now\n        result = get_time()\n        self.assertEqual(result, '08:15 AM')\n\n    @patch('datetime.datetime', new_callable=lambda: datetime)\n    def test_should_return_correct_time_during_PM_hours(self, mock_datetime):\n        mock_datetime.now = self.mock_datetime('2024-10-01T17:20:00').now\n        result = get_time()\n        self.assertEqual(result, '05:20 PM')\n\n    @patch('datetime.datetime', new_callable=lambda: datetime)\n    def test_should_return_12_00_AM_at_midnight(self, mock_datetime):\n        mock_datetime.now = self.mock_datetime('2024-10-01T00:00:00').now\n        result = get_time()\n        self.assertEqual(result, '12:00 AM')\n\n    @patch('datetime.datetime', new_callable=lambda: datetime)\n    def test_should_return_12_00_PM_at_noon(self, mock_datetime):\n        mock_datetime.now = self.mock_datetime('2024-10-01T12:00:00').now\n        result = get_time()\n        self.assertEqual(result, '12:00 PM')\n\n    @patch('datetime.datetime', new_callable=lambda: datetime)\n    def test_should_handle_single_digit_minutes_correctly(self, mock_datetime):\n        mock_datetime.now = self.mock_datetime('2024-10-01T09:05:00').now\n        result = get_time()\n        self.assertEqual(result, '09:05 AM')\n", "prompt": "please write a python function , the function signature as below def get_time() -> str:\n    \"\"\"\n    Gets the current time formatted as 'hh:mm AM/PM'.\n\n    Returns:\n        str: The formatted time string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Gets the current time formatted as 'hh:mm AM/PM'.\n *\n * @returns {string} The formatted time string.\n */\nfunction getTime() {\n}", "test_code": "describe('getTime', () => {\n    const mockDate = (dateString) => {\n        const date = new Date(dateString);\n        jest.spyOn(global, 'Date').mockImplementation(() => date);\n    };\n\n    afterEach(() => {\n        jest.restoreAllMocks();\n    });\n\n    test('should return a string', () => {\n        mockDate('2024-10-01T10:30:00'); // Mocking a specific date and time\n        const result = getTime();\n        expect(typeof result).toBe('string');\n    });\n\n    test('should return a formatted time string including AM/PM', () => {\n        mockDate('2024-10-01T15:45:00'); // 3:45 PM\n        const result = getTime();\n        expect(result).toMatch(/^\\d{1,2}:\\d{2} (AM|PM)$/);\n    });\n\n    test('should return the correct time during AM hours', () => {\n        mockDate('2024-10-01T08:15:00'); // 8:15 AM\n        const result = getTime();\n        expect(result).toBe('8:15 AM');\n    });\n\n    test('should return the correct time during PM hours', () => {\n        mockDate('2024-10-01T17:20:00'); // 5:20 PM\n        const result = getTime();\n        expect(result).toBe('5:20 PM');\n    });\n\n    test('should return \"12:00 AM\" at midnight', () => {\n        mockDate('2024-10-01T00:00:00'); // 12:00 AM\n        const result = getTime();\n        expect(result).toBe('12:00 AM');\n    });\n\n    test('should return \"12:00 PM\" at noon', () => {\n        mockDate('2024-10-01T12:00:00'); // 12:00 PM\n        const result = getTime();\n        expect(result).toBe('12:00 PM');\n    });\n\n    test('should handle single-digit minutes correctly', () => {\n        mockDate('2024-10-01T09:05:00'); // 9:05 AM\n        const result = getTime();\n        expect(result).toBe('9:05 AM');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Gets the current time formatted as 'hh:mm AM/PM'.\n *\n * @returns {string} The formatted time string.\n */\nfunction getTime() {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Gets the current time formatted as 'hh:mm AM/PM'.\n *\n * @returns {string} The formatted time string.\n */\nfunction getTime(): string {\n}", "test_code": "describe('getTime', () => {\n    const mockDate = (dateString: string): void => {\n        const date = new Date(dateString);\n        jest.spyOn(global, 'Date').mockImplementation(() => date);\n    };\n\n    afterEach(() => {\n        jest.restoreAllMocks();\n    });\n\n    test('should return a string', () => {\n        mockDate('2024-10-01T10:30:00'); // Mocking a specific date and time\n        const result: string = getTime();\n        expect(typeof result).toBe('string');\n    });\n\n    test('should return a formatted time string including AM/PM', () => {\n        mockDate('2024-10-01T15:45:00'); // 3:45 PM\n        const result: string = getTime();\n        expect(result).toMatch(/^\\d{1,2}:\\d{2} (AM|PM)$/);\n    });\n\n    test('should return the correct time during AM hours', () => {\n        mockDate('2024-10-01T08:15:00'); // 8:15 AM\n        const result: string = getTime();\n        expect(result).toBe('8:15 AM');\n    });\n\n    test('should return the correct time during PM hours', () => {\n        mockDate('2024-10-01T17:20:00'); // 5:20 PM\n        const result: string = getTime();\n        expect(result).toBe('5:20 PM');\n    });\n\n    test('should return \"12:00 AM\" at midnight', () => {\n        mockDate('2024-10-01T00:00:00'); // 12:00 AM\n        const result: string = getTime();\n        expect(result).toBe('12:00 AM');\n    });\n\n    test('should return \"12:00 PM\" at noon', () => {\n        mockDate('2024-10-01T12:00:00'); // 12:00 PM\n        const result: string = getTime();\n        expect(result).toBe('12:00 PM');\n    });\n\n    test('should handle single-digit minutes correctly', () => {\n        mockDate('2024-10-01T09:05:00'); // 9:05 AM\n        const result: string = getTime();\n        expect(result).toBe('9:05 AM');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Gets the current time formatted as 'hh:mm AM/PM'.\n *\n * @returns {string} The formatted time string.\n */\nfunction getTime(): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Gets the current time formatted as 'hh:mm AM/PM'.\n *\n * @returns The formatted time string.\n */\nstd::string getTime();", "test_code": "std::string getTime() {\n    std::time_t now = std::time(nullptr);\n    std::tm *localTime = std::localtime(&now);\n    std::ostringstream oss;\n    oss << std::put_time(localTime, \"%I:%M %p\");\n    return oss.str();\n}\n\nTEST_CASE(\"getTime\") {\n    // Mocking function to set a specific time\n    auto mockDate = [](const std::string& dateString) {\n        std::tm tm = {};\n        std::istringstream ss(dateString);\n        ss >> std::get_time(&tm, \"%Y-%m-%dT%H:%M:%S\");\n        std::time_t mockTime = std::mktime(&tm);\n        std::tm *localTime = std::localtime(&mockTime);\n        return localTime;\n    };\n\n    SECTION(\"should return a string\") {\n        std::tm* mockTime = mockDate(\"2024-10-01T10:30:00\");\n        std::string result = getTime(); // Adjust this to use mocked time in your actual implementation\n        REQUIRE(result.length() > 0);\n    }\n\n    SECTION(\"should return a formatted time string including AM/PM\") {\n        std::tm* mockTime = mockDate(\"2024-10-01T15:45:00\");\n        std::string result = getTime(); // Adjust this to use mocked time\n        REQUIRE(std::regex_match(result, std::regex(\"^\\\\d{1,2}:\\\\d{2} (AM|PM)$\")));\n    }\n\n    SECTION(\"should return the correct time during AM hours\") {\n        std::tm* mockTime = mockDate(\"2024-10-01T08:15:00\");\n        std::string result = getTime(); // Adjust this to use mocked time\n        REQUIRE(result == \"8:15 AM\");\n    }\n\n    SECTION(\"should return the correct time during PM hours\") {\n        std::tm* mockTime = mockDate(\"2024-10-01T17:20:00\");\n        std::string result = getTime(); // Adjust this to use mocked time\n        REQUIRE(result == \"5:20 PM\");\n    }\n\n    SECTION(\"should return '12:00 AM' at midnight\") {\n        std::tm* mockTime = mockDate(\"2024-10-01T00:00:00\");\n        std::string result = getTime(); // Adjust this to use mocked time\n        REQUIRE(result == \"12:00 AM\");\n    }\n\n    SECTION(\"should return '12:00 PM' at noon\") {\n        std::tm* mockTime = mockDate(\"2024-10-01T12:00:00\");\n        std::string result = getTime(); // Adjust this to use mocked time\n        REQUIRE(result == \"12:00 PM\");\n    }\n\n    SECTION(\"should handle single-digit minutes correctly\") {\n        std::tm* mockTime = mockDate(\"2024-10-01T09:05:00\");\n        std::string result = getTime(); // Adjust this to use mocked time\n        REQUIRE(result == \"9:05 AM\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Gets the current time formatted as 'hh:mm AM/PM'.\n *\n * @returns The formatted time string.\n */\nstd::string getTime();", "addition_info": ""}, "java": {"code_signature": "/**\n * Gets the current time formatted as 'hh:mm AM/PM'.\n *\n * @returns {String} The formatted time string.\n */\npublic String getTime() {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\npublic class Tester {\n    private static final String originalTimeZone = TimeZone.getDefault().getID();\n\n    @Before\n    public void setUp() {\n        TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\")); // Set a consistent timezone for testing\n    }\n\n    @After\n    public void tearDown() {\n        TimeZone.setDefault(TimeZone.getTimeZone(originalTimeZone)); // Restore original timezone\n    }\n\n    private String mockDate(String dateString) {\n        System.setProperty(\"current.time\", dateString); // Simulate mock date (you would need to implement this in getTime)\n        return getTime();\n    }\n\n    @Test\n    public void shouldReturnAString() {\n        String result = mockDate(\"2024-10-01T10:30:00\");\n        assertTrue(result instanceof String);\n    }\n\n    @Test\n    public void shouldReturnFormattedTimeStringIncludingAMPM() {\n        String result = mockDate(\"2024-10-01T15:45:00\");\n        assertTrue(result.matches(\"^\\\\d{1,2}:\\\\d{2} (AM|PM)$\"));\n    }\n\n    @Test\n    public void shouldReturnCorrectTimeDuringAMHours() {\n        String result = mockDate(\"2024-10-01T08:15:00\");\n        assertEquals(\"8:15 AM\", result);\n    }\n\n    @Test\n    public void shouldReturnCorrectTimeDuringPMHours() {\n        String result = mockDate(\"2024-10-01T17:20:00\");\n        assertEquals(\"5:20 PM\", result);\n    }\n\n    @Test\n    public void shouldReturn12AMAtMidnight() {\n        String result = mockDate(\"2024-10-01T00:00:00\");\n        assertEquals(\"12:00 AM\", result);\n    }\n\n    @Test\n    public void shouldReturn12PMAtNoon() {\n        String result = mockDate(\"2024-10-01T12:00:00\");\n        assertEquals(\"12:00 PM\", result);\n    }\n\n    @Test\n    public void shouldHandleSingleDigitMinutesCorrectly() {\n        String result = mockDate(\"2024-10-01T09:05:00\");\n        assertEquals(\"9:05 AM\", result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Gets the current time formatted as 'hh:mm AM/PM'.\n *\n * @returns {String} The formatted time string.\n */\npublic String getTime() {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 538, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Sorts an array of objects alphabetically based on a specified field.", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Sorts an array of objects alphabetically based on a specified field.\n *\n * @param {Array} array - The array of objects to sort.\n * @param {String} field - The field of the objects to sort by.\n * @param {Boolean} ascending - If true, sort in ascending order; if false, sort in descending order.\n * @returns {Array} - The sorted array of objects.\n */\nfunction sortByField(array, field, ascending = true) {\n}", "test_code": "describe('sortByField', () => {\n    const data = [\n        {name: 'John', age: 25},\n        {name: 'Alice', age: 30},\n        {name: 'Bob', age: 22},\n        {name: 'Charlie', age: 28},\n    ];\n\n    test('should sort by name in ascending order', () => {\n        const sorted = sortByField(data, 'name', true);\n        expect(sorted).toEqual([\n            {name: 'Alice', age: 30},\n            {name: 'Bob', age: 22},\n            {name: 'Charlie', age: 28},\n            {name: 'John', age: 25},\n        ]);\n    });\n\n    test('should sort by name in descending order', () => {\n        const sorted = sortByField(data, 'name', false);\n        expect(sorted).toEqual([\n            {name: 'John', age: 25},\n            {name: 'Charlie', age: 28},\n            {name: 'Bob', age: 22},\n            {name: 'Alice', age: 30},\n        ]);\n    });\n\n    test('should sort by age in ascending order', () => {\n        const sorted = sortByField(data, 'age', true);\n        expect(sorted).toEqual([\n            {name: 'Bob', age: 22},\n            {name: 'John', age: 25},\n            {name: 'Charlie', age: 28},\n            {name: 'Alice', age: 30},\n        ]);\n    });\n\n    test('should sort by age in descending order', () => {\n        const sorted = sortByField(data, 'age', false);\n        expect(sorted).toEqual([\n            {name: 'Alice', age: 30},\n            {name: 'Charlie', age: 28},\n            {name: 'John', age: 25},\n            {name: 'Bob', age: 22},\n        ]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Sorts an array of objects alphabetically based on a specified field.\n *\n * @param {Array} array - The array of objects to sort.\n * @param {String} field - The field of the objects to sort by.\n * @param {Boolean} ascending - If true, sort in ascending order; if false, sort in descending order.\n * @returns {Array} - The sorted array of objects.\n */\nfunction sortByField(array, field, ascending = true) {\n}", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "please write a typescript function , the function signature as below ", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 540, "code_type": "method", "original_language": "javascript", "question_type": "Algorithm and data structure", "summary": "Generates all unique combinations of pairs from an array.", "language_version_list": {"python": {"code_signature": "def generate_unique_pairs(array: list) -> list:\n    \"\"\"\n    Generates all unique combinations of pairs from a list.\n\n    Args:\n        array (list): The input list from which combinations are generated.\n\n    Returns:\n        list of lists: A list of lists, where each inner list contains a unique pair of elements.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGenerateUniquePairs(unittest.TestCase):\n\n    def test_generates_unique_pairs_from_three_elements(self):\n        items = ['A', 'B', 'C']\n        result = generate_unique_pairs(items)\n        self.assertEqual(result, [('A', 'B'), ('A', 'C'), ('B', 'C')])\n\n    def test_generates_unique_pairs_from_two_elements(self):\n        items = ['A', 'B']\n        result = generate_unique_pairs(items)\n        self.assertEqual(result, [('A', 'B')])\n\n    def test_returns_empty_array_when_input_array_is_empty(self):\n        items = []\n        result = generate_unique_pairs(items)\n        self.assertEqual(result, [])\n\n    def test_returns_empty_array_when_input_array_has_one_element(self):\n        items = ['A']\n        result = generate_unique_pairs(items)\n        self.assertEqual(result, [])\n\n    def test_handles_array_with_different_types_of_elements(self):\n        items = [1, 'A', {'key': 'value'}]\n        result = generate_unique_pairs(items)\n        self.assertEqual(result, [(1, 'A'), (1, {'key': 'value'}), ('A', {'key': 'value'})])\n\n    def test_generates_pairs_from_array_with_more_than_three_elements(self):\n        items = ['A', 'B', 'C', 'D']\n        result = generate_unique_pairs(items)\n        self.assertEqual(result, [('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('B', 'D'), ('C', 'D')])", "prompt": "please write a python function , the function signature as below def generate_unique_pairs(array: list) -> list:\n    \"\"\"\n    Generates all unique combinations of pairs from a list.\n\n    Args:\n        array (list): The input list from which combinations are generated.\n\n    Returns:\n        list of lists: A list of lists, where each inner list contains a unique pair of elements.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Generates all unique combinations of pairs from an array.\n *\n * @param {Array} array - The input array from which combinations are generated.\n * @returns {Array} - An array of arrays, where each inner array contains a unique pair of elements.\n */\nfunction generateUniquePairs(array) {\n}", "test_code": "describe('generateUniquePairs', () => {\n    test('generates unique pairs from an array with three elements', () => {\n        const items = ['A', 'B', 'C'];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([\n            ['A', 'B'],\n            ['A', 'C'],\n            ['B', 'C']\n        ]);\n    });\n\n    test('generates unique pairs from an array with two elements', () => {\n        const items = ['A', 'B'];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([['A', 'B']]);\n    });\n\n    test('returns an empty array when the input array is empty', () => {\n        const items = [];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([]);\n    });\n\n    test('returns an empty array when the input array has one element', () => {\n        const items = ['A'];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([]);\n    });\n\n\n    test('handles an array with different types of elements', () => {\n        const items = [1, 'A', { key: 'value' }];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([\n            [1, 'A'],\n            [1, { key: 'value' }],\n            ['A', { key: 'value' }]\n        ]);\n    });\n\n    test('generates pairs from an array with more than three elements', () => {\n        const items = ['A', 'B', 'C', 'D'];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([\n            ['A', 'B'],\n            ['A', 'C'],\n            ['A', 'D'],\n            ['B', 'C'],\n            ['B', 'D'],\n            ['C', 'D']\n        ]);\n    });\n\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Generates all unique combinations of pairs from an array.\n *\n * @param {Array} array - The input array from which combinations are generated.\n * @returns {Array} - An array of arrays, where each inner array contains a unique pair of elements.\n */\nfunction generateUniquePairs(array) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Generates all unique combinations of pairs from an array.\n *\n * @param {Array<T>} array - The input array from which combinations are generated.\n * @returns {Array<[T, T]>} - An array of arrays, where each inner array contains a unique pair of elements.\n */\nfunction generateUniquePairs<T>(array: T[]): [T, T][] {\n}", "test_code": "describe('generateUniquePairs', () => {\n    test('generates unique pairs from an array with three elements', () => {\n        const items: string[] = ['A', 'B', 'C'];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([\n            ['A', 'B'],\n            ['A', 'C'],\n            ['B', 'C']\n        ]);\n    });\n\n    test('generates unique pairs from an array with two elements', () => {\n        const items: string[] = ['A', 'B'];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([['A', 'B']]);\n    });\n\n    test('returns an empty array when the input array is empty', () => {\n        const items: string[] = [];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([]);\n    });\n\n    test('returns an empty array when the input array has one element', () => {\n        const items: string[] = ['A'];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([]);\n    });\n\n    test('handles an array with different types of elements', () => {\n        const items: (string | number | { key: string })[] = [1, 'A', { key: 'value' }];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([\n            [1, 'A'],\n            [1, { key: 'value' }],\n            ['A', { key: 'value' }]\n        ]);\n    });\n\n    test('generates pairs from an array with more than three elements', () => {\n        const items: string[] = ['A', 'B', 'C', 'D'];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([\n            ['A', 'B'],\n            ['A', 'C'],\n            ['A', 'D'],\n            ['B', 'C'],\n            ['B', 'D'],\n            ['C', 'D']\n        ]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Generates all unique combinations of pairs from an array.\n *\n * @param {Array<T>} array - The input array from which combinations are generated.\n * @returns {Array<[T, T]>} - An array of arrays, where each inner array contains a unique pair of elements.\n */\nfunction generateUniquePairs<T>(array: T[]): [T, T][] {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Generates all unique combinations of pairs from an array.\n *\n * @param vector<int> array - The input vector from which combinations are generated.\n * @returns vector<vector<int>> - A vector of vectors, where each inner vector contains a unique pair of elements.\n */\nvector<vector<int>> generateUniquePairs(const vector<int>& array) {}", "test_code": "TEST_CASE(\"generateUniquePairs\") {\n    SECTION(\"generates unique pairs from an array with three elements\") {\n        vector<variant<int, string, struct {string key;}>> items = {\"A\", \"B\", \"C\"};\n        auto result = generateUniquePairs(items);\n        REQUIRE(result == vector<vector<variant<int, string, struct {string key;}>>>{ \n            {\"A\", \"B\"},\n            {\"A\", \"C\"},\n            {\"B\", \"C\"}\n        });\n    }\n\n    SECTION(\"generates unique pairs from an array with two elements\") {\n        vector<variant<int, string, struct {string key;}>> items = {\"A\", \"B\"};\n        auto result = generateUniquePairs(items);\n        REQUIRE(result == vector<vector<variant<int, string, struct {string key;}>>>{ \n            {\"A\", \"B\"}\n        });\n    }\n\n    SECTION(\"returns an empty array when the input array is empty\") {\n        vector<variant<int, string, struct {string key;}>> items = {};\n        auto result = generateUniquePairs(items);\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"returns an empty array when the input array has one element\") {\n        vector<variant<int, string, struct {string key;}>> items = {\"A\"};\n        auto result = generateUniquePairs(items);\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"handles an array with different types of elements\") {\n        vector<variant<int, string, struct {string key;}>> items = {1, \"A\", { \"value\" }};\n        auto result = generateUniquePairs(items);\n        REQUIRE(result == vector<vector<variant<int, string, struct {string key;}>>>{ \n            {1, \"A\"},\n            {1, { \"value\" }},\n            {\"A\", { \"value\" }}\n        });\n    }\n\n    SECTION(\"generates pairs from an array with more than three elements\") {\n        vector<variant<int, string, struct {string key;}>> items = {\"A\", \"B\", \"C\", \"D\"};\n        auto result = generateUniquePairs(items);\n        REQUIRE(result == vector<vector<variant<int, string, struct {string key;}>>>{ \n            {\"A\", \"B\"},\n            {\"A\", \"C\"},\n            {\"A\", \"D\"},\n            {\"B\", \"C\"},\n            {\"B\", \"D\"},\n            {\"C\", \"D\"}\n        });\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Generates all unique combinations of pairs from an array.\n *\n * @param vector<int> array - The input vector from which combinations are generated.\n * @returns vector<vector<int>> - A vector of vectors, where each inner vector contains a unique pair of elements.\n */\nvector<vector<int>> generateUniquePairs(const vector<int>& array) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Generates all unique combinations of pairs from an array.\n *\n * @param array - The input array from which combinations are generated.\n * @returns - A list of lists, where each inner list contains a unique pair of elements.\n */\npublic List<List<T>> generateUniquePairs(T[] array) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testGenerateUniquePairsWithThreeElements() {\n        String[] items = {\"A\", \"B\", \"C\"};\n        List<List<String>> result = generateUniquePairs(items);\n        List<List<String>> expected = Arrays.asList(\n            Arrays.asList(\"A\", \"B\"),\n            Arrays.asList(\"A\", \"C\"),\n            Arrays.asList(\"B\", \"C\")\n        );\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testGenerateUniquePairsWithTwoElements() {\n        String[] items = {\"A\", \"B\"};\n        List<List<String>> result = generateUniquePairs(items);\n        List<List<String>> expected = Arrays.asList(\n            Arrays.asList(\"A\", \"B\")\n        );\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testGenerateUniquePairsWithEmptyArray() {\n        String[] items = {};\n        List<List<String>> result = generateUniquePairs(items);\n        List<List<String>> expected = Arrays.asList();\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testGenerateUniquePairsWithOneElement() {\n        String[] items = {\"A\"};\n        List<List<String>> result = generateUniquePairs(items);\n        List<List<String>> expected = Arrays.asList();\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testGenerateUniquePairsWithDifferentTypes() {\n        Object[] items = {1, \"A\", new Object() { public String key = \"value\"; }};\n        List<List<Object>> result = generateUniquePairs(items);\n        List<List<Object>> expected = Arrays.asList(\n            Arrays.asList(1, \"A\"),\n            Arrays.asList(1, new Object() { public String key = \"value\"; }),\n            Arrays.asList(\"A\", new Object() { public String key = \"value\"; })\n        );\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testGenerateUniquePairsWithMoreThanThreeElements() {\n        String[] items = {\"A\", \"B\", \"C\", \"D\"};\n        List<List<String>> result = generateUniquePairs(items);\n        List<List<String>> expected = Arrays.asList(\n            Arrays.asList(\"A\", \"B\"),\n            Arrays.asList(\"A\", \"C\"),\n            Arrays.asList(\"A\", \"D\"),\n            Arrays.asList(\"B\", \"C\"),\n            Arrays.asList(\"B\", \"D\"),\n            Arrays.asList(\"C\", \"D\")\n        );\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Generates all unique combinations of pairs from an array.\n *\n * @param array - The input array from which combinations are generated.\n * @returns - A list of lists, where each inner list contains a unique pair of elements.\n */\npublic List<List<T>> generateUniquePairs(T[] array) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 541, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Filters elements from an array based on a qualification function.", "language_version_list": {"python": {"code_signature": "def filter_array(unfiltered_array: list, is_qualified: callable) -> list:\n    \"\"\"\n    Filters elements from an array based on a qualification function.\n\n    Args:\n        unfiltered_array (list): The array to filter.\n        is_qualified (callable): A function that determines if an element qualifies.\n\n    Returns:\n        list: A new list containing the elements that qualify.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFilterArray(unittest.TestCase):\n\n    def test_filters_out_numbers_less_than_or_equal_to_ten(self):\n        unfiltered_array = [5, 12, 3, 18, 7, 10, 15]\n        result = filter_array(unfiltered_array, lambda x: x > 10)\n        self.assertEqual(result, [12, 18, 15])\n\n    def test_returns_empty_array_when_all_elements_are_disqualified(self):\n        unfiltered_array = [1, 2, 3, 4, 5]\n        result = filter_array(unfiltered_array, lambda x: x > 10)\n        self.assertEqual(result, [])\n\n    def test_returns_same_array_when_all_elements_are_qualified(self):\n        unfiltered_array = [11, 12, 15, 20]\n        result = filter_array(unfiltered_array, lambda x: x > 10)\n        self.assertEqual(result, [11, 12, 15, 20])\n\n    def test_handles_empty_array_input(self):\n        unfiltered_array = []\n        result = filter_array(unfiltered_array, lambda x: x > 10)\n        self.assertEqual(result, [])\n\n    def test_filters_out_strings_based_on_length(self):\n        unfiltered_array = ['a', 'ab', 'abc', 'abcd', 'abcde']\n        result = filter_array(unfiltered_array, lambda x: len(x)>3)\n        self.assertEqual(result, ['abcd', 'abcde'])\n\n    def test_correctly_filters_array_with_mixed_types(self):\n        unfiltered_array = [1, 'hello', True, 'world', None]\n        result = filter_array(unfiltered_array, lambda x: isinstance(x, str))\n        self.assertEqual(result, ['hello', 'world'])\n\n    def test_filters_based_on_object_property(self):\n        unfiltered_array = [{'value': 3}, {'value': 5}, {'value': 7}]\n        result = filter_array(unfiltered_array, lambda x: x > 5)\n        self.assertEqual(result, [{'value': 7}])\n\n    def test_returns_empty_array_when_no_qualifying_function_provided(self):\n        unfiltered_array = [1, 2, 3, 4, 5]\n        result = filter_array(unfiltered_array, lambda x: False)  # Always returns false\n        self.assertEqual(result, [])\n", "prompt": "please write a python function , the function signature as below def filter_array(unfiltered_array: list, is_qualified: callable) -> list:\n    \"\"\"\n    Filters elements from an array based on a qualification function.\n\n    Args:\n        unfiltered_array (list): The array to filter.\n        is_qualified (callable): A function that determines if an element qualifies.\n\n    Returns:\n        list: A new list containing the elements that qualify.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Filters elements from an array based on a qualification function.\n *\n * @param {Array} unfilteredArray - The array to filter.\n * @param {Function} isQualified - The function that determines if an element qualifies.\n * @returns {Array} - A new array containing the elements that qualify.\n */\nfunction filterArray(unfilteredArray, isQualified) {\n}", "test_code": "describe('filterArray', () => {\n    // Qualification function that checks if a number is greater than 10\n    const isGreaterThanTen = (num) => num > 10;\n\n    test('filters out numbers less than or equal to 10', () => {\n        const unfilteredArray = [5, 12, 3, 18, 7, 10, 15];\n        const result = filterArray(unfilteredArray, isGreaterThanTen);\n        expect(result).toEqual([12, 18, 15]);\n    });\n\n    test('returns an empty array when all elements are disqualified', () => {\n        const unfilteredArray = [1, 2, 3, 4, 5];\n        const result = filterArray(unfilteredArray, isGreaterThanTen);\n        expect(result).toEqual([]);\n    });\n\n    test('returns the same array when all elements are qualified', () => {\n        const unfilteredArray = [11, 12, 15, 20];\n        const result = filterArray(unfilteredArray, isGreaterThanTen);\n        expect(result).toEqual([11, 12, 15, 20]);\n    });\n\n    test('handles an empty array input', () => {\n        const unfilteredArray = [];\n        const result = filterArray(unfilteredArray, isGreaterThanTen);\n        expect(result).toEqual([]);\n    });\n\n    test('filters out strings based on length', () => {\n        const isLongerThanThreeChars = (str) => str.length > 3;\n        const unfilteredArray = ['a', 'ab', 'abc', 'abcd', 'abcde'];\n        const result = filterArray(unfilteredArray, isLongerThanThreeChars);\n        expect(result).toEqual(['abcd', 'abcde']);\n    });\n\n    test('correctly filters an array with mixed types', () => {\n        const isString = (item) => typeof item === 'string';\n        const unfilteredArray = [1, 'hello', true, 'world', null];\n        const result = filterArray(unfilteredArray, isString);\n        expect(result).toEqual(['hello', 'world']);\n    });\n\n    test('filters based on an object property', () => {\n        const hasValueGreaterThanFive = (obj) => obj.value > 5;\n        const unfilteredArray = [{ value: 3 }, { value: 5 }, { value: 7 }];\n        const result = filterArray(unfilteredArray, hasValueGreaterThanFive);\n        expect(result).toEqual([{ value: 7 }]);\n    });\n\n    test('returns an empty array when no qualifying function is provided', () => {\n        const unfilteredArray = [1, 2, 3, 4, 5];\n        const result = filterArray(unfilteredArray, () => false); // Always returns false\n        expect(result).toEqual([]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Filters elements from an array based on a qualification function.\n *\n * @param {Array} unfilteredArray - The array to filter.\n * @param {Function} isQualified - The function that determines if an element qualifies.\n * @returns {Array} - A new array containing the elements that qualify.\n */\nfunction filterArray(unfilteredArray, isQualified) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Filters elements from an array based on a qualification function.\n *\n * @param {T[]} unfilteredArray - The array to filter.\n * @param {(element: T) => boolean} isQualified - The function that determines if an element qualifies.\n * @returns {T[]} - A new array containing the elements that qualify.\n */\nfunction filterArray<T>(unfilteredArray: T[], isQualified: (element: T) => boolean): T[] {\n}", "test_code": "describe('filterArray', () => {\n    // Qualification function that checks if a number is greater than 10\n    const isGreaterThanTen = (num: number): boolean => num > 10;\n\n    test('filters out numbers less than or equal to 10', () => {\n        const unfilteredArray: number[] = [5, 12, 3, 18, 7, 10, 15];\n        const result = filterArray(unfilteredArray, isGreaterThanTen);\n        expect(result).toEqual([12, 18, 15]);\n    });\n\n    test('returns an empty array when all elements are disqualified', () => {\n        const unfilteredArray: number[] = [1, 2, 3, 4, 5];\n        const result = filterArray(unfilteredArray, isGreaterThanTen);\n        expect(result).toEqual([]);\n    });\n\n    test('returns the same array when all elements are qualified', () => {\n        const unfilteredArray: number[] = [11, 12, 15, 20];\n        const result = filterArray(unfilteredArray, isGreaterThanTen);\n        expect(result).toEqual([11, 12, 15, 20]);\n    });\n\n    test('handles an empty array input', () => {\n        const unfilteredArray: number[] = [];\n        const result = filterArray(unfilteredArray, isGreaterThanTen);\n        expect(result).toEqual([]);\n    });\n\n    test('filters out strings based on length', () => {\n        const isLongerThanThreeChars = (str: string): boolean => str.length > 3;\n        const unfilteredArray: string[] = ['a', 'ab', 'abc', 'abcd', 'abcde'];\n        const result = filterArray(unfilteredArray, isLongerThanThreeChars);\n        expect(result).toEqual(['abcd', 'abcde']);\n    });\n\n    test('correctly filters an array with mixed types', () => {\n        const isString = (item: unknown): item is string => typeof item === 'string';\n        const unfilteredArray: (number | string | boolean | null)[] = [1, 'hello', true, 'world', null];\n        const result = filterArray(unfilteredArray, isString);\n        expect(result).toEqual(['hello', 'world']);\n    });\n\n    test('filters based on an object property', () => {\n        const hasValueGreaterThanFive = (obj: { value: number }): boolean => obj.value > 5;\n        const unfilteredArray = [{ value: 3 }, { value: 5 }, { value: 7 }];\n        const result = filterArray(unfilteredArray, hasValueGreaterThanFive);\n        expect(result).toEqual([{ value: 7 }]);\n    });\n\n    test('returns an empty array when no qualifying function is provided', () => {\n        const unfilteredArray: number[] = [1, 2, 3, 4, 5];\n        const result = filterArray(unfilteredArray, () => false); // Always returns false\n        expect(result).toEqual([]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Filters elements from an array based on a qualification function.\n *\n * @param {T[]} unfilteredArray - The array to filter.\n * @param {(element: T) => boolean} isQualified - The function that determines if an element qualifies.\n * @returns {T[]} - A new array containing the elements that qualify.\n */\nfunction filterArray<T>(unfilteredArray: T[], isQualified: (element: T) => boolean): T[] {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Filters elements from a vector based on a qualification function.\n *\n * @param unfilteredArray - The vector to filter.\n * @param isQualified - The function that determines if an element qualifies.\n * @returns A new vector containing the elements that qualify.\n */\ntemplate <typename T>\nstd::vector<T> filterArray(const std::vector<T>& unfilteredArray, std::function<bool(const T&)> isQualified) {\n}", "test_code": "TEST_CASE(\"filterArray\") {\n    // Qualification function that checks if a number is greater than 10\n    auto isGreaterThanTen = [](int num) { return num > 10; };\n\n    SECTION(\"filters out numbers less than or equal to 10\") {\n        std::vector<int> unfilteredArray = {5, 12, 3, 18, 7, 10, 15};\n        auto result = filterArray(unfilteredArray, isGreaterThanTen);\n        REQUIRE(result == std::vector<int>({12, 18, 15}));\n    }\n\n    SECTION(\"returns an empty array when all elements are disqualified\") {\n        std::vector<int> unfilteredArray = {1, 2, 3, 4, 5};\n        auto result = filterArray(unfilteredArray, isGreaterThanTen);\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"returns the same array when all elements are qualified\") {\n        std::vector<int> unfilteredArray = {11, 12, 15, 20};\n        auto result = filterArray(unfilteredArray, isGreaterThanTen);\n        REQUIRE(result == std::vector<int>({11, 12, 15, 20}));\n    }\n\n    SECTION(\"handles an empty array input\") {\n        std::vector<int> unfilteredArray = {};\n        auto result = filterArray(unfilteredArray, isGreaterThanTen);\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"filters out strings based on length\") {\n        auto isLongerThanThreeChars = [](const std::string& str) { return str.length() > 3; };\n        std::vector<std::string> unfilteredArray = {\"a\", \"ab\", \"abc\", \"abcd\", \"abcde\"};\n        auto result = filterArray(unfilteredArray, isLongerThanThreeChars);\n        REQUIRE(result == std::vector<std::string>({\"abcd\", \"abcde\"}));\n    }\n\n    SECTION(\"correctly filters an array with mixed types\") {\n        auto isString = [](const std::variant<int, std::string, bool, std::nullptr_t>& item) {\n            return std::holds_alternative<std::string>(item);\n        };\n        std::vector<std::variant<int, std::string, bool, std::nullptr_t>> unfilteredArray = {1, \"hello\", true, \"world\", nullptr};\n        auto result = filterArray(unfilteredArray, isString);\n        REQUIRE(result == std::vector<std::variant<int, std::string, bool, std::nullptr_t>>({\"hello\", \"world\"}));\n    }\n\n    SECTION(\"filters based on an object property\") {\n        auto hasValueGreaterThanFive = [](const std::map<std::string, int>& obj) { return obj.at(\"value\") > 5; };\n        std::vector<std::map<std::string, int>> unfilteredArray = {{{\"value\", 3}}, {{\"value\", 5}}, {{\"value\", 7}}};\n        auto result = filterArray(unfilteredArray, hasValueGreaterThanFive);\n        REQUIRE(result == std::vector<std::map<std::string, int>>({{{\"value\", 7}}}));\n    }\n\n    SECTION(\"returns an empty array when no qualifying function is provided\") {\n        std::vector<int> unfilteredArray = {1, 2, 3, 4, 5};\n        auto result = filterArray(unfilteredArray, [](int) { return false; }); // Always returns false\n        REQUIRE(result.empty());\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Filters elements from a vector based on a qualification function.\n *\n * @param unfilteredArray - The vector to filter.\n * @param isQualified - The function that determines if an element qualifies.\n * @returns A new vector containing the elements that qualify.\n */\ntemplate <typename T>\nstd::vector<T> filterArray(const std::vector<T>& unfilteredArray, std::function<bool(const T&)> isQualified) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Filters elements from a list based on a qualification function.\n *\n * @param <T> - The type of elements in the list.\n * @param unfilteredList - The list to filter.\n * @param isQualified - The function that determines if an element qualifies.\n * @return - A new list containing the elements that qualify.\n */\npublic static <T> List<T> filterList(List<T> unfilteredList, Predicate<T> isQualified) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Predicate;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    // Qualification function that checks if a number is greater than 10\n    private Predicate<Integer> isGreaterThanTen = num -> num > 10;\n\n    @Test\n    public void testFiltersOutNumbersLessThanOrEqualToTen() {\n        List<Integer> unfilteredList = Arrays.asList(5, 12, 3, 18, 7, 10, 15);\n        List<Integer> result = Answer.filterList(unfilteredList, isGreaterThanTen);\n        assertEquals(Arrays.asList(12, 18, 15), result);\n    }\n\n    @Test\n    public void testReturnsEmptyListWhenAllElementsAreDisqualified() {\n        List<Integer> unfilteredList = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> result = Answer.filterList(unfilteredList, isGreaterThanTen);\n        assertEquals(Arrays.asList(), result);\n    }\n\n    @Test\n    public void testReturnsSameListWhenAllElementsAreQualified() {\n        List<Integer> unfilteredList = Arrays.asList(11, 12, 15, 20);\n        List<Integer> result = Answer.filterList(unfilteredList, isGreaterThanTen);\n        assertEquals(Arrays.asList(11, 12, 15, 20), result);\n    }\n\n    @Test\n    public void testHandlesEmptyListInput() {\n        List<Integer> unfilteredList = Arrays.asList();\n        List<Integer> result = Answer.filterList(unfilteredList, isGreaterThanTen);\n        assertEquals(Arrays.asList(), result);\n    }\n\n    @Test\n    public void testFiltersOutStringsBasedOnLength() {\n        Predicate<String> isLongerThanThreeChars = str -> str.length() > 3;\n        List<String> unfilteredList = Arrays.asList(\"a\", \"ab\", \"abc\", \"abcd\", \"abcde\");\n        List<String> result = Answer.filterList(unfilteredList, isLongerThanThreeChars);\n        assertEquals(Arrays.asList(\"abcd\", \"abcde\"), result);\n    }\n\n    @Test\n    public void testCorrectlyFiltersArrayWithMixedTypes() {\n        Predicate<Object> isString = item -> item instanceof String;\n        List<Object> unfilteredList = Arrays.asList(1, \"hello\", true, \"world\", null);\n        List<Object> result = Answer.filterList(unfilteredList, isString);\n        assertEquals(Arrays.asList(\"hello\", \"world\"), result);\n    }\n\n\n    @Test\n    public void testReturnsEmptyListWhenNoQualifyingFunctionProvided() {\n        List<Integer> unfilteredList = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> result = Answer.filterList(unfilteredList, num -> false); // Always returns false\n        assertEquals(Arrays.asList(), result);\n    }\n\n    // Helper class for the object property test\n    private static class Item {\n        int value;\n\n        Item(int value) {\n            this.value = value;\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Filters elements from a list based on a qualification function.\n *\n * @param <T> - The type of elements in the list.\n * @param unfilteredList - The list to filter.\n * @param isQualified - The function that determines if an element qualifies.\n * @return - A new list containing the elements that qualify.\n */\npublic static <T> List<T> filterList(List<T> unfilteredList, Predicate<T> isQualified) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 542, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Calculate the corresponding discount based on the given price and the actual price paid\n", "language_version_list": {"python": {"code_signature": "def calculate_discount(original_price: float, actual_price: float) -> float:\n    \"\"\"\n    Calculates the discount percentage based on the given price and the actual price paid.\n\n    Args:\n        original_price (float): The original price of the item.\n        actual_price (float): The actual price paid for the item.\n\n    Returns:\n        float: The discount percentage, rounded to two decimal places.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCalculateDiscount(unittest.TestCase):\n\n    def test_discount_25_percent(self):\n        self.assertEqual(calculate_discount(100, 75), 25.00)\n\n    def test_discount_0_percent(self):\n        self.assertEqual(calculate_discount(50, 50), 0.00)\n\n    def test_discount_100_percent(self):\n        self.assertEqual(calculate_discount(100, 0), 100.00)\n\n    def test_discount_50_percent(self):\n        self.assertEqual(calculate_discount(200, 100), 50.00)\n", "prompt": "please write a python function , the function signature as below def calculate_discount(original_price: float, actual_price: float) -> float:\n    \"\"\"\n    Calculates the discount percentage based on the given price and the actual price paid.\n\n    Args:\n        original_price (float): The original price of the item.\n        actual_price (float): The actual price paid for the item.\n\n    Returns:\n        float: The discount percentage, rounded to two decimal places.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculates the discount percentage based on the given price and the actual price paid.\n *\n * @param {number} originalPrice - The original price of the item.\n * @param {number} actualPrice - The actual price paid for the item.\n * @returns {number} - The discount percentage, rounded to two decimal places.\n */\nfunction calculateDiscount(originalPrice, actualPrice) {\n}", "test_code": "describe('calculateDiscount', () => {\n    test('should return 25.00% discount for original price of 100 and actual price of 75', () => {\n        expect(calculateDiscount(100, 75)).toBe(25.00);\n    });\n\n    test('should return 0.00% discount for original price of 50 and actual price of 50', () => {\n        expect(calculateDiscount(50, 50)).toBe(0.00);\n    });\n\n    test('should return 100.00% discount for original price of 100 and actual price of 0', () => {\n        expect(calculateDiscount(100, 0)).toBe(100.00);\n    });\n\n    test('should return 50.00% discount for original price of 200 and actual price of 100', () => {\n        expect(calculateDiscount(200, 100)).toBe(50.00);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the discount percentage based on the given price and the actual price paid.\n *\n * @param {number} originalPrice - The original price of the item.\n * @param {number} actualPrice - The actual price paid for the item.\n * @returns {number} - The discount percentage, rounded to two decimal places.\n */\nfunction calculateDiscount(originalPrice, actualPrice) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the discount percentage based on the given price and the actual price paid.\n *\n * @param {number} originalPrice - The original price of the item.\n * @param {number} actualPrice - The actual price paid for the item.\n * @returns {number} - The discount percentage, rounded to two decimal places.\n */\nfunction calculateDiscount(originalPrice: number, actualPrice: number): number {\n}", "test_code": "describe('calculateDiscount', () => {\n    test('should return 25.00% discount for original price of 100 and actual price of 75', () => {\n        expect(calculateDiscount(100, 75)).toBe(25.00);\n    });\n\n    test('should return 0.00% discount for original price of 50 and actual price of 50', () => {\n        expect(calculateDiscount(50, 50)).toBe(0.00);\n    });\n\n    test('should return 100.00% discount for original price of 100 and actual price of 0', () => {\n        expect(calculateDiscount(100, 0)).toBe(100.00);\n    });\n\n    test('should return 50.00% discount for original price of 200 and actual price of 100', () => {\n        expect(calculateDiscount(200, 100)).toBe(50.00);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the discount percentage based on the given price and the actual price paid.\n *\n * @param {number} originalPrice - The original price of the item.\n * @param {number} actualPrice - The actual price paid for the item.\n * @returns {number} - The discount percentage, rounded to two decimal places.\n */\nfunction calculateDiscount(originalPrice: number, actualPrice: number): number {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculates the discount percentage based on the given price and the actual price paid.\n *\n * @param originalPrice - The original price of the item.\n * @param actualPrice - The actual price paid for the item.\n * @returns The discount percentage, rounded to two decimal places.\n */\ndouble calculateDiscount(double originalPrice, double actualPrice) {\n}", "test_code": "TEST_CASE(\"calculateDiscount\", \"[discount]\") {\n    SECTION(\"should return 25.00% discount for original price of 100 and actual price of 75\") {\n        REQUIRE(calculateDiscount(100, 75) == Approx(25.00).margin(0.01));\n    }\n\n    SECTION(\"should return 0.00% discount for original price of 50 and actual price of 50\") {\n        REQUIRE(calculateDiscount(50, 50) == Approx(0.00).margin(0.01));\n    }\n\n    SECTION(\"should return 100.00% discount for original price of 100 and actual price of 0\") {\n        REQUIRE(calculateDiscount(100, 0) == Approx(100.00).margin(0.01));\n    }\n\n    SECTION(\"should return 50.00% discount for original price of 200 and actual price of 100\") {\n        REQUIRE(calculateDiscount(200, 100) == Approx(50.00).margin(0.01));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculates the discount percentage based on the given price and the actual price paid.\n *\n * @param originalPrice - The original price of the item.\n * @param actualPrice - The actual price paid for the item.\n * @returns The discount percentage, rounded to two decimal places.\n */\ndouble calculateDiscount(double originalPrice, double actualPrice) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the discount percentage based on the given price and the actual price paid.\n *\n * @param originalPrice - The original price of the item.\n * @param actualPrice - The actual price paid for the item.\n * @return - The discount percentage, rounded to two decimal places.\n */\npublic static double calculateDiscount(double originalPrice, double actualPrice) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testCalculateDiscount1() {\n        assertEquals(25.00, calculateDiscount(100, 75), 0.01);\n    }\n\n    @Test\n    public void testCalculateDiscount2() {\n        assertEquals(0.00, calculateDiscount(50, 50), 0.01);\n    }\n\n    @Test\n    public void testCalculateDiscount3() {\n        assertEquals(100.00, calculateDiscount(100, 0), 0.01);\n    }\n\n    @Test\n    public void testCalculateDiscount4() {\n        assertEquals(50.00, calculateDiscount(200, 100), 0.01);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the discount percentage based on the given price and the actual price paid.\n *\n * @param originalPrice - The original price of the item.\n * @param actualPrice - The actual price paid for the item.\n * @return - The discount percentage, rounded to two decimal places.\n */\npublic static double calculateDiscount(double originalPrice, double actualPrice) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 543, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Increment the entered number. For non-positive numbers (less than or equal to 0), return the original value directly, and for positive numbers, return the value plus 1.\n", "language_version_list": {"python": {"code_signature": "def increment_number(num: float) -> float:\n    \"\"\"\n    Increments the entered number.\n\n    If the number is non-positive (<= 0), returns the original value.\n    If the number is positive, returns the value plus 1.\n\n    Args:\n        num (float): The number to increment.\n\n    Returns:\n        float: The incremented value or the original number.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIncrementNumber(unittest.TestCase):\n\n    def test_input_5(self):\n        self.assertEqual(increment_number(5), 6)\n\n    def test_input_0(self):\n        self.assertEqual(increment_number(0), 0)\n\n    def test_input_negative_3(self):\n        self.assertEqual(increment_number(-3), -3)\n\n    def test_input_0_5(self):\n        self.assertEqual(increment_number(0.5), 1.5)\n\n    def test_input_1(self):\n        self.assertEqual(increment_number(1), 2)\n\n    def test_input_negative_1(self):\n        self.assertEqual(increment_number(-1), -1)\n", "prompt": "please write a python function , the function signature as below def increment_number(num: float) -> float:\n    \"\"\"\n    Increments the entered number.\n\n    If the number is non-positive (<= 0), returns the original value.\n    If the number is positive, returns the value plus 1.\n\n    Args:\n        num (float): The number to increment.\n\n    Returns:\n        float: The incremented value or the original number.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Increments the entered number.\n * If the number is non-positive (<= 0), returns the original value.\n * If the number is positive, returns the value plus 1.\n *\n * @param {number} num - The number to increment.\n * @returns {number} - The incremented value or the original number.\n */\nfunction incrementNumber(num) {\n}", "test_code": "describe('incrementNumber', () => {\n    test('should return 6 when input is 5', () => {\n        expect(incrementNumber(5)).toBe(6);\n    });\n\n    test('should return 0 when input is 0', () => {\n        expect(incrementNumber(0)).toBe(0);\n    });\n\n    test('should return -3 when input is -3', () => {\n        expect(incrementNumber(-3)).toBe(-3);\n    });\n\n    test('should return 1 when input is 0.5', () => {\n        expect(incrementNumber(0.5)).toBe(1.5);\n    });\n\n    test('should return 1 when input is 1', () => {\n        expect(incrementNumber(1)).toBe(2);\n    });\n\n    test('should return -1 when input is -1', () => {\n        expect(incrementNumber(-1)).toBe(-1);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Increments the entered number.\n * If the number is non-positive (<= 0), returns the original value.\n * If the number is positive, returns the value plus 1.\n *\n * @param {number} num - The number to increment.\n * @returns {number} - The incremented value or the original number.\n */\nfunction incrementNumber(num) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Increments the entered number.\n * If the number is non-positive (<= 0), returns the original value.\n * If the number is positive, returns the value plus 1.\n *\n * @param {number} num - The number to increment.\n * @returns {number} - The incremented value or the original number.\n */\nfunction incrementNumber(num: number): number {\n}", "test_code": "describe('incrementNumber', () => {\n    test('should return 6 when input is 5', () => {\n        expect(incrementNumber(5)).toBe(6);\n    });\n\n    test('should return 0 when input is 0', () => {\n        expect(incrementNumber(0)).toBe(0);\n    });\n\n    test('should return -3 when input is -3', () => {\n        expect(incrementNumber(-3)).toBe(-3);\n    });\n\n    test('should return 1 when input is 0.5', () => {\n        expect(incrementNumber(0.5)).toBe(1.5);\n    });\n\n    test('should return 2 when input is 1', () => {\n        expect(incrementNumber(1)).toBe(2);\n    });\n\n    test('should return -1 when input is -1', () => {\n        expect(incrementNumber(-1)).toBe(-1);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Increments the entered number.\n * If the number is non-positive (<= 0), returns the original value.\n * If the number is positive, returns the value plus 1.\n *\n * @param {number} num - The number to increment.\n * @returns {number} - The incremented value or the original number.\n */\nfunction incrementNumber(num: number): number {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Increments the entered number.\n * If the number is non-positive (<= 0), returns the original value.\n * If the number is positive, returns the value plus 1.\n *\n * @param num - The number to increment.\n * @returns The incremented value or the original number.\n */\nint incrementNumber(int num) {\n}", "test_code": "TEST_CASE(\"incrementNumber\") {\n    REQUIRE(incrementNumber(5) == 6);\n    REQUIRE(incrementNumber(0) == 0);\n    REQUIRE(incrementNumber(-3) == -3);\n    REQUIRE(incrementNumber(0.5) == 1.5);\n    REQUIRE(incrementNumber(1) == 2);\n    REQUIRE(incrementNumber(-1) == -1);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Increments the entered number.\n * If the number is non-positive (<= 0), returns the original value.\n * If the number is positive, returns the value plus 1.\n *\n * @param num - The number to increment.\n * @returns The incremented value or the original number.\n */\nint incrementNumber(int num) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Increments the entered number.\n * If the number is non-positive (<= 0), returns the original value.\n * If the number is positive, returns the value plus 1.\n *\n * @param num The number to increment.\n * @return The incremented value or the original number.\n */\npublic static int incrementNumber(int num) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testIncrementNumberInputFive() {\n        assertEquals(6, incrementNumber(5));\n    }\n\n    @Test\n    public void testIncrementNumberInputZero() {\n        assertEquals(0, incrementNumber(0));\n    }\n\n    @Test\n    public void testIncrementNumberInputNegativeThree() {\n        assertEquals(-3, incrementNumber(-3));\n    }\n    \n\n    @Test\n    public void testIncrementNumberInputOne() {\n        assertEquals(2, incrementNumber(1));\n    }\n\n    @Test\n    public void testIncrementNumberInputNegativeOne() {\n        assertEquals(-1, incrementNumber(-1));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Increments the entered number.\n * If the number is non-positive (<= 0), returns the original value.\n * If the number is positive, returns the value plus 1.\n *\n * @param num The number to increment.\n * @return The incremented value or the original number.\n */\npublic static int incrementNumber(int num) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 544, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Filter out all even numbers from the original array data", "language_version_list": {"python": {"code_signature": "from typing import List\n\ndef filter_out_even_numbers(array: List[int]) -> List[int]:\n    \"\"\"\n    Filters out all even numbers from an array.\n\n    Args:\n        array (List[int]): The array of numbers to filter.\n\n    Returns:\n        List[int]: A new array containing only the odd numbers.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFilterOutEvenNumbers(unittest.TestCase):\n\n    def test_removes_all_even_numbers_from_the_array(self):\n        input_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        result = filter_out_even_numbers(input_array)\n        self.assertEqual(result, [1, 3, 5, 7, 9])\n\n    def test_returns_empty_array_when_input_is_empty(self):\n        input_array = []\n        result = filter_out_even_numbers(input_array)\n        self.assertEqual(result, [])\n\n    def test_returns_same_array_if_all_numbers_are_odd(self):\n        input_array = [1, 3, 5, 7, 9]\n        result = filter_out_even_numbers(input_array)\n        self.assertEqual(result, [1, 3, 5, 7, 9])\n\n    def test_returns_empty_array_if_all_numbers_are_even(self):\n        input_array = [2, 4, 6, 8, 10]\n        result = filter_out_even_numbers(input_array)\n        self.assertEqual(result, [])\n\n    def test_handles_mixed_positive_and_negative_numbers(self):\n        input_array = [-3, -2, -1, 0, 1, 2, 3]\n        result = filter_out_even_numbers(input_array)\n        self.assertEqual(result, [-3, -1, 1, 3])\n\n    def test_handles_large_numbers_and_zero_correctly(self):\n        input_array = [0, 1000000000, 1000000001, 1000000002, 1000000003]\n        result = filter_out_even_numbers(input_array)\n        self.assertEqual(result, [1000000001, 1000000003])\n", "prompt": "please write a python function , the function signature as below from typing import List\n\ndef filter_out_even_numbers(array: List[int]) -> List[int]:\n    \"\"\"\n    Filters out all even numbers from an array.\n\n    Args:\n        array (List[int]): The array of numbers to filter.\n\n    Returns:\n        List[int]: A new array containing only the odd numbers.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Filters out all even numbers from an array.\n *\n * @param {number[]} array - The array of numbers to filter.\n * @returns {number[]} - A new array containing only the odd numbers.\n */\nfunction filterOutEvenNumbers(array) {\n}", "test_code": "describe('filterOutEvenNumbers', () => {\n    test('removes all even numbers from the array', () => {\n        const inputArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([1, 3, 5, 7, 9]);\n    });\n\n    test('returns an empty array when input is empty', () => {\n        const inputArray = [];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([]);\n    });\n\n    test('returns the same array if all numbers are odd', () => {\n        const inputArray = [1, 3, 5, 7, 9];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([1, 3, 5, 7, 9]);\n    });\n\n    test('returns an empty array if all numbers are even', () => {\n        const inputArray = [2, 4, 6, 8, 10];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([]);\n    });\n\n    test('handles mixed positive and negative numbers', () => {\n        const inputArray = [-3, -2, -1, 0, 1, 2, 3];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([-3, -1, 1, 3]);\n    });\n\n    test('handles large numbers and zero correctly', () => {\n        const inputArray = [0, 1000000000, 1000000001, 1000000002, 1000000003];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([1000000001, 1000000003]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Filters out all even numbers from an array.\n *\n * @param {number[]} array - The array of numbers to filter.\n * @returns {number[]} - A new array containing only the odd numbers.\n */\nfunction filterOutEvenNumbers(array) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Filters out all even numbers from an array.\n *\n * @param {number[]} array - The array of numbers to filter.\n * @returns {number[]} - A new array containing only the odd numbers.\n */\nfunction filterOutEvenNumbers(array: number[]): number[] {\n}", "test_code": "describe('filterOutEvenNumbers', () => {\n    test('removes all even numbers from the array', () => {\n        const inputArray: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        const result: number[] = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([1, 3, 5, 7, 9]);\n    });\n\n    test('returns an empty array when input is empty', () => {\n        const inputArray: number[] = [];\n        const result: number[] = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([]);\n    });\n\n    test('returns the same array if all numbers are odd', () => {\n        const inputArray: number[] = [1, 3, 5, 7, 9];\n        const result: number[] = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([1, 3, 5, 7, 9]);\n    });\n\n    test('returns an empty array if all numbers are even', () => {\n        const inputArray: number[] = [2, 4, 6, 8, 10];\n        const result: number[] = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([]);\n    });\n\n    test('handles mixed positive and negative numbers', () => {\n        const inputArray: number[] = [-3, -2, -1, 0, 1, 2, 3];\n        const result: number[] = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([-3, -1, 1, 3]);\n    });\n\n    test('handles large numbers and zero correctly', () => {\n        const inputArray: number[] = [0, 1000000000, 1000000001, 1000000002, 1000000003];\n        const result: number[] = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([1000000001, 1000000003]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Filters out all even numbers from an array.\n *\n * @param {number[]} array - The array of numbers to filter.\n * @returns {number[]} - A new array containing only the odd numbers.\n */\nfunction filterOutEvenNumbers(array: number[]): number[] {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Filters out all even numbers from an array.\n *\n * @param array - The vector of numbers to filter.\n * @returns A new vector containing only the odd numbers.\n */\nstd::vector<int> filterOutEvenNumbers(const std::vector<int>& array) {}", "test_code": "TEST_CASE(\"filterOutEvenNumbers\") {\n    SECTION(\"removes all even numbers from the array\") {\n        std::vector<int> inputArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        std::vector<int> result = filterOutEvenNumbers(inputArray);\n        REQUIRE(result == std::vector<int>{1, 3, 5, 7, 9});\n    }\n\n    SECTION(\"returns an empty array when input is empty\") {\n        std::vector<int> inputArray = {};\n        std::vector<int> result = filterOutEvenNumbers(inputArray);\n        REQUIRE(result == std::vector<int>{});\n    }\n\n    SECTION(\"returns the same array if all numbers are odd\") {\n        std::vector<int> inputArray = {1, 3, 5, 7, 9};\n        std::vector<int> result = filterOutEvenNumbers(inputArray);\n        REQUIRE(result == std::vector<int>{1, 3, 5, 7, 9});\n    }\n\n    SECTION(\"returns an empty array if all numbers are even\") {\n        std::vector<int> inputArray = {2, 4, 6, 8, 10};\n        std::vector<int> result = filterOutEvenNumbers(inputArray);\n        REQUIRE(result == std::vector<int>{});\n    }\n\n    SECTION(\"handles mixed positive and negative numbers\") {\n        std::vector<int> inputArray = {-3, -2, -1, 0, 1, 2, 3};\n        std::vector<int> result = filterOutEvenNumbers(inputArray);\n        REQUIRE(result == std::vector<int>{-3, -1, 1, 3});\n    }\n\n    SECTION(\"handles large numbers and zero correctly\") {\n        std::vector<int> inputArray = {0, 1000000000, 1000000001, 1000000002, 1000000003};\n        std::vector<int> result = filterOutEvenNumbers(inputArray);\n        REQUIRE(result == std::vector<int>{1000000001, 1000000003});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Filters out all even numbers from an array.\n *\n * @param array - The vector of numbers to filter.\n * @returns A new vector containing only the odd numbers.\n */\nstd::vector<int> filterOutEvenNumbers(const std::vector<int>& array) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Filters out all even numbers from an array.\n *\n * @param array - The array of numbers to filter.\n * @return - A new list containing only the odd numbers.\n */\npublic static List<Integer> filterOutEvenNumbers(int[] array) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testRemovesAllEvenNumbers() {\n        int[] inputArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        List<Integer> result = filterOutEvenNumbers(inputArray);\n        List<Integer> expected = Arrays.asList(1, 3, 5, 7, 9);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testReturnsEmptyArrayWhenInputIsEmpty() {\n        int[] inputArray = {};\n        List<Integer> result = filterOutEvenNumbers(inputArray);\n        List<Integer> expected = Arrays.asList();\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testReturnsSameArrayIfAllNumbersAreOdd() {\n        int[] inputArray = {1, 3, 5, 7, 9};\n        List<Integer> result = filterOutEvenNumbers(inputArray);\n        List<Integer> expected = Arrays.asList(1, 3, 5, 7, 9);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testReturnsEmptyArrayIfAllNumbersAreEven() {\n        int[] inputArray = {2, 4, 6, 8, 10};\n        List<Integer> result = filterOutEvenNumbers(inputArray);\n        List<Integer> expected = Arrays.asList();\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testHandlesMixedPositiveAndNegativeNumbers() {\n        int[] inputArray = {-3, -2, -1, 0, 1, 2, 3};\n        List<Integer> result = filterOutEvenNumbers(inputArray);\n        List<Integer> expected = Arrays.asList(-3, -1, 1, 3);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testHandlesLargeNumbersAndZeroCorrectly() {\n        int[] inputArray = {0, 1000000000, 1000000001, 1000000002, 1000000003};\n        List<Integer> result = filterOutEvenNumbers(inputArray);\n        List<Integer> expected = Arrays.asList(1000000001, 1000000003);\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Filters out all even numbers from an array.\n *\n * @param array - The array of numbers to filter.\n * @return - A new list containing only the odd numbers.\n */\npublic static List<Integer> filterOutEvenNumbers(int[] array) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 545, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Iterate through the array of elements until the first null is encountered, returning the array before the null is encountered", "language_version_list": {"python": {"code_signature": "from typing import List, Any\n\n\ndef elements_before_null(array: List[Any]) -> List[Any]:\n    \"\"\"\n    Iterates through the array of elements until the first None is encountered,\n    returning a new list that includes all elements before None.\n\n    Args:\n        array (List[Any]): The array to iterate through.\n\n    Returns:\n        List[Any]: A new list containing elements before the first None.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestElementsBeforeNull(unittest.TestCase):\n\n    def test_returns_elements_before_first_null(self):\n        input_array = ['element1', 'element2', None, 'element3', 'element4']\n        result = elements_before_null(input_array)\n        self.assertEqual(result, ['element1', 'element2'])\n\n    def test_returns_empty_array_when_input_is_empty(self):\n        input_array = []\n        result = elements_before_null(input_array)\n        self.assertEqual(result, [])\n\n    def test_returns_same_array_if_no_null(self):\n        input_array = ['element1', 'element2', 'element3']\n        result = elements_before_null(input_array)\n        self.assertEqual(result, ['element1', 'element2', 'element3'])\n\n    def test_returns_empty_array_if_first_element_is_null(self):\n        input_array = [None, 'element2', 'element3']\n        result = elements_before_null(input_array)\n        self.assertEqual(result, [])\n\n    def test_handles_mixed_types_with_null(self):\n        input_array = [1, 'text', None, True, False]\n        result = elements_before_null(input_array)\n        self.assertEqual(result, [1, 'text'])\n\n    def test_handles_array_with_only_null(self):\n        input_array = [None]\n        result = elements_before_null(input_array)\n        self.assertEqual(result, [])\n", "prompt": "please write a python function , the function signature as below from typing import List, Any\n\n\ndef elements_before_null(array: List[Any]) -> List[Any]:\n    \"\"\"\n    Iterates through the array of elements until the first None is encountered,\n    returning a new list that includes all elements before None.\n\n    Args:\n        array (List[Any]): The array to iterate through.\n\n    Returns:\n        List[Any]: A new list containing elements before the first None.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Iterates through the array of elements until the first null is encountered,\n * returning a new array that includes all elements before the null.\n *\n * @param {Array} array - The array to iterate through.\n * @returns {Array} - A new array containing elements before the first null.\n */\nfunction elementsBeforeNull(array) {\n}", "test_code": "\ndescribe('elementsBeforeNull', () => {\n    test('returns elements before the first null', () => {\n        const inputArray = ['element1', 'element2', null, 'element3', 'element4'];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual(['element1', 'element2']);\n    });\n\n    test('returns an empty array when input is empty', () => {\n        const inputArray = [];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual([]);\n    });\n\n    test('returns the same array if there is no null', () => {\n        const inputArray = ['element1', 'element2', 'element3'];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual(['element1', 'element2', 'element3']);\n    });\n\n    test('returns an empty array if the first element is null', () => {\n        const inputArray = [null, 'element2', 'element3'];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual([]);\n    });\n\n    test('handles mixed types with null', () => {\n        const inputArray = [1, 'text', null, true, false];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual([1, 'text']);\n    });\n\n    test('handles an array with only null', () => {\n        const inputArray = [null];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual([]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Iterates through the array of elements until the first null is encountered,\n * returning a new array that includes all elements before the null.\n *\n * @param {Array} array - The array to iterate through.\n * @returns {Array} - A new array containing elements before the first null.\n */\nfunction elementsBeforeNull(array) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Iterates through the array of elements until the first null is encountered,\n * returning a new array that includes all elements before the null.\n *\n * @param {Array<any>} array - The array to iterate through.\n * @returns {Array<any>} - A new array containing elements before the first null.\n */\nfunction elementsBeforeNull(array: Array<any>): Array<any> {}", "test_code": "describe('elementsBeforeNull', () => {\n    test('returns elements before the first null', () => {\n        const inputArray: (string | null)[] = ['element1', 'element2', null, 'element3', 'element4'];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual(['element1', 'element2']);\n    });\n\n    test('returns an empty array when input is empty', () => {\n        const inputArray: (string | null)[] = [];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual([]);\n    });\n\n    test('returns the same array if there is no null', () => {\n        const inputArray: string[] = ['element1', 'element2', 'element3'];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual(['element1', 'element2', 'element3']);\n    });\n\n    test('returns an empty array if the first element is null', () => {\n        const inputArray: (string | null)[] = [null, 'element2', 'element3'];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual([]);\n    });\n\n    test('handles mixed types with null', () => {\n        const inputArray: (number | string | boolean | null)[] = [1, 'text', null, true, false];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual([1, 'text']);\n    });\n\n    test('handles an array with only null', () => {\n        const inputArray: (null)[] = [null];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual([]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Iterates through the array of elements until the first null is encountered,\n * returning a new array that includes all elements before the null.\n *\n * @param {Array<any>} array - The array to iterate through.\n * @returns {Array<any>} - A new array containing elements before the first null.\n */\nfunction elementsBeforeNull(array: Array<any>): Array<any> {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Iterates through the vector of elements until the first null is encountered,\n * returning a new vector that includes all elements before the null.\n *\n * @param std::vector<int*> array - The vector to iterate through.\n * @returns std::vector<int*> - A new vector containing elements before the first null.\n */\nstd::vector<int*> elementsBeforeNull(const std::vector<int*>& array) {\n}", "test_code": "TEST_CASE(\"elementsBeforeNull\") {\n    SECTION(\"returns elements before the first null\") {\n        std::vector<std::string> inputArray = {\"element1\", \"element2\", \"\", \"element3\", \"element4\"};\n        auto result = elementsBeforeNull(inputArray);\n        REQUIRE(result == std::vector<std::string>{\"element1\", \"element2\"});\n    }\n\n    SECTION(\"returns an empty array when input is empty\") {\n        std::vector<std::string> inputArray = {};\n        auto result = elementsBeforeNull(inputArray);\n        REQUIRE(result == std::vector<std::string>{});\n    }\n\n    SECTION(\"returns the same array if there is no null\") {\n        std::vector<std::string> inputArray = {\"element1\", \"element2\", \"element3\"};\n        auto result = elementsBeforeNull(inputArray);\n        REQUIRE(result == std::vector<std::string>{\"element1\", \"element2\", \"element3\"});\n    }\n\n    SECTION(\"returns an empty array if the first element is null\") {\n        std::vector<std::string> inputArray = {\"\", \"element2\", \"element3\"};\n        auto result = elementsBeforeNull(inputArray);\n        REQUIRE(result == std::vector<std::string>{});\n    }\n\n    SECTION(\"handles mixed types with null\") {\n        std::vector<std::variant<int, std::string, bool>> inputArray = {1, \"text\", std::monostate{}, true, false};\n        auto result = elementsBeforeNull(inputArray);\n        REQUIRE(result == std::vector<std::variant<int, std::string, bool>>{1, \"text\"});\n    }\n\n    SECTION(\"handles an array with only null\") {\n        std::vector<std::string> inputArray = {\"\"};\n        auto result = elementsBeforeNull(inputArray);\n        REQUIRE(result == std::vector<std::string>{});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Iterates through the vector of elements until the first null is encountered,\n * returning a new vector that includes all elements before the null.\n *\n * @param std::vector<int*> array - The vector to iterate through.\n * @returns std::vector<int*> - A new vector containing elements before the first null.\n */\nstd::vector<int*> elementsBeforeNull(const std::vector<int*>& array) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Iterates through the array of elements until the first null is encountered,\n * returning a new list that includes all elements before the null.\n *\n * @param array - The array to iterate through.\n * @returns - A new list containing elements before the first null.\n */\npublic static List<Object> elementsBeforeNull(Object[] array) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void returnsElementsBeforeTheFirstNull() {\n        Object[] inputArray = {\"element1\", \"element2\", null, \"element3\", \"element4\"};\n        List<Object> result = Answer.elementsBeforeNull(inputArray);\n        assertEquals(Arrays.asList(\"element1\", \"element2\"), result);\n    }\n\n    @Test\n    public void returnsAnEmptyArrayWhenInputIsEmpty() {\n        Object[] inputArray = {};\n        List<Object> result = Answer.elementsBeforeNull(inputArray);\n        assertEquals(Arrays.asList(), result);\n    }\n\n    @Test\n    public void returnsTheSameArrayIfThereIsNoNull() {\n        Object[] inputArray = {\"element1\", \"element2\", \"element3\"};\n        List<Object> result = Answer.elementsBeforeNull(inputArray);\n        assertEquals(Arrays.asList(\"element1\", \"element2\", \"element3\"), result);\n    }\n\n    @Test\n    public void returnsAnEmptyArrayIfTheFirstElementIsNull() {\n        Object[] inputArray = {null, \"element2\", \"element3\"};\n        List<Object> result = Answer.elementsBeforeNull(inputArray);\n        assertEquals(Arrays.asList(), result);\n    }\n\n    @Test\n    public void handlesMixedTypesWithNull() {\n        Object[] inputArray = {1, \"text\", null, true, false};\n        List<Object> result = Answer.elementsBeforeNull(inputArray);\n        assertEquals(Arrays.asList(1, \"text\"), result);\n    }\n\n    @Test\n    public void handlesAnArrayWithOnlyNull() {\n        Object[] inputArray = {null};\n        List<Object> result = Answer.elementsBeforeNull(inputArray);\n        assertEquals(Arrays.asList(), result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Iterates through the array of elements until the first null is encountered,\n * returning a new list that includes all elements before the null.\n *\n * @param array - The array to iterate through.\n * @returns - A new list containing elements before the first null.\n */\npublic static List<Object> elementsBeforeNull(Object[] array) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 559, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Check whether a file name is a cpp language header file", "language_version_list": {"python": {"code_signature": "def is_cpp_header_file(file_name: str) -> bool:\n    \"\"\"\n    Checks whether a file name is a C++ header file.\n\n    Args:\n        file_name (str): The name of the file to check.\n\n    Returns:\n        bool: Returns True if the file is a C++ header file, False otherwise.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsCppHeaderFile(unittest.TestCase):\n\n    def test_returns_true_for_h_file(self):\n        self.assertTrue(is_cpp_header_file('example.h'))\n\n    def test_returns_true_for_hpp_file(self):\n        self.assertTrue(is_cpp_header_file('example.hpp'))\n\n    def test_returns_false_for_non_header_file_extension(self):\n        self.assertFalse(is_cpp_header_file('example.txt'))\n\n    def test_returns_false_for_file_without_extension(self):\n        self.assertFalse(is_cpp_header_file('example'))\n\n    def test_returns_false_for_c_file(self):\n        self.assertFalse(is_cpp_header_file('example.c'))\n", "prompt": "please write a python function , the function signature as below def is_cpp_header_file(file_name: str) -> bool:\n    \"\"\"\n    Checks whether a file name is a C++ header file.\n\n    Args:\n        file_name (str): The name of the file to check.\n\n    Returns:\n        bool: Returns True if the file is a C++ header file, False otherwise.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Checks whether a file name is a C++ header file.\n *\n * @param {string} fileName - The name of the file to check.\n * @returns {boolean} - Returns true if the file is a C++ header file, false otherwise.\n */\nfunction isCppHeaderFile(fileName) {\n}", "test_code": "describe('isCppHeaderFile', () => {\n    test('returns true for a .h file', () => {\n        expect(isCppHeaderFile('example.h')).toBe(true);\n    });\n\n    test('returns true for a .hpp file', () => {\n        expect(isCppHeaderFile('example.hpp')).toBe(true);\n    });\n\n\n\n    test('returns false for a non-header file extension', () => {\n        expect(isCppHeaderFile('example.txt')).toBe(false);\n    });\n\n    test('returns false for a file without an extension', () => {\n        expect(isCppHeaderFile('example')).toBe(false);\n    });\n\n    test('returns false for a .c file', () => {\n        expect(isCppHeaderFile('example.c')).toBe(false);\n    });\n\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Checks whether a file name is a C++ header file.\n *\n * @param {string} fileName - The name of the file to check.\n * @returns {boolean} - Returns true if the file is a C++ header file, false otherwise.\n */\nfunction isCppHeaderFile(fileName) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Checks whether a file name is a C++ header file.\n *\n * @param {string} fileName - The name of the file to check.\n * @returns {boolean} - Returns true if the file is a C++ header file, false otherwise.\n */\nfunction isCppHeaderFile(fileName: string): boolean {}", "test_code": "describe('isCppHeaderFile', () => {\n    test('returns true for a .h file', () => {\n        expect(isCppHeaderFile('example.h')).toBe(true);\n    });\n\n    test('returns true for a .hpp file', () => {\n        expect(isCppHeaderFile('example.hpp')).toBe(true);\n    });\n\n    test('returns false for a non-header file extension', () => {\n        expect(isCppHeaderFile('example.txt')).toBe(false);\n    });\n\n    test('returns false for a file without an extension', () => {\n        expect(isCppHeaderFile('example')).toBe(false);\n    });\n\n    test('returns false for a .c file', () => {\n        expect(isCppHeaderFile('example.c')).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Checks whether a file name is a C++ header file.\n *\n * @param {string} fileName - The name of the file to check.\n * @returns {boolean} - Returns true if the file is a C++ header file, false otherwise.\n */\nfunction isCppHeaderFile(fileName: string): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Checks whether a file name is a C++ header file.\n *\n * @param fileName - The name of the file to check.\n * @returns true if the file is a C++ header file, false otherwise.\n */\nbool isCppHeaderFile(const std::string& fileName) {}", "test_code": "TEST_CASE(\"isCppHeaderFile\") {\n    SECTION(\"returns true for a .h file\") {\n        REQUIRE(isCppHeaderFile(\"example.h\") == true);\n    }\n\n    SECTION(\"returns true for a .hpp file\") {\n        REQUIRE(isCppHeaderFile(\"example.hpp\") == true);\n    }\n\n    SECTION(\"returns false for a non-header file extension\") {\n        REQUIRE(isCppHeaderFile(\"example.txt\") == false);\n    }\n\n    SECTION(\"returns false for a file without an extension\") {\n        REQUIRE(isCppHeaderFile(\"example\") == false);\n    }\n\n    SECTION(\"returns false for a .c file\") {\n        REQUIRE(isCppHeaderFile(\"example.c\") == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Checks whether a file name is a C++ header file.\n *\n * @param fileName - The name of the file to check.\n * @returns true if the file is a C++ header file, false otherwise.\n */\nbool isCppHeaderFile(const std::string& fileName) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks whether a file name is a C++ header file.\n *\n * @param fileName - The name of the file to check.\n * @returns - Returns true if the file is a C++ header file, false otherwise.\n */\npublic static boolean isCppHeaderFile(String fileName) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\nimport org.junit.Test;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testIsCppHeaderFile_HFile() {\n        assertTrue(isCppHeaderFile(\"example.h\"));\n    }\n\n    @Test\n    public void testIsCppHeaderFile_HppFile() {\n        assertTrue(isCppHeaderFile(\"example.hpp\"));\n    }\n\n    @Test\n    public void testIsCppHeaderFile_NonHeaderFile() {\n        assertFalse(isCppHeaderFile(\"example.txt\"));\n    }\n\n    @Test\n    public void testIsCppHeaderFile_NoExtension() {\n        assertFalse(isCppHeaderFile(\"example\"));\n    }\n\n    @Test\n    public void testIsCppHeaderFile_CFile() {\n        assertFalse(isCppHeaderFile(\"example.c\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks whether a file name is a C++ header file.\n *\n * @param fileName - The name of the file to check.\n * @returns - Returns true if the file is a C++ header file, false otherwise.\n */\npublic static boolean isCppHeaderFile(String fileName) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 560, "code_type": "method", "original_language": "javascript", "question_type": "Data processing and transformation", "summary": "Gets the line number in the content at the specified index.", "language_version_list": {"python": {"code_signature": "def get_line_number(content: str, index: int) -> int:\n    \"\"\"\n    Gets the line number in the content at the specified index.\n\n    Args:\n        content (str): The string content to check.\n        index (int): The character index to find the line number for.\n\n    Returns:\n        int: The line number corresponding to the given index.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGetLineNumber(unittest.TestCase):\n\n    def test_returns_1_for_first_character(self):\n        self.assertEqual(get_line_number(\"Line 1\\nLine 2\\nLine 3\", 0), 1)\n\n    def test_returns_1_for_last_character_of_first_line(self):\n        self.assertEqual(get_line_number(\"Line 1\\nLine 2\\nLine 3\", 5), 1)\n\n    def test_returns_3_for_last_character_of_third_line(self):\n        self.assertEqual(get_line_number(\"Line 1\\nLine 2\\nLine 3\", 18), 3)\n\n    def test_returns_1_for_single_line_string(self):\n        self.assertEqual(get_line_number(\"Single line string\", 0), 1)\n\n    def test_returns_3_for_index_in_multiline_string_with_trailing_newlines(self):\n        self.assertEqual(get_line_number(\"Line 1\\nLine 2\\nLine 3\\n\\n\", 15), 3)\n", "prompt": "please write a python function , the function signature as below def get_line_number(content: str, index: int) -> int:\n    \"\"\"\n    Gets the line number in the content at the specified index.\n\n    Args:\n        content (str): The string content to check.\n        index (int): The character index to find the line number for.\n\n    Returns:\n        int: The line number corresponding to the given index.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Gets the line number in the content at the specified index.\n *\n * @param {string} content - The string content to check.\n * @param {number} index - The character index to find the line number for.\n * @returns {number} - The line number corresponding to the given index.\n */\nfunction getLineNumber(content, index) {\n}", "test_code": "describe('getLineNumber', () => {\n    test('returns 1 for the first character', () => {\n        expect(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 0)).toBe(1);\n    });\n\n    test('returns 1 for the last character of the first line', () => {\n        expect(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 5)).toBe(1);\n    });\n\n    test('returns 3 for the last character of the third line', () => {\n        expect(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 18)).toBe(3);\n    });\n\n    test('returns 1 for a single line string', () => {\n        expect(getLineNumber(\"Single line string\", 0)).toBe(1);\n    });\n\n    test('returns 3 for an index within a multiline string with trailing newlines', () => {\n        expect(getLineNumber(\"Line 1\\nLine 2\\nLine 3\\n\\n\", 15)).toBe(3);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Gets the line number in the content at the specified index.\n *\n * @param {string} content - The string content to check.\n * @param {number} index - The character index to find the line number for.\n * @returns {number} - The line number corresponding to the given index.\n */\nfunction getLineNumber(content, index) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Gets the line number in the content at the specified index.\n *\n * @param {string} content - The string content to check.\n * @param {number} index - The character index to find the line number for.\n * @returns {number} - The line number corresponding to the given index.\n */\nfunction getLineNumber(content: string, index: number): number {\n}", "test_code": "describe('getLineNumber', () => {\n    test('returns 1 for the first character', () => {\n        expect(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 0)).toBe(1);\n    });\n\n    test('returns 1 for the last character of the first line', () => {\n        expect(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 5)).toBe(1);\n    });\n\n    test('returns 3 for the last character of the third line', () => {\n        expect(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 18)).toBe(3);\n    });\n\n    test('returns 1 for a single line string', () => {\n        expect(getLineNumber(\"Single line string\", 0)).toBe(1);\n    });\n\n    test('returns 3 for an index within a multiline string with trailing newlines', () => {\n        expect(getLineNumber(\"Line 1\\nLine 2\\nLine 3\\n\\n\", 15)).toBe(3);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Gets the line number in the content at the specified index.\n *\n * @param {string} content - The string content to check.\n * @param {number} index - The character index to find the line number for.\n * @returns {number} - The line number corresponding to the given index.\n */\nfunction getLineNumber(content: string, index: number): number {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Gets the line number in the content at the specified index.\n *\n * @param content - The string content to check.\n * @param index - The character index to find the line number for.\n * @returns The line number corresponding to the given index.\n */\nint getLineNumber(const std::string& content, size_t index){}", "test_code": "TEST_CASE(\"getLineNumber\") {\n    SECTION(\"returns 1 for the first character\") {\n        REQUIRE(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 0) == 1);\n    }\n\n    SECTION(\"returns 1 for the last character of the first line\") {\n        REQUIRE(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 5) == 1);\n    }\n\n    SECTION(\"returns 3 for the last character of the third line\") {\n        REQUIRE(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 18) == 3);\n    }\n\n    SECTION(\"returns 1 for a single line string\") {\n        REQUIRE(getLineNumber(\"Single line string\", 0) == 1);\n    }\n\n    SECTION(\"returns 3 for an index within a multiline string with trailing newlines\") {\n        REQUIRE(getLineNumber(\"Line 1\\nLine 2\\nLine 3\\n\\n\", 15) == 3);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Gets the line number in the content at the specified index.\n *\n * @param content - The string content to check.\n * @param index - The character index to find the line number for.\n * @returns The line number corresponding to the given index.\n */\nint getLineNumber(const std::string& content, size_t index){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Gets the line number in the content at the specified index.\n *\n * @param content The string content to check.\n * @param index The character index to find the line number for.\n * @return The line number corresponding to the given index.\n */\npublic static int getLineNumber(String content, int index) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testGetLineNumber_FirstCharacter() {\n        assertEquals(1, getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 0));\n    }\n\n    @Test\n    public void testGetLineNumber_LastCharacterOfFirstLine() {\n        assertEquals(1, getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 5));\n    }\n\n    @Test\n    public void testGetLineNumber_LastCharacterOfThirdLine() {\n        assertEquals(3, getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 18));\n    }\n\n    @Test\n    public void testGetLineNumber_SingleLineString() {\n        assertEquals(1, getLineNumber(\"Single line string\", 0));\n    }\n\n    @Test\n    public void testGetLineNumber_MultilineStringWithTrailingNewlines() {\n        assertEquals(3, getLineNumber(\"Line 1\\nLine 2\\nLine 3\\n\\n\", 15));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Gets the line number in the content at the specified index.\n *\n * @param content The string content to check.\n * @param index The character index to find the line number for.\n * @return The line number corresponding to the given index.\n */\npublic static int getLineNumber(String content, int index) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
