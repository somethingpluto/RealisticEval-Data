{"task_id": 170, "code_type": "method", "original_language": "java", "question_type": "Data processing and transformation", "summary": "convert the HTML string to the corresponding MarkDown formatted text. HTML tags that support conversion include a, strong, code, em, p, br, u, ul, li, ol\n", "language_version_list": {"python": {"code_signature": "def convert(html: str) -> str:\n    \"\"\"\n    Converts a string containing HTML to a Markdown-formatted string.\n\n    1. Line breaks (<br> or <br/>): Replaced with newline characters.\n    2. Paragraphs (<p> and </p>): Opening <p> tags are removed, while closing\n        </p> tags are replaced with two newline characters to separate paragraphs.\n    3. Strong emphasis (<strong> and </strong>): Replaced with double asterisks (**).\n    4. Italics (<em> and </em>): Replaced with single asterisks (*).\n    5. Underlined text (<u> and </u>): Replaced with single asterisks (*)\n        as underlining is not supported in Markdown.\n    6. Code snippets (<code> and </code>): Replaced with backticks (`).\n    7. Unordered lists (<ul> and </ul>): Opening and closing tags are removed.\n    8. Ordered lists (<ol> and </ol>): Opening and closing tags are removed.\n    9. List items (<li>): Opening <li> tags are replaced with an asterisk followed\n        by a space, while closing </li> tags are replaced with a newline character.\n    10. Hyperlinks (<a href=\"...\">...</a>): Replaced with the Markdown format\n        [text](URL), where \"text\" is the anchor text and \"URL\" is the link target.\n\n    Args:\n        html (str): The input string containing HTML content.\n\n    Returns:\n        str: A string formatted in Markdown, reflecting the input HTML structure.\n    \"\"\"", "test_code": "import unittest\n\nclass TestAnswer(unittest.TestCase):\n    \n    def test_simple_line_break(self):\n        input_html = \"Hello<br>World\"\n        expected_output = \"Hello\\nWorld\"\n        self.assertEqual(expected_output, convert(input_html))\n    \n    def test_strong_tags(self):\n        input_html = \"This is <strong>important</strong> text.\"\n        expected_output = \"This is **important** text.\"\n        self.assertEqual(expected_output, convert(input_html))\n    \n    def test_emphasis_tags(self):\n        input_html = \"This is <em>emphasized</em> text.\"\n        expected_output = \"This is *emphasized* text.\"\n        self.assertEqual(expected_output, convert(input_html))\n    \n    def test_unordered_list(self):\n        input_html = \"<ul><li>Item 1</li><li>Item 2</li></ul>\"\n        expected_output = \"* Item 1\\n* Item 2\\n\"\n        self.assertEqual(expected_output, convert(input_html))\n    \n    def test_anchor_tags(self):\n        input_html = 'Check this link: <a href=\"http://example.com\">Example</a>.'\n        expected_output = 'Check this link: [Example](http://example.com).'\n        self.assertEqual(expected_output, convert(input_html))", "prompt": "please write a python function , the function signature as below def convert(html: str) -> str:\n    \"\"\"\n    Converts a string containing HTML to a Markdown-formatted string.\n\n    1. Line breaks (<br> or <br/>): Replaced with newline characters.\n    2. Paragraphs (<p> and </p>): Opening <p> tags are removed, while closing\n        </p> tags are replaced with two newline characters to separate paragraphs.\n    3. Strong emphasis (<strong> and </strong>): Replaced with double asterisks (**).\n    4. Italics (<em> and </em>): Replaced with single asterisks (*).\n    5. Underlined text (<u> and </u>): Replaced with single asterisks (*)\n        as underlining is not supported in Markdown.\n    6. Code snippets (<code> and </code>): Replaced with backticks (`).\n    7. Unordered lists (<ul> and </ul>): Opening and closing tags are removed.\n    8. Ordered lists (<ol> and </ol>): Opening and closing tags are removed.\n    9. List items (<li>): Opening <li> tags are replaced with an asterisk followed\n        by a space, while closing </li> tags are replaced with a newline character.\n    10. Hyperlinks (<a href=\"...\">...</a>): Replaced with the Markdown format\n        [text](URL), where \"text\" is the anchor text and \"URL\" is the link target.\n\n    Args:\n        html (str): The input string containing HTML content.\n\n    Returns:\n        str: A string formatted in Markdown, reflecting the input HTML structure.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a string containing HTML to a Markdown-formatted string.\n *\n * 1. Line breaks (<br> or <br/>): Replaced with newline characters.\n * 2. Paragraphs (<p> and </p>): Opening <p> tags are removed, while closing\n *    </p> tags are replaced with two newline characters to separate paragraphs.\n * 3. Strong emphasis (<strong> and </strong>): Replaced with double asterisks (**).\n * 4. Italics (<em> and </em>): Replaced with single asterisks (*).\n * 5. Underlined text (<u> and </u>): Replaced with single asterisks (*)\n *    as underlining is not supported in Markdown.\n * 6. Code snippets (<code> and </code>): Replaced with backticks (`).\n * 7. Unordered lists (<ul> and </ul>): Opening and closing tags are removed.\n * 8. Ordered lists (<ol> and </ol>): Opening and closing tags are removed.\n * 9. List items (<li>): Opening <li> tags are replaced with an asterisk followed\n *    by a space, while closing </li> tags are replaced with a newline character.\n * 10. Hyperlinks (<a href=\"...\">...</a>): Replaced with the Markdown format\n *     [text](URL), where \"text\" is the anchor text and \"URL\" is the link target.\n *\n * @param {string} html - The input string containing HTML content.\n * @return {string} A string formatted in Markdown, reflecting the input HTML structure.\n */\nfunction convert(html) {}", "test_code": "describe('HTML to Markdown Converter', () => {\n  \n    test('testSimpleLineBreak', () => {\n        const input = 'Hello<br>World';\n        const expectedOutput = 'Hello\\nWorld';\n        expect(convert(input)).toBe(expectedOutput);\n    });\n\n    test('testStrongTags', () => {\n        const input = 'This is <strong>important</strong> text.';\n        const expectedOutput = 'This is **important** text.';\n        expect(convert(input)).toBe(expectedOutput);\n    });\n\n    test('testEmphasisTags', () => {\n        const input = 'This is <em>emphasized</em> text.';\n        const expectedOutput = 'This is *emphasized* text.';\n        expect(convert(input)).toBe(expectedOutput);\n    });\n\n    test('testUnorderedList', () => {\n        const input = '<ul><li>Item 1</li><li>Item 2</li></ul>';\n        const expectedOutput = '* Item 1\\n* Item 2\\n';\n        expect(convert(input)).toBe(expectedOutput);\n    });\n\n    test('testAnchorTags', () => {\n        const input = 'Check this link: <a href=\"http://example.com\">Example</a>.';\n        const expectedOutput = 'Check this link: [Example](http://example.com).';\n        expect(convert(input)).toBe(expectedOutput);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a string containing HTML to a Markdown-formatted string.\n *\n * 1. Line breaks (<br> or <br/>): Replaced with newline characters.\n * 2. Paragraphs (<p> and </p>): Opening <p> tags are removed, while closing\n *    </p> tags are replaced with two newline characters to separate paragraphs.\n * 3. Strong emphasis (<strong> and </strong>): Replaced with double asterisks (**).\n * 4. Italics (<em> and </em>): Replaced with single asterisks (*).\n * 5. Underlined text (<u> and </u>): Replaced with single asterisks (*)\n *    as underlining is not supported in Markdown.\n * 6. Code snippets (<code> and </code>): Replaced with backticks (`).\n * 7. Unordered lists (<ul> and </ul>): Opening and closing tags are removed.\n * 8. Ordered lists (<ol> and </ol>): Opening and closing tags are removed.\n * 9. List items (<li>): Opening <li> tags are replaced with an asterisk followed\n *    by a space, while closing </li> tags are replaced with a newline character.\n * 10. Hyperlinks (<a href=\"...\">...</a>): Replaced with the Markdown format\n *     [text](URL), where \"text\" is the anchor text and \"URL\" is the link target.\n *\n * @param {string} html - The input string containing HTML content.\n * @return {string} A string formatted in Markdown, reflecting the input HTML structure.\n */\nfunction convert(html) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a string containing HTML to a Markdown-formatted string.\n *\n * 1. Line breaks (<br> or <br/>): Replaced with newline characters.\n * 2. Paragraphs (<p> and </p>): Opening <p> tags are removed, while closing\n *    </p> tags are replaced with two newline characters to separate paragraphs.\n * 3. Strong emphasis (<strong> and </strong>): Replaced with double asterisks (**).\n * 4. Italics (<em> and </em>): Replaced with single asterisks (*).\n * 5. Underlined text (<u> and </u>): Replaced with single asterisks (*)\n *    as underlining is not supported in Markdown.\n * 6. Code snippets (<code> and </code>): Replaced with backticks (`).\n * 7. Unordered lists (<ul> and </ul>): Opening and closing tags are removed.\n * 8. Ordered lists (<ol> and </ol>): Opening and closing tags are removed.\n * 9. List items (<li>): Opening <li> tags are replaced with an asterisk followed\n *    by a space, while closing </li> tags are replaced with a newline character.\n * 10. Hyperlinks (<a href=\"...\">...</a>): Replaced with the Markdown format\n *     [text](URL), where \"text\" is the anchor text and \"URL\" is the link target.\n *\n * @param {string} html - The input string containing HTML content.\n * @return {string} A string formatted in Markdown, reflecting the input HTML structure.\n */\nfunction convert(html: string): string {}", "test_code": "describe('Answer', () => {\n    test('testSimpleLineBreak', () => {\n        const input = 'Hello<br>World';\n        const expectedOutput = 'Hello\\nWorld';\n        expect(convert(input)).toEqual(expectedOutput);\n    });\n\n    test('testStrongTags', () => {\n        const input = 'This is <strong>important</strong> text.';\n        const expectedOutput = 'This is **important** text.';\n        expect(convert(input)).toEqual(expectedOutput);\n    });\n\n    test('testEmphasisTags', () => {\n        const input = 'This is <em>emphasized</em> text.';\n        const expectedOutput = 'This is *emphasized* text.';\n        expect(convert(input)).toEqual(expectedOutput);\n    });\n\n    test('testUnorderedList', () => {\n        const input = '<ul><li>Item 1</li><li>Item 2</li></ul>';\n        const expectedOutput = '* Item 1\\n* Item 2\\n';\n        expect(convert(input)).toEqual(expectedOutput);\n    });\n\n    test('testAnchorTags', () => {\n        const input = 'Check this link: <a href=\"http://example.com\">Example</a>.';\n        const expectedOutput = 'Check this link: [Example](http://example.com).';\n        expect(convert(input)).toEqual(expectedOutput);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a string containing HTML to a Markdown-formatted string.\n *\n * 1. Line breaks (<br> or <br/>): Replaced with newline characters.\n * 2. Paragraphs (<p> and </p>): Opening <p> tags are removed, while closing\n *    </p> tags are replaced with two newline characters to separate paragraphs.\n * 3. Strong emphasis (<strong> and </strong>): Replaced with double asterisks (**).\n * 4. Italics (<em> and </em>): Replaced with single asterisks (*).\n * 5. Underlined text (<u> and </u>): Replaced with single asterisks (*)\n *    as underlining is not supported in Markdown.\n * 6. Code snippets (<code> and </code>): Replaced with backticks (`).\n * 7. Unordered lists (<ul> and </ul>): Opening and closing tags are removed.\n * 8. Ordered lists (<ol> and </ol>): Opening and closing tags are removed.\n * 9. List items (<li>): Opening <li> tags are replaced with an asterisk followed\n *    by a space, while closing </li> tags are replaced with a newline character.\n * 10. Hyperlinks (<a href=\"...\">...</a>): Replaced with the Markdown format\n *     [text](URL), where \"text\" is the anchor text and \"URL\" is the link target.\n *\n * @param {string} html - The input string containing HTML content.\n * @return {string} A string formatted in Markdown, reflecting the input HTML structure.\n */\nfunction convert(html: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a string containing HTML to a Markdown-formatted string.\n *\n * This function performs the following transformations:\n * \n * 1. **Line breaks** (`<br>` or `<br/>`): Replaced with newline characters.\n * 2. **Paragraphs** (`<p>` and `</p>`): Opening `<p>` tags are removed, \n *    while closing `</p>` tags are replaced with two newline characters \n *    to separate paragraphs.\n * 3. **Strong emphasis** (`<strong>` and `</strong>`): Replaced with \n *    double asterisks (`**`).\n * 4. **Italics** (`<em>` and `</em>`): Replaced with single asterisks (`*`).\n * 5. **Underlined text** (`<u>` and `</u>`): Replaced with single asterisks (`*`) \n *    as underlining is not supported in Markdown.\n * 6. **Code snippets** (`<code>` and `</code>`): Replaced with backticks (`` ` ``).\n * 7. **Unordered lists** (`<ul>` and `</ul>`): Opening and closing tags are removed.\n * 8. **Ordered lists** (`<ol>` and `</ol>`): Opening and closing tags are removed.\n * 9. **List items** (`<li>`): Opening `<li>` tags are replaced with an asterisk \n *    followed by a space, while closing `</li>` tags are replaced with a newline character.\n * 10. **Hyperlinks** (`<a href=\"...\">...</a>`): Replaced with the Markdown format \n *     `[\\$2](\\$1)`, where \"text\" is the anchor text and \"URL\" is the link target.\n *\n * @param html The input string containing HTML content.\n * @return A string formatted in Markdown, reflecting the input HTML structure.\n */\nstd::string convert(const std::string& html);", "test_code": "TEST_CASE(\"Test Simple Line Break\") {\n    std::string input = \"Hello<br>World\";\n    std::string expectedOutput = \"Hello\\nWorld\";\n    REQUIRE(convert(input) == expectedOutput);\n}\n\nTEST_CASE(\"Test Strong Tags\") {\n    std::string input = \"This is <strong>important</strong> text.\";\n    std::string expectedOutput = \"This is **important** text.\";\n    REQUIRE(convert(input) == expectedOutput);\n}\n\nTEST_CASE(\"Test Emphasis Tags\") {\n    std::string input = \"This is <em>emphasized</em> text.\";\n    std::string expectedOutput = \"This is *emphasized* text.\";\n    REQUIRE(convert(input) == expectedOutput);\n}\n\nTEST_CASE(\"Test Unordered List\") {\n    std::string input = \"<ul><li>Item 1</li><li>Item 2</li></ul>\";\n    std::string expectedOutput = \"* Item 1\\n* Item 2\";\n    REQUIRE(convert(input) == expectedOutput);\n}\n\nTEST_CASE(\"Test Anchor Tags\") {\n    std::string input = \"Check this link: <a href=\\\"http://example.com\\\">Example</a>.\";\n    std::string expectedOutput = \"Check this link: [Example](http://example.com).\";\n    REQUIRE(convert(input) == expectedOutput);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a string containing HTML to a Markdown-formatted string.\n *\n * This function performs the following transformations:\n * \n * 1. **Line breaks** (`<br>` or `<br/>`): Replaced with newline characters.\n * 2. **Paragraphs** (`<p>` and `</p>`): Opening `<p>` tags are removed, \n *    while closing `</p>` tags are replaced with two newline characters \n *    to separate paragraphs.\n * 3. **Strong emphasis** (`<strong>` and `</strong>`): Replaced with \n *    double asterisks (`**`).\n * 4. **Italics** (`<em>` and `</em>`): Replaced with single asterisks (`*`).\n * 5. **Underlined text** (`<u>` and `</u>`): Replaced with single asterisks (`*`) \n *    as underlining is not supported in Markdown.\n * 6. **Code snippets** (`<code>` and `</code>`): Replaced with backticks (`` ` ``).\n * 7. **Unordered lists** (`<ul>` and `</ul>`): Opening and closing tags are removed.\n * 8. **Ordered lists** (`<ol>` and `</ol>`): Opening and closing tags are removed.\n * 9. **List items** (`<li>`): Opening `<li>` tags are replaced with an asterisk \n *    followed by a space, while closing `</li>` tags are replaced with a newline character.\n * 10. **Hyperlinks** (`<a href=\"...\">...</a>`): Replaced with the Markdown format \n *     `[\\$2](\\$1)`, where \"text\" is the anchor text and \"URL\" is the link target.\n *\n * @param html The input string containing HTML content.\n * @return A string formatted in Markdown, reflecting the input HTML structure.\n */\nstd::string convert(const std::string& html);", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a string containing HTML to a Markdown-formatted string.\n *\n * 1. Line breaks (<br> or <br/>): Replaced with newline characters.\n * 2. Paragraphs (<p> and </p>): Opening <p> tags are removed, while closing\n *    </p> tags are replaced with two newline characters to separate paragraphs.\n * 3. Strong emphasis (<strong> and </strong>): Replaced with double asterisks (**).\n * 4. Italics (<em> and </em>): Replaced with single asterisks (*).\n * 5. Underlined text (<u> and </u>): Replaced with single asterisks (*)\n *    as underlining is not supported in Markdown.\n * 6. Code snippets (<code> and </code>): Replaced with backticks (`).\n * 7. Unordered lists (<ul> and </ul>): Opening and closing tags are removed.\n * 8. Ordered lists (<ol> and </ol>): Opening and closing tags are removed.\n * 9. List items (<li>): Opening <li> tags are replaced with an asterisk followed\n *    by a space, while closing </li> tags are replaced with a newline character.\n * 10. Hyperlinks (<a href=\"...\">...</a>): Replaced with the Markdown format\n *     [text](URL), where \"text\" is the anchor text and \"URL\" is the link target.\n *\n * @param html The input string containing HTML content.\n * @return A string formatted in Markdown, reflecting the input HTML structure.\n */\npublic static String convert(String html) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertArrayEquals;\n\nimport org.real.temp.*;\npublic class Tester {\n\n    @Test\n    public void testCubicBezier_t0() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 0.0;\n        double[] expected = {0.0, 0.0};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3),1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_t1() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 1.0;\n        double[] expected = {1.0, 0.0};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3),1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_t0_5() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 0.5;\n        double[] expected = {0.5, 0.75};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_midPoint() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {1.0, 1.0};\n        double[] p2 = {2.0, 1.0};\n        double[] p3 = {3.0, 0.0};\n\n        double t = 0.5;\n        double[] expected = {1.5, 0.75};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_arbitraryT() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 2.0};\n        double[] p2 = {2.0, 2.0};\n        double[] p3 = {2.0, 0.0};\n        double t = 0.75;\n        double[] expected = {1.6875, 1.125};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts a string containing HTML to a Markdown-formatted string.\n *\n * 1. Line breaks (<br> or <br/>): Replaced with newline characters.\n * 2. Paragraphs (<p> and </p>): Opening <p> tags are removed, while closing\n *    </p> tags are replaced with two newline characters to separate paragraphs.\n * 3. Strong emphasis (<strong> and </strong>): Replaced with double asterisks (**).\n * 4. Italics (<em> and </em>): Replaced with single asterisks (*).\n * 5. Underlined text (<u> and </u>): Replaced with single asterisks (*)\n *    as underlining is not supported in Markdown.\n * 6. Code snippets (<code> and </code>): Replaced with backticks (`).\n * 7. Unordered lists (<ul> and </ul>): Opening and closing tags are removed.\n * 8. Ordered lists (<ol> and </ol>): Opening and closing tags are removed.\n * 9. List items (<li>): Opening <li> tags are replaced with an asterisk followed\n *    by a space, while closing </li> tags are replaced with a newline character.\n * 10. Hyperlinks (<a href=\"...\">...</a>): Replaced with the Markdown format\n *     [text](URL), where \"text\" is the anchor text and \"URL\" is the link target.\n *\n * @param html The input string containing HTML content.\n * @return A string formatted in Markdown, reflecting the input HTML structure.\n */\npublic static String convert(String html) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 173, "code_type": "method", "original_language": "java", "question_type": "Algorithm and data structure", "summary": "Calculate the coordinates of a cubic B\u00e9zier curve at a given parametert(typically between 0 and 1).", "language_version_list": {"python": {"code_signature": "def cubic_bezier(t: float, p0: list, p1: list, p2: list, p3: list) -> list:\n    \"\"\"\n    Calculate the coordinates of a cubic B\u00e9zier curve at a given parameter t (typically between 0 and 1).\n\n    Args:\n        t (float): A float representing the parameter along the curve, where 0 <= t <= 1.\n        p0 (list): A list of size 2 representing the x and y coordinates of the start point.\n        p1 (list): A list of size 2 representing the x and y coordinates of the first control point.\n        p2 (list): A list of size 2 representing the x and y coordinates of the second control point.\n        p3 (list): A list of size 2 representing the x and y coordinates of the end point.\n\n    Returns:\n        list: A list of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n    \"\"\"", "test_code": "import unittest\nfrom typing import List\n\nclass TestCubicBezier(unittest.TestCase):\n    def test_cubic_bezier_t0(self):\n        p0 = [0.0, 0.0]\n        p1 = [0.0, 1.0]\n        p2 = [1.0, 1.0]\n        p3 = [1.0, 0.0]\n        t = 0.0\n        expected = [0.0, 0.0]\n        self.assertAlmostEqual(cubic_bezier(t, p0, p1, p2, p3), expected)\n\n    def test_cubic_bezier_t1(self):\n        p0 = [0.0, 0.0]\n        p1 = [0.0, 1.0]\n        p2 = [1.0, 1.0]\n        p3 = [1.0, 0.0]\n        t = 1.0\n        expected = [1.0, 0.0]\n        self.assertAlmostEqual(cubic_bezier(t, p0, p1, p2, p3), expected)\n\n    def test_cubic_bezier_t0_5(self):\n        p0 = [0.0, 0.0]\n        p1 = [0.0, 1.0]\n        p2 = [1.0, 1.0]\n        p3 = [1.0, 0.0]\n        t = 0.5\n        expected = [0.5, 0.75]\n        self.assertAlmostEqual(cubic_bezier(t, p0, p1, p2, p3), expected, places=9)\n\n    def test_cubic_bezier_mid_point(self):\n        p0 = [0.0, 0.0]\n        p1 = [1.0, 1.0]\n        p2 = [2.0, 1.0]\n        p3 = [3.0, 0.0]\n        t = 0.5\n        expected = [1.5, 0.75]\n        self.assertAlmostEqual(cubic_bezier(t, p0, p1, p2, p3), expected, places=9)\n\n    def test_cubic_bezier_arbitrary_t(self):\n        p0 = [0.0, 0.0]\n        p1 = [0.0, 2.0]\n        p2 = [2.0, 2.0]\n        p3 = [2.0, 0.0]\n        t = 0.75\n        expected = [1.6875, 1.125]\n        self.assertAlmostEqual(cubic_bezier(t, p0, p1, p2, p3), expected, places=9)", "prompt": "please write a python function , the function signature as below def cubic_bezier(t: float, p0: list, p1: list, p2: list, p3: list) -> list:\n    \"\"\"\n    Calculate the coordinates of a cubic B\u00e9zier curve at a given parameter t (typically between 0 and 1).\n\n    Args:\n        t (float): A float representing the parameter along the curve, where 0 <= t <= 1.\n        p0 (list): A list of size 2 representing the x and y coordinates of the start point.\n        p1 (list): A list of size 2 representing the x and y coordinates of the first control point.\n        p2 (list): A list of size 2 representing the x and y coordinates of the second control point.\n        p3 (list): A list of size 2 representing the x and y coordinates of the end point.\n\n    Returns:\n        list: A list of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parameter t (typically between 0 and 1).\n * @param {number} t  A number representing the parameter along the curve, where 0 <= t <= 1.\n * @param {Array<number>} p0 A two-element array representing the x and y coordinates of the start point.\n * @param {Array<number>} p1 A two-element array representing the x and y coordinates of the first control point.\n * @param {Array<number>} p2 A two-element array representing the x and y coordinates of the second control point.\n * @param {Array<number>} p3 A two-element array representing the x and y coordinates of the end point.\n * @return {Array<number>} A two-element array containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\nfunction cubicBezier(t, p0, p1, p2, p3) {}", "test_code": "describe('cubicBezier', () => {\n    test('t = 0', () => {\n        const p0 = [0.0, 0.0];\n        const p1 = [0.0, 1.0];\n        const p2 = [1.0, 1.0];\n        const p3 = [1.0, 0.0];\n        const t = 0.0;\n        const expected = [0.0, 0.0];\n        expect(cubicBezier(t, p0, p1, p2, p3)).toEqual(expected);\n    });\n\n    test('t = 1', () => {\n        const p0 = [0.0, 0.0];\n        const p1 = [0.0, 1.0];\n        const p2 = [1.0, 1.0];\n        const p3 = [1.0, 0.0];\n        const t = 1.0;\n        const expected = [1.0, 0.0];\n        expect(cubicBezier(t, p0, p1, p2, p3)).toEqual(expected);\n    });\n\n    test('t = 0.5', () => {\n        const p0 = [0.0, 0.0];\n        const p1 = [0.0, 1.0];\n        const p2 = [1.0, 1.0];\n        const p3 = [1.0, 0.0];\n        const t = 0.5;\n        const expected = [0.5, 0.75];\n        expect(cubicBezier(t, p0, p1, p2, p3)).toBeCloseTo(expected[0], 9);\n        expect(cubicBezier(t, p0, p1, p2, p3)).toBeCloseTo(expected[1], 9);\n    });\n\n    test('t = 0.5 with mid points', () => {\n        const p0 = [0.0, 0.0];\n        const p1 = [1.0, 1.0];\n        const p2 = [2.0, 1.0];\n        const p3 = [3.0, 0.0];\n        const t = 0.5;\n        const expected = [1.5, 0.75];\n        expect(cubicBezier(t, p0, p1, p2, p3)).toBeCloseTo(expected[0], 9);\n        expect(cubicBezier(t, p0, p1, p2, p3)).toBeCloseTo(expected[1], 9);\n    });\n\n    test('arbitrary t = 0.75', () => {\n        const p0 = [0.0, 0.0];\n        const p1 = [0.0, 2.0];\n        const p2 = [2.0, 2.0];\n        const p3 = [2.0, 0.0];\n        const t = 0.75;\n        const expected = [1.6875, 1.125];\n        expect(cubicBezier(t, p0, p1, p2, p3)).toBeCloseTo(expected[0], 9);\n        expect(cubicBezier(t, p0, p1, p2, p3)).toBeCloseTo(expected[1], 9);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parameter t (typically between 0 and 1).\n * @param {number} t  A number representing the parameter along the curve, where 0 <= t <= 1.\n * @param {Array<number>} p0 A two-element array representing the x and y coordinates of the start point.\n * @param {Array<number>} p1 A two-element array representing the x and y coordinates of the first control point.\n * @param {Array<number>} p2 A two-element array representing the x and y coordinates of the second control point.\n * @param {Array<number>} p3 A two-element array representing the x and y coordinates of the end point.\n * @return {Array<number>} A two-element array containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\nfunction cubicBezier(t, p0, p1, p2, p3) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parameter t (typically between 0 and 1).\n * @param t  A number representing the parameter along the curve, where 0 <= t <= 1.\n * @param p0 A tuple of numbers representing the x and y coordinates of the start point.\n * @param p1 A tuple of numbers representing the x and y coordinates of the first control point.\n * @param p2 A tuple of numbers representing the x and y coordinates of the second control point.\n * @param p3 A tuple of numbers representing the x and y coordinates of the end point.\n * @return   A tuple of numbers containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\nfunction cubicBezier(\n    t: number,\n    p0: [number, number],\n    p1: [number, number],\n    p2: [number, number],\n    p3: [number, number]\n): [number, number] {}", "test_code": "describe('Answer', () => {\n    test('cubicBezier t=0', () => {\n        const p0: [number, number] = [0.0, 0.0];\n        const p1: [number, number] = [0.0, 1.0];\n        const p2: [number, number] = [1.0, 1.0];\n        const p3: [number, number] = [1.0, 0.0];\n\n        const t = 0.0;\n        const expected: [number, number] = [0.0, 0.0];\n        expect(cubicBezier(t, p0, p1, p2, p3)).toEqual(expected);\n    });\n\n    test('cubicBezier t=1', () => {\n        const p0: [number, number] = [0.0, 0.0];\n        const p1: [number, number] = [0.0, 1.0];\n        const p2: [number, number] = [1.0, 1.0];\n        const p3: [number, number] = [1.0, 0.0];\n\n        const t = 1.0;\n        const expected: [number, number] = [1.0, 0.0];\n        expect(cubicBezier(t, p0, p1, p2, p3)).toEqual(expected);\n    });\n\n    test('cubicBezier t=0.5', () => {\n        const p0: [number, number] = [0.0, 0.0];\n        const p1: [number, number] = [0.0, 1.0];\n        const p2: [number, number] = [1.0, 1.0];\n        const p3: [number, number] = [1.0, 0.0];\n\n        const t = 0.5;\n        const expected: [number, number] = [0.5, 0.75];\n        expect(cubicBezier(t, p0, p1, p2, p3)).toBeCloseTo(expected[0], 9);\n        expect(cubicBezier(t, p0, p1, p2, p3)[1]).toBeCloseTo(expected[1], 9);\n    });\n\n    test('cubicBezier midPoint', () => {\n        const p0: [number, number] = [0.0, 0.0];\n        const p1: [number, number] = [1.0, 1.0];\n        const p2: [number, number] = [2.0, 1.0];\n        const p3: [number, number] = [3.0, 0.0];\n\n        const t = 0.5;\n        const expected: [number, number] = [1.5, 0.75];\n        expect(cubicBezier(t, p0, p1, p2, p3)).toBeCloseTo(expected[0], 9);\n        expect(cubicBezier(t, p0, p1, p2, p3)[1]).toBeCloseTo(expected[1], 9);\n    });\n\n    test('cubicBezier arbitraryT', () => {\n        const p0: [number, number] = [0.0, 0.0];\n        const p1: [number, number] = [0.0, 2.0];\n        const p2: [number, number] = [2.0, 2.0];\n        const p3: [number, number] = [2.0, 0.0];\n\n        const t = 0.75;\n        const expected: [number, number] = [1.6875, 1.125];\n        expect(cubicBezier(t, p0, p1, p2, p3)).toBeCloseTo(expected[0], 9);\n        expect(cubicBezier(t, p0, p1, p2, p3)[1]).toBeCloseTo(expected[1], 9);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parameter t (typically between 0 and 1).\n * @param t  A number representing the parameter along the curve, where 0 <= t <= 1.\n * @param p0 A tuple of numbers representing the x and y coordinates of the start point.\n * @param p1 A tuple of numbers representing the x and y coordinates of the first control point.\n * @param p2 A tuple of numbers representing the x and y coordinates of the second control point.\n * @param p3 A tuple of numbers representing the x and y coordinates of the end point.\n * @return   A tuple of numbers containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\nfunction cubicBezier(\n    t: number,\n    p0: [number, number],\n    p1: [number, number],\n    p2: [number, number],\n    p3: [number, number]\n): [number, number] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parameter t (typically between 0 and 1).\n * @param t  A double representing the parameter along the curve, where 0 <= t <= 1.\n * @param p0 A std::array of size 2 representing the x and y coordinates of the start point.\n * @param p1 A std::array of size 2 representing the x and y coordinates of the first control point.\n * @param p2 A std::array of size 2 representing the x and y coordinates of the second control point.\n * @param p3 A std::array of size 2 representing the x and y coordinates of the end point.\n * @return   A std::array of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\nstd::array<double, 2> cubicBezier(double t, const std::array<double, 2>& p0, \n                                   const std::array<double, 2>& p1, \n                                   const std::array<double, 2>& p2, \n                                   const std::array<double, 2>& p3) {}", "test_code": "TEST_CASE(\"Cubic Bezier Curve Tests\") {\n    std::array<double, 2> p0 = {0.0, 0.0};\n    std::array<double, 2> p1 = {0.0, 1.0};\n    std::array<double, 2> p2 = {1.0, 1.0};\n    std::array<double, 2> p3 = {1.0, 0.0};\n\n    SECTION(\"t = 0.0\") {\n        double t = 0.0;\n        std::array<double, 2> expected = {0.0, 0.0};\n        REQUIRE(cubicBezier(t, p0, p1, p2, p3) == expected);\n    }\n\n    SECTION(\"t = 1.0\") {\n        double t = 1.0;\n        std::array<double, 2> expected = {1.0, 0.0};\n        REQUIRE(cubicBezier(t, p0, p1, p2, p3) == expected);\n    }\n\n    SECTION(\"t = 0.5\") {\n        double t = 0.5;\n        std::array<double, 2> expected = {0.5, 0.75};\n        REQUIRE_THAT(cubicBezier(t, p0, p1, p2, p3), Catch::Equals(expected, 1e-9));\n    }\n\n    SECTION(\"Mid point\") {\n        std::array<double, 2> p1 = {1.0, 1.0};\n        std::array<double, 2> p2 = {2.0, 1.0};\n        std::array<double, 2> p3 = {3.0, 0.0};\n        double t = 0.5;\n        std::array<double, 2> expected = {1.5, 0.75};\n        REQUIRE_THAT(cubicBezier(t, p0, p1, p2, p3), Catch::Equals(expected, 1e-9));\n    }\n\n    SECTION(\"Arbitrary t = 0.75\") {\n        std::array<double, 2> p1 = {0.0, 2.0};\n        std::array<double, 2> p2 = {2.0, 2.0};\n        std::array<double, 2> p3 = {2.0, 0.0};\n        double t = 0.75;\n        std::array<double, 2> expected = {1.6875, 1.125};\n        REQUIRE_THAT(cubicBezier(t, p0, p1, p2, p3), Catch::Equals(expected, 1e-9));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parameter t (typically between 0 and 1).\n * @param t  A double representing the parameter along the curve, where 0 <= t <= 1.\n * @param p0 A std::array of size 2 representing the x and y coordinates of the start point.\n * @param p1 A std::array of size 2 representing the x and y coordinates of the first control point.\n * @param p2 A std::array of size 2 representing the x and y coordinates of the second control point.\n * @param p3 A std::array of size 2 representing the x and y coordinates of the end point.\n * @return   A std::array of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\nstd::array<double, 2> cubicBezier(double t, const std::array<double, 2>& p0, \n                                   const std::array<double, 2>& p1, \n                                   const std::array<double, 2>& p2, \n                                   const std::array<double, 2>& p3) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parametert(typically between 0 and 1).\n * @param t  A double representing the parameter along the curve, where 0 <= t <= 1.\n * @param p0 A double array of size 2 representing the x and y coordinates of the start point.\n * @param p1 A double array of size 2 representing the x and y coordinates of the first control point.\n * @param p2 A double array of size 2 representing the x and y coordinates of the second control point.\n * @param p3 A double array of size 2 representing the x and y coordinates of the end point.\n * @return   A double array of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\npublic static double[] cubicBezier(double t, double[] p0, double[] p1, double[] p2, double[] p3) {}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertArrayEquals;\n\nimport org.real.temp.*;\npublic class Tester {\n\n    @Test\n    public void testCubicBezier_t0() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 0.0;\n        double[] expected = {0.0, 0.0};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3));\n    }\n\n    @Test\n    public void testCubicBezier_t1() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 1.0;\n        double[] expected = {1.0, 0.0};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3));\n    }\n\n    @Test\n    public void testCubicBezier_t0_5() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 0.5;\n        double[] expected = {0.5, 0.75};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_midPoint() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {1.0, 1.0};\n        double[] p2 = {2.0, 1.0};\n        double[] p3 = {3.0, 0.0};\n\n        double t = 0.5;\n        double[] expected = {1.5, 0.75};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_arbitraryT() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 2.0};\n        double[] p2 = {2.0, 2.0};\n        double[] p3 = {2.0, 0.0};\n        double t = 0.75;\n        double[] expected = {1.6875, 1.125};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parametert(typically between 0 and 1).\n * @param t  A double representing the parameter along the curve, where 0 <= t <= 1.\n * @param p0 A double array of size 2 representing the x and y coordinates of the start point.\n * @param p1 A double array of size 2 representing the x and y coordinates of the first control point.\n * @param p2 A double array of size 2 representing the x and y coordinates of the second control point.\n * @param p3 A double array of size 2 representing the x and y coordinates of the end point.\n * @return   A double array of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\npublic static double[] cubicBezier(double t, double[] p0, double[] p1, double[] p2, double[] p3) {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 174, "code_type": "method", "original_language": "java", "question_type": "Algorithm and data structure", "summary": "Implement a function using the secant method that takes a B\u00e9zier curve and a target x-value as inputs and returns the parameter t where the B\u00e9zier curve reaches the specified x-value.", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef find_t_for_x(target_x: float, p0: Tuple[float, float], p1: Tuple[float, float], p2: Tuple[float, float]) -> float:\n    \"\"\"\n    Find the parameter t corresponding to a given x-coordinate target_x\n    on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n\n    Args:\n        target_x (float): The x-coordinate for which we want to find the corresponding parameter t.\n        p0 (Tuple[float, float]): The first control point of the B\u00e9zier curve.\n        p1 (Tuple[float, float]): The second control point of the B\u00e9zier curve.\n        p2 (Tuple[float, float]): The third control point of the B\u00e9zier curve.\n\n    Returns:\n        float: The parameter t (in the range [0, 1]) for which the B\u00e9zier curve evaluated at t is closest to target_x.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestFindxTForX(unittest.TestCase):\n    TOLERANCE = 1e-6\n\n    def test_find_t_for_x_at_start(self):\n        p0 = 0.0\n        p1 = 0.5\n        p2 = 1.0\n        target_x = 0.0\n        t = find_t_for_x(target_x, p0, p1, p2)\n        self.assertAlmostEqual(t, 0.0, delta=self.TOLERANCE)\n\n    def test_find_t_for_x_at_end(self):\n        p0 = 0.0\n        p1 = 0.5\n        p2 = 1.0\n        target_x = 1.0\n        t = find_t_for_x(target_x, p0, p1, p2)\n        self.assertAlmostEqual(t, 1.0, delta=self.TOLERANCE)\n\n    def test_find_t_for_x_mid_curve(self):\n        p0 = 0.0\n        p1 = 0.5\n        p2 = 1.0\n        target_x = 0.25\n        t = find_t_for_x(target_x, p0, p1, p2)\n        self.assertAlmostEqual(t, 0.25, delta=self.TOLERANCE)\n\n    def test_find_t_for_x_near_mid_curve(self):\n        p0 = 0.0\n        p1 = 1.0\n        p2 = 2.0\n        target_x = 1.5\n        t = find_t_for_x(target_x, p0, p1, p2)\n        self.assertAlmostEqual(t, 0.75, delta=self.TOLERANCE)", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef find_t_for_x(target_x: float, p0: Tuple[float, float], p1: Tuple[float, float], p2: Tuple[float, float]) -> float:\n    \"\"\"\n    Find the parameter t corresponding to a given x-coordinate target_x\n    on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n\n    Args:\n        target_x (float): The x-coordinate for which we want to find the corresponding parameter t.\n        p0 (Tuple[float, float]): The first control point of the B\u00e9zier curve.\n        p1 (Tuple[float, float]): The second control point of the B\u00e9zier curve.\n        p2 (Tuple[float, float]): The third control point of the B\u00e9zier curve.\n\n    Returns:\n        float: The parameter t (in the range [0, 1]) for which the B\u00e9zier curve evaluated at t is closest to target_x.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Finds the parameter `t` corresponding to a given x-coordinate `targetX`\n * on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n * The function uses the secant method to iteratively approach the value of `t`\n * where the B\u00e9zier curve intersects with the vertical line at `targetX`.\n *\n * @param {number} targetX - The x-coordinate for which we want to find the corresponding\n *                parameter `t` on the B\u00e9zier curve.\n * @param {number} p0 - The first control point of the B\u00e9zier curve, representing the\n *            starting point.\n * @param {number} p1 - The second control point of the B\u00e9zier curve, affecting the curve's\n *            shape.\n * @param {number} p2 - The third control point of the B\u00e9zier curve, representing the\n *            ending point.\n * @return {number} The parameter `t` (in the range [0, 1]) for which the B\u00e9zier curve\n *         evaluated at `t` is closest to `targetX`. If no precise value is\n *         found within the specified tolerance and iterations, the function\n *         returns the best approximation.\n */\nfunction findTForX(targetX, p0, p1, p2) {}", "test_code": "describe('TestfindTForX', () => {\n    // Tolerance level for floating-point comparisons\n    const TOLERANCE = 1e-6;\n\n    test('findTForX should return 0.0 when targetX is at the start', () => {\n        const p0 = 0.0;\n        const p1 = 0.5;\n        const p2 = 1.0;\n        const targetX = 0.0;\n\n        const t = findTForX(targetX, p0, p1, p2);\n        expect(t).toBeCloseTo(0.0, TOLERANCE);\n    });\n\n    test('findTForX should return 1.0 when targetX is at the end', () => {\n        const p0 = 0.0;\n        const p1 = 0.5;\n        const p2 = 1.0;\n        const targetX = 1.0;\n\n        const t = findTForX(targetX, p0, p1, p2);\n        expect(t).toBeCloseTo(1.0, TOLERANCE);\n    });\n\n    test('findTForX should return 0.25 when targetX is mid-curve', () => {\n        const p0 = 0.0;\n        const p1 = 0.5;\n        const p2 = 1.0;\n        const targetX = 0.25;\n\n        const t = findTForX(targetX, p0, p1, p2);\n        expect(t).toBeCloseTo(0.25, TOLERANCE);\n    });\n\n    test('findTForX should return 0.75 when targetX is near mid-curve', () => {\n        const p0 = 0.0;\n        const p1 = 1.0;\n        const p2 = 2.0;\n        const targetX = 1.5;\n\n        const t = findTForX(targetX, p0, p1, p2);\n        expect(t).toBeCloseTo(0.75, TOLERANCE);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Finds the parameter `t` corresponding to a given x-coordinate `targetX`\n * on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n * The function uses the secant method to iteratively approach the value of `t`\n * where the B\u00e9zier curve intersects with the vertical line at `targetX`.\n *\n * @param {number} targetX - The x-coordinate for which we want to find the corresponding\n *                parameter `t` on the B\u00e9zier curve.\n * @param {number} p0 - The first control point of the B\u00e9zier curve, representing the\n *            starting point.\n * @param {number} p1 - The second control point of the B\u00e9zier curve, affecting the curve's\n *            shape.\n * @param {number} p2 - The third control point of the B\u00e9zier curve, representing the\n *            ending point.\n * @return {number} The parameter `t` (in the range [0, 1]) for which the B\u00e9zier curve\n *         evaluated at `t` is closest to `targetX`. If no precise value is\n *         found within the specified tolerance and iterations, the function\n *         returns the best approximation.\n */\nfunction findTForX(targetX, p0, p1, p2) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Finds the parameter `t` corresponding to a given x-coordinate `targetX`\n * on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n * The function uses the secant method to iteratively approach the value of `t`\n * where the B\u00e9zier curve intersects with the vertical line at `targetX`.\n *\n * @param targetX - The x-coordinate for which we want to find the corresponding\n *                parameter `t` on the B\u00e9zier curve.\n * @param p0 - The first control point of the B\u00e9zier curve, representing the\n *            starting point.\n * @param p1 - The second control point of the B\u00e9zier curve, affecting the curve's\n *            shape.\n * @param p2 - The third control point of the B\u00e9zier curve, representing the\n *            ending point.\n * @returns The parameter `t` (in the range [0, 1]) for which the B\u00e9zier curve\n *         evaluated at `t` is closest to `targetX`. If no precise value is\n *         found within the specified tolerance and iterations, the function\n *         returns the best approximation.\n */\nfunction findTForX(targetX: number, p0: number, p1: number, p2: number): number {}", "test_code": "describe('TestfindTForX', () => {\n    // Tolerance level for floating-point comparisons\n    const TOLERANCE = 1e-6;\n\n    test('findTForX should return 0.0 when targetX is at the start', () => {\n        const p0 = 0.0;\n        const p1 = 0.5;\n        const p2 = 1.0;\n        const targetX = 0.0;\n\n        const t = findTForX(targetX, p0, p1, p2);\n        expect(t).toBeCloseTo(0.0, TOLERANCE);\n    });\n\n    test('findTForX should return 1.0 when targetX is at the end', () => {\n        const p0 = 0.0;\n        const p1 = 0.5;\n        const p2 = 1.0;\n        const targetX = 1.0;\n\n        const t = findTForX(targetX, p0, p1, p2);\n        expect(t).toBeCloseTo(1.0, TOLERANCE);\n    });\n\n    test('findTForX should return 0.25 when targetX is mid-curve', () => {\n        const p0 = 0.0;\n        const p1 = 0.5;\n        const p2 = 1.0;\n        const targetX = 0.25;\n\n        const t = findTForX(targetX, p0, p1, p2);\n        expect(t).toBeCloseTo(0.25, TOLERANCE);\n    });\n\n    test('findTForX should return 0.75 when targetX is near mid-curve', () => {\n        const p0 = 0.0;\n        const p1 = 1.0;\n        const p2 = 2.0;\n        const targetX = 1.5;\n\n        const t = findTForX(targetX, p0, p1, p2);\n        expect(t).toBeCloseTo(0.75, TOLERANCE);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Finds the parameter `t` corresponding to a given x-coordinate `targetX`\n * on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n * The function uses the secant method to iteratively approach the value of `t`\n * where the B\u00e9zier curve intersects with the vertical line at `targetX`.\n *\n * @param targetX - The x-coordinate for which we want to find the corresponding\n *                parameter `t` on the B\u00e9zier curve.\n * @param p0 - The first control point of the B\u00e9zier curve, representing the\n *            starting point.\n * @param p1 - The second control point of the B\u00e9zier curve, affecting the curve's\n *            shape.\n * @param p2 - The third control point of the B\u00e9zier curve, representing the\n *            ending point.\n * @returns The parameter `t` (in the range [0, 1]) for which the B\u00e9zier curve\n *         evaluated at `t` is closest to `targetX`. If no precise value is\n *         found within the specified tolerance and iterations, the function\n *         returns the best approximation.\n */\nfunction findTForX(targetX: number, p0: number, p1: number, p2: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Finds the parameter `t` corresponding to a given x-coordinate `targetX`\n * on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n * The function uses the secant method to iteratively approach the value of `t`\n * where the B\u00e9zier curve intersects with the vertical line at `targetX`.\n *\n * @param targetX The x-coordinate for which we want to find the corresponding\n *                parameter `t` on the B\u00e9zier curve.\n * @param p0 The first control point of the B\u00e9zier curve, representing the\n *            starting point.\n * @param p1 The second control point of the B\u00e9zier curve, affecting the curve's\n *            shape.\n * @param p2 The third control point of the B\u00e9zier curve, representing the\n *            ending point.\n * @return The parameter `t` (in the range [0, 1]) for which the B\u00e9zier curve\n *         evaluated at `t` is closest to `targetX`. If no precise value is\n *         found within the specified tolerance and iterations, the function\n *         returns the best approximation.\n */\ndouble find_t_for_x(double targetX, double p0, double p1, double p2) {}", "test_code": "TEST_CASE(\"Find T for X at start\", \"[bezier]\") {\n    const double TOLERANCE = 1e-6;\n    double p0 = 0.0;\n    double p1 = 0.5;\n    double p2 = 1.0;\n    double targetX = 0.0;\n\n    double t = find_t_for_x(targetX, p0, p1, p2);\n    REQUIRE(std::abs(t - 0.0) < TOLERANCE);\n}\n\nTEST_CASE(\"Find T for X at end\", \"[bezier]\") {\n    const double TOLERANCE = 1e-6;\n    double p0 = 0.0;\n    double p1 = 0.5;\n    double p2 = 1.0;\n    double targetX = 1.0;\n\n    double t = find_t_for_x(targetX, p0, p1, p2);\n    REQUIRE(std::abs(t - 1.0) < TOLERANCE);\n}\n\nTEST_CASE(\"Find T for X mid curve\", \"[bezier]\") {\n    const double TOLERANCE = 1e-6;\n    double p0 = 0.0;\n    double p1 = 0.5;\n    double p2 = 1.0;\n    double targetX = 0.25;\n\n    double t = find_t_for_x(targetX, p0, p1, p2);\n    REQUIRE(std::abs(t - 0.25) < TOLERANCE);\n}\n\nTEST_CASE(\"Find T for X near mid curve\", \"[bezier]\") {\n    const double TOLERANCE = 1e-6;\n    double p0 = 0.0;\n    double p1 = 1.0;\n    double p2 = 2.0;\n    double targetX = 1.5;\n\n    double t = find_t_for_x(targetX, p0, p1, p2);\n    REQUIRE(std::abs(t - 0.75) < TOLERANCE);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Finds the parameter `t` corresponding to a given x-coordinate `targetX`\n * on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n * The function uses the secant method to iteratively approach the value of `t`\n * where the B\u00e9zier curve intersects with the vertical line at `targetX`.\n *\n * @param targetX The x-coordinate for which we want to find the corresponding\n *                parameter `t` on the B\u00e9zier curve.\n * @param p0 The first control point of the B\u00e9zier curve, representing the\n *            starting point.\n * @param p1 The second control point of the B\u00e9zier curve, affecting the curve's\n *            shape.\n * @param p2 The third control point of the B\u00e9zier curve, representing the\n *            ending point.\n * @return The parameter `t` (in the range [0, 1]) for which the B\u00e9zier curve\n *         evaluated at `t` is closest to `targetX`. If no precise value is\n *         found within the specified tolerance and iterations, the function\n *         returns the best approximation.\n */\ndouble find_t_for_x(double targetX, double p0, double p1, double p2) {}", "addition_info": ""}, "java": {"code_signature": " /**\n * Finds the parameter `t` corresponding to a given x-coordinate `targetX`\n * on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n * The function uses a numerical method (Newton's method) to iteratively\n * approach the value of `t` where the B\u00e9zier curve intersects with the\n * vertical line at `targetX`.\n *\n * @param targetX The x-coordinate for which we want to find the corresponding\n *                parameter `t` on the B\u00e9zier curve.\n * @param p0 The first control point of the B\u00e9zier curve, representing the\n *            starting point.\n * @param p1 The second control point of the B\u00e9zier curve, affecting the curve's\n *            shape.\n * @param p2 The third control point of the B\u00e9zier curve, representing the\n *            ending point.\n * @return The parameter `t` (in the range [0, 1]) for which the B\u00e9zier curve\n *         evaluated at `t` is closest to `targetX`. If no precise value is\n *         found within the specified tolerance and iterations, the function\n *         returns the best approximation.\n */\npublic static double findTForX(double targetX, double p0, double p1, double p2) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; \nimport static org.junit.Assert.assertEquals; \nimport org.real.temp.*;\n\n\npublic class Tester {\n    // Tolerance level for floating-point comparisons\n    private static final double TOLERANCE = 1e-6;\n\n    @Test\n    public void testFindTForX_AtStart() {\n        double p0 = 0.0;\n        double p1 = 0.5;\n        double p2 = 1.0;\n        double targetX = 0.0;\n\n        double t = Answer.findTForX(targetX, p0, p1, p2);\n        assertEquals(0.0, t, TOLERANCE);\n    }\n\n    @Test\n    public void testFindTForX_AtEnd() {\n        double p0 = 0.0;\n        double p1 = 0.5;\n        double p2 = 1.0;\n        double targetX = 1.0;\n\n        double t = Answer.findTForX(targetX, p0, p1, p2);\n        assertEquals(1.0, t, TOLERANCE);\n    }\n\n    @Test\n    public void testFindTForX_MidCurve() {\n        double p0 = 0.0;\n        double p1 = 0.5;\n        double p2 = 1.0;\n        double targetX = 0.25;\n\n        double t = Answer.findTForX(targetX, p0, p1, p2);\n        assertEquals(0.25, t, TOLERANCE);\n    }\n\n\n    @Test\n    public void testFindTForX_NearMidCurve() {\n        double p0 = 0.0;\n        double p1 = 1.0;\n        double p2 = 2.0;\n        double targetX = 1.5;\n\n        double t = Answer.findTForX(targetX, p0, p1, p2);\n        assertEquals(0.75, t, TOLERANCE);\n    }\n\n}\n", "prompt": "please write a java function , the function signature as below  /**\n * Finds the parameter `t` corresponding to a given x-coordinate `targetX`\n * on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n * The function uses a numerical method (Newton's method) to iteratively\n * approach the value of `t` where the B\u00e9zier curve intersects with the\n * vertical line at `targetX`.\n *\n * @param targetX The x-coordinate for which we want to find the corresponding\n *                parameter `t` on the B\u00e9zier curve.\n * @param p0 The first control point of the B\u00e9zier curve, representing the\n *            starting point.\n * @param p1 The second control point of the B\u00e9zier curve, affecting the curve's\n *            shape.\n * @param p2 The third control point of the B\u00e9zier curve, representing the\n *            ending point.\n * @return The parameter `t` (in the range [0, 1]) for which the B\u00e9zier curve\n *         evaluated at `t` is closest to `targetX`. If no precise value is\n *         found within the specified tolerance and iterations, the function\n *         returns the best approximation.\n */\npublic static double findTForX(double targetX, double p0, double p1, double p2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 176, "code_type": "method", "original_language": "java", "question_type": "Algorithm and data structure", "summary": "Given a set of points and a query point, write an algorithm to find the K nearest neighbors to the query point. The algorithm should efficiently handle large datasets, and the output should include the coordinates or indices of these neighbors.", "language_version_list": {"python": {"code_signature": "import math\nfrom typing import List\n\n\nclass Point:\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n\n    def distance_to(self, other: 'Point') -> float:\n        \"\"\"Calculate the Euclidean distance to another point.\"\"\"\n        return math.sqrt((self.x - other.x) ** 2 + (self.y - other.y) ** 2)\n\n\ndef find_k_nearest_neighbors(points: List[Point], query_point: Point, k: int) -> List[Point]:\n    \"\"\"Find the k nearest neighbors to the query_point.\n\n    Args:\n        points (List[Point]): A list of Point objects representing the available points in the space.\n        query_point (Point): The Point object for which we want to find the nearest neighbors.\n        k (int): The number of nearest neighbors to find.\n\n    Returns:\n        List[Point]: A list of the k nearest Point objects to the query_point.\n    \"\"\"\n", "test_code": "import math\nimport unittest\n\n\nclass Point:\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n\n    def distance_to(self, other: 'Point') -> float:\n        return math.sqrt((self.x - other.x) ** 2 + (self.y - other.y) ** 2)\n\n\nclass Tester(unittest.TestCase):\n\n    def test_find_k_nearest_neighbors_simple_case(self):\n        points = [\n            Point(1, 2),\n            Point(3, 4),\n            Point(1, -1),\n            Point(5, 2)\n        ]\n        query_point = Point(2, 2)\n        k = 2\n        result = find_k_nearest_neighbors(points, query_point, k)\n\n        self.assertEqual(len(result), 2)\n        self.assertTrue(self.contains_point(result, Point(1, 2)))\n        self.assertTrue(self.contains_point(result, Point(3, 4)))\n\n    def test_find_k_nearest_neighbors_exact_match(self):\n        points = [\n            Point(1, 2),\n            Point(2, 2),\n            Point(3, 3)\n        ]\n        query_point = Point(2, 2)\n        k = 1\n        result = find_k_nearest_neighbors(points, query_point, k)\n\n        self.assertEqual(len(result), 1)\n        self.assertAlmostEqual(result[0].x, 2.0, delta=0.001)\n        self.assertAlmostEqual(result[0].y, 2.0, delta=0.001)\n\n    def test_find_k_nearest_neighbors_larger_k(self):\n        points = [\n            Point(1, 2),\n            Point(3, 4),\n            Point(1, -1),\n            Point(5, 2)\n        ]\n        query_point = Point(2, 2)\n        k = 5  # k is larger than the number of points\n        result = find_k_nearest_neighbors(points, query_point, k)\n\n        self.assertEqual(len(result), 4)\n\n    def test_find_k_nearest_neighbors_empty_points(self):\n        points = []\n        query_point = Point(2, 2)\n        k = 3\n        result = find_k_nearest_neighbors(points, query_point, k)\n\n        self.assertEqual(len(result), 0)\n\n    def test_find_k_nearest_neighbors_all_points_equidistant(self):\n        points = [\n            Point(2, 3),\n            Point(3, 2),\n            Point(1, 2),\n            Point(2, 1)\n        ]\n        query_point = Point(2, 2)\n        k = 2\n        result = find_k_nearest_neighbors(points, query_point, k)\n\n        self.assertEqual(len(result), 2)\n        self.assertTrue(self.contains_point(result, Point(2, 3)))\n        self.assertTrue(self.contains_point(result, Point(3, 2)))\n\n    def contains_point(self, points, point):\n        for p in points:\n            if math.isclose(p.x, point.x, abs_tol=0.001) and math.isclose(p.y, point.y, abs_tol=0.001):\n                return True\n        return False\n", "prompt": "please write a python function , the function signature as below import math\nfrom typing import List\n\n\nclass Point:\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n\n    def distance_to(self, other: 'Point') -> float:\n        \"\"\"Calculate the Euclidean distance to another point.\"\"\"\n        return math.sqrt((self.x - other.x) ** 2 + (self.y - other.y) ** 2)\n\n\ndef find_k_nearest_neighbors(points: List[Point], query_point: Point, k: int) -> List[Point]:\n    \"\"\"Find the k nearest neighbors to the query_point.\n\n    Args:\n        points (List[Point]): A list of Point objects representing the available points in the space.\n        query_point (Point): The Point object for which we want to find the nearest neighbors.\n        k (int): The number of nearest neighbors to find.\n\n    Returns:\n        List[Point]: A list of the k nearest Point objects to the query_point.\n    \"\"\"\n", "addition_info": "class Point:\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n\n    def distance_to(self, other: 'Point') -> float:\n        \"\"\"Calculate the Euclidean distance to another point.\"\"\"\n        return math.sqrt((self.x - other.x) ** 2 + (self.y - other.y) ** 2)"}, "javascript": {"code_signature": "class Point {\n    /**\n     * Creates an instance of Point.\n     * @param {number} x - The x-coordinate of the point.\n     * @param {number} y - The y-coordinate of the point.\n     */\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Calculate the Euclidean distance to another point.\n     * @param {Point} other - The other point.\n     * @returns {number} The distance to the other point.\n     */\n    distanceTo(other) {\n        return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);\n    }\n}\n\n/**\n * Find the k nearest neighbors to the query point.\n * @param {Point[]} points - An array of Point objects representing the available points in the space.\n * @param {Point} queryPoint - The Point object for which we want to find the nearest neighbors.\n * @param {number} k - The number of nearest neighbors to find.\n * @returns {Point[]} An array of the k nearest Point objects to the query point.\n */\nfunction findKNearestNeighbors(points, queryPoint, k) {}", "test_code": "describe('Point', () => {\n    test('find k nearest neighbors simple case', () => {\n        const points = [\n            new Point(1, 2),\n            new Point(3, 4),\n            new Point(1, -1),\n            new Point(5, 2)\n        ];\n        const queryPoint = new Point(2, 2);\n        const k = 2;\n        const result = findKNearestNeighbors(points, queryPoint, k);\n\n        expect(result.length).toBe(2);\n        expect(containsPoint(result, new Point(1, 2))).toBe(true);\n        expect(containsPoint(result, new Point(3, 4))).toBe(true);\n    });\n\n    test('find k nearest neighbors exact match', () => {\n        const points = [\n            new Point(1, 2),\n            new Point(2, 2),\n            new Point(3, 3)\n        ];\n        const queryPoint = new Point(2, 2);\n        const k = 1;\n        const result = findKNearestNeighbors(points, queryPoint, k);\n\n        expect(result.length).toBe(1);\n        expect(result[0].x).toBeCloseTo(2.0, 3); // delta equivalent\n        expect(result[0].y).toBeCloseTo(2.0, 3); // delta equivalent\n    });\n\n    test('find k nearest neighbors larger k', () => {\n        const points = [\n            new Point(1, 2),\n            new Point(3, 4),\n            new Point(1, -1),\n            new Point(5, 2)\n        ];\n        const queryPoint = new Point(2, 2);\n        const k = 5; // k is larger than the number of points\n        const result = findKNearestNeighbors(points, queryPoint, k);\n\n        expect(result.length).toBe(4);\n    });\n\n    test('find k nearest neighbors empty points', () => {\n        const points = [];\n        const queryPoint = new Point(2, 2);\n        const k = 3;\n        const result = findKNearestNeighbors(points, queryPoint, k);\n\n        expect(result.length).toBe(0);\n    });\n\n    test('find k nearest neighbors all points equidistant', () => {\n        const points = [\n            new Point(2, 3),\n            new Point(3, 2),\n            new Point(1, 2),\n            new Point(2, 1)\n        ];\n        const queryPoint = new Point(2, 2);\n        const k = 2;\n        const result = findKNearestNeighbors(points, queryPoint, k);\n\n        expect(result.length).toBe(2);\n        expect(containsPoint(result, new Point(2, 3))).toBe(true);\n        expect(containsPoint(result, new Point(3, 2))).toBe(true);\n    });\n});", "prompt": "please write a javascript function , the function signature as below class Point {\n    /**\n     * Creates an instance of Point.\n     * @param {number} x - The x-coordinate of the point.\n     * @param {number} y - The y-coordinate of the point.\n     */\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Calculate the Euclidean distance to another point.\n     * @param {Point} other - The other point.\n     * @returns {number} The distance to the other point.\n     */\n    distanceTo(other) {\n        return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);\n    }\n}\n\n/**\n * Find the k nearest neighbors to the query point.\n * @param {Point[]} points - An array of Point objects representing the available points in the space.\n * @param {Point} queryPoint - The Point object for which we want to find the nearest neighbors.\n * @param {number} k - The number of nearest neighbors to find.\n * @returns {Point[]} An array of the k nearest Point objects to the query point.\n */\nfunction findKNearestNeighbors(points, queryPoint, k) {}", "addition_info": ""}, "typescript": {"code_signature": "class Point {\n    x: number;\n    y: number;\n\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Calculate the Euclidean distance to another point.\n     * @param other - The other Point object.\n     * @returns The distance to the other point.\n     */\n    distanceTo(other: Point): number {\n        return math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);\n    }\n}\n\n/**\n * Find the k nearest neighbors to the query_point.\n * @param points - A list of Point objects representing the available points in the space.\n * @param queryPoint - The Point object for which we want to find the nearest neighbors.\n * @param k - The number of nearest neighbors to find.\n * @returns A list of the k nearest Point objects to the queryPoint.\n */\nfunction findKNearestNeighbors(points: Point[], queryPoint: Point, k: number): Point[] {}", "test_code": "describe('findKNearestNeighbors', () => {\n    \n    const containsPoint = (points: Point[], point: Point): boolean => {\n        return points.some(p => \n            Math.abs(p.x - point.x) < 0.001 && Math.abs(p.y - point.y) < 0.001\n        );\n    };\n\n    test('simple case', () => {\n        const points: Point[] = [\n            new Point(1, 2),\n            new Point(3, 4),\n            new Point(1, -1),\n            new Point(5, 2)\n        ];\n        const queryPoint = new Point(2, 2);\n        const k = 2;\n        const result = findKNearestNeighbors(points, queryPoint, k);\n\n        expect(result.length).toBe(2);\n        expect(containsPoint(result, new Point(1, 2))).toBe(true);\n        expect(containsPoint(result, new Point(3, 4))).toBe(true);\n    });\n\n    test('exact match', () => {\n        const points: Point[] = [\n            new Point(1, 2),\n            new Point(2, 2),\n            new Point(3, 3)\n        ];\n        const queryPoint = new Point(2, 2);\n        const k = 1;\n        const result = findKNearestNeighbors(points, queryPoint, k);\n\n        expect(result.length).toBe(1);\n        expect(Math.abs(result[0].x - 2.0)).toBeLessThan(0.001);\n        expect(Math.abs(result[0].y - 2.0)).toBeLessThan(0.001);\n    });\n\n    test('larger k', () => {\n        const points: Point[] = [\n            new Point(1, 2),\n            new Point(3, 4),\n            new Point(1, -1),\n            new Point(5, 2)\n        ];\n        const queryPoint = new Point(2, 2);\n        const k = 5; // k is larger than the number of points\n        const result = findKNearestNeighbors(points, queryPoint, k);\n\n        expect(result.length).toBe(4);\n    });\n\n    test('empty points', () => {\n        const points: Point[] = [];\n        const queryPoint = new Point(2, 2);\n        const k = 3;\n        const result = findKNearestNeighbors(points, queryPoint, k);\n\n        expect(result.length).toBe(0);\n    });\n\n    test('all points equidistant', () => {\n        const points: Point[] = [\n            new Point(2, 3),\n            new Point(3, 2),\n            new Point(1, 2),\n            new Point(2, 1)\n        ];\n        const queryPoint = new Point(2, 2);\n        const k = 2;\n        const result = findKNearestNeighbors(points, queryPoint, k);\n\n        expect(result.length).toBe(2);\n        expect(containsPoint(result, new Point(2, 3))).toBe(true);\n        expect(containsPoint(result, new Point(3, 2))).toBe(true);\n    });\n});", "prompt": "please write a typescript function , the function signature as below class Point {\n    x: number;\n    y: number;\n\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Calculate the Euclidean distance to another point.\n     * @param other - The other Point object.\n     * @returns The distance to the other point.\n     */\n    distanceTo(other: Point): number {\n        return math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);\n    }\n}\n\n/**\n * Find the k nearest neighbors to the query_point.\n * @param points - A list of Point objects representing the available points in the space.\n * @param queryPoint - The Point object for which we want to find the nearest neighbors.\n * @param k - The number of nearest neighbors to find.\n * @returns A list of the k nearest Point objects to the queryPoint.\n */\nfunction findKNearestNeighbors(points: Point[], queryPoint: Point, k: number): Point[] {}", "addition_info": "class Point {\n    x: number;\n    y: number;\n\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Calculate the Euclidean distance to another point.\n     * @param other - The other Point object.\n     * @returns The distance to the other point.\n     */\n    distanceTo(other: Point): number {\n        return math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);\n    }\n}"}, "c&cpp": {"code_signature": "\nclass Point {\npublic:\n    double x; // X-coordinate of the point\n    double y; // Y-coordinate of the point\n\n    // Constructor for the Point class\n    Point(double x, double y) : x(x), y(y) {}\n\n    // Calculate the Euclidean distance to another point\n    double distance_to(const Point& other) const;\n};\n/**\n * @brief Finds the k nearest neighbors to the specified query point.\n *\n * This function identifies the k nearest neighbors to a given query point \n * from a collection of available points in the space.\n *\n * @param points A list of Point objects representing the available points in the space.\n * @type points std::vector<Point>\n *\n * @param query_point The Point object for which we want to find the nearest neighbors.\n * @type query_point Point\n *\n * @param k The number of nearest neighbors to find.\n * @type k int\n *\n * @return A list of the k nearest Point objects to the query_point.\n * @rtype std::vector<Point>\n */\n\nstd::vector<Point> find_k_nearest_neighbors(const std::vector<Point>& points, const Point& query_point, int k);", "test_code": "TEST_CASE(\"Find k nearest neighbors simple case\") {\n    std::vector<Point> points = {\n        Point(1, 2),\n        Point(3, 4),\n        Point(1, -1),\n        Point(5, 2)\n    };\n    Point query_point(2, 2);\n    int k = 2;\n    auto result = find_k_nearest_neighbors(points, query_point, k);\n\n    REQUIRE(result.size() == 2);\n    REQUIRE(contains_point(result, Point(1, 2)));\n    REQUIRE(contains_point(result, Point(3, 4)));\n}\n\nTEST_CASE(\"Find k nearest neighbors exact match\") {\n    std::vector<Point> points = {\n        Point(1, 2),\n        Point(2, 2),\n        Point(3, 3)\n    };\n    Point query_point(2, 2);\n    int k = 1;\n    auto result = find_k_nearest_neighbors(points, query_point, k);\n\n    REQUIRE(result.size() == 1);\n    REQUIRE(std::fabs(result[0].x - 2.0) < 0.001);\n    REQUIRE(std::fabs(result[0].y - 2.0) < 0.001);\n}\n\nTEST_CASE(\"Find k nearest neighbors larger k\") {\n    std::vector<Point> points = {\n        Point(1, 2),\n        Point(3, 4),\n        Point(1, -1),\n        Point(5, 2)\n    };\n    Point query_point(2, 2);\n    int k = 5; // k is larger than the number of points\n    auto result = find_k_nearest_neighbors(points, query_point, k);\n\n    REQUIRE(result.size() == 4);\n}\n\nTEST_CASE(\"Find k nearest neighbors empty points\") {\n    std::vector<Point> points = {};\n    Point query_point(2, 2);\n    int k = 3;\n    auto result = find_k_nearest_neighbors(points, query_point, k);\n\n    REQUIRE(result.size() == 0);\n}\n\nTEST_CASE(\"Find k nearest neighbors all points equidistant\") {\n    std::vector<Point> points = {\n        Point(2, 3),\n        Point(3, 2),\n        Point(1, 2),\n        Point(2, 1)\n    };\n    Point query_point(2, 2);\n    int k = 2;\n    auto result = find_k_nearest_neighbors(points, query_point, k);\n\n    REQUIRE(result.size() == 2);\n    REQUIRE(contains_point(result, Point(2, 3)));\n    REQUIRE(contains_point(result, Point(3, 2)));\n}", "prompt": "please write a cpp function , the function signature as below \nclass Point {\npublic:\n    double x; // X-coordinate of the point\n    double y; // Y-coordinate of the point\n\n    // Constructor for the Point class\n    Point(double x, double y) : x(x), y(y) {}\n\n    // Calculate the Euclidean distance to another point\n    double distance_to(const Point& other) const;\n};\n/**\n * @brief Finds the k nearest neighbors to the specified query point.\n *\n * This function identifies the k nearest neighbors to a given query point \n * from a collection of available points in the space.\n *\n * @param points A list of Point objects representing the available points in the space.\n * @type points std::vector<Point>\n *\n * @param query_point The Point object for which we want to find the nearest neighbors.\n * @type query_point Point\n *\n * @param k The number of nearest neighbors to find.\n * @type k int\n *\n * @return A list of the k nearest Point objects to the query_point.\n * @rtype std::vector<Point>\n */\n\nstd::vector<Point> find_k_nearest_neighbors(const std::vector<Point>& points, const Point& query_point, int k);", "addition_info": ""}, "java": {"code_signature": "/**\n * Given a set of points and a query point, write an algorithm to find the K nearest neighbors to the query point. The algorithm should efficiently handle large datasets, and the output should include the coordinates or indices of these neighbors.\n *\n * @param points Array of points from which to find the nearest neighbors.\n * @param queryPoint The point to which the nearest neighbors are found.\n * @param k The number of nearest neighbors to find.\n * @return An array containing the k nearest neighbors.\n */\nclass Point {\n    double x, y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public double distanceTo(Point other) {\n        return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2));\n    }\n}\npublic Point[] findKNearestNeighbors(Point[] points, Point queryPoint, int k) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; \nimport static org.junit.Assert.assertEquals; \nimport static org.junit.Assert.assertTrue; \n\nimport org.real.temp.*;\n\npublic class Tester {\n    @Test\n    public void testFindKNearestNeighbors_SimpleCase() {\n        Answer knn = new Answer();\n        Answer.Point[] points = {\n                new Answer.Point(1, 2),\n                new Answer.Point(3, 4),\n                new Answer.Point(1, -1),\n                new Answer.Point(5, 2)\n        };\n        Answer.Point queryPoint = new Answer.Point(2, 2);\n        int k = 2;\n\n        Answer.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(2, result.length);\n        assertTrue(containsPoint(result, new Answer.Point(1, 2)));\n        assertTrue(containsPoint(result, new Answer.Point(3, 4)));\n    }\n\n    @Test\n    public void testFindKNearestNeighbors_ExactMatch() {\n        Answer knn = new Answer();\n        Answer.Point[] points = {\n                new Answer.Point(1, 2),\n                new Answer.Point(2, 2),\n                new Answer.Point(3, 3)\n        };\n        Answer.Point queryPoint = new Answer.Point(2, 2);\n        int k = 1;\n\n        Answer.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(1, result.length);\n        assertEquals(2.0, result[0].x, 0.001);\n        assertEquals(2.0, result[0].y, 0.001);\n    }\n\n    @Test\n    public void testFindKNearestNeighbors_LargerK() {\n        Answer knn = new Answer();\n        Answer.Point[] points = {\n                new Answer.Point(1, 2),\n                new Answer.Point(3, 4),\n                new Answer.Point(1, -1),\n                new Answer.Point(5, 2)\n        };\n        Answer.Point queryPoint = new Answer.Point(2, 2);\n        int k = 5;  // k is larger than the number of points\n\n        Answer.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(4, result.length);\n    }\n\n    @Test\n    public void testFindKNearestNeighbors_EmptyPoints() {\n        Answer knn = new Answer();\n        Answer.Point[] points = {};\n        Answer.Point queryPoint = new Answer.Point(2, 2);\n        int k = 3;\n\n        Answer.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(0, result.length);\n    }\n\n    @Test\n    public void testFindKNearestNeighbors_AllPointsEquidistant() {\n        Answer knn = new Answer();\n        Answer.Point[] points = {\n                new Answer.Point(2, 3),\n                new Answer.Point(3, 2),\n                new Answer.Point(1, 2),\n                new Answer.Point(2, 1)\n        };\n        Answer.Point queryPoint = new Answer.Point(2, 2);\n        int k = 2;\n\n        Answer.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(2, result.length);\n        assertTrue(containsPoint(result, new Answer.Point(2, 3)));\n        assertTrue(containsPoint(result, new Answer.Point(3, 2)));\n    }\n\n    private boolean containsPoint(Answer.Point[] points, Answer.Point point) {\n        for (Answer.Point p : points) {\n            if (Math.abs(p.x - point.x) < 0.001 && Math.abs(p.y - point.y) < 0.001) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Given a set of points and a query point, write an algorithm to find the K nearest neighbors to the query point. The algorithm should efficiently handle large datasets, and the output should include the coordinates or indices of these neighbors.\n *\n * @param points Array of points from which to find the nearest neighbors.\n * @param queryPoint The point to which the nearest neighbors are found.\n * @param k The number of nearest neighbors to find.\n * @return An array containing the k nearest neighbors.\n */\nclass Point {\n    double x, y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public double distanceTo(Point other) {\n        return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2));\n    }\n}\npublic Point[] findKNearestNeighbors(Point[] points, Point queryPoint, int k) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 177, "code_type": "method", "original_language": "java", "question_type": "Security", "summary": "Generates a 16-byte random salt value and hashes the password with that salt value and the SHA-256 hash algorithm", "language_version_list": {"python": {"code_signature": "import hashlib\nimport os\n\n\ndef hash_password_with_salt(password: str) -> bytes:\n    \"\"\"\n    Generates a 16-byte random salt value, hashes the provided password with that salt\n    using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n\n    Args:\n        password (str): The password to be hashed.\n\n    Returns:\n        bytes: A byte array containing the salt followed by the hashed password.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    def test_hashPasswordWithSaltLength(self):\n        \"\"\"Test that the hashPasswordWithSalt method returns a byte array with the correct length.\"\"\"\n        password = \"testPassword\"\n        result = hash_password_with_salt(password)\n        # SHA-256 hash length is 32 bytes, and the salt length is 16 bytes\n        self.assertEqual(len(result), 48, \"The combined salt and hashed password length should be 48 bytes.\")\n\n    def test_saltIsIncludedInResult(self):\n        \"\"\"Test that the salt is correctly generated and included in the hash result.\"\"\"\n        password = \"testPassword\"\n        result = hash_password_with_salt(password)\n        salt = result[:16]  # First 16 bytes represent the salt\n        self.assertIsNotNone(salt, \"Salt should not be None.\")\n        self.assertEqual(len(salt), 16, \"Salt length should be 16 bytes.\")\n\n    def test_differentPasswordsProduceDifferentHashes(self):\n        \"\"\"Test that two different passwords produce different hashes, even with the same salt.\"\"\"\n        password1 = \"password123\"\n        password2 = \"password456\"\n        hash1 = hash_password_with_salt(password1)\n        hash2 = hash_password_with_salt(password2)\n        self.assertNotEqual(hash1, hash2, \"Different passwords should produce different hashes.\")\n\n    def test_samePasswordDifferentSalts(self):\n        \"\"\"Test that the same password produces different hashes when hashed with different salts.\"\"\"\n        password = \"password123\"\n        hash1 = hash_password_with_salt(password)\n        hash2 = hash_password_with_salt(password)\n        # The salt is generated randomly, so the hashes should be different.\n        self.assertNotEqual(hash1, hash2, \"The same password should produce different hashes with different salts.\")", "prompt": "please write a python function , the function signature as below import hashlib\nimport os\n\n\ndef hash_password_with_salt(password: str) -> bytes:\n    \"\"\"\n    Generates a 16-byte random salt value, hashes the provided password with that salt\n    using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n\n    Args:\n        password (str): The password to be hashed.\n\n    Returns:\n        bytes: A byte array containing the salt followed by the hashed password.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "const crypto = require('crypto');\n\n/**\n * Generates a 16-byte random salt value, hashes the provided password with that salt\n * using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n *\n * @param {string} password - The password to be hashed.\n * @returns {Buffer} A byte array containing the salt followed by the hashed password.\n */\nfunction hashPasswordWithSalt(password) {}", "test_code": "describe('Hashing Tests', () => {\n    test('hashPasswordWithSalt returns a byte array with the correct length', () => {\n        // Test that the hashPasswordWithSalt method returns a byte array with the correct length.\n        const password = \"testPassword\";\n        const result = hashPasswordWithSalt(password);\n        // SHA-256 hash length is 32 bytes, and the salt length is 16 bytes\n        expect(result.length).toBe(48);\n    });\n\n    test('salt is included in result', () => {\n        // Test that the salt is correctly generated and included in the hash result.\n        const password = \"testPassword\";\n        const result = hashPasswordWithSalt(password);\n        const salt = result.slice(0, 16); // First 16 bytes represent the salt\n        expect(salt).not.toBeNull();\n        expect(salt.length).toBe(16);\n    });\n\n    test('different passwords produce different hashes', () => {\n        // Test that two different passwords produce different hashes, even with the same salt.\n        const password1 = \"password123\";\n        const password2 = \"password456\";\n        const hash1 = hashPasswordWithSalt(password1);\n        const hash2 = hashPasswordWithSalt(password2);\n        expect(hash1.equals(hash2)).toBe(false); // Comparing Buffers\n    });\n\n    test('same password different salts', () => {\n        // Test that the same password produces different hashes when hashed with different salts.\n        const password = \"password123\";\n        const hash1 = hashPasswordWithSalt(password);\n        const hash2 = hashPasswordWithSalt(password);\n        expect(hash1.equals(hash2)).toBe(false); // The salt is generated randomly, so the hashes should be different.\n    });\n});", "prompt": "please write a javascript function , the function signature as below const crypto = require('crypto');\n\n/**\n * Generates a 16-byte random salt value, hashes the provided password with that salt\n * using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n *\n * @param {string} password - The password to be hashed.\n * @returns {Buffer} A byte array containing the salt followed by the hashed password.\n */\nfunction hashPasswordWithSalt(password) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as crypto from 'crypto';\n\n/**\n * Generates a 16-byte random salt value, hashes the provided password with that salt\n * using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n * \n * @param password - The password to be hashed.\n * @returns A Buffer containing the salt followed by the hashed password.\n */\nfunction hashPasswordWithSalt(password: string): Buffer {}", "test_code": "describe('Tester', () => {\n    test('hashPasswordWithSalt returns correct length', () => {\n        const password = 'testPassword';\n        const result = hashPasswordWithSalt(password);\n        // SHA-256 hash length is 32 bytes, and the salt length is 16 bytes\n        expect(result.length).toBe(48);\n    });\n\n    test('salt is included in result', () => {\n        const password = 'testPassword';\n        const result = hashPasswordWithSalt(password);\n        const salt = result.slice(0, 16); // First 16 bytes represent the salt\n        expect(salt).not.toBeNull();\n        expect(salt.length).toBe(16);\n    });\n\n    test('different passwords produce different hashes', () => {\n        const password1 = 'password123';\n        const password2 = 'password456';\n        const hash1 = hashPasswordWithSalt(password1);\n        const hash2 = hashPasswordWithSalt(password2);\n        expect(hash1).not.toEqual(hash2);\n    });\n\n    test('same password different salts', () => {\n        const password = 'password123';\n        const hash1 = hashPasswordWithSalt(password);\n        const hash2 = hashPasswordWithSalt(password);\n        // The salt is generated randomly, so the hashes should be different.\n        expect(hash1).not.toEqual(hash2);\n    });\n});", "prompt": "please write a typescript function , the function signature as below import * as crypto from 'crypto';\n\n/**\n * Generates a 16-byte random salt value, hashes the provided password with that salt\n * using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n * \n * @param password - The password to be hashed.\n * @returns A Buffer containing the salt followed by the hashed password.\n */\nfunction hashPasswordWithSalt(password: string): Buffer {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Generates a 16-byte random salt value, hashes the provided password with that salt\n *        using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n *\n * @param password The password to be hashed.\n *\n * @return A byte array containing the salt followed by the hashed password.\n */\nstd::vector<uint8_t> hash_password_with_salt(const std::string& password);", "test_code": "TEST_CASE(\"Hash Password with Salt Length\", \"[hashing]\") {\n    /* Test that the hashPasswordWithSalt method returns a byte array with the correct length. */\n    std::string password = \"testPassword\";\n    auto result = hash_password_with_salt(password);\n    // SHA-256 hash length is 32 bytes, and the salt length is 16 bytes\n    REQUIRE(result.size() == 48);\n}\n\nTEST_CASE(\"Salt Is Included In Result\", \"[hashing]\") {\n    /* Test that the salt is correctly generated and included in the hash result. */\n    std::string password = \"testPassword\";\n    auto result = hash_password_with_salt(password);\n    std::vector<uint8_t> salt(result.begin(), result.begin() + 16);  // First 16 bytes represent the salt\n    REQUIRE(salt.size() == 16);\n    REQUIRE(salt.data() != nullptr);\n}\n\nTEST_CASE(\"Different Passwords Produce Different Hashes\", \"[hashing]\") {\n    /* Test that two different passwords produce different hashes, even with the same salt. */\n    std::string password1 = \"password123\";\n    std::string password2 = \"password456\";\n    auto hash1 = hash_password_with_salt(password1);\n    auto hash2 = hash_password_with_salt(password2);\n    REQUIRE(hash1 != hash2);\n}\n\nTEST_CASE(\"Same Password Different Salts\", \"[hashing]\") {\n    /* Test that the same password produces different hashes when hashed with different salts. */\n    std::string password = \"password123\";\n    auto hash1 = hash_password_with_salt(password);\n    auto hash2 = hash_password_with_salt(password);\n    // The salt is generated randomly, so the hashes should be different.\n    REQUIRE(hash1 != hash2);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Generates a 16-byte random salt value, hashes the provided password with that salt\n *        using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n *\n * @param password The password to be hashed.\n *\n * @return A byte array containing the salt followed by the hashed password.\n */\nstd::vector<uint8_t> hash_password_with_salt(const std::string& password);", "addition_info": ""}, "java": {"code_signature": "/**\n * Generates a 16-byte random salt value, hashes the provided password with that salt\n * using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n *\n * @param password The password to be hashed.\n * @return A byte array containing the salt followed by the hashed password.\n * @throws NoSuchAlgorithmException If the SHA-256 algorithm is not available.\n */\npublic static byte[] hashPasswordWithSalt(String password) throws NoSuchAlgorithmException {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*; \nimport java.security.NoSuchAlgorithmException; \nimport org.real.temp.*;\nimport java.util.Arrays;\n\n\npublic class Tester {\n\n    /**\n     * Test that the hashPasswordWithSalt method returns a byte array with the correct length.\n     * The length should be 48 bytes (16 bytes of salt + 32 bytes of SHA-256 hash).\n     */\n    @Test\n    public void testHashPasswordWithSaltLength() throws NoSuchAlgorithmException {\n        String password = \"testPassword\";\n        byte[] result = Answer.hashPasswordWithSalt(password);\n\n        // SHA-256 hash length is 32 bytes, and the salt length is 16 bytes\n        assertEquals(48, result.length);\n    }\n\n    /**\n     * Test that the salt is correctly generated and included in the hash result.\n     * The first 16 bytes of the result should represent the salt.\n     */\n    @Test\n    public void testSaltIsIncludedInResult() throws NoSuchAlgorithmException {\n        String password = \"testPassword\";\n        byte[] result = Answer.hashPasswordWithSalt(password);\n\n        byte[] salt = Arrays.copyOfRange(result, 0, 16);\n\n        assertEquals(16, salt.length);\n    }\n\n    /**\n     * Test that two different passwords produce different hashes, even with the same salt.\n     */\n    @Test\n    public void testDifferentPasswordsProduceDifferentHashes() throws NoSuchAlgorithmException {\n        String password1 = \"password123\";\n        String password2 = \"password456\";\n\n        byte[] hash1 = Answer.hashPasswordWithSalt(password1);\n        byte[] hash2 = Answer.hashPasswordWithSalt(password2);\n\n        assertNotEquals(Arrays.toString(hash1), Arrays.toString(hash2), \"Different passwords should produce different hashes.\");\n    }\n\n    /**\n     * Test that the same password produces different hashes when hashed with different salts.\n     */\n    @Test\n    public void testSamePasswordDifferentSalts() throws NoSuchAlgorithmException {\n        String password = \"password123\";\n\n        byte[] hash1 = Answer.hashPasswordWithSalt(password);\n        byte[] hash2 = Answer.hashPasswordWithSalt(password);\n\n        // The salt is generated randomly, so the hashes should be different.\n        assertNotEquals(Arrays.toString(hash1), Arrays.toString(hash2), \"The same password should produce different hashes with different salts.\");\n    }\n\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Generates a 16-byte random salt value, hashes the provided password with that salt\n * using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n *\n * @param password The password to be hashed.\n * @return A byte array containing the salt followed by the hashed password.\n * @throws NoSuchAlgorithmException If the SHA-256 algorithm is not available.\n */\npublic static byte[] hashPasswordWithSalt(String password) throws NoSuchAlgorithmException {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 178, "code_type": "method", "original_language": "java", "question_type": "Algorithm and data structure", "summary": "Find the longest non-decreasing subsequence in the given list.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef find_longest_non_decreasing_subsequence(nums: List[int]) -> List[int]:\n    \"\"\"Find the longest non-decreasing subsequence in the given list.\n\n    Args:\n        nums (List[int]): The input array of integers.\n\n    Returns:\n        List[int]: A list containing the longest non-decreasing subsequence.\n    \"\"\"\n", "test_code": "import unittest\nfrom typing import List\n\n\nclass TestAnswer(unittest.TestCase):\n\n    def test_non_decreasing_sequence(self):\n        nums = [5, 7, 4, 8, 6, 10, 2, 11]\n        expected: List[int] = [5, 7, 8, 10, 11]\n        self.assertEqual(expected, find_longest_non_decreasing_subsequence(nums))\n\n    def test_all_increasing(self):\n        nums = [1, 2, 3, 4, 5]\n        expected: List[int] = [1, 2, 3, 4, 5]\n        self.assertEqual(expected, find_longest_non_decreasing_subsequence(nums))\n\n    def test_all_decreasing(self):\n        nums = [5, 4, 3, 2, 1]\n        expected: List[int] = [5]\n        self.assertEqual(expected, find_longest_non_decreasing_subsequence(nums))\n\n    def test_single_element(self):\n        nums = [10]\n        expected: List[int] = [10]\n        self.assertEqual(expected, find_longest_non_decreasing_subsequence(nums))\n\n    def test_empty_array(self):\n        nums = []\n        expected: List[int] = []\n        self.assertEqual(expected, find_longest_non_decreasing_subsequence(nums))", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_longest_non_decreasing_subsequence(nums: List[int]) -> List[int]:\n    \"\"\"Find the longest non-decreasing subsequence in the given list.\n\n    Args:\n        nums (List[int]): The input array of integers.\n\n    Returns:\n        List[int]: A list containing the longest non-decreasing subsequence.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Find the longest non-decreasing subsequence in the given array.\n *\n * @param {number[]} nums - The input array of integers.\n * @returns {number[]} A list containing the longest non-decreasing subsequence.\n */\nfunction findLongestNonDecreasingSubsequence(nums) {}", "test_code": "describe('TestAnswer', () => {\n    test('non-decreasing sequence', () => {\n        const nums = [5, 7, 4, 8, 6, 10, 2, 11];\n        const expected = [5, 7, 8, 10, 11];\n        expect(findLongestNonDecreasingSubsequence(nums)).toEqual(expected);\n    });\n\n    test('all increasing', () => {\n        const nums = [1, 2, 3, 4, 5];\n        const expected = [1, 2, 3, 4, 5];\n        expect(findLongestNonDecreasingSubsequence(nums)).toEqual(expected);\n    });\n\n    test('all decreasing', () => {\n        const nums = [5, 4, 3, 2, 1];\n        const expected = [5];\n        expect(findLongestNonDecreasingSubsequence(nums)).toEqual(expected);\n    });\n\n    test('single element', () => {\n        const nums = [10];\n        const expected = [10];\n        expect(findLongestNonDecreasingSubsequence(nums)).toEqual(expected);\n    });\n\n    test('empty array', () => {\n        const nums = [];\n        const expected = [];\n        expect(findLongestNonDecreasingSubsequence(nums)).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Find the longest non-decreasing subsequence in the given array.\n *\n * @param {number[]} nums - The input array of integers.\n * @returns {number[]} A list containing the longest non-decreasing subsequence.\n */\nfunction findLongestNonDecreasingSubsequence(nums) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Find the longest non-decreasing subsequence in the given array.\n *\n * @param nums - The input array of integers.\n * @returns A list containing the longest non-decreasing subsequence.\n */\nfunction findLongestNonDecreasingSubsequence(nums: number[]): number[] {}", "test_code": "describe('TestAnswer', () => {\n    test('non-decreasing sequence', () => {\n        const nums: number[] = [5, 7, 4, 8, 6, 10, 2, 11];\n        const expected: number[] = [5, 7, 8, 10, 11];\n        expect(findLongestNonDecreasingSubsequence(nums)).toEqual(expected);\n    });\n\n    test('all increasing', () => {\n        const nums: number[] = [1, 2, 3, 4, 5];\n        const expected: number[] = [1, 2, 3, 4, 5];\n        expect(findLongestNonDecreasingSubsequence(nums)).toEqual(expected);\n    });\n\n    test('all decreasing', () => {\n        const nums: number[] = [5, 4, 3, 2, 1];\n        const expected: number[] = [5];\n        expect(findLongestNonDecreasingSubsequence(nums)).toEqual(expected);\n    });\n\n    test('single element', () => {\n        const nums: number[] = [10];\n        const expected: number[] = [10];\n        expect(findLongestNonDecreasingSubsequence(nums)).toEqual(expected);\n    });\n\n    test('empty array', () => {\n        const nums: number[] = [];\n        const expected: number[] = [];\n        expect(findLongestNonDecreasingSubsequence(nums)).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Find the longest non-decreasing subsequence in the given array.\n *\n * @param nums - The input array of integers.\n * @returns A list containing the longest non-decreasing subsequence.\n */\nfunction findLongestNonDecreasingSubsequence(nums: number[]): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds the longest non-decreasing subsequence in the given list of integers.\n *\n * @param nums The input array of integers.\n *\n * @return A vector containing the longest non-decreasing subsequence.\n */\n\nstd::vector<int> find_longest_non_decreasing_subsequence(const std::vector<int>& nums);", "test_code": "TEST_CASE(\"Test longest non-decreasing subsequence\") {\n    SECTION(\"Non-decreasing sequence\") {\n        std::vector<int> nums = {5, 7, 4, 8, 6, 10, 2, 11};\n        std::vector<int> expected = {5, 7, 8, 10, 11};\n        REQUIRE(expected == find_longest_non_decreasing_subsequence(nums));\n    }\n\n    SECTION(\"All increasing\") {\n        std::vector<int> nums = {1, 2, 3, 4, 5};\n        std::vector<int> expected = {1, 2, 3, 4, 5};\n        REQUIRE(expected == find_longest_non_decreasing_subsequence(nums));\n    }\n\n    SECTION(\"All decreasing\") {\n        std::vector<int> nums = {5, 4, 3, 2, 1};\n        std::vector<int> expected = {5};\n        REQUIRE(expected == find_longest_non_decreasing_subsequence(nums));\n    }\n\n    SECTION(\"Single element\") {\n        std::vector<int> nums = {10};\n        std::vector<int> expected = {10};\n        REQUIRE(expected == find_longest_non_decreasing_subsequence(nums));\n    }\n\n    SECTION(\"Empty array\") {\n        std::vector<int> nums = {};\n        std::vector<int> expected = {};\n        REQUIRE(expected == find_longest_non_decreasing_subsequence(nums));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds the longest non-decreasing subsequence in the given list of integers.\n *\n * @param nums The input array of integers.\n *\n * @return A vector containing the longest non-decreasing subsequence.\n */\n\nstd::vector<int> find_longest_non_decreasing_subsequence(const std::vector<int>& nums);", "addition_info": ""}, "java": {"code_signature": "/**\n * Find the longest non-decreasing subsequence in the given list.\n *\n * @param nums The input array of integers.\n * @return A list containing the longest non-decreasing subsequence.\n */\npublic static List<Integer> findLongestNonDecreasingSubsequence(int[] nums) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; // JUnit 4 Test annotation\nimport static org.junit.Assert.assertEquals; // JUnit 4 assertEquals\nimport java.util.Arrays;\nimport java.util.List;\n\n\nimport org.real.temp.*;\npublic class Tester {\n    @Test\n    public void testNonDecreasingSequence() {\n        int[] nums = {5, 7, 4, 8, 6, 10, 2, 11};\n        List<Integer> expected = Arrays.asList(5, 7, 8, 10, 11);\n        assertEquals(expected, Answer.findLongestNonDecreasingSubsequence(nums));\n    }\n\n    @Test\n    public void testAllIncreasing() {\n        int[] nums = {1, 2, 3, 4, 5};\n        List<Integer> expected = Arrays.asList(1, 2, 3, 4, 5);\n        assertEquals(expected, Answer.findLongestNonDecreasingSubsequence(nums));\n    }\n\n    @Test\n    public void testAllDecreasing() {\n        int[] nums = {5, 4, 3, 2, 1};\n        List<Integer> expected = Arrays.asList(5);\n        assertEquals(expected, Answer.findLongestNonDecreasingSubsequence(nums));\n    }\n\n    @Test\n    public void testSingleElement() {\n        int[] nums = {10};\n        List<Integer> expected = Arrays.asList(10);\n        assertEquals(expected, Answer.findLongestNonDecreasingSubsequence(nums));\n    }\n\n    @Test\n    public void testEmptyArray() {\n        int[] nums = {};\n        List<Integer> expected = Arrays.asList();\n        assertEquals(expected, Answer.findLongestNonDecreasingSubsequence(nums));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Find the longest non-decreasing subsequence in the given list.\n *\n * @param nums The input array of integers.\n * @return A list containing the longest non-decreasing subsequence.\n */\npublic static List<Integer> findLongestNonDecreasingSubsequence(int[] nums) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 179, "code_type": "method", "original_language": "java", "question_type": "File operations and I/O operation", "summary": "Copies all files and subdirectories in a directory to the specified directory", "language_version_list": {"python": {"code_signature": "def copy_directory(source_dir: str, target_dir: str) -> None:\n    \"\"\"\n    Copies all files and subdirectories from the source directory to the target directory.\n\n    Args:\n        source_dir (str): The source directory from which files and subdirectories will be copied.\n        target_dir (str): The target directory to which files and subdirectories will be copied.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import os\nimport shutil\nimport unittest\n\n\nclass TestDirectoryOperations(unittest.TestCase):\n\n    def setUp(self):\n        self.source_dir = \"testSourceDir\"\n        self.target_dir = \"testTargetDir\"\n\n        os.makedirs(self.source_dir, exist_ok=True)\n        os.makedirs(self.target_dir, exist_ok=True)\n\n    def tearDown(self):\n        self.delete_directory(self.source_dir)\n        self.delete_directory(self.target_dir)\n\n    def delete_directory(self, dir_path):\n        if os.path.exists(dir_path):\n            shutil.rmtree(dir_path)\n\n    def test_copy_empty_directory(self):\n        # Simulating Answer.copyDirectory functionality\n        copy_directory(self.source_dir, self.target_dir)\n\n        self.assertTrue(os.path.exists(self.target_dir), \"Target directory should exist after copying.\")\n        self.assertTrue(os.path.isdir(self.target_dir), \"Target directory should be a directory.\")\n        self.assertEqual(len(os.listdir(self.target_dir)), 0, \"Target directory should be empty.\")\n\n    def test_copy_directory_with_files(self):\n        test_file = os.path.join(self.source_dir, \"testFile.txt\")\n        with open(test_file, 'w') as f:\n            f.write(\"Sample content\")\n\n        copy_directory(self.source_dir, self.target_dir)\n\n        copied_file = os.path.join(self.target_dir, \"testFile.txt\")\n        self.assertTrue(os.path.exists(copied_file), \"File should be copied to target directory.\")\n        self.assertEqual(os.path.getsize(test_file), os.path.getsize(copied_file),\n                         \"File size should be the same after copying.\")\n\n    def test_non_existent_source_directory(self):\n        non_existent_dir = \"nonExistentDir\"\n\n        with self.assertRaises(Exception) as context:\n            copy_directory(non_existent_dir, self.target_dir)\n\n    def test_copy_directory_with_subdirectories(self):\n        sub_dir = os.path.join(self.source_dir, \"subDir\")\n        os.makedirs(sub_dir, exist_ok=True)\n        test_file = os.path.join(sub_dir, \"testFile.txt\")\n        with open(test_file, 'w') as f:\n            f.write(\"Sample content in subdirectory\")\n\n        copy_directory(self.source_dir, self.target_dir)\n\n        copied_sub_dir = os.path.join(self.target_dir, \"subDir\")\n        copied_file = os.path.join(copied_sub_dir, \"testFile.txt\")\n\n        self.assertTrue(os.path.exists(copied_sub_dir), \"Subdirectory should be copied to target directory.\")\n        self.assertTrue(os.path.exists(copied_file), \"File within subdirectory should be copied to target directory.\")\n\n    def test_overwrite_file_in_target_directory(self):\n        # Create a source file with some content\n        test_file = os.path.join(self.source_dir, \"testFile.txt\")\n        with open(test_file, 'w') as f:\n            f.write(\"Source content\")\n\n        # Create a target file with different content\n        target_file = os.path.join(self.target_dir, \"testFile.txt\")\n        with open(target_file, 'w') as f:\n            f.write(\"Target content\")\n\n        # Copy the directory, which should overwrite the target file\n        copy_directory(self.source_dir, self.target_dir)\n\n        copied_file = os.path.join(self.target_dir, \"testFile.txt\")\n        self.assertTrue(os.path.exists(copied_file), \"File should be copied to target directory.\")\n\n        # Check that the content of the file is now the same as the source file\n        with open(copied_file, 'r') as f:\n            copied_content = f.read()\n\n        self.assertEqual(copied_content, \"Source content\",\n                         \"File in target directory should be overwritten with source content.\")\n", "prompt": "please write a python function , the function signature as below def copy_directory(source_dir: str, target_dir: str) -> None:\n    \"\"\"\n    Copies all files and subdirectories from the source directory to the target directory.\n\n    Args:\n        source_dir (str): The source directory from which files and subdirectories will be copied.\n        target_dir (str): The target directory to which files and subdirectories will be copied.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Copies all files and subdirectories from the source directory to the target directory.\n *\n * @param {string} sourceDir - The source directory from which files and subdirectories will be copied.\n * @param {string} targetDir - The target directory to which files and subdirectories will be copied.\n * @returns {void}\n */\nfunction copyDirectory(sourceDir, targetDir) {}", "test_code": "const fs = require('fs');\nconst path = require('path');\ndescribe('Directory Operations', () => {\n    const sourceDir = 'testSourceDir';\n    const targetDir = 'testTargetDir';\n\n    beforeEach(() => {\n        // Setup: Create source and target directories\n        fs.mkdirSync(sourceDir, { recursive: true });\n        fs.mkdirSync(targetDir, { recursive: true });\n    });\n\n    afterEach(() => {\n        // Teardown: Delete source and target directories\n        deleteDirectory(sourceDir);\n        deleteDirectory(targetDir);\n    });\n\n    function deleteDirectory(dirPath) {\n        if (fs.existsSync(dirPath)) {\n            fs.rmdirSync(dirPath, { recursive: true });\n        }\n    }\n\n    test('copy empty directory', () => {\n        // Simulating copyDirectory functionality\n        copyDirectory(sourceDir, targetDir);\n\n        expect(fs.existsSync(targetDir)).toBe(true);\n        expect(fs.statSync(targetDir).isDirectory()).toBe(true);\n        expect(fs.readdirSync(targetDir).length).toBe(0);\n    });\n\n    test('copy directory with files', () => {\n        const testFile = path.join(sourceDir, 'testFile.txt');\n        fs.writeFileSync(testFile, 'Sample content');\n\n        copyDirectory(sourceDir, targetDir);\n\n        const copiedFile = path.join(targetDir, 'testFile.txt');\n        expect(fs.existsSync(copiedFile)).toBe(true);\n        expect(fs.statSync(testFile).size).toBe(fs.statSync(copiedFile).size);\n    });\n\n    test('non-existent source directory', () => {\n        const nonExistentDir = 'nonExistentDir';\n\n        expect(() => {\n            copyDirectory(nonExistentDir, targetDir);\n        }).toThrow('Source directory does not exist.');\n    });\n\n    test('copy directory with subdirectories', () => {\n        const subDir = path.join(sourceDir, 'subDir');\n        fs.mkdirSync(subDir, { recursive: true });\n        const testFile = path.join(subDir, 'testFile.txt');\n        fs.writeFileSync(testFile, 'Sample content in subdirectory');\n\n        copyDirectory(sourceDir, targetDir);\n\n        const copiedSubDir = path.join(targetDir, 'subDir');\n        const copiedFile = path.join(copiedSubDir, 'testFile.txt');\n\n        expect(fs.existsSync(copiedSubDir)).toBe(true);\n        expect(fs.existsSync(copiedFile)).toBe(true);\n    });\n\n    test('overwrite file in target directory', () => {\n        // Create a source file with some content\n        const testFile = path.join(sourceDir, 'testFile.txt');\n        fs.writeFileSync(testFile, 'Source content');\n\n        // Create a target file with different content\n        const targetFile = path.join(targetDir, 'testFile.txt');\n        fs.writeFileSync(targetFile, 'Target content');\n\n        // Copy the directory, which should overwrite the target file\n        copyDirectory(sourceDir, targetDir);\n\n        const copiedFile = path.join(targetDir, 'testFile.txt');\n        expect(fs.existsSync(copiedFile)).toBe(true);\n\n        // Check that the content of the file is now the same as the source file\n        const copiedContent = fs.readFileSync(copiedFile, 'utf-8');\n        expect(copiedContent).toBe('Source content');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Copies all files and subdirectories from the source directory to the target directory.\n *\n * @param {string} sourceDir - The source directory from which files and subdirectories will be copied.\n * @param {string} targetDir - The target directory to which files and subdirectories will be copied.\n * @returns {void}\n */\nfunction copyDirectory(sourceDir, targetDir) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Copies all files and subdirectories from the source directory to the target directory.\n *\n * @param sourceDir - The source directory from which files and subdirectories will be copied.\n * @param targetDir - The target directory to which files and subdirectories will be copied.\n */\nfunction copyDirectory(sourceDir: string, targetDir: string): void {}", "test_code": "import fs from 'fs';\nimport path from 'path';\ndescribe('TestDirectoryOperations', () => {\n    const sourceDir = 'testSourceDir';\n    const targetDir = 'testTargetDir';\n\n    beforeAll(() => {\n        fs.mkdirSync(sourceDir, { recursive: true });\n        fs.mkdirSync(targetDir, { recursive: true });\n    });\n\n    afterAll(() => {\n        deleteDirectory(sourceDir);\n        deleteDirectory(targetDir);\n    });\n\n    const deleteDirectory = (dirPath: string): void => {\n        if (fs.existsSync(dirPath)) {\n            fs.rmdirSync(dirPath, { recursive: true });\n        }\n    };\n\n    test('copy empty directory', () => {\n        copyDirectory(sourceDir, targetDir);\n        expect(fs.existsSync(targetDir)).toBe(true);\n        expect(fs.statSync(targetDir).isDirectory()).toBe(true);\n        expect(fs.readdirSync(targetDir).length).toBe(0);\n    });\n\n    test('copy directory with files', () => {\n        const testFile = path.join(sourceDir, 'testFile.txt');\n        fs.writeFileSync(testFile, 'Sample content');\n\n        copyDirectory(sourceDir, targetDir);\n        \n        const copiedFile = path.join(targetDir, 'testFile.txt');\n        expect(fs.existsSync(copiedFile)).toBe(true);\n        expect(fs.statSync(testFile).size).toBe(fs.statSync(copiedFile).size);\n    });\n\n    test('non-existent source directory', () => {\n        const nonExistentDir = 'nonExistentDir';\n        expect(() => {\n            copyDirectory(nonExistentDir, targetDir);\n        }).toThrowError(new Error('Source directory does not exist.'));\n    });\n\n    test('copy directory with subdirectories', () => {\n        const subDir = path.join(sourceDir, 'subDir');\n        fs.mkdirSync(subDir, { recursive: true });\n        const testFile = path.join(subDir, 'testFile.txt');\n        fs.writeFileSync(testFile, 'Sample content in subdirectory');\n\n        copyDirectory(sourceDir, targetDir);\n\n        const copiedSubDir = path.join(targetDir, 'subDir');\n        const copiedFile = path.join(copiedSubDir, 'testFile.txt');\n\n        expect(fs.existsSync(copiedSubDir)).toBe(true);\n        expect(fs.existsSync(copiedFile)).toBe(true);\n    });\n\n    test('overwrite file in target directory', () => {\n        const testFile = path.join(sourceDir, 'testFile.txt');\n        fs.writeFileSync(testFile, 'Source content');\n\n        const targetFile = path.join(targetDir, 'testFile.txt');\n        fs.writeFileSync(targetFile, 'Target content');\n\n        copyDirectory(sourceDir, targetDir);\n\n        const copiedFile = path.join(targetDir, 'testFile.txt');\n        expect(fs.existsSync(copiedFile)).toBe(true);\n\n        const copiedContent = fs.readFileSync(copiedFile, 'utf-8');\n        expect(copiedContent).toBe('Source content');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Copies all files and subdirectories from the source directory to the target directory.\n *\n * @param sourceDir - The source directory from which files and subdirectories will be copied.\n * @param targetDir - The target directory to which files and subdirectories will be copied.\n */\nfunction copyDirectory(sourceDir: string, targetDir: string): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Copies all files and subdirectories from the source directory to the target directory.\n *\n * @param source_dir The source directory from which files and subdirectories will be copied.\n * @type source_dir const std::string&\n *\n * @param target_dir The target directory to which files and subdirectories will be copied.\n * @type target_dir const std::string&\n *\n * @return void\n */\nvoid copy_directory(const std::string& source_dir, const std::string& target_dir);", "test_code": "TEST_CASE_METHOD(TestDirectoryOperations, \"Copy empty directory\") {\n    copy_directory(source_dir, target_dir);\n\n    REQUIRE(fs::exists(target_dir));\n    REQUIRE(fs::is_directory(target_dir));\n    REQUIRE(fs::is_empty(target_dir));\n}\n\nTEST_CASE_METHOD(TestDirectoryOperations, \"Copy directory with files\") {\n    std::string test_file = (fs::path(source_dir) / \"testFile.txt\").string();\n    {\n        std::ofstream f(test_file);\n        f << \"Sample content\";\n    }\n\n    copy_directory(source_dir, target_dir);\n\n    std::string copied_file = (fs::path(target_dir) / \"testFile.txt\").string();\n    REQUIRE(fs::exists(copied_file));\n    REQUIRE(fs::file_size(test_file) == fs::file_size(copied_file));\n}\n\nTEST_CASE_METHOD(TestDirectoryOperations, \"Non-existent source directory\") {\n    std::string non_existent_dir = \"nonExistentDir\";\n\n    REQUIRE_THROWS_AS(copy_directory(non_existent_dir, target_dir), std::invalid_argument);\n}\n\nTEST_CASE_METHOD(TestDirectoryOperations, \"Copy directory with subdirectories\") {\n    std::string sub_dir = (fs::path(source_dir) / \"subDir\").string();\n    fs::create_directories(sub_dir);\n    std::string test_file = (fs::path(sub_dir) / \"testFile.txt\").string();\n    {\n        std::ofstream f(test_file);\n        f << \"Sample content in subdirectory\";\n    }\n\n    copy_directory(source_dir, target_dir);\n\n    std::string copied_sub_dir = (fs::path(target_dir) / \"subDir\").string();\n    std::string copied_file = (fs::path(copied_sub_dir) / \"testFile.txt\").string();\n\n    REQUIRE(fs::exists(copied_sub_dir));\n    REQUIRE(fs::exists(copied_file));\n}\n\nTEST_CASE_METHOD(TestDirectoryOperations, \"Overwrite file in target directory\") {\n    std::string test_file = (fs::path(source_dir) / \"testFile.txt\").string();\n    {\n        std::ofstream f(test_file);\n        f << \"Source content\";\n    }\n\n    std::string target_file = (fs::path(target_dir) / \"testFile.txt\").string();\n    {\n        std::ofstream f(target_file);\n        f << \"Target content\";\n    }\n\n    copy_directory(source_dir, target_dir);\n\n    std::string copied_file = (fs::path(target_dir) / \"testFile.txt\").string();\n    REQUIRE(fs::exists(copied_file));\n\n    std::ifstream f(copied_file);\n    std::string copied_content((std::istreambuf_iterator<char>(f)), std::istreambuf_iterator<char>());\n\n    REQUIRE(copied_content == \"Source content\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Copies all files and subdirectories from the source directory to the target directory.\n *\n * @param source_dir The source directory from which files and subdirectories will be copied.\n * @type source_dir const std::string&\n *\n * @param target_dir The target directory to which files and subdirectories will be copied.\n * @type target_dir const std::string&\n *\n * @return void\n */\nvoid copy_directory(const std::string& source_dir, const std::string& target_dir);", "addition_info": ""}, "java": {"code_signature": "/**\n* Copies all files and subdirectories from the source directory to the target directory.\n*\n* @param sourceDir The source directory from which files and subdirectories will be copied.\n* @param targetDir The target directory to which files and subdirectories will be copied.\n* @throws IOException If an I/O error occurs while copying files or directories.\n*/\npublic static void copyDirectory(File sourceDir, File targetDir) throws IOException {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport org.junit.After;\nimport org.junit.Before;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\n\nimport static org.junit.Assert.*; // Changed from org.junit.jupiter.api.Assertions to org.junit.Assert\n\nimport org.real.temp.Answer.*;\n\npublic class Tester {\n    private File sourceDir;\n    private File targetDir;\n\n    @Before\n    public void setUp() throws IOException {\n        sourceDir = new File(\"testSourceDir\");\n        targetDir = new File(\"testTargetDir\");\n\n        if (!sourceDir.exists()) {\n            sourceDir.mkdir();\n        }\n\n        if (!targetDir.exists()) {\n            targetDir.mkdir();\n        }\n    }\n\n    @After\n    public void tearDown() {\n        deleteDirectory(sourceDir);\n        deleteDirectory(targetDir);\n    }\n\n    /**\n     * Test copying an empty directory.\n     */\n    @Test\n    public void testCopyEmptyDirectory() throws IOException {\n        Answer.copyDirectory(sourceDir, targetDir);\n        assertTrue(\"Target directory should exist after copying.\", targetDir.exists());\n        assertTrue(\"Target directory should be a directory.\", targetDir.isDirectory());\n        assertEquals(\"Target directory should be empty.\", 0, targetDir.listFiles().length);\n    }\n\n    /**\n     * Test copying a directory with files.\n     */\n    @Test\n    public void testCopyDirectoryWithFiles() throws IOException {\n        File testFile = new File(sourceDir, \"testFile.txt\");\n        Files.createFile(testFile.toPath());\n\n        Answer.copyDirectory(sourceDir, targetDir);\n        File copiedFile = new File(targetDir, \"testFile.txt\");\n\n        assertTrue(\"File should be copied to target directory.\", copiedFile.exists());\n        assertEquals(\"File size should be the same after copying.\", testFile.length(), copiedFile.length());\n    }\n\n    /**\n     * Test handling of non-existent source directory.\n     */\n    @Test(expected = Exception.class) // Changed to expected for JUnit 4\n    public void testNonExistentSourceDirectory() throws IOException {\n        File nonExistentDir = new File(\"nonExistentDir\");\n        Answer.copyDirectory(nonExistentDir, targetDir); // No need for assertThrows\n    }\n\n    /**\n     * Test copying a directory with subdirectories.\n     */\n    @Test\n    public void testCopyDirectoryWithSubdirectories() throws IOException {\n        File subDir = new File(sourceDir, \"subDir\");\n        subDir.mkdir();\n        File testFile = new File(subDir, \"testFile.txt\");\n        Files.createFile(testFile.toPath());\n\n        Answer.copyDirectory(sourceDir, targetDir);\n        File copiedSubDir = new File(targetDir, \"subDir\");\n        File copiedFile = new File(copiedSubDir, \"testFile.txt\");\n\n        assertTrue(\"Subdirectory should be copied to target directory.\", copiedSubDir.exists());\n        assertTrue(\"File within subdirectory should be copied to target directory.\", copiedFile.exists());\n    }\n\n    /**\n     * Test overwriting files in the target directory.\n     */\n    @Test\n    public void testOverwriteFileInTargetDirectory() throws IOException {\n        // Create a source file with some content\n        File testFile = new File(sourceDir, \"testFile.txt\");\n        Files.writeString(testFile.toPath(), \"Source content\");\n\n        // Create a target file with different content\n        File targetFile = new File(targetDir, \"testFile.txt\");\n        Files.writeString(targetFile.toPath(), \"Target content\");\n\n        // Copy the directory, which should overwrite the target file\n        Answer.copyDirectory(sourceDir, targetDir);\n        File copiedFile = new File(targetDir, \"testFile.txt\");\n\n        assertTrue(\"File should be copied to target directory.\", copiedFile.exists());\n\n        // Check that the content of the file is now the same as the source file\n        String copiedContent = Files.readString(copiedFile.toPath());\n        assertEquals(\"File in target directory should be overwritten with source content.\", \"Source content\", copiedContent);\n    }\n\n    /**\n     * Helper method to delete a directory and its contents.\n     *\n     * @param dir The directory to delete.\n     */\n    private void deleteDirectory(File dir) {\n        File[] files = dir.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                if (file.isDirectory()) {\n                    deleteDirectory(file);\n                } else {\n                    file.delete();\n                }\n            }\n        }\n        dir.delete();\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n* Copies all files and subdirectories from the source directory to the target directory.\n*\n* @param sourceDir The source directory from which files and subdirectories will be copied.\n* @param targetDir The target directory to which files and subdirectories will be copied.\n* @throws IOException If an I/O error occurs while copying files or directories.\n*/\npublic static void copyDirectory(File sourceDir, File targetDir) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 180, "code_type": "method", "original_language": "java", "question_type": "Data processing and transformation", "summary": "Implement binary search to find the target or the location closest to the target in the sorted array", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef binary_search_closest(array: List[int], target: int) -> int:\n    \"\"\"\n    Performs a binary search to find the index of the target value in a sorted array.\n    If the target value is not found, it returns the index of the closest value.\n\n    Args:\n        array (List[int]): The sorted array in which to search.The sorted array in which to search.\n        target (int): The target value to search for.\n\n    Returns:\n        int: The index of the target or the index of the closest value if the target is not found.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestBinarySearchClosest(unittest.TestCase):\n\n    def test_target_present(self):\n        \"\"\"Test when the target is present in the array.\"\"\"\n        array = [1, 3, 5, 7, 9, 11]\n        target = 7\n        result = binary_search_closest(array, target)\n        self.assertEqual(result, 3, \"Target should be found at index 3.\")\n\n    def test_closest_element_smaller(self):\n        \"\"\"Test when the target is not present and the closest element is smaller.\"\"\"\n        array = [1, 3, 5, 7, 9, 11]\n        target = 6\n        result = binary_search_closest(array, target)\n        self.assertEqual(result, 2, \"Closest element should be 5 at index 2.\")\n\n    def test_closest_element_larger(self):\n        \"\"\"Test when the target is not present and the closest element is larger.\"\"\"\n        array = [1, 3, 5, 7, 9, 11]\n        target = 8\n        result = binary_search_closest(array, target)\n        self.assertEqual(result, 3, \"Closest element should be 7 at index 3.\")\n\n    def test_target_smaller_than_all(self):\n        \"\"\"Test when the target is smaller than all elements in the array.\"\"\"\n        array = [1, 3, 5, 7, 9, 11]\n        target = 0\n        result = binary_search_closest(array, target)\n        self.assertEqual(result, 0, \"Closest element should be 1 at index 0.\")\n\n    def test_target_larger_than_all(self):\n        \"\"\"Test when the target is larger than all elements in the array.\"\"\"\n        array = [1, 3, 5, 7, 9, 11]\n        target = 12\n        result = binary_search_closest(array, target)\n        self.assertEqual(result, 5, \"Closest element should be 11 at index 5.\")\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef binary_search_closest(array: List[int], target: int) -> int:\n    \"\"\"\n    Performs a binary search to find the index of the target value in a sorted array.\n    If the target value is not found, it returns the index of the closest value.\n\n    Args:\n        array (List[int]): The sorted array in which to search.The sorted array in which to search.\n        target (int): The target value to search for.\n\n    Returns:\n        int: The index of the target or the index of the closest value if the target is not found.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Performs a binary search to find the index of the target value in a sorted array.\n * If the target value is not found, it returns the index of the closest value.\n *\n * @param {Array<number>} array - The sorted array in which to search.\n * @param {number} target - The target value to search for.\n * @returns {number} The index of the target or the index of the closest value if the target is not found.\n */\nfunction binarySearchClosest(array, target) {}", "test_code": "describe('binarySearchClosest', () => {\n    test('Target is present in the array', () => {\n        const array = [1, 3, 5, 7, 9, 11];\n        const target = 7;\n        const result = binarySearchClosest(array, target);\n        expect(result).toBe(3); // Target should be found at index 3.\n    });\n\n    test('Closest element is smaller than target', () => {\n        const array = [1, 3, 5, 7, 9, 11];\n        const target = 6;\n        const result = binarySearchClosest(array, target);\n        expect(result).toBe(2); // Closest element should be 5 at index 2.\n    });\n\n    test('Closest element is larger than target', () => {\n        const array = [1, 3, 5, 7, 9, 11];\n        const target = 8;\n        const result = binarySearchClosest(array, target);\n        expect(result).toBe(3); // Closest element should be 7 at index 3.\n    });\n\n    test('Target is smaller than all elements', () => {\n        const array = [1, 3, 5, 7, 9, 11];\n        const target = 0;\n        const result = binarySearchClosest(array, target);\n        expect(result).toBe(0); // Closest element should be 1 at index 0.\n    });\n\n    test('Target is larger than all elements', () => {\n        const array = [1, 3, 5, 7, 9, 11];\n        const target = 12;\n        const result = binarySearchClosest(array, target);\n        expect(result).toBe(5); // Closest element should be 11 at index 5.\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Performs a binary search to find the index of the target value in a sorted array.\n * If the target value is not found, it returns the index of the closest value.\n *\n * @param {Array<number>} array - The sorted array in which to search.\n * @param {number} target - The target value to search for.\n * @returns {number} The index of the target or the index of the closest value if the target is not found.\n */\nfunction binarySearchClosest(array, target) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Performs a binary search to find the index of the target value in a sorted array.\n * If the target value is not found, it returns the index of the closest value.\n *\n * @param {number[]} array - The sorted array in which to search.\n * @param {number} target - The target value to search for.\n * @returns {number} The index of the target or the index of the closest value if the target is not found.\n */\nfunction binarySearchClosest(array: number[], target: number): number {}", "test_code": "describe('binarySearchClosest', () => {\n    \n    test('target present', () => {\n        const array = [1, 3, 5, 7, 9, 11];\n        const target = 7;\n        const result = binarySearchClosest(array, target);\n        expect(result).toBe(3); // Target should be found at index 3.\n    });\n\n    test('closest element smaller', () => {\n        const array = [1, 3, 5, 7, 9, 11];\n        const target = 6;\n        const result = binarySearchClosest(array, target);\n        expect(result).toBe(2); // Closest element should be 5 at index 2.\n    });\n\n    test('closest element larger', () => {\n        const array = [1, 3, 5, 7, 9, 11];\n        const target = 8;\n        const result = binarySearchClosest(array, target);\n        expect(result).toBe(3); // Closest element should be 7 at index 3.\n    });\n\n    test('target smaller than all', () => {\n        const array = [1, 3, 5, 7, 9, 11];\n        const target = 0;\n        const result = binarySearchClosest(array, target);\n        expect(result).toBe(0); // Closest element should be 1 at index 0.\n    });\n\n    test('target larger than all', () => {\n        const array = [1, 3, 5, 7, 9, 11];\n        const target = 12;\n        const result = binarySearchClosest(array, target);\n        expect(result).toBe(5); // Closest element should be 11 at index 5.\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Performs a binary search to find the index of the target value in a sorted array.\n * If the target value is not found, it returns the index of the closest value.\n *\n * @param {number[]} array - The sorted array in which to search.\n * @param {number} target - The target value to search for.\n * @returns {number} The index of the target or the index of the closest value if the target is not found.\n */\nfunction binarySearchClosest(array: number[], target: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Performs a binary search to find the index of the target value in a sorted array.\n *\n * @param array The sorted array in which to search.\n * @type array std::vector<int>\n *\n * @param target The target value to search for.\n * @type target int\n *\n * @return The index of the target or the index of the closest value if the target is not found.\n * @rtype int\n */\n\nint binary_search_closest(const std::vector<int>& array, int target){}", "test_code": "TEST_CASE(\"TestBinarySearchClosest\") {\n\n    SECTION(\"Target present\") {\n        // Test when the target is present in the array.\n        std::vector<int> array = {1, 3, 5, 7, 9, 11};\n        int target = 7;\n        int result = binary_search_closest(array, target);\n        REQUIRE(result == 3); // Target should be found at index 3.\n    }\n\n    SECTION(\"Closest element smaller\") {\n        // Test when the target is not present and the closest element is smaller.\n        std::vector<int> array = {1, 3, 5, 7, 9, 11};\n        int target = 6;\n        int result = binary_search_closest(array, target);\n        REQUIRE(result == 2); // Closest element should be 5 at index 2.\n    }\n\n    SECTION(\"Closest element larger\") {\n        // Test when the target is not present and the closest element is larger.\n        std::vector<int> array = {1, 3, 5, 7, 9, 11};\n        int target = 8;\n        int result = binary_search_closest(array, target);\n        REQUIRE(result == 3); // Closest element should be 7 at index 3.\n    }\n\n    SECTION(\"Target smaller than all\") {\n        // Test when the target is smaller than all elements in the array.\n        std::vector<int> array = {1, 3, 5, 7, 9, 11};\n        int target = 0;\n        int result = binary_search_closest(array, target);\n        REQUIRE(result == 0); // Closest element should be 1 at index 0.\n    }\n\n    SECTION(\"Target larger than all\") {\n        // Test when the target is larger than all elements in the array.\n        std::vector<int> array = {1, 3, 5, 7, 9, 11};\n        int target = 12;\n        int result = binary_search_closest(array, target);\n        REQUIRE(result == 5); // Closest element should be 11 at index 5.\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Performs a binary search to find the index of the target value in a sorted array.\n *\n * @param array The sorted array in which to search.\n * @type array std::vector<int>\n *\n * @param target The target value to search for.\n * @type target int\n *\n * @return The index of the target or the index of the closest value if the target is not found.\n * @rtype int\n */\n\nint binary_search_closest(const std::vector<int>& array, int target){}", "addition_info": ""}, "java": {"code_signature": "/**\n* Implement binary search to find the target or the location closest to the target in the sorted array\n*\n* @param array  The sorted array in which to search.\n* @param target The target value to search for.\n* @return The index of the target or the index of the closest value if the target is not found.\n*/\npublic static int binarySearchClosest(int[] array, int target) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; // Change this import to JUnit 4\nimport org.junit.After;\nimport org.junit.Before;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport static org.junit.Assert.*; // Change this import to JUnit 4 assertions\n\npublic class Tester {\n\n    private File testFile;\n\n    @Before\n    public void setUp() throws IOException {\n        testFile = new File(\"testFile.txt\");\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(\"Test content\".getBytes());\n        }\n    }\n\n    @After\n    public void tearDown() {\n        if (testFile.exists()) {\n            testFile.delete();\n        }\n    }\n\n    /**\n     * Test reading a file that exists and has content.\n     */\n    @Test\n    public void testReadFileWithContent() throws IOException {\n        byte[] content = Answer.readFileToByteArray(testFile.getAbsolutePath());\n        assertEquals(\"The file content should match the expected string.\", \"Test content\", new String(content));\n    }\n\n    /**\n     * Test reading an empty file.\n     */\n    @Test\n    public void testReadEmptyFile() throws IOException {\n        File emptyFile = new File(\"emptyFile.txt\");\n        emptyFile.createNewFile();\n\n        byte[] content = Answer.readFileToByteArray(emptyFile.getAbsolutePath());\n        assertEquals(\"The content of an empty file should be a byte array of length 0.\", 0, content.length);\n\n        emptyFile.delete();\n    }\n\n    /**\n     * Test reading a file that does not exist.\n     */\n    @Test(expected = Exception.class)\n    public void testReadNonExistentFile() throws IOException {\n        String nonExistentFilePath = \"nonExistentFile.txt\";\n        // Change to JUnit 4's way of asserting exceptions\n        Answer.readFileToByteArray(nonExistentFilePath);\n\n    }\n\n    /**\n     * Test reading a file with special characters in its content.\n     */\n    @Test\n    public void testReadFileWithSpecialCharacters() throws IOException {\n        String specialContent = \"Special content: !@#$%^&*()_+\";\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(specialContent.getBytes());\n        }\n\n        byte[] content = Answer.readFileToByteArray(testFile.getAbsolutePath());\n        assertEquals(\"The file content should match the special characters string.\", specialContent, new String(content));\n    }\n\n    /**\n     * Test reading a large file.\n     */\n    @Test\n    public void testReadLargeFile() throws IOException {\n        byte[] largeContent = new byte[10 * 1024 * 1024]; // 10 MB\n        for (int i = 0; i < largeContent.length; i++) {\n            largeContent[i] = (byte) (i % 256);\n        }\n\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(largeContent);\n        }\n\n        byte[] content = Answer.readFileToByteArray(testFile.getAbsolutePath());\n        assertArrayEquals(\"The content of the large file should match the expected byte array.\", largeContent, content);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n* Implement binary search to find the target or the location closest to the target in the sorted array\n*\n* @param array  The sorted array in which to search.\n* @param target The target value to search for.\n* @return The index of the target or the index of the closest value if the target is not found.\n*/\npublic static int binarySearchClosest(int[] array, int target) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 181, "code_type": "method", "original_language": "java", "question_type": "File operations and I/O operation", "summary": "Read the file content specified in the file path and return it as a byte array", "language_version_list": {"python": {"code_signature": "def read_file_to_byte_array(file_path: str) -> bytes:\n    \"\"\"\n    Reads the content of the file specified by the file path and returns it as a byte array.\n\n    Args:\n        file_path (str): The path to the file that needs to be read.\n\n    Returns:\n        bytes: A byte array containing the content of the file.\n    \"\"\"", "test_code": "import os\nimport unittest\n\n\nclass TestFileOperations(unittest.TestCase):\n    def setUp(self):\n        self.test_file = \"testFile.txt\"\n        with open(self.test_file, 'wb') as f:\n            f.write(b\"Test content\")\n\n    def tearDown(self):\n        if os.path.exists(self.test_file):\n            os.remove(self.test_file)\n\n    def test_read_file_with_content(self):\n        \"\"\"Test reading a file that exists and has content.\"\"\"\n        content = read_file_to_byte_array(self.test_file)\n        self.assertEqual(b\"Test content\", content, \"The file content should match the expected string.\")\n\n    def test_read_empty_file(self):\n        \"\"\"Test reading an empty file.\"\"\"\n        empty_file = \"emptyFile.txt\"\n        open(empty_file, 'a').close()  # Create an empty file\n        with self.assertRaises(Exception):\n            read_file_to_byte_array(empty_file)\n        os.remove(empty_file)  # Cleanup\n\n    def test_read_non_existent_file(self):\n        \"\"\"Test reading a file that does not exist.\"\"\"\n        non_existent_file_path = \"nonExistentFile.txt\"\n        with self.assertRaises(Exception):\n            read_file_to_byte_array(non_existent_file_path)\n\n    def test_read_file_with_special_characters(self):\n        \"\"\"Test reading a file with special characters in its content.\"\"\"\n        special_content = \"Special content: !@#$%^&*()_+\"\n        with open(self.test_file, 'wb') as f:\n            f.write(special_content.encode())\n        content = read_file_to_byte_array(self.test_file)\n        self.assertEqual(special_content.encode(), content, \"The file content should match the special characters string.\")\n\n    def test_read_large_file(self):\n        \"\"\"Test reading a large file.\"\"\"\n        large_content = bytes(range(256)) * (10 * 1024)  # 10 MB\n        with open(self.test_file, 'wb') as f:\n            f.write(large_content)\n        content = read_file_to_byte_array(self.test_file)\n        self.assertEqual(large_content, content, \"The content of the large file should match the expected byte array.\")", "prompt": "please write a python function , the function signature as below def read_file_to_byte_array(file_path: str) -> bytes:\n    \"\"\"\n    Reads the content of the file specified by the file path and returns it as a byte array.\n\n    Args:\n        file_path (str): The path to the file that needs to be read.\n\n    Returns:\n        bytes: A byte array containing the content of the file.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Reads the content of the file specified by the file path and returns it as a byte array.\n *\n * @param {string} filePath - The path to the file that needs to be read.\n * @returns {Buffer} A byte array containing the content of the file.\n */\nfunction readFileToByteArray(filePath) {}", "test_code": "const fs = require('fs');\nconst path = require('path');\ndescribe('File Operations', () => {\n    let testFile;\n\n    beforeEach(() => {\n        testFile = 'testFile.txt';\n        fs.writeFileSync(testFile, Buffer.from('Test content'));\n    });\n\n    afterEach(() => {\n        if (fs.existsSync(testFile)) {\n            fs.unlinkSync(testFile);\n        }\n    });\n\n    test('reading a file with content', () => {\n        /** \n         * Test reading a file that exists and has content.\n         */\n        const content = readFileToByteArray(testFile);\n        expect(content).toEqual(Buffer.from('Test content'));\n    });\n\n    test('reading an empty file', () => {\n        /** \n         * Test reading an empty file.\n         */\n        const emptyFile = 'emptyFile.txt';\n        fs.closeSync(fs.openSync(emptyFile, 'w')); // Create an empty file\n        const content = readFileToByteArray(emptyFile);\n        expect(content.length).toBe(0);\n        fs.unlinkSync(emptyFile); // Cleanup\n    });\n\n    test('reading a non-existent file', () => {\n        /** \n         * Test reading a file that does not exist.\n         */\n        const nonExistentFilePath = 'nonExistentFile.txt';\n        expect(() => readFileToByteArray(nonExistentFilePath)).toThrow();\n    });\n\n    test('reading a file with special characters', () => {\n        /** \n         * Test reading a file with special characters in its content.\n         */\n        const specialContent = 'Special content: !@#$%^&*()_+';\n        fs.writeFileSync(testFile, Buffer.from(specialContent));\n        const content = readFileToByteArray(testFile);\n        expect(content).toEqual(Buffer.from(specialContent));\n    });\n\n    test('reading a large file', () => {\n        /** \n         * Test reading a large file.\n         */\n        const largeContent = Buffer.from([...Array(256).keys()].flatMap(i => new Array(10 * 1024).fill(i))); // 10 MB\n        fs.writeFileSync(testFile, largeContent);\n        const content = readFileToByteArray(testFile);\n        expect(content).toEqual(largeContent);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Reads the content of the file specified by the file path and returns it as a byte array.\n *\n * @param {string} filePath - The path to the file that needs to be read.\n * @returns {Buffer} A byte array containing the content of the file.\n */\nfunction readFileToByteArray(filePath) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Reads the content of the file specified by the file path and returns it as a byte array.\n *\n * @param {string} filePath - The path to the file that needs to be read.\n * @returns {Uint8Array} - A byte array containing the content of the file.\n */\nfunction readFileToByteArray(filePath: string): Uint8Array {}", "test_code": "import * as fs from 'fs';\n\ndescribe('File Operations', () => {\n    const testFile = 'testFile.txt';\n\n    beforeEach(() => {\n        fs.writeFileSync(testFile, Buffer.from('Test content'));\n    });\n\n    afterEach(() => {\n        if (fs.existsSync(testFile)) {\n            fs.unlinkSync(testFile);\n        }\n    });\n\n    test('read file with content', () => {\n        const content = readFileToByteArray(testFile);\n        expect(content).toEqual(Buffer.from('Test content'));\n    });\n\n    test('read empty file', () => {\n        const emptyFile = 'emptyFile.txt';\n        fs.writeFileSync(emptyFile, '');\n        const content = readFileToByteArray(emptyFile);\n        expect(content.length).toBe(0);\n        fs.unlinkSync(emptyFile);\n    });\n\n    test('read non-existent file', () => {\n        const nonExistentFilePath = 'nonExistentFile.txt';\n        expect(() => readFileToByteArray(nonExistentFilePath)).toThrow();\n    });\n\n    test('read file with special characters', () => {\n        const specialContent = 'Special content: !@#$%^&*()_+';\n        fs.writeFileSync(testFile, Buffer.from(specialContent));\n        const content = readFileToByteArray(testFile);\n        expect(content).toEqual(Buffer.from(specialContent));\n    });\n\n    test('read large file', () => {\n        const largeContent = Buffer.from(Array.from({ length: 256 }, (_, i) => i).flatMap(i => Array(10).fill(i)));\n        fs.writeFileSync(testFile, largeContent);\n        const content = readFileToByteArray(testFile);\n        expect(content).toEqual(largeContent);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Reads the content of the file specified by the file path and returns it as a byte array.\n *\n * @param {string} filePath - The path to the file that needs to be read.\n * @returns {Uint8Array} - A byte array containing the content of the file.\n */\nfunction readFileToByteArray(filePath: string): Uint8Array {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads the content of the file specified by the file path and returns it as a byte array.\n *\n * @param file_path The path to the file that needs to be read.\n * @return A vector of chars containing the content of the file.\n */\nstd::vector<char> read_file_to_byte_array(const std::string& file_path);", "test_code": "TEST_CASE(\"Test reading an empty file\") {\n    std::string empty_file = \"emptyFile.txt\";\n    std::ofstream(empty_file); // Create an empty file\n\n    auto content = read_file_to_byte_array(empty_file);\n    REQUIRE(content.size() == 0);\n\n    std::filesystem::remove(empty_file); // Cleanup\n}\n\nTEST_CASE(\"Test reading a file that does not exist\") {\n    std::string non_existent_file_path = \"nonExistentFile.txt\";\n    REQUIRE_THROWS_AS(read_file_to_byte_array(non_existent_file_path), std::runtime_error);\n}\n\nTEST_CASE(\"Test reading a file with special characters in its content\") {\n    std::string special_content = \"Special content: !@#$%^&*()_+\";\n    std::string test_file = \"testFile.txt\";\n\n    std::ofstream f(test_file, std::ios::binary);\n    f.write(special_content.c_str(), special_content.size());\n\n    auto content = read_file_to_byte_array(test_file);\n    REQUIRE(content == std::vector<char>(special_content.begin(), special_content.end()));\n}\n\nTEST_CASE(\"Test reading a large file\") {\n    std::string test_file = \"testFile.txt\";\n    std::vector<char> large_content(256);\n    for (int i = 0; i < 256; ++i) {\n        large_content[i] = static_cast<char>(i);\n    }\n    large_content.resize(10 * 1024 * 256); // 10 MB\n\n    std::ofstream f(test_file, std::ios::binary);\n    f.write(large_content.data(), large_content.size());\n\n    auto content = read_file_to_byte_array(test_file);\n    REQUIRE(content == large_content);", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads the content of the file specified by the file path and returns it as a byte array.\n *\n * @param file_path The path to the file that needs to be read.\n * @return A vector of chars containing the content of the file.\n */\nstd::vector<char> read_file_to_byte_array(const std::string& file_path);", "addition_info": ""}, "java": {"code_signature": "/**\n* Reads the content of the file specified by the file path and returns it as a byte array.\n*\n* @param filePath The path to the file that needs to be read.\n* @return A byte array containing the content of the file.\n* @throws IOException If an I/O error occurs while reading the file.\n*/\npublic static byte[] readFileToByteArray(String filePath) throws IOException {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nimport org.real.temp.*;\npublic class Tester {\n\n    private File testFile;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        testFile = new File(\"testFile.txt\");\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(\"Test content\".getBytes());\n        }\n    }\n\n    @Before\n    public void tearDown() {\n        if (testFile.exists()) {\n            testFile.delete();\n        }\n    }\n\n    /**\n     * Test reading a file that exists and has content.\n     */\n    @Test\n    public void testReadFileWithContent() throws IOException {\n        byte[] content = Answer.readFileToByteArray(testFile.getAbsolutePath());\n        assertEquals(\"Test content\", new String(content), \"The file content should match the expected string.\");\n    }\n\n    /**\n     * Test reading an empty file.\n     */\n    @Test\n    public void testReadEmptyFile() throws IOException {\n        File emptyFile = new File(\"emptyFile.txt\");\n        emptyFile.createNewFile();\n\n        byte[] content = Answer.readFileToByteArray(emptyFile.getAbsolutePath());\n        assertEquals(0, content.length, \"The content of an empty file should be a byte array of length 0.\");\n\n        emptyFile.delete();\n    }\n\n    /**\n     * Test reading a file that does not exist.\n     */\n    @Test\n    public void testReadNonExistentFile() {\n        String nonExistentFilePath = \"nonExistentFile.txt\";\n        assertThrows(Exception.class, () -> {\n            Answer.readFileToByteArray(nonExistentFilePath);\n        }, \"Reading a non-existent file should throw an IllegalArgumentException.\");\n    }\n\n    /**\n     * Test reading a file with special characters in its content.\n     */\n    @Test\n    public void testReadFileWithSpecialCharacters() throws IOException {\n        String specialContent = \"Special content: !@#$%^&*()_+\";\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(specialContent.getBytes());\n        }\n\n        byte[] content = Answer.readFileToByteArray(testFile.getAbsolutePath());\n        assertEquals(specialContent, new String(content), \"The file content should match the special characters string.\");\n    }\n\n    /**\n     * Test reading a large file.\n     */\n    @Test\n    public void testReadLargeFile() throws IOException {\n        byte[] largeContent = new byte[10 * 1024 * 1024]; // 10 MB\n        for (int i = 0; i < largeContent.length; i++) {\n            largeContent[i] = (byte) (i % 256);\n        }\n\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(largeContent);\n        }\n\n        byte[] content = Answer.readFileToByteArray(testFile.getAbsolutePath());\n        assertArrayEquals(largeContent, content, \"The content of the large file should match the expected byte array.\");\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n* Reads the content of the file specified by the file path and returns it as a byte array.\n*\n* @param filePath The path to the file that needs to be read.\n* @return A byte array containing the content of the file.\n* @throws IOException If an I/O error occurs while reading the file.\n*/\npublic static byte[] readFileToByteArray(String filePath) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 182, "code_type": "method", "original_language": "java", "question_type": "Configuration and deployment", "summary": "Use a buffer stream to copy the contents of one file to another and measure the time it takes to complete the operation", "language_version_list": {"python": {"code_signature": "def copy_file_with_buffered_stream(source_file_path: str, destination_file_path: str) -> int:\n    \"\"\"\n    Copies the contents of the source file to the destination file using a buffered stream\n    and measures the time it takes to complete the operation.\n\n    Args:\n        source_file_path (str): The path to the source file.\n        destination_file_path (str): The path to the destination file.\n\n    Returns:\n        int: The time taken to copy the file in milliseconds.\n    \"\"\"\n", "test_code": "import os\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n    def setUp(self):\n        self.source_file = \"testSourceFile.txt\"\n        self.destination_file = \"testDestinationFile.txt\"\n        with open(self.source_file, 'wb') as f:\n            f.write(b\"This is a test file content.\")\n\n    def tearDown(self):\n        for file in [self.source_file, self.destination_file]:\n            if os.path.exists(file):\n                os.remove(file)\n\n    def test_copy_file_with_content(self):\n        time_taken = copy_file_with_buffered_stream(self.source_file, self.destination_file)\n        self.assertTrue(os.path.exists(self.destination_file), \"Destination file should exist after copying.\")\n        self.assertEqual(os.path.getsize(self.source_file), os.path.getsize(self.destination_file), \"File sizes should match.\")\n        self.assertGreaterEqual(time_taken, 0, \"Time taken should be non-negative.\")\n\n    def test_copy_empty_file(self):\n        empty_file = \"emptyFile.txt\"\n        with open(empty_file, 'wb') as f:\n            pass  # Create an empty file\n        destination_empty_file = \"destinationEmptyFile.txt\"\n        time_taken = copy_file_with_buffered_stream(empty_file, destination_empty_file)\n        self.assertTrue(os.path.exists(destination_empty_file), \"Destination file should exist after copying.\")\n        self.assertEqual(os.path.getsize(destination_empty_file), 0, \"Empty file should have length 0.\")\n        self.assertGreaterEqual(time_taken, 0, \"Time taken should be non-negative.\")\n        os.remove(empty_file)\n        os.remove(destination_empty_file)\n\n    def test_copy_non_existent_file(self):\n        non_existent_file_path = \"nonExistentFile.txt\"\n        with self.assertRaises(Exception):\n            copy_file_with_buffered_stream(non_existent_file_path, self.destination_file)\n\n    def test_copy_file_overwrite(self):\n        with open(self.destination_file, 'wb') as f:\n            f.write(b\"Old content\")\n        time_taken = copy_file_with_buffered_stream(self.source_file, self.destination_file)\n        self.assertTrue(os.path.exists(self.destination_file), \"Destination file should exist after copying.\")\n        self.assertEqual(os.path.getsize(self.source_file), os.path.getsize(self.destination_file), \"File sizes should match after overwriting.\")\n        self.assertGreater(time_taken, 0, \"Time taken should be greater than 0.\")\n\n    def test_copy_large_file(self):\n        large_content = bytearray(10 * 1024 * 1024)  # 10 MB\n        for i in range(len(large_content)):\n            large_content[i] = i % 256\n        with open(self.source_file, 'wb') as f:\n            f.write(large_content)\n        time_taken = copy_file_with_buffered_stream(self.source_file, self.destination_file)\n        self.assertTrue(os.path.exists(self.destination_file), \"Destination file should exist after copying.\")\n        self.assertEqual(os.path.getsize(self.source_file), os.path.getsize(self.destination_file), \"File sizes should match.\")\n        self.assertGreater(time_taken, 0, \"Time taken should be greater than 0.\")", "prompt": "please write a python function , the function signature as below def copy_file_with_buffered_stream(source_file_path: str, destination_file_path: str) -> int:\n    \"\"\"\n    Copies the contents of the source file to the destination file using a buffered stream\n    and measures the time it takes to complete the operation.\n\n    Args:\n        source_file_path (str): The path to the source file.\n        destination_file_path (str): The path to the destination file.\n\n    Returns:\n        int: The time taken to copy the file in milliseconds.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Copies the contents of the source file to the destination file using a buffered stream\n * and measures the time it takes to complete the operation.\n *\n * @param source_file_path The path to the source file.\n * @param destination_file_path The path to the destination file.\n * @return The time taken to copy the file in milliseconds.\n */\nint copy_file_with_buffered_stream(const std::string& source_file_path, const std::string& destination_file_path);", "test_code": "TEST_CASE_METHOD(FileTest, \"Test copy file with content\") {\n    long long time_taken = copy_file_with_buffered_stream(source_file, destination_file);\n    \n    REQUIRE(std::filesystem::exists(destination_file));\n    REQUIRE(std::filesystem::file_size(source_file) == std::filesystem::file_size(destination_file));\n    REQUIRE(time_taken >= 0);\n}\n\nTEST_CASE(\"Test copy empty file\") {\n    std::string empty_file = \"emptyFile.txt\";\n    std::ofstream f(empty_file, std::ios::binary);\n    \n    std::string destination_empty_file = \"destinationEmptyFile.txt\";\n    long long time_taken = copy_file_with_buffered_stream(empty_file, destination_empty_file);\n\n    REQUIRE(std::filesystem::exists(destination_empty_file));\n    REQUIRE(std::filesystem::file_size(destination_empty_file) == 0);\n    REQUIRE(time_taken >= 0);\n\n    std::filesystem::remove(empty_file);\n    std::filesystem::remove(destination_empty_file);\n}\n\nTEST_CASE(\"Test copy non-existent file\") {\n    std::string non_existent_file_path = \"nonExistentFile.txt\";\n    REQUIRE_THROWS(copy_file_with_buffered_stream(non_existent_file_path, \"someDestination.txt\"));\n}\n\nTEST_CASE_METHOD(FileTest, \"Test copy file overwrite\") {\n    std::ofstream f(destination_file, std::ios::binary);\n    f.write(\"Old content\", 12);\n    \n    long long time_taken = copy_file_with_buffered_stream(source_file, destination_file);\n\n    REQUIRE(std::filesystem::exists(destination_file));\n    REQUIRE(std::filesystem::file_size(source_file) == std::filesystem::file_size(destination_file));\n    REQUIRE(time_taken > 0);\n}\n\nTEST_CASE(\"Test copy large file\") {\n    std::string large_file = \"largeFile.txt\";\n    std::ofstream f(large_file, std::ios::binary);\n    \n    std::vector<char> large_content(10 * 1024 * 1024); // 10 MB\n    for (size_t i = 0; i < large_content.size(); ++i) {\n        large_content[i] = static_cast<char>(i % 256);\n    }\n    f.write(large_content.data(), large_content.size());\n    \n    std::string destination_large_file = \"destinationLargeFile.txt\";\n    long long time_taken = copy_file_with_buffered_stream(large_file, destination_large_file);\n\n    REQUIRE(std::filesystem::exists(destination_large_file));\n    REQUIRE(std::filesystem::file_size(large_file) == std::filesystem::file_size(destination_large_file));\n    REQUIRE(time_taken > 0);\n\n    std::filesystem::remove(large_file);\n    std::filesystem::remove(destination_large_file);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Copies the contents of the source file to the destination file using a buffered stream\n * and measures the time it takes to complete the operation.\n *\n * @param source_file_path The path to the source file.\n * @param destination_file_path The path to the destination file.\n * @return The time taken to copy the file in milliseconds.\n */\nint copy_file_with_buffered_stream(const std::string& source_file_path, const std::string& destination_file_path);", "addition_info": ""}, "java": {"code_signature": "/**\n* Copies the contents of the source file to the destination file using a buffered stream\n* and measures the time it takes to complete the operation.\n*\n* @param sourceFilePath      The path to the source file.\n* @param destinationFilePath The path to the destination file.\n* @return The time taken to copy the file in milliseconds.\n* @throws IOException If an I/O error occurs during the copy operation.\n*/\npublic static long copyFileWithBufferedStream(String sourceFilePath, String destinationFilePath) throws IOException {}", "test_code": "package org.real.temp;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\nimport org.real.temp.*;\n\npublic class Tester {\n    private File sourceFile;\n    private File destinationFile;\n\n    @Before\n    public void setUp() throws IOException {\n        sourceFile = new File(\"testSourceFile.txt\");\n        destinationFile = new File(\"testDestinationFile.txt\");\n\n        try (FileOutputStream fos = new FileOutputStream(sourceFile)) {\n            fos.write(\"This is a test file content.\".getBytes());\n        }\n    }\n\n    @After\n    public void tearDown() {\n        if (sourceFile.exists()) {\n            sourceFile.delete();\n        }\n        if (destinationFile.exists()) {\n            destinationFile.delete();\n        }\n    }\n\n    /**\n     * Test copying a file with content.\n     */\n    @Test\n    public void testCopyFileWithContent() throws IOException {\n        long timeTaken = Answer.copyFileWithBufferedStream(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());\n        assertTrue(\"Destination file should exist after copying.\", destinationFile.exists());\n        assertEquals(\"File sizes should match.\", sourceFile.length(), destinationFile.length());\n        assertTrue(\"Time taken should be non-negative.\", timeTaken >= 0);\n    }\n\n    /**\n     * Test copying an empty file.\n     */\n    @Test\n    public void testCopyEmptyFile() throws IOException {\n        File emptyFile = new File(\"emptyFile.txt\");\n        emptyFile.createNewFile();\n        File destinationEmptyFile = new File(\"destinationEmptyFile.txt\");\n\n        long timeTaken = Answer.copyFileWithBufferedStream(emptyFile.getAbsolutePath(), destinationEmptyFile.getAbsolutePath());\n        assertTrue(\"Destination file should exist after copying.\", destinationEmptyFile.exists());\n        assertEquals(\"Empty file should have length 0.\", 0, destinationEmptyFile.length());\n        assertTrue(\"Time taken should be non-negative.\", timeTaken >= 0);\n\n        emptyFile.delete();\n        destinationEmptyFile.delete();\n    }\n\n    /**\n     * Test copying a non-existent source file.\n     */\n    @Test(expected = IOException.class)\n    public void testCopyNonExistentFile() throws IOException {\n        String nonExistentFilePath = \"nonExistentFile.txt\";\n        Answer.copyFileWithBufferedStream(nonExistentFilePath, destinationFile.getAbsolutePath());\n    }\n\n    /**\n     * Test copying a file to an existing destination file (overwriting).\n     */\n    @Test\n    public void testCopyFileOverwrite() throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(destinationFile)) {\n            fos.write(\"Old content\".getBytes());\n        }\n\n        long timeTaken = Answer.copyFileWithBufferedStream(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());\n        assertTrue(\"Destination file should exist after copying.\", destinationFile.exists());\n        assertEquals(\"File sizes should match after overwriting.\", sourceFile.length(), destinationFile.length());\n        assertTrue(\"Time taken should be greater than 0.\", timeTaken > 0);\n    }\n\n    /**\n     * Test copying a large file.\n     */\n    @Test\n    public void testCopyLargeFile() throws IOException {\n        byte[] largeContent = new byte[10 * 1024 * 1024]; // 10 MB\n        for (int i = 0; i < largeContent.length; i++) {\n            largeContent[i] = (byte) (i % 256);\n        }\n\n        try (FileOutputStream fos = new FileOutputStream(sourceFile)) {\n            fos.write(largeContent);\n        }\n\n        long timeTaken = Answer.copyFileWithBufferedStream(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());\n        assertTrue(\"Destination file should exist after copying.\", destinationFile.exists());\n        assertEquals(\"File sizes should match.\", sourceFile.length(), destinationFile.length());\n        assertTrue(\"Time taken should be greater than 0.\", timeTaken > 0);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n* Copies the contents of the source file to the destination file using a buffered stream\n* and measures the time it takes to complete the operation.\n*\n* @param sourceFilePath      The path to the source file.\n* @param destinationFilePath The path to the destination file.\n* @return The time taken to copy the file in milliseconds.\n* @throws IOException If an I/O error occurs during the copy operation.\n*/\npublic static long copyFileWithBufferedStream(String sourceFilePath, String destinationFilePath) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 348, "code_type": "method", "original_language": "java", "question_type": "Algorithm and data structure", "summary": "Find all primes in a given range and calculate the sum of those primes", "language_version_list": {"python": {"code_signature": "def find_primes(lower_bound: int, upper_bound: int) -> list:\n    \"\"\"Find all prime numbers within a specified range.\n\n    Args:\n        lower_bound (int): The lower limit of the range (inclusive).\n        upper_bound (int): The upper limit of the range (inclusive).\n\n    Returns:\n        list: A list containing all prime numbers within the specified range.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFindPrimesInRange(unittest.TestCase):\n    def test_find_primes_in_range(self):\n        expected = [2, 3, 5, 7, 11]\n        self.assertEqual(find_primes(1, 12), expected, \"Check primes between 1 and 12\")\n\n    def test_find_primes_single_prime(self):\n        expected = [29]\n        self.assertEqual(find_primes(29, 29), expected, \"Check single prime number\")\n\n    def test_find_primes_in_big_range(self):\n        expected = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n        self.assertEqual(find_primes(1, 100), expected, \"Check primes between 1 and 100\")\n\n    def test_find_primes_no_primes(self):\n        expected = []\n        self.assertEqual(find_primes(0, 1), expected, \"Check range with no primes\")\n", "prompt": "please write a python function , the function signature as below def find_primes(lower_bound: int, upper_bound: int) -> list:\n    \"\"\"Find all prime numbers within a specified range.\n\n    Args:\n        lower_bound (int): The lower limit of the range (inclusive).\n        upper_bound (int): The upper limit of the range (inclusive).\n\n    Returns:\n        list: A list containing all prime numbers within the specified range.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Find all prime numbers within a specified range.\n *\n * @param {number} lowerBound - The lower limit of the range (inclusive).\n * @param {number} upperBound - The upper limit of the range (inclusive).\n * @returns {Array<number>} A list containing all prime numbers within the specified range.\n */\nfunction findPrimes(lowerBound, upperBound) {}", "test_code": "describe('findPrimes', () => {\n    test('find primes in range', () => {\n        const expected = [2, 3, 5, 7, 11];\n        expect(findPrimes(1, 12)).toEqual(expected);\n    });\n\n    test('find single prime', () => {\n        const expected = [29];\n        expect(findPrimes(29, 29)).toEqual(expected);\n    });\n\n    test('find primes in big range', () => {\n        const expected = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n        expect(findPrimes(1, 100)).toEqual(expected);\n    });\n\n    test('find no primes', () => {\n        const expected = [];\n        expect(findPrimes(0, 1)).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Find all prime numbers within a specified range.\n *\n * @param {number} lowerBound - The lower limit of the range (inclusive).\n * @param {number} upperBound - The upper limit of the range (inclusive).\n * @returns {Array<number>} A list containing all prime numbers within the specified range.\n */\nfunction findPrimes(lowerBound, upperBound) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Find all prime numbers within a specified range.\n *\n * @param lowerBound - The lower limit of the range (inclusive).\n * @param upperBound - The upper limit of the range (inclusive).\n * @returns A list containing all prime numbers within the specified range.\n */\nfunction findPrimes(lowerBound: number, upperBound: number): number[] {}", "test_code": "describe('findPrimes', () => {\n    test('should find primes in range 1 to 12', () => {\n        const expected = [2, 3, 5, 7, 11];\n        expect(findPrimes(1, 12)).toEqual(expected);\n    });\n\n    test('should find a single prime number', () => {\n        const expected = [29];\n        expect(findPrimes(29, 29)).toEqual(expected);\n    });\n\n    test('should find primes in a big range 1 to 100', () => {\n        const expected = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n        expect(findPrimes(1, 100)).toEqual(expected);\n    });\n\n    test('should return an empty array for range with no primes', () => {\n        const expected: number[] = [];\n        expect(findPrimes(0, 1)).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Find all prime numbers within a specified range.\n *\n * @param lowerBound - The lower limit of the range (inclusive).\n * @param upperBound - The upper limit of the range (inclusive).\n * @returns A list containing all prime numbers within the specified range.\n */\nfunction findPrimes(lowerBound: number, upperBound: number): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds all prime numbers within a specified range.\n *\n * @param lower_bound The lower limit of the range (inclusive).\n * @type lower_bound int\n *\n * @param upper_bound The upper limit of the range (inclusive).\n * @type upper_bound int\n *\n * @return A vector containing all prime numbers within the specified range.\n * @rtype std::vector<int>\n */\nstd::vector<int> find_primes(int lower_bound, int upper_bound);", "test_code": "TEST_CASE(\"TestFindPrimesInRange\") {\n    SECTION(\"Find primes in range\") {\n        std::vector<int> expected = {2, 3, 5, 7, 11};\n        REQUIRE(find_primes(1, 12) == expected);\n    }\n\n    SECTION(\"Find primes for a single prime\") {\n        std::vector<int> expected = {29};\n        REQUIRE(find_primes(29, 29) == expected);\n    }\n\n    SECTION(\"Find primes in a large range\") {\n        std::vector<int> expected = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n        REQUIRE(find_primes(1, 100) == expected);\n    }\n\n    SECTION(\"Find primes in a range with no primes\") {\n        std::vector<int> expected = {};\n        REQUIRE(find_primes(0, 1) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds all prime numbers within a specified range.\n *\n * @param lower_bound The lower limit of the range (inclusive).\n * @type lower_bound int\n *\n * @param upper_bound The upper limit of the range (inclusive).\n * @type upper_bound int\n *\n * @return A vector containing all prime numbers within the specified range.\n * @rtype std::vector<int>\n */\nstd::vector<int> find_primes(int lower_bound, int upper_bound);", "addition_info": ""}, "java": {"code_signature": "/**\n * Find all primes in a given range and calculate the sum of those primes\n *\n * @param lowerBound The starting point of the range to check for prime numbers. Must be a non-negative integer.\n * @param upperBound The endpoint of the range to check for prime numbers. Must be equal to or greater than lowerBound.\n * @return A List<Integer> containing all the prime numbers found in the specified range. The list will be empty if no primes are found.\n */\npublic static List<Integer> findPrimes(int lowerBound, int upperBound) {}\n", "test_code": "package org.real.temp;\nimport org.junit.jupiter.api.Test;\n\nimport org.real.temp.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Tester {\n    @Test\n    public void testFindPrimesInRange() {\n        List<Integer> expected = Arrays.asList(2, 3, 5, 7, 11);\n        assertEquals(expected, Answer.findPrimes(1, 12), \"Check primes between 1 and 12\");\n    }\n\n    @Test\n    public void testFindPrimesSinglePrime() {\n        List<Integer> expected = Arrays.asList(29);\n        assertEquals(expected, Answer.findPrimes(29, 29), \"Check single prime number\");\n    }\n\n    @Test\n    public void testFindPrimesInBigRange() {\n        List<Integer> expected = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97);\n        assertEquals(expected, Answer.findPrimes(1, 100), \"Check primes between 1 and 100\");\n    }\n\n    @Test\n    public void testFindPrimesNoPrimes() {\n        List<Integer> expected = Arrays.asList();\n        assertEquals(expected, Answer.findPrimes(0, 1), \"Check range with no primes\");\n    }\n\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Find all primes in a given range and calculate the sum of those primes\n *\n * @param lowerBound The starting point of the range to check for prime numbers. Must be a non-negative integer.\n * @param upperBound The endpoint of the range to check for prime numbers. Must be equal to or greater than lowerBound.\n * @return A List<Integer> containing all the prime numbers found in the specified range. The list will be empty if no primes are found.\n */\npublic static List<Integer> findPrimes(int lowerBound, int upperBound) {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 349, "code_type": "method", "original_language": "java", "question_type": "Algorithm and data structure", "summary": "Generates all possible combinations of elements from a list of lists, where each combination consists of\npicking exactly one element from each list in the input list of lists. This method is useful for generating\nproduct variations, scenarios in decision-making tools, or any other context where all possible combinations\nof a set of options need to be explored.", "language_version_list": {"python": {"code_signature": "from typing import List, Any\n\n\ndef generate_combinations(input_lists: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Generates all possible combinations of elements from a list of lists.\n    Each combination consists of picking exactly one element from each list in the input list of lists.\n    This method is useful for generating product variations, scenarios in decision-making tools,\n    or any context where all possible combinations of a set of options need to be explored.\n\n    Args:\n        input_lists (List[List[Any]]): A list of lists containing the elements to combine.\n                                         The lists must not be empty but can contain elements of any type.\n\n    Returns:\n        List[List[Any]]: A list of lists, where each inner list represents a possible combination of elements\n                         taken from the input lists. Returns an empty list if the input list is empty.\n    \"\"\"\n", "test_code": "import unittest\nfrom typing import List\n\n\nclass TestGenerateCombinations(unittest.TestCase):\n\n    def test_empty_input(self):\n        input_data: List[List[str]] = []\n        expected: List[List[str]] = []\n        self.assertEqual(generate_combinations(input_data), expected, \"Testing with empty input\")\n\n    def test_single_empty_list(self):\n        input_data: List[List[str]] = [[]]  # Equivalent to Arrays.asList(new ArrayList<>())\n        expected: List[List[str]] = []\n        self.assertEqual(generate_combinations(input_data), expected, \"Testing with a single empty list\")\n\n    def test_single_non_empty_list(self):\n        input_data: List[List[str]] = [[\"a\", \"b\", \"c\"]]  # Equivalent to Arrays.asList(Arrays.asList(\"a\", \"b\", \"c\"))\n        expected: List[List[str]] = [[\"a\"], [\"b\"], [\"c\"]]\n        self.assertEqual(generate_combinations(input_data), expected, \"Testing with a single non-empty list\")\n\n    def test_multiple_lists(self):\n        input_data: List[List[str]] = [[\"a\", \"b\"], [\"1\", \"2\"]]  # Equivalent to Arrays.asList(Arrays.asList(\"a\", \"b\"), Arrays.asList(\"1\", \"2\"))\n        expected: List[List[str]] = [[\"a\", \"1\"], [\"a\", \"2\"], [\"b\", \"1\"], [\"b\", \"2\"]]\n        self.assertEqual(generate_combinations(input_data), expected, \"Testing with multiple lists\")\n\n    def test_input_containing_empty_list(self):\n        input_data: List[List[str]] = [[\"a\", \"b\"], [], [\"1\", \"2\"]]  # Equivalent to the Java example\n        expected: List[List[str]] = []\n        self.assertEqual(generate_combinations(input_data), expected, \"Testing with an input that contains an empty list\")\n", "prompt": "please write a python function , the function signature as below from typing import List, Any\n\n\ndef generate_combinations(input_lists: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Generates all possible combinations of elements from a list of lists.\n    Each combination consists of picking exactly one element from each list in the input list of lists.\n    This method is useful for generating product variations, scenarios in decision-making tools,\n    or any context where all possible combinations of a set of options need to be explored.\n\n    Args:\n        input_lists (List[List[Any]]): A list of lists containing the elements to combine.\n                                         The lists must not be empty but can contain elements of any type.\n\n    Returns:\n        List[List[Any]]: A list of lists, where each inner list represents a possible combination of elements\n                         taken from the input lists. Returns an empty list if the input list is empty.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Generates all possible combinations of elements from a list of lists.\n * Each combination consists of picking exactly one element from each list in the input list of lists.\n * This method is useful for generating product variations, scenarios in decision-making tools,\n * or any context where all possible combinations of a set of options need to be explored.\n *\n * @param {Array<Array<any>>} inputLists - A list of lists containing the elements to combine.\n *                                          The lists must not be empty but can contain elements of any type.\n * @returns {Array<Array<any>>} - A list of lists, where each inner list represents a possible combination of elements\n *                                 taken from the input lists. Returns an empty list if the input list is empty.\n */\nfunction generateCombinations(inputLists) {}", "test_code": "describe('generateCombinations', () => {\n    \n    test('empty input', () => {\n        const inputData = [];\n        const expected = [];\n        expect(generateCombinations(inputData)).toEqual(expected); // Jest's expect is similar to unittest's assertEqual\n    });\n\n    test('single empty list', () => {\n        const inputData = [[]]; // Equivalent to [[]] in Python\n        const expected = [];\n        expect(generateCombinations(inputData)).toEqual(expected);\n    });\n\n    test('single non-empty list', () => {\n        const inputData = [[\"a\", \"b\", \"c\"]]; // Same representation in JavaScript\n        const expected = [[\"a\"], [\"b\"], [\"c\"]];\n        expect(generateCombinations(inputData)).toEqual(expected);\n    });\n\n    test('multiple lists', () => {\n        const inputData = [[\"a\", \"b\"], [\"1\", \"2\"]]; // Same representation in JavaScript\n        const expected = [[\"a\", \"1\"], [\"a\", \"2\"], [\"b\", \"1\"], [\"b\", \"2\"]];\n        expect(generateCombinations(inputData)).toEqual(expected);\n    });\n\n    test('input containing empty list', () => {\n        const inputData = [[\"a\", \"b\"], [], [\"1\", \"2\"]]; // Same representation in JavaScript\n        const expected = [];\n        expect(generateCombinations(inputData)).toEqual(expected);\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Generates all possible combinations of elements from a list of lists.\n * Each combination consists of picking exactly one element from each list in the input list of lists.\n * This method is useful for generating product variations, scenarios in decision-making tools,\n * or any context where all possible combinations of a set of options need to be explored.\n *\n * @param {Array<Array<any>>} inputLists - A list of lists containing the elements to combine.\n *                                          The lists must not be empty but can contain elements of any type.\n * @returns {Array<Array<any>>} - A list of lists, where each inner list represents a possible combination of elements\n *                                 taken from the input lists. Returns an empty list if the input list is empty.\n */\nfunction generateCombinations(inputLists) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Generates all possible combinations of elements from a list of lists.\n * Each combination consists of picking exactly one element from each list in the input list of lists.\n * This method is useful for generating product variations, scenarios in decision-making tools,\n * or any context where all possible combinations of a set of options need to be explored.\n *\n * @param inputLists - A list of lists containing the elements to combine.\n *                     The lists must not be empty but can contain elements of any type.\n * @returns A list of lists, where each inner list represents a possible combination of elements\n *          taken from the input lists. Returns an empty list if the input list is empty.\n */\nfunction generateCombinations(inputLists: Array<Array<unknown>>): Array<Array<unknown>> {}", "test_code": "describe('generateCombinations', () => {\n    \n    test('should return an empty array for empty input', () => {\n        const inputData: Array<Array<string>> = [];\n        const expected: Array<Array<string>> = [];\n        expect(generateCombinations(inputData)).toEqual(expected);\n    });\n\n    test('should return an empty array for a single empty list', () => {\n        const inputData: Array<Array<string>> = [[]];\n        const expected: Array<Array<string>> = [];\n        expect(generateCombinations(inputData)).toEqual(expected);\n    });\n\n    test('should return combinations for a single non-empty list', () => {\n        const inputData: Array<Array<string>> = [['a', 'b', 'c']];\n        const expected: Array<Array<string>> = [['a'], ['b'], ['c']];\n        expect(generateCombinations(inputData)).toEqual(expected);\n    });\n\n    test('should return combinations for multiple lists', () => {\n        const inputData: Array<Array<string>> = [['a', 'b'], ['1', '2']];\n        const expected: Array<Array<string>> = [['a', '1'], ['a', '2'], ['b', '1'], ['b', '2']];\n        expect(generateCombinations(inputData)).toEqual(expected);\n    });\n\n    test('should return an empty array for input containing an empty list', () => {\n        const inputData: Array<Array<string>> = [['a', 'b'], [], ['1', '2']];\n        const expected: Array<Array<string>> = [];\n        expect(generateCombinations(inputData)).toEqual(expected);\n    });\n\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Generates all possible combinations of elements from a list of lists.\n * Each combination consists of picking exactly one element from each list in the input list of lists.\n * This method is useful for generating product variations, scenarios in decision-making tools,\n * or any context where all possible combinations of a set of options need to be explored.\n *\n * @param inputLists - A list of lists containing the elements to combine.\n *                     The lists must not be empty but can contain elements of any type.\n * @returns A list of lists, where each inner list represents a possible combination of elements\n *          taken from the input lists. Returns an empty list if the input list is empty.\n */\nfunction generateCombinations(inputLists: Array<Array<unknown>>): Array<Array<unknown>> {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Generates all possible combinations of elements from a list of lists.\n *\n * @param input_lists A vector of vectors containing the elements to combine. \n *                    The vectors must not be empty but can contain elements of any type.\n * @type input_lists std::vector<std::vector<std::any>>\n *\n * @return A vector of vectors, where each inner vector represents a possible combination of elements taken from the input lists. \n *         Returns an empty vector if the input list is empty.\n * @rtype std::vector<std::vector<std::any>>\n */\n\nstd::vector<std::vector<std::any>> generate_combinations(const std::vector<std::vector<std::any>>& input_lists) {\n    // Function implementation goes here\n}", "test_code": "TEST_CASE(\"TestGenerateCombinations\") {\n\n    SECTION(\"Empty input\") {\n        std::vector<std::vector<std::string>> input_data = {};\n        std::vector<std::vector<std::string>> expected = {};\n        REQUIRE(generate_combinations(input_data) == expected);\n    }\n\n    SECTION(\"Single empty list\") {\n        std::vector<std::vector<std::string>> input_data = {{}};\n        std::vector<std::vector<std::string>> expected = {};\n        REQUIRE(generate_combinations(input_data) == expected);\n    }\n\n    SECTION(\"Single non-empty list\") {\n        std::vector<std::vector<std::string>> input_data = {{\"a\", \"b\", \"c\"}};\n        std::vector<std::vector<std::string>> expected = {{\"a\"}, {\"b\"}, {\"c\"}};\n        REQUIRE(generate_combinations(input_data) == expected);\n    }\n\n    SECTION(\"Multiple lists\") {\n        std::vector<std::vector<std::string>> input_data = {{\"a\", \"b\"}, {\"1\", \"2\"}};\n        std::vector<std::vector<std::string>> expected = {{\"a\", \"1\"}, {\"a\", \"2\"}, {\"b\", \"1\"}, {\"b\", \"2\"}};\n        REQUIRE(generate_combinations(input_data) == expected);\n    }\n\n    SECTION(\"Input containing empty list\") {\n        std::vector<std::vector<std::string>> input_data = {{\"a\", \"b\"}, {}, {\"1\", \"2\"}};\n        std::vector<std::vector<std::string>> expected = {};\n        REQUIRE(generate_combinations(input_data) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Generates all possible combinations of elements from a list of lists.\n *\n * @param input_lists A vector of vectors containing the elements to combine. \n *                    The vectors must not be empty but can contain elements of any type.\n * @type input_lists std::vector<std::vector<std::any>>\n *\n * @return A vector of vectors, where each inner vector represents a possible combination of elements taken from the input lists. \n *         Returns an empty vector if the input list is empty.\n * @rtype std::vector<std::vector<std::any>>\n */\n\nstd::vector<std::vector<std::any>> generate_combinations(const std::vector<std::vector<std::any>>& input_lists) {\n    // Function implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Generates all possible combinations of elements from a list of lists, where each combination consists of\n * picking exactly one element from each list in the input list of lists. This method is useful for generating\n * product variations, scenarios in decision-making tools, or any other context where all possible combinations\n * of a set of options need to be explored.\n *\n * @param inputLists A list of lists containing the elements to combine. The lists must not be null but can contain any type of elements.\n * @return A list of lists, where each list represents a possible combination of elements taken from the input lists.\n *         Returns an empty list if the input list is null or empty.\n */\npublic List<List<T>> generateCombinations(List<List<T>> inputLists) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n    @Test\n    public void testEmptyInput() {\n        Answer generator = new Answer();\n        List<List<String>> input = new ArrayList<>();\n        List<List<String>> expected = new ArrayList<>();\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with empty input\");\n    }\n\n    @Test\n    public void testSingleEmptyList() {\n        Answer generator = new Answer();\n        List<List<String>> input = Arrays.asList(new ArrayList<>());\n        List<List<String>> expected = new ArrayList<>();\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with a single empty list\");\n    }\n\n    @Test\n    public void testSingleNonEmptyList() {\n        Answer generator = new Answer();\n        List<List<String>> input = Arrays.asList(Arrays.asList(\"a\", \"b\", \"c\"));\n        List<List<String>> expected = Arrays.asList(\n                Arrays.asList(\"a\"), Arrays.asList(\"b\"), Arrays.asList(\"c\")\n        );\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with a single non-empty list\");\n    }\n\n    @Test\n    public void testMultipleLists() {\n        Answer generator = new Answer();\n        List<List<String>> input = Arrays.asList(\n                Arrays.asList(\"a\", \"b\"),\n                Arrays.asList(\"1\", \"2\")\n        );\n        List<List<String>> expected = Arrays.asList(\n                Arrays.asList(\"a\", \"1\"), Arrays.asList(\"a\", \"2\"),\n                Arrays.asList(\"b\", \"1\"), Arrays.asList(\"b\", \"2\")\n        );\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with multiple lists\");\n    }\n\n    @Test\n    public void testInputContainingEmptyList() {\n        Answer generator = new Answer();\n        List<List<String>> input = Arrays.asList(\n                Arrays.asList(\"a\", \"b\"),\n                new ArrayList<>(),\n                Arrays.asList(\"1\", \"2\")\n        );\n        List<List<String>> expected = new ArrayList<>();\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with an input that contains an empty list\");\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Generates all possible combinations of elements from a list of lists, where each combination consists of\n * picking exactly one element from each list in the input list of lists. This method is useful for generating\n * product variations, scenarios in decision-making tools, or any other context where all possible combinations\n * of a set of options need to be explored.\n *\n * @param inputLists A list of lists containing the elements to combine. The lists must not be null but can contain any type of elements.\n * @return A list of lists, where each list represents a possible combination of elements taken from the input lists.\n *         Returns an empty list if the input list is null or empty.\n */\npublic List<List<T>> generateCombinations(List<List<T>> inputLists) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 350, "code_type": "method", "original_language": "java", "question_type": "Security", "summary": "Converts a byte array into its corresponding hexadecimal string representation.", "language_version_list": {"python": {"code_signature": "def byte_array_to_hex_string(byte_array: bytes) -> str:\n    \"\"\"\n    Converts a byte array into its corresponding hexadecimal string representation.\n\n    Args:\n        byte_array (bytes): An array of bytes to be converted into a hexadecimal string.\n\n    Returns:\n        str: A string representing the hexadecimal values of the bytes in the input array.If the input array is empty, returns an empty string.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestAnswer(unittest.TestCase):\n\n    def test_empty_byte_array(self):\n        input_data = bytes()  # Empty byte array\n        self.assertEqual(\"\", byte_array_to_hex_string(input_data), \"Empty array should return empty string\")\n\n    def test_single_byte(self):\n        input_data = bytes([0x0F])  # 15 in decimal\n        result = byte_array_to_hex_string(input_data)\n        self.assertTrue(result in [\"0F\", \"0f\"])\n\n    def test_multiple_bytes(self):\n        input_data = bytes([0x01, 0x0A, 0xFF])\n        result = byte_array_to_hex_string(input_data)\n        self.assertTrue(result in [\"010aff\", \"010AFF\"])\n\n    def test_zero_bytes(self):\n        input_data = bytes([0x00, 0x00, 0x00])\n        self.assertEqual(\"000000\", byte_array_to_hex_string(input_data), \"Zero bytes should be converted to '000000'\")\n\n    def test_negative_bytes(self):\n        input_data = bytes([0x80, 0xFF])  # 128 and 255 in signed byte representation\n        result = byte_array_to_hex_string(input_data)\n        self.assertTrue(result in [\"80FF\", \"80ff\"])", "prompt": "please write a python function , the function signature as below def byte_array_to_hex_string(byte_array: bytes) -> str:\n    \"\"\"\n    Converts a byte array into its corresponding hexadecimal string representation.\n\n    Args:\n        byte_array (bytes): An array of bytes to be converted into a hexadecimal string.\n\n    Returns:\n        str: A string representing the hexadecimal values of the bytes in the input array.If the input array is empty, returns an empty string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a byte array into its corresponding hexadecimal string representation.\n *\n * @param {Uint8Array} byteArray - An array of bytes to be converted into a hexadecimal string.\n * @returns {string} A string representing the hexadecimal values of the bytes in the input array. If the input array is empty, returns an empty string.\n */\nfunction byteArrayToHexString(byteArray) {}", "test_code": "describe('TestAnswer', () => {\n    test('empty byte array', () => {\n        const inputData = new Uint8Array(); // Empty byte array\n        expect(byteArrayToHexString(inputData)).toBe(\"\"); // Jest equivalent of assertEqual\n    });\n\n    test('single byte', () => {\n        const inputData = new Uint8Array([0x0F]); // 15 in decimal\n        const result = byteArrayToHexString(inputData);\n        expect([\"0F\", \"0f\"]).toContain(result); // Jest equivalent of assertTrue with array inclusion\n    });\n\n    test('multiple bytes', () => {\n        const inputData = new Uint8Array([0x01, 0x0A, 0xFF]);\n        const result = byteArrayToHexString(inputData);\n        expect([\"010aff\", \"010AFF\"]).toContain(result); // Same as above\n    });\n\n    test('zero bytes', () => {\n        const inputData = new Uint8Array([0x00, 0x00, 0x00]);\n        expect(byteArrayToHexString(inputData)).toBe(\"000000\"); // Jest equivalent of assertEqual\n    });\n\n    test('negative bytes', () => {\n        const inputData = new Uint8Array([0x80, 0xFF]); // 128 and 255 in signed byte representation\n        const result = byteArrayToHexString(inputData);\n        expect([\"80FF\", \"80ff\"]).toContain(result); // Same as above\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a byte array into its corresponding hexadecimal string representation.\n *\n * @param {Uint8Array} byteArray - An array of bytes to be converted into a hexadecimal string.\n * @returns {string} A string representing the hexadecimal values of the bytes in the input array. If the input array is empty, returns an empty string.\n */\nfunction byteArrayToHexString(byteArray) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a byte array into its corresponding hexadecimal string representation.\n *\n * @param byteArray - An array of bytes to be converted into a hexadecimal string.\n * @returns A string representing the hexadecimal values of the bytes in the input array. If the input array is empty, returns an empty string.\n */\nfunction byteArrayToHexString(byteArray: Uint8Array): string {}", "test_code": "describe('byteArrayToHexString', () => {\n    \n    test('empty byte array', () => {\n        const inputData = new Uint8Array(); // Empty byte array\n        expect(byteArrayToHexString(inputData)).toBe('');\n    });\n\n    test('single byte', () => {\n        const inputData = new Uint8Array([0x0F]); // 15 in decimal\n        const result = byteArrayToHexString(inputData);\n        expect(['0F', '0f']).toContain(result);\n    });\n\n    test('multiple bytes', () => {\n        const inputData = new Uint8Array([0x01, 0x0A, 0xFF]);\n        const result = byteArrayToHexString(inputData);\n        expect(['010aff', '010AFF']).toContain(result);\n    });\n\n    test('zero bytes', () => {\n        const inputData = new Uint8Array([0x00, 0x00, 0x00]);\n        expect(byteArrayToHexString(inputData)).toBe('000000');\n    });\n\n    test('negative bytes', () => {\n        const inputData = new Uint8Array([0x80, 0xFF]); // 128 and 255\n        const result = byteArrayToHexString(inputData);\n        expect(['80FF', '80ff']).toContain(result);\n    });\n\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a byte array into its corresponding hexadecimal string representation.\n *\n * @param byteArray - An array of bytes to be converted into a hexadecimal string.\n * @returns A string representing the hexadecimal values of the bytes in the input array. If the input array is empty, returns an empty string.\n */\nfunction byteArrayToHexString(byteArray: Uint8Array): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a byte array into its corresponding hexadecimal string representation.\n *\n * @param byte_array The array of bytes to be converted into a hexadecimal string.\n *                   Must be a non-empty vector of unsigned char.\n * @type byte_array const std::vector<unsigned char>&\n *\n * @return A string representing the hexadecimal values of the bytes in the input array. \n *         Returns an empty string if the input array is empty.\n * @rtype std::string\n */\n\nstd::string byte_array_to_hex_string(const std::vector<unsigned char>& byte_array);", "test_code": "TEST_CASE(\"Test byte_array_to_hex_string function\") {\n    \n    SECTION(\"Empty byte array\") {\n        std::vector<unsigned char> input_data;  // Empty byte array\n        REQUIRE(byte_array_to_hex_string(input_data) == \"\");\n    }\n\n    SECTION(\"Single byte\") {\n        std::vector<unsigned char> input_data = {0x0F};  // 15 in decimal\n        std::string result = byte_array_to_hex_string(input_data);\n        REQUIRE(result == \"0F\" || result == \"0f\");\n    }\n\n    SECTION(\"Multiple bytes\") {\n        std::vector<unsigned char> input_data = {0x01, 0x0A, 0xFF};\n        std::string result = byte_array_to_hex_string(input_data);\n        REQUIRE(result == \"010aff\" || result == \"010AFF\");\n    }\n\n    SECTION(\"Zero bytes\") {\n        std::vector<unsigned char> input_data = {0x00, 0x00, 0x00};\n        REQUIRE(byte_array_to_hex_string(input_data) == \"000000\");\n    }\n\n    SECTION(\"Negative bytes\") {\n        std::vector<unsigned char> input_data = {0x80, 0xFF};  // 128 and 255\n        std::string result = byte_array_to_hex_string(input_data);\n        REQUIRE(result == \"80FF\" || result == \"80ff\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a byte array into its corresponding hexadecimal string representation.\n *\n * @param byte_array The array of bytes to be converted into a hexadecimal string.\n *                   Must be a non-empty vector of unsigned char.\n * @type byte_array const std::vector<unsigned char>&\n *\n * @return A string representing the hexadecimal values of the bytes in the input array. \n *         Returns an empty string if the input array is empty.\n * @rtype std::string\n */\n\nstd::string byte_array_to_hex_string(const std::vector<unsigned char>& byte_array);", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a byte array into its corresponding hexadecimal string representation.\n *\n * @param byteArray An array of bytes to be converted into a hexadecimal string.\n * @return A string representing the hexadecimal values of the bytes in the input array. If the input array\n *         is empty, returns an empty string.\n */\npublic static String byteArrayToHexString(byte[] byteArray) {}", "test_code": "package org.real.temp;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class Tester {\n    @Test\n    void testEmptyByteArray() {\n        byte[] input = new byte[0];\n        assertEquals(\"\", Answer.byteArrayToHexString(input), \"Empty array should return empty string\");\n    }\n\n    @Test\n    void testSingleByte() {\n        byte[] input = {0x0F}; // 15 in decimal\n        String result = Answer.byteArrayToHexString(input);\n        assertTrue(result.equals(\"0F\") || result.equals(\"0f\"));\n    }\n\n    @Test\n    void testMultipleBytes() {\n        byte[] input = {0x01, 0x0A, (byte) 0xFF};\n        String result = Answer.byteArrayToHexString(input);\n        assertTrue(result.equals(\"010aff\") || result.equals(\"010AFF\"));\n    }\n\n    @Test\n    void testZeroBytes() {\n        byte[] input = {0x00, 0x00, 0x00};\n        assertEquals(\"000000\", Answer.byteArrayToHexString(input), \"Zero bytes should be converted to '000000'\");\n    }\n\n    @Test\n    void testNegativeBytes() {\n        byte[] input = {(byte) 0x80, (byte) 0xFF}; // 128 and 255 in signed byte representation\n        String result = Answer.byteArrayToHexString(input);\n        assertTrue(result.equals(\"80FF\") || result.equals(\"80ff\"));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts a byte array into its corresponding hexadecimal string representation.\n *\n * @param byteArray An array of bytes to be converted into a hexadecimal string.\n * @return A string representing the hexadecimal values of the bytes in the input array. If the input array\n *         is empty, returns an empty string.\n */\npublic static String byteArrayToHexString(byte[] byteArray) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 352, "code_type": "method", "original_language": "java", "question_type": "Data processing and transformation", "summary": "Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n in a readable format, especially in networking, cryptography, and systems programming. ", "language_version_list": {"python": {"code_signature": "def hex_string_to_byte_array(hex_str: str) -> bytes:\n    \"\"\"Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n    in a readable format, especially in networking, cryptography, and systems programming.\n\n    Args:\n        hex_str (str): The hexadecimal string to be converted. This string should only contain hexadecimal characters\n                       (0-9, A-F, a-f). If the string has an odd number of characters, a leading zero is added to ensure\n                       proper conversion.\n\n    Returns:\n        bytes: A byte array representing the binary data encoded in the hex string.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestHexStringToByteArray(unittest.TestCase):\n    def test_normal_hex_string(self):\n        hex_str = \"1a3f\"\n        expected = bytes([0x1A, 0x3F])\n        self.assertEqual(expected, hex_string_to_byte_array(hex_str),\n                         \"Should correctly convert a normal hex string\")\n\n    def test_odd_length_hex_string(self):\n        hex_str = \"123\"\n        expected = bytes([0x01, 0x23])\n        self.assertEqual(expected, hex_string_to_byte_array(hex_str),\n                         \"Should handle odd-length hex strings by prepending zero\")\n\n    def test_empty_string(self):\n        hex_str = \"\"\n        expected = bytes()\n        self.assertEqual(expected, hex_string_to_byte_array(hex_str),\n                         \"Should return an empty array for an empty string\")\n\n    def test_hex_string_with_uppercase(self):\n        hex_str = \"1A3F\"\n        expected = bytes([0x1A, 0x3F])\n        self.assertEqual(expected, hex_string_to_byte_array(hex_str),\n                         \"Should correctly handle hex strings with uppercase letters\")\n", "prompt": "please write a python function , the function signature as below def hex_string_to_byte_array(hex_str: str) -> bytes:\n    \"\"\"Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n    in a readable format, especially in networking, cryptography, and systems programming.\n\n    Args:\n        hex_str (str): The hexadecimal string to be converted. This string should only contain hexadecimal characters\n                       (0-9, A-F, a-f). If the string has an odd number of characters, a leading zero is added to ensure\n                       proper conversion.\n\n    Returns:\n        bytes: A byte array representing the binary data encoded in the hex string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n * in a readable format, especially in networking, cryptography, and systems programming.\n *\n * @param {string} hexStr - The hexadecimal string to be converted. This string should only contain hexadecimal characters\n *                          (0-9, A-F, a-f). If the string has an odd number of characters, a leading zero is added to ensure\n *                          proper conversion.\n * @returns {Uint8Array} A byte array representing the binary data encoded in the hex string.\n */\nfunction hexStringToByteArray(hexStr) {}", "test_code": "describe('hexStringToByteArray', () => {\n    test('normal hex string', () => {\n        const hexStr = \"1a3f\";\n        const expected = new Uint8Array([0x1A, 0x3F]);\n        expect(hexStringToByteArray(hexStr)).toEqual(expected);\n        // Assertion message is not included in Jest by default\n    });\n\n    test('odd length hex string', () => {\n        const hexStr = \"123\";\n        const expected = new Uint8Array([0x01, 0x23]);\n        expect(hexStringToByteArray(hexStr)).toEqual(expected);\n    });\n\n    test('empty string', () => {\n        const hexStr = \"\";\n        const expected = new Uint8Array([]);\n        expect(hexStringToByteArray(hexStr)).toEqual(expected);\n    });\n\n    test('hex string with uppercase', () => {\n        const hexStr = \"1A3F\";\n        const expected = new Uint8Array([0x1A, 0x3F]);\n        expect(hexStringToByteArray(hexStr)).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n * in a readable format, especially in networking, cryptography, and systems programming.\n *\n * @param {string} hexStr - The hexadecimal string to be converted. This string should only contain hexadecimal characters\n *                          (0-9, A-F, a-f). If the string has an odd number of characters, a leading zero is added to ensure\n *                          proper conversion.\n * @returns {Uint8Array} A byte array representing the binary data encoded in the hex string.\n */\nfunction hexStringToByteArray(hexStr) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n * in a readable format, especially in networking, cryptography, and systems programming.\n *\n * @param hexStr - The hexadecimal string to be converted. This string should only contain hexadecimal characters\n *                 (0-9, A-F, a-f). If the string has an odd number of characters, a leading zero is added to ensure\n *                 proper conversion.\n * @returns A byte array representing the binary data encoded in the hex string.\n */\nfunction hexStringToByteArray(hexStr: string): Uint8Array {}", "test_code": "describe('hexStringToByteArray', () => {\n    test('should correctly convert a normal hex string', () => {\n        const hexStr = \"1a3f\";\n        const expected = new Uint8Array([0x1A, 0x3F]);\n        expect(hexStringToByteArray(hexStr)).toEqual(expected);\n    });\n\n    test('should handle odd-length hex strings by prepending zero', () => {\n        const hexStr = \"123\";\n        const expected = new Uint8Array([0x01, 0x23]);\n        expect(hexStringToByteArray(hexStr)).toEqual(expected);\n    });\n\n    test('should return an empty array for an empty string', () => {\n        const hexStr = \"\";\n        const expected = new Uint8Array(0);\n        expect(hexStringToByteArray(hexStr)).toEqual(expected);\n    });\n\n    test('should correctly handle hex strings with uppercase letters', () => {\n        const hexStr = \"1A3F\";\n        const expected = new Uint8Array([0x1A, 0x3F]);\n        expect(hexStringToByteArray(hexStr)).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n * in a readable format, especially in networking, cryptography, and systems programming.\n *\n * @param hexStr - The hexadecimal string to be converted. This string should only contain hexadecimal characters\n *                 (0-9, A-F, a-f). If the string has an odd number of characters, a leading zero is added to ensure\n *                 proper conversion.\n * @returns A byte array representing the binary data encoded in the hex string.\n */\nfunction hexStringToByteArray(hexStr: string): Uint8Array {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a hexadecimal string into a byte array.\n *\n * @param hex_str The hexadecimal string to be converted. \n *                This string should only contain hexadecimal characters (0-9, A-F, a-f). \n *                If the string has an odd number of characters, a leading zero is added \n *                to ensure proper conversion.\n * @type hex_str std::string\n *\n * @return A byte array representing the binary data encoded in the hex string.\n * @rtype std::vector<uint8_t>\n */\n\nstd::vector<uint8_t> hex_string_to_byte_array(const std::string& hex_str);", "test_code": "TEST_CASE(\"Hex string to byte array conversion\") {\n    \n    SECTION(\"Normal hex string\") {\n        std::string hex_str = \"1a3f\";\n        std::vector<uint8_t> expected = {0x1A, 0x3F};\n        REQUIRE(hex_string_to_byte_array(hex_str) == expected);\n    }\n\n    SECTION(\"Odd length hex string\") {\n        std::string hex_str = \"123\";\n        std::vector<uint8_t> expected = {0x01, 0x23};\n        REQUIRE(hex_string_to_byte_array(hex_str) == expected);\n    }\n\n    SECTION(\"Empty string\") {\n        std::string hex_str = \"\";\n        std::vector<uint8_t> expected = {};\n        REQUIRE(hex_string_to_byte_array(hex_str) == expected);\n    }\n\n    SECTION(\"Hex string with uppercase\") {\n        std::string hex_str = \"1A3F\";\n        std::vector<uint8_t> expected = {0x1A, 0x3F};\n        REQUIRE(hex_string_to_byte_array(hex_str) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a hexadecimal string into a byte array.\n *\n * @param hex_str The hexadecimal string to be converted. \n *                This string should only contain hexadecimal characters (0-9, A-F, a-f). \n *                If the string has an odd number of characters, a leading zero is added \n *                to ensure proper conversion.\n * @type hex_str std::string\n *\n * @return A byte array representing the binary data encoded in the hex string.\n * @rtype std::vector<uint8_t>\n */\n\nstd::vector<uint8_t> hex_string_to_byte_array(const std::string& hex_str);", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n * in a readable format, especially in networking, cryptography, and systems programming.\n *\n * @param hex The hexadecimal string to be converted. This string should only contain hexadecimal characters\n *            (0-9, A-F, a-f). If the string has an odd number of characters, a leading zero is added to ensure\n *            proper conversion.\n * @return A byte array representing the binary data encoded in the hex string.\n */\npublic static byte[] hexStringToByteArray(String hex) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Tester {\n    @Test\n    void testNormalHexString() {\n        String hex = \"1a3f\";\n        byte[] expected = { (byte) 0x1A, (byte) 0x3F };\n        assertArrayEquals(expected, Answer.hexStringToByteArray(hex), \"Should correctly convert a normal hex string\");\n    }\n\n    @Test\n    void testOddLengthHexString() {\n        String hex = \"123\";\n        byte[] expected = { (byte) 0x01, (byte) 0x23 };\n        assertArrayEquals(expected, Answer.hexStringToByteArray(hex), \"Should handle odd-length hex strings by prepending zero\");\n    }\n\n    @Test\n    void testEmptyString() {\n        String hex = \"\";\n        byte[] expected = new byte[0];\n        assertArrayEquals(expected, Answer.hexStringToByteArray(hex), \"Should return an empty array for an empty string\");\n    }\n\n    @Test\n    void testHexStringWithUppercase() {\n        String hex = \"1A3F\";\n        byte[] expected = { (byte) 0x1A, (byte) 0x3F };\n        assertArrayEquals(expected, Answer.hexStringToByteArray(hex), \"Should correctly handle hex strings with uppercase letters\");\n    }\n\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n * in a readable format, especially in networking, cryptography, and systems programming.\n *\n * @param hex The hexadecimal string to be converted. This string should only contain hexadecimal characters\n *            (0-9, A-F, a-f). If the string has an odd number of characters, a leading zero is added to ensure\n *            proper conversion.\n * @return A byte array representing the binary data encoded in the hex string.\n */\npublic static byte[] hexStringToByteArray(String hex) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 609, "code_type": "method", "original_language": "java", "question_type": "Algorithm and data structure", "summary": "Given an integer array nums and an integer target value target, find the two integers in the array whose sum is the target value target and return their array subscripts\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef two_sum(nums: List[int], target: int) -> int:\n    \"\"\"\n    Finds two indices of numbers in the array that sum up to the target value.\n\n    Args:\n        nums (List[int]): The input array of integers.\n        target (int): The target sum value.\n\n    Returns:\n        list[int]: A list containing the indices of the two numbers.\n\n    Raises:\n        ValueError: If no such indices are found.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestAnswer(unittest.TestCase):\n    def test_valid_pair(self):\n        nums = [2, 7, 11, 15]\n        target = 9\n        expected = [0, 1]  # 2 + 7 = 9\n        self.assertEqual(expected, two_sum(nums, target))\n\n    def test_negative_numbers(self):\n        nums = [-1, -2, -3, -4, -5]\n        target = -8\n        expected = [2, 4]  # -3 + -5 = -8\n        self.assertEqual(expected, two_sum(nums, target))\n\n    def test_zero_sum(self):\n        nums = [0, 4, 3, 0]\n        target = 0\n        expected = [0, 3]  # 0 + 0 = 0\n        self.assertEqual(expected, two_sum(nums, target))\n\n    def test_no_solution(self):\n        nums = [1, 2, 3, 4, 5]\n        target = 10\n        with self.assertRaises(Exception):\n            two_sum(nums, target)\n\n    def test_same_number_twice(self):\n        nums = [3, 3]\n        target = 6\n        expected = [0, 1]  # 3 + 3 = 6\n        self.assertEqual(expected, two_sum(nums, target))\n\n    def test_large_numbers(self):\n        nums = [2147483647, -2147483648, 0, 1]\n        target = 1\n        expected = [2, 3]  # 0 + 1 = 1\n        self.assertEqual(expected, two_sum(nums, target))", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef two_sum(nums: List[int], target: int) -> int:\n    \"\"\"\n    Finds two indices of numbers in the array that sum up to the target value.\n\n    Args:\n        nums (List[int]): The input array of integers.\n        target (int): The target sum value.\n\n    Returns:\n        list[int]: A list containing the indices of the two numbers.\n\n    Raises:\n        ValueError: If no such indices are found.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Finds two indices of numbers in the array that sum up to the target value.\n *\n * @param {number[]} nums - The input array of integers.\n * @param {number} target - The target sum value.\n * @returns {number[]} A list containing the indices of the two numbers.\n * @throws {Error} If no such indices are found.\n */\nfunction twoSum(nums, target) {}", "test_code": "describe('TestAnswer', () => {\n    test('valid pair', () => {\n        const nums = [2, 7, 11, 15];\n        const target = 9;\n        const expected = [0, 1]; // 2 + 7 = 9\n        expect(twoSum(nums, target)).toEqual(expected);\n    });\n\n    test('negative numbers', () => {\n        const nums = [-1, -2, -3, -4, -5];\n        const target = -8;\n        const expected = [2, 4]; // -3 + -5 = -8\n        expect(twoSum(nums, target)).toEqual(expected);\n    });\n\n    test('zero sum', () => {\n        const nums = [0, 4, 3, 0];\n        const target = 0;\n        const expected = [0, 3]; // 0 + 0 = 0\n        expect(twoSum(nums, target)).toEqual(expected);\n    });\n\n    test('no solution', () => {\n        const nums = [1, 2, 3, 4, 5];\n        const target = 10;\n        expect(() => twoSum(nums, target)).toThrow(Error);\n    });\n\n    test('same number twice', () => {\n        const nums = [3, 3];\n        const target = 6;\n        const expected = [0, 1]; // 3 + 3 = 6\n        expect(twoSum(nums, target)).toEqual(expected);\n    });\n\n    test('large numbers', () => {\n        const nums = [2147483647, -2147483648, 0, 1];\n        const target = 1;\n        const expected = [2, 3]; // 0 + 1 = 1\n        expect(twoSum(nums, target)).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Finds two indices of numbers in the array that sum up to the target value.\n *\n * @param {number[]} nums - The input array of integers.\n * @param {number} target - The target sum value.\n * @returns {number[]} A list containing the indices of the two numbers.\n * @throws {Error} If no such indices are found.\n */\nfunction twoSum(nums, target) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Finds two indices of numbers in the array that sum up to the target value.\n *\n * @param nums - The input array of integers.\n * @param target - The target sum value.\n * @returns A list containing the indices of the two numbers.\n * @throws Error if no such indices are found.\n */\nfunction twoSum(nums: number[], target: number): number[] {}", "test_code": "describe('TestAnswer', () => {\n    test('valid pair', () => {\n        const nums = [2, 7, 11, 15];\n        const target = 9;\n        const expected = [0, 1]; // 2 + 7 = 9\n        expect(twoSum(nums, target)).toEqual(expected);\n    });\n\n    test('negative numbers', () => {\n        const nums = [-1, -2, -3, -4, -5];\n        const target = -8;\n        const expected = [2, 4]; // -3 + -5 = -8\n        expect(twoSum(nums, target)).toEqual(expected);\n    });\n\n    test('zero sum', () => {\n        const nums = [0, 4, 3, 0];\n        const target = 0;\n        const expected = [0, 3]; // 0 + 0 = 0\n        expect(twoSum(nums, target)).toEqual(expected);\n    });\n\n    test('no solution', () => {\n        const nums = [1, 2, 3, 4, 5];\n        const target = 10;\n        expect(() => twoSum(nums, target)).toThrow(Error);\n    });\n\n    test('same number twice', () => {\n        const nums = [3, 3];\n        const target = 6;\n        const expected = [0, 1]; // 3 + 3 = 6\n        expect(twoSum(nums, target)).toEqual(expected);\n    });\n\n    test('large numbers', () => {\n        const nums = [2147483647, -2147483648, 0, 1];\n        const target = 1;\n        const expected = [2, 3]; // 0 + 1 = 1\n        expect(twoSum(nums, target)).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Finds two indices of numbers in the array that sum up to the target value.\n *\n * @param nums - The input array of integers.\n * @param target - The target sum value.\n * @returns A list containing the indices of the two numbers.\n * @throws Error if no such indices are found.\n */\nfunction twoSum(nums: number[], target: number): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds two indices of numbers in the input array that add up to a specified target sum.\n *\n *\n * @param nums The input array of integers.\n *             Must be a vector of integers with at least two elements.\n * @type nums std::vector<int>\n *\n * @param target The target sum value that two numbers from the array should add up to.\n * @type target int\n *\n * @return A vector containing the indices of the two numbers that sum to the target.\n * @rtype std::vector<int>\n *\n * @throws std::invalid_argument If no such indices are found.\n */\nstd::vector<int> two_sum(const std::vector<int>& nums, int target);", "test_code": "TEST_CASE(\"TestAnswer\") {\n    SECTION(\"Valid pair\") {\n        std::vector<int> nums = {2, 7, 11, 15};\n        int target = 9;\n        std::vector<int> expected = {0, 1};  // 2 + 7 = 9\n        REQUIRE(two_sum(nums, target) == expected);\n    }\n\n    SECTION(\"Negative numbers\") {\n        std::vector<int> nums = {-1, -2, -3, -4, -5};\n        int target = -8;\n        std::vector<int> expected = {2, 4};  // -3 + -5 = -8\n        REQUIRE(two_sum(nums, target) == expected);\n    }\n\n    SECTION(\"Zero sum\") {\n        std::vector<int> nums = {0, 4, 3, 0};\n        int target = 0;\n        std::vector<int> expected = {0, 3};  // 0 + 0 = 0\n        REQUIRE(two_sum(nums, target) == expected);\n    }\n\n    SECTION(\"No solution\") {\n        std::vector<int> nums = {1, 2, 3, 4, 5};\n        int target = 10;\n        REQUIRE_THROWS_AS(two_sum(nums, target), std::invalid_argument);\n    }\n\n    SECTION(\"Same number twice\") {\n        std::vector<int> nums = {3, 3};\n        int target = 6;\n        std::vector<int> expected = {0, 1};  // 3 + 3 = 6\n        REQUIRE(two_sum(nums, target) == expected);\n    }\n\n    SECTION(\"Large numbers\") {\n        std::vector<int> nums = {2147483647, -2147483648, 0, 1};\n        int target = 1;\n        std::vector<int> expected = {2, 3};  // 0 + 1 = 1\n        REQUIRE(two_sum(nums, target) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds two indices of numbers in the input array that add up to a specified target sum.\n *\n *\n * @param nums The input array of integers.\n *             Must be a vector of integers with at least two elements.\n * @type nums std::vector<int>\n *\n * @param target The target sum value that two numbers from the array should add up to.\n * @type target int\n *\n * @return A vector containing the indices of the two numbers that sum to the target.\n * @rtype std::vector<int>\n *\n * @throws std::invalid_argument If no such indices are found.\n */\nstd::vector<int> two_sum(const std::vector<int>& nums, int target);", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds two indices of numbers in the array that sum up to the target value.\n *\n * @param nums   the input array of integers\n * @param target the target sum value\n * @return an array containing the indices of the two numbers\n * @throws IllegalArgumentException if no such indices are found\n */\npublic int[] twoSum(int[] nums, int target) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Tester {\n\n    private final Answer answer = new Answer();\n\n    @Test\n    public void testValidPair() {\n        int[] nums = {2, 7, 11, 15};\n        int target = 9;\n        int[] expected = {0, 1}; // 2 + 7 = 9\n        assertArrayEquals(expected, answer.twoSum(nums, target));\n    }\n\n    @Test\n    public void testNegativeNumbers() {\n        int[] nums = {-1, -2, -3, -4, -5};\n        int target = -8;\n        int[] expected = {2, 4}; // -3 + -5 = -8\n        assertArrayEquals(expected, answer.twoSum(nums, target));\n    }\n\n    @Test\n    public void testZeroSum() {\n        int[] nums = {0, 4, 3, 0};\n        int target = 0;\n        int[] expected = {0, 3}; // 0 + 0 = 0\n        assertArrayEquals(expected, answer.twoSum(nums, target));\n    }\n\n    @Test\n    public void testNoSolution() {\n        int[] nums = {1, 2, 3, 4, 5};\n        int target = 10;\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> {\n            answer.twoSum(nums, target);\n        });\n        assertEquals(\"No two sum solution\", exception.getMessage());\n    }\n\n    @Test\n    public void testSameNumberTwice() {\n        int[] nums = {3, 3};\n        int target = 6;\n        int[] expected = {0, 1}; // 3 + 3 = 6\n        assertArrayEquals(expected, answer.twoSum(nums, target));\n    }\n\n    @Test\n    public void testLargeNumbers() {\n        int[] nums = {Integer.MAX_VALUE, Integer.MIN_VALUE, 0, 1};\n        int target = 1;\n        int[] expected = {2, 3}; // 0 + 1 = 1\n        assertArrayEquals(expected, answer.twoSum(nums, target));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds two indices of numbers in the array that sum up to the target value.\n *\n * @param nums   the input array of integers\n * @param target the target sum value\n * @return an array containing the indices of the two numbers\n * @throws IllegalArgumentException if no such indices are found\n */\npublic int[] twoSum(int[] nums, int target) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 610, "code_type": "method", "original_language": "java", "question_type": "Data processing and transformation", "summary": "Rewrite the hashcode method in the content part of the class so that its hashcode is related to the name and age fields in the class\n", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "/**\n * Rewrite the hashcode method in the content part of the class so that its hashcode is related to the name and age fields in the class\n *\n * @return obj hashcode\n */\n@Override\npublic int hashCode() {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass Tester {\n\n    @Test\n    void testHashCode_SameNameAndAge() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Alice\", 25);\n        assertEquals(answer1.hashCode(), answer2.hashCode(), \"Hash codes should be equal for the same name and age.\");\n    }\n\n    @Test\n    void testHashCode_DifferentName() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Bob\", 25);\n        assertNotEquals(answer1.hashCode(), answer2.hashCode(), \"Hash codes should be different for different names.\");\n    }\n\n    @Test\n    void testHashCode_DifferentAge() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Alice\", 30);\n        assertNotEquals(answer1.hashCode(), answer2.hashCode(), \"Hash codes should be different for different ages.\");\n    }\n\n    @Test\n    void testEquals_SameReference() {\n        Answer answer = new Answer(\"Alice\", 25);\n        assertTrue(answer.equals(answer), \"An object should be equal to itself.\");\n    }\n\n    @Test\n    void testEquals_SameNameAndAge() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Alice\", 25);\n        assertTrue(answer1.equals(answer2), \"Two answers with the same name and age should be equal.\");\n    }\n\n    @Test\n    void testEquals_DifferentName() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Bob\", 25);\n        assertFalse(answer1.equals(answer2), \"Two answers with different names should not be equal.\");\n    }\n\n    @Test\n    void testEquals_DifferentAge() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Alice\", 30);\n        assertFalse(answer1.equals(answer2), \"Two answers with different ages should not be equal.\");\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Rewrite the hashcode method in the content part of the class so that its hashcode is related to the name and age fields in the class\n *\n * @return obj hashcode\n */\n@Override\npublic int hashCode() {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 611, "code_type": "method", "original_language": "java", "question_type": "Data processing and transformation", "summary": "Generates a random string of length 25 and must contain both upper case letters (A-Z) and lower case letters (a-z)\n", "language_version_list": {"python": {"code_signature": "def generate_random_string() -> str:\n    \"\"\"Generates a random string of length 25 containing both upper case (A-Z) and lower case (a-z) letters.\n\n    Returns:\n        str: A randomly generated string that meets the criteria of including both upper and lower case letters.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGenerateRandomString(unittest.TestCase):\n\n    def test_length(self):\n        random_string = generate_random_string()\n        self.assertEqual(len(random_string), 25, \"The generated string length should be 25.\")\n\n    def test_contains_upper_case(self):\n        random_string = generate_random_string()\n        self.assertTrue(any(char.isupper() for char in random_string),\n                        \"The generated string should contain at least one uppercase letter.\")\n\n    def test_contains_lower_case(self):\n        random_string = generate_random_string()\n        self.assertTrue(any(char.islower() for char in random_string),\n                        \"The generated string should contain at least one lowercase letter.\")\n\n    def test_randomness(self):\n        string1 = generate_random_string()\n        string2 = generate_random_string()\n        self.assertNotEqual(string1, string2, \"Two generated strings should not be the same.\")\n\n    def test_multiple_generations(self):\n        num_tests = 100\n        has_upper_case = False\n        has_lower_case = False\n\n        for _ in range(num_tests):\n            random_string = generate_random_string()\n            has_upper_case |= any(char.isupper() for char in random_string)\n            has_lower_case |= any(char.islower() for char in random_string)\n\n        self.assertTrue(has_upper_case, \"At least one generated string should contain an uppercase letter.\")\n        self.assertTrue(has_lower_case, \"At least one generated string should contain a lowercase letter.\")\n", "prompt": "please write a python function , the function signature as below def generate_random_string() -> str:\n    \"\"\"Generates a random string of length 25 containing both upper case (A-Z) and lower case (a-z) letters.\n\n    Returns:\n        str: A randomly generated string that meets the criteria of including both upper and lower case letters.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Generates a random string of length 25 containing both upper case (A-Z) and lower case (a-z) letters.\n *\n * @returns {string} A randomly generated string that meets the criteria of including both upper and lower case letters.\n */\nfunction generateRandomString() {}", "test_code": "describe('generateRandomString', () => {\n    \n    test('length', () => {\n        const randomString = generateRandomString();\n        expect(randomString.length).toBe(25); // Equivalent of assertEqual in unittest\n    });\n\n    test('contains upper case', () => {\n        const randomString = generateRandomString();\n        const hasUpperCase = [...randomString].some(char => char === char.toUpperCase() && char !== char.toLowerCase());\n        expect(hasUpperCase).toBe(true); // Equivalent of assertTrue in unittest\n    });\n\n    test('contains lower case', () => {\n        const randomString = generateRandomString();\n        const hasLowerCase = [...randomString].some(char => char === char.toLowerCase() && char !== char.toUpperCase());\n        expect(hasLowerCase).toBe(true); // Equivalent of assertTrue in unittest\n    });\n\n    test('randomness', () => {\n        const string1 = generateRandomString();\n        const string2 = generateRandomString();\n        expect(string1).not.toBe(string2); // Equivalent of assertNotEqual in unittest\n    });\n\n    test('multiple generations', () => {\n        const numTests = 100;\n        let hasUpperCase = false;\n        let hasLowerCase = false;\n\n        for (let i = 0; i < numTests; i++) {\n            const randomString = generateRandomString();\n            hasUpperCase ||= [...randomString].some(char => char === char.toUpperCase() && char !== char.toLowerCase());\n            hasLowerCase ||= [...randomString].some(char => char === char.toLowerCase() && char !== char.toUpperCase());\n        }\n\n        expect(hasUpperCase).toBe(true); // Equivalent of assertTrue in unittest\n        expect(hasLowerCase).toBe(true); // Equivalent of assertTrue in unittest\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Generates a random string of length 25 containing both upper case (A-Z) and lower case (a-z) letters.\n *\n * @returns {string} A randomly generated string that meets the criteria of including both upper and lower case letters.\n */\nfunction generateRandomString() {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Generates a random string of length 25 containing both upper case (A-Z) \n * and lower case (a-z) letters.\n *\n * @returns {string} A randomly generated string that meets the criteria of \n * including both upper and lower case letters.\n */\nfunction generateRandomString(): string {}", "test_code": "describe('generateRandomString', () => {\n    test('length', () => {\n        const randomString = generateRandomString();\n        expect(randomString.length).toBe(25);\n    });\n\n    test('contains upper case', () => {\n        const randomString = generateRandomString();\n        expect(randomString.split('').some(char => char.toUpperCase() === char && char.toLowerCase() !== char)).toBe(true);\n    });\n\n    test('contains lower case', () => {\n        const randomString = generateRandomString();\n        expect(randomString.split('').some(char => char.toLowerCase() === char && char.toUpperCase() !== char)).toBe(true);\n    });\n\n    test('randomness', () => {\n        const string1 = generateRandomString();\n        const string2 = generateRandomString();\n        expect(string1).not.toBe(string2);\n    });\n\n    test('multiple generations', () => {\n        const numTests = 100;\n        let hasUpperCase = false;\n        let hasLowerCase = false;\n\n        for (let i = 0; i < numTests; i++) {\n            const randomString = generateRandomString();\n            hasUpperCase ||= randomString.split('').some(char => char.toUpperCase() === char && char.toLowerCase() !== char);\n            hasLowerCase ||= randomString.split('').some(char => char.toLowerCase() === char && char.toUpperCase() !== char);\n        }\n\n        expect(hasUpperCase).toBe(true);\n        expect(hasLowerCase).toBe(true);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Generates a random string of length 25 containing both upper case (A-Z) \n * and lower case (a-z) letters.\n *\n * @returns {string} A randomly generated string that meets the criteria of \n * including both upper and lower case letters.\n */\nfunction generateRandomString(): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Generates a random string of specified length containing both upper case \n *        (A-Z) and lower case (a-z) letters.\n *\n * @return A randomly generated string that meets the criteria of including both \n *         upper and lower case letters.\n * @rtype std::string\n */\n\nstd::string generate_random_string();", "test_code": "TEST_CASE(\"Test Generate Random String\") {\n\n    SECTION(\"Test length\") {\n        std::string random_string = generate_random_string();\n        REQUIRE(random_string.length() == 25);\n    }\n\n    SECTION(\"Test contains upper case\") {\n        std::string random_string = generate_random_string();\n        bool has_upper_case = std::any_of(random_string.begin(), random_string.end(), [](char c) {\n            return std::isupper(static_cast<unsigned char>(c));\n        });\n        REQUIRE(has_upper_case);\n    }\n\n    SECTION(\"Test contains lower case\") {\n        std::string random_string = generate_random_string();\n        bool has_lower_case = std::any_of(random_string.begin(), random_string.end(), [](char c) {\n            return std::islower(static_cast<unsigned char>(c));\n        });\n        REQUIRE(has_lower_case);\n    }\n\n    SECTION(\"Test randomness\") {\n        std::string string1 = generate_random_string();\n        std::string string2 = generate_random_string();\n        REQUIRE(string1 != string2);\n    }\n\n    SECTION(\"Test multiple generations\") {\n        const int num_tests = 100;\n        bool has_upper_case = false;\n        bool has_lower_case = false;\n\n        for (int i = 0; i < num_tests; ++i) {\n            std::string random_string = generate_random_string();\n            has_upper_case |= std::any_of(random_string.begin(), random_string.end(), [](char c) {\n                return std::isupper(static_cast<unsigned char>(c));\n            });\n            has_lower_case |= std::any_of(random_string.begin(), random_string.end(), [](char c) {\n                return std::islower(static_cast<unsigned char>(c));\n            });\n        }\n\n        REQUIRE(has_upper_case);\n        REQUIRE(has_lower_case);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Generates a random string of specified length containing both upper case \n *        (A-Z) and lower case (a-z) letters.\n *\n * @return A randomly generated string that meets the criteria of including both \n *         upper and lower case letters.\n * @rtype std::string\n */\n\nstd::string generate_random_string();", "addition_info": ""}, "java": {"code_signature": "/**\n * Generates a random string of length 25 and must contain both upper case letters (A-Z) and lower case letters (a-z)\n *\n * @return random string\n */\npublic static String generateRandomString() {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testLength() {\n        String randomString = Answer.generateRandomString();\n        assertEquals(25, randomString.length(), \"The generated string length should be 25.\");\n    }\n\n    @Test\n    public void testContainsUpperCase() {\n        String randomString = Answer.generateRandomString();\n        assertTrue(randomString.chars().anyMatch(Character::isUpperCase),\n                \"The generated string should contain at least one uppercase letter.\");\n    }\n\n    @Test\n    public void testContainsLowerCase() {\n        String randomString = Answer.generateRandomString();\n        assertTrue(randomString.chars().anyMatch(Character::isLowerCase),\n                \"The generated string should contain at least one lowercase letter.\");\n    }\n\n    @Test\n    public void testRandomness() {\n        String string1 = Answer.generateRandomString();\n        String string2 = Answer.generateRandomString();\n        assertNotEquals(string1, string2, \"Two generated strings should not be the same.\");\n    }\n\n    @Test\n    public void testMultipleGenerations() {\n        int numTests = 100;\n        boolean hasUpperCase = false;\n        boolean hasLowerCase = false;\n\n        for (int i = 0; i < numTests; i++) {\n            String randomString = Answer.generateRandomString();\n            hasUpperCase |= randomString.chars().anyMatch(Character::isUpperCase);\n            hasLowerCase |= randomString.chars().anyMatch(Character::isLowerCase);\n        }\n\n        assertTrue(hasUpperCase, \"At least one generated string should contain an uppercase letter.\");\n        assertTrue(hasLowerCase, \"At least one generated string should contain a lowercase letter.\");\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Generates a random string of length 25 and must contain both upper case letters (A-Z) and lower case letters (a-z)\n *\n * @return random string\n */\npublic static String generateRandomString() {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 612, "code_type": "method", "original_language": "java", "question_type": "File operations and I/O operation", "summary": "Find and replace text in the specified file\n", "language_version_list": {"python": {"code_signature": "def find_and_replace_in_file(file_path:str, search_string:str, replace_string:str):\n    \"\"\"\n    Finds and replaces text in a specified file.\n\n    Args:\n        file_path (str): The path to the file.\n        search_string (str): The string to search for.\n        replace_string (str): The string to replace with.\n\n    Raises:\n        IOError: If an I/O error occurs reading from the file or writing to the file.\n    \"\"\"", "test_code": "import os\nimport unittest\n\n\nclass TestFindAndReplace(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory for the tests\n        self.temp_dir = os.path.join(os.path.dirname(__file__), 'qa_item')\n        os.makedirs(self.temp_dir, exist_ok=True)\n\n    def tearDown(self):\n        # Remove the temporary directory after tests\n        for file in os.listdir(self.temp_dir):\n            os.remove(os.path.join(self.temp_dir, file))\n        os.rmdir(self.temp_dir)\n\n    # Test case 1: Basic find and replace\n    def test_find_and_replace_basic(self):\n        file_path = os.path.join(self.temp_dir, \"testfile.txt\")\n        with open(file_path, 'w') as file:\n            file.writelines([\"Hello World\\n\", \"Goodbye World\\n\"])\n\n        find_and_replace_in_file(file_path, \"World\", \"Java\")\n\n        with open(file_path, 'r') as file:\n            result = file.readlines()\n\n        self.assertEqual(result, [\"Hello Java\\n\", \"Goodbye Java\\n\"])\n\n    # Test case 2: No occurrences of the search string\n    def test_find_and_replace_no_occurrences(self):\n        file_path = os.path.join(self.temp_dir, \"testfile.txt\")\n        with open(file_path, 'w') as file:\n            file.writelines([\"Hello World\\n\", \"Goodbye World\\n\"])\n\n        find_and_replace_in_file(file_path, \"Python\", \"Java\")\n\n        with open(file_path, 'r') as file:\n            result = file.readlines()\n\n        self.assertEqual(result, [\"Hello World\\n\", \"Goodbye World\\n\"])\n\n    # Test case 3: Multiple occurrences in a single line\n    def test_find_and_replace_multiple_occurrences(self):\n        file_path = os.path.join(self.temp_dir, \"testfile.txt\")\n        with open(file_path, 'w') as file:\n            file.writelines([\"Hello World World\\n\", \"Goodbye World\\n\"])\n\n        find_and_replace_in_file(file_path, \"World\", \"Java\")\n\n        with open(file_path, 'r') as file:\n            result = file.readlines()\n\n        self.assertEqual(result, [\"Hello Java Java\\n\", \"Goodbye Java\\n\"])\n\n    # Test case 4: Replace with an empty string\n    def test_find_and_replace_with_empty_string(self):\n        file_path = os.path.join(self.temp_dir, \"testfile.txt\")\n        with open(file_path, 'w') as file:\n            file.writelines([\"Hello World\\n\", \"Goodbye World\\n\"])\n\n        find_and_replace_in_file(file_path, \"World\", \"\")\n\n        with open(file_path, 'r') as file:\n            result = file.readlines()\n\n        self.assertEqual(result, [\"Hello \\n\", \"Goodbye \\n\"])\n\n    # Test case 5: Empty file\n    def test_find_and_replace_empty_file(self):\n        file_path = os.path.join(self.temp_dir, \"testfile.txt\")\n        with open(file_path, 'w') as file:\n            file.writelines([\"\\n\"])\n\n        find_and_replace_in_file(file_path, \"World\", \"Java\")\n\n        with open(file_path, 'r') as file:\n            result = file.readlines()\n\n        self.assertEqual(result, [\"\\n\"])\n", "prompt": "please write a python function , the function signature as below def find_and_replace_in_file(file_path:str, search_string:str, replace_string:str):\n    \"\"\"\n    Finds and replaces text in a specified file.\n\n    Args:\n        file_path (str): The path to the file.\n        search_string (str): The string to search for.\n        replace_string (str): The string to replace with.\n\n    Raises:\n        IOError: If an I/O error occurs reading from the file or writing to the file.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Finds and replaces text in a specified file.\n *\n * @param {string} filePath - The path to the file.\n * @param {string} searchString - The string to search for.\n * @param {string} replaceString - The string to replace with.\n * @throws {Error} If an I/O error occurs reading from the file or writing to the file.\n */\nfunction findAndReplaceInFile(filePath, searchString, replaceString) {}", "test_code": "import path from \"path\";\n\ndescribe('TestFindAndReplace', () => {\n    let tempDir;\n\n    beforeAll(() => {\n        // Create a temporary directory for the tests\n        tempDir = path.join(__dirname, 'temp');\n        fs.mkdirSync(tempDir, { recursive: true });\n    });\n\n    afterAll(() => {\n        // Remove the temporary directory after tests\n        fs.readdirSync(tempDir).forEach(file => {\n            fs.unlinkSync(path.join(tempDir, file));\n        });\n        fs.rmdirSync(tempDir);\n    });\n\n    // Test case 1: Basic find and replace\n    test('find and replace basic', () => {\n        const filePath = path.join(tempDir, 'testfile.txt');\n        fs.writeFileSync(filePath, 'Hello World\\nGoodbye World\\n');\n\n        findAndReplaceInFile(filePath, 'World', 'Java');\n\n        const result = fs.readFileSync(filePath, 'utf-8').split('\\n');\n        expect(result).toEqual(['Hello Java', 'Goodbye Java', '']);\n    });\n\n    // Test case 2: No occurrences of the search string\n    test('find and replace no occurrences', () => {\n        const filePath = path.join(tempDir, 'testfile.txt');\n        fs.writeFileSync(filePath, 'Hello World\\nGoodbye World\\n');\n\n        findAndReplaceInFile(filePath, 'Python', 'Java');\n\n        const result = fs.readFileSync(filePath, 'utf-8').split('\\n');\n        expect(result).toEqual(['Hello World', 'Goodbye World', '']);\n    });\n\n    // Test case 3: Multiple occurrences in a single line\n    test('find and replace multiple occurrences', () => {\n        const filePath = path.join(tempDir, 'testfile.txt');\n        fs.writeFileSync(filePath, 'Hello World World\\nGoodbye World\\n');\n\n        findAndReplaceInFile(filePath, 'World', 'Java');\n\n        const result = fs.readFileSync(filePath, 'utf-8').split('\\n');\n        expect(result).toEqual(['Hello Java Java', 'Goodbye Java', '']);\n    });\n\n    // Test case 4: Replace with an empty string\n    test('find and replace with empty string', () => {\n        const filePath = path.join(tempDir, 'testfile.txt');\n        fs.writeFileSync(filePath, 'Hello World\\nGoodbye World\\n');\n\n        findAndReplaceInFile(filePath, 'World', '');\n\n        const result = fs.readFileSync(filePath, 'utf-8').split('\\n');\n        expect(result).toEqual(['Hello ', 'Goodbye ', '']);\n    });\n\n    // Test case 5: Empty file\n    test('find and replace empty file', () => {\n        const filePath = path.join(tempDir, 'testfile.txt');\n        fs.writeFileSync(filePath, '\\n');\n\n        findAndReplaceInFile(filePath, 'World', 'Java');\n\n        const result = fs.readFileSync(filePath, 'utf-8').split('\\n');\n        expect(result).toEqual(['', '']);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Finds and replaces text in a specified file.\n *\n * @param {string} filePath - The path to the file.\n * @param {string} searchString - The string to search for.\n * @param {string} replaceString - The string to replace with.\n * @throws {Error} If an I/O error occurs reading from the file or writing to the file.\n */\nfunction findAndReplaceInFile(filePath, searchString, replaceString) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Finds and replaces text in a specified file.\n *\n * @param filePath - The path to the file.\n * @param searchString - The string to search for.\n * @param replaceString - The string to replace with.\n * @throws {Error} If an I/O error occurs reading from the file or writing to the file.\n */\nfunction findAndReplaceInFile(filePath: string, searchString: string, replaceString: string): void {}", "test_code": "import * as path from 'path';\n\ndescribe('TestFindAndReplace', () => {\n    const tempDir = path.join(__dirname, 'qa_item');\n\n    beforeAll(() => {\n        // Create a temporary directory for the tests\n        fs.mkdirSync(tempDir, { recursive: true });\n    });\n\n    afterAll(() => {\n        // Remove the temporary directory after tests\n        fs.rmdirSync(tempDir, { recursive: true });\n    });\n\n    // Test case 1: Basic find and replace\n    test('find and replace basic', () => {\n        const filePath = path.join(tempDir, 'testfile.txt');\n        fs.writeFileSync(filePath, 'Hello World\\nGoodbye World\\n');\n\n        findAndReplaceInFile(filePath, 'World', 'Java');\n\n        const result = fs.readFileSync(filePath, 'utf-8').split('\\n');\n        expect(result).toEqual(['Hello Java', 'Goodbye Java', '']);\n    });\n\n    // Test case 2: No occurrences of the search string\n    test('find and replace no occurrences', () => {\n        const filePath = path.join(tempDir, 'testfile.txt');\n        fs.writeFileSync(filePath, 'Hello World\\nGoodbye World\\n');\n\n        findAndReplaceInFile(filePath, 'Python', 'Java');\n\n        const result = fs.readFileSync(filePath, 'utf-8').split('\\n');\n        expect(result).toEqual(['Hello World', 'Goodbye World', '']);\n    });\n\n    // Test case 3: Multiple occurrences in a single line\n    test('find and replace multiple occurrences', () => {\n        const filePath = path.join(tempDir, 'testfile.txt');\n        fs.writeFileSync(filePath, 'Hello World World\\nGoodbye World\\n');\n\n        findAndReplaceInFile(filePath, 'World', 'Java');\n\n        const result = fs.readFileSync(filePath, 'utf-8').split('\\n');\n        expect(result).toEqual(['Hello Java Java', 'Goodbye Java', '']);\n    });\n\n    // Test case 4: Replace with an empty string\n    test('find and replace with empty string', () => {\n        const filePath = path.join(tempDir, 'testfile.txt');\n        fs.writeFileSync(filePath, 'Hello World\\nGoodbye World\\n');\n\n        findAndReplaceInFile(filePath, 'World', '');\n\n        const result = fs.readFileSync(filePath, 'utf-8').split('\\n');\n        expect(result).toEqual(['Hello ', 'Goodbye ', '']);\n    });\n\n    // Test case 5: Empty file\n    test('find and replace empty file', () => {\n        const filePath = path.join(tempDir, 'testfile.txt');\n        fs.writeFileSync(filePath, '\\n');\n\n        findAndReplaceInFile(filePath, 'World', 'Java');\n\n        const result = fs.readFileSync(filePath, 'utf-8').split('\\n');\n        expect(result).toEqual(['','']);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Finds and replaces text in a specified file.\n *\n * @param filePath - The path to the file.\n * @param searchString - The string to search for.\n * @param replaceString - The string to replace with.\n * @throws {Error} If an I/O error occurs reading from the file or writing to the file.\n */\nfunction findAndReplaceInFile(filePath: string, searchString: string, replaceString: string): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds and replaces text in a specified file.\n *\n * @param file_path The path to the file.\n * @param search_string The string to search for.\n * @param replace_string The string to replace with.\n *\n * @throws std::ios_base::failure If an I/O error occurs reading from the file or writing to the file.\n */\nvoid find_and_replace_in_file(const std::string& file_path, const std::string& search_string, const std::string& replace_string);", "test_code": "TEST_CASE_METHOD(TestFindAndReplace, \"Basic find and replace\") {\n    auto file_path = temp_dir / \"testfile.txt\";\n    std::ofstream(file_path) << \"Hello World\\nGoodbye World\\n\";\n\n    find_and_replace_in_file(file_path.string(), \"World\", \"Java\");\n\n    std::ifstream ifs(file_path);\n    std::string result((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());\n    REQUIRE(result == \"Hello Java\\nGoodbye Java\\n\");\n}\n\nTEST_CASE_METHOD(TestFindAndReplace, \"No occurrences of the search string\") {\n    auto file_path = temp_dir / \"testfile.txt\";\n    std::ofstream(file_path) << \"Hello World\\nGoodbye World\\n\";\n\n    find_and_replace_in_file(file_path.string(), \"Python\", \"Java\");\n\n    std::ifstream ifs(file_path);\n    std::string result((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());\n    REQUIRE(result == \"Hello World\\nGoodbye World\\n\");\n}\n\nTEST_CASE_METHOD(TestFindAndReplace, \"Multiple occurrences in a single line\") {\n    auto file_path = temp_dir / \"testfile.txt\";\n    std::ofstream(file_path) << \"Hello World World\\nGoodbye World\\n\";\n\n    find_and_replace_in_file(file_path.string(), \"World\", \"Java\");\n\n    std::ifstream ifs(file_path);\n    std::string result((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());\n    REQUIRE(result == \"Hello Java Java\\nGoodbye Java\\n\");\n}\n\nTEST_CASE_METHOD(TestFindAndReplace, \"Replace with an empty string\") {\n    auto file_path = temp_dir / \"testfile.txt\";\n    std::ofstream(file_path) << \"Hello World\\nGoodbye World\\n\";\n\n    find_and_replace_in_file(file_path.string(), \"World\", \"\");\n\n    std::ifstream ifs(file_path);\n    std::string result((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());\n    REQUIRE(result == \"Hello \\nGoodbye \\n\");\n}\n\nTEST_CASE_METHOD(TestFindAndReplace, \"Empty file\") {\n    auto file_path = temp_dir / \"testfile.txt\";\n    std::ofstream(file_path) << \"\\n\";\n\n    find_and_replace_in_file(file_path.string(), \"World\", \"Java\");\n\n    std::ifstream ifs(file_path);\n    std::string result((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());\n    REQUIRE(result == \"\\n\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds and replaces text in a specified file.\n *\n * @param file_path The path to the file.\n * @param search_string The string to search for.\n * @param replace_string The string to replace with.\n *\n * @throws std::ios_base::failure If an I/O error occurs reading from the file or writing to the file.\n */\nvoid find_and_replace_in_file(const std::string& file_path, const std::string& search_string, const std::string& replace_string);", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds and replaces text in a specified file.\n *\n * @param filePath      the path to the file\n * @param searchString  the string to search for\n * @param replaceString the string to replace with\n * @throws IOException if an I/O error occurs reading from the file or writing to the file\n */\npublic static void findAndReplaceInFile(Path filePath, String searchString, String replaceString) throws IOException {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.real.temp.Answer;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\n\npublic class Tester {\n\n    // Test case 1: Basic find and replace\n    @Test\n    public void testFindAndReplaceBasic(@TempDir Path tempDir) throws IOException {\n        Path filePath = tempDir.resolve(\"testfile.txt\");\n        Files.write(filePath, List.of(\"Hello World\", \"Goodbye World\"));\n\n        Answer.findAndReplaceInFile(filePath, \"World\", \"Java\");\n\n        List<String> result = Files.readAllLines(filePath);\n        assertEquals(List.of(\"Hello Java\", \"Goodbye Java\"), result);\n    }\n\n    // Test case 2: No occurrences of the search string\n    @Test\n    public void testFindAndReplaceNoOccurrences(@TempDir Path tempDir) throws IOException {\n        Path filePath = tempDir.resolve(\"testfile.txt\");\n        Files.write(filePath, List.of(\"Hello World\", \"Goodbye World\"));\n\n        Answer.findAndReplaceInFile(filePath, \"Python\", \"Java\");\n\n        List<String> result = Files.readAllLines(filePath);\n        assertEquals(List.of(\"Hello World\", \"Goodbye World\"), result);\n    }\n\n    // Test case 3: Multiple occurrences in a single line\n    @Test\n    public void testFindAndReplaceMultipleOccurrences(@TempDir Path tempDir) throws IOException {\n        Path filePath = tempDir.resolve(\"testfile.txt\");\n        Files.write(filePath, List.of(\"Hello World World\", \"Goodbye World\"));\n\n        Answer.findAndReplaceInFile(filePath, \"World\", \"Java\");\n\n        List<String> result = Files.readAllLines(filePath);\n        assertEquals(List.of(\"Hello Java Java\", \"Goodbye Java\"), result);\n    }\n\n    // Test case 4: Replace with an empty string\n    @Test\n    public void testFindAndReplaceWithEmptyString(@TempDir Path tempDir) throws IOException {\n        Path filePath = tempDir.resolve(\"testfile.txt\");\n        Files.write(filePath, List.of(\"Hello World\", \"Goodbye World\"));\n\n        Answer.findAndReplaceInFile(filePath, \"World\", \"\");\n\n        List<String> result = Files.readAllLines(filePath);\n        assertEquals(List.of(\"Hello \", \"Goodbye \"), result);\n    }\n\n    // Test case 5: Empty file\n    @Test\n    public void testFindAndReplaceEmptyFile(@TempDir Path tempDir) throws IOException {\n        Path filePath = tempDir.resolve(\"testfile.txt\");\n        Files.write(filePath, List.of(\"\"));\n\n        Answer.findAndReplaceInFile(filePath, \"World\", \"Java\");\n\n        List<String> result = Files.readAllLines(filePath);\n        assertEquals(List.of(\"\"), result);\n    }\n\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Finds and replaces text in a specified file.\n *\n * @param filePath      the path to the file\n * @param searchString  the string to search for\n * @param replaceString the string to replace with\n * @throws IOException if an I/O error occurs reading from the file or writing to the file\n */\npublic static void findAndReplaceInFile(Path filePath, String searchString, String replaceString) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 614, "code_type": "method", "original_language": "java", "question_type": "Data processing and transformation", "summary": "Accept a list containing multiple integer values, calculate the difference from the previous data for each item of data, get a difference array, and calculate the average difference value\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef calculate_average_difference(numbers: List[int]) -> float:\n    \"\"\"Calculates the average difference between consecutive integers in the provided list.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        float: The average difference between consecutive integers, or 0 if there are fewer than 2 integers.\n    \"\"\"", "test_code": "import unittest\nfrom typing import List\n\n\nclass TestCalculateAverageDifference(unittest.TestCase):\n\n    def test_calculate_average_difference_positive_integers(self):\n        numbers: List[int] = [10, 20, 30, 40]\n        result = calculate_average_difference(numbers)\n        expected = 10.0\n        self.assertAlmostEqual(expected, result, msg=\"The average difference should be 10.0\")\n\n    def test_calculate_average_difference_mixed_positive_and_negative(self):\n        numbers: List[int] = [-10, 0, 10, 20]\n        result = calculate_average_difference(numbers)\n        expected = 10.0\n        self.assertAlmostEqual(expected, result, msg=\"The average difference should be 10.0\")\n\n    def test_calculate_average_difference_same_values(self):\n        numbers: List[int] = [5, 5, 5, 5]\n        result = calculate_average_difference(numbers)\n        expected = 0.0\n        self.assertAlmostEqual(expected, result, msg=\"The average difference should be 0.0 as all values are the same\")\n\n    def test_calculate_average_difference_single_element(self):\n        numbers: List[int] = [100]\n        result = calculate_average_difference(numbers)\n        expected = 0.0  # Not enough data to calculate differences\n        self.assertAlmostEqual(expected, result, msg=\"The average difference should be 0.0 for a single element list\")\n\n    def test_calculate_average_difference_empty_list(self):\n        numbers: List[int] = []\n        result = calculate_average_difference(numbers)\n        expected = 0.0  # Not enough data to calculate differences\n        self.assertAlmostEqual(expected, result, msg=\"The average difference should be 0.0 for an empty list\")", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef calculate_average_difference(numbers: List[int]) -> float:\n    \"\"\"Calculates the average difference between consecutive integers in the provided list.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        float: The average difference between consecutive integers, or 0 if there are fewer than 2 integers.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculates the average difference between consecutive integers in the provided array.\n *\n * @param {number[]} numbers - An array of integers.\n * @returns {number} The average difference between consecutive integers, or 0 if there are fewer than 2 integers.\n */\nfunction calculateAverageDifference(numbers) {}", "test_code": "describe('calculateAverageDifference', () => {\n    test('calculates average difference for positive integers', () => {\n        const numbers = [10, 20, 30, 40];\n        const result = calculateAverageDifference(numbers);\n        const expected = 10.0;\n        expect(result).toBeCloseTo(expected, 5); // Jest equivalent for almost equal assertion\n    });\n\n    test('calculates average difference for mixed positive and negative integers', () => {\n        const numbers = [-10, 0, 10, 20];\n        const result = calculateAverageDifference(numbers);\n        const expected = 10.0;\n        expect(result).toBeCloseTo(expected, 5); // Jest equivalent for almost equal assertion\n    });\n\n    test('calculates average difference for same values', () => {\n        const numbers = [5, 5, 5, 5];\n        const result = calculateAverageDifference(numbers);\n        const expected = 0.0;\n        expect(result).toBeCloseTo(expected, 5); // Jest equivalent for almost equal assertion\n    });\n\n    test('returns 0 for single element list', () => {\n        const numbers = [100];\n        const result = calculateAverageDifference(numbers);\n        const expected = 0.0; // Not enough data to calculate differences\n        expect(result).toBeCloseTo(expected, 5); // Jest equivalent for almost equal assertion\n    });\n\n    test('returns 0 for empty list', () => {\n        const numbers = [];\n        const result = calculateAverageDifference(numbers);\n        const expected = 0.0; // Not enough data to calculate differences\n        expect(result).toBeCloseTo(expected, 5); // Jest equivalent for almost equal assertion\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the average difference between consecutive integers in the provided array.\n *\n * @param {number[]} numbers - An array of integers.\n * @returns {number} The average difference between consecutive integers, or 0 if there are fewer than 2 integers.\n */\nfunction calculateAverageDifference(numbers) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the average difference between consecutive integers in the provided list.\n *\n * @param {number[]} numbers - A list of integers.\n * @returns {number} The average difference between consecutive integers, or 0 if there are fewer than 2 integers.\n */\nfunction calculateAverageDifference(numbers: number[]): number {}", "test_code": "describe('calculateAverageDifference', () => {\n    test('calculates average difference for positive integers', () => {\n        const numbers: number[] = [10, 20, 30, 40];\n        const result = calculateAverageDifference(numbers);\n        const expected = 10.0;\n        expect(result).toBeCloseTo(expected, 5); // Precision for floating point comparison\n    });\n\n    test('calculates average difference for mixed positive and negative integers', () => {\n        const numbers: number[] = [-10, 0, 10, 20];\n        const result = calculateAverageDifference(numbers);\n        const expected = 10.0;\n        expect(result).toBeCloseTo(expected, 5);\n    });\n\n    test('calculates average difference for same values', () => {\n        const numbers: number[] = [5, 5, 5, 5];\n        const result = calculateAverageDifference(numbers);\n        const expected = 0.0;\n        expect(result).toBeCloseTo(expected, 5);\n    });\n\n    test('returns 0.0 for single element list', () => {\n        const numbers: number[] = [100];\n        const result = calculateAverageDifference(numbers);\n        const expected = 0.0; // Not enough data to calculate differences\n        expect(result).toBeCloseTo(expected, 5);\n    });\n\n    test('returns 0.0 for empty list', () => {\n        const numbers: number[] = [];\n        const result = calculateAverageDifference(numbers);\n        const expected = 0.0; // Not enough data to calculate differences\n        expect(result).toBeCloseTo(expected, 5);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the average difference between consecutive integers in the provided list.\n *\n * @param {number[]} numbers - A list of integers.\n * @returns {number} The average difference between consecutive integers, or 0 if there are fewer than 2 integers.\n */\nfunction calculateAverageDifference(numbers: number[]): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculates the average difference between consecutive integers in a provided list.\n *\n * @param numbers A vector of integers for which the average difference is to be calculated.\n * @type numbers std::vector<int>\n *\n * @return The average difference between consecutive integers, or 0 if there are fewer \n *         than two integers.\n * @rtype double\n */\n\ndouble calculate_average_difference(const std::vector<int>& numbers);", "test_code": "TEST_CASE(\"TestCalculateAverageDifference\") {\n    \n    SECTION(\"Positive integers\") {\n        std::vector<int> numbers = {10, 20, 30, 40};\n        double result = calculate_average_difference(numbers);\n        double expected = 10.0;\n        REQUIRE(result == Approx(expected).epsilon(0.001)); // Using Approx for floating-point comparison\n    }\n\n    SECTION(\"Mixed positive and negative integers\") {\n        std::vector<int> numbers = {-10, 0, 10, 20};\n        double result = calculate_average_difference(numbers);\n        double expected = 10.0;\n        REQUIRE(result == Approx(expected).epsilon(0.001));\n    }\n\n    SECTION(\"Same values\") {\n        std::vector<int> numbers = {5, 5, 5, 5};\n        double result = calculate_average_difference(numbers);\n        double expected = 0.0;\n        REQUIRE(result == Approx(expected).epsilon(0.001));\n    }\n\n    SECTION(\"Single element\") {\n        std::vector<int> numbers = {100};\n        double result = calculate_average_difference(numbers);\n        double expected = 0.0; // Not enough data to calculate differences\n        REQUIRE(result == Approx(expected).epsilon(0.001));\n    }\n\n    SECTION(\"Empty list\") {\n        std::vector<int> numbers = {};\n        double result = calculate_average_difference(numbers);\n        double expected = 0.0; // Not enough data to calculate differences\n        REQUIRE(result == Approx(expected).epsilon(0.001));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculates the average difference between consecutive integers in a provided list.\n *\n * @param numbers A vector of integers for which the average difference is to be calculated.\n * @type numbers std::vector<int>\n *\n * @return The average difference between consecutive integers, or 0 if there are fewer \n *         than two integers.\n * @rtype double\n */\n\ndouble calculate_average_difference(const std::vector<int>& numbers);", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the average difference between consecutive integers in the provided list.\n *\n * @param numbers a list of integers\n * @return the average difference, or 0 if there are fewer than 2 integers\n */\npublic static double calculateAverageDifference(List<Integer> numbers) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testCalculateAverageDifference_PositiveIntegers() {\n        List<Integer> numbers = List.of(10, 20, 30, 40);\n        double result = Answer.calculateAverageDifference(numbers);\n        double expected = 10.0;\n        assertEquals(expected, result, \"The average difference should be 10.0\");\n    }\n\n    @Test\n    public void testCalculateAverageDifference_MixedPositiveAndNegative() {\n        List<Integer> numbers = List.of(-10, 0, 10, 20);\n        double result = Answer.calculateAverageDifference(numbers);\n        double expected = 10.0;\n        assertEquals(expected, result, \"The average difference should be 10.0\");\n    }\n\n    @Test\n    public void testCalculateAverageDifference_SameValues() {\n        List<Integer> numbers = List.of(5, 5, 5, 5);\n        double result = Answer.calculateAverageDifference(numbers);\n        double expected = 0.0;\n        assertEquals(expected, result, \"The average difference should be 0.0 as all values are the same\");\n    }\n\n    @Test\n    public void testCalculateAverageDifference_SingleElement() {\n        List<Integer> numbers = List.of(100);\n        double result = Answer.calculateAverageDifference(numbers);\n        double expected = 0.0;  // Not enough data to calculate differences\n        assertEquals(expected, result, \"The average difference should be 0.0 for a single element list\");\n    }\n\n    @Test\n    public void testCalculateAverageDifference_EmptyList() {\n        List<Integer> numbers = List.of();\n        double result = Answer.calculateAverageDifference(numbers);\n        double expected = 0.0;  // Not enough data to calculate differences\n        assertEquals(expected, result, \"The average difference should be 0.0 for an empty list\");\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the average difference between consecutive integers in the provided list.\n *\n * @param numbers a list of integers\n * @return the average difference, or 0 if there are fewer than 2 integers\n */\npublic static double calculateAverageDifference(List<Integer> numbers) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 615, "code_type": "method", "original_language": "java", "question_type": "Algorithm and data structure", "summary": "Calculates the average of a set of integer lists over a specified period\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef calculate(values: List[int], period: int) -> float:\n    \"\"\"Calculates the average of the last 'period' integers in the given list of values.\n\n    Args:\n        values (List[int]): The list of integers from which to calculate the average.\n        period (int): The number of last elements to include in the average calculation.\n\n    Returns:\n        float: The average of the last 'period' integers, or math.nan if the input list\n                does not contain enough elements or if the period is invalid (<= 0).\n    \"\"\"", "test_code": "import math\nimport unittest\n\n\nclass TestAnswer(unittest.TestCase):\n\n    def test_calculate_with_valid_input(self):\n        values = [1, 2, 3, 4, 5]\n        period = 3\n        expected = 4.0  # (3 + 4 + 5) / 3\n        self.assertEqual(expected, calculate(values, period))\n\n    def test_calculate_with_all_same_values(self):\n        values = [5, 5, 5, 5, 5]\n        period = 5\n        expected = 5.0  # (5 + 5 + 5 + 5 + 5) / 5\n        self.assertEqual(expected, calculate(values, period))\n\n    def test_calculate_with_single_value(self):\n        values = [10]\n        period = 1\n        expected = 10.0  # (10) / 1\n        self.assertEqual(expected, calculate(values, period))\n\n    def test_calculate_with_insufficient_values(self):\n        values = [1, 2]\n        period = 3\n        self.assertTrue(math.isnan(calculate(values, period)))  # Expecting NaN\n\n    def test_calculate_with_empty_list(self):\n        values = []\n        period = 1\n        self.assertTrue(math.isnan(calculate(values, period)))  # Expecting NaN\n\n    def test_calculate_with_negative_period(self):\n        values = [1, 2, 3, 4, 5]\n        period = -1\n        self.assertTrue(math.isnan(calculate(values, period)))  # Expecting NaN", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef calculate(values: List[int], period: int) -> float:\n    \"\"\"Calculates the average of the last 'period' integers in the given list of values.\n\n    Args:\n        values (List[int]): The list of integers from which to calculate the average.\n        period (int): The number of last elements to include in the average calculation.\n\n    Returns:\n        float: The average of the last 'period' integers, or math.nan if the input list\n                does not contain enough elements or if the period is invalid (<= 0).\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculates the average of the last 'period' integers in the given array of values.\n *\n * @param {number[]} values - The array of integers from which to calculate the average.\n * @param {number} period - The number of last elements to include in the average calculation.\n * @returns {number} The average of the last 'period' integers, or NaN if the input array\n *                  does not contain enough elements or if the period is invalid (<= 0).\n */\nfunction calculate(values, period) {}", "test_code": "describe('Test Answer', () => {\n    \n    test('calculate with valid input', () => {\n        const values = [1, 2, 3, 4, 5];\n        const period = 3;\n        const expected = 4.0;  // (3 + 4 + 5) / 3\n        expect(calculate(values, period)).toBe(expected);\n    });\n\n    test('calculate with all same values', () => {\n        const values = [5, 5, 5, 5, 5];\n        const period = 5;\n        const expected = 5.0;  // (5 + 5 + 5 + 5 + 5) / 5\n        expect(calculate(values, period)).toBe(expected);\n    });\n\n    test('calculate with single value', () => {\n        const values = [10];\n        const period = 1;\n        const expected = 10.0;  // (10) / 1\n        expect(calculate(values, period)).toBe(expected);\n    });\n\n    test('calculate with insufficient values', () => {\n        const values = [1, 2];\n        const period = 3;\n        expect(isNaN(calculate(values, period))).toBe(true);  // Expecting NaN\n    });\n\n    test('calculate with empty list', () => {\n        const values = [];\n        const period = 1;\n        expect(isNaN(calculate(values, period))).toBe(true);  // Expecting NaN\n    });\n\n    test('calculate with negative period', () => {\n        const values = [1, 2, 3, 4, 5];\n        const period = -1;\n        expect(isNaN(calculate(values, period))).toBe(true);  // Expecting NaN\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the average of the last 'period' integers in the given array of values.\n *\n * @param {number[]} values - The array of integers from which to calculate the average.\n * @param {number} period - The number of last elements to include in the average calculation.\n * @returns {number} The average of the last 'period' integers, or NaN if the input array\n *                  does not contain enough elements or if the period is invalid (<= 0).\n */\nfunction calculate(values, period) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the average of the last 'period' integers in the given array of values.\n *\n * @param {number[]} values - The array of integers from which to calculate the average.\n * @param {number} period - The number of last elements to include in the average calculation.\n * @returns {number} - The average of the last 'period' integers, or NaN if the input array\n *                     does not contain enough elements or if the period is invalid (<= 0).\n */\nfunction calculate(values: number[], period: number): number {}", "test_code": "describe('calculate', () => {\n    \n    test('should calculate the average with valid input', () => {\n        const values: number[] = [1, 2, 3, 4, 5];\n        const period: number = 3;\n        const expected: number = 4.0; // (3 + 4 + 5) / 3\n        expect(calculate(values, period)).toBe(expected);\n    });\n\n    test('should calculate the average with all same values', () => {\n        const values: number[] = [5, 5, 5, 5, 5];\n        const period: number = 5;\n        const expected: number = 5.0; // (5 + 5 + 5 + 5 + 5) / 5\n        expect(calculate(values, period)).toBe(expected);\n    });\n\n    test('should calculate the average with a single value', () => {\n        const values: number[] = [10];\n        const period: number = 1;\n        const expected: number = 10.0; // (10) / 1\n        expect(calculate(values, period)).toBe(expected);\n    });\n\n    test('should return NaN with insufficient values', () => {\n        const values: number[] = [1, 2];\n        const period: number = 3;\n        expect(calculate(values, period)).toBeNaN(); // Expecting NaN\n    });\n\n    test('should return NaN with an empty list', () => {\n        const values: number[] = [];\n        const period: number = 1;\n        expect(calculate(values, period)).toBeNaN(); // Expecting NaN\n    });\n\n    test('should return NaN with negative period', () => {\n        const values: number[] = [1, 2, 3, 4, 5];\n        const period: number = -1;\n        expect(calculate(values, period)).toBeNaN(); // Expecting NaN\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the average of the last 'period' integers in the given array of values.\n *\n * @param {number[]} values - The array of integers from which to calculate the average.\n * @param {number} period - The number of last elements to include in the average calculation.\n * @returns {number} - The average of the last 'period' integers, or NaN if the input array\n *                     does not contain enough elements or if the period is invalid (<= 0).\n */\nfunction calculate(values: number[], period: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculates the average of the last 'period' integers in the given list of values.\n *\n * @param values A vector of integers from which to calculate the average.\n * @type values std::vector<int>\n *\n * @param period The number of last elements to include in the average calculation. \n *               Must be greater than zero.\n * @type period int\n *\n * @return The average of the last `period` integers, or `std::nan` if the input vector \n *         does not contain enough elements or if the period is invalid.\n * @rtype double\n */\n\ndouble calculate(const std::vector<int>& values, int period);", "test_code": "TEST_CASE(\"TestAnswer\") {\n    \n    SECTION(\"test_calculate_with_valid_input\") {\n        std::vector<int> values = {1, 2, 3, 4, 5};\n        int period = 3;\n        double expected = 4.0; // (3 + 4 + 5) / 3\n        REQUIRE(calculate(values, period) == Approx(expected));\n    }\n\n    SECTION(\"test_calculate_with_all_same_values\") {\n        std::vector<int> values = {5, 5, 5, 5, 5};\n        int period = 5;\n        double expected = 5.0; // (5 + 5 + 5 + 5 + 5) / 5\n        REQUIRE(calculate(values, period) == Approx(expected));\n    }\n\n    SECTION(\"test_calculate_with_single_value\") {\n        std::vector<int> values = {10};\n        int period = 1;\n        double expected = 10.0; // (10) / 1\n        REQUIRE(calculate(values, period) == Approx(expected));\n    }\n\n    SECTION(\"test_calculate_with_insufficient_values\") {\n        std::vector<int> values = {1, 2};\n        int period = 3;\n        REQUIRE(std::isnan(calculate(values, period))); // Expecting NaN\n    }\n\n    SECTION(\"test_calculate_with_empty_list\") {\n        std::vector<int> values = {};\n        int period = 1;\n        REQUIRE(std::isnan(calculate(values, period))); // Expecting NaN\n    }\n\n    SECTION(\"test_calculate_with_negative_period\") {\n        std::vector<int> values = {1, 2, 3, 4, 5};\n        int period = -1;\n        REQUIRE(std::isnan(calculate(values, period))); // Expecting NaN\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculates the average of the last 'period' integers in the given list of values.\n *\n * @param values A vector of integers from which to calculate the average.\n * @type values std::vector<int>\n *\n * @param period The number of last elements to include in the average calculation. \n *               Must be greater than zero.\n * @type period int\n *\n * @return The average of the last `period` integers, or `std::nan` if the input vector \n *         does not contain enough elements or if the period is invalid.\n * @rtype double\n */\n\ndouble calculate(const std::vector<int>& values, int period);", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the average of the last 'period' integers in the given list of values.\n *\n * @param values The list of integers from which to calculate the average.\n * @param period The number of last elements to include in the average calculation.\n * @return The average of the last 'period' integers, or Double.NaN if the input list\n *         does not contain enough elements or if the period is invalid (<= 0).\n */\npublic static double calculate(List<Integer> values, int period) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testCalculateWithValidInput() {\n        List<Integer> values = Arrays.asList(1, 2, 3, 4, 5);\n        int period = 3;\n        double expected = 4.0; // (3 + 4 + 5) / 3\n        assertEquals(expected, Answer.calculate(values, period));\n    }\n\n    @Test\n    public void testCalculateWithAllSameValues() {\n        List<Integer> values = Arrays.asList(5, 5, 5, 5, 5);\n        int period = 5;\n        double expected = 5.0; // (5 + 5 + 5 + 5 + 5) / 5\n        assertEquals(expected, Answer.calculate(values, period));\n    }\n\n    @Test\n    public void testCalculateWithSingleValue() {\n        List<Integer> values = Arrays.asList(10);\n        int period = 1;\n        double expected = 10.0; // (10) / 1\n        assertEquals(expected, Answer.calculate(values, period));\n    }\n\n    @Test\n    public void testCalculateWithInsufficientValues() {\n        List<Integer> values = Arrays.asList(1, 2);\n        int period = 3;\n        assertTrue(Double.isNaN(Answer.calculate(values, period))); // Expecting NaN\n    }\n\n    @Test\n    public void testCalculateWithEmptyList() {\n        List<Integer> values = Arrays.asList();\n        int period = 1;\n        assertTrue(Double.isNaN(Answer.calculate(values, period))); // Expecting NaN\n    }\n\n    @Test\n    public void testCalculateWithNegativePeriod() {\n        List<Integer> values = Arrays.asList(1, 2, 3, 4, 5);\n        int period = -1;\n        assertTrue(Double.isNaN(Answer.calculate(values, period))); // Expecting NaN\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the average of the last 'period' integers in the given list of values.\n *\n * @param values The list of integers from which to calculate the average.\n * @param period The number of last elements to include in the average calculation.\n * @return The average of the last 'period' integers, or Double.NaN if the input list\n *         does not contain enough elements or if the period is invalid (<= 0).\n */\npublic static double calculate(List<Integer> values, int period) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 616, "code_type": "method", "original_language": "java", "question_type": "Data processing and transformation", "summary": "Converts a size in bytes to a human-readable string representation.", "language_version_list": {"python": {"code_signature": "def byte_count_to_display_size(size_in_bytes: int) -> str:\n    \"\"\"Converts a size in bytes to a human-readable string representation.\n\n    Args:\n        size_in_bytes (int): The size in bytes to convert.\n\n    Returns:\n        str: A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestByteCountToDisplaySizeByteCountToDisplaySize(unittest.TestCase):\n\n    def test_zero_bytes(self):\n        \"\"\"Test case for 0 bytes.\"\"\"\n        input_size = 0\n        expected = \"0 bytes\"\n        self.assertEqual(byte_count_to_display_size(input_size), expected)\n\n    def test_bytes_less_than_kb(self):\n        \"\"\"Test case for bytes less than 1KB.\"\"\"\n        input_size = 500\n        expected = \"500 bytes\"\n        self.assertEqual(byte_count_to_display_size(input_size), expected)\n\n    def test_exactly_one_kb(self):\n        \"\"\"Test case for exactly 1KB.\"\"\"\n        input_size = 1024\n        result = byte_count_to_display_size(input_size)\n        self.assertTrue(result == \"1 KB\" or result == \"1.00 KB\")\n\n    def test_between_kb_and_mb(self):\n        \"\"\"Test case for a size between 1KB and 1MB.\"\"\"\n        input_size = 5000\n        expected = \"4.88 KB\"\n        self.assertEqual(byte_count_to_display_size(input_size), expected)\n\n    def test_exactly_one_mb(self):\n        \"\"\"Test case for exactly 1MB.\"\"\"\n        input_size = 1048576  # 1024 * 1024\n        result = byte_count_to_display_size(input_size)\n        self.assertTrue(result == \"1 MB\" or result == \"1.00 MB\")\n", "prompt": "please write a python function , the function signature as below def byte_count_to_display_size(size_in_bytes: int) -> str:\n    \"\"\"Converts a size in bytes to a human-readable string representation.\n\n    Args:\n        size_in_bytes (int): The size in bytes to convert.\n\n    Returns:\n        str: A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a size in bytes to a human-readable string representation.\n *\n * @param {number} sizeInBytes - The size in bytes to convert.\n * @returns {string} A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n */\nfunction byteCountToDisplaySize(sizeInBytes) {}", "test_code": "describe('byteCountToDisplaySize', () => {\n    test('should return \"0 bytes\" for 0 bytes', () => {\n        const inputSize = 0;\n        const expected = \"0 bytes\";\n        expect(byteCountToDisplaySize(inputSize)).toBe(expected);\n    });\n\n    test('should return \"500 bytes\" for 500 bytes', () => {\n        const inputSize = 500;\n        const expected = \"500 bytes\";\n        expect(byteCountToDisplaySize(inputSize)).toBe(expected);\n    });\n\n    test('should return \"1 KB\" or \"1.00 KB\" for exactly 1 KB', () => {\n        const inputSize = 1024;\n        const result = byteCountToDisplaySize(inputSize);\n        expect(result).toMatch(/1 KB|1\\.00 KB/);\n    });\n\n    test('should return \"4.88 KB\" for a size between 1 KB and 1 MB', () => {\n        const inputSize = 5000;\n        const expected = \"4.88 KB\";\n        expect(byteCountToDisplaySize(inputSize)).toBe(expected);\n    });\n\n    test('should return \"1 MB\" or \"1.00 MB\" for exactly 1 MB', () => {\n        const inputSize = 1048576; // 1024 * 1024\n        const result = byteCountToDisplaySize(inputSize);\n        expect(result).toMatch(/1 MB|1\\.00 MB/);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a size in bytes to a human-readable string representation.\n *\n * @param {number} sizeInBytes - The size in bytes to convert.\n * @returns {string} A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n */\nfunction byteCountToDisplaySize(sizeInBytes) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a size in bytes to a human-readable string representation.\n *\n * @param sizeInBytes - The size in bytes to convert.\n * @returns A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n */\nfunction byteCountToDisplaySize(sizeInBytes: number): string {}", "test_code": "describe('byteCountToDisplaySize', () => {\n    test('should return \"0 bytes\" for 0 bytes', () => {\n        const inputSize = 0;\n        const expected = \"0 bytes\";\n        expect(byteCountToDisplaySize(inputSize)).toBe(expected);\n    });\n\n    test('should return \"500 bytes\" for 500 bytes', () => {\n        const inputSize = 500;\n        const expected = \"500 bytes\";\n        expect(byteCountToDisplaySize(inputSize)).toBe(expected);\n    });\n\n    test('should return \"1 KB\" or \"1.00 KB\" for exactly 1 KB', () => {\n        const inputSize = 1024;\n        const result = byteCountToDisplaySize(inputSize);\n        expect(result).toMatch(/1 KB|1\\.00 KB/);\n    });\n\n    test('should return \"4.88 KB\" for a size between 1 KB and 1 MB', () => {\n        const inputSize = 5000;\n        const expected = \"4.88 KB\";\n        expect(byteCountToDisplaySize(inputSize)).toBe(expected);\n    });\n\n    test('should return \"1 MB\" or \"1.00 MB\" for exactly 1 MB', () => {\n        const inputSize = 1048576; // 1024 * 1024\n        const result = byteCountToDisplaySize(inputSize);\n        expect(result).toMatch(/1 MB|1\\.00 MB/);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a size in bytes to a human-readable string representation.\n *\n * @param sizeInBytes - The size in bytes to convert.\n * @returns A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n */\nfunction byteCountToDisplaySize(sizeInBytes: number): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a size in bytes to a human-readable string representation.\n *\n * @param size_in_bytes The size in bytes to convert.\n * @return A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n */\nstd::string byte_count_to_display_size(int size_in_bytes);", "test_code": "", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a size in bytes to a human-readable string representation.\n *\n * @param size_in_bytes The size in bytes to convert.\n * @return A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n */\nstd::string byte_count_to_display_size(int size_in_bytes);", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a size in bytes to a human-readable string representation.\n *\n * @param sizeInBytes The size in bytes to convert.\n * @return A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n */\npublic static String byteCountToDisplaySize(final long sizeInBytes) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Objects;\n\nimport static junit.framework.TestCase.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class Tester {\n\n    /**\n     * Test the byteCountToDisplaySize function with various inputs.\n     */\n\n    @Test\n    public void testZeroBytes() {\n        // Test case for 0 bytes\n        long input = 0L;\n        String expected = \"0 bytes\";\n        assertEquals(expected, Answer.byteCountToDisplaySize(input));\n    }\n\n    @Test\n    public void testBytesLessThanKB() {\n        // Test case for bytes less than 1KB\n        long input = 500L;\n        String expected = \"500 bytes\";\n        assertEquals(expected, Answer.byteCountToDisplaySize(input));\n    }\n\n    @Test\n    public void testExactlyOneKB() {\n        // Test case for exactly 1KB\n        long input = 1024L;\n        assertTrue(Objects.equals(Answer.byteCountToDisplaySize(input), \"1 KB\") || Objects.equals(Answer.byteCountToDisplaySize(input), \"1.00 KB\"));\n    }\n\n    @Test\n    public void testBetweenKBAndMB() {\n        // Test case for a size between 1KB and 1MB\n        long input = 5000L;\n        String expected = \"4.88 KB\";\n        assertEquals(expected, Answer.byteCountToDisplaySize(input));\n    }\n\n    @Test\n    public void testExactlyOneMB() {\n        // Test case for exactly 1MB\n        long input = 1048576L; // 1024 * 1024\n        assertTrue(Objects.equals(Answer.byteCountToDisplaySize(input), \"1 MB\") || Objects.equals(Answer.byteCountToDisplaySize(input), \"1.00 MB\"));\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a size in bytes to a human-readable string representation.\n *\n * @param sizeInBytes The size in bytes to convert.\n * @return A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n */\npublic static String byteCountToDisplaySize(final long sizeInBytes) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 617, "code_type": "method", "original_language": "java", "question_type": "Data processing and transformation", "summary": "Parse the JSON file and store the parsed content using MAP\n", "language_version_list": {"python": {"code_signature": "from typing import Dict, Any\n\n\ndef parse_json_file(file_path: str) -> Dict[str, Any]:\n    \"\"\"\n    Parses a JSON file and stores its contents in a dictionary.\n\n    Args:\n        file_path (str): The path to the JSON file to be parsed. The file must exist and contain valid JSON.\n                      The path should be a fully qualified path or relative to the current working directory.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing the key-value pairs parsed from the JSON file.\n    \"\"\"", "test_code": "import json\nimport os\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_valid_json(self):\n        json_content = '{\"name\": \"John\", \"age\": 30}'\n        path = 'temp_valid.json'\n\n        with open(path, 'w') as temp_file:\n            temp_file.write(json_content)\n\n        result = parse_json_file(path)\n        self.assertEqual(\"John\", result.get(\"name\"))\n        self.assertEqual(30, result.get(\"age\"))\n\n        os.remove(path)  # Clean up the temporary file\n\n    def test_empty_json(self):\n        json_content = '{}'\n        path = 'temp_empty.json'\n\n        with open(path, 'w') as temp_file:\n            temp_file.write(json_content)\n\n        result = parse_json_file(path)\n        self.assertTrue(len(result) == 0)\n\n        os.remove(path)  # Clean up the temporary file\n\n    def test_null_input(self):\n        with self.assertRaises(Exception):\n            parse_json_file(None)\n\n    def test_non_json_file(self):\n        not_json_content = \"Hello, World!\"\n        path = 'temp_not_json.txt'\n\n        with open(path, 'w') as temp_file:\n            temp_file.write(not_json_content)\n\n        with self.assertRaises(json.JSONDecodeError):\n            parse_json_file(path)\n\n        os.remove(path)  # Clean up the temporary file\n\n    def test_json_with_array(self):\n        json_content = '{\"names\": [\"John\", \"Doe\"]}'\n        path = 'temp_array.json'\n\n        with open(path, 'w') as temp_file:\n            temp_file.write(json_content)\n\n        result = parse_json_file(path)\n        self.assertIsNotNone(result.get(\"names\"))\n\n        os.remove(path)  # Clean up the temporary file", "prompt": "please write a python function , the function signature as below from typing import Dict, Any\n\n\ndef parse_json_file(file_path: str) -> Dict[str, Any]:\n    \"\"\"\n    Parses a JSON file and stores its contents in a dictionary.\n\n    Args:\n        file_path (str): The path to the JSON file to be parsed. The file must exist and contain valid JSON.\n                      The path should be a fully qualified path or relative to the current working directory.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing the key-value pairs parsed from the JSON file.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Parses a JSON file and stores its contents in a dictionary.\n *\n * @param file_path The path to the JSON file to be parsed.\n *                  Must be a valid file path leading to an existing JSON file.\n * @type file_path std::string\n *\n * @return A dictionary containing the key-value pairs parsed from the JSON file.\n * @rtype std::unordered_map<std::string, Any>\n */\n\nstd::unordered_map<std::string, Any> parse_json_file(const std::string& file_path){}", "test_code": "TEST_CASE(\"Tester\", \"[json]\") {\n    std::string path;\n\n    SECTION(\"valid JSON\") {\n        std::string json_content = R\"({\"name\": \"John\", \"age\": 30})\";\n        path = \"temp_valid.json\";\n\n        std::ofstream temp_file(path);\n        temp_file << json_content;\n        temp_file.close();\n\n        auto result = parse_json_file(path);\n        REQUIRE(result.at(\"name\") == \"John\");\n        REQUIRE(result.at(\"age\") == 30);\n\n        std::remove(path.c_str()); // Clean up the temporary file\n    }\n\n    SECTION(\"empty JSON\") {\n        std::string json_content = R\"({})\";\n        path = \"temp_empty.json\";\n\n        std::ofstream temp_file(path);\n        temp_file << json_content;\n        temp_file.close();\n\n        auto result = parse_json_file(path);\n        REQUIRE(result.empty());\n\n        std::remove(path.c_str()); // Clean up the temporary file\n    }\n\n    SECTION(\"null input\") {\n        REQUIRE_THROWS_AS(parse_json_file(nullptr), std::invalid_argument);\n    }\n\n    SECTION(\"non-JSON file\") {\n        std::string not_json_content = \"Hello, World!\";\n        path = \"temp_not_json.txt\";\n\n        std::ofstream temp_file(path);\n        temp_file << not_json_content;\n        temp_file.close();\n\n        REQUIRE_THROWS_AS(parse_json_file(path), std::runtime_error);\n\n        std::remove(path.c_str()); // Clean up the temporary file\n    }\n\n    SECTION(\"JSON with array\") {\n        std::string json_content = R\"({\"names\": [\"John\", \"Doe\"]})\";\n        path = \"temp_array.json\";\n\n        std::ofstream temp_file(path);\n        temp_file << json_content;\n        temp_file.close();\n\n        auto result = parse_json_file(path);\n        REQUIRE(result.find(\"names\") != result.end());\n\n        std::remove(path.c_str()); // Clean up the temporary file\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Parses a JSON file and stores its contents in a dictionary.\n *\n * @param file_path The path to the JSON file to be parsed.\n *                  Must be a valid file path leading to an existing JSON file.\n * @type file_path std::string\n *\n * @return A dictionary containing the key-value pairs parsed from the JSON file.\n * @rtype std::unordered_map<std::string, Any>\n */\n\nstd::unordered_map<std::string, Any> parse_json_file(const std::string& file_path){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Parses a JSON file and stores its contents in a Map.\n *\n * @param filePath the path to the JSON file to be parsed. The file must exist and contain valid JSON.\n *                 The path should be a fully qualified path or relative to the current working directory.\n * @return a Map<String, Object> containing the key-value pairs parsed from the JSON file. If the JSON\n *         file is empty or contains only simple key-value pairs without nested structures, the resulting\n *         Map will be correspondingly simple. The function returns an empty Map if the file is empty.\n * @throws FileNotFoundException if the specified file does not exist or cannot be opened. This exception\n *         is caught within the function and logged to the standard output, but it might be more appropriate\n *         in a real-world application to rethrow it or handle it in a way that informs the user more effectively.\n */\npublic static Map<String, Object> parseJsonFile(String filePath) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport org.junit.jupiter.api.Test;\nimport java.util.Map;\n\npublic class Tester {\n\n    @Test\n    public void testValidJson() throws IOException {\n        String jsonContent = \"{\\\"name\\\":\\\"John\\\", \\\"age\\\":30}\";\n        Path path = Files.createTempFile(null, \".json\");\n        Files.write(path, jsonContent.getBytes());\n\n        Map<String, Object> result = Answer.parseJsonFile(path.toString());\n        assertEquals(\"John\", result.get(\"name\"));\n        assertEquals(30, result.get(\"age\"));\n    }\n\n    @Test\n    public void testEmptyJson() throws IOException {\n        String jsonContent = \"{}\";\n        Path path = Files.createTempFile(null, \".json\");\n        Files.write(path, jsonContent.getBytes());\n\n        Map<String, Object> result = Answer.parseJsonFile(path.toString());\n        assertTrue(result.isEmpty());\n    }\n\n\n\n    @Test\n    public void testNullInput() {\n        assertThrows(NullPointerException.class, () -> Answer.parseJsonFile(null));\n    }\n\n    @Test\n    public void testNonJsonFile() throws IOException {\n        String notJsonContent = \"Hello, World!\";\n        Path path = Files.createTempFile(null, \".txt\");\n        Files.write(path, notJsonContent.getBytes());\n\n        assertThrows(Exception.class, () -> Answer.parseJsonFile(path.toString()));\n    }\n\n    @Test\n    public void testJsonWithArray() throws IOException {\n        String jsonContent = \"{\\\"names\\\":[\\\"John\\\", \\\"Doe\\\"]}\";\n        Path path = Files.createTempFile(null, \".json\");\n        Files.write(path, jsonContent.getBytes());\n\n        Map<String, Object> result = Answer.parseJsonFile(path.toString());\n        assertNotNull(result.get(\"names\"));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Parses a JSON file and stores its contents in a Map.\n *\n * @param filePath the path to the JSON file to be parsed. The file must exist and contain valid JSON.\n *                 The path should be a fully qualified path or relative to the current working directory.\n * @return a Map<String, Object> containing the key-value pairs parsed from the JSON file. If the JSON\n *         file is empty or contains only simple key-value pairs without nested structures, the resulting\n *         Map will be correspondingly simple. The function returns an empty Map if the file is empty.\n * @throws FileNotFoundException if the specified file does not exist or cannot be opened. This exception\n *         is caught within the function and logged to the standard output, but it might be more appropriate\n *         in a real-world application to rethrow it or handle it in a way that informs the user more effectively.\n */\npublic static Map<String, Object> parseJsonFile(String filePath) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 618, "code_type": "method", "original_language": "java", "question_type": "Algorithm and data structure", "summary": "Calculate the rotation matrix required to rotate from one three-dimensional vector to another three-dimensional vector using the original vector\n", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 623, "code_type": "method", "original_language": "java", "question_type": "Data processing and transformation", "summary": "Convert a Color object to its corresponding RGB color code string, formatted as a hexadecimal string\n", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a Color object to its corresponding RGB color code string.\n *\n * @param color the Color object to convert\n * @return a hexadecimal string representing the RGB color code\n */\npublic static String toRGBCode(Color color) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\nimport java.awt.Color;\n\npublic class Tester {\n\n    @Test\n    public void testToRGBCode_White() {\n        Color color = new Color(255, 255, 255); // White\n        String expected = \"#FFFFFF\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testToRGBCode_Black() {\n        Color color = new Color(0, 0, 0); // Black\n        String expected = \"#000000\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testToRGBCode_Red() {\n        Color color = new Color(255, 0, 0); // Red\n        String expected = \"#FF0000\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testToRGBCode_Green() {\n        Color color = new Color(0, 255, 0); // Green\n        String expected = \"#00FF00\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testToRGBCode_Blue() {\n        Color color = new Color(0, 0, 255); // Blue\n        String expected = \"#0000FF\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testToRGBCode_CustomColor() {\n        Color color = new Color(255, 87, 51); // Custom Color\n        String expected = \"#FF5733\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a Color object to its corresponding RGB color code string.\n *\n * @param color the Color object to convert\n * @return a hexadecimal string representing the RGB color code\n */\npublic static String toRGBCode(Color color) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 625, "code_type": "method", "original_language": "java", "question_type": "Data processing and transformation", "summary": "Read data from the file at the specified path, determine whether the string or integer or floating point number in each line of the file, and perform type conversion\n", "language_version_list": {"python": {"code_signature": "from typing import List, Union\n\n\ndef read_data_from_file(path: str) -> List[Union[int, float, str]]:\n    \"\"\"\n    Reads data from a specified file and determines the type of each line.\n    This function processes each line of the specified file and attempts to convert it\n    into either an integer, a floating-point number, or a string.\n\n    Args:\n        path (str): The path to the file to be read. The file should exist and be accessible for reading.\n\n    Returns:\n        list: A list containing the converted values of each line in the file. Each element\n              can be an int, float, or str, depending on the content of the line.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        PermissionError: If the program lacks permissions to read the file.\n        IOError: If an I/O error occurs while reading the file.\n    \"\"\"\n", "test_code": "import os\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def create_test_file(self, file_name, content):\n        with open(file_name, 'w') as writer:\n            writer.write(content)\n\n    def test_read_valid_integers(self):\n        file_path = \"valid_integers.txt\"\n        self.create_test_file(file_path, \"42\\n-7\\n0\\n100\\n\")\n        result = read_data_from_file(file_path)\n        self.assertEqual(4, len(result))\n        self.assertEqual(42, result[0])\n        self.assertEqual(-7, result[1])\n        self.assertEqual(0, result[2])\n        self.assertEqual(100, result[3])\n        os.remove(file_path)  # Clean up the test file\n\n    def test_read_valid_floats(self):\n        file_path = \"valid_floats.txt\"\n        self.create_test_file(file_path, \"3.14\\n-0.001\\n2.71828\\n0.0\\n\")\n        result = read_data_from_file(file_path)\n        self.assertEqual(4, len(result))\n        self.assertEqual(3.14, result[0])\n        self.assertEqual(-0.001, result[1])\n        self.assertEqual(2.71828, result[2])\n        self.assertEqual(0.0, result[3])\n        os.remove(file_path)  # Clean up the test file\n\n    def test_read_mixed_data(self):\n        file_path = \"mixed_data.txt\"\n        self.create_test_file(file_path, \"Hello\\n42\\n3.14\\nWorld\\n-19.99\\n\")\n        result = read_data_from_file(file_path)\n        self.assertEqual(5, len(result))\n        self.assertEqual(\"Hello\", result[0])\n        self.assertEqual(42, result[1])\n        self.assertEqual(3.14, result[2])\n        self.assertEqual(\"World\", result[3])\n        self.assertEqual(-19.99, result[4])\n        os.remove(file_path)  # Clean up the test file\n\n    def test_read_empty_file(self):\n        file_path = \"empty_file.txt\"\n        self.create_test_file(file_path, \"\")\n        result = read_data_from_file(file_path)\n        self.assertEqual(0, len(result))\n        os.remove(file_path)  # Clean up the test file\n\n    def test_read_invalid_data(self):\n        file_path = \"invalid_data.txt\"\n        self.create_test_file(file_path, \"Hello\\n42a\\n3.14.15\\nWorld!\\n\")\n        result = read_data_from_file(file_path)\n        self.assertEqual(4, len(result))\n        self.assertEqual(\"Hello\", result[0])\n        self.assertEqual(\"42a\", result[1])\n        self.assertEqual(\"3.14.15\", result[2])\n        self.assertEqual(\"World!\", result[3])\n        os.remove(file_path)  # Clean up the test file\n", "prompt": "please write a python function , the function signature as below from typing import List, Union\n\n\ndef read_data_from_file(path: str) -> List[Union[int, float, str]]:\n    \"\"\"\n    Reads data from a specified file and determines the type of each line.\n    This function processes each line of the specified file and attempts to convert it\n    into either an integer, a floating-point number, or a string.\n\n    Args:\n        path (str): The path to the file to be read. The file should exist and be accessible for reading.\n\n    Returns:\n        list: A list containing the converted values of each line in the file. Each element\n              can be an int, float, or str, depending on the content of the line.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        PermissionError: If the program lacks permissions to read the file.\n        IOError: If an I/O error occurs while reading the file.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Reads data from a specified file and determines the type of each line.\n * This function processes each line of the specified file and attempts to convert it\n * into either an integer, a floating-point number, or a string.\n *\n * @param {string} path - The path to the file to be read. The file should exist and be accessible for reading.\n * @returns {Array<number|string>} - A list containing the converted values of each line in the file. Each element\n *                                    can be a number (int or float) or a string, depending on the content of the line.\n * @throws {Error} If an error occurs while reading the file.\n */\nfunction readDataFromFile(path) {}", "test_code": "import path from 'path';\n\ndescribe('Tester', () => {\n    // Helper function to create a test file\n    const createTestFile = (fileName, content) => {\n        fs.writeFileSync(fileName, content);\n    };\n\n    afterEach(() => {\n        // Cleanup: Remove any test files created during tests\n        const testFiles = [\n            \"valid_integers.txt\",\n            \"valid_floats.txt\",\n            \"mixed_data.txt\",\n            \"empty_file.txt\",\n            \"invalid_data.txt\"\n        ];\n        testFiles.forEach(file => {\n            if (fs.existsSync(file)) {\n                fs.unlinkSync(file);\n            }\n        });\n    });\n\n    test('read valid integers', () => {\n        const filePath = \"valid_integers.txt\";\n        createTestFile(filePath, \"42\\n-7\\n0\\n100\\n\");\n        const result = readDataFromFile(filePath);\n        expect(result.length).toBe(4);\n        expect(result[0]).toBe(42);\n        expect(result[1]).toBe(-7);\n        expect(result[2]).toBe(0);\n        expect(result[3]).toBe(100);\n    });\n\n    test('read valid floats', () => {\n        const filePath = \"valid_floats.txt\";\n        createTestFile(filePath, \"3.14\\n-0.001\\n2.71828\\n0.0\\n\");\n        const result = readDataFromFile(filePath);\n        expect(result.length).toBe(4);\n        expect(result[0]).toBe(3.14);\n        expect(result[1]).toBe(-0.001);\n        expect(result[2]).toBe(2.71828);\n        expect(result[3]).toBe(0.0);\n    });\n\n    test('read mixed data', () => {\n        const filePath = \"mixed_data.txt\";\n        createTestFile(filePath, \"Hello\\n42\\n3.14\\nWorld\\n-19.99\\n\");\n        const result = readDataFromFile(filePath);\n        expect(result.length).toBe(5);\n        expect(result[0]).toBe(\"Hello\");\n        expect(result[1]).toBe(42);\n        expect(result[2]).toBe(3.14);\n        expect(result[3]).toBe(\"World\");\n        expect(result[4]).toBe(-19.99);\n    });\n\n    test('read empty file', () => {\n        const filePath = \"empty_file.txt\";\n        createTestFile(filePath, \"\");\n        const result = readDataFromFile(filePath);\n        expect(result.length).toBe(0);\n    });\n\n    test('read invalid data', () => {\n        const filePath = \"invalid_data.txt\";\n        createTestFile(filePath, \"Hello\\n42a\\n3.14.15\\nWorld!\\n\");\n        const result = readDataFromFile(filePath);\n        expect(result.length).toBe(4);\n        expect(result[0]).toBe(\"Hello\");\n        expect(result[1]).toBe(\"42a\");\n        expect(result[2]).toBe(\"3.14.15\");\n        expect(result[3]).toBe(\"World!\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Reads data from a specified file and determines the type of each line.\n * This function processes each line of the specified file and attempts to convert it\n * into either an integer, a floating-point number, or a string.\n *\n * @param {string} path - The path to the file to be read. The file should exist and be accessible for reading.\n * @returns {Array<number|string>} - A list containing the converted values of each line in the file. Each element\n *                                    can be a number (int or float) or a string, depending on the content of the line.\n * @throws {Error} If an error occurs while reading the file.\n */\nfunction readDataFromFile(path) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Reads data from a specified file and determines the type of each line.\n * This function processes each line of the specified file and attempts to convert it\n * into either an integer, a floating-point number, or a string.\n *\n * @param {string} path - The path to the file to be read. The file should exist and be accessible for reading.\n * @returns {(number | string)[]} - A list containing the converted values of each line in the file. Each element\n *                                  can be an int, float, or string, depending on the content of the line.\n * @throws {Error} - If the specified file does not exist, if permissions are lacking, or if an I/O error occurs while reading the file.\n */\nfunction readDataFromFile(path: string): (number | string)[] {}", "test_code": "import * as fs from 'fs';\n\ndescribe('Tester', () => {\n    const createTestFile = (fileName: string, content: string): void => {\n        fs.writeFileSync(fileName, content);\n    };\n\n    afterEach(() => {\n        // Cleanup: Remove test files after each test\n        const testFiles = ['valid_integers.txt', 'valid_floats.txt', 'mixed_data.txt', 'empty_file.txt', 'invalid_data.txt'];\n        testFiles.forEach(file => {\n            if (fs.existsSync(file)) {\n                fs.unlinkSync(file);\n            }\n        });\n    });\n\n    test('read valid integers', () => {\n        const filePath = 'valid_integers.txt';\n        createTestFile(filePath, '42\\n-7\\n0\\n100\\n');\n        const result = readDataFromFile(filePath);\n        expect(result.length).toBe(4);\n        expect(result[0]).toBe(42);\n        expect(result[1]).toBe(-7);\n        expect(result[2]).toBe(0);\n        expect(result[3]).toBe(100);\n    });\n\n    test('read valid floats', () => {\n        const filePath = 'valid_floats.txt';\n        createTestFile(filePath, '3.14\\n-0.001\\n2.71828\\n0.0\\n');\n        const result = readDataFromFile(filePath);\n        expect(result.length).toBe(4);\n        expect(result[0]).toBe(3.14);\n        expect(result[1]).toBe(-0.001);\n        expect(result[2]).toBe(2.71828);\n        expect(result[3]).toBe(0.0);\n    });\n\n    test('read mixed data', () => {\n        const filePath = 'mixed_data.txt';\n        createTestFile(filePath, 'Hello\\n42\\n3.14\\nWorld\\n-19.99\\n');\n        const result = readDataFromFile(filePath);\n        expect(result.length).toBe(5);\n        expect(result[0]).toBe('Hello');\n        expect(result[1]).toBe(42);\n        expect(result[2]).toBe(3.14);\n        expect(result[3]).toBe('World');\n        expect(result[4]).toBe(-19.99);\n    });\n\n    test('read empty file', () => {\n        const filePath = 'empty_file.txt';\n        createTestFile(filePath, '');\n        const result = readDataFromFile(filePath);\n        expect(result.length).toBe(0);\n    });\n\n    test('read invalid data', () => {\n        const filePath = 'invalid_data.txt';\n        createTestFile(filePath, 'Hello\\n42a\\n3.14.15\\nWorld!\\n');\n        const result = readDataFromFile(filePath);\n        expect(result.length).toBe(4);\n        expect(result[0]).toBe('Hello');\n        expect(result[1]).toBe('42a');\n        expect(result[2]).toBe('3.14.15');\n        expect(result[3]).toBe('World!');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Reads data from a specified file and determines the type of each line.\n * This function processes each line of the specified file and attempts to convert it\n * into either an integer, a floating-point number, or a string.\n *\n * @param {string} path - The path to the file to be read. The file should exist and be accessible for reading.\n * @returns {(number | string)[]} - A list containing the converted values of each line in the file. Each element\n *                                  can be an int, float, or string, depending on the content of the line.\n * @throws {Error} - If the specified file does not exist, if permissions are lacking, or if an I/O error occurs while reading the file.\n */\nfunction readDataFromFile(path: string): (number | string)[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads data from a specified file and determines the type of each line.\n *\n * @param path The path to the file to be read. The file should exist and be \n *             accessible for reading.\n * @type path const std::string&\n *\n * @return A vector containing the converted values of each line in the file. Each \n *         element can be an `int`, `float`, or `std::string`, depending on the content \n *         of the line.\n * @rtype std::vector<std::variant<int, float, std::string>>\n *\n * @throws std::runtime_error If the specified file does not exist or if there \n *         is an error reading the file.\n */\n\nstd::vector<std::variant<int, float, std::string>> read_data_from_file(const std::string& path);", "test_code": "void create_test_file(const std::string& file_name, const std::string& content) {\n    std::ofstream writer(file_name);\n    writer << content;\n    writer.close();\n}\n\nTEST_CASE(\"Read valid integers\") {\n    std::string file_path = \"valid_integers.txt\";\n    create_test_file(file_path, \"42\\n-7\\n0\\n100\\n\");\n    auto result = read_data_from_file(file_path);\n    \n    REQUIRE(result.size() == 4);\n    REQUIRE(std::get<int>(result[0]) == 42);\n    REQUIRE(std::get<int>(result[1]) == -7);\n    REQUIRE(std::get<int>(result[2]) == 0);\n    REQUIRE(std::get<int>(result[3]) == 100);\n\n    std::remove(file_path.c_str()); // Clean up the test file\n}\n\nTEST_CASE(\"Read valid floats\") {\n    std::string file_path = \"valid_floats.txt\";\n    create_test_file(file_path, \"3.14\\n-0.001\\n2.71828\\n0.0\\n\");\n    auto result = read_data_from_file(file_path);\n    \n    REQUIRE(result.size() == 4);\n    REQUIRE(std::get<float>(result[0]) == Approx(3.14f));\n    REQUIRE(std::get<float>(result[1]) == Approx(-0.001f));\n    REQUIRE(std::get<float>(result[2]) == Approx(2.71828f));\n    REQUIRE(std::get<float>(result[3]) == Approx(0.0f));\n\n    std::remove(file_path.c_str()); // Clean up the test file\n}\n\nTEST_CASE(\"Read mixed data\") {\n    std::string file_path = \"mixed_data.txt\";\n    create_test_file(file_path, \"Hello\\n42\\n3.14\\nWorld\\n-19.99\\n\");\n    auto result = read_data_from_file(file_path);\n    \n    REQUIRE(result.size() == 5);\n    REQUIRE(std::get<std::string>(result[0]) == \"Hello\");\n    REQUIRE(std::get<int>(result[1]) == 42);\n    REQUIRE(std::get<float>(result[2]) == Approx(3.14f));\n    REQUIRE(std::get<std::string>(result[3]) == \"World\");\n    REQUIRE(std::get<float>(result[4]) == Approx(-19.99f));\n\n    std::remove(file_path.c_str()); // Clean up the test file\n}\n\nTEST_CASE(\"Read empty file\") {\n    std::string file_path = \"empty_file.txt\";\n    create_test_file(file_path, \"\");\n    auto result = read_data_from_file(file_path);\n    \n    REQUIRE(result.size() == 0);\n\n    std::remove(file_path.c_str()); // Clean up the test file\n}\n\nTEST_CASE(\"Read invalid data\") {\n    std::string file_path = \"invalid_data.txt\";\n    create_test_file(file_path, \"Hello\\n42a\\n3.14.15\\nWorld!\\n\");\n    auto result = read_data_from_file(file_path);\n    \n    REQUIRE(result.size() == 4);\n    REQUIRE(std::get<std::string>(result[0]) == \"Hello\");\n    REQUIRE(std::get<std::string>(result[1]) == \"42a\");\n    REQUIRE(std::get<std::string>(result[2]) == \"3.14.15\");\n    REQUIRE(std::get<std::string>(result[3]) == \"World!\");\n\n    std::remove(file_path.c_str()); // Clean up the test file\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads data from a specified file and determines the type of each line.\n *\n * @param path The path to the file to be read. The file should exist and be \n *             accessible for reading.\n * @type path const std::string&\n *\n * @return A vector containing the converted values of each line in the file. Each \n *         element can be an `int`, `float`, or `std::string`, depending on the content \n *         of the line.\n * @rtype std::vector<std::variant<int, float, std::string>>\n *\n * @throws std::runtime_error If the specified file does not exist or if there \n *         is an error reading the file.\n */\n\nstd::vector<std::variant<int, float, std::string>> read_data_from_file(const std::string& path);", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads data from a specified file and determines the type of each line.\n * The method processes each line of the file and attempts to convert it\n * into either an integer, a floating-point number, or a string.\n *\n * @param path the path to the file to be read. The file should exist and be accessible for reading.\n *\n * @return a list of Objects where each object can be an Integer, Float, or String,\n *         representing the converted values of each line in the file.\n *\n * @throws IllegalArgumentException if an I/O error occurs while reading the file.\n *         This may happen if the file does not exist, or if the program lacks\n *         permissions to read the file.\n */\npublic List<Object> readDataFromFile(String path) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Tester {\n\n    private void createTestFile(String fileName, String content) throws IOException {\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(fileName))) {\n            writer.write(content);\n        }\n    }\n\n    @Test\n    void testReadValidIntegers() throws IOException {\n        String filePath = \"valid_integers.txt\";\n        createTestFile(filePath, \"42\\n-7\\n0\\n100\\n\");\n\n        Answer answer = new Answer();\n        List<Object> result = answer.readDataFromFile(filePath);\n\n        assertEquals(4, result.size());\n        assertEquals(42, result.get(0));\n        assertEquals(-7, result.get(1));\n        assertEquals(0, result.get(2));\n        assertEquals(100, result.get(3));\n    }\n\n    @Test\n    void testReadValidFloats() throws IOException {\n        String filePath = \"valid_floats.txt\";\n        createTestFile(filePath, \"3.14\\n-0.001\\n2.71828\\n0.0\\n\");\n\n        Answer answer = new Answer();\n        List<Object> result = answer.readDataFromFile(filePath);\n\n        assertEquals(4, result.size());\n        assertEquals(3.14f, result.get(0));\n        assertEquals(-0.001f, result.get(1));\n        assertEquals(2.71828f, result.get(2));\n        assertEquals(0.0f, result.get(3));\n    }\n\n    @Test\n    void testReadMixedData() throws IOException {\n        String filePath = \"mixed_data.txt\";\n        createTestFile(filePath, \"Hello\\n42\\n3.14\\nWorld\\n-19.99\\n\");\n\n        Answer answer = new Answer();\n        List<Object> result = answer.readDataFromFile(filePath);\n\n        assertEquals(5, result.size());\n        assertEquals(\"Hello\", result.get(0));\n        assertEquals(42, result.get(1));\n        assertEquals(3.14f, result.get(2));\n        assertEquals(\"World\", result.get(3));\n        assertEquals(-19.99f, result.get(4));\n    }\n\n    @Test\n    void testReadEmptyFile() throws IOException {\n        String filePath = \"empty_file.txt\";\n        createTestFile(filePath, \"\");\n\n        Answer answer = new Answer();\n        List<Object> result = answer.readDataFromFile(filePath);\n\n        assertEquals(0, result.size());\n    }\n\n    @Test\n    void testReadInvalidData() throws IOException {\n        String filePath = \"invalid_data.txt\";\n        createTestFile(filePath, \"Hello\\n42a\\n3.14.15\\nWorld!\\n\");\n\n        Answer answer = new Answer();\n        List<Object> result = answer.readDataFromFile(filePath);\n\n        assertEquals(4, result.size());\n        assertEquals(\"Hello\", result.get(0));\n        assertEquals(\"42a\", result.get(1));\n        assertEquals(\"3.14.15\", result.get(2));\n        assertEquals(\"World!\", result.get(3));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Reads data from a specified file and determines the type of each line.\n * The method processes each line of the file and attempts to convert it\n * into either an integer, a floating-point number, or a string.\n *\n * @param path the path to the file to be read. The file should exist and be accessible for reading.\n *\n * @return a list of Objects where each object can be an Integer, Float, or String,\n *         representing the converted values of each line in the file.\n *\n * @throws IllegalArgumentException if an I/O error occurs while reading the file.\n *         This may happen if the file does not exist, or if the program lacks\n *         permissions to read the file.\n */\npublic List<Object> readDataFromFile(String path) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 626, "code_type": "method", "original_language": "java", "question_type": "Data processing and transformation", "summary": "Read the file under the specified path, process each line of the file, remove in-line comments (parts starting with #), remove line breaks, and return a list of the processed line contents.\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef read_file_and_process_lines(path: str) -> List[str]:\n    \"\"\"\n    Reads a file from the specified path, processes each line to remove inline comments,\n    removes line breaks, and returns a list of the processed line contents.\n\n    Args:\n        path (str): The path to the file to be read.The path to the file to be read.\n\n    Returns:\n        List[str]: A list of strings, each representing a processed line from the file.\n    \"\"\"\n", "test_code": "import os\nimport unittest\n\n\nclass TestAnswer(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Create a temporary file for testing.\"\"\"\n        self.test_file_path = \"testFile.txt\"\n        open(self.test_file_path, 'w').close()  # Create an empty file\n\n    def write_to_file(self, content):\n        \"\"\"Helper method to write to the test file.\"\"\"\n        with open(self.test_file_path, 'w') as writer:\n            writer.write(content)\n\n    def test_normal_input(self):\n        \"\"\"Test processing of normal input.\"\"\"\n        self.write_to_file(\"Line 1\\nLine 2 # Comment\\nLine 3\\n\")\n        result = read_file_and_process_lines(self.test_file_path)\n        self.assertEqual(result, [\"Line 1\", \"Line 2\", \"Line 3\"])\n\n    def test_only_comments(self):\n        \"\"\"Test processing when only comments are present.\"\"\"\n        self.write_to_file(\"# This is a comment\\n# Another comment\\n\")\n        result = read_file_and_process_lines(self.test_file_path)\n        self.assertEqual(result, [])\n\n    def test_empty_lines(self):\n        \"\"\"Test processing with empty lines.\"\"\"\n        self.write_to_file(\"Line 1\\n\\nLine 2\\n\\n\\nLine 3 # Comment\\n\")\n        result = read_file_and_process_lines(self.test_file_path)\n        self.assertEqual(result, [\"Line 1\", \"Line 2\", \"Line 3\"])\n\n    def test_no_inline_comments(self):\n        \"\"\"Test processing when there are no inline comments.\"\"\"\n        self.write_to_file(\"Line 1\\nLine 2\\nLine 3\\n\")\n        result = read_file_and_process_lines(self.test_file_path)\n        self.assertEqual(result, [\"Line 1\", \"Line 2\", \"Line 3\"])\n\n    def test_only_new_lines(self):\n        \"\"\"Test processing with only new lines.\"\"\"\n        self.write_to_file(\"\\n\\n\\n\\n\")\n        result = read_file_and_process_lines(self.test_file_path)\n        self.assertEqual(result, [])\n\n    def test_mixed_content(self):\n        \"\"\"Test processing with mixed content.\"\"\"\n        self.write_to_file(\"Valid line\\n# This is a comment\\nLine 2\\n# Another comment\\n\\nLine 3 # End of line comment\\n\")\n        result = read_file_and_process_lines(self.test_file_path)\n        self.assertEqual(result, [\"Valid line\", \"Line 2\", \"Line 3\"])\n\n    def tearDown(self):\n        \"\"\"Cleanup after tests.\"\"\"\n        try:\n            os.remove(self.test_file_path)\n        except OSError:\n            pass  # Ignore if the file doesn't exist", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef read_file_and_process_lines(path: str) -> List[str]:\n    \"\"\"\n    Reads a file from the specified path, processes each line to remove inline comments,\n    removes line breaks, and returns a list of the processed line contents.\n\n    Args:\n        path (str): The path to the file to be read.The path to the file to be read.\n\n    Returns:\n        List[str]: A list of strings, each representing a processed line from the file.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Reads a file from the specified path, processes each line to remove inline comments,\n * removes line breaks, and returns an array of the processed line contents.\n *\n * @param {string} path - The path to the file to be read.\n * @returns {string[]} An array of strings, each representing a processed line from the file.\n */\nfunction readFileAndProcessLines(path) {}", "test_code": "const fs = require('fs');\n\ndescribe('TestAnswer', () => {\n    const testFilePath = 'testFile.txt';\n\n    beforeEach(() => {\n        /** \n         * Create a temporary file for testing.\n         * This will create an empty file at the start of each test.\n         */\n        fs.writeFileSync(testFilePath, '');\n    });\n\n    function writeToFile(content) {\n        /**\n         * Helper method to write to the test file.\n         */\n        fs.writeFileSync(testFilePath, content);\n    }\n\n    test('processing of normal input', () => {\n        /** \n         * Test processing of normal input.\n         */\n        writeToFile(\"Line 1\\nLine 2 # Comment\\nLine 3\\n\");\n        const result = readFileAndProcessLines(testFilePath);\n        expect(result).toEqual([\"Line 1\", \"Line 2\", \"Line 3\"]);\n    });\n\n    test('processing when only comments are present', () => {\n        /** \n         * Test processing when only comments are present.\n         */\n        writeToFile(\"# This is a comment\\n# Another comment\\n\");\n        const result = readFileAndProcessLines(testFilePath);\n        expect(result).toEqual([]);\n    });\n\n    test('processing with empty lines', () => {\n        /** \n         * Test processing with empty lines.\n         */\n        writeToFile(\"Line 1\\n\\nLine 2\\n\\n\\nLine 3 # Comment\\n\");\n        const result = readFileAndProcessLines(testFilePath);\n        expect(result).toEqual([\"Line 1\", \"Line 2\", \"Line 3\"]);\n    });\n\n    test('processing when there are no inline comments', () => {\n        /** \n         * Test processing when there are no inline comments.\n         */\n        writeToFile(\"Line 1\\nLine 2\\nLine 3\\n\");\n        const result = readFileAndProcessLines(testFilePath);\n        expect(result).toEqual([\"Line 1\", \"Line 2\", \"Line 3\"]);\n    });\n\n    test('processing with only new lines', () => {\n        /** \n         * Test processing with only new lines.\n         */\n        writeToFile(\"\\n\\n\\n\\n\");\n        const result = readFileAndProcessLines(testFilePath);\n        expect(result).toEqual([]);\n    });\n\n    test('processing with mixed content', () => {\n        /** \n         * Test processing with mixed content.\n         */\n        writeToFile(\"Valid line\\n# This is a comment\\nLine 2\\n# Another comment\\n\\nLine 3 # End of line comment\\n\");\n        const result = readFileAndProcessLines(testFilePath);\n        expect(result).toEqual([\"Valid line\", \"Line 2\", \"Line 3\"]);\n    });\n\n    afterEach(() => {\n        /** \n         * Cleanup after tests.\n         * This removes the test file created during tests.\n         */\n        try {\n            fs.unlinkSync(testFilePath);\n        } catch (err) {\n            // Ignore if the file doesn't exist\n        }\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Reads a file from the specified path, processes each line to remove inline comments,\n * removes line breaks, and returns an array of the processed line contents.\n *\n * @param {string} path - The path to the file to be read.\n * @returns {string[]} An array of strings, each representing a processed line from the file.\n */\nfunction readFileAndProcessLines(path) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Reads a file from the specified path, processes each line to remove inline comments,\n * removes line breaks, and returns a list of the processed line contents.\n *\n * @param path - The path to the file to be read.\n * @returns A list of strings, each representing a processed line from the file.\n */\nfunction readFileAndProcessLines(path: string): string[] {}", "test_code": "import fs from 'fs';\nimport path from 'path';\n\ndescribe('TestAnswer', () => {\n    const testFilePath = path.join(__dirname, 'testFile.txt');\n\n    beforeEach(() => {\n        /** Create a temporary file for testing. */\n        fs.writeFileSync(testFilePath, '');\n    });\n\n    const writeToFile = (content: string) => {\n        /** Helper method to write to the test file. */\n        fs.writeFileSync(testFilePath, content);\n    };\n\n    afterEach(() => {\n        /** Cleanup after tests. */\n        try {\n            fs.unlinkSync(testFilePath);\n        } catch (error) {\n            // Ignore if the file doesn't exist\n        }\n    });\n\n    test('normal input', () => {\n        /** Test processing of normal input. */\n        writeToFile(\"Line 1\\nLine 2 # Comment\\nLine 3\\n\");\n        const result = readFileAndProcessLines(testFilePath);\n        expect(result).toEqual([\"Line 1\", \"Line 2\", \"Line 3\"]);\n    });\n\n    test('only comments', () => {\n        /** Test processing when only comments are present. */\n        writeToFile(\"# This is a comment\\n# Another comment\\n\");\n        const result = readFileAndProcessLines(testFilePath);\n        expect(result).toEqual([]);\n    });\n\n    test('empty lines', () => {\n        /** Test processing with empty lines. */\n        writeToFile(\"Line 1\\n\\nLine 2\\n\\n\\nLine 3 # Comment\\n\");\n        const result = readFileAndProcessLines(testFilePath);\n        expect(result).toEqual([\"Line 1\", \"Line 2\", \"Line 3\"]);\n    });\n\n    test('no inline comments', () => {\n        /** Test processing when there are no inline comments. */\n        writeToFile(\"Line 1\\nLine 2\\nLine 3\\n\");\n        const result = readFileAndProcessLines(testFilePath);\n        expect(result).toEqual([\"Line 1\", \"Line 2\", \"Line 3\"]);\n    });\n\n    test('only new lines', () => {\n        /** Test processing with only new lines. */\n        writeToFile(\"\\n\\n\\n\\n\");\n        const result = readFileAndProcessLines(testFilePath);\n        expect(result).toEqual([]);\n    });\n\n    test('mixed content', () => {\n        /** Test processing with mixed content. */\n        writeToFile(\"Valid line\\n# This is a comment\\nLine 2\\n# Another comment\\n\\nLine 3 # End of line comment\\n\");\n        const result = readFileAndProcessLines(testFilePath);\n        expect(result).toEqual([\"Valid line\", \"Line 2\", \"Line 3\"]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Reads a file from the specified path, processes each line to remove inline comments,\n * removes line breaks, and returns a list of the processed line contents.\n *\n * @param path - The path to the file to be read.\n * @returns A list of strings, each representing a processed line from the file.\n */\nfunction readFileAndProcessLines(path: string): string[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "\n/**\n * @brief Reads a file from the specified path, processes each line to remove inline comments,\n * removes line breaks, and returns a list of the processed line contents.\n *\n * @param path The path to the file to be read.\n * @return std::vector<std::string> A vector of strings, each representing a processed line from the file.\n */\nstd::vector<std::string> read_file_and_process_lines(const std::string& path);", "test_code": "TEST_CASE_METHOD(TestAnswer, \"Test processing of normal input\") {\n    write_to_file(\"Line 1\\nLine 2 # Comment\\nLine 3\\n\");\n    auto result = read_file_and_process_lines(test_file_path);\n    REQUIRE(result == std::vector<std::string>{\"Line 1\", \"Line 2\", \"Line 3\"});\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test processing when only comments are present\") {\n    write_to_file(\"# This is a comment\\n# Another comment\\n\");\n    auto result = read_file_and_process_lines(test_file_path);\n    REQUIRE(result.empty());\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test processing with empty lines\") {\n    write_to_file(\"Line 1\\n\\nLine 2\\n\\n\\nLine 3 # Comment\\n\");\n    auto result = read_file_and_process_lines(test_file_path);\n    REQUIRE(result == std::vector<std::string>{\"Line 1\", \"Line 2\", \"Line 3\"});\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test processing when there are no inline comments\") {\n    write_to_file(\"Line 1\\nLine 2\\nLine 3\\n\");\n    auto result = read_file_and_process_lines(test_file_path);\n    REQUIRE(result == std::vector<std::string>{\"Line 1\", \"Line 2\", \"Line 3\"});\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test processing with only new lines\") {\n    write_to_file(\"\\n\\n\\n\\n\");\n    auto result = read_file_and_process_lines(test_file_path);\n    REQUIRE(result.empty());\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test processing with mixed content\") {\n    write_to_file(\"Valid line\\n# This is a comment\\nLine 2\\n# Another comment\\n\\nLine 3 # End of line comment\\n\");\n    auto result = read_file_and_process_lines(test_file_path);\n    REQUIRE(result == std::vector<std::string>{\"Valid line\", \"Line 2\", \"Line 3\"});\n}", "prompt": "please write a cpp function , the function signature as below \n/**\n * @brief Reads a file from the specified path, processes each line to remove inline comments,\n * removes line breaks, and returns a list of the processed line contents.\n *\n * @param path The path to the file to be read.\n * @return std::vector<std::string> A vector of strings, each representing a processed line from the file.\n */\nstd::vector<std::string> read_file_and_process_lines(const std::string& path);", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads a file from the specified path, processes each line to remove inline comments,\n * removes line breaks, and returns a list of the processed line contents.\n *\n * @param path The path to the file to be read.\n * @return A list of strings, each representing a processed line from the file.\n * @throws IllegalArgumentException if an I/O error occurs while reading the file.\n */\npublic List<String> readFileAndProcessLines(String path) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.BeforeEach;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass Tester {\n\n    private String testFilePath;\n\n    @BeforeEach\n    void setUp() throws IOException {\n        // Create a temporary file for testing\n        testFilePath = \"testFile.txt\";\n        File file = new File(testFilePath);\n        file.createNewFile();\n    }\n\n    // Helper method to write to the test file\n    private void writeToFile(String content) throws IOException {\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(testFilePath))) {\n            writer.write(content);\n        }\n    }\n\n    @Test\n    void testNormalInput() throws IOException {\n        writeToFile(\"Line 1\\nLine 2 # Comment\\nLine 3\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(\"Line 1\", \"Line 2\", \"Line 3\"), result);\n    }\n\n    @Test\n    void testOnlyComments() throws IOException {\n        writeToFile(\"# This is a comment\\n# Another comment\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(), result);\n    }\n\n    @Test\n    void testEmptyLines() throws IOException {\n        writeToFile(\"Line 1\\n\\nLine 2\\n\\n\\nLine 3 # Comment\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(\"Line 1\", \"Line 2\", \"Line 3\"), result);\n    }\n\n    @Test\n    void testNoInlineComments() throws IOException {\n        writeToFile(\"Line 1\\nLine 2\\nLine 3\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(\"Line 1\", \"Line 2\", \"Line 3\"), result);\n    }\n\n\n    @Test\n    void testOnlyNewLines() throws IOException {\n        writeToFile(\"\\n\\n\\n\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(), result);\n    }\n\n    @Test\n    void testMixedContent() throws IOException {\n        writeToFile(\"Valid line\\n# This is a comment\\nLine 2\\n# Another comment\\n\\nLine 3 # End of line comment\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(\"Valid line\", \"Line 2\", \"Line 3\"), result);\n    }\n\n    // Cleanup after tests\n    @AfterEach\n    void tearDown() throws IOException {\n        Files.deleteIfExists(Paths.get(testFilePath));\n    }\n\n    // The method to be tested\n    public List<String> readFileAndProcessLines(String path) {\n        List<String> processedLines = new ArrayList<>();\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {\n            String line;\n\n            while ((line = reader.readLine()) != null) {\n                // Remove inline comments\n                line = line.split(\"#\")[0].trim();\n                // Only add non-empty lines to the list\n                if (!line.isEmpty()) {\n                    processedLines.add(line);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new IllegalArgumentException(\"Error reading file: \" + e.getMessage());\n        }\n\n        return processedLines;\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Reads a file from the specified path, processes each line to remove inline comments,\n * removes line breaks, and returns a list of the processed line contents.\n *\n * @param path The path to the file to be read.\n * @return A list of strings, each representing a processed line from the file.\n * @throws IllegalArgumentException if an I/O error occurs while reading the file.\n */\npublic List<String> readFileAndProcessLines(String path) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 628, "code_type": "method", "original_language": "java", "question_type": "Data processing and transformation", "summary": "Modify a specific line in the specified file and update the content of the line based on the new value you enter\n", "language_version_list": {"python": {"code_signature": "def modify_line_in_file(file_path: str, line_number: int, new_value: str) -> None:\n    \"\"\"\n    Modifies a specific line in the given file.\n\n    Args:\n        file_path (str): The path of the file to be modified.\n        line_number (str): The line number to be modified (1-based index).\n        new_value (str): The new value to update the line with.\n    Raises:\n        IOError: If an I/O error occurs\n    Returns:\n\n    \"\"\"\n", "test_code": "import os\nimport unittest\n\n\nclass TestAnswer(unittest.TestCase):\n    TEST_FILE = \"testFile.txt\"\n\n    def setUp(self):\n        # Create a test file with initial content\n        with open(self.TEST_FILE, 'w') as writer:\n            writer.write(\"Line 1\\n\")\n            writer.write(\"Line 2\\n\")\n            writer.write(\"Line 3\\n\")\n\n    def tearDown(self):\n        # Clean up the test file after each test\n        try:\n            os.remove(self.TEST_FILE)\n        except FileNotFoundError:\n            pass  # File might already be deleted\n\n    def test_modify_line_success(self):\n        modify_line_in_file(self.TEST_FILE, 2, \"Updated Line 2\")\n        with open(self.TEST_FILE, 'r') as reader:\n            self.assertEqual(\"Line 1\\n\", reader.readline())\n            self.assertEqual(\"Updated Line 2\\n\", reader.readline())\n            self.assertEqual(\"Line 3\\n\", reader.readline())\n\n    def test_modify_first_line(self):\n        modify_line_in_file(self.TEST_FILE, 1, \"Updated Line 1\")\n        with open(self.TEST_FILE, 'r') as reader:\n            self.assertEqual(\"Updated Line 1\\n\", reader.readline())\n            self.assertEqual(\"Line 2\\n\", reader.readline())\n            self.assertEqual(\"Line 3\\n\", reader.readline())\n\n    def test_modify_last_line(self):\n        modify_line_in_file(self.TEST_FILE, 3, \"Updated Line 3\")\n        with open(self.TEST_FILE, 'r') as reader:\n            self.assertEqual(\"Line 1\\n\", reader.readline())\n            self.assertEqual(\"Line 2\\n\", reader.readline())\n            self.assertEqual(\"Updated Line 3\\n\", reader.readline())\n\n    def test_modify_non_existent_line(self):\n        with self.assertRaises(Exception):\n            modify_line_in_file(self.TEST_FILE, 4, \"Should Fail\")\n\n    def test_modify_negative_line_number(self):\n        with self.assertRaises(Exception):\n            modify_line_in_file(self.TEST_FILE, 0, \"Should Fail\")\n", "prompt": "please write a python function , the function signature as below def modify_line_in_file(file_path: str, line_number: int, new_value: str) -> None:\n    \"\"\"\n    Modifies a specific line in the given file.\n\n    Args:\n        file_path (str): The path of the file to be modified.\n        line_number (str): The line number to be modified (1-based index).\n        new_value (str): The new value to update the line with.\n    Raises:\n        IOError: If an I/O error occurs\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Modifies a specific line in the given file.\n *\n * @param {string} filePath - The path of the file to be modified.\n * @param {number} lineNumber - The line number to be modified (1-based index).\n * @param {string} newValue - The new value to update the line with.\n * @returns {void}\n */\nfunction modifyLineInFile(filePath, lineNumber, newValue) {}", "test_code": "import path from \"path\";\n\n\ndescribe('TestAnswer', () => {\n    const TEST_FILE = path.join(__dirname, 'testFile.txt');\n\n    // Setup: Create a test file with initial content before each test\n    beforeEach(() => {\n        fs.writeFileSync(TEST_FILE, \"Line 1\\nLine 2\\nLine 3\\n\");\n    });\n\n    // Teardown: Clean up the test file after each test\n    afterEach(() => {\n        try {\n            fs.unlinkSync(TEST_FILE);\n        } catch (err) {\n            // If the file does not exist, we can safely ignore the error\n        }\n    });\n\n    test('modify line success', () => {\n        modifyLineInFile(TEST_FILE, 2, \"Updated Line 2\");\n        const lines = fs.readFileSync(TEST_FILE, 'utf-8').split('\\n');\n        expect(lines[0]).toBe(\"Line 1\");\n        expect(lines[1]).toBe(\"Updated Line 2\");\n        expect(lines[2]).toBe(\"Line 3\");\n    });\n\n    test('modify first line', () => {\n        modifyLineInFile(TEST_FILE, 1, \"Updated Line 1\");\n        const lines = fs.readFileSync(TEST_FILE, 'utf-8').split('\\n');\n        expect(lines[0]).toBe(\"Updated Line 1\");\n        expect(lines[1]).toBe(\"Line 2\");\n        expect(lines[2]).toBe(\"Line 3\");\n    });\n\n    test('modify last line', () => {\n        modifyLineInFile(TEST_FILE, 3, \"Updated Line 3\");\n        const lines = fs.readFileSync(TEST_FILE, 'utf-8').split('\\n');\n        expect(lines[0]).toBe(\"Line 1\");\n        expect(lines[1]).toBe(\"Line 2\");\n        expect(lines[2]).toBe(\"Updated Line 3\");\n    });\n\n    test('modify non-existent line', () => {\n        expect(() => {\n            modifyLineInFile(TEST_FILE, 4, \"Should Fail\");\n        }).toThrow();\n    });\n\n    test('modify negative line number', () => {\n        expect(() => {\n            modifyLineInFile(TEST_FILE, 0, \"Should Fail\");\n        }).toThrow();\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Modifies a specific line in the given file.\n *\n * @param {string} filePath - The path of the file to be modified.\n * @param {number} lineNumber - The line number to be modified (1-based index).\n * @param {string} newValue - The new value to update the line with.\n * @returns {void}\n */\nfunction modifyLineInFile(filePath, lineNumber, newValue) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Modifies a specific line in the given file.\n * \n * @param filePath - The path of the file to be modified.\n * @param lineNumber - The line number to be modified (1-based index).\n * @param newValue - The new value to update the line with.\n */\nfunction modifyLineInFile(filePath: string, lineNumber: number, newValue: string): void {}", "test_code": "import * as fs from 'fs';\n\ndescribe('TestAnswer', () => {\n    const TEST_FILE = 'testFile.txt';\n\n    beforeEach(() => {\n        // Create a test file with initial content\n        fs.writeFileSync(TEST_FILE, 'Line 1\\nLine 2\\nLine 3\\n');\n    });\n\n    afterEach(() => {\n        // Clean up the test file after each test\n        try {\n            fs.unlinkSync(TEST_FILE);\n        } catch (err) {\n            // File might already be deleted\n        }\n    });\n\n    test('modify line success', () => {\n        modifyLineInFile(TEST_FILE, 2, 'Updated Line 2');\n        const lines = fs.readFileSync(TEST_FILE, 'utf-8').split('\\n');\n        expect(lines[0]).toBe('Line 1');\n        expect(lines[1]).toBe('Updated Line 2');\n        expect(lines[2]).toBe('Line 3');\n    });\n\n    test('modify first line', () => {\n        modifyLineInFile(TEST_FILE, 1, 'Updated Line 1');\n        const lines = fs.readFileSync(TEST_FILE, 'utf-8').split('\\n');\n        expect(lines[0]).toBe('Updated Line 1');\n        expect(lines[1]).toBe('Line 2');\n        expect(lines[2]).toBe('Line 3');\n    });\n\n    test('modify last line', () => {\n        modifyLineInFile(TEST_FILE, 3, 'Updated Line 3');\n        const lines = fs.readFileSync(TEST_FILE, 'utf-8').split('\\n');\n        expect(lines[0]).toBe('Line 1');\n        expect(lines[1]).toBe('Line 2');\n        expect(lines[2]).toBe('Updated Line 3');\n    });\n\n    test('modify non-existent line', () => {\n        expect(() => {\n            modifyLineInFile(TEST_FILE, 4, 'Should Fail');\n        }).toThrow();\n    });\n\n    test('modify negative line number', () => {\n        expect(() => {\n            modifyLineInFile(TEST_FILE, 0, 'Should Fail');\n        }).toThrow();\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Modifies a specific line in the given file.\n * \n * @param filePath - The path of the file to be modified.\n * @param lineNumber - The line number to be modified (1-based index).\n * @param newValue - The new value to update the line with.\n */\nfunction modifyLineInFile(filePath: string, lineNumber: number, newValue: string): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Modifies a specific line in the given file.\n *\n * @param filePath The path of the file to be modified.\n *                 Must be a valid file path leading to an accessible file.\n * @type filePath std::string\n *\n * @param lineNumber The line number to be modified (1-based index).\n *                   Must be greater than zero and within the total number of lines in the file.\n * @type lineNumber int\n *\n * @param newValue The new value to update the line with.\n * @type newValue std::string\n *\n * @return void\n */\n\nvoid modifyLineInFile(const std::string& filePath, int lineNumber, const std::string& newValue);", "test_code": "TEST_CASE_METHOD(TestAnswer, \"Test Modify Line Success\") {\n    modifyLineInFile(TEST_FILE, 2, \"Updated Line 2\");\n    \n    std::ifstream reader(TEST_FILE);\n    std::string line;\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Line 1\");\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Updated Line 2\");\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Line 3\");\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test Modify First Line\") {\n    modifyLineInFile(TEST_FILE, 1, \"Updated Line 1\");\n    \n    std::ifstream reader(TEST_FILE);\n    std::string line;\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Updated Line 1\");\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Line 2\");\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Line 3\");\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test Modify Last Line\") {\n    modifyLineInFile(TEST_FILE, 3, \"Updated Line 3\");\n    \n    std::ifstream reader(TEST_FILE);\n    std::string line;\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Line 1\");\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Line 2\");\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Updated Line 3\");\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test Modify Non-Existent Line\") {\n    REQUIRE_THROWS_AS(modifyLineInFile(TEST_FILE, 4, \"Should Fail\"), std::exception);\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test Modify Negative Line Number\") {\n    REQUIRE_THROWS_AS(modifyLineInFile(TEST_FILE, 0, \"Should Fail\"), std::exception);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Modifies a specific line in the given file.\n *\n * @param filePath The path of the file to be modified.\n *                 Must be a valid file path leading to an accessible file.\n * @type filePath std::string\n *\n * @param lineNumber The line number to be modified (1-based index).\n *                   Must be greater than zero and within the total number of lines in the file.\n * @type lineNumber int\n *\n * @param newValue The new value to update the line with.\n * @type newValue std::string\n *\n * @return void\n */\n\nvoid modifyLineInFile(const std::string& filePath, int lineNumber, const std::string& newValue);", "addition_info": ""}, "java": {"code_signature": "/**\n * Modifies a specific line in the given file.\n *\n * @param filePath the path of the file to be modified\n * @param lineNumber the line number to be modified (1-based index)\n * @param newValue the new value to update the line with\n * @throws IOException if an I/O error occurs\n */\npublic void modifyLineInFile(String filePath, int lineNumber, String newValue) throws IOException {}", "test_code": "{\n\n    private static final String TEST_FILE = \"testFile.txt\";\n    private Answer answer;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        answer = new Answer();\n        // Create a test file with initial content\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(TEST_FILE))) {\n            writer.write(\"Line 1\");\n            writer.newLine();\n            writer.write(\"Line 2\");\n            writer.newLine();\n            writer.write(\"Line 3\");\n            writer.newLine();\n        }\n    }\n\n    @AfterEach\n    public void tearDown() throws IOException {\n        // Clean up the test file after each test\n        Files.deleteIfExists(Paths.get(TEST_FILE));\n    }\n\n    @Test\n    public void testModifyLine_Success() throws IOException {\n        answer.modifyLineInFile(TEST_FILE, 2, \"Updated Line 2\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(TEST_FILE))) {\n            assertEquals(\"Line 1\", reader.readLine());\n            assertEquals(\"Updated Line 2\", reader.readLine());\n            assertEquals(\"Line 3\", reader.readLine());\n        }\n    }\n\n    @Test\n    public void testModifyFirstLine() throws IOException {\n        answer.modifyLineInFile(TEST_FILE, 1, \"Updated Line 1\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(TEST_FILE))) {\n            assertEquals(\"Updated Line 1\", reader.readLine());\n            assertEquals(\"Line 2\", reader.readLine());\n            assertEquals(\"Line 3\", reader.readLine());\n        }\n    }\n\n    @Test\n    public void testModifyLastLine() throws IOException {\n        answer.modifyLineInFile(TEST_FILE, 3, \"Updated Line 3\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(TEST_FILE))) {\n            assertEquals(\"Line 1\", reader.readLine());\n            assertEquals(\"Line 2\", reader.readLine());\n            assertEquals(\"Updated Line 3\", reader.readLine());\n        }\n    }\n\n    @Test\n    public void testModifyNonExistentLine() {\n        assertThrows(Exception.class, () -> {\n            answer.modifyLineInFile(TEST_FILE, 4, \"Should Fail\");\n        });\n    }\n\n    @Test\n    public void testModifyNegativeLineNumber() {\n        assertThrows(Exception.class, () -> {\n            answer.modifyLineInFile(TEST_FILE, 0, \"Should Fail\");\n        });\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Modifies a specific line in the given file.\n *\n * @param filePath the path of the file to be modified\n * @param lineNumber the line number to be modified (1-based index)\n * @param newValue the new value to update the line with\n * @throws IOException if an I/O error occurs\n */\npublic void modifyLineInFile(String filePath, int lineNumber, String newValue) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 630, "code_type": "method", "original_language": "java", "question_type": "Algorithm and data structure", "summary": "Implement insertion sorting\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef insertion_sort(arr:List):\n    \"\"\"\n    Sorts a list of floats in ascending order using the insertion sort algorithm.\n\n    Args:\n        arr (List): The list of floats to be sorted.\n\n    Returns:\n\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestAnswer(unittest.TestCase):\n    def test_basic_unsorted_array(self):\n        \"\"\"Test case 1: Basic unsorted array.\"\"\"\n        arr = [12.4, 11.2, 13.5, 5.6, 6.7]\n        expected = [5.6, 6.7, 11.2, 12.4, 13.5]\n        insertion_sort(arr)\n        self.assertEqual(expected, arr)\n\n    def test_already_sorted_array(self):\n        \"\"\"Test case 2: Already sorted array.\"\"\"\n        arr = [1.1, 2.2, 3.3, 4.4, 5.5]\n        expected = [1.1, 2.2, 3.3, 4.4, 5.5]\n        insertion_sort(arr)\n        self.assertEqual(expected, arr)\n\n    def test_reverse_sorted_array(self):\n        \"\"\"Test case 3: Reverse sorted array.\"\"\"\n        arr = [5.5, 4.4, 3.3, 2.2, 1.1]\n        expected = [1.1, 2.2, 3.3, 4.4, 5.5]\n        insertion_sort(arr)\n        self.assertEqual(expected, arr)\n\n    def test_empty_array(self):\n        \"\"\"Test case 4: Empty array.\"\"\"\n        arr = []\n        expected = []\n        insertion_sort(arr)\n        self.assertEqual(expected, arr)\n\n    def test_single_element_array(self):\n        \"\"\"Test case 5: Single element array.\"\"\"\n        arr = [3.3]\n        expected = [3.3]\n        insertion_sort(arr)\n        self.assertEqual(expected, arr)\n\n    def test_array_with_duplicates(self):\n        \"\"\"Test case 6: Array with duplicate values.\"\"\"\n        arr = [2.2, 3.3, 2.2, 1.1, 3.3]\n        expected = [1.1, 2.2, 2.2, 3.3, 3.3]\n        insertion_sort(arr)\n        self.assertEqual(expected, arr)\n\n    def test_large_numbers(self):\n        \"\"\"Test case 7: Large numbers.\"\"\"\n        arr = [1e10, 1e9, 1e11, 1e8]\n        expected = [1e8, 1e9, 1e10, 1e11]\n        insertion_sort(arr)\n        self.assertEqual(expected, arr)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef insertion_sort(arr:List):\n    \"\"\"\n    Sorts a list of floats in ascending order using the insertion sort algorithm.\n\n    Args:\n        arr (List): The list of floats to be sorted.\n\n    Returns:\n\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Sorts an array of floats in ascending order using the insertion sort algorithm.\n *\n * @param {number[]} arr - The array of floats to be sorted.\n */\nfunction insertionSort(arr) {}", "test_code": "describe('insertionSort', () => {\n    test('Test case 1: Basic unsorted array.', () => {\n        const arr = [12.4, 11.2, 13.5, 5.6, 6.7];\n        const expected = [5.6, 6.7, 11.2, 12.4, 13.5];\n        insertionSort(arr);\n        expect(arr).toEqual(expected);\n    });\n\n    test('Test case 2: Already sorted array.', () => {\n        const arr = [1.1, 2.2, 3.3, 4.4, 5.5];\n        const expected = [1.1, 2.2, 3.3, 4.4, 5.5];\n        insertionSort(arr);\n        expect(arr).toEqual(expected);\n    });\n\n    test('Test case 3: Reverse sorted array.', () => {\n        const arr = [5.5, 4.4, 3.3, 2.2, 1.1];\n        const expected = [1.1, 2.2, 3.3, 4.4, 5.5];\n        insertionSort(arr);\n        expect(arr).toEqual(expected);\n    });\n\n    test('Test case 4: Empty array.', () => {\n        const arr = [];\n        const expected = [];\n        insertionSort(arr);\n        expect(arr).toEqual(expected);\n    });\n\n    test('Test case 5: Single element array.', () => {\n        const arr = [3.3];\n        const expected = [3.3];\n        insertionSort(arr);\n        expect(arr).toEqual(expected);\n    });\n\n    test('Test case 6: Array with duplicate values.', () => {\n        const arr = [2.2, 3.3, 2.2, 1.1, 3.3];\n        const expected = [1.1, 2.2, 2.2, 3.3, 3.3];\n        insertionSort(arr);\n        expect(arr).toEqual(expected);\n    });\n\n    test('Test case 7: Large numbers.', () => {\n        const arr = [1e10, 1e9, 1e11, 1e8];\n        const expected = [1e8, 1e9, 1e10, 1e11];\n        insertionSort(arr);\n        expect(arr).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Sorts an array of floats in ascending order using the insertion sort algorithm.\n *\n * @param {number[]} arr - The array of floats to be sorted.\n */\nfunction insertionSort(arr) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Sorts a list of floats in ascending order using the insertion sort algorithm.\n *\n * @param {number[]} arr - The list of floats to be sorted.\n * @returns {void}\n */\nfunction insertionSort(arr: number[]): void {}", "test_code": "describe('insertionSort', () => {\n    test('Basic unsorted array', () => {\n        const arr: number[] = [12.4, 11.2, 13.5, 5.6, 6.7];\n        const expected: number[] = [5.6, 6.7, 11.2, 12.4, 13.5];\n        insertionSort(arr);\n        expect(arr).toEqual(expected);\n    });\n\n    test('Already sorted array', () => {\n        const arr: number[] = [1.1, 2.2, 3.3, 4.4, 5.5];\n        const expected: number[] = [1.1, 2.2, 3.3, 4.4, 5.5];\n        insertionSort(arr);\n        expect(arr).toEqual(expected);\n    });\n\n    test('Reverse sorted array', () => {\n        const arr: number[] = [5.5, 4.4, 3.3, 2.2, 1.1];\n        const expected: number[] = [1.1, 2.2, 3.3, 4.4, 5.5];\n        insertionSort(arr);\n        expect(arr).toEqual(expected);\n    });\n\n    test('Empty array', () => {\n        const arr: number[] = [];\n        const expected: number[] = [];\n        insertionSort(arr);\n        expect(arr).toEqual(expected);\n    });\n\n    test('Single element array', () => {\n        const arr: number[] = [3.3];\n        const expected: number[] = [3.3];\n        insertionSort(arr);\n        expect(arr).toEqual(expected);\n    });\n\n    test('Array with duplicates', () => {\n        const arr: number[] = [2.2, 3.3, 2.2, 1.1, 3.3];\n        const expected: number[] = [1.1, 2.2, 2.2, 3.3, 3.3];\n        insertionSort(arr);\n        expect(arr).toEqual(expected);\n    });\n\n    test('Large numbers', () => {\n        const arr: number[] = [1e10, 1e9, 1e11, 1e8];\n        const expected: number[] = [1e8, 1e9, 1e10, 1e11];\n        insertionSort(arr);\n        expect(arr).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Sorts a list of floats in ascending order using the insertion sort algorithm.\n *\n * @param {number[]} arr - The list of floats to be sorted.\n * @returns {void}\n */\nfunction insertionSort(arr: number[]): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Sorts a vector of floats in ascending order using the insertion sort algorithm.\n *\n * @param arr The vector of floats to be sorted.\n */\nvoid insertion_sort(std::vector<float>& arr) {}", "test_code": "TEST_CASE(\"Insertion Sort Tests\", \"[insertion_sort]\") {\n    SECTION(\"Basic unsorted array\") {\n        std::vector<float> arr = {12.4f, 11.2f, 13.5f, 5.6f, 6.7f};\n        std::vector<float> expected = {5.6f, 6.7f, 11.2f, 12.4f, 13.5f};\n        insertion_sort(arr);\n        REQUIRE(arr == expected);\n    }\n\n    SECTION(\"Already sorted array\") {\n        std::vector<float> arr = {1.1f, 2.2f, 3.3f, 4.4f, 5.5f};\n        std::vector<float> expected = {1.1f, 2.2f, 3.3f, 4.4f, 5.5f};\n        insertion_sort(arr);\n        REQUIRE(arr == expected);\n    }\n\n    SECTION(\"Reverse sorted array\") {\n        std::vector<float> arr = {5.5f, 4.4f, 3.3f, 2.2f, 1.1f};\n        std::vector<float> expected = {1.1f, 2.2f, 3.3f, 4.4f, 5.5f};\n        insertion_sort(arr);\n        REQUIRE(arr == expected);\n    }\n\n    SECTION(\"Empty array\") {\n        std::vector<float> arr = {};\n        std::vector<float> expected = {};\n        insertion_sort(arr);\n        REQUIRE(arr == expected);\n    }\n\n    SECTION(\"Single element array\") {\n        std::vector<float> arr = {3.3f};\n        std::vector<float> expected = {3.3f};\n        insertion_sort(arr);\n        REQUIRE(arr == expected);\n    }\n\n    SECTION(\"Array with duplicate values\") {\n        std::vector<float> arr = {2.2f, 3.3f, 2.2f, 1.1f, 3.3f};\n        std::vector<float> expected = {1.1f, 2.2f, 2.2f, 3.3f, 3.3f};\n        insertion_sort(arr);\n        REQUIRE(arr == expected);\n    }\n\n    SECTION(\"Large numbers\") {\n        std::vector<float> arr = {1e10f, 1e9f, 1e11f, 1e8f};\n        std::vector<float> expected = {1e8f, 1e9f, 1e10f, 1e11f};\n        insertion_sort(arr);\n        REQUIRE(arr == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Sorts a vector of floats in ascending order using the insertion sort algorithm.\n *\n * @param arr The vector of floats to be sorted.\n */\nvoid insertion_sort(std::vector<float>& arr) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Sorts an array of doubles in ascending order using the insertion sort algorithm.\n *\n * The insertion sort algorithm works by dividing the array into a sorted and an\n * unsorted portion. It iterates through the unsorted portion, taking one element\n * (the key) at a time and inserting it into its correct position in the sorted portion.\n *\n * @param arr the array of doubles to be sorted\n */\npublic static void insertionSort(double[] arr) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    // Test case 1: Basic unsorted array\n    @Test\n    public void testBasicUnsortedArray() {\n        double[] arr = {12.4, 11.2, 13.5, 5.6, 6.7};\n        double[] expected = {5.6, 6.7, 11.2, 12.4, 13.5};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 2: Already sorted array\n    @Test\n    public void testAlreadySortedArray() {\n        double[] arr = {1.1, 2.2, 3.3, 4.4, 5.5};\n        double[] expected = {1.1, 2.2, 3.3, 4.4, 5.5};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 3: Reverse sorted array\n    @Test\n    public void testReverseSortedArray() {\n        double[] arr = {5.5, 4.4, 3.3, 2.2, 1.1};\n        double[] expected = {1.1, 2.2, 3.3, 4.4, 5.5};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 4: Empty array\n    @Test\n    public void testEmptyArray() {\n        double[] arr = {};\n        double[] expected = {};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 5: Single element array\n    @Test\n    public void testSingleElementArray() {\n        double[] arr = {3.3};\n        double[] expected = {3.3};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 6: Array with duplicate values\n    @Test\n    public void testArrayWithDuplicates() {\n        double[] arr = {2.2, 3.3, 2.2, 1.1, 3.3};\n        double[] expected = {1.1, 2.2, 2.2, 3.3, 3.3};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 7: Large numbers\n    @Test\n    public void testLargeNumbers() {\n        double[] arr = {1e10, 1e9, 1e11, 1e8};\n        double[] expected = {1e8, 1e9, 1e10, 1e11};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Sorts an array of doubles in ascending order using the insertion sort algorithm.\n *\n * The insertion sort algorithm works by dividing the array into a sorted and an\n * unsorted portion. It iterates through the unsorted portion, taking one element\n * (the key) at a time and inserting it into its correct position in the sorted portion.\n *\n * @param arr the array of doubles to be sorted\n */\npublic static void insertionSort(double[] arr) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 631, "code_type": "method", "original_language": "java", "question_type": "Data processing and transformation", "summary": "Format a list of strings into a single-line string in CSV (comma-separated values) format and write it to a file\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef write_csv_to_file(strings: List[str], file_path: str):\n    \"\"\"\n    Formats a list of strings into a single-line CSV string and writes it to a specified file.\n\n    Args:\n        strings (List[str]): List of strings to be formatted into CSV.\n        file_path (str): The file path where the CSV string should be written.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import os\nimport unittest\n\n\nclass TestAnswer(unittest.TestCase):\n    def setUp(self):\n        self.test_file_path = \"test_output.csv\"  # Path for test output file\n\n    def tearDown(self):\n        # Delete the test file after each test\n        if os.path.exists(self.test_file_path):\n            os.remove(self.test_file_path)\n\n    def read_file(self, file_path):\n        \"\"\"Helper method to read file content as a string.\"\"\"\n        try:\n            with open(file_path, 'r') as file:\n                return file.read()\n        except IOError as e:\n            self.fail(f\"Failed to read file: {e}\")\n\n    def test_write_csv_to_file_with_multiple_strings(self):\n        data = [\"Apple\", \"Banana\", \"Cherry\"]\n        write_csv_to_file(data, self.test_file_path)\n        # Assert the content of the file\n        content = self.read_file(self.test_file_path)\n        self.assertEqual(\"Apple,Banana,Cherry\", content)\n\n    def test_write_csv_to_file_with_single_string(self):\n        data = [\"Apple\"]\n        write_csv_to_file(data, self.test_file_path)\n        # Assert the content of the file\n        content = self.read_file(self.test_file_path)\n        self.assertEqual(\"Apple\", content)\n\n    def test_write_csv_to_file_with_empty_list(self):\n        data = []\n        write_csv_to_file(data, self.test_file_path)\n        # Assert the content of the file is empty\n        content = self.read_file(self.test_file_path)\n        self.assertEqual(\"\", content)\n\n    def test_write_csv_to_file_with_special_characters(self):\n        data = [\"Apple\", \"Banana, Cherry\", \"Date\"]\n        write_csv_to_file(data, self.test_file_path)\n        # Assert the content of the file\n        content = self.read_file(self.test_file_path)\n        self.assertEqual(\"Apple,Banana, Cherry,Date\", content)\n\n    def test_write_csv_to_file_with_spaces(self):\n        data = [\"Apple \", \" Banana\", \" Cherry \"]\n        write_csv_to_file(data, self.test_file_path)\n        # Assert the content of the file with spaces\n        content = self.read_file(self.test_file_path)\n        self.assertEqual(\"Apple , Banana, Cherry \", content)\n\n    def test_write_csv_to_file_with_file_overwrite(self):\n        # First write to the file\n        first_data = [\"Apple\", \"Banana\"]\n        write_csv_to_file(first_data, self.test_file_path)\n\n        # Now overwrite with new data\n        second_data = [\"Cherry\", \"Date\"]\n        write_csv_to_file(second_data, self.test_file_path)\n\n        # Assert that the file now contains the new data\n        content = self.read_file(self.test_file_path)\n        self.assertEqual(\"Cherry,Date\", content)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef write_csv_to_file(strings: List[str], file_path: str):\n    \"\"\"\n    Formats a list of strings into a single-line CSV string and writes it to a specified file.\n\n    Args:\n        strings (List[str]): List of strings to be formatted into CSV.\n        file_path (str): The file path where the CSV string should be written.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Formats a list of strings into a single-line CSV string and writes it to a specified file.\n *\n * @param {string[]} strings - List of strings to be formatted into CSV.\n * @param {string} filePath - The file path where the CSV string should be written.\n */\nfunction writeCsvToFile(strings, filePath) {}", "test_code": "import path from \"path\";\n\ndescribe('TestAnswer', () => {\n    const testFilePath = path.join(__dirname, 'test_output.csv'); // Path for test output file\n\n    afterEach(() => {\n        // Delete the test file after each test\n        if (fs.existsSync(testFilePath)) {\n            fs.unlinkSync(testFilePath);\n        }\n    });\n\n    const readFile = (filePath) => {\n        /** Helper method to read file content as a string. */\n        try {\n            return fs.readFileSync(filePath, 'utf8');\n        } catch (e) {\n            throw new Error(`Failed to read file: ${e.message}`);\n        }\n    };\n\n    test('writeCsvToFile with multiple strings', () => {\n        const data = [\"Apple\", \"Banana\", \"Cherry\"];\n        writeCsvToFile(data, testFilePath);\n        // Assert the content of the file\n        const content = readFile(testFilePath);\n        expect(content).toBe(\"Apple,Banana,Cherry\");\n    });\n\n    test('writeCsvToFile with single string', () => {\n        const data = [\"Apple\"];\n        writeCsvToFile(data, testFilePath);\n        // Assert the content of the file\n        const content = readFile(testFilePath);\n        expect(content).toBe(\"Apple\");\n    });\n\n    test('writeCsvToFile with empty list', () => {\n        const data = [];\n        writeCsvToFile(data, testFilePath);\n        // Assert the content of the file is empty\n        const content = readFile(testFilePath);\n        expect(content).toBe(\"\");\n    });\n\n    test('writeCsvToFile with special characters', () => {\n        const data = [\"Apple\", \"Banana, Cherry\", \"Date\"];\n        writeCsvToFile(data, testFilePath);\n        // Assert the content of the file\n        const content = readFile(testFilePath);\n        expect(content).toBe(\"Apple,Banana, Cherry,Date\");\n    });\n\n    test('writeCsvToFile with spaces', () => {\n        const data = [\"Apple \", \" Banana\", \" Cherry \"];\n        writeCsvToFile(data, testFilePath);\n        // Assert the content of the file with spaces\n        const content = readFile(testFilePath);\n        expect(content).toBe(\"Apple , Banana, Cherry \");\n    });\n\n    test('writeCsvToFile with file overwrite', () => {\n        // First write to the file\n        const firstData = [\"Apple\", \"Banana\"];\n        writeCsvToFile(firstData, testFilePath);\n\n        // Now overwrite with new data\n        const secondData = [\"Cherry\", \"Date\"];\n        writeCsvToFile(secondData, testFilePath);\n\n        // Assert that the file now contains the new data\n        const content = readFile(testFilePath);\n        expect(content).toBe(\"Cherry,Date\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Formats a list of strings into a single-line CSV string and writes it to a specified file.\n *\n * @param {string[]} strings - List of strings to be formatted into CSV.\n * @param {string} filePath - The file path where the CSV string should be written.\n */\nfunction writeCsvToFile(strings, filePath) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Formats a list of strings into a single-line CSV string and writes it to a specified file.\n *\n * @param strings - Array of strings to be formatted into CSV.\n * @param filePath - The file path where the CSV string should be written.\n */\nfunction writeCsvToFile(strings: string[], filePath: string): void {}", "test_code": "import * as fs from 'fs';\n\ndescribe('writeCsvToFile', () => {\n    const testFilePath = 'test_output.csv'; // Path for test output file\n\n    afterEach(() => {\n        // Delete the test file after each test\n        if (fs.existsSync(testFilePath)) {\n            fs.unlinkSync(testFilePath);\n        }\n    });\n\n    const readFile = (filePath: string): string => {\n        /** Helper method to read file content as a string. */\n        return fs.readFileSync(filePath, 'utf-8');\n    };\n\n    test('should write CSV to file with multiple strings', () => {\n        const data = ['Apple', 'Banana', 'Cherry'];\n        writeCsvToFile(data, testFilePath);\n        // Assert the content of the file\n        const content = readFile(testFilePath);\n        expect(content).toBe('Apple,Banana,Cherry');\n    });\n\n    test('should write CSV to file with a single string', () => {\n        const data = ['Apple'];\n        writeCsvToFile(data, testFilePath);\n        // Assert the content of the file\n        const content = readFile(testFilePath);\n        expect(content).toBe('Apple');\n    });\n\n    test('should write CSV to file with an empty list', () => {\n        const data: string[] = [];\n        writeCsvToFile(data, testFilePath);\n        // Assert the content of the file is empty\n        const content = readFile(testFilePath);\n        expect(content).toBe('');\n    });\n\n    test('should write CSV to file with special characters', () => {\n        const data = ['Apple', 'Banana, Cherry', 'Date'];\n        writeCsvToFile(data, testFilePath);\n        // Assert the content of the file\n        const content = readFile(testFilePath);\n        expect(content).toBe('Apple,Banana, Cherry,Date');\n    });\n\n    test('should write CSV to file with spaces', () => {\n        const data = ['Apple ', ' Banana', ' Cherry '];\n        writeCsvToFile(data, testFilePath);\n        // Assert the content of the file with spaces\n        const content = readFile(testFilePath);\n        expect(content).toBe('Apple , Banana, Cherry ');\n    });\n\n    test('should overwrite the file with new data', () => {\n        // First write to the file\n        const firstData = ['Apple', 'Banana'];\n        writeCsvToFile(firstData, testFilePath);\n\n        // Now overwrite with new data\n        const secondData = ['Cherry', 'Date'];\n        writeCsvToFile(secondData, testFilePath);\n\n        // Assert that the file now contains the new data\n        const content = readFile(testFilePath);\n        expect(content).toBe('Cherry,Date');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Formats a list of strings into a single-line CSV string and writes it to a specified file.\n *\n * @param strings - Array of strings to be formatted into CSV.\n * @param filePath - The file path where the CSV string should be written.\n */\nfunction writeCsvToFile(strings: string[], filePath: string): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Formats a list of strings into a single-line CSV string and writes it to a specified file.\n *\n * @param strings The vector of strings to be formatted into CSV.\n *                Must not be empty; an empty vector will result in no output.\n * @type strings const std::vector<std::string>&\n *\n * @param file_path The file path where the CSV string should be written.\n *                  Must be a valid file path that is accessible for writing.\n * @type file_path const std::string&\n *\n * @return void\n */\n\nvoid write_csv_to_file(const std::vector<std::string>& strings, const std::string& file_path);", "test_code": "TEST_CASE_METHOD(TestAnswer, \"Test write_csv_to_file with multiple strings\") {\n    std::vector<std::string> data = {\"Apple\", \"Banana\", \"Cherry\"};\n    write_csv_to_file(data, test_file_path);\n    // Assert the content of the file\n    std::string content = read_file(test_file_path);\n    REQUIRE(content == \"Apple,Banana,Cherry\");\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test write_csv_to_file with single string\") {\n    std::vector<std::string> data = {\"Apple\"};\n    write_csv_to_file(data, test_file_path);\n    // Assert the content of the file\n    std::string content = read_file(test_file_path);\n    REQUIRE(content == \"Apple\");\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test write_csv_to_file with empty list\") {\n    std::vector<std::string> data = {};\n    write_csv_to_file(data, test_file_path);\n    // Assert the content of the file is empty\n    std::string content = read_file(test_file_path);\n    REQUIRE(content == \"\");\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test write_csv_to_file with special characters\") {\n    std::vector<std::string> data = {\"Apple\", \"Banana, Cherry\", \"Date\"};\n    write_csv_to_file(data, test_file_path);\n    // Assert the content of the file\n    std::string content = read_file(test_file_path);\n    REQUIRE(content == \"Apple,Banana, Cherry,Date\");\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test write_csv_to_file with spaces\") {\n    std::vector<std::string> data = {\"Apple \", \" Banana\", \" Cherry \"};\n    write_csv_to_file(data, test_file_path);\n    // Assert the content of the file with spaces\n    std::string content = read_file(test_file_path);\n    REQUIRE(content == \"Apple , Banana, Cherry \");\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test write_csv_to_file with file overwrite\") {\n    // First write to the file\n    std::vector<std::string> first_data = {\"Apple\", \"Banana\"};\n    write_csv_to_file(first_data, test_file_path);\n\n    // Now overwrite with new data\n    std::vector<std::string> second_data = {\"Cherry\", \"Date\"};\n    write_csv_to_file(second_data, test_file_path);\n\n    // Assert that the file now contains the new data\n    std::string content = read_file(test_file_path);\n    REQUIRE(content == \"Cherry,Date\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Formats a list of strings into a single-line CSV string and writes it to a specified file.\n *\n * @param strings The vector of strings to be formatted into CSV.\n *                Must not be empty; an empty vector will result in no output.\n * @type strings const std::vector<std::string>&\n *\n * @param file_path The file path where the CSV string should be written.\n *                  Must be a valid file path that is accessible for writing.\n * @type file_path const std::string&\n *\n * @return void\n */\n\nvoid write_csv_to_file(const std::vector<std::string>& strings, const std::string& file_path);", "addition_info": ""}, "java": {"code_signature": "/**\n * Formats a list of strings into a single-line CSV string and writes it to a specified file.\n *\n * @param strings List of strings to be formatted into CSV.\n * @param filePath The file path where the CSV string should be written.\n */\npublic void writeCsvToFile(List<String> strings, String filePath) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.*;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Tester {\n    private Answer answer;\n    private final String testFilePath = \"test_output.csv\"; // Path for test output file\n\n    @BeforeEach\n    public void setUp() {\n        answer = new Answer(); // Create an instance of the Answer class\n    }\n\n    @AfterEach\n    public void tearDown() throws IOException {\n        // Delete the test file after each test\n        Path path = Paths.get(testFilePath);\n        if (Files.exists(path)) {\n            Files.delete(path);\n        }\n    }\n\n    @Test\n    public void testWriteCsvToFile_WithMultipleStrings() {\n        List<String> data = List.of(\"Apple\", \"Banana\", \"Cherry\");\n        answer.writeCsvToFile(data, testFilePath);\n\n        // Assert the content of the file\n        String content = readFile(testFilePath);\n        assertEquals(\"Apple,Banana,Cherry\", content);\n    }\n\n    @Test\n    public void testWriteCsvToFile_WithSingleString() {\n        List<String> data = List.of(\"Apple\");\n        answer.writeCsvToFile(data, testFilePath);\n\n        // Assert the content of the file\n        String content = readFile(testFilePath);\n        assertEquals(\"Apple\", content);\n    }\n\n    @Test\n    public void testWriteCsvToFile_WithEmptyList() {\n        List<String> data = List.of();\n        answer.writeCsvToFile(data, testFilePath);\n\n        // Assert the content of the file is empty\n        String content = readFile(testFilePath);\n        assertEquals(\"\", content);\n    }\n\n\n    @Test\n    public void testWriteCsvToFile_WithSpecialCharacters() {\n        List<String> data = List.of(\"Apple\", \"Banana, Cherry\", \"Date\");\n        answer.writeCsvToFile(data, testFilePath);\n\n        // Assert the content of the file\n        String content = readFile(testFilePath);\n        assertEquals(\"Apple,Banana, Cherry,Date\", content);\n    }\n\n    @Test\n    public void testWriteCsvToFile_WithSpaces() {\n        List<String> data = List.of(\"Apple \", \" Banana\", \" Cherry \");\n        answer.writeCsvToFile(data, testFilePath);\n\n        // Assert the content of the file with spaces\n        String content = readFile(testFilePath);\n        assertEquals(\"Apple , Banana, Cherry \", content);\n    }\n\n    @Test\n    public void testWriteCsvToFile_WithFileOverwrite() {\n        // First write to the file\n        List<String> firstData = List.of(\"Apple\", \"Banana\");\n        answer.writeCsvToFile(firstData, testFilePath);\n\n        // Now overwrite with new data\n        List<String> secondData = List.of(\"Cherry\", \"Date\");\n        answer.writeCsvToFile(secondData, testFilePath);\n\n        // Assert that the file now contains the new data\n        String content = readFile(testFilePath);\n        assertEquals(\"Cherry,Date\", content);\n    }\n\n    // Helper method to read file content as a String\n    private String readFile(String filePath) {\n        try {\n            return Files.readString(Path.of(filePath));\n        } catch (IOException e) {\n            fail(\"Failed to read file: \" + e.getMessage());\n            return \"\";\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Formats a list of strings into a single-line CSV string and writes it to a specified file.\n *\n * @param strings List of strings to be formatted into CSV.\n * @param filePath The file path where the CSV string should be written.\n */\npublic void writeCsvToFile(List<String> strings, String filePath) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 632, "code_type": "method", "original_language": "java", "question_type": "Data processing and transformation", "summary": "Parses a mathematical expression string, identifies its operators and operands, and stores them in a list\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef parse_expression(expression: str) -> List[str]:\n    \"\"\"\n    Parses a mathematical expression string into a list of tokens.\n    This function identifies both operands (numbers) and operators (+, -, *, /, etc.)\n    in the provided expression and returns them in a list format.\n\n    Args:\n        expression (str): The mathematical expression to be parsed.\n\n    Returns:\n        list[str]: A list containing the tokens identified in the expression.\n                    The list will include both operands and operators in the order they appear.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_simple_addition(self):\n        expression = \"2 + 2\"\n        result = parse_expression(expression)\n        self.assertEqual(result, [\"2\", \"+\", \"2\"])\n\n    def test_complex_expression(self):\n        expression = \"3 + 5 * (2 - 8)\"\n        result = parse_expression(expression)\n        self.assertEqual(result, [\"3\", \"+\", \"5\", \"*\", \"(\", \"2\", \"-\", \"8\", \")\"])\n\n    def test_negative_numbers(self):\n        expression = \"-1 + 4 - 5\"\n        result = parse_expression(expression)\n        self.assertEqual(result, [\"-\", \"1\", \"+\", \"4\", \"-\", \"5\"])\n\n    def test_decimals(self):\n        expression = \"3.5 + 2.1\"\n        result = parse_expression(expression)\n        self.assertEqual(result, [\"3.5\", \"+\", \"2.1\"])\n\n    def test_operators_only(self):\n        expression = \"+ - * /\"\n        result = parse_expression(expression)\n        self.assertEqual(result, [\"+\", \"-\", \"*\", \"/\"])\n\n    def test_empty_expression(self):\n        expression = \"\"\n        result = parse_expression(expression)\n        self.assertTrue(len(result) == 0)\n\n    def test_single_number(self):\n        expression = \"42\"\n        result = parse_expression(expression)\n        self.assertEqual(result, [\"42\"])", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef parse_expression(expression: str) -> List[str]:\n    \"\"\"\n    Parses a mathematical expression string into a list of tokens.\n    This function identifies both operands (numbers) and operators (+, -, *, /, etc.)\n    in the provided expression and returns them in a list format.\n\n    Args:\n        expression (str): The mathematical expression to be parsed.\n\n    Returns:\n        list[str]: A list containing the tokens identified in the expression.\n                    The list will include both operands and operators in the order they appear.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Parses a mathematical expression string into an array of tokens.\n * This function identifies both operands (numbers) and operators (+, -, *, /, etc.)\n * in the provided expression and returns them in an array format.\n *\n * @param {string} expression - The mathematical expression to be parsed.\n * @returns {string[]} An array containing the tokens identified in the expression.\n *                     The array will include both operands and operators in the order they appear.\n */\nfunction parseExpression(expression) {}", "test_code": "describe('parseExpression', () => {\n    \n    test('simple addition', () => {\n        const expression = \"2 + 2\";\n        const result = parseExpression(expression);\n        expect(result).toEqual([\"2\", \"+\", \"2\"]);\n    });\n\n    test('complex expression', () => {\n        const expression = \"3 + 5 * (2 - 8)\";\n        const result = parseExpression(expression);\n        expect(result).toEqual([\"3\", \"+\", \"5\", \"*\", \"(\", \"2\", \"-\", \"8\", \")\"]);\n    });\n\n    test('negative numbers', () => {\n        const expression = \"-1 + 4 - 5\";\n        const result = parseExpression(expression);\n        expect(result).toEqual([\"-\", \"1\", \"+\", \"4\", \"-\", \"5\"]);\n    });\n\n    test('decimals', () => {\n        const expression = \"3.5 + 2.1\";\n        const result = parseExpression(expression);\n        expect(result).toEqual([\"3.5\", \"+\", \"2.1\"]);\n    });\n\n    test('operators only', () => {\n        const expression = \"+ - * /\";\n        const result = parseExpression(expression);\n        expect(result).toEqual([\"+\", \"-\", \"*\", \"/\"]);\n    });\n\n    test('empty expression', () => {\n        const expression = \"\";\n        const result = parseExpression(expression);\n        expect(result.length).toBe(0);\n    });\n\n    test('single number', () => {\n        const expression = \"42\";\n        const result = parseExpression(expression);\n        expect(result).toEqual([\"42\"]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Parses a mathematical expression string into an array of tokens.\n * This function identifies both operands (numbers) and operators (+, -, *, /, etc.)\n * in the provided expression and returns them in an array format.\n *\n * @param {string} expression - The mathematical expression to be parsed.\n * @returns {string[]} An array containing the tokens identified in the expression.\n *                     The array will include both operands and operators in the order they appear.\n */\nfunction parseExpression(expression) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Parses a mathematical expression string into a list of tokens.\n * This function identifies both operands (numbers) and operators (+, -, *, /, etc.)\n * in the provided expression and returns them in a list format.\n *\n * @param expression - The mathematical expression to be parsed.\n * @returns An array containing the tokens identified in the expression.\n *          The array will include both operands and operators in the order they appear.\n */\nfunction parseExpression(expression: string): string[] {}", "test_code": "describe('parseExpression', () => {\n    test('simple addition', () => {\n        const expression = \"2 + 2\";\n        const result = parseExpression(expression);\n        expect(result).toEqual([\"2\", \"+\", \"2\"]);\n    });\n\n    test('complex expression', () => {\n        const expression = \"3 + 5 * (2 - 8)\";\n        const result = parseExpression(expression);\n        expect(result).toEqual([\"3\", \"+\", \"5\", \"*\", \"(\", \"2\", \"-\", \"8\", \")\"]);\n    });\n\n    test('negative numbers', () => {\n        const expression = \"-1 + 4 - 5\";\n        const result = parseExpression(expression);\n        expect(result).toEqual([\"-\", \"1\", \"+\", \"4\", \"-\", \"5\"]);\n    });\n\n    test('decimals', () => {\n        const expression = \"3.5 + 2.1\";\n        const result = parseExpression(expression);\n        expect(result).toEqual([\"3.5\", \"+\", \"2.1\"]);\n    });\n\n    test('operators only', () => {\n        const expression = \"+ - * /\";\n        const result = parseExpression(expression);\n        expect(result).toEqual([\"+\", \"-\", \"*\", \"/\"]);\n    });\n\n    test('empty expression', () => {\n        const expression = \"\";\n        const result = parseExpression(expression);\n        expect(result.length).toBe(0);\n    });\n\n    test('single number', () => {\n        const expression = \"42\";\n        const result = parseExpression(expression);\n        expect(result).toEqual([\"42\"]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Parses a mathematical expression string into a list of tokens.\n * This function identifies both operands (numbers) and operators (+, -, *, /, etc.)\n * in the provided expression and returns them in a list format.\n *\n * @param expression - The mathematical expression to be parsed.\n * @returns An array containing the tokens identified in the expression.\n *          The array will include both operands and operators in the order they appear.\n */\nfunction parseExpression(expression: string): string[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Parses a mathematical expression string into a list of tokens.\n *\n * @param expression The mathematical expression to be parsed.\n *                  Must be a valid expression containing operands and operators.\n * @type expression std::string\n *\n * @return A vector containing the tokens identified in the expression. \n *         The vector includes both operands and operators in the order they appear.\n * @rtype std::vector<std::string>\n */\nstd::vector<std::string> parse_expression(const std::string& expression){}", "test_code": "TEST_CASE(\"Parser Tests\") {\n    SECTION(\"Simple Addition\") {\n        std::string expression = \"2 + 2\";\n        auto result = parse_expression(expression);\n        REQUIRE(result == std::vector<std::string>{\"2\", \"+\", \"2\"});\n    }\n\n    SECTION(\"Complex Expression\") {\n        std::string expression = \"3 + 5 * (2 - 8)\";\n        auto result = parse_expression(expression);\n        REQUIRE(result == std::vector<std::string>{\"3\", \"+\", \"5\", \"*\", \"(\", \"2\", \"-\", \"8\", \")\"});\n    }\n\n    SECTION(\"Negative Numbers\") {\n        std::string expression = \"-1 + 4 - 5\";\n        auto result = parse_expression(expression);\n        REQUIRE(result == std::vector<std::string>{\"-\", \"1\", \"+\", \"4\", \"-\", \"5\"});\n    }\n\n    SECTION(\"Decimals\") {\n        std::string expression = \"3.5 + 2.1\";\n        auto result = parse_expression(expression);\n        REQUIRE(result == std::vector<std::string>{\"3.5\", \"+\", \"2.1\"});\n    }\n\n    SECTION(\"Operators Only\") {\n        std::string expression = \"+ - * /\";\n        auto result = parse_expression(expression);\n        REQUIRE(result == std::vector<std::string>{\"+\", \"-\", \"*\", \"/\"});\n    }\n\n    SECTION(\"Empty Expression\") {\n        std::string expression = \"\";\n        auto result = parse_expression(expression);\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"Single Number\") {\n        std::string expression = \"42\";\n        auto result = parse_expression(expression);\n        REQUIRE(result == std::vector<std::string>{\"42\"});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Parses a mathematical expression string into a list of tokens.\n *\n * @param expression The mathematical expression to be parsed.\n *                  Must be a valid expression containing operands and operators.\n * @type expression std::string\n *\n * @return A vector containing the tokens identified in the expression. \n *         The vector includes both operands and operators in the order they appear.\n * @rtype std::vector<std::string>\n */\nstd::vector<std::string> parse_expression(const std::string& expression){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Parses a mathematical expression string into a list of tokens.\n * This method identifies both operands (numbers) and operators (+, -, *, /, etc.) \n * in the provided expression, and returns them in a list format.\n *\n * @param expression The mathematical expression to be parsed, represented as a String.\n *                   The expression can contain integers, decimal numbers, \n *                   and standard arithmetic operators, as well as parentheses.\n * @return A List<String> containing the tokens identified in the expression. \n *         The list will include both operands and operators in the order they appear.\n */\npublic List<String> parseExpression(String expression) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.util.List;\n\npublic class Tester {\n\n    private final Answer answer = new Answer();\n\n    @Test\n    public void testSimpleAddition() {\n        String expression = \"2 + 2\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"2\", \"+\", \"2\"), result);\n    }\n\n    @Test\n    public void testComplexExpression() {\n        String expression = \"3 + 5 * (2 - 8)\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"3\", \"+\", \"5\", \"*\", \"(\", \"2\", \"-\", \"8\", \")\"), result);\n    }\n\n    @Test\n    public void testNegativeNumbers() {\n        String expression = \"-1 + 4 - 5\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"-\", \"1\", \"+\", \"4\", \"-\", \"5\"), result);\n    }\n\n    @Test\n    public void testDecimals() {\n        String expression = \"3.5 + 2.1\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"3.5\", \"+\", \"2.1\"), result);\n    }\n\n    @Test\n    public void testOperatorsOnly() {\n        String expression = \"+ - * /\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"+\", \"-\", \"*\", \"/\"), result);\n    }\n\n    @Test\n    public void testEmptyExpression() {\n        String expression = \"\";\n        List<String> result = answer.parseExpression(expression);\n        assertTrue(result.isEmpty());\n    }\n\n    @Test\n    public void testSingleNumber() {\n        String expression = \"42\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"42\"), result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Parses a mathematical expression string into a list of tokens.\n * This method identifies both operands (numbers) and operators (+, -, *, /, etc.) \n * in the provided expression, and returns them in a list format.\n *\n * @param expression The mathematical expression to be parsed, represented as a String.\n *                   The expression can contain integers, decimal numbers, \n *                   and standard arithmetic operators, as well as parentheses.\n * @return A List<String> containing the tokens identified in the expression. \n *         The list will include both operands and operators in the order they appear.\n */\npublic List<String> parseExpression(String expression) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 633, "code_type": "method", "original_language": "java", "question_type": "Data processing and transformation", "summary": "Read the CSV file and parse each line into a list of strings\n", "language_version_list": {"python": {"code_signature": "import csv\nfrom typing import List\n\n\ndef read_csv(file_path: str) -> List[List[str]]:\n    \"\"\"\n    Reads a CSV file and parses each line into a list of strings.\n\n    Args:\n        file_path (str): The path to the CSV file.\n\n    Returns:\n        List[List[str]]: A list of string lists, where each list represents a line from the CSV.\n    \"\"\"\n", "test_code": "import os\nimport unittest\n\n\nclass TestAnswer(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary CSV file for testing\n        self.test_file_path = 'test.csv'\n        sample_csv_content = \"Name,Age,Location\\n\" + \\\n                             \"Alice,30,New York\\n\" + \\\n                             \"Bob,25,Los Angeles\\n\" + \\\n                             \"Charlie,35,Chicago\\n\"\n        with open(self.test_file_path, 'w') as file:\n            file.write(sample_csv_content)\n\n    def test_read_valid_csv(self):\n        result = read_csv(self.test_file_path)\n        self.assertEqual(len(result), 4)  # 4 lines including the header\n        self.assertEqual(result[0], [\"Name\", \"Age\", \"Location\"])  # Check header\n        self.assertEqual(result[1], [\"Alice\", \"30\", \"New York\"])\n        self.assertEqual(result[2], [\"Bob\", \"25\", \"Los Angeles\"])\n        self.assertEqual(result[3], [\"Charlie\", \"35\", \"Chicago\"])\n\n    def test_read_empty_csv(self):\n        # Create an empty CSV file\n        with open(self.test_file_path, 'w') as file:\n            file.write(\"\")\n        result = read_csv(self.test_file_path)\n        self.assertTrue(len(result) == 0)  # Expecting an empty list\n\n    def test_read_csv_with_quotes(self):\n        # Write CSV content with quoted fields\n        content_with_quotes = '\"Name\",\"Age\",\"Location\"\\n' + \\\n                              '\"Alice\",\"30\",\"New York\"\\n' + \\\n                              '\"Bob\",\"25\",\"Los Angeles\"\\n'\n        with open(self.test_file_path, 'w') as file:\n            file.write(content_with_quotes)\n        result = read_csv(self.test_file_path)\n        self.assertEqual(len(result), 3)  # 3 lines including the header\n        self.assertEqual(result[0], ['Name', 'Age', 'Location'])\n\n    def test_read_invalid_csv_file(self):\n        with self.assertRaises(FileNotFoundError):\n            read_csv('non_existent_file.csv')\n\n    def test_read_csv_with_different_delimiters(self):\n        # Write CSV content with semicolons instead of commas\n        content_with_semicolons = \"Name;Age;Location\\n\" + \\\n                                  \"Alice;30;New York\\n\" + \\\n                                  \"Bob;25;Los Angeles\\n\"\n        with open(self.test_file_path, 'w') as file:\n            file.write(content_with_semicolons)\n        result = read_csv(self.test_file_path)\n        self.assertEqual(len(result), 3)  # Expecting 3 lines\n        self.assertEqual(result[0], [\"Name;Age;Location\"])\n\n    def tearDown(self):\n        # Clean up: remove test file after tests\n        try:\n            os.remove(self.test_file_path)\n        except FileNotFoundError:\n            pass\n", "prompt": "please write a python function , the function signature as below import csv\nfrom typing import List\n\n\ndef read_csv(file_path: str) -> List[List[str]]:\n    \"\"\"\n    Reads a CSV file and parses each line into a list of strings.\n\n    Args:\n        file_path (str): The path to the CSV file.\n\n    Returns:\n        List[List[str]]: A list of string lists, where each list represents a line from the CSV.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Reads a CSV file and parses each line into a list of strings.\n *\n * @param {string} filePath - The path to the CSV file.\n * @returns {Array<Array<string>>} A list of string lists, where each list represents a line from the CSV.\n */\nasync function readCsv(filePath) {}", "test_code": "describe('TestAnswer', () => {\n    const testFilePath = 'test.csv';\n\n    beforeAll(() => {\n        // Create a temporary CSV file for testing\n        const sampleCsvContent = \"Name,Age,Location\\n\" +\n                                  \"Alice,30,New York\\n\" +\n                                  \"Bob,25,Los Angeles\\n\" +\n                                  \"Charlie,35,Chicago\\n\";\n        fs.writeFileSync(testFilePath, sampleCsvContent);\n    });\n\n    test('read valid CSV', async () => {\n        const result = await readCsv(testFilePath);\n        expect(result.length).toBe(4);  // 4 lines including the header\n        expect(result[0]).toEqual([\"Name\", \"Age\", \"Location\"]);  // Check header\n        expect(result[1]).toEqual([\"Alice\", \"30\", \"New York\"]);\n        expect(result[2]).toEqual([\"Bob\", \"25\", \"Los Angeles\"]);\n        expect(result[3]).toEqual([\"Charlie\", \"35\", \"Chicago\"]);\n    });\n\n    test('read empty CSV', async () => {\n        // Create an empty CSV file\n        fs.writeFileSync(testFilePath, \"\");\n        const result = await readCsv(testFilePath);\n        expect(result.length).toBe(0);  // Expecting an empty list\n    });\n\n    test('read CSV with quotes', async () => {\n        // Write CSV content with quoted fields\n        const contentWithQuotes = '\"Name\",\"Age\",\"Location\"\\n' +\n                                   '\"Alice\",\"30\",\"New York\"\\n' +\n                                   '\"Bob\",\"25\",\"Los Angeles\"\\n';\n        fs.writeFileSync(testFilePath, contentWithQuotes);\n        const result = await readCsv(testFilePath);\n        expect(result.length).toBe(3);  // 3 lines including the header\n        expect(result[0]).toEqual(['Name', 'Age', 'Location']);\n    });\n\n    test('read invalid CSV file', async () => {\n        await expect(readCsv('non_existent_file.csv')).rejects.toThrow(Error);\n    });\n\n    test('read CSV with different delimiters', async () => {\n        // Write CSV content with semicolons instead of commas\n        const contentWithSemicolons = \"Name;Age;Location\\n\" +\n                                       \"Alice;30;New York\\n\" +\n                                       \"Bob;25;Los Angeles\\n\";\n        fs.writeFileSync(testFilePath, contentWithSemicolons);\n        const result = await readCsv(testFilePath);\n        expect(result.length).toBe(3);  // Expecting 3 lines\n        expect(result[0]).toEqual([\"Name;Age;Location\"]);\n    });\n\n    afterAll(() => {\n        // Clean up: remove test file after tests\n        try {\n            fs.unlinkSync(testFilePath);\n        } catch (err) {\n            // Handle error if necessary\n        }\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Reads a CSV file and parses each line into a list of strings.\n *\n * @param {string} filePath - The path to the CSV file.\n * @returns {Array<Array<string>>} A list of string lists, where each list represents a line from the CSV.\n */\nasync function readCsv(filePath) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Reads a CSV file and parses each line into a list of strings.\n *\n * @param filePath - The path to the CSV file.\n * @returns A list of string arrays, where each array represents a line from the CSV.\n */\nfunction readCsv(filePath: string): Promise<string[][]> {}", "test_code": "import * as fs from 'fs';\n\ndescribe('TestAnswer', () => {\n    const testFilePath = 'test.csv';\n\n    beforeEach(() => {\n        // Create a temporary CSV file for testing\n        const sampleCsvContent = \"Name,Age,Location\\n\" +\n                                  \"Alice,30,New York\\n\" +\n                                  \"Bob,25,Los Angeles\\n\" +\n                                  \"Charlie,35,Chicago\\n\";\n        fs.writeFileSync(testFilePath, sampleCsvContent);\n    });\n\n    test('read valid CSV', async () => {\n        const result = await readCsv(testFilePath);\n        expect(result.length).toBe(4);  // 4 lines including the header\n        expect(result[0]).toEqual([\"Name\", \"Age\", \"Location\"]);  // Check header\n        expect(result[1]).toEqual([\"Alice\", \"30\", \"New York\"]);\n        expect(result[2]).toEqual([\"Bob\", \"25\", \"Los Angeles\"]);\n        expect(result[3]).toEqual([\"Charlie\", \"35\", \"Chicago\"]);\n    });\n\n    test('read empty CSV', async () => {\n        // Create an empty CSV file\n        fs.writeFileSync(testFilePath, \"\");\n        const result = await readCsv(testFilePath);\n        expect(result.length).toBe(0);  // Expecting an empty list\n    });\n\n    test('read CSV with quotes', async () => {\n        // Write CSV content with quoted fields\n        const contentWithQuotes = '\"Name\",\"Age\",\"Location\"\\n' +\n                                  '\"Alice\",\"30\",\"New York\"\\n' +\n                                  '\"Bob\",\"25\",\"Los Angeles\"\\n';\n        fs.writeFileSync(testFilePath, contentWithQuotes);\n        const result = await readCsv(testFilePath);\n        expect(result.length).toBe(3);  // 3 lines including the header\n        expect(result[0]).toEqual(['Name', 'Age', 'Location']);\n    });\n\n    test('read invalid CSV file', async () => {\n        await expect(readCsv('non_existent_file.csv')).rejects.toThrowError();\n    });\n\n    test('read CSV with different delimiters', async () => {\n        // Write CSV content with semicolons instead of commas\n        const contentWithSemicolons = \"Name;Age;Location\\n\" +\n                                       \"Alice;30;New York\\n\" +\n                                       \"Bob;25;Los Angeles\\n\";\n        fs.writeFileSync(testFilePath, contentWithSemicolons);\n        const result = await readCsv(testFilePath);\n        expect(result.length).toBe(3);  // Expecting 3 lines\n        expect(result[0]).toEqual([\"Name;Age;Location\"]);\n    });\n\n    afterEach(() => {\n        // Clean up: remove test file after tests\n        try {\n            fs.unlinkSync(testFilePath);\n        } catch (error) {\n            // Handle the error if file does not exist\n        }\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Reads a CSV file and parses each line into a list of strings.\n *\n * @param filePath - The path to the CSV file.\n * @returns A list of string arrays, where each array represents a line from the CSV.\n */\nfunction readCsv(filePath: string): Promise<string[][]> {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads a CSV file and parses each line into a vector of strings.\n *\n * @param file_path The path to the CSV file.\n * @return A vector of vector of strings, where each vector represents a line from the CSV.\n */\nstd::vector<std::vector<std::string>> read_csv(const std::string& file_path);", "test_code": "TEST_CASE_METHOD(TestAnswer, \"test_read_valid_csv\") {\n    auto result = read_csv(test_file_path);\n    REQUIRE(result.size() == 4); // 4 lines including the header\n    REQUIRE(result[0] == std::vector<std::string>{\"Name\", \"Age\", \"Location\"}); // Check header\n    REQUIRE(result[1] == std::vector<std::string>{\"Alice\", \"30\", \"New York\"});\n    REQUIRE(result[2] == std::vector<std::string>{\"Bob\", \"25\", \"Los Angeles\"});\n    REQUIRE(result[3] == std::vector<std::string>{\"Charlie\", \"35\", \"Chicago\"});\n}\n\nTEST_CASE_METHOD(TestAnswer, \"test_read_empty_csv\") {\n    // Create an empty CSV file\n    std::ofstream file(test_file_path);\n    file << \"\";\n    file.close();\n    auto result = read_csv(test_file_path);\n    REQUIRE(result.empty()); // Expecting an empty list\n}\n\nTEST_CASE_METHOD(TestAnswer, \"test_read_csv_with_quotes\") {\n    // Write CSV content with quoted fields\n    std::string content_with_quotes = \"\\\"Name\\\",\\\"Age\\\",\\\"Location\\\"\\n\"\n                                       \"\\\"Alice\\\",\\\"30\\\",\\\"New York\\\"\\n\"\n                                       \"\\\"Bob\\\",\\\"25\\\",\\\"Los Angeles\\\"\\n\";\n    std::ofstream file(test_file_path);\n    file << content_with_quotes;\n    file.close();\n    auto result = read_csv(test_file_path);\n    REQUIRE(result.size() == 3); // 3 lines including the header\n    REQUIRE(result[0] == std::vector<std::string>{\"Name\", \"Age\", \"Location\"});\n}\n\nTEST_CASE(\"test_read_invalid_csv_file\") {\n    REQUIRE_THROWS_AS(read_csv(\"non_existent_file.csv\"), std::ifstream::failure);\n}\n\nTEST_CASE_METHOD(TestAnswer, \"test_read_csv_with_different_delimiters\") {\n    // Write CSV content with semicolons instead of commas\n    std::string content_with_semicolons = \"Name;Age;Location\\n\"\n                                           \"Alice;30;New York\\n\"\n                                           \"Bob;25;Los Angeles\\n\";\n    std::ofstream file(test_file_path);\n    file << content_with_semicolons;\n    file.close();\n    auto result = read_csv(test_file_path);\n    REQUIRE(result.size() == 3); // Expecting 3 lines\n    REQUIRE(result[0] == std::vector<std::string>{\"Name;Age;Location\"});\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads a CSV file and parses each line into a vector of strings.\n *\n * @param file_path The path to the CSV file.\n * @return A vector of vector of strings, where each vector represents a line from the CSV.\n */\nstd::vector<std::vector<std::string>> read_csv(const std::string& file_path);", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads a CSV file and parses each line into a list of strings.\n *\n * @param filePath The path to the CSV file.\n * @return A list of string arrays, where each array represents a line from the CSV.\n * @throws IOException If there is an error reading the file.\n */\npublic List<List<String>> readCsv(String filePath) throws IOException {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.AfterEach;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\npublic class Tester {\n\n    private final Answer answer = new Answer();\n    private final String testFilePath = \"test.csv\";\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        // Create a temporary CSV file for testing\n        // Writing sample CSV content to the file\n        String sampleCsvContent = \"Name,Age,Location\\n\" +\n                \"Alice,30,New York\\n\" +\n                \"Bob,25,Los Angeles\\n\" +\n                \"Charlie,35,Chicago\\n\";\n        Files.write(Paths.get(testFilePath), sampleCsvContent.getBytes(), StandardOpenOption.CREATE);\n    }\n\n    @Test\n    public void testReadValidCsv() throws IOException {\n        List<List<String>> result = answer.readCsv(testFilePath);\n        assertEquals(4, result.size()); // 4 lines including the header\n        assertEquals(List.of(\"Name\", \"Age\", \"Location\"), result.get(0)); // Check header\n        assertEquals(List.of(\"Alice\", \"30\", \"New York\"), result.get(1));\n        assertEquals(List.of(\"Bob\", \"25\", \"Los Angeles\"), result.get(2));\n        assertEquals(List.of(\"Charlie\", \"35\", \"Chicago\"), result.get(3));\n    }\n\n    @Test\n    public void testReadEmptyCsv() throws IOException {\n        // Create an empty CSV file\n        Files.write(Paths.get(testFilePath), \"\".getBytes(), StandardOpenOption.TRUNCATE_EXISTING);\n        List<List<String>> result = answer.readCsv(testFilePath);\n        assertTrue(result.isEmpty()); // Expecting an empty list\n    }\n\n\n    @Test\n    public void testReadCsvWithQuotes() throws IOException {\n        // Write CSV content with quoted fields\n        String contentWithQuotes = \"\\\"Name\\\",\\\"Age\\\",\\\"Location\\\"\\n\" +\n                \"\\\"Alice\\\",\\\"30\\\",\\\"New York\\\"\\n\" +\n                \"\\\"Bob\\\",\\\"25\\\",\\\"Los Angeles\\\"\\n\";\n        Files.write(Paths.get(testFilePath), contentWithQuotes.getBytes(), StandardOpenOption.TRUNCATE_EXISTING);\n        List<List<String>> result = answer.readCsv(testFilePath);\n        assertEquals(3, result.size()); // 3 lines including the header\n        assertEquals(List.of(\"\\\"Name\\\"\", \"\\\"Age\\\"\", \"\\\"Location\\\"\"), result.get(0));\n    }\n\n    @Test\n    public void testReadInvalidCsvFile() {\n        // Attempt to read a non-existent file and assert that a FileNotFoundException is thrown\n        assertThrows(Exception.class, () -> {\n            answer.readCsv(\"non_existent_file.csv\");\n        });\n    }\n\n    @Test\n    public void testReadCsvWithDifferentDelimiters() throws IOException {\n        // Write CSV content with semicolons instead of commas\n        String contentWithSemicolons = \"Name;Age;Location\\n\" +\n                \"Alice;30;New York\\n\" +\n                \"Bob;25;Los Angeles\\n\";\n        Files.write(Paths.get(testFilePath), contentWithSemicolons.getBytes(), StandardOpenOption.TRUNCATE_EXISTING);\n        // Modify the readCsv function to handle semicolons if necessary.\n        List<List<String>> result = answer.readCsv(testFilePath);\n        assertEquals(3, result.size()); // Expecting 3 lines\n        assertEquals(List.of(\"Name;Age;Location\"), result.get(0));\n    }\n\n    // Clean up after tests (Optional)\n    @AfterEach\n    public void tearDown() throws IOException {\n        Files.deleteIfExists(Paths.get(testFilePath)); // Remove test file after tests\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Reads a CSV file and parses each line into a list of strings.\n *\n * @param filePath The path to the CSV file.\n * @return A list of string arrays, where each array represents a line from the CSV.\n * @throws IOException If there is an error reading the file.\n */\npublic List<List<String>> readCsv(String filePath) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}
