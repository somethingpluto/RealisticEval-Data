{"task_id": 140, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units\n", "language_version_list": {"python": {"code_signature": "from datetime import datetime\nfrom typing import Tuple\n\n\ndef get_time_since_born_until_now(birth_date: datetime) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n    Calculate the years, months, days, hours, and minutes that have passed\n    from the birth date to the current date and return them as a tuple.\n\n    Args:\n        birth_date (datetime): The birth date as a datetime object.\n\n    Returns:\n        Tuple[int, int, int, int, int]: A tuple containing the values of years, months, days, hours, and minutes.\n    \"\"\"\n", "test_code": "import unittest\nfrom datetime import datetime, timedelta\n\n# Assuming the function get_time_since_born_until_now is defined here\n\nclass TestGetTimeSinceBornUntilNow(unittest.TestCase):\n\n    def setUp(self):\n        # Set the system time to a fixed date\n        self.fixed_time = datetime(2024, 8, 23, 15, 45)\n        # Mock datetime.now() for the tests\n        self.original_datetime_now = datetime.now\n\n        def mock_datetime_now():\n            return self.fixed_time\n        \n        datetime.now = mock_datetime_now\n\n    def tearDown(self):\n        # Restore original datetime.now\n        datetime.now = self.original_datetime_now\n\n    def test_typical_birth_date(self):\n        birth_date = datetime(1990, 5, 15, 10, 30)\n        result = get_time_since_born_until_now(birth_date)\n        self.assertEqual(result, (34, 3, 8, 5, 15))  # 34 years, 3 months, 8 days, 5 hours, 15 minutes\n\n    def test_recent_birth_date(self):\n        birth_date = datetime(2024, 8, 20, 12, 0)\n        result = get_time_since_born_until_now(birth_date)\n        self.assertEqual(result, (0, 0, 3, 3, 45))  # 3 days, 3 hours, 45 minutes\n\n    def test_edge_case_end_of_year(self):\n        birth_date = datetime(2023, 12, 31, 23, 59)\n        result = get_time_since_born_until_now(birth_date)\n        self.assertEqual(result, (0, 7, 22, 15, 46))  # 7 months, 22 days, 15 hours, 46 minutes\n\n    def test_birthday_earlier_in_month(self):\n        birth_date = datetime(2024, 8, 1, 0, 0)\n        result = get_time_since_born_until_now(birth_date)\n        self.assertEqual(result, (0, 0, 22, 15, 45))  # 22 days, 15 hours, 45 minutes\n\n    def test_birthday_later_in_year_before_month(self):\n        birth_date = datetime(2024, 1, 1, 1, 0)\n        result = get_time_since_born_until_now(birth_date)\n        self.assertEqual(result, (0, 7, 22, 14, 45))  # 7 months, 22 days, 14 hours, 45 minutes\n\n    def test_birthday_previous_month(self):\n        birth_date = datetime(2024, 7, 30, 10, 0)\n        result = get_time_since_born_until_now(birth_date)\n        self.assertEqual(result, (0, 0, 24, 5, 45))  # 24 days, 5 hours, 45 minutes", "prompt": "please write a python function , the function signature as below from datetime import datetime\nfrom typing import Tuple\n\n\ndef get_time_since_born_until_now(birth_date: datetime) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n    Calculate the years, months, days, hours, and minutes that have passed\n    from the birth date to the current date and return them as a tuple.\n\n    Args:\n        birth_date (datetime): The birth date as a datetime object.\n\n    Returns:\n        Tuple[int, int, int, int, int]: A tuple containing the values of years, months, days, hours, and minutes.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units.\n * @param birthDate\n */\nfunction getTimeSinceBornUntilNow(birthDate) {\n\n}", "test_code": "describe('getTimeSinceBornUntilNow', () => {\n    beforeAll(() => {\n        jest.useFakeTimers().setSystemTime(new Date('2024-08-23T15:45:00'));\n    });\n\n    afterAll(() => {\n        jest.useRealTimers();\n    });\n\n    test('should return the correct difference for a typical birth date', () => {\n        const birthDate = new Date('1990-05-15T10:30:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([34, 3, 8, 5, 15]); // Example output: 34 years, 3 months, 8 days, 5 hours, 15 minutes\n    });\n\n    test('should return the correct difference for a recent birth date', () => {\n        const birthDate = new Date('2024-08-20T12:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 0, 3, 3, 45]); // 3 days, 3 hours, 45 minutes\n    });\n\n    test('should handle edge cases at the end of the year', () => {\n        const birthDate = new Date('2023-12-31T23:59:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 7, 22, 15, 46]); // 7 months, 22 days, 15 hours, 46 minutes\n    });\n\n    test('should handle birthdays earlier in the current month', () => {\n        const birthDate = new Date('2024-08-01T00:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 0, 22, 15, 45]); // 22 days, 15 hours, 45 minutes\n    });\n\n    test('should handle birthdays later in the current year before the current month', () => {\n        const birthDate = new Date('2024-01-01T01:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 7, 22, 14, 45]); // 7 months, 22 days, 14 hours, 45 minutes\n    });\n\n    test('should handle birthdays in the previous month of the same year', () => {\n        const birthDate = new Date('2024-07-30T10:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 0, 24, 5, 45]); // 24 days, 5 hours, 45 minutes\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units.\n * @param birthDate\n */\nfunction getTimeSinceBornUntilNow(birthDate) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units\n * @param birthDate\n */\nfunction getTimeSinceBornUntilNow(birthDate: Date): [number, number, number, number, number] {\n\n}", "test_code": "describe('getTimeSinceBornUntilNow', () => {\n    beforeAll(() => {\n        jest.useFakeTimers().setSystemTime(new Date('2024-08-23T15:45:00'));\n    });\n\n    afterAll(() => {\n        jest.useRealTimers();\n    });\n\n    test('should return the correct difference for a typical birth date', () => {\n        const birthDate = new Date('1990-05-15T10:30:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([34, 3, 8, 5, 15]); // Example output: 34 years, 3 months, 8 days, 5 hours, 15 minutes\n    });\n\n    test('should return the correct difference for a recent birth date', () => {\n        const birthDate = new Date('2024-08-20T12:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 0, 3, 3, 45]); // 3 days, 3 hours, 45 minutes\n    });\n\n    test('should handle edge cases at the end of the year', () => {\n        const birthDate = new Date('2023-12-31T23:59:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 7, 22, 15, 46]); // 7 months, 22 days, 15 hours, 46 minutes\n    });\n\n\n    test('should handle birthdays earlier in the current month', () => {\n        const birthDate = new Date('2024-08-01T00:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 0, 22, 15, 45]); // 22 days, 15 hours, 45 minutes\n    });\n\n    test('should handle birthdays later in the current year before the current month', () => {\n        const birthDate = new Date('2024-01-01T01:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 7, 22, 14, 45]); // 7 months, 22 days, 14 hours, 45 minutes\n    });\n\n    test('should handle birthdays in the previous month of the same year', () => {\n        const birthDate = new Date('2024-07-30T10:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 0, 24, 5, 45]); // 24 days, 5 hours, 45 minutes\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units\n * @param birthDate\n */\nfunction getTimeSinceBornUntilNow(birthDate: Date): [number, number, number, number, number] {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units.\n * @param birthDate The birth date.\n * @return An array containing years, months, days, hours, and minutes.\n */\nstd::array<int, 5> getTimeSinceBornUntilNow(const std::tm& birthDate) {}", "test_code": "TEST_CASE(\"getTimeSinceBornUntilNow\") {\n    // Mocking system time for testing\n    std::tm mockTime = {};\n    strptime(\"2024-08-23 15:45:00\", \"%Y-%m-%d %H:%M:%S\", &mockTime);\n    time_t systemTime = mktime(&mockTime);\n    std::tm* oldTime = localtime(&systemTime);\n\n    SECTION(\"should return the correct difference for a typical birth date\") {\n        std::tm birthDate = {};\n        strptime(\"1990-05-15 10:30:00\", \"%Y-%m-%d %H:%M:%S\", &birthDate);\n        auto result = getTimeSinceBornUntilNow(birthDate);\n        REQUIRE(result == std::array<int, 5>{34, 3, 8, 5, 15});\n    }\n\n    SECTION(\"should return the correct difference for a recent birth date\") {\n        std::tm birthDate = {};\n        strptime(\"2024-08-20 12:00:00\", \"%Y-%m-%d %H:%M:%S\", &birthDate);\n        auto result = getTimeSinceBornUntilNow(birthDate);\n        REQUIRE(result == std::array<int, 5>{0, 0, 3, 3, 45});\n    }\n\n    SECTION(\"should handle edge cases at the end of the year\") {\n        std::tm birthDate = {};\n        strptime(\"2023-12-31 23:59:00\", \"%Y-%m-%d %H:%M:%S\", &birthDate);\n        auto result = getTimeSinceBornUntilNow(birthDate);\n        REQUIRE(result == std::array<int, 5>{0, 7, 22, 15, 46});\n    }\n\n    SECTION(\"should handle birthdays earlier in the current month\") {\n        std::tm birthDate = {};\n        strptime(\"2024-08-01 00:00:00\", \"%Y-%m-%d %H:%M:%S\", &birthDate);\n        auto result = getTimeSinceBornUntilNow(birthDate);\n        REQUIRE(result == std::array<int, 5>{0, 0, 22, 15, 45});\n    }\n\n    SECTION(\"should handle birthdays later in the current year before the current month\") {\n        std::tm birthDate = {};\n        strptime(\"2024-01-01 01:00:00\", \"%Y-%m-%d %H:%M:%S\", &birthDate);\n        auto result = getTimeSinceBornUntilNow(birthDate);\n        REQUIRE(result == std::array<int, 5>{0, 7, 22, 14, 45});\n    }\n\n    SECTION(\"should handle birthdays in the previous month of the same year\") {\n        std::tm birthDate = {};\n        strptime(\"2024-07-30 10:00:00\", \"%Y-%m-%d %H:%M:%S\", &birthDate);\n        auto result = getTimeSinceBornUntilNow(birthDate);\n        REQUIRE(result == std::array<int, 5>{0, 0, 24, 5, 45});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units.\n * @param birthDate The birth date.\n * @return An array containing years, months, days, hours, and minutes.\n */\nstd::array<int, 5> getTimeSinceBornUntilNow(const std::tm& birthDate) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units.\n * @param birthDate the date of birth\n * @return an array containing years, months, days, hours, and minutes\n */\npublic static int[] getTimeSinceBornUntilNow(Date birthDate) {\n}", "test_code": "\npackage org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertArrayEquals;\n\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.time.temporal.ChronoUnit;\n\npublic class Tester {\n\n    private LocalDateTime fixedTime;\n    private LocalDateTime originalNow;\n\n    @Before\n    public void setUp() {\n        // Set the system time to a fixed date\n        fixedTime = LocalDateTime.of(2024, 8, 23, 15, 45);\n        originalNow = LocalDateTime.now();\n\n        // Assuming we can mock or replace LocalDateTime.now() in the method being tested.\n        // If you can't mock the system time directly, consider passing a clock or fixed date to the method.\n    }\n\n    @After\n    public void tearDown() {\n        // Restore original time if needed\n        // This would typically be done through a static mock or resetting the context if using a library.\n    }\n\n    private long[] getTimeSinceBornUntilNow(LocalDateTime birthDate) {\n        // This is where you would implement or call your actual function.\n        // For demonstration, let's assume it's implemented correctly.\n        LocalDateTime now = fixedTime; // Use the fixed time for testing\n\n        // Calculate the time since birth\n        long years = ChronoUnit.YEARS.between(birthDate, now);\n        long months = ChronoUnit.MONTHS.between(birthDate.plusYears(years), now);\n        long days = ChronoUnit.DAYS.between(birthDate.plusYears(years).plusMonths(months), now);\n        long hours = ChronoUnit.HOURS.between(birthDate.plusYears(years).plusMonths(months).plusDays(days), now);\n        long minutes = ChronoUnit.MINUTES.between(birthDate.plusYears(years).plusMonths(months).plusDays(days).plusHours(hours), now);\n\n        return new long[]{years, months, days, hours, minutes};\n    }\n\n    @Test\n    public void testTypicalBirthDate() {\n        LocalDateTime birthDate = LocalDateTime.of(1990, 5, 15, 10, 30);\n        long[] result = getTimeSinceBornUntilNow(birthDate);\n        assertArrayEquals(new long[]{34, 3, 8, 5, 15}, result); // 34 years, 3 months, 8 days, 5 hours, 15 minutes\n    }\n\n    @Test\n    public void testRecentBirthDate() {\n        LocalDateTime birthDate = LocalDateTime.of(2024, 8, 20, 12, 0);\n        long[] result = getTimeSinceBornUntilNow(birthDate);\n        assertArrayEquals(new long[]{0, 0, 3, 3, 45}, result); // 3 days, 3 hours, 45 minutes\n    }\n\n    @Test\n    public void testEdgeCaseEndOfYear() {\n        LocalDateTime birthDate = LocalDateTime.of(2023, 12, 31, 23, 59);\n        long[] result = getTimeSinceBornUntilNow(birthDate);\n        assertArrayEquals(new long[]{0, 7, 22, 15, 46}, result); // 7 months, 22 days, 15 hours, 46 minutes\n    }\n\n    @Test\n    public void testBirthdayEarlierInMonth() {\n        LocalDateTime birthDate = LocalDateTime.of(2024, 8, 1, 0, 0);\n        long[] result = getTimeSinceBornUntilNow(birthDate);\n        assertArrayEquals(new long[]{0, 0, 22, 15, 45}, result); // 22 days, 15 hours, 45 minutes\n    }\n\n    @Test\n    public void testBirthdayLaterInYearBeforeMonth() {\n        LocalDateTime birthDate = LocalDateTime.of(2024, 1, 1, 1, 0);\n        long[] result = getTimeSinceBornUntilNow(birthDate);\n        assertArrayEquals(new long[]{0, 7, 22, 14, 45}, result); // 7 months, 22 days, 14 hours, 45 minutes\n    }\n\n    @Test\n    public void testBirthdayPreviousMonth() {\n        LocalDateTime birthDate = LocalDateTime.of(2024, 7, 30, 10, 0);\n        long[] result = getTimeSinceBornUntilNow(birthDate);\n        assertArrayEquals(new long[]{0, 0, 24, 5, 45}, result); // 24 days, 5 hours, 45 minutes\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units.\n * @param birthDate the date of birth\n * @return an array containing years, months, days, hours, and minutes\n */\npublic static int[] getTimeSinceBornUntilNow(Date birthDate) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 141, "code_type": "method", "original_language": "typescript", "question_type": "Algorithm and data structure", "summary": "implement a generic compareArrays function that compares the elements of two arrays to each other", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Compares two arrays to determine if they contain the same unique elements, irrespective of order.\n *\n * @param {Array} arr1 - The first array to compare. Elements can be of any type.\n * @param {Array} arr2 - The second array to compare. Elements should be of the same type as the first array.\n * @returns {boolean} - Returns true if both arrays contain the same unique elements, otherwise returns false.\n *\n */\nfunction compareArrays(arr1, arr2) {\n}", "test_code": "describe('compareArrays', () => {\n    test('should return true for identical arrays with same order', () => {\n        const arr1 = [1, 2, 3];\n        const arr2 = [1, 2, 3];\n        expect(compareArrays(arr1, arr2)).toBe(true);\n    });\n\n    test('should return true for identical arrays with different order', () => {\n        const arr1 = [3, 2, 1];\n        const arr2 = [1, 2, 3];\n        expect(compareArrays(arr1, arr2)).toBe(true);\n    });\n\n    test('should return false for arrays with different elements', () => {\n        const arr1 = [1, 2, 3];\n        const arr2 = [4, 5, 6];\n        expect(compareArrays(arr1, arr2)).toBe(false);\n    });\n\n    test('should return false for arrays with different lengths', () => {\n        const arr1 = [1, 2, 3];\n        const arr2 = [1, 2];\n        expect(compareArrays(arr1, arr2)).toBe(false);\n    });\n\n    test('should return true for arrays with duplicate elements but same unique set', () => {\n        const arr1 = [1, 1, 2, 3, 3];\n        const arr2 = [3, 2, 1, 1];\n        expect(compareArrays(arr1, arr2)).toBe(true);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Compares two arrays to determine if they contain the same unique elements, irrespective of order.\n *\n * @param {Array} arr1 - The first array to compare. Elements can be of any type.\n * @param {Array} arr2 - The second array to compare. Elements should be of the same type as the first array.\n * @returns {boolean} - Returns true if both arrays contain the same unique elements, otherwise returns false.\n *\n */\nfunction compareArrays(arr1, arr2) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Compares two arrays to determine if they contain the same unique elements, irrespective of order.\n *\n * @param {Array<T>} arr1 - The first array to compare. Elements can be of any type T.\n * @param {Array<T>} arr2 - The second array to compare. Elements should be of the same type as the first array.\n * @returns {boolean} - Returns true if both arrays contain the same unique elements, otherwise returns false.\n *\n * @template T - The type of the elements in the arrays.\n *\n */\nfunction compareArrays<T>(arr1: Array<T>, arr2: Array<T>): boolean {\n}", "test_code": "describe('compareArrays', () => {\n    test('should return true for identical arrays with same order', () => {\n        const arr1 = [1, 2, 3];\n        const arr2 = [1, 2, 3];\n        expect(compareArrays(arr1, arr2)).toBe(true);\n    });\n\n    test('should return true for identical arrays with different order', () => {\n        const arr1 = [3, 2, 1];\n        const arr2 = [1, 2, 3];\n        expect(compareArrays(arr1, arr2)).toBe(true);\n    });\n\n    test('should return false for arrays with different elements', () => {\n        const arr1 = [1, 2, 3];\n        const arr2 = [4, 5, 6];\n        expect(compareArrays(arr1, arr2)).toBe(false);\n    });\n\n    test('should return false for arrays with different lengths', () => {\n        const arr1 = [1, 2, 3];\n        const arr2 = [1, 2];\n        expect(compareArrays(arr1, arr2)).toBe(false);\n    });\n\n    test('should return true for arrays with duplicate elements but same unique set', () => {\n        const arr1 = [1, 1, 2, 3, 3];\n        const arr2 = [3, 2, 1, 1];\n        expect(compareArrays(arr1, arr2)).toBe(true);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Compares two arrays to determine if they contain the same unique elements, irrespective of order.\n *\n * @param {Array<T>} arr1 - The first array to compare. Elements can be of any type T.\n * @param {Array<T>} arr2 - The second array to compare. Elements should be of the same type as the first array.\n * @returns {boolean} - Returns true if both arrays contain the same unique elements, otherwise returns false.\n *\n * @template T - The type of the elements in the arrays.\n *\n */\nfunction compareArrays<T>(arr1: Array<T>, arr2: Array<T>): boolean {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "/**\n * Compares two arrays to determine if they contain the same unique elements, irrespective of order.\n *\n * @param arr1 - The first array to compare. Elements can be of any type T.\n * @param arr2 - The second array to compare. Elements should be of the same type as the first array.\n * @return Returns true if both arrays contain the same unique elements, otherwise returns false.\n *\n * @param <T> - The type of the elements in the arrays.\n */\npublic static <T> boolean compareArrays(T[] arr1, T[] arr2) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testIdenticalArraysSameOrder() {\n        Integer[] arr1 = {1, 2, 3};\n        Integer[] arr2 = {1, 2, 3};\n        assertTrue(compareArrays(arr1, arr2));\n    }\n\n    @Test\n    public void testIdenticalArraysDifferentOrder() {\n        Integer[] arr1 = {3, 2, 1};\n        Integer[] arr2 = {1, 2, 3};\n        assertTrue(compareArrays(arr1, arr2));\n    }\n\n    @Test\n    public void testDifferentElements() {\n        Integer[] arr1 = {1, 2, 3};\n        Integer[] arr2 = {4, 5, 6};\n        assertFalse(compareArrays(arr1, arr2));\n    }\n\n    @Test\n    public void testDifferentLengths() {\n        Integer[] arr1 = {1, 2, 3};\n        Integer[] arr2 = {1, 2};\n        assertFalse(compareArrays(arr1, arr2));\n    }\n\n    @Test\n    public void testDuplicateElementsSameUniqueSet() {\n        Integer[] arr1 = {1, 1, 2, 3, 3};\n        Integer[] arr2 = {3, 2, 1, 1};\n        assertTrue(compareArrays(arr1, arr2));\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Compares two arrays to determine if they contain the same unique elements, irrespective of order.\n *\n * @param arr1 - The first array to compare. Elements can be of any type T.\n * @param arr2 - The second array to compare. Elements should be of the same type as the first array.\n * @return Returns true if both arrays contain the same unique elements, otherwise returns false.\n *\n * @param <T> - The type of the elements in the arrays.\n */\npublic static <T> boolean compareArrays(T[] arr1, T[] arr2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 142, "code_type": "method", "original_language": "typescript", "question_type": "Program input code", "summary": "convert a string with hump nomenclature to a string with spaces and capitalize the initial letter\n", "language_version_list": {"python": {"code_signature": "def camel_case_to_capitalized_with_spaces(input: str) -> str:\n    \"\"\"\n    Initialize the camelCase string to a format where only the first letter is capitalized and there are spaces between words.\n    Args:\n        input_string (str): The camelCase string to be converted.\n\n    Returns:\n        str: The converted string with spaces and initial capitalization.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCamelCaseConversion(unittest.TestCase):\n\n    def test_simple_camel_case(self):\n        input = \"thisIsTest\"\n        expected_output = \"This is test\"\n        self.assertEqual(camel_case_to_capitalized_with_spaces(input), expected_output)\n\n    def test_single_word_lowercase(self):\n        input = \"example\"\n        expected_output = \"Example\"\n        self.assertEqual(camel_case_to_capitalized_with_spaces(input), expected_output)\n\n    def test_multiple_uppercase_letters(self):\n        input = \"thisIsAnExampleString\"\n        expected_output = \"This is an example string\"\n        self.assertEqual(camel_case_to_capitalized_with_spaces(input), expected_output)\n\n    def test_single_uppercase_letter(self):\n        input = \"aSingleUppercaseLetterX\"\n        expected_output = \"A single uppercase letter x\"\n        self.assertEqual(camel_case_to_capitalized_with_spaces(input), expected_output)\n\n    def test_already_capitalized_string(self):\n        input = \"AlreadyCapitalized\"\n        expected_output = \"Already capitalized\"\n        self.assertEqual(camel_case_to_capitalized_with_spaces(input), expected_output)", "prompt": "please write a python function , the function signature as below def camel_case_to_capitalized_with_spaces(input: str) -> str:\n    \"\"\"\n    Initialize the camelCase string to a format where only the first letter is capitalized and there are spaces between words.\n    Args:\n        input_string (str): The camelCase string to be converted.\n\n    Returns:\n        str: The converted string with spaces and initial capitalization.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n * For example:\n *      input: \"thisIsTest\"\n *      output: \"This is test\"\n *\n * @param input The camelCase string to be converted.\n * @returns The converted string with spaces and initial capitalization.\n */\nfunction camelCaseToCapitalizedWithSpaces(input) {}", "test_code": "describe('convertCamelCaseToSentence', () => {\n    test('should convert a simple camelCase string to a sentence', () => {\n        const input = \"thisIsTest\";\n        const expectedOutput = \"This is test\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle single word starting with lowercase', () => {\n        const input = \"example\";\n        const expectedOutput = \"Example\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a camelCase string with multiple uppercase letters', () => {\n        const input = \"thisIsAnExampleString\";\n        const expectedOutput = \"This is an example string\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a single uppercase letter', () => {\n        const input = \"aSingleUppercaseLetterX\";\n        const expectedOutput = \"A single uppercase letter x\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle an already capitalized string', () => {\n        const input = \"AlreadyCapitalized\";\n        const expectedOutput = \"Already capitalized\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n * For example:\n *      input: \"thisIsTest\"\n *      output: \"This is test\"\n *\n * @param input The camelCase string to be converted.\n * @returns The converted string with spaces and initial capitalization.\n */\nfunction camelCaseToCapitalizedWithSpaces(input) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n * For example:\n *      input: \"thisIsTest\"\n *      output: \"This is test\"\n *\n * @param input The camelCase string to be converted.\n * @returns The converted string with spaces and initial capitalization.\n */\nfunction camelCaseToCapitalizedWithSpaces(input: string): string {\n}", "test_code": "describe('convertCamelCaseToSentence', () => {\n    test('should convert a simple camelCase string to a sentence', () => {\n        const input = \"thisIsTest\";\n        const expectedOutput = \"This is test\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle single word starting with lowercase', () => {\n        const input = \"example\";\n        const expectedOutput = \"Example\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a camelCase string with multiple uppercase letters', () => {\n        const input = \"thisIsAnExampleString\";\n        const expectedOutput = \"This is an example string\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a single uppercase letter', () => {\n        const input = \"aSingleUppercaseLetterX\";\n        const expectedOutput = \"A single uppercase letter x\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle an already capitalized string', () => {\n        const input = \"AlreadyCapitalized\";\n        const expectedOutput = \"Already capitalized\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n * For example:\n *      input: \"thisIsTest\"\n *      output: \"This is test\"\n *\n * @param input The camelCase string to be converted.\n * @returns The converted string with spaces and initial capitalization.\n */\nfunction camelCaseToCapitalizedWithSpaces(input: string): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n * For example:\n *      input: \"thisIsTest\"\n *      output: \"This is test\"\n *\n * @param input The camelCase string to be converted.\n * @returns The converted string with spaces and initial capitalization.\n */\nstd::string camelCaseToCapitalizedWithSpaces(const std::string& input) {\n    // Implementation goes here\n}", "test_code": "TEST_CASE(\"convertCamelCaseToSentence\") {\n    SECTION(\"should convert a simple camelCase string to a sentence\") {\n        std::string input = \"thisIsTest\";\n        std::string expectedOutput = \"This is test\";\n        REQUIRE(camelCaseToCapitalizedWithSpaces(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle single word starting with lowercase\") {\n        std::string input = \"example\";\n        std::string expectedOutput = \"Example\";\n        REQUIRE(camelCaseToCapitalizedWithSpaces(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle a camelCase string with multiple uppercase letters\") {\n        std::string input = \"thisIsAnExampleString\";\n        std::string expectedOutput = \"This is an example string\";\n        REQUIRE(camelCaseToCapitalizedWithSpaces(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle a single uppercase letter\") {\n        std::string input = \"aSingleUppercaseLetterX\";\n        std::string expectedOutput = \"A single uppercase letter x\";\n        REQUIRE(camelCaseToCapitalizedWithSpaces(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle an already capitalized string\") {\n        std::string input = \"AlreadyCapitalized\";\n        std::string expectedOutput = \"Already capitalized\";\n        REQUIRE(camelCaseToCapitalizedWithSpaces(input) == expectedOutput);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n * For example:\n *      input: \"thisIsTest\"\n *      output: \"This is test\"\n *\n * @param input The camelCase string to be converted.\n * @returns The converted string with spaces and initial capitalization.\n */\nstd::string camelCaseToCapitalizedWithSpaces(const std::string& input) {\n    // Implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n * For example:\n *      input: \"thisIsTest\"\n *      output: \"This is test\"\n *\n * @param input The camelCase string to be converted.\n * @return The converted string with spaces and initial capitalization.\n */\npublic static String camelCaseToCapitalizedWithSpaces(String input) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testConvertSimpleCamelCase() {\n        // Test for a simple camelCase string\n        String input = \"thisIsTest\";\n        String expectedOutput = \"This is test\";\n        assertEquals(expectedOutput, camelCaseToCapitalizedWithSpaces(input));\n    }\n\n    @Test\n    public void testConvertSingleLowercaseWord() {\n        // Test for a single word starting with lowercase\n        String input = \"example\";\n        String expectedOutput = \"Example\";\n        assertEquals(expectedOutput, camelCaseToCapitalizedWithSpaces(input));\n    }\n\n    @Test\n    public void testConvertCamelCaseWithMultipleUppercase() {\n        // Test for a camelCase string with multiple uppercase letters\n        String input = \"thisIsAnExampleString\";\n        String expectedOutput = \"This is an example string\";\n        assertEquals(expectedOutput, camelCaseToCapitalizedWithSpaces(input));\n    }\n\n    @Test\n    public void testConvertSingleUppercaseLetter() {\n        // Test for a single uppercase letter\n        String input = \"aSingleUppercaseLetterX\";\n        String expectedOutput = \"A single uppercase letter x\";\n        assertEquals(expectedOutput, camelCaseToCapitalizedWithSpaces(input));\n    }\n\n    @Test\n    public void testConvertAlreadyCapitalizedString() {\n        // Test for an already capitalized string\n        String input = \"AlreadyCapitalized\";\n        String expectedOutput = \"Already capitalized\";\n        assertEquals(expectedOutput, camelCaseToCapitalizedWithSpaces(input));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n * For example:\n *      input: \"thisIsTest\"\n *      output: \"This is test\"\n *\n * @param input The camelCase string to be converted.\n * @return The converted string with spaces and initial capitalization.\n */\npublic static String camelCaseToCapitalizedWithSpaces(String input) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 143, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "convert Arabic digits in the string to corresponding English digits\n", "language_version_list": {"python": {"code_signature": "def arabic_to_english_numbers(s: str) -> str:\n    \"\"\"\n    Converts Arabic digits in the string to corresponding English digits.\n\n    Args:\n        s (str): The input string containing Arabic digits.\n\n    Returns:\n        str: The string with Arabic digits converted to English digits.\n    \"\"\"", "test_code": "import unittest\nclass TestArabicToEnglishNumbers(unittest.TestCase):\n    \n    def test_convert_arabic_numerals_to_english_numerals(self):\n        input_str = \"\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660\"\n        expected_output = \"1234567890\"\n        self.assertEqual(arabic_to_english_numbers(input_str), expected_output)\n\n    def test_return_same_string_if_no_arabic_numerals(self):\n        input_str = \"Hello, World!\"\n        expected_output = \"Hello, World!\"\n        self.assertEqual(arabic_to_english_numbers(input_str), expected_output)\n\n    def test_handle_mixed_arabic_numerals_and_english_characters(self):\n        input_str = \"\u0631\u0642\u0645 \u0661\u0662\u0663 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\"\n        expected_output = \"\u0631\u0642\u0645 123 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\"\n        self.assertEqual(arabic_to_english_numbers(input_str), expected_output)\n\n    def test_handle_empty_string(self):\n        input_str = \"\"\n        expected_output = \"\"\n        self.assertEqual(arabic_to_english_numbers(input_str), expected_output)\n\n    def test_handle_string_with_mixed_arabic_and_english_numerals(self):\n        input_str = \"The number is \u0663\u0665\u0666 and 789.\"\n        expected_output = \"The number is 356 and 789.\"\n        self.assertEqual(arabic_to_english_numbers(input_str), expected_output)", "prompt": "please write a python function , the function signature as below def arabic_to_english_numbers(s: str) -> str:\n    \"\"\"\n    Converts Arabic digits in the string to corresponding English digits.\n\n    Args:\n        s (str): The input string containing Arabic digits.\n\n    Returns:\n        str: The string with Arabic digits converted to English digits.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * convert Arabic digits in the string to corresponding English digits\n * @param str\n */\nfunction arabicToEnglishNumbers(str) {\n\n}", "test_code": "describe('arabicToEnglishNumbers', () => {\n    test('should convert Arabic numerals to English numerals', () => {\n        const input = \"\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660\";\n        const expectedOutput = \"1234567890\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should return the same string if there are no Arabic numerals', () => {\n        const input = \"Hello, World!\";\n        const expectedOutput = \"Hello, World!\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a mix of Arabic numerals and English characters', () => {\n        const input = \"\u0631\u0642\u0645 \u0661\u0662\u0663 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\";\n        const expectedOutput = \"\u0631\u0642\u0645 123 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should handle empty string', () => {\n        const input = \"\";\n        const expectedOutput = \"\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a string with mixed Arabic and English numerals', () => {\n        const input = \"The number is \u0663\u0665\u0666 and 789.\";\n        const expectedOutput = \"The number is 356 and 789.\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * convert Arabic digits in the string to corresponding English digits\n * @param str\n */\nfunction arabicToEnglishNumbers(str) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * convert Arabic digits in the string to corresponding English digits\n * @param str\n */\nfunction arabicToEnglishNumbers(str: string): string {\n\n}", "test_code": "describe('arabicToEnglishNumbers', () => {\n    test('should convert Arabic numerals to English numerals', () => {\n        const input = \"\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660\";\n        const expectedOutput = \"1234567890\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should return the same string if there are no Arabic numerals', () => {\n        const input = \"Hello, World!\";\n        const expectedOutput = \"Hello, World!\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a mix of Arabic numerals and English characters', () => {\n        const input = \"\u0631\u0642\u0645 \u0661\u0662\u0663 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\";\n        const expectedOutput = \"\u0631\u0642\u0645 123 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should handle empty string', () => {\n        const input = \"\";\n        const expectedOutput = \"\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a string with mixed Arabic and English numerals', () => {\n        const input = \"The number is \u0663\u0665\u0666 and 789.\";\n        const expectedOutput = \"The number is 356 and 789.\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * convert Arabic digits in the string to corresponding English digits\n * @param str\n */\nfunction arabicToEnglishNumbers(str: string): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * convert Arabic digits in the string to corresponding English digits\n * @param str\n * @return converted string with English digits\n */\nstd::string arabicToEnglishNumbers(const std::string& str) {\n    // Function implementation goes here\n}", "test_code": "TEST_CASE(\"arabicToEnglishNumbers\") {\n    SECTION(\"should convert Arabic numerals to English numerals\") {\n        std::string input = \"\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660\";\n        std::string expectedOutput = \"1234567890\";\n        REQUIRE(arabicToEnglishNumbers(input) == expectedOutput);\n    }\n\n    SECTION(\"should return the same string if there are no Arabic numerals\") {\n        std::string input = \"Hello, World!\";\n        std::string expectedOutput = \"Hello, World!\";\n        REQUIRE(arabicToEnglishNumbers(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle a mix of Arabic numerals and English characters\") {\n        std::string input = \"\u0631\u0642\u0645 \u0661\u0662\u0663 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\";\n        std::string expectedOutput = \"\u0631\u0642\u0645 123 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\";\n        REQUIRE(arabicToEnglishNumbers(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle empty string\") {\n        std::string input = \"\";\n        std::string expectedOutput = \"\";\n        REQUIRE(arabicToEnglishNumbers(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle a string with mixed Arabic and English numerals\") {\n        std::string input = \"The number is \u0663\u0665\u0666 and 789.\";\n        std::string expectedOutput = \"The number is 356 and 789.\";\n        REQUIRE(arabicToEnglishNumbers(input) == expectedOutput);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * convert Arabic digits in the string to corresponding English digits\n * @param str\n * @return converted string with English digits\n */\nstd::string arabicToEnglishNumbers(const std::string& str) {\n    // Function implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Convert Arabic digits in the string to corresponding English digits.\n * @param str the input string containing Arabic digits\n * @return a string with Arabic digits replaced by English digits\n */\npublic static String arabicToEnglishNumbers(String str) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testConvertsSingleArabicNumeralsToEnglish() {\n        assertEquals(\"1\", arabicToEnglishNumbers(\"\u0661\"));\n        assertEquals(\"5\", arabicToEnglishNumbers(\"\u0665\"));\n        assertEquals(\"9\", arabicToEnglishNumbers(\"\u0669\"));\n    }\n\n    @Test\n    public void testConvertsStringOfArabicNumeralsToEnglish() {\n        assertEquals(\"0123456789\", arabicToEnglishNumbers(\"\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\"));\n    }\n\n    @Test\n    public void testHandlesStringsWithArabicAndEnglishNumeralsMixed() {\n        assertEquals(\"012345\", arabicToEnglishNumbers(\"\u0660\u066123\u06645\"));\n    }\n\n    @Test\n    public void testLeavesNonNumeralCharactersUnchanged() {\n        assertEquals(\"Hello World!\", arabicToEnglishNumbers(\"Hello World!\"));\n        assertEquals(\"2022-2023\", arabicToEnglishNumbers(\"2022-\u0662\u0660\u0662\u0663\"));\n    }\n\n    @Test\n    public void testWorksWithFullSentencesIncludingArabicNumerals() {\n        assertEquals(\"The year is 2024!\", arabicToEnglishNumbers(\"The year is \u0662\u0660\u0662\u0664!\"));\n    }\n\n    @Test\n    public void testHandlesEmptyStringsCorrectly() {\n        assertEquals(\"\", arabicToEnglishNumbers(\"\"));\n    }\n\n    @Test\n    public void testProcessesArabicNumeralsInComplexMixedContext() {\n        assertEquals(\"Price: 500$ and Date: 2023-12-01\", \n                     arabicToEnglishNumbers(\"Price: \u0665\u0660\u0660$ and Date: \u0662\u0660\u0662\u0663-\u0661\u0662-\u0660\u0661\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Convert Arabic digits in the string to corresponding English digits.\n * @param str the input string containing Arabic digits\n * @return a string with Arabic digits replaced by English digits\n */\npublic static String arabicToEnglishNumbers(String str) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 144, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Converts a string containing Arabic numbers to a floating point number", "language_version_list": {"python": {"code_signature": "def arabic_to_english_numbers(value: str) -> str:\n    \"\"\"\n    Converts Arabic numerals in a string to English numerals.\n    This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n    with their corresponding English numerals (0-9) while leaving other characters unchanged.\n    For example:\n         input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n         output: 012345678\n\n    Args:\n        value (str): The string containing Arabic numerals to be converted.\n\n    Returns:\n        str: The converted string with Arabic numerals replaced by English numerals.\n    \"\"\"", "test_code": "import unittest\n\nclass TestArabicToEnglishNumbers(unittest.TestCase):\n    \n    def test_converts_single_arabic_numerals_to_english(self):\n        self.assertEqual(arabic_to_english_numbers('\u0661'), '1')\n        self.assertEqual(arabic_to_english_numbers('\u0665'), '5')\n        self.assertEqual(arabic_to_english_numbers('\u0669'), '9')\n\n    def test_converts_a_string_of_arabic_numerals_to_english(self):\n        self.assertEqual(arabic_to_english_numbers('\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669'), '0123456789')\n\n    def test_handles_strings_with_arabic_and_english_numerals_mixed(self):\n        self.assertEqual(arabic_to_english_numbers('\u0660\u066123\u06645'), '012345')\n\n    def test_leaves_non_numeral_characters_unchanged(self):\n        self.assertEqual(arabic_to_english_numbers('Hello World!'), 'Hello World!')\n        self.assertEqual(arabic_to_english_numbers('2022-\u0662\u0660\u0662\u0663'), '2022-2023')\n\n    def test_works_with_full_sentences_that_include_arabic_numerals(self):\n        self.assertEqual(arabic_to_english_numbers('The year is \u0662\u0660\u0662\u0664!'), 'The year is 2024!')\n\n    def test_handles_empty_strings_correctly(self):\n        self.assertEqual(arabic_to_english_numbers(''), '')\n\n    def test_processes_arabic_numerals_in_a_complex_mixed_context(self):\n        self.assertEqual(arabic_to_english_numbers('Price: \u0665\u0660\u0660$ and Date: \u0662\u0660\u0662\u0663-\u0661\u0662-\u0660\u0661'), 'Price: 500$ and Date: 2023-12-01')\n", "prompt": "please write a python function , the function signature as below def arabic_to_english_numbers(value: str) -> str:\n    \"\"\"\n    Converts Arabic numerals in a string to English numerals.\n    This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n    with their corresponding English numerals (0-9) while leaving other characters unchanged.\n    For example:\n         input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n         output: 012345678\n\n    Args:\n        value (str): The string containing Arabic numerals to be converted.\n\n    Returns:\n        str: The converted string with Arabic numerals replaced by English numerals.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts Arabic numerals in a string to English numerals.\n * This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n * with their corresponding English numerals (0-9) while leaving other characters unchanged.\n * For example:\n *      input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n *      output: 012345678\n *\n * @param {string} value - The string containing Arabic numerals to be converted.\n * @returns {string} The converted string with Arabic numerals replaced by English numerals.\n */\nfunction arabicToEnglishNumbers(value) {\n}", "test_code": "describe('arabicToEnglishNumbers', () => {\n    test('converts single Arabic numerals to English', () => {\n        expect(arabicToEnglishNumbers('\u0661')).toBe('1');\n        expect(arabicToEnglishNumbers('\u0665')).toBe('5');\n        expect(arabicToEnglishNumbers('\u0669')).toBe('9');\n    });\n\n    test('converts a string of Arabic numerals to English', () => {\n        expect(arabicToEnglishNumbers('\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669')).toBe('0123456789');\n    });\n\n    test('handles strings with Arabic and English numerals mixed', () => {\n        expect(arabicToEnglishNumbers('\u0660\u066123\u06645')).toBe('012345');\n    });\n\n    test('leaves non-numeral characters unchanged', () => {\n        expect(arabicToEnglishNumbers('Hello World!')).toBe('Hello World!');\n        expect(arabicToEnglishNumbers('2022-\u0662\u0660\u0662\u0663')).toBe('2022-2023');\n    });\n\n    test('works with full sentences that include Arabic numerals', () => {\n        expect(arabicToEnglishNumbers('The year is \u0662\u0660\u0662\u0664!')).toBe('The year is 2024!');\n    });\n\n    test('handles empty strings correctly', () => {\n        expect(arabicToEnglishNumbers('')).toBe('');\n    });\n\n    test('processes Arabic numerals in a complex mixed context', () => {\n        expect(arabicToEnglishNumbers('Price: \u0665\u0660\u0660$ and Date: \u0662\u0660\u0662\u0663-\u0661\u0662-\u0660\u0661')).toBe('Price: 500$ and Date: 2023-12-01');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts Arabic numerals in a string to English numerals.\n * This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n * with their corresponding English numerals (0-9) while leaving other characters unchanged.\n * For example:\n *      input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n *      output: 012345678\n *\n * @param {string} value - The string containing Arabic numerals to be converted.\n * @returns {string} The converted string with Arabic numerals replaced by English numerals.\n */\nfunction arabicToEnglishNumbers(value) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts Arabic numerals in a string to English numerals.\n * This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n * with their corresponding English numerals (0-9) while leaving other characters unchanged.\n * For example:\n *      input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n *      output: 012345678\n *\n * @param {string} value - The string containing Arabic numerals to be converted.\n * @returns {string} The converted string with Arabic numerals replaced by English numerals.\n */\nfunction arabicToEnglishNumbers(value: string): string {\n}", "test_code": "describe('arabicToEnglishNumbers', () => {\n    test('converts single Arabic numerals to English', () => {\n        expect(arabicToEnglishNumbers('\u0661')).toBe('1');\n        expect(arabicToEnglishNumbers('\u0665')).toBe('5');\n        expect(arabicToEnglishNumbers('\u0669')).toBe('9');\n    });\n\n    test('converts a string of Arabic numerals to English', () => {\n        expect(arabicToEnglishNumbers('\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669')).toBe('0123456789');\n    });\n\n    test('handles strings with Arabic and English numerals mixed', () => {\n        expect(arabicToEnglishNumbers('\u0660\u066123\u06645')).toBe('012345');\n    });\n\n    test('leaves non-numeral characters unchanged', () => {\n        expect(arabicToEnglishNumbers('Hello World!')).toBe('Hello World!');\n        expect(arabicToEnglishNumbers('2022-\u0662\u0660\u0662\u0663')).toBe('2022-2023');\n    });\n\n    test('works with full sentences that include Arabic numerals', () => {\n        expect(arabicToEnglishNumbers('The year is \u0662\u0660\u0662\u0664!')).toBe('The year is 2024!');\n    });\n\n    test('handles empty strings correctly', () => {\n        expect(arabicToEnglishNumbers('')).toBe('');\n    });\n\n    test('processes Arabic numerals in a complex mixed context', () => {\n        expect(arabicToEnglishNumbers('Price: \u0665\u0660\u0660$ and Date: \u0662\u0660\u0662\u0663-\u0661\u0662-\u0660\u0661')).toBe('Price: 500$ and Date: 2023-12-01');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts Arabic numerals in a string to English numerals.\n * This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n * with their corresponding English numerals (0-9) while leaving other characters unchanged.\n * For example:\n *      input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n *      output: 012345678\n *\n * @param {string} value - The string containing Arabic numerals to be converted.\n * @returns {string} The converted string with Arabic numerals replaced by English numerals.\n */\nfunction arabicToEnglishNumbers(value: string): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts Arabic numerals in a string to English numerals.\n * This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n * with their corresponding English numerals (0-9) while leaving other characters unchanged.\n * For example:\n *      input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n *      output: 012345678\n *\n * @param value - The string containing Arabic numerals to be converted.\n * @returns The converted string with Arabic numerals replaced by English numerals.\n */\nstd::string arabicToEnglishNumbers(const std::string& value) {\n    // Implementation goes here\n}", "test_code": "TEST_CASE(\"arabicToEnglishNumbers\", \"[conversion]\") {\n    SECTION(\"converts single Arabic numerals to English\") {\n        REQUIRE(arabicToEnglishNumbers(\"\u0661\") == \"1\");\n        REQUIRE(arabicToEnglishNumbers(\"\u0665\") == \"5\");\n        REQUIRE(arabicToEnglishNumbers(\"\u0669\") == \"9\");\n    }\n\n    SECTION(\"converts a string of Arabic numerals to English\") {\n        REQUIRE(arabicToEnglishNumbers(\"\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\") == \"0123456789\");\n    }\n\n    SECTION(\"handles strings with Arabic and English numerals mixed\") {\n        REQUIRE(arabicToEnglishNumbers(\"\u0660\u066123\u06645\") == \"012345\");\n    }\n\n    SECTION(\"leaves non-numeral characters unchanged\") {\n        REQUIRE(arabicToEnglishNumbers(\"Hello World!\") == \"Hello World!\");\n        REQUIRE(arabicToEnglishNumbers(\"2022-\u0662\u0660\u0662\u0663\") == \"2022-2023\");\n    }\n\n    SECTION(\"works with full sentences that include Arabic numerals\") {\n        REQUIRE(arabicToEnglishNumbers(\"The year is \u0662\u0660\u0662\u0664!\") == \"The year is 2024!\");\n    }\n\n    SECTION(\"handles empty strings correctly\") {\n        REQUIRE(arabicToEnglishNumbers(\"\") == \"\");\n    }\n\n    SECTION(\"processes Arabic numerals in a complex mixed context\") {\n        REQUIRE(arabicToEnglishNumbers(\"Price: \u0665\u0660\u0660$ and Date: \u0662\u0660\u0662\u0663-\u0661\u0662-\u0660\u0661\") == \"Price: 500$ and Date: 2023-12-01\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts Arabic numerals in a string to English numerals.\n * This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n * with their corresponding English numerals (0-9) while leaving other characters unchanged.\n * For example:\n *      input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n *      output: 012345678\n *\n * @param value - The string containing Arabic numerals to be converted.\n * @returns The converted string with Arabic numerals replaced by English numerals.\n */\nstd::string arabicToEnglishNumbers(const std::string& value) {\n    // Implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts Arabic numerals in a string to English numerals.\n * This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n * with their corresponding English numerals (0-9) while leaving other characters unchanged.\n * For example:\n *      input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n *      output: 012345678\n *\n * @param value - The string containing Arabic numerals to be converted.\n * @return The converted string with Arabic numerals replaced by English numerals.\n */\npublic static String arabicToEnglishNumbers(String value) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testConvertsSingleArabicNumeralsToEnglish() {\n        assertEquals(\"1\", NumberConverter.arabicToEnglishNumbers(\"\u0661\"));\n        assertEquals(\"5\", NumberConverter.arabicToEnglishNumbers(\"\u0665\"));\n        assertEquals(\"9\", NumberConverter.arabicToEnglishNumbers(\"\u0669\"));\n    }\n\n    @Test\n    public void testConvertsStringOfArabicNumeralsToEnglish() {\n        assertEquals(\"0123456789\", NumberConverter.arabicToEnglishNumbers(\"\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\"));\n    }\n\n    @Test\n    public void testHandlesStringsWithArabicAndEnglishNumeralsMixed() {\n        assertEquals(\"012345\", NumberConverter.arabicToEnglishNumbers(\"\u0660\u066123\u06645\"));\n    }\n\n    @Test\n    public void testLeavesNonNumeralCharactersUnchanged() {\n        assertEquals(\"Hello World!\", NumberConverter.arabicToEnglishNumbers(\"Hello World!\"));\n        assertEquals(\"2022-2023\", NumberConverter.arabicToEnglishNumbers(\"2022-\u0662\u0660\u0662\u0663\"));\n    }\n\n    @Test\n    public void testWorksWithFullSentencesIncludingArabicNumerals() {\n        assertEquals(\"The year is 2024!\", NumberConverter.arabicToEnglishNumbers(\"The year is \u0662\u0660\u0662\u0664!\"));\n    }\n\n    @Test\n    public void testHandlesEmptyStringsCorrectly() {\n        assertEquals(\"\", NumberConverter.arabicToEnglishNumbers(\"\"));\n    }\n\n    @Test\n    public void testProcessesArabicNumeralsInComplexMixedContext() {\n        assertEquals(\"Price: 500$ and Date: 2023-12-01\", \n                     NumberConverter.arabicToEnglishNumbers(\"Price: \u0665\u0660\u0660$ and Date: \u0662\u0660\u0662\u0663-\u0661\u0662-\u0660\u0661\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts Arabic numerals in a string to English numerals.\n * This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n * with their corresponding English numerals (0-9) while leaving other characters unchanged.\n * For example:\n *      input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n *      output: 012345678\n *\n * @param value - The string containing Arabic numerals to be converted.\n * @return The converted string with Arabic numerals replaced by English numerals.\n */\npublic static String arabicToEnglishNumbers(String value) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 145, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Format a number as a string representation of the specified currency. It uses the given locale and currencyCode to generate string output that matches the currency format for that locale.", "language_version_list": {"python": {"code_signature": "def format_currency(value: float, currency_code: str, locale: str = \"en_US\") -> str:\n    \"\"\"\n    Formats a number as currency according to the specified locale and currency code.\n\n    Args:\n        value (float): The numerical value to be formatted.\n        currency_code (str): The currency code (e.g., \"USD\", \"EUR\").\n        locale (str): The locale string (e.g., \"en_US\", \"fr_FR\"). Default is \"en_US\".\n\n    Returns:\n        str: The formatted currency string.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestFormatCurrency(unittest.TestCase):\n    \n    def test_format_currency_usd(self):\n        value = 1234.56\n        currency_code = 'USD'\n        locale = 'en-US'\n        expected_output = '\\$1,234.56'  # Expected format for USD\n        self.assertEqual(format_currency(value, currency_code, locale), expected_output)\n\n    def test_format_currency_euro(self):\n        value = 1234.56\n        currency_code = 'EUR'\n        locale = 'en-US'\n        expected_output = '\u20ac1,234.56'  # Expected format for EUR\n        self.assertEqual(format_currency(value, currency_code, locale), expected_output)\n\n    def test_format_currency_gbp(self):\n        value = 1234.56\n        currency_code = 'GBP'\n        locale = 'en-GB'\n        expected_output = '\u00a31,234.56'  # Expected format for GBP\n        self.assertEqual(format_currency(value, currency_code, locale), expected_output)\n\n    def test_format_currency_negative(self):\n        value = -1234.56\n        currency_code = 'USD'\n        locale = 'en-US'\n        expected_output = '-\\$1,234.56'  # Expected format for negative USD\n        self.assertEqual(format_currency(value, currency_code, locale), expected_output)\n\n    def test_format_currency_zero(self):\n        value = 0\n        currency_code = 'JPY'\n        locale = 'en-JP'\n        expected_output = '\u00a50'  # Expected format for JPY (no decimals)\n        self.assertEqual(format_currency(value, currency_code, locale), expected_output)", "prompt": "please write a python function , the function signature as below def format_currency(value: float, currency_code: str, locale: str = \"en_US\") -> str:\n    \"\"\"\n    Formats a number as currency according to the specified locale and currency code.\n\n    Args:\n        value (float): The numerical value to be formatted.\n        currency_code (str): The currency code (e.g., \"USD\", \"EUR\").\n        locale (str): The locale string (e.g., \"en_US\", \"fr_FR\"). Default is \"en_US\".\n\n    Returns:\n        str: The formatted currency string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Formats a number as currency according to the specified locale and currency code.\n *\n * @param {number} value - The numerical value to be formatted.\n * @param {string} currencyCode - The currency code (e.g., \"USD\", \"EUR\").\n * @param {string} [locale=\"en-US\"] - The locale string (e.g., \"en-US\", \"fr-FR\").\n * @returns {string} The formatted currency string.\n */\nfunction formatCurrency(value, currencyCode, locale = \"en-US\") {\n    // Function implementation goes here\n}", "test_code": "describe('formatCurrency function tests', () => {\n    test('should format currency in US dollars', () => {\n        const value = 1234.56;\n        const currencyCode = 'USD';\n        const locale = 'en-US';\n        const expectedOutput = '$1,234.56'; // Expected format for USD\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n\n    test('should format currency in Euro', () => {\n        const value = 1234.56;\n        const currencyCode = 'EUR';\n        const locale = 'en-US';\n        const expectedOutput = '\u20ac1,234.56'; // Expected format for EUR\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n\n    test('should format currency in British Pound', () => {\n        const value = 1234.56;\n        const currencyCode = 'GBP';\n        const locale = 'en-GB';\n        const expectedOutput = '\u00a31,234.56'; // Expected format for GBP\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n\n    test('should format currency with a negative value', () => {\n        const value = -1234.56;\n        const currencyCode = 'USD';\n        const locale = 'en-US';\n        const expectedOutput = '-$1,234.56'; // Expected format for negative USD\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n\n    test('should handle zero value correctly', () => {\n        const value = 0;\n        const currencyCode = 'JPY';\n        const locale = 'en-JP';\n        const expectedOutput = '\u00a50'; // Expected format for JPY (no decimals)\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Formats a number as currency according to the specified locale and currency code.\n *\n * @param {number} value - The numerical value to be formatted.\n * @param {string} currencyCode - The currency code (e.g., \"USD\", \"EUR\").\n * @param {string} [locale=\"en-US\"] - The locale string (e.g., \"en-US\", \"fr-FR\").\n * @returns {string} The formatted currency string.\n */\nfunction formatCurrency(value, currencyCode, locale = \"en-US\") {\n    // Function implementation goes here\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Formats a number as currency according to the specified locale and currency code.\n *\n * @param value - The numerical value to be formatted.\n * @param currencyCode - The currency code (e.g., \"USD\", \"EUR\").\n * @param locale - The locale string (e.g., \"en-US\", \"fr-FR\"). Default is \"en-US\".\n * @returns The formatted currency string.\n */\nfunction formatCurrency(\n    value: number,\n    currencyCode: string,\n    locale: string = \"en-US\"\n): string {\n}", "test_code": "describe('formatCurrency function tests', () => {\n    test('should format currency in US dollars', () => {\n        const value = 1234.56;\n        const currencyCode = 'USD';\n        const locale = 'en-US';\n        const expectedOutput = '\\$1,234.56'; // Expected format for USD\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n\n    test('should format currency in Euro', () => {\n        const value = 1234.56;\n        const currencyCode = 'EUR';\n        const locale = 'en-US';\n        const expectedOutput = '\u20ac1,234.56'; // Expected format for EUR\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n\n    test('should format currency in British Pound', () => {\n        const value = 1234.56;\n        const currencyCode = 'GBP';\n        const locale = 'en-GB';\n        const expectedOutput = '\u00a31,234.56'; // Expected format for GBP\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n\n    test('should format currency with a negative value', () => {\n        const value = -1234.56;\n        const currencyCode = 'USD';\n        const locale = 'en-US';\n        const expectedOutput = '-\\$1,234.56'; // Expected format for negative USD\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n\n    test('should handle zero value correctly', () => {\n        const value = 0;\n        const currencyCode = 'JPY';\n        const locale = 'en-JP';\n        const expectedOutput = '\u00a50'; // Expected format for JPY (no decimals)\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Formats a number as currency according to the specified locale and currency code.\n *\n * @param value - The numerical value to be formatted.\n * @param currencyCode - The currency code (e.g., \"USD\", \"EUR\").\n * @param locale - The locale string (e.g., \"en-US\", \"fr-FR\"). Default is \"en-US\".\n * @returns The formatted currency string.\n */\nfunction formatCurrency(\n    value: number,\n    currencyCode: string,\n    locale: string = \"en-US\"\n): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Formats a number as currency according to the specified locale and currency code.\n *\n * @param value - The numerical value to be formatted.\n * @param currencyCode - The currency code (e.g., \"USD\", \"EUR\").\n * @param locale - The locale string (e.g., \"en-US\", \"fr-FR\"). Default is \"en-US\".\n * @returns The formatted currency string.\n */\nstd::string formatCurrency(double value, const std::string& currencyCode, const std::string& locale = \"en-US\") {\n    // Function implementation goes here\n}", "test_code": "TEST_CASE(\"formatCurrency function tests\") {\n    SECTION(\"should format currency in US dollars\") {\n        double value = 1234.56;\n        std::string currencyCode = \"USD\";\n        std::string locale = \"en-US\";\n        std::string expectedOutput = \"$1,234.56\"; // Expected format for USD\n        REQUIRE(formatCurrency(value, currencyCode, locale) == expectedOutput);\n    }\n\n    SECTION(\"should format currency in Euro\") {\n        double value = 1234.56;\n        std::string currencyCode = \"EUR\";\n        std::string locale = \"en-US\";\n        std::string expectedOutput = \"\u20ac1,234.56\"; // Expected format for EUR\n        REQUIRE(formatCurrency(value, currencyCode, locale) == expectedOutput);\n    }\n\n    SECTION(\"should format currency in British Pound\") {\n        double value = 1234.56;\n        std::string currencyCode = \"GBP\";\n        std::string locale = \"en-GB\";\n        std::string expectedOutput = \"\u00a31,234.56\"; // Expected format for GBP\n        REQUIRE(formatCurrency(value, currencyCode, locale) == expectedOutput);\n    }\n\n    SECTION(\"should format currency with a negative value\") {\n        double value = -1234.56;\n        std::string currencyCode = \"USD\";\n        std::string locale = \"en-US\";\n        std::string expectedOutput = \"-$1,234.56\"; // Expected format for negative USD\n        REQUIRE(formatCurrency(value, currencyCode, locale) == expectedOutput);\n    }\n\n    SECTION(\"should handle zero value correctly\") {\n        double value = 0;\n        std::string currencyCode = \"JPY\";\n        std::string locale = \"en-JP\";\n        std::string expectedOutput = \"\u00a50\"; // Expected format for JPY (no decimals)\n        REQUIRE(formatCurrency(value, currencyCode, locale) == expectedOutput);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Formats a number as currency according to the specified locale and currency code.\n *\n * @param value - The numerical value to be formatted.\n * @param currencyCode - The currency code (e.g., \"USD\", \"EUR\").\n * @param locale - The locale string (e.g., \"en-US\", \"fr-FR\"). Default is \"en-US\".\n * @returns The formatted currency string.\n */\nstd::string formatCurrency(double value, const std::string& currencyCode, const std::string& locale = \"en-US\") {\n    // Function implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Formats a number as currency according to the specified locale and currency code.\n *\n * @param value - The numerical value to be formatted.\n * @param currencyCode - The currency code (e.g., \"USD\", \"EUR\").\n * @param locale - The locale string (e.g., \"en-US\", \"fr-FR\"). Default is \"en-US\".\n * @return The formatted currency string.\n */\npublic static String formatCurrency(double value, String currencyCode, String locale) {\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testFormatCurrencyInUSD() {\n        double value = 1234.56;\n        String currencyCode = \"USD\";\n        String locale = \"en-US\";\n        String expectedOutput = \"$1,234.56\"; // Expected format for USD\n        assertEquals(expectedOutput, formatCurrency(value, currencyCode, locale));\n    }\n\n    @Test\n    public void testFormatCurrencyInEuro() {\n        double value = 1234.56;\n        String currencyCode = \"EUR\";\n        String locale = \"en-US\";\n        String expectedOutput = \"\u20ac1,234.56\"; // Expected format for EUR\n        assertEquals(expectedOutput, formatCurrency(value, currencyCode, locale));\n    }\n\n    @Test\n    public void testFormatCurrencyInBritishPound() {\n        double value = 1234.56;\n        String currencyCode = \"GBP\";\n        String locale = \"en-GB\";\n        String expectedOutput = \"\u00a31,234.56\"; // Expected format for GBP\n        assertEquals(expectedOutput, formatCurrency(value, currencyCode, locale));\n    }\n\n    @Test\n    public void testFormatCurrencyNegativeValue() {\n        double value = -1234.56;\n        String currencyCode = \"USD\";\n        String locale = \"en-US\";\n        String expectedOutput = \"-$1,234.56\"; // Expected format for negative USD\n        assertEquals(expectedOutput, formatCurrency(value, currencyCode, locale));\n    }\n\n    @Test\n    public void testHandleZeroValueCorrectly() {\n        double value = 0;\n        String currencyCode = \"JPY\";\n        String locale = \"en-JP\";\n        String expectedOutput = \"\u00a50\"; // Expected format for JPY (no decimals)\n        assertEquals(expectedOutput, formatCurrency(value, currencyCode, locale));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Formats a number as currency according to the specified locale and currency code.\n *\n * @param value - The numerical value to be formatted.\n * @param currencyCode - The currency code (e.g., \"USD\", \"EUR\").\n * @param locale - The locale string (e.g., \"en-US\", \"fr-FR\"). Default is \"en-US\".\n * @return The formatted currency string.\n */\npublic static String formatCurrency(double value, String currencyCode, String locale) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 146, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Format the number of bytes as a human-readable file size string. It displays file sizes in different units and decimal places depending on the options provided.", "language_version_list": {"python": {"code_signature": "def format_bytes(bytes: int, options: dict = None) -> str:\n    \"\"\"\n    Formats a given number of bytes into a human-readable string representation,\n    using either the SI (decimal) or binary (accurate) size notation.\n\n    Args:\n        bytes (int): The number of bytes to format.\n        options (dict, optional): Optional settings to customize the output.\n            - 'decimals' (int): Number of decimal places to include in the result.\n            - 'sizeType' (str): Specifies whether to use binary (\"accurate\") or\n              decimal (\"normal\") units.\n              \"accurate\" uses units like KiB, MiB (base 1024).\n              \"normal\" uses units like KB, MB (base 1000).\n\n    Returns:\n        str: A string representation of the byte size in a human-readable format.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestFormatBytes(unittest.TestCase):\n\n    def test_zero_bytes(self):\n        result = format_bytes(0)\n        self.assertIn(result, ['0 B', '0 Byte'])\n\n    def test_two_kb(self):\n        result = format_bytes(2048)\n        self.assertIn(result, ['2 KB', '2.0 KB'])\n\n    def test_two_kib(self):\n        result = format_bytes(2048, {'sizeType': 'accurate'})\n        self.assertIn(result, ['2 KiB', '2.0 KiB'])\n\n    def test_five_mb(self):\n        result = format_bytes(5242880)\n        self.assertIn(result, ['5 MB', '5.0 MB'])\n\n    def test_five_mib_with_decimals(self):\n        result = format_bytes(5242880, {'decimals': 2, 'sizeType': 'accurate'})\n        self.assertEqual(result, '5.00 MiB')", "prompt": "please write a python function , the function signature as below def format_bytes(bytes: int, options: dict = None) -> str:\n    \"\"\"\n    Formats a given number of bytes into a human-readable string representation,\n    using either the SI (decimal) or binary (accurate) size notation.\n\n    Args:\n        bytes (int): The number of bytes to format.\n        options (dict, optional): Optional settings to customize the output.\n            - 'decimals' (int): Number of decimal places to include in the result.\n            - 'sizeType' (str): Specifies whether to use binary (\"accurate\") or\n              decimal (\"normal\") units.\n              \"accurate\" uses units like KiB, MiB (base 1024).\n              \"normal\" uses units like KB, MB (base 1000).\n\n    Returns:\n        str: A string representation of the byte size in a human-readable format.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param {number} bytes - The number of bytes to format.\n * @param {Object} options - Optional settings to customize the output.\n * @param {number} [options.decimals=0] - Number of decimal places to include in the output.\n * @param {\"accurate\" | \"normal\"} [options.sizeType=\"normal\"] -\n *        Specifies whether to use binary (\"accurate\") or decimal (\"normal\") units.\n *        \"accurate\" uses units like KiB, MiB (base 1024).\n *        \"normal\" uses units like KB, MB (base 1000).\n * @returns {string} A string representation of the byte size in a human-readable format.\n */\nfunction formatBytes(bytes, options) {}", "test_code": "describe('formatBytes', () => {\n    test('should return \"0 Byte\" for 0 bytes', () => {\n        const result = formatBytes(0);\n        expect(['0 B', '0 Byte']).toContain(result);\n    });\n\n    test('should return \"2.0 KB\" for 2048 bytes', () => {\n        const result = formatBytes(2048);\n        expect(['2 KB', '2.0 KB']).toContain(result);\n    });\n\n    test('should return \"2.0 KiB\" for 2048 bytes with sizeType \"accurate\"', () => {\n        const result = formatBytes(2048, { sizeType: \"accurate\" });\n        expect(['2 KiB', '2.0 KiB']).toContain(result);\n    });\n\n    test('should return \"5.0 MB\" for 5242880 bytes', () => {\n        const result = formatBytes(5242880);\n        expect(['5 MB', '5.0 MB']).toContain(result);\n    });\n\n    test('should return \"5.00 MiB\" for 5242880 bytes with 2 decimal places and sizeType \"accurate\"', () => {\n        const result = formatBytes(5242880, { decimals: 2, sizeType: \"accurate\" });\n        expect(result).toBe('5.00 MiB');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param {number} bytes - The number of bytes to format.\n * @param {Object} options - Optional settings to customize the output.\n * @param {number} [options.decimals=0] - Number of decimal places to include in the output.\n * @param {\"accurate\" | \"normal\"} [options.sizeType=\"normal\"] -\n *        Specifies whether to use binary (\"accurate\") or decimal (\"normal\") units.\n *        \"accurate\" uses units like KiB, MiB (base 1024).\n *        \"normal\" uses units like KB, MB (base 1000).\n * @returns {string} A string representation of the byte size in a human-readable format.\n */\nfunction formatBytes(bytes, options) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param {number} bytes - The number of bytes to format.\n * @param {Object} options - Optional settings to customize the output.\n * @param {number} [options.decimals=0] - Number of decimal places to include in the model_answer_result.\n * @param {\"accurate\" | \"normal\"} [options.sizeType=\"normal\"] -\n *        Specifies whether to use binary (\"accurate\") or decimal (\"normal\") units.\n *        \"accurate\" uses units like KiB, MiB (base 1024).\n *        \"normal\" uses units like KB, MB (base 1000).\n * @returns {string} A string representation of the byte size in a human-readable format.\n */\nfunction formatBytes(\n    bytes: number,\n    options?: {\n      decimals?: number;\n      sizeType?: \"accurate\" | \"normal\";\n    }\n): string;\n", "test_code": "describe('formatBytes', () => {\n    test('should return \"0 Byte\" for 0 bytes', () => {\n        const result = formatBytes(0);\n        expect(['0 B','0 Byte']).toContain(result)\n    });\n\n    test('should return \"2.0 KB\" for 2048 bytes', () => {\n        const result = formatBytes(2048);\n        expect(['2 KB','2.0 KB']).toContain(result)\n    });\n\n    test('should return \"2.0 KiB\" for 2048 bytes with sizeType \"accurate\"', () => {\n        const result = formatBytes(2048, { sizeType: \"accurate\" });\n        expect(['2 KiB','2.0 Kib']).toContain(result)\n    });\n\n    test('should return \"5.0 MB\" for 5242880 bytes', () => {\n        const result = formatBytes(5242880);\n         expect(['5 MB','5.0 MB']).toContain(result)\n    });\n\n    test('should return \"5.00 MiB\" for 5242880 bytes with 2 decimal places and sizeType \"accurate\"', () => {\n        const result = formatBytes(5242880, { decimals: 2, sizeType: \"accurate\" });\n        expect(result).toBe('5.00 MiB');\n    });\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param {number} bytes - The number of bytes to format.\n * @param {Object} options - Optional settings to customize the output.\n * @param {number} [options.decimals=0] - Number of decimal places to include in the model_answer_result.\n * @param {\"accurate\" | \"normal\"} [options.sizeType=\"normal\"] -\n *        Specifies whether to use binary (\"accurate\") or decimal (\"normal\") units.\n *        \"accurate\" uses units like KiB, MiB (base 1024).\n *        \"normal\" uses units like KB, MB (base 1000).\n * @returns {string} A string representation of the byte size in a human-readable format.\n */\nfunction formatBytes(\n    bytes: number,\n    options?: {\n      decimals?: number;\n      sizeType?: \"accurate\" | \"normal\";\n    }\n): string;\n", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param bytes - The number of bytes to format.\n * @param decimals - Optional number of decimal places to include in the output.\n * @param sizeType - Optional specification of whether to use binary (\"accurate\") \n *                   or decimal (\"normal\") units.\n *                   \"accurate\" uses units like KiB, MiB (base 1024).\n *                   \"normal\" uses units like KB, MB (base 1000).\n * @returns A string representation of the byte size in a human-readable format.\n */\nstd::string formatBytes()", "test_code": "TEST_CASE(\"formatBytes\", \"[formatBytes]\") {\n    SECTION(\"should return '0 Byte' for 0 bytes\") {\n        auto result = formatBytes(0);\n        REQUIRE(result == \"0 Byte\" || result == \"0 B\");\n    }\n\n    SECTION(\"should return '2.0 KB' for 2048 bytes\") {\n        auto result = formatBytes(2048);\n        REQUIRE(result == \"2 KB\" || result == \"2.0 KB\");\n    }\n\n    SECTION(\"should return '2.0 KiB' for 2048 bytes with sizeType 'accurate'\") {\n        auto result = formatBytes(2048, std::nullopt, \"accurate\");\n        REQUIRE(result == \"2 KiB\" || result == \"2.0 KiB\");\n    }\n\n    SECTION(\"should return '5.0 MB' for 5242880 bytes\") {\n        auto result = formatBytes(5242880);\n        REQUIRE(result == \"5 MB\" || result == \"5.0 MB\");\n    }\n\n    SECTION(\"should return '5.00 MiB' for 5242880 bytes with 2 decimal places and sizeType 'accurate'\") {\n        auto result = formatBytes(5242880, 2, \"accurate\");\n        REQUIRE(result == \"5.00 MiB\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param bytes - The number of bytes to format.\n * @param decimals - Optional number of decimal places to include in the output.\n * @param sizeType - Optional specification of whether to use binary (\"accurate\") \n *                   or decimal (\"normal\") units.\n *                   \"accurate\" uses units like KiB, MiB (base 1024).\n *                   \"normal\" uses units like KB, MB (base 1000).\n * @returns A string representation of the byte size in a human-readable format.\n */\nstd::string formatBytes()", "addition_info": ""}, "java": {"code_signature": "/**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param bytes The number of bytes to format.\n * @param options Optional settings to customize the output.\n * @param options.decimals Number of decimal places to include in the formatted result.\n * @param options.sizeType Specifies whether to use binary (\"accurate\") or decimal (\"normal\") units.\n *        \"accurate\" uses units like KiB, MiB (base 1024).\n *        \"normal\" uses units like KB, MB (base 1000).\n * @returns A string representation of the byte size in a human-readable format.\n */\npublic static String formatBytes(long bytes, FormatOptions options) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\n\npublic class Tester {\n\n    public static String arrayBufferToString(ByteBuffer buffer) {\n        byte[] byteArray = new byte[buffer.remaining()];\n        buffer.get(byteArray);\n        return new String(byteArray, StandardCharsets.UTF_8);\n    }\n\n    @Test\n    public void testEmptyBuffer() {\n        ByteBuffer buffer1 = ByteBuffer.allocate(0);\n        String result = arrayBufferToString(buffer1);\n        assertEquals(\"\", result); // Expected: \"\"\n    }\n\n    @Test\n    public void testSingleCharacter() {\n        ByteBuffer buffer2 = ByteBuffer.wrap(\"A\".getBytes(StandardCharsets.UTF_8));\n        String result = arrayBufferToString(buffer2);\n        assertEquals(\"A\", result); // Expected: \"A\"\n    }\n\n    @Test\n    public void testHelloString() {\n        ByteBuffer buffer3 = ByteBuffer.wrap(\"Hello\".getBytes(StandardCharsets.UTF_8));\n        String result = arrayBufferToString(buffer3);\n        assertEquals(\"Hello\", result); // Expected: \"Hello\"\n    }\n\n    @Test\n    public void testMultipleCharacters() {\n        ByteBuffer buffer4 = ByteBuffer.wrap(\"Hello, World!\".getBytes(StandardCharsets.UTF_8));\n        String result = arrayBufferToString(buffer4);\n        assertEquals(\"Hello, World!\", result); // Expected: \"Hello, World!\"\n    }\n    \n}", "prompt": "please write a java function , the function signature as below /**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param bytes The number of bytes to format.\n * @param options Optional settings to customize the output.\n * @param options.decimals Number of decimal places to include in the formatted result.\n * @param options.sizeType Specifies whether to use binary (\"accurate\") or decimal (\"normal\") units.\n *        \"accurate\" uses units like KiB, MiB (base 1024).\n *        \"normal\" uses units like KB, MB (base 1000).\n * @returns A string representation of the byte size in a human-readable format.\n */\npublic static String formatBytes(long bytes, FormatOptions options) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 147, "code_type": "method", "original_language": "typescript", "question_type": "Network requests and API call", "summary": "Converts the ArrayBuffer object to a string", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts an ArrayBuffer to a string.\n *\n * @param buffer - The ArrayBuffer to be converted.\n * @returns The string representation of the ArrayBuffer.\n */\nfunction arrayBufferToString(buffer) {}", "test_code": "describe('arrayBufferToString', () => {\n    test('should return an empty string for an empty ArrayBuffer', () => {\n        const buffer1 = new ArrayBuffer(0);\n        const result = arrayBufferToString(buffer1);\n        expect(result).toBe(''); // Expected: \"\"\n    });\n\n    test('should return \"A\" for a buffer containing the character \"A\"', () => {\n        const buffer2 = new TextEncoder().encode(\"A\").buffer;\n        const result = arrayBufferToString(buffer2);\n        expect(result).toBe('A'); // Expected: \"A\"\n    });\n\n    test('should return \"Hello\" for a buffer containing the string \"Hello\"', () => {\n        const buffer3 = new TextEncoder().encode(\"Hello\").buffer;\n        const result = arrayBufferToString(buffer3);\n        expect(result).toBe('Hello'); // Expected: \"Hello\"\n    });\n\n    test('should return the correct string for a buffer containing multiple characters', () => {\n        const buffer4 = new TextEncoder().encode(\"Hello, World!\").buffer;\n        const result = arrayBufferToString(buffer4);\n        expect(result).toBe('Hello, World!'); // Expected: \"Hello, World!\"\n    });\n\n    test('should not modify the input buffer', () => {\n        const input = \"Test input\";\n        const buffer8 = new TextEncoder().encode(input).buffer;\n        arrayBufferToString(buffer8);\n        const result = new TextDecoder().decode(buffer8);\n        expect(result).toBe(input); // Check if the buffer content remains unchanged\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts an ArrayBuffer to a string.\n *\n * @param buffer - The ArrayBuffer to be converted.\n * @returns The string representation of the ArrayBuffer.\n */\nfunction arrayBufferToString(buffer) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts an ArrayBuffer to a string.\n *\n * @param buffer - The ArrayBuffer to be converted.\n * @returns The string representation of the ArrayBuffer.\n */\nfunction arrayBufferToString(buffer: ArrayBuffer): string;\n", "test_code": "describe('arrayBufferToString', () => {\n    test('should return an empty string for an empty ArrayBuffer', () => {\n        const buffer1 = new ArrayBuffer(0);\n        const result = arrayBufferToString(buffer1);\n        expect(result).toBe(''); // Expected: \"\"\n    });\n\n    test('should return \"A\" for a buffer containing the character \"A\"', () => {\n        const buffer2 = new TextEncoder().encode(\"A\").buffer;\n        const result = arrayBufferToString(buffer2);\n        expect(result).toBe('A'); // Expected: \"A\"\n    });\n\n    test('should return \"Hello\" for a buffer containing the string \"Hello\"', () => {\n        const buffer3 = new TextEncoder().encode(\"Hello\").buffer;\n        const result = arrayBufferToString(buffer3);\n        expect(result).toBe('Hello'); // Expected: \"Hello\"\n    });\n\n        test('should return the correct string for a buffer containing multiple characters', () => {\n        const buffer4 = new TextEncoder().encode(\"Hello, World!\").buffer;\n        const result = arrayBufferToString(buffer4);\n        expect(result).toBe('Hello, World!'); // Expected: \"Hello, World!\"\n    });\n\n\n    test('should not modify the input buffer', () => {\n        const input = \"Test input\";\n        const buffer8 = new TextEncoder().encode(input).buffer;\n        arrayBufferToString(buffer8);\n        const result = new TextDecoder().decode(buffer8);\n        expect(result).toBe(input); // Check if the buffer content remains unchanged\n    });\n\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts an ArrayBuffer to a string.\n *\n * @param buffer - The ArrayBuffer to be converted.\n * @returns The string representation of the ArrayBuffer.\n */\nfunction arrayBufferToString(buffer: ArrayBuffer): string;\n", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 148, "code_type": "method", "original_language": "typescript", "question_type": "Network requests and API call", "summary": "Converts a base64-encoded string to an ArrayBuffer. An ArrayBuffer is a generic, fixed-length buffer of raw binary data that is commonly used to represent binary data.", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a Base64-encoded string to an ArrayBuffer.\n *\n * @param base64 - The Base64-encoded string to convert.\n * @returns An ArrayBuffer representing the decoded bytes.\n */\nexport function base64ToArrayBuffer(base64) {\n    // Function implementation goes here\n}", "test_code": "describe('base64ToArrayBuffer function', () => {\n    // Test Case 1\n    test('should decode \"SGVsbG8sIFdvcmxkIQ==\" to \"Hello, World!\"', () => {\n        const base64 = \"SGVsbG8sIFdvcmxkIQ==\";\n        const expected = \"Hello, World!\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n    // Test Case 2\n    test('should decode \"U29tZSB0ZXh0IHdpdGggc3BhcmluZyBhbmQgd29ya2luZyE=\" to \"Some text with sparing and working!\"', () => {\n        const base64 = \"U29tZSB0ZXh0IHdpdGggc3BhcmluZyBhbmQgd29ya2luZyE=\";\n        const expected = \"Some text with sparing and working!\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n    // Test Case 3\n    test('should decode \"QmFzZTY0IGVuY29kaW5nIGlzIGEgY29tbW9ubG9nIEZvciBiaW5hcnkgZGF0YQ==\" to \"Base64 encoding is a common log For binary data\"', () => {\n        const base64 = \"QmFzZTY0IGVuY29kaW5nIGlzIGEgY29tbW9ubG9nIEZvciBiaW5hcnkgZGF0YQ==\";\n        const expected = \"Base64 encoding is a common log For binary data\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n    // Test Case 4\n    test('should decode \"R2l2ZSBtZSBhbG9uZyBhIHBhdGggdG8gY29tcGxldGUgc3RhcnQgcGFnZS4=\" to \"Give me along a path to complete start page.\"', () => {\n        const base64 = \"R2l2ZSBtZSBhbG9uZyBhIHBhdGggdG8gY29tcGxldGUgc3RhcnQgcGFnZS4=\";\n        const expected = \"Give me along a path to complete start page.\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a Base64-encoded string to an ArrayBuffer.\n *\n * @param base64 - The Base64-encoded string to convert.\n * @returns An ArrayBuffer representing the decoded bytes.\n */\nexport function base64ToArrayBuffer(base64) {\n    // Function implementation goes here\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a Base64-encoded string to an ArrayBuffer.\n *\n * @param base64 - The Base64-encoded string to convert.\n * @returns An ArrayBuffer representing the decoded bytes.\n */\nexport function base64ToArrayBuffer(base64: string){\n\n}\n", "test_code": "describe('base64ToArrayBuffer function', () => {\n    // Test Case 1\n    test('should decode \"SGVsbG8sIFdvcmxkIQ==\" to \"Hello, World!\"', () => {\n        const base64 = \"SGVsbG8sIFdvcmxkIQ==\";\n        const expected = \"Hello, World!\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n    // Test Case 2\n    test('should decode \"U29tZSB0ZXh0IHdpdGggc3BhcmluZyBhbmQgd29ya2luZyE=\" to \"Some text with sparing and working!\"', () => {\n        const base64 = \"U29tZSB0ZXh0IHdpdGggc3BhcmluZyBhbmQgd29ya2luZyE=\";\n        const expected = \"Some text with sparing and working!\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n    // Test Case 3\n    test('should decode \"QmFzZTY0IGVuY29kaW5nIGlzIGEgY29tbW9ubG9nIEZvciBiaW5hcnkgZGF0YQ==\" to \"Base64 encoding is a common log For binary question\"', () => {\n        const base64 = \"QmFzZTY0IGVuY29kaW5nIGlzIGEgY29tbW9ubG9nIEZvciBiaW5hcnkgZGF0YQ==\";\n        const expected = \"Base64 encoding is a commonlog For binary data\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n    // Test Case 4\n    test('should decode \"R2l2ZSBtZSBhbG9uZyBhIHBhdGggdG8gY29tcGxldGUgc3RhcnQgcGFnZS4=\" to \"Give me along a path to complete start page.\"', () => {\n        const base64 = \"R2l2ZSBtZSBhbG9uZyBhIHBhdGggdG8gY29tcGxldGUgc3RhcnQgcGFnZS4=\";\n        const expected = \"Give me along a path to complete start page.\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a Base64-encoded string to an ArrayBuffer.\n *\n * @param base64 - The Base64-encoded string to convert.\n * @returns An ArrayBuffer representing the decoded bytes.\n */\nexport function base64ToArrayBuffer(base64: string){\n\n}\n", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 150, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Convert RGB colors to and from hexadecimal color format.", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef rgb_to_hex(rgb: Dict):\n    \"\"\"\n    Convert an RGB color object to a HEX color string.\n\n    Args:\n        rgb (dict): An object containing the red, green, and blue components of the color.\n                    Example: {'r': 255, 'g': 0, 'b': 0}\n\n    Returns:\n        str: A string representing the HEX color code.\n             Example: \"#FF0000\" for red.\n    \"\"\"\n\n\ndef hex_to_rgb(hex_color: str):\n    \"\"\"\n    Convert a HEX color string to an RGB color object.\n\n    Args:\n        hex_color (str): A string representing the HEX color code.\n                         Example: \"#FF0000\" for red.\n\n    Returns:\n        dict or None: An object containing the red, green, and blue components of the color.\n                       Returns None if the HEX code is invalid.\n                       Example: {'r': 255, 'g': 0, 'b': 0} for red.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestColorConversion(unittest.TestCase):\n    def test_rgb_to_hex(self):\n        rgb = {'r': 255, 'g': 99, 'b': 71}\n        result = rgbToHex(rgb)\n        self.assertEqual(result, '#ff6347')  # Expected HEX code for RGB(255, 99, 71)\n\n    def test_hex_to_rgb(self):\n        hex_code = '#ff6347'\n        result = hexToRgb(hex_code)\n        self.assertEqual(result, {'r': 255, 'g': 99, 'b': 71})  # Expected RGB object for HEX #ff6347\n\n    def test_invalid_rgb_components(self):\n        rgb = {'r': 300, 'g': -10, 'b': 128}\n        result = rgbToHex(rgb)\n        self.assertEqual(result, '#00c080')  # Clamped values should be \"00\", valid value should convert to \"80\"\n\n    def test_invalid_hex_string(self):\n        invalid_hex = '#ggg123'\n        result = hexToRgb(invalid_hex)\n        self.assertIsNone(result)  # Invalid HEX code should return None\n\n    def test_boundary_values_rgb(self):\n        rgb_black = {'r': 0, 'g': 0, 'b': 0}\n        result_black = rgbToHex(rgb_black)\n        self.assertEqual(result_black, '#000000')  # RGB(0, 0, 0) should convert to #000000\n        \n        rgb_white = {'r': 255, 'g': 255, 'b': 255}\n        result_white = rgbToHex(rgb_white)\n        self.assertEqual(result_white, '#ffffff')  # RGB(255, 255, 255) should convert to #ffffff\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef rgb_to_hex(rgb: Dict):\n    \"\"\"\n    Convert an RGB color object to a HEX color string.\n\n    Args:\n        rgb (dict): An object containing the red, green, and blue components of the color.\n                    Example: {'r': 255, 'g': 0, 'b': 0}\n\n    Returns:\n        str: A string representing the HEX color code.\n             Example: \"#FF0000\" for red.\n    \"\"\"\n\n\ndef hex_to_rgb(hex_color: str):\n    \"\"\"\n    Convert a HEX color string to an RGB color object.\n\n    Args:\n        hex_color (str): A string representing the HEX color code.\n                         Example: \"#FF0000\" for red.\n\n    Returns:\n        dict or None: An object containing the red, green, and blue components of the color.\n                       Returns None if the HEX code is invalid.\n                       Example: {'r': 255, 'g': 0, 'b': 0} for red.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - An object containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\nexport function rgbToHex(rgb) {\n\n}\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An object containing the red, green, and blue components of the color, or null if the HEX code is invalid.\n */\nexport function hexToRgb(hex) {\n\n}", "test_code": "describe('rgbToHex and hexToRgb', () => {\n\n    // Test the basic functionality of rgbToHex\n    test('should correctly convert RGB to HEX', () => {\n        const rgb = { r: 255, g: 99, b: 71 };\n        const result = rgbToHex(rgb);\n        expect(result).toBe('#ff6347'); // Expected HEX code for RGB(255, 99, 71)\n    });\n\n    // Test the basic functionality of hexToRgb\n    test('should correctly convert HEX to RGB', () => {\n        const hex = '#ff6347';\n        const result = hexToRgb(hex);\n        expect(result).toEqual({ r: 255, g: 99, b: 71 }); // Expected RGB object for HEX #ff6347\n    });\n\n    // Test rgbToHex for handling invalid values gracefully\n    test('should handle invalid RGB components gracefully', () => {\n        const rgb = { r: 300, g: -10, b: 128 };\n        const result = rgbToHex(rgb);\n        expect(result).toBe('#12c800'); // Invalid values (300, -10) should be clamped to \"00\", valid value should convert to \"80\"\n    });\n\n    // Test hexToRgb for handling invalid HEX strings\n    test('should return null for invalid HEX strings', () => {\n        const invalidHex = '#ggg123';\n        const result = hexToRgb(invalidHex);\n        expect(result).toBeNull(); // Invalid HEX code should return null\n    });\n\n    // Test rgbToHex for handling boundary values\n    test('should handle boundary values in RGB correctly', () => {\n        const rgb = { r: 0, g: 0, b: 0 };\n        const result = rgbToHex(rgb);\n        expect(result).toBe('#000000'); // Boundary RGB(0, 0, 0) should convert to #000000\n\n        const rgbWhite = { r: 255, g: 255, b: 255 };\n        const resultWhite = rgbToHex(rgbWhite);\n        expect(resultWhite).toBe('#ffffff'); // Boundary RGB(255, 255, 255) should convert to #ffffff\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - An object containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\nexport function rgbToHex(rgb) {\n\n}\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An object containing the red, green, and blue components of the color, or null if the HEX code is invalid.\n */\nexport function hexToRgb(hex) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - An object containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\nexport function rgbToHex(rgb: { r: number; g: number; b: number }): string {\n\n}\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An object containing the red, green, and blue components of the color, or null if the HEX code is invalid.\n */\nexport function hexToRgb(hex: string): { r: number; g: number; b: number } | null {\n\n}\n", "test_code": "describe('rgbToHex and hexToRgb', () => {\n\n    // \u6d4b\u8bd5 rgbToHex \u51fd\u6570\u7684\u57fa\u672c\u903b\u8f91\u529f\u80fd\n    test('should correctly convert RGB to HEX', () => {\n        const rgb = { r: 255, g: 99, b: 71 };\n        const result = rgbToHex(rgb);\n        expect(result).toBe('#ff6347'); // Expected HEX code for RGB(255, 99, 71)\n    });\n\n    // \u6d4b\u8bd5 hexToRgb \u51fd\u6570\u7684\u57fa\u672c\u903b\u8f91\u529f\u80fd\n    test('should correctly convert HEX to RGB', () => {\n        const hex = '#ff6347';\n        const result = hexToRgb(hex);\n        expect(result).toEqual({ r: 255, g: 99, b: 71 }); // Expected RGB object for HEX #ff6347\n    });\n\n    // \u6d4b\u8bd5 rgbToHex \u51fd\u6570\u7684\u5f02\u5e38\u503c\u5904\u7406\n    test('should handle invalid RGB components gracefully', () => {\n        const rgb = { r: 300, g: -10, b: 128 };\n        const result = rgbToHex(rgb);\n        expect(result).toBe('#12c-a80'); // Invalid values (300, -10) should be clamped to \"00\", valid value should convert to \"80\"\n    });\n\n    // \u6d4b\u8bd5 hexToRgb \u51fd\u6570\u7684\u5f02\u5e38\u503c\u5904\u7406\n    test('should return null for invalid HEX strings', () => {\n        const invalidHex = '#ggg123';\n        const result = hexToRgb(invalidHex);\n        expect(result).toBeNull(); // Invalid HEX code should return null\n    });\n\n    // \u6d4b\u8bd5 rgbToHex \u51fd\u6570\u7684\u8fb9\u754c\u503c\n    test('should handle boundary values in RGB correctly', () => {\n        const rgb = { r: 0, g: 0, b: 0 };\n        const result = rgbToHex(rgb);\n        expect(result).toBe('#000000'); // Boundary RGB(0, 0, 0) should convert to #000000\n\n        const rgbWhite = { r: 255, g: 255, b: 255 };\n        const resultWhite = rgbToHex(rgbWhite);\n        expect(resultWhite).toBe('#ffffff'); // Boundary RGB(255, 255, 255) should convert to #ffffff\n    });\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - An object containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\nexport function rgbToHex(rgb: { r: number; g: number; b: number }): string {\n\n}\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An object containing the red, green, and blue components of the color, or null if the HEX code is invalid.\n */\nexport function hexToRgb(hex: string): { r: number; g: number; b: number } | null {\n\n}\n", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - A struct containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\nstd::string rgbToHex(const RGB& rgb);\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An optional struct containing the red, green, and blue components of the color, or nullopt if the HEX code is invalid.\n */\nstd::optional<RGB> hexToRgb(const std::string& hex);", "test_code": "TEST_CASE(\"rgbToHex and hexToRgb\") {\n    \n    // Test the basic logic of rgbToHex function\n    SECTION(\"should correctly convert RGB to HEX\") {\n        RGB rgb = {255, 99, 71};\n        std::string result = rgbToHex(rgb);\n        REQUIRE(result == \"#ff6347\"); // Expected HEX code for RGB(255, 99, 71)\n    }\n\n    // Test the basic logic of hexToRgb function\n    SECTION(\"should correctly convert HEX to RGB\") {\n        std::string hex = \"#ff6347\";\n        auto result = hexToRgb(hex);\n        REQUIRE(result.has_value());\n        REQUIRE(result->r == 255);\n        REQUIRE(result->g == 99);\n        REQUIRE(result->b == 71); // Expected RGB object for HEX #ff6347\n    }\n\n    // Test the exception handling of rgbToHex function\n    SECTION(\"should handle invalid RGB components gracefully\") {\n        RGB rgb = {300, -10, 128};\n        std::string result = rgbToHex(rgb);\n        REQUIRE(result == \"#12c080\"); // Invalid values (300, -10) should be clamped to \"00\", valid value should convert to \"80\"\n    }\n\n    // Test the exception handling of hexToRgb function\n    SECTION(\"should return nullopt for invalid HEX strings\") {\n        std::string invalidHex = \"#ggg123\";\n        auto result = hexToRgb(invalidHex);\n        REQUIRE(!result.has_value()); // Invalid HEX code should return nullopt\n    }\n\n    // Test boundary values for rgbToHex function\n    SECTION(\"should handle boundary values in RGB correctly\") {\n        RGB rgb = {0, 0, 0};\n        std::string result = rgbToHex(rgb);\n        REQUIRE(result == \"#000000\"); // Boundary RGB(0, 0, 0) should convert to #000000\n\n        RGB rgbWhite = {255, 255, 255};\n        std::string resultWhite = rgbToHex(rgbWhite);\n        REQUIRE(resultWhite == \"#ffffff\"); // Boundary RGB(255, 255, 255) should convert to #ffffff\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - A struct containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\nstd::string rgbToHex(const RGB& rgb);\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An optional struct containing the red, green, and blue components of the color, or nullopt if the HEX code is invalid.\n */\nstd::optional<RGB> hexToRgb(const std::string& hex);", "addition_info": ""}, "java": {"code_signature": "/**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - An array containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\npublic static String rgbToHex(int[] rgb) {\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An array containing the red, green, and blue components of the color, or null if the HEX code is invalid.\n */\npublic static int[] hexToRgb(String hex) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    // Test rgbToHex function basic logic\n    @Test\n    public void testRgbToHex() {\n        int[] rgb = {255, 99, 71};\n        String result = rgbToHex(rgb);\n        assertEquals(\"#ff6347\", result); // Expected HEX code for RGB(255, 99, 71)\n    }\n\n    // Test hexToRgb function basic logic\n    @Test\n    public void testHexToRgb() {\n        String hex = \"#ff6347\";\n        int[] result = hexToRgb(hex);\n        assertArrayEquals(new int[]{255, 99, 71}, result); // Expected RGB object for HEX #ff6347\n    }\n    // Test hexToRgb function for invalid HEX strings\n    @Test\n    public void testInvalidHexString() {\n        String invalidHex = \"#ggg123\";\n        int[] result = hexToRgb(invalidHex);\n        assertNull(result); // Invalid HEX code should return null\n    }\n\n    // Test rgbToHex function boundary values\n    @Test\n    public void testBoundaryValuesInRgb() {\n        int[] rgbBlack = {0, 0, 0};\n        String resultBlack = rgbToHex(rgbBlack);\n        assertEquals(\"#000000\", resultBlack); // RGB(0, 0, 0) should convert to #000000\n\n        int[] rgbWhite = {255, 255, 255};\n        String resultWhite = rgbToHex(rgbWhite);\n        assertEquals(\"#ffffff\", resultWhite); // RGB(255, 255, 255) should convert to #ffffff\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - An array containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\npublic static String rgbToHex(int[] rgb) {\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An array containing the red, green, and blue components of the color, or null if the HEX code is invalid.\n */\npublic static int[] hexToRgb(String hex) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 151, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Convert RGB color values \u200b\u200bto HSL color values", "language_version_list": {"python": {"code_signature": "def rgb_to_hsl(rgb: dict) -> dict:\n    \"\"\"\n    Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n\n    The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n    - `h` (Hue) in the range of 0 to 360,\n    - `s` (Saturation) in the range of 0 to 100 (percentage),\n    - `l` (Lightness) in the range of 0 to 100 (percentage).\n\n    Args:\n        rgb (dict): The RGB color values.\n            - rgb['r'] (int): The red color value (0-255).\n            - rgb['g'] (int): The green color value (0-255).\n            - rgb['b'] (int): The blue color value (0-255).\n\n    Returns:\n        dict: A dictionary representing the HSL color values.\n            - h (int): The hue value (0-360).\n            - s (int): The saturation value (0-100).\n            - l (int): The lightness value (0-100).\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestRgbToHsl(unittest.TestCase):\n\n    def test_basic_rgb_red(self):\n        rgb = {'r': 255, 'g': 0, 'b': 0}\n        result = rgb_to_hsl(rgb)\n        self.assertEqual(result, {'h': 0, 's': 100, 'l': 50})\n\n    def test_grayscale_middle_gray(self):\n        rgb = {'r': 128, 'g': 128, 'b': 128}\n        result = rgb_to_hsl(rgb)\n        self.assertEqual(result, {'h': 0, 's': 0, 'l': 50})\n\n    def test_edge_case_white(self):\n        rgb = {'r': 255, 'g': 255, 'b': 255}\n        result = rgb_to_hsl(rgb)\n        self.assertEqual(result, {'h': 0, 's': 0, 'l': 100})\n\n    def test_edge_case_black(self):\n        rgb = {'r': 0, 'g': 0, 'b': 0}\n        result = rgb_to_hsl(rgb)\n        self.assertEqual(result, {'h': 0, 's': 0, 'l': 0})\n\n    def test_vibrant_green(self):\n        rgb = {'r': 0, 'g': 255, 'b': 0}\n        result = rgb_to_hsl(rgb)\n        self.assertEqual(result, {'h': 120, 's': 100, 'l': 50})\n\n    def test_deep_blue(self):\n        rgb = {'r': 0, 'g': 0, 'b': 255}\n        result = rgb_to_hsl(rgb)\n        self.assertEqual(result, {'h': 240, 's': 100, 'l': 50})\n", "prompt": "please write a python function , the function signature as below def rgb_to_hsl(rgb: dict) -> dict:\n    \"\"\"\n    Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n\n    The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n    - `h` (Hue) in the range of 0 to 360,\n    - `s` (Saturation) in the range of 0 to 100 (percentage),\n    - `l` (Lightness) in the range of 0 to 100 (percentage).\n\n    Args:\n        rgb (dict): The RGB color values.\n            - rgb['r'] (int): The red color value (0-255).\n            - rgb['g'] (int): The green color value (0-255).\n            - rgb['b'] (int): The blue color value (0-255).\n\n    Returns:\n        dict: A dictionary representing the HSL color values.\n            - h (int): The hue value (0-360).\n            - s (int): The saturation value (0-100).\n            - l (int): The lightness value (0-100).\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "please write a javascript function , the function signature as below ", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param {Object} rgb - The RGB color values.\n * @param {number} rgb.r - The red color value (0-255).\n * @param {number} rgb.g - The green color value (0-255).\n * @param {number} rgb.b - The blue color value (0-255).\n * @returns {Object} An object representing the HSL color values.\n * @returns {number} h - The hue value (0-360).\n * @returns {number} s - The saturation value (0-100).\n * @returns {number} l - The lightness value (0-100).\n */\nfunction rgbToHsl({r, g, b}: { r: number; g: number; b: number }): { h: number; s: number; l: number } {\n\n}\n", "test_code": "describe('rgbToHsl', () => {\n    test('should convert basic RGB values correctly (red)', () => {\n        const rgb = { r: 255, g: 0, b: 0 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 100, l: 50 });\n    });\n\n    test('should handle grayscale values (middle gray)', () => {\n        const rgb = { r: 128, g: 128, b: 128 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 50 });\n    });\n\n    test('should handle edge cases (white color)', () => {\n        const rgb = { r: 255, g: 255, b: 255 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 100 });\n    });\n\n    test('should handle edge cases (black color)', () => {\n        const rgb = { r: 0, g: 0, b: 0 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 0 });\n    });\n\n    // Additional tests\n    test('should handle vibrant green', () => {\n        const rgb = { r: 0, g: 255, b: 0 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 120, s: 100, l: 50 });\n    });\n\n    test('should handle deep blue', () => {\n        const rgb = { r: 0, g: 0, b: 255 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 240, s: 100, l: 50 });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param {Object} rgb - The RGB color values.\n * @param {number} rgb.r - The red color value (0-255).\n * @param {number} rgb.g - The green color value (0-255).\n * @param {number} rgb.b - The blue color value (0-255).\n * @returns {Object} An object representing the HSL color values.\n * @returns {number} h - The hue value (0-360).\n * @returns {number} s - The saturation value (0-100).\n * @returns {number} l - The lightness value (0-100).\n */\nfunction rgbToHsl({r, g, b}: { r: number; g: number; b: number }): { h: number; s: number; l: number } {\n\n}\n", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param rgb - The RGB color values.\n * @param rgb.r - The red color value (0-255).\n * @param rgb.g - The green color value (0-255).\n * @param rgb.b - The blue color value (0-255).\n * @returns An object representing the HSL color values.\n * @returns h - The hue value (0-360).\n * @returns s - The saturation value (0-100).\n * @returns l - The lightness value (0-100).\n */\nHSL rgbToHsl(const RGB& rgb);", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include \"color_conversion.h\" // Include your header file where rgbToHsl is defined\n\nTEST_CASE(\"rgbToHsl\", \"[color_conversion]\") {\n    SECTION(\"should convert basic RGB values correctly (red)\") {\n        RGB rgb = {255, 0, 0};\n        HSL result = rgbToHsl(rgb);\n        REQUIRE(result.h == 0);\n        REQUIRE(result.s == 100);\n        REQUIRE(result.l == 50);\n    }\n\n    SECTION(\"should handle grayscale values (middle gray)\") {\n        RGB rgb = {128, 128, 128};\n        HSL result = rgbToHsl(rgb);\n        REQUIRE(result.h == 0);\n        REQUIRE(result.s == 0);\n        REQUIRE(result.l == 50);\n    }\n\n    SECTION(\"should handle edge cases (white color)\") {\n        RGB rgb = {255, 255, 255};\n        HSL result = rgbToHsl(rgb);\n        REQUIRE(result.h == 0);\n        REQUIRE(result.s == 0);\n        REQUIRE(result.l == 100);\n    }\n\n    SECTION(\"should handle edge cases (black color)\") {\n        RGB rgb = {0, 0, 0};\n        HSL result = rgbToHsl(rgb);\n        REQUIRE(result.h == 0);\n        REQUIRE(result.s == 0);\n        REQUIRE(result.l == 0);\n    }\n\n    // Additional tests\n    SECTION(\"should handle vibrant green\") {\n        RGB rgb = {0, 255, 0};\n        HSL result = rgbToHsl(rgb);\n        REQUIRE(result.h == 120);\n        REQUIRE(result.s == 100);\n        REQUIRE(result.l == 50);\n    }\n\n    SECTION(\"should handle deep blue\") {\n        RGB rgb = {0, 0, 255};\n        HSL result = rgbToHsl(rgb);\n        REQUIRE(result.h == 240);\n        REQUIRE(result.s == 100);\n        REQUIRE(result.l == 50);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param rgb - The RGB color values.\n * @param rgb.r - The red color value (0-255).\n * @param rgb.g - The green color value (0-255).\n * @param rgb.b - The blue color value (0-255).\n * @returns An object representing the HSL color values.\n * @returns h - The hue value (0-360).\n * @returns s - The saturation value (0-100).\n * @returns l - The lightness value (0-100).\n */\nHSL rgbToHsl(const RGB& rgb);", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param r The red color value (0-255).\n * @param g The green color value (0-255).\n * @param b The blue color value (0-255).\n * @return An HSL object representing the HSL color values.\n * @return.h The hue value (0-360).\n * @return.s The saturation value (0-100).\n * @return.l The lightness value (0-100).\n */\npublic static class HSL {\n    public int h;\n    public int s;\n    public int l;\n\n    public HSL(int h, int s, int l) {\n        this.h = h;\n        this.s = s;\n        this.l = l;\n    }\n}\npublic static HSL rgbToHsl(int r, int g, int b) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testRgbToHslRed() {\n        HSL result = rgbToHsl(255, 0, 0);\n        assertEquals(0, result.h);\n        assertEquals(100, result.s);\n        assertEquals(50, result.l);\n    }\n\n    @Test\n    public void testRgbToHslMiddleGray() {\n        HSL result = rgbToHsl(128, 128, 128);\n        assertEquals(0, result.h);\n        assertEquals(0, result.s);\n        assertEquals(50, result.l);\n    }\n\n    @Test\n    public void testRgbToHslWhite() {\n        HSL result = rgbToHsl(255, 255, 255);\n        assertEquals(0, result.h);\n        assertEquals(0, result.s);\n        assertEquals(100, result.l);\n    }\n\n    @Test\n    public void testRgbToHslBlack() {\n        HSL result = rgbToHsl(0, 0, 0);\n        assertEquals(0, result.h);\n        assertEquals(0, result.s);\n        assertEquals(0, result.l);\n    }\n\n    @Test\n    public void testRgbToHslVibrantGreen() {\n        HSL result = rgbToHsl(0, 255, 0);\n        assertEquals(120, result.h);\n        assertEquals(100, result.s);\n        assertEquals(50, result.l);\n    }\n\n    @Test\n    public void testRgbToHslDeepBlue() {\n        HSL result = rgbToHsl(0, 0, 255);\n        assertEquals(240, result.h);\n        assertEquals(100, result.s);\n        assertEquals(50, result.l);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param r The red color value (0-255).\n * @param g The green color value (0-255).\n * @param b The blue color value (0-255).\n * @return An HSL object representing the HSL color values.\n * @return.h The hue value (0-360).\n * @return.s The saturation value (0-100).\n * @return.l The lightness value (0-100).\n */\npublic static class HSL {\n    public int h;\n    public int s;\n    public int l;\n\n    public HSL(int h, int s, int l) {\n        this.h = h;\n        this.s = s;\n        this.l = l;\n    }\n}\npublic static HSL rgbToHsl(int r, int g, int b) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 152, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Converts each character in the input string to the corresponding \"mathematical sans serif italic\" character.", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a given string into its corresponding mathematical sans-serif italic characters.\n *\n * @param input The input string to be converted.\n * @returns The converted string with each character replaced by its mathematical sans-serif italic equivalent.\n */\nfunction convertToMathematicalSansSerifItalic(input) {\n\n}", "test_code": "describe('convertToMathematicalSansSerifItalic', () => {\n    test('should return an empty string when input is an empty string', () => {\n        const input = '';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe(''); // Edge case: empty string\n    });\n\n    test('should correctly convert all uppercase and lowercase letters to mathematical sans-serif italic', () => {\n        const input = 'HelloWorld';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc6f\ud835\udc86\ud835\udc8d\ud835\udc8d\ud835\udc90\ud835\udc7e\ud835\udc90\ud835\udc93\ud835\udc8d\ud835\udc85'); // Basic logic: mixed case\n    });\n\n    test('should leave characters unchanged if they have no corresponding mathematical sans-serif italic equivalent', () => {\n        const input = '12345!@#';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udfe3\ud835\udfe4\ud835\udfe5\ud835\udfe6\ud835\udfe7!@#'); // Basic logic: numbers with special characters\n    });\n\n    test('should handle input with a mix of convertible and non-convertible characters', () => {\n        const input = 'Math123!';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc74\ud835\udc82\ud835\udc95\ud835\udc89\ud835\udfe3\ud835\udfe4\ud835\udfe5!'); // Basic logic: mix of letters, numbers, and special characters\n    });\n\n    test('should handle edge case where input is at the boundary of supported characters', () => {\n        const input = 'A0z9';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc68\ud835\udfe2\ud835\udc9b\ud835\udfeb'); // Boundary values: 'A', '0', 'z', '9'\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a given string into its corresponding mathematical sans-serif italic characters.\n *\n * @param input The input string to be converted.\n * @returns The converted string with each character replaced by its mathematical sans-serif italic equivalent.\n */\nfunction convertToMathematicalSansSerifItalic(input) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a given string into its corresponding mathematical sans-serif italic characters.\n *\n * @param input The input string to be converted.\n * @returns The converted string with each character replaced by its mathematical sans-serif italic equivalent.\n */\nfunction convertToMathematicalSansSerifItalic(input: string): string {\n\n}", "test_code": "describe('convertToMathematicalSansSerifItalic', () => {\n    test('should return an empty string when input is an empty string', () => {\n        const input = '';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe(''); // Edge case: empty string\n    });\n\n    test('should correctly convert all uppercase and lowercase letters to mathematical sans-serif italic', () => {\n        const input = 'HelloWorld';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc6f\ud835\udc86\ud835\udc8d\ud835\udc8d\ud835\udc90\ud835\udc7e\ud835\udc90\ud835\udc93\ud835\udc8d\ud835\udc85'); // Basic logic: mixed case\n    });\n\n    test('should leave characters unchanged if they have no corresponding mathematical sans-serif italic equivalent', () => {\n        const input = '12345!@#';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udfe3\ud835\udfe4\ud835\udfe5\ud835\udfe6\ud835\udfe7!@#'); // Basic logic: numbers with special characters\n    });\n\n    test('should handle input with a mix of convertible and non-convertible characters', () => {\n        const input = 'Math123!';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc74\ud835\udc82\ud835\udc95\ud835\udc89\ud835\udfe3\ud835\udfe4\ud835\udfe5!'); // Basic logic: mix of letters, numbers, and special characters\n    });\n\n    test('should handle edge case where input is at the boundary of supported characters', () => {\n        const input = 'A0z9';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc68\ud835\udfe2\ud835\udc9b\ud835\udfeb'); // Boundary values: 'A', '0', 'z', '9'\n    });\n});\n\n\n", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a given string into its corresponding mathematical sans-serif italic characters.\n *\n * @param input The input string to be converted.\n * @returns The converted string with each character replaced by its mathematical sans-serif italic equivalent.\n */\nfunction convertToMathematicalSansSerifItalic(input: string): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 153, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "The input hash buffer is compressed into a number letter string of length no less than 5", "language_version_list": {"python": {"code_signature": "def compress_hash(hash_bytes: bytes) -> str:\n    \"\"\"\n    Compresses the input hash buffer into a string representation of at least length 5.\n\n    Args:\n        hash_bytes (bytes): The hash buffer to be compressed.\n\n    Returns:\n        str: A compressed string representation of the hash.\n              The output string will have a length no less than 5.\n    \"\"\"", "test_code": "import hashlib\nimport unittest\n\n\nclass TestCompressHash(unittest.TestCase):\n\n    def test_length_of_result(self):\n        \"\"\"should return a string of length 5\"\"\"\n        hash_bytes = hashlib.sha256(b'test').digest()\n        result = compress_hash(hash_bytes)\n        self.assertEqual(len(result), 5)\n\n    def test_different_inputs(self):\n        \"\"\"should return different strings for different inputs\"\"\"\n        hash1 = hashlib.sha256(b'test1').digest()\n        hash2 = hashlib.sha256(b'test2').digest()\n        result1 = compress_hash(hash1)\n        result2 = compress_hash(hash2)\n        self.assertNotEqual(result1, result2)\n\n    def test_consistent_result_for_same_input(self):\n        \"\"\"should return a consistent result for the same input\"\"\"\n        hash_bytes = hashlib.sha256(b'test').digest()\n        result1 = compress_hash(hash_bytes)\n        result2 = compress_hash(hash_bytes)\n        self.assertEqual(result1, result2)\n\n    def test_all_zeros(self):\n        \"\"\"should handle a hash of all zeros\"\"\"\n        hash_bytes = bytes([0] * 32)  # 32 bytes of zeros\n        result = compress_hash(hash_bytes)\n        self.assertRegex(result, r'^[0-9a-zA-Z]{5}$')\n\n    def test_all_ones(self):\n        \"\"\"should handle a hash of all ones\"\"\"\n        hash_bytes = bytes([255] * 32)  # 32 bytes of 0xFF (255 in decimal)\n        result = compress_hash(hash_bytes)\n        self.assertRegex(result, r'^[0-9a-zA-Z]{5}$')\n", "prompt": "please write a python function , the function signature as below def compress_hash(hash_bytes: bytes) -> str:\n    \"\"\"\n    Compresses the input hash buffer into a string representation of at least length 5.\n\n    Args:\n        hash_bytes (bytes): The hash buffer to be compressed.\n\n    Returns:\n        str: A compressed string representation of the hash.\n              The output string will have a length no less than 5.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * The input hash buffer is compressed into a number letter string of length no less than 5\n *\n * @param {Buffer} hash - The hash buffer to be compressed.\n * @returns {string} A compressed string representation of the hash.\n */\nfunction compressHash(hash) {\n    // Implementation goes here\n}", "test_code": "describe('compressHash', () => {\n\n    test('should return a string of length 5', () => {\n        const hash = crypto.createHash('sha256').update('test').digest();\n        const result = compressHash(hash);\n        expect(result.length).toBe(5);\n    });\n\n    test('should return different strings for different inputs', () => {\n        const hash1 = crypto.createHash('sha256').update('test1').digest();\n        const hash2 = crypto.createHash('sha256').update('test2').digest();\n        const result1 = compressHash(hash1);\n        const result2 = compressHash(hash2);\n        expect(result1).not.toBe(result2);\n    });\n\n    test('should return a consistent result for the same input', () => {\n        const hash = crypto.createHash('sha256').update('test').digest();\n        const result1 = compressHash(hash);\n        const result2 = compressHash(hash);\n        expect(result1).toBe(result2);\n    });\n\n    test('should handle a hash of all zeros', () => {\n        const hash = Buffer.alloc(32, 0); // 32 bytes of zeros\n        const result = compressHash(hash);\n        expect(result).toMatch(/^[0-9a-zA-Z]{5}$/);\n    });\n\n    test('should handle a hash of all ones', () => {\n        const hash = Buffer.alloc(32, 255); // 32 bytes of 0xFF (255 in decimal)\n        const result = compressHash(hash);\n        expect(result).toMatch(/^[0-9a-zA-Z]{5}$/);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * The input hash buffer is compressed into a number letter string of length no less than 5\n *\n * @param {Buffer} hash - The hash buffer to be compressed.\n * @returns {string} A compressed string representation of the hash.\n */\nfunction compressHash(hash) {\n    // Implementation goes here\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * The input hash buffer is compressed into a number letter string of length no less than 5\n *\n * @param {Buffer} hash - The hash buffer to be compressed.\n * @returns {string} A compressed string representation of the hash.\n */\n// @ts-ignore\nfunction compressHash(hash: Buffer): string {\n\n}", "test_code": "// @ts-ignore\nconst crypto = require('crypto');\n\ndescribe('compressHash', () => {\n\n    test('should return a string of length 5', () => {\n        // @ts-ignore\n        const hash = crypto.createHash('sha256').update('test').digest();\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result.length).toBe(5);\n    });\n\n    test('should return different strings for different inputs', () => {\n        // @ts-ignore\n        const hash1 = crypto.createHash('sha256').update('test1').digest();\n        // @ts-ignore\n        const hash2 = crypto.createHash('sha256').update('test2').digest();\n        // @ts-ignore\n        const result1 = compressHash(hash1);\n        // @ts-ignore\n        const result2 = compressHash(hash2);\n        expect(result1).not.toBe(result2);\n    });\n\n    test('should return a consistent model_answer_result for the same input', () => {\n        // @ts-ignore\n        const hash = crypto.createHash('sha256').update('test').digest();\n        // @ts-ignore\n        const result1 = compressHash(hash);\n        // @ts-ignore\n        const result2 = compressHash(hash);\n        expect(result1).toBe(result2);\n    });\n\n    test('should handle a hash of all zeros', () => {\n        const hash = Buffer.alloc(32, 0); // 32 bytes of zeros\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result).toMatch(/^[0-9a-zA-Z]{5}$/);\n    });\n\n    test('should handle a hash of all ones', () => {\n        const hash = Buffer.alloc(32, 255); // 32 bytes of 0xFF (255 in decimal)\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result).toMatch(/^[0-9a-zA-Z]{5}$/);\n    });\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * The input hash buffer is compressed into a number letter string of length no less than 5\n *\n * @param {Buffer} hash - The hash buffer to be compressed.\n * @returns {string} A compressed string representation of the hash.\n */\n// @ts-ignore\nfunction compressHash(hash: Buffer): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * The input hash string is compressed into a number letter string of length no less than 5\n *\n * @param hash - The hash string to be compressed.\n * @returns A compressed string representation of the hash.\n */\nstd::string compressHash(const std::string& hash) {\n    // Function implementation will go here\n}", "test_code": "TEST_CASE(\"compressHash\") {\n    SECTION(\"should return a string of length 5\") {\n        std::string hash = createHash(\"test\");\n        std::string result = compressHash(hash);\n        REQUIRE(result.length() == 5);\n    }\n\n    SECTION(\"should return different strings for different inputs\") {\n        std::string hash1 = createHash(\"test1\");\n        std::string hash2 = createHash(\"test2\");\n        std::string result1 = compressHash(hash1);\n        std::string result2 = compressHash(hash2);\n        REQUIRE(result1 != result2);\n    }\n\n    SECTION(\"should return a consistent result for the same input\") {\n        std::string hash = createHash(\"test\");\n        std::string result1 = compressHash(hash);\n        std::string result2 = compressHash(hash);\n        REQUIRE(result1 == result2);\n    }\n\n    SECTION(\"should handle a hash of all zeros\") {\n        unsigned char zeroHash[32] = {0}; // 32 bytes of zeros\n        std::string result = compressHash(std::string(reinterpret_cast<char*>(zeroHash), 32));\n        REQUIRE(std::regex_match(result, std::regex(\"^[0-9a-zA-Z]{5}$\")));\n    }\n\n    SECTION(\"should handle a hash of all ones\") {\n        unsigned char oneHash[32] = {255}; // 32 bytes of 0xFF (255 in decimal)\n        std::string result = compressHash(std::string(reinterpret_cast<char*>(oneHash), 32));\n        REQUIRE(std::regex_match(result, std::regex(\"^[0-9a-zA-Z]{5}$\")));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * The input hash string is compressed into a number letter string of length no less than 5\n *\n * @param hash - The hash string to be compressed.\n * @returns A compressed string representation of the hash.\n */\nstd::string compressHash(const std::string& hash) {\n    // Function implementation will go here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * The input hash buffer is compressed into a number letter string of length no less than 5\n *\n * @param hash - The hash buffer to be compressed.\n * @return A compressed string representation of the hash.\n */\npublic static String compressHash(ByteBuffer hash) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\nimport java.nio.ByteBuffer;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    /**\n     * Utility method to create SHA-256 hash from a string.\n     */\n    private ByteBuffer createHash(String input) throws NoSuchAlgorithmException {\n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = digest.digest(input.getBytes());\n        return ByteBuffer.wrap(hash);\n    }\n\n    @Test\n    public void testShouldReturnStringOfLength5() throws NoSuchAlgorithmException {\n        ByteBuffer hash = createHash(\"test\");\n        String result = compressHash(hash);\n        assertEquals(5, result.length());\n    }\n\n    @Test\n    public void testShouldReturnDifferentStringsForDifferentInputs() throws NoSuchAlgorithmException {\n        ByteBuffer hash1 = createHash(\"test1\");\n        ByteBuffer hash2 = createHash(\"test2\");\n        String result1 = compressHash(hash1);\n        String result2 = compressHash(hash2);\n        assertNotEquals(result1, result2);\n    }\n\n    @Test\n    public void testShouldReturnConsistentResultForSameInput() throws NoSuchAlgorithmException {\n        ByteBuffer hash = createHash(\"test\");\n        String result1 = compressHash(hash);\n        String result2 = compressHash(hash);\n        assertEquals(result1, result2);\n    }\n\n    @Test\n    public void testShouldHandleHashOfAllZeros() {\n        ByteBuffer hash = ByteBuffer.allocate(32).put(new byte[32]);\n        String result = compressHash(hash);\n        assertTrue(result.matches(\"^[0-9a-zA-Z]{5}$\"));\n    }\n\n    @Test\n    public void testShouldHandleHashOfAllOnes() {\n        ByteBuffer hash = ByteBuffer.allocate(32).put(new byte[32]); // 32 bytes of 0xFF\n        for (int i = 0; i < 32; i++) {\n            hash.put(i, (byte) 0xFF);\n        }\n        String result = compressHash(hash);\n        assertTrue(result.matches(\"^[0-9a-zA-Z]{5}$\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * The input hash buffer is compressed into a number letter string of length no less than 5\n *\n * @param hash - The hash buffer to be compressed.\n * @return A compressed string representation of the hash.\n */\npublic static String compressHash(ByteBuffer hash) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 154, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Parsing a string containing the contents of a Git diff returns an array of objects with details of each file's changes", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef parse_git_diff(diff_text: str) -> List:\n    \"\"\"\n    Parses a string containing the contents of a Git diff and returns a list of objects\n    detailing the changes for each file.\n\n    Args:\n        diff_text (str): The Git diff text to parse.\n\n    Returns:\n        list: A list of objects representing the diff for each file, where each object contains\n              details about the changes, such as file name, added lines, and removed lines.\n    \"\"\"", "test_code": "import unittest\n\nclass TestParseGitDiff(unittest.TestCase):\n\n    def test_parse_simple_file_addition(self):\n        diff_text = (\n            \"diff --git a/file.txt b/file.txt\\n\"\n            \"new file mode 100644\\n\"\n            \"index 0000000..e69de29\\n\"\n            \"--- /dev/null\\n\"\n            \"+++ b/file.txt\"\n        )\n        result = parse_git_diff(diff_text)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0].oldPath, 'file.txt')\n        self.assertEqual(result[0].newPath, 'file.txt')\n        self.assertEqual(result[0].newFileMode, '100644')\n\n    def test_parse_simple_file_deletion(self):\n        diff_text = (\n            \"diff --git a/file.txt b/file.txt\\n\"\n            \"deleted file mode 100644\\n\"\n            \"index e69de29..0000000\\n\"\n            \"--- a/file.txt\\n\"\n            \"+++ /dev/null\"\n        )\n        result = parse_git_diff(diff_text)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0].oldPath, 'file.txt')\n        self.assertEqual(result[0].newPath, 'file.txt')\n        self.assertEqual(result[0].deletedFileMode, '100644')\n\n    def test_parse_file_modification_with_changes(self):\n        diff_text = (\n            \"diff --git a/file.txt b/file.txt\\n\"\n            \"index e69de29..d95f3ad 100644\\n\"\n            \"--- a/file.txt\\n\"\n            \"+++ b/file.txt\\n\"\n            \"@@ -0,0 +1 @@\\n\"\n            \"+Hello World\"\n        )\n        result = parse_git_diff(diff_text)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0].oldPath, 'file.txt')\n        self.assertEqual(result[0].newPath, 'file.txt')\n        self.assertEqual(result[0].index, 'e69de29..d95f3ad')\n        self.assertEqual(result[0].changes, [\n            {\"code\": \"--- a/file.txt\"},\n            {\"code\": \"+++ b/file.txt\"},\n            {\"diff\": '@@ -0,0 +1 @@'},\n            {\"code\": '+Hello World'}\n        ])\n\n    def test_handle_multiple_file_diffs(self):\n        diff_text = (\n            \"diff --git a/file1.txt b/file1.txt\\n\"\n            \"index e69de29..d95f3ad 100644\\n\"\n            \"--- a/file1.txt\\n\"\n            \"+++ b/file1.txt\\n\"\n            \"@@ -0,0 +1 @@\\n\"\n            \"+Hello World\\n\"\n            \"diff --git a/file2.txt b/file2.txt\\n\"\n            \"index 0a1b2c3..d4e5f6a 100644\\n\"\n            \"--- a/file2.txt\\n\"\n            \"+++ b/file2.txt\\n\"\n            \"@@ -1 +1 @@\\n\"\n            \"-Hello\\n\"\n            \"+Hi\"\n        )\n        result = parse_git_diff(diff_text)\n        self.assertEqual(len(result), 2)\n        self.assertEqual(result[0].oldPath, 'file1.txt')\n        self.assertEqual(result[1].oldPath, 'file2.txt')\n\n    def test_return_empty_array_for_empty_diff_text(self):\n        result = parse_git_diff('')\n        self.assertEqual(result, [])\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef parse_git_diff(diff_text: str) -> List:\n    \"\"\"\n    Parses a string containing the contents of a Git diff and returns a list of objects\n    detailing the changes for each file.\n\n    Args:\n        diff_text (str): The Git diff text to parse.\n\n    Returns:\n        list: A list of objects representing the diff for each file, where each object contains\n              details about the changes, such as file name, added lines, and removed lines.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Parsing a string containing the contents of a Git diff returns an array of objects with details of each file's changes\n *\n * @param {string} diffText - The Git diff text to parse.\n * @returns {Array} - An array of objects representing the diff for each file.\n */\n// @ts-ignore\nfunction parseGitDiff(diffText) {\n}", "test_code": "describe('parseGitDiff', () => {\n\n    test('should parse a simple file addition', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\nnew file mode 100644\nindex 0000000..e69de29\n--- /dev/null\n+++ b/file.txt`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(1);\n        expect(result[0].oldPath).toBe('file.txt');\n        expect(result[0].newPath).toBe('file.txt');\n        expect(result[0].newFileMode).toBe('100644');\n    });\n\n    test('should parse a simple file deletion', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\ndeleted file mode 100644\nindex e69de29..0000000\n--- a/file.txt\n+++ /dev/null`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(1);\n        expect(result[0].oldPath).toBe('file.txt');\n        expect(result[0].newPath).toBe('file.txt');\n        expect(result[0].deletedFileMode).toBe('100644');\n    });\n\n    test('should parse a file modification with changes', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\nindex e69de29..d95f3ad 100644\n--- a/file.txt\n+++ b/file.txt\n@@ -0,0 +1 @@\n+Hello World`;\n\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n\n        expect(result).toHaveLength(1); // Ensure only one file diff is parsed\n        expect(result[0].oldPath).toBe('file.txt'); // Validate old file path\n        expect(result[0].newPath).toBe('file.txt'); // Validate new file path\n        expect(result[0].index).toBe('e69de29..d95f3ad'); // Validate index value\n        expect(result[0].changes).toEqual([\n            { code: \"--- a/file.txt\" }, // Validate old file path line\n            { code: \"+++ b/file.txt\" }, // Validate new file path line\n            { diff: '@@ -0,0 +1 @@' },  // Validate diff header\n            { code: '+Hello World' }     // Validate code addition\n        ]); // Validate changes array\n    });\n\n    test('should handle multiple file diffs', () => {\n        const diffText = `diff --git a/file1.txt b/file1.txt\nindex e69de29..d95f3ad 100644\n--- a/file1.txt\n+++ b/file1.txt\n@@ -0,0 +1 @@\n+Hello World\ndiff --git a/file2.txt b/file2.txt\nindex 0a1b2c3..d4e5f6a 100644\n--- a/file2.txt\n+++ b/file2.txt\n@@ -1 +1 @@\n-Hello\n+Hi`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(2);\n        expect(result[0].oldPath).toBe('file1.txt');\n        expect(result[1].oldPath).toBe('file2.txt');\n    });\n\n    test('should return an empty array for empty diff text', () => {\n        // @ts-ignore\n        const result = parseGitDiff('');\n        expect(result).toEqual([]);\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Parsing a string containing the contents of a Git diff returns an array of objects with details of each file's changes\n *\n * @param {string} diffText - The Git diff text to parse.\n * @returns {Array} - An array of objects representing the diff for each file.\n */\n// @ts-ignore\nfunction parseGitDiff(diffText) {\n}", "addition_info": ""}, "typescript": {"code_signature": "// Define the types for the objects we're working with\ninterface GitDiffChange {\n    diff?: string;\n    code?: string;\n}\n\ninterface GitDiffFile {\n    oldPath: string;\n    newPath: string;\n    changes: GitDiffChange[];\n    newFileMode: string | null;\n    deletedFileMode: string | null;\n    index: string | null;\n}\n\n/**\n * Parsing a string containing the contents of a Git diff returns an array of objects with details of each file's changes\n *\n * @param {string} diffText - The Git diff text to parse.\n * @returns {GitDiffFile[]} - An array of objects representing the diff for each file.\n */\n// @ts-ignore\nexport function parseGitDiff(diffText: string): GitDiffFile[] {\n\n}", "test_code": "describe('parseGitDiff', () => {\n\n    test('should parse a simple file addition', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\nnew file mode 100644\nindex 0000000..e69de29\n--- /dev/null\n+++ b/file.txt`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(1);\n        expect(result[0].oldPath).toBe('file.txt');\n        expect(result[0].newPath).toBe('file.txt');\n        expect(result[0].newFileMode).toBe('100644');\n    });\n\n    test('should parse a simple file deletion', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\ndeleted file mode 100644\nindex e69de29..0000000\n--- a/file.txt\n+++ /dev/null`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(1);\n        expect(result[0].oldPath).toBe('file.txt');\n        expect(result[0].newPath).toBe('file.txt');\n        expect(result[0].deletedFileMode).toBe('100644');\n    });\n\n    test('should parse a file modification with changes', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\nindex e69de29..d95f3ad 100644\n--- a/file.txt\n+++ b/file.txt\n@@ -0,0 +1 @@\n+Hello World`;\n\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n\n        expect(result).toHaveLength(1); // Ensure only one file diff is parsed\n        expect(result[0].oldPath).toBe('file.txt'); // Validate old file path\n        expect(result[0].newPath).toBe('file.txt'); // Validate new file path\n        expect(result[0].index).toBe('e69de29..d95f3ad'); // Validate index value\n        expect(result[0].changes).toEqual([\n            {code: \"--- a/file.txt\"}, // Validate old file path line\n            {code: \"+++ b/file.txt\"}, // Validate new file path line\n            {diff: '@@ -0,0 +1 @@'},  // Validate diff header\n            {code: '+Hello World'}     // Validate code addition\n        ]); // Validate changes array\n    });\n\n    test('should handle multiple file diffs', () => {\n        const diffText = `diff --git a/file1.txt b/file1.txt\nindex e69de29..d95f3ad 100644\n--- a/file1.txt\n+++ b/file1.txt\n@@ -0,0 +1 @@\n+Hello World\ndiff --git a/file2.txt b/file2.txt\nindex 0a1b2c3..d4e5f6a 100644\n--- a/file2.txt\n+++ b/file2.txt\n@@ -1 +1 @@\n-Hello\n+Hi`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(2);\n        expect(result[0].oldPath).toBe('file1.txt');\n        expect(result[1].oldPath).toBe('file2.txt');\n    });\n\n    test('should return an empty array for empty diff text', () => {\n        // @ts-ignore\n        const result = parseGitDiff('');\n        expect(result).toEqual([]);\n    });\n\n});", "prompt": "please write a typescript function , the function signature as below // Define the types for the objects we're working with\ninterface GitDiffChange {\n    diff?: string;\n    code?: string;\n}\n\ninterface GitDiffFile {\n    oldPath: string;\n    newPath: string;\n    changes: GitDiffChange[];\n    newFileMode: string | null;\n    deletedFileMode: string | null;\n    index: string | null;\n}\n\n/**\n * Parsing a string containing the contents of a Git diff returns an array of objects with details of each file's changes\n *\n * @param {string} diffText - The Git diff text to parse.\n * @returns {GitDiffFile[]} - An array of objects representing the diff for each file.\n */\n// @ts-ignore\nexport function parseGitDiff(diffText: string): GitDiffFile[] {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 155, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Computes the difference between the specified date and the current time, returning it in a human-readable way", "language_version_list": {"python": {"code_signature": "from datetime import datetime\n\n\ndef get_timestamp(created_at: datetime) -> str:\n    \"\"\"Computes the difference between the specified date and the current time, returning it in a human-readable way.\n    \n    Args:\n        created_at (datetime): The date to calculate the time difference from.\n        \n    Returns:\n        str: A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n    \"\"\"\n", "test_code": "import unittest\nfrom datetime import datetime, timedelta\n\nclass TestGetTimestamp(unittest.TestCase):\n\n    def test_one_second_ago(self):\n        one_second_ago = datetime.now() - timedelta(seconds=1)  # 1 second ago\n        self.assertEqual(get_timestamp(one_second_ago), '1 second ago')\n\n    def test_five_minutes_ago(self):\n        five_minutes_ago = datetime.now() - timedelta(minutes=5)  # 5 minutes ago\n        self.assertEqual(get_timestamp(five_minutes_ago), '5 minutes ago')\n\n    def test_two_hours_ago(self):\n        two_hours_ago = datetime.now() - timedelta(hours=2)  # 2 hours ago\n        self.assertEqual(get_timestamp(two_hours_ago), '2 hours ago')\n\n    def test_three_days_ago(self):\n        three_days_ago = datetime.now() - timedelta(days=3)  # 3 days ago\n        self.assertEqual(get_timestamp(three_days_ago), '3 days ago')", "prompt": "please write a python function , the function signature as below from datetime import datetime\n\n\ndef get_timestamp(created_at: datetime) -> str:\n    \"\"\"Computes the difference between the specified date and the current time, returning it in a human-readable way.\n    \n    Args:\n        created_at (datetime): The date to calculate the time difference from.\n        \n    Returns:\n        str: A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way\n *\n * @param {Date} createdAt - The date to calculate the time difference from.\n * @returns {string} A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\nexport const getTimestamp = (createdAt) => {\n    // Your implementation here\n};", "test_code": "describe('getTimestamp', () => {\n    test('should return \"1 second ago\" for a date 1 second ago', () => {\n        const oneSecondAgo = new Date(new Date().getTime() - 1000); // 1 second ago\n        expect(getTimestamp(oneSecondAgo)).toBe('1 second ago');\n    });\n\n    test('should return \"5 minutes ago\" for a date 5 minutes ago', () => {\n        const fiveMinutesAgo = new Date(new Date().getTime() - 5 * 60 * 1000); // 5 minutes ago\n        expect(getTimestamp(fiveMinutesAgo)).toBe('5 minutes ago');\n    });\n\n    test('should return \"2 hours ago\" for a date 2 hours ago', () => {\n        const twoHoursAgo = new Date(new Date().getTime() - 2 * 60 * 60 * 1000); // 2 hours ago\n        expect(getTimestamp(twoHoursAgo)).toBe('2 hours ago');\n    });\n\n    test('should return \"3 days ago\" for a date 3 days ago', () => {\n        const threeDaysAgo = new Date(new Date().getTime() - 3 * 24 * 60 * 60 * 1000); // 3 days ago\n        expect(getTimestamp(threeDaysAgo)).toBe('3 days ago');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way\n *\n * @param {Date} createdAt - The date to calculate the time difference from.\n * @returns {string} A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\nexport const getTimestamp = (createdAt) => {\n    // Your implementation here\n};", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way\n *\n * @param {Date} createdAt - The date to calculate the time difference from.\n * @returns {string} A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\n// @ts-ignore\nexport const getTimestamp = (createdAt: Date): string => {\n\n}", "test_code": "describe('getTimestamp', () => {\n    test('should return \"1 second ago\" for a date 1 second ago', () => {\n        const oneSecondAgo = new Date(new Date().getTime() - 1000); // 1 second ago\n        // @ts-ignore\n        expect(getTimestamp(oneSecondAgo)).toBe('1 second ago');\n    });\n\n    test('should return \"5 minutes ago\" for a date 5 minutes ago', () => {\n        const fiveMinutesAgo = new Date(new Date().getTime() - 5 * 60 * 1000); // 5 minutes ago\n        // @ts-ignore\n        expect(getTimestamp(fiveMinutesAgo)).toBe('5 minutes ago');\n    });\n\n    test('should return \"2 hours ago\" for a date 2 hours ago', () => {\n        const twoHoursAgo = new Date(new Date().getTime() - 2 * 60 * 60 * 1000); // 2 hours ago\n        // @ts-ignore\n        expect(getTimestamp(twoHoursAgo)).toBe('2 hours ago');\n    });\n\n    test('should return \"3 days ago\" for a date 3 days ago', () => {\n        const threeDaysAgo = new Date(new Date().getTime() - 3 * 24 * 60 * 60 * 1000); // 3 days ago\n        // @ts-ignore\n        expect(getTimestamp(threeDaysAgo)).toBe('3 days ago');\n    });\n\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way\n *\n * @param {Date} createdAt - The date to calculate the time difference from.\n * @returns {string} A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\n// @ts-ignore\nexport const getTimestamp = (createdAt: Date): string => {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way\n *\n * @param createdAt - The date to calculate the time difference from.\n * @returns A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\nstd::string getTimestamp(std::chrono::system_clock::time_point createdAt) {\n    // Implementation goes here\n}", "test_code": "TEST_CASE(\"getTimestamp\") {\n    SECTION(\"should return '1 second ago' for a date 1 second ago\") {\n        auto oneSecondAgo = std::chrono::system_clock::now() - std::chrono::seconds(1);\n        REQUIRE(getTimestamp(oneSecondAgo) == \"1 second ago\");\n    }\n\n    SECTION(\"should return '5 minutes ago' for a date 5 minutes ago\") {\n        auto fiveMinutesAgo = std::chrono::system_clock::now() - std::chrono::minutes(5);\n        REQUIRE(getTimestamp(fiveMinutesAgo) == \"5 minutes ago\");\n    }\n\n    SECTION(\"should return '2 hours ago' for a date 2 hours ago\") {\n        auto twoHoursAgo = std::chrono::system_clock::now() - std::chrono::hours(2);\n        REQUIRE(getTimestamp(twoHoursAgo) == \"2 hours ago\");\n    }\n\n    SECTION(\"should return '3 days ago' for a date 3 days ago\") {\n        auto threeDaysAgo = std::chrono::system_clock::now() - std::chrono::hours(72); // 3 days\n        REQUIRE(getTimestamp(threeDaysAgo) == \"3 days ago\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way\n *\n * @param createdAt - The date to calculate the time difference from.\n * @returns A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\nstd::string getTimestamp(std::chrono::system_clock::time_point createdAt) {\n    // Implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "\n/**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way.\n *\n * @param createdAt - The date to calculate the time difference from.\n * @return A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\npublic static String getTimestamp(Date createdAt) {\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Date;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testGetTimestampOneSecondAgo() {\n        Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000); // 1 second ago\n        assertEquals(\"1 second ago\",getTimestamp(oneSecondAgo));\n    }\n\n    @Test\n    public void testGetTimestampFiveMinutesAgo() {\n        Date fiveMinutesAgo = new Date(System.currentTimeMillis() - 5 * 60 * 1000); // 5 minutes ago\n        assertEquals(\"5 minutes ago\",getTimestamp(fiveMinutesAgo));\n    }\n\n    @Test\n    public void testGetTimestampTwoHoursAgo() {\n        Date twoHoursAgo = new Date(System.currentTimeMillis() - 2 * 60 * 60 * 1000); // 2 hours ago\n        assertEquals(\"2 hours ago\",getTimestamp(twoHoursAgo));\n    }\n\n    @Test\n    public void testGetTimestampThreeDaysAgo() {\n        Date threeDaysAgo = new Date(System.currentTimeMillis() - 3 * 24 * 60 * 60 * 1000); // 3 days ago\n        assertEquals(\"3 days ago\",getTimestamp(threeDaysAgo));\n    }\n}", "prompt": "please write a java function , the function signature as below \n/**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way.\n *\n * @param createdAt - The date to calculate the time difference from.\n * @return A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\npublic static String getTimestamp(Date createdAt) {\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 156, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\"", "language_version_list": {"python": {"code_signature": "def format_number(num: float) -> str:\n    \"\"\"\n    Format the number into a more readable string representation, returning the original form if the number is less than 1,000.\n    If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\".\n    For a million or more, format it as \"x.xM\".\n\n    Args:\n        num (float): The number to be formatted.\n\n    Returns:\n        str: The formatted number as a string.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFormatNumber(unittest.TestCase):\n    def test_format_greater_than_equal_to_million(self):\n        \"\"\"should format numbers greater than or equal to 1,000,000 with 'M' suffix\"\"\"\n        self.assertEqual(format_number(1500000), '1.5M')\n        self.assertEqual(format_number(1000000), '1.0M')\n\n    def test_format_greater_than_equal_to_thousand(self):\n        \"\"\"should format numbers greater than or equal to 1,000 but less than 1,000,000 with 'K' suffix\"\"\"\n        self.assertEqual(format_number(2500), '2.5K')\n        self.assertEqual(format_number(1000), '1.0K')\n\n    def test_return_string_if_less_than_thousand(self):\n        \"\"\"should return the number as a string if it is less than 1,000\"\"\"\n        self.assertEqual(format_number(999), '999')\n        self.assertEqual(format_number(500), '500')\n\n    def test_handle_edge_cases(self):\n        \"\"\"should handle edge cases like exactly 1,000 or 1,000,000\"\"\"\n        self.assertEqual(format_number(1000), '1.0K')\n        self.assertEqual(format_number(1000000), '1.0M')\n", "prompt": "please write a python function , the function signature as below def format_number(num: float) -> str:\n    \"\"\"\n    Format the number into a more readable string representation, returning the original form if the number is less than 1,000.\n    If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\".\n    For a million or more, format it as \"x.xM\".\n\n    Args:\n        num (float): The number to be formatted.\n\n    Returns:\n        str: The formatted number as a string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\".\n *\n * @param {number} num - The number to be formatted.\n * @returns {string} The formatted number as a string.\n */\nexport const formatNumber = (num) => {\n    \n};", "test_code": "describe('formatNumber', () => {\n    test('should format numbers greater than or equal to 1,000,000 with \"M\" suffix', () => {\n        expect(formatNumber(1500000)).toBe('1.5M');\n        expect(formatNumber(1000000)).toBe('1.0M');\n    });\n\n    test('should format numbers greater than or equal to 1,000 but less than 1,000,000 with \"K\" suffix', () => {\n        expect(formatNumber(2500)).toBe('2.5K');\n        expect(formatNumber(1000)).toBe('1.0K');\n    });\n\n    test('should return the number as a string if it is less than 1,000', () => {\n        expect(formatNumber(999)).toBe('999');\n        expect(formatNumber(500)).toBe('500');\n    });\n\n    test('should handle edge cases like exactly 1,000 or 1,000,000', () => {\n        expect(formatNumber(1000)).toBe('1.0K');\n        expect(formatNumber(1000000)).toBe('1.0M');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\".\n *\n * @param {number} num - The number to be formatted.\n * @returns {string} The formatted number as a string.\n */\nexport const formatNumber = (num) => {\n    \n};", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\".\n *\n * @param {number} num - The number to be formatted.\n * @returns {string} The formatted number as a string.\n */\n// @ts-ignore\nexport const formatNumber = (num: number): string => {\n\n}", "test_code": "describe('formatNumber', () => {\n    test('should format numbers greater than or equal to 1,000,000 with \"M\" suffix', () => {\n        // @ts-ignore\n        expect(formatNumber(1500000)).toBe('1.5M');\n        // @ts-ignore\n        expect(formatNumber(1000000)).toBe('1.0M');\n    });\n\n    test('should format numbers greater than or equal to 1,000 but less than 1,000,000 with \"K\" suffix', () => {\n        // @ts-ignore\n        expect(formatNumber(2500)).toBe('2.5K');\n        // @ts-ignore\n        expect(formatNumber(1000)).toBe('1.0K');\n    });\n\n    test('should return the number as a string if it is less than 1,000', () => {\n        // @ts-ignore\n        expect(formatNumber(999)).toBe('999');\n        // @ts-ignore\n        expect(formatNumber(500)).toBe('500');\n    });\n\n\n    test('should handle edge cases like exactly 1,000 or 1,000,000', () => {\n        // @ts-ignore\n        expect(formatNumber(1000)).toBe('1.0K');\n        // @ts-ignore\n        expect(formatNumber(1000000)).toBe('1.0M');\n    });\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\".\n *\n * @param {number} num - The number to be formatted.\n * @returns {string} The formatted number as a string.\n */\n// @ts-ignore\nexport const formatNumber = (num: number): string => {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\".\n *\n * @param num - The number to be formatted.\n * @returns The formatted number as a string.\n */\nstd::string formatNumber(double num);", "test_code": "TEST_CASE(\"formatNumber\") {\n    SECTION(\"should format numbers greater than or equal to 1,000,000 with 'M' suffix\") {\n        REQUIRE(formatNumber(1500000) == \"1.5M\");\n        REQUIRE(formatNumber(1000000) == \"1.0M\");\n    }\n\n    SECTION(\"should format numbers greater than or equal to 1,000 but less than 1,000,000 with 'K' suffix\") {\n        REQUIRE(formatNumber(2500) == \"2.5K\");\n        REQUIRE(formatNumber(1000) == \"1.0K\");\n    }\n\n    SECTION(\"should return the number as a string if it is less than 1,000\") {\n        REQUIRE(formatNumber(999) == \"999\");\n        REQUIRE(formatNumber(500) == \"500\");\n    }\n\n    SECTION(\"should handle edge cases like exactly 1,000 or 1,000,000\") {\n        REQUIRE(formatNumber(1000) == \"1.0K\");\n        REQUIRE(formatNumber(1000000) == \"1.0M\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\".\n *\n * @param num - The number to be formatted.\n * @returns The formatted number as a string.\n */\nstd::string formatNumber(double num);", "addition_info": ""}, "java": {"code_signature": "/**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000.\n * If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\".\n * For a million or more, format it as \"x.xM\".\n *\n * @param num The number to be formatted.\n * @return The formatted number as a string.\n */\npublic static String formatNumber(double num) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testFormatNumber_Million() {\n        assertEquals(\"1.5M\", formatNumber(1500000));\n        assertEquals(\"1.0M\", formatNumber(1000000));\n    }\n\n    @Test\n    public void testFormatNumber_Thousand() {\n        assertEquals(\"2.5K\", formatNumber(2500));\n        assertEquals(\"1.0K\", formatNumber(1000));\n    }\n\n    @Test\n    public void testFormatNumber_LessThanThousand() {\n        assertEquals(\"999\", formatNumber(999));\n        assertEquals(\"500\", formatNumber(500));\n    }\n\n    @Test\n    public void testFormatNumber_EdgeCases() {\n        assertEquals(\"1.0K\", formatNumber(1000));\n        assertEquals(\"1.0M\", formatNumber(1000000));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000.\n * If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\".\n * For a million or more, format it as \"x.xM\".\n *\n * @param num The number to be formatted.\n * @return The formatted number as a string.\n */\npublic static String formatNumber(double num) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 157, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places", "language_version_list": {"python": {"code_signature": "def bytes_to_size(bytes: int) -> str:\n    \"\"\"\n    Converts a given number of Bytes into a readable string representation\n    with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places.\n\n    Args:\n        bytes (int): The number of bytes to be converted.\n\n    Returns:\n        str: A string representation of the size in Bytes, KB, MB, GB, or TB.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestBytesToSize(unittest.TestCase):\n    def test_convert_bytes_to_kb(self):\n        self.assertEqual(bytes_to_size(1024), '1.00 KB')\n        self.assertEqual(bytes_to_size(2048), '2.00 KB')\n\n    def test_convert_bytes_to_mb(self):\n        self.assertEqual(bytes_to_size(1048576), '1.00 MB')\n        self.assertEqual(bytes_to_size(2097152), '2.00 MB')\n\n    def test_convert_bytes_to_gb(self):\n        self.assertEqual(bytes_to_size(1073741824), '1.00 GB')\n        self.assertEqual(bytes_to_size(2147483648), '2.00 GB')\n\n    def test_convert_bytes_to_tb(self):\n        self.assertEqual(bytes_to_size(1099511627776), '1.00 TB')\n        self.assertEqual(bytes_to_size(2199023255552), '2.00 TB')\n", "prompt": "please write a python function , the function signature as below def bytes_to_size(bytes: int) -> str:\n    \"\"\"\n    Converts a given number of Bytes into a readable string representation\n    with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places.\n\n    Args:\n        bytes (int): The number of bytes to be converted.\n\n    Returns:\n        str: A string representation of the size in Bytes, KB, MB, GB, or TB.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places.\n *\n * @param {number} bytes - The number of bytes to be converted.\n * @returns {string} - A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\nfunction bytesToSize(bytes) {\n    // Function implementation will go here\n}", "test_code": "describe('bytesToSize', () => {\n    test('should convert bytes to KB correctly', () => {\n        expect(bytesToSize(1024)).toBe('1.00 KB');\n        expect(bytesToSize(2048)).toBe('2.00 KB');\n    });\n\n    test('should convert bytes to MB correctly', () => {\n        expect(bytesToSize(1048576)).toBe('1.00 MB');\n        expect(bytesToSize(2097152)).toBe('2.00 MB');\n    });\n\n    test('should convert bytes to GB correctly', () => {\n        expect(bytesToSize(1073741824)).toBe('1.00 GB');\n        expect(bytesToSize(2147483648)).toBe('2.00 GB');\n    });\n\n    test('should convert bytes to TB correctly', () => {\n        expect(bytesToSize(1099511627776)).toBe('1.00 TB');\n        expect(bytesToSize(2199023255552)).toBe('2.00 TB');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places.\n *\n * @param {number} bytes - The number of bytes to be converted.\n * @returns {string} - A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\nfunction bytesToSize(bytes) {\n    // Function implementation will go here\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places *\n *\n * @param {number} bytes - The number of bytes to be converted.\n * @returns {string} - A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\nfunction bytesToSize(bytes: number): string {\n\n}", "test_code": "describe('bytesToSize', () => {\n\n    test('should convert bytes to KB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1024)).toBe('1.00 KB');\n        // @ts-ignore\n        expect(bytesToSize(2048)).toBe('2.00 KB');\n    });\n\n    test('should convert bytes to MB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1048576)).toBe('1.00 MB');\n        // @ts-ignore\n        expect(bytesToSize(2097152)).toBe('2.00 MB');\n    });\n\n    test('should convert bytes to GB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1073741824)).toBe('1.00 GB');\n        // @ts-ignore\n        expect(bytesToSize(2147483648)).toBe('2.00 GB');\n    });\n\n    test('should convert bytes to TB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1099511627776)).toBe('1.00 TB');\n        // @ts-ignore\n        expect(bytesToSize(2199023255552)).toBe('2.00 TB');\n    });\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places *\n *\n * @param {number} bytes - The number of bytes to be converted.\n * @returns {string} - A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\nfunction bytesToSize(bytes: number): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places.\n *\n * @param bytes - The number of bytes to be converted.\n * @returns A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\nstd::string bytesToSize(long long bytes);", "test_code": "TEST_CASE(\"bytesToSize\") {\n    SECTION(\"should convert bytes to KB correctly\") {\n        REQUIRE(bytesToSize(1024) == \"1.00 KB\");\n        REQUIRE(bytesToSize(2048) == \"2.00 KB\");\n    }\n\n    SECTION(\"should convert bytes to MB correctly\") {\n        REQUIRE(bytesToSize(1048576) == \"1.00 MB\");\n        REQUIRE(bytesToSize(2097152) == \"2.00 MB\");\n    }\n\n    SECTION(\"should convert bytes to GB correctly\") {\n        REQUIRE(bytesToSize(1073741824) == \"1.00 GB\");\n        REQUIRE(bytesToSize(2147483648) == \"2.00 GB\");\n    }\n\n    SECTION(\"should convert bytes to TB correctly\") {\n        REQUIRE(bytesToSize(1099511627776) == \"1.00 TB\");\n        REQUIRE(bytesToSize(2199023255552) == \"2.00 TB\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places.\n *\n * @param bytes - The number of bytes to be converted.\n * @returns A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\nstd::string bytesToSize(long long bytes);", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places.\n *\n * @param bytes - The number of bytes to be converted.\n * @return - A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\npublic static String bytesToSize(long bytes) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testBytesToSize_KB() {\n        assertEquals(\"1.00 KB\", bytesToSize(1024));\n        assertEquals(\"2.00 KB\", bytesToSize(2048));\n    }\n\n    @Test\n    public void testBytesToSize_MB() {\n        assertEquals(\"1.00 MB\", bytesToSize(1048576));\n        assertEquals(\"2.00 MB\", bytesToSize(2097152));\n    }\n\n    @Test\n    public void testBytesToSize_GB() {\n        assertEquals(\"1.00 GB\", bytesToSize(1073741824));\n        assertEquals(\"2.00 GB\", bytesToSize(2147483648L));\n    }\n\n    @Test\n    public void testBytesToSize_TB() {\n        assertEquals(\"1.00 TB\", bytesToSize(1099511627776L));\n        assertEquals(\"2.00 TB\", bytesToSize(2199023255552L));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places.\n *\n * @param bytes - The number of bytes to be converted.\n * @return - A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\npublic static String bytesToSize(long bytes) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 158, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Extract the file extension and return it if it exists. If not, an empty string is returned", "language_version_list": {"python": {"code_signature": "def get_file_extension(file_name: str) -> str:\n    \"\"\"\n    Extract the file extension and return it if it exists. If not, an empty string is returned.\n\n    Args:\n        file_name (str): The full name of the file from which to extract the extension.\n\n    Returns:\n        str: The file extension without the dot, or an empty string if no extension is found.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGetFileExtension(unittest.TestCase):\n\n    def test_standard_file_extension(self):\n        \"\"\"should return the file extension for a standard file\"\"\"\n        self.assertEqual(get_file_extension('example.txt'), 'txt')\n\n    def test_no_extension(self):\n        \"\"\"should return an empty string for files without an extension\"\"\"\n        self.assertEqual(get_file_extension('example'), '')\n\n    def test_multiple_dots(self):\n        \"\"\"should handle files with multiple dots\"\"\"\n        self.assertEqual(get_file_extension('example.with.many.dots.jpg'), 'jpg')\n\n    def test_filenames_ending_with_dot(self):\n        \"\"\"should return an empty string for filenames that end with a dot\"\"\"\n        self.assertEqual(get_file_extension('example.'), '')\n\n    def test_case_sensitivity(self):\n        \"\"\"should correctly handle case sensitivity\"\"\"\n        self.assertEqual(get_file_extension('example.JPG'), 'JPG')\n", "prompt": "please write a python function , the function signature as below def get_file_extension(file_name: str) -> str:\n    \"\"\"\n    Extract the file extension and return it if it exists. If not, an empty string is returned.\n\n    Args:\n        file_name (str): The full name of the file from which to extract the extension.\n\n    Returns:\n        str: The file extension without the dot, or an empty string if no extension is found.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extract the file extension and return it if it exists. If not, an empty string is returned\n *\n * @param {string} file_name - The full name of the file from which to extract the extension.\n * @returns {string} The file extension without the dot, or an empty string if no extension is found.\n */\nfunction getFileExtension(file_name) {\n}", "test_code": "describe('getFileExtension', () => {\n    test('should return the file extension for a standard file', () => {\n        expect(getFileExtension('example.txt')).toBe('txt');\n    });\n\n    test('should return an empty string for files without an extension', () => {\n        expect(getFileExtension('example')).toBe('');\n    });\n\n    test('should handle files with multiple dots', () => {\n        expect(getFileExtension('example.with.many.dots.jpg')).toBe('jpg');\n    });\n\n    test('should return an empty string for filenames that end with a dot', () => {\n        expect(getFileExtension('example.')).toBe('');\n    });\n\n    test('should correctly handle case sensitivity', () => {\n        expect(getFileExtension('example.JPG')).toBe('JPG');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Extract the file extension and return it if it exists. If not, an empty string is returned\n *\n * @param {string} file_name - The full name of the file from which to extract the extension.\n * @returns {string} The file extension without the dot, or an empty string if no extension is found.\n */\nfunction getFileExtension(file_name) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Extract the file extension and return it if it exists. If not, an empty string is returned\n *\n * @param {string} file_name - The full name of the file from which to extract the extension.\n * @returns {string} The file extension without the dot, or an empty string if no extension is found.\n */\nfunction getFileExtension(file_name: string): string {\n}", "test_code": "describe('getFileExtension', () => {\n    test('should return the file extension for a standard file', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.txt')).toBe('txt');\n    });\n\n    test('should return an empty string for files without an extension', () => {\n        // @ts-ignore\n        expect(getFileExtension('example')).toBe('');\n    });\n\n    test('should handle files with multiple dots', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.with.many.dots.jpg')).toBe('jpg');\n    });\n\n    test('should return an empty string for filenames that end with a dot', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.')).toBe('');\n    });\n\n    test('should correctly handle case sensitivity', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.JPG')).toBe('JPG');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Extract the file extension and return it if it exists. If not, an empty string is returned\n *\n * @param {string} file_name - The full name of the file from which to extract the extension.\n * @returns {string} The file extension without the dot, or an empty string if no extension is found.\n */\nfunction getFileExtension(file_name: string): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Extract the file extension and return it if it exists. If not, an empty string is returned\n *\n * @param file_name - The full name of the file from which to extract the extension.\n * @returns The file extension without the dot, or an empty string if no extension is found.\n */\nstd::string getFileExtension(const std::string& file_name);", "test_code": "TEST_CASE(\"getFileExtension\", \"[extension]\") {\n    SECTION(\"should return the file extension for a standard file\") {\n        REQUIRE(getFileExtension(\"example.txt\") == \"txt\");\n    }\n\n    SECTION(\"should return an empty string for files without an extension\") {\n        REQUIRE(getFileExtension(\"example\") == \"\");\n    }\n\n    SECTION(\"should handle files with multiple dots\") {\n        REQUIRE(getFileExtension(\"example.with.many.dots.jpg\") == \"jpg\");\n    }\n\n    SECTION(\"should return an empty string for filenames that end with a dot\") {\n        REQUIRE(getFileExtension(\"example.\") == \"\");\n    }\n\n    SECTION(\"should correctly handle case sensitivity\") {\n        REQUIRE(getFileExtension(\"example.JPG\") == \"JPG\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Extract the file extension and return it if it exists. If not, an empty string is returned\n *\n * @param file_name - The full name of the file from which to extract the extension.\n * @returns The file extension without the dot, or an empty string if no extension is found.\n */\nstd::string getFileExtension(const std::string& file_name);", "addition_info": ""}, "java": {"code_signature": "/**\n * Extract the file extension and return it if it exists. If not, an empty string is returned.\n *\n * @param fileName The full name of the file from which to extract the extension.\n * @return The file extension without the dot, or an empty string if no extension is found.\n */\npublic static String getFileExtension(String fileName) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testGetFileExtension_standardFile() {\n        assertEquals(\"txt\", getFileExtension(\"example.txt\"));\n    }\n\n    @Test\n    public void testGetFileExtension_noExtension() {\n        assertEquals(\"\", getFileExtension(\"example\"));\n    }\n\n    @Test\n    public void testGetFileExtension_multipleDots() {\n        assertEquals(\"jpg\", getFileExtension(\"example.with.many.dots.jpg\"));\n    }\n\n    @Test\n    public void testGetFileExtension_trailingDot() {\n        assertEquals(\"\", getFileExtension(\"example.\"));\n    }\n\n    @Test\n    public void testGetFileExtension_caseSensitivity() {\n        assertEquals(\"JPG\", getFileExtension(\"example.JPG\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extract the file extension and return it if it exists. If not, an empty string is returned.\n *\n * @param fileName The full name of the file from which to extract the extension.\n * @return The file extension without the dot, or an empty string if no extension is found.\n */\npublic static String getFileExtension(String fileName) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 159, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Removes the extension of the given filename and returns the remainder", "language_version_list": {"python": {"code_signature": "def remove_file_extension(file_name: str) -> str:\n    \"\"\"\n    Removes the extension of the given filename and returns the remainder.\n\n    Args:\n        file_name (str): The full name of the file from which to remove the extension.\n\n    Returns:\n        str: The file name without the extension. If no extension is found, returns the original file name.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestRemoveFileExtension(unittest.TestCase):\n    def test_remove_standard_file_extension(self):\n        \"\"\"Should remove the file extension from a standard file.\"\"\"\n        self.assertEqual(remove_file_extension('document.txt'), 'document')\n\n    def test_return_original_filename_without_extension(self):\n        \"\"\"Should return the original filename for files without an extension.\"\"\"\n        self.assertEqual(remove_file_extension('document'), 'document')\n\n    def test_handle_files_with_multiple_dots(self):\n        \"\"\"Should handle files with multiple dots correctly.\"\"\"\n        self.assertEqual(remove_file_extension('my.file.with.many.extensions.pdf'), 'my.file.with.many.extensions')\n\n    def test_return_original_filename_if_ends_with_dot(self):\n        \"\"\"Should return the original filename if it ends with a dot.\"\"\"\n        self.assertEqual(remove_file_extension('document.'), 'document')\n\n    def test_handle_filenames_with_dots_in_directory_names(self):\n        \"\"\"Should correctly handle filenames with dots in directory names.\"\"\"\n        self.assertEqual(remove_file_extension('path.to/my.file.txt'), 'path.to/my.file')\n", "prompt": "please write a python function , the function signature as below def remove_file_extension(file_name: str) -> str:\n    \"\"\"\n    Removes the extension of the given filename and returns the remainder.\n\n    Args:\n        file_name (str): The full name of the file from which to remove the extension.\n\n    Returns:\n        str: The file name without the extension. If no extension is found, returns the original file name.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Removes the extension of the given filename and returns the remainder\n *\n * @param {string} file_name - The full name of the file from which to remove the extension.\n * @returns {string} The file name without the extension. If no extension is found, returns the original file name.\n */\nfunction removeFileExtension(file_name) {\n    // Implementation goes here\n}", "test_code": "describe('removeFileExtension', () => {\n    test('should remove the file extension from a standard file', () => {\n        expect(removeFileExtension('document.txt')).toBe('document');\n    });\n\n    test('should return the original filename for files without an extension', () => {\n        expect(removeFileExtension('document')).toBe('document');\n    });\n\n    test('should handle files with multiple dots correctly', () => {\n        expect(removeFileExtension('my.file.with.many.extensions.pdf')).toBe('my.file.with.many.extensions');\n    });\n\n    test('should return the original filename if it ends with a dot', () => {\n        expect(removeFileExtension('document.')).toBe('document');\n    });\n\n    test('should correctly handle filenames with dots in directory names', () => {\n        expect(removeFileExtension('path.to/my.file.txt')).toBe('path.to/my.file');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Removes the extension of the given filename and returns the remainder\n *\n * @param {string} file_name - The full name of the file from which to remove the extension.\n * @returns {string} The file name without the extension. If no extension is found, returns the original file name.\n */\nfunction removeFileExtension(file_name) {\n    // Implementation goes here\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Removes the extension of the given filename and returns the remainder\n *\n * @param {string} file_name - The full name of the file from which to remove the extension.\n * @returns {string} The file name without the extension. If no extension is found, returns the original file name.\n */\nfunction removeFileExtension(file_name: string): string {}", "test_code": "describe('removeFileExtension', () => {\n    test('should remove the file extension from a standard file', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document.txt')).toBe('document');\n    });\n\n    test('should return the original filename for files without an extension', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document')).toBe('document');\n    });\n\n    test('should handle files with multiple dots correctly', () => {\n        // @ts-ignore\n        expect(removeFileExtension('my.file.with.many.extensions.pdf')).toBe('my.file.with.many.extensions');\n    });\n\n    test('should return the original filename if it ends with a dot', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document.')).toBe('document');\n    });\n\n    test('should correctly handle filenames with dots in directory names', () => {\n        // @ts-ignore\n        expect(removeFileExtension('path.to/my.file.txt')).toBe('path.to/my.file');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Removes the extension of the given filename and returns the remainder\n *\n * @param {string} file_name - The full name of the file from which to remove the extension.\n * @returns {string} The file name without the extension. If no extension is found, returns the original file name.\n */\nfunction removeFileExtension(file_name: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Removes the extension of the given filename and returns the remainder\n *\n * @param file_name - The full name of the file from which to remove the extension.\n * @returns The file name without the extension. If no extension is found, returns the original file name.\n */\nstd::string removeFileExtension(const std::string& file_name);", "test_code": "TEST_CASE(\"removeFileExtension\") {\n    SECTION(\"should remove the file extension from a standard file\") {\n        REQUIRE(removeFileExtension(\"document.txt\") == \"document\");\n    }\n\n    SECTION(\"should return the original filename for files without an extension\") {\n        REQUIRE(removeFileExtension(\"document\") == \"document\");\n    }\n\n    SECTION(\"should handle files with multiple dots correctly\") {\n        REQUIRE(removeFileExtension(\"my.file.with.many.extensions.pdf\") == \"my.file.with.many.extensions\");\n    }\n\n    SECTION(\"should return the original filename if it ends with a dot\") {\n        REQUIRE(removeFileExtension(\"document.\") == \"document\");\n    }\n\n    SECTION(\"should correctly handle filenames with dots in directory names\") {\n        REQUIRE(removeFileExtension(\"path.to/my.file.txt\") == \"path.to/my.file\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Removes the extension of the given filename and returns the remainder\n *\n * @param file_name - The full name of the file from which to remove the extension.\n * @returns The file name without the extension. If no extension is found, returns the original file name.\n */\nstd::string removeFileExtension(const std::string& file_name);", "addition_info": ""}, "java": {"code_signature": "/**\n * Removes the extension of the given filename and returns the remainder.\n *\n * @param fileName - The full name of the file from which to remove the extension.\n * @return The file name without the extension. If no extension is found, returns the original file name.\n */\npublic static String removeFileExtension(String fileName) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testRemoveFileExtensionStandardFile() {\n        assertEquals(\"document\", removeFileExtension(\"document.txt\"));\n    }\n\n    @Test\n    public void testRemoveFileExtensionNoExtension() {\n        assertEquals(\"document\", removeFileExtension(\"document\"));\n    }\n\n    @Test\n    public void testRemoveFileExtensionMultipleDots() {\n        assertEquals(\"my.file.with.many.extensions\", removeFileExtension(\"my.file.with.many.extensions.pdf\"));\n    }\n\n    @Test\n    public void testRemoveFileExtensionEndsWithDot() {\n        assertEquals(\"document\", removeFileExtension(\"document.\"));\n    }\n\n    @Test\n    public void testRemoveFileExtensionWithDotsInPath() {\n        assertEquals(\"path.to/my.file\", removeFileExtension(\"path.to/my.file.txt\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Removes the extension of the given filename and returns the remainder.\n *\n * @param fileName - The full name of the file from which to remove the extension.\n * @return The file name without the extension. If no extension is found, returns the original file name.\n */\npublic static String removeFileExtension(String fileName) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 160, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Compress the part of the file name before the file extension, and if the part exceeds the specified maximum length, replace the excess with***\n", "language_version_list": {"python": {"code_signature": "def compress_filename(file_name: str, max_length: int = 18) -> str:\n    \"\"\"\n    Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters.\n\n    For example:\n        compress_filename('verylongfilename.txt', 10) output: verylongfi***.txt\n\n    Args:\n        file_name (str): The original file name to be compressed.\n        max_length (int): The maximum allowed length for the compressed file name. Defaults to 18.\n\n    Returns:\n        str: The compressed file name, with the middle section replaced by ellipses ('...'),\n              or the original file name if it is within the maximum length.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCompressFilename(unittest.TestCase):\n    def test_return_filename_unchanged_if_under_max_length(self):\n        self.assertEqual(compress_filename('file.txt', 10), 'file.txt')\n\n    def test_truncate_and_append_if_exceeds_max_length(self):\n        self.assertEqual(compress_filename('verylongfilename.txt', 10), 'verylongfi***.txt')\n\n    def test_preserve_file_extension_after_compression(self):\n        self.assertEqual(compress_filename('document.pdf', 5), 'docum***.pdf')\n\n    def test_truncate_and_append_if_filename_exceeds(self):\n        self.assertEqual(compress_filename('short.mp3', 2), 'sh***.mp3')", "prompt": "please write a python function , the function signature as below def compress_filename(file_name: str, max_length: int = 18) -> str:\n    \"\"\"\n    Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters.\n\n    For example:\n        compress_filename('verylongfilename.txt', 10) output: verylongfi***.txt\n\n    Args:\n        file_name (str): The original file name to be compressed.\n        max_length (int): The maximum allowed length for the compressed file name. Defaults to 18.\n\n    Returns:\n        str: The compressed file name, with the middle section replaced by ellipses ('...'),\n              or the original file name if it is within the maximum length.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters\n * For example:\n *      compressFilename('verylongfilename.txt', 10) output: verylongfi***.txt\n *\n * @param {string} fileName - The original file name to be compressed.\n * @param {number} maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @returns {string} The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\nfunction compressFileName(fileName, maxLength = 18) {}", "test_code": "describe('compressFilename', () => {\n    test('should return the filename unchanged if under max length', () => {\n        expect(compressFilename('file.txt', 10)).toBe('file.txt');\n    });\n\n    test('should truncate and append *** if filename exceeds max length', () => {\n        expect(compressFilename('verylongfilename.txt', 10)).toBe('verylongfi***.txt');\n    });\n\n    test('should preserve file extension after compression', () => {\n        expect(compressFilename('document.pdf', 5)).toBe('docum***.pdf');\n    });\n\n    test('should truncate and append *** if filename exceeds', () => {\n        expect(compressFilename('short.mp3', 2)).toBe('sh***.mp3');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters\n * For example:\n *      compressFilename('verylongfilename.txt', 10) output: verylongfi***.txt\n *\n * @param {string} fileName - The original file name to be compressed.\n * @param {number} maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @returns {string} The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\nfunction compressFileName(fileName, maxLength = 18) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters\n * For example:\n *      compressFilename('verylongfilename.txt', 10) output: verylongfi***.txt\n *\n * @param {string} fileName - The original file name to be compressed.\n * @param {number} maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @returns {string} The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\nfunction compressFileName(fileName: string, maxLength: number = 18): string {\n}", "test_code": "describe('compressFilename', () => {\n    test('should return the filename unchanged if under max length', () => {\n        expect(compressFilename('file.txt', 10)).toBe('file.txt');\n    });\n\n    test('should truncate and append *** if filename exceeds max length', () => {\n        expect(compressFilename('verylongfilename.txt', 10)).toBe('verylongfi***.txt');\n    });\n\n\n    test('should preserve file extension after compression', () => {\n        expect(compressFilename('document.pdf', 5)).toBe('docum***.pdf');\n    });\n\n\n    test('should truncate and append *** if filename exceeds', () => {\n        expect(compressFilename('short.mp3', 2)).toBe('sh***.mp3');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters\n * For example:\n *      compressFilename('verylongfilename.txt', 10) output: verylongfi***.txt\n *\n * @param {string} fileName - The original file name to be compressed.\n * @param {number} maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @returns {string} The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\nfunction compressFileName(fileName: string, maxLength: number = 18): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters.\n * For example:\n *      compressFileName(\"verylongfilename.txt\", 10) output: verylongfi***.txt\n *\n * @param fileName - The original file name to be compressed.\n * @param maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @returns The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\nstd::string compressFileName(const std::string& fileName, int maxLength = 18){}", "test_code": "TEST_CASE(\"compressFileName\") {\n    SECTION(\"should return the filename unchanged if under max length\") {\n        REQUIRE(compressFileName(\"file.txt\", 10) == \"file.txt\");\n    }\n\n    SECTION(\"should truncate and append *** if filename exceeds max length\") {\n        REQUIRE(compressFileName(\"verylongfilename.txt\", 10) == \"verylongfi***.txt\");\n    }\n\n    SECTION(\"should preserve file extension after compression\") {\n        REQUIRE(compressFileName(\"document.pdf\", 5) == \"docum***.pdf\");\n    }\n\n    SECTION(\"should truncate and append *** if filename exceeds\") {\n        REQUIRE(compressFileName(\"short.mp3\", 2) == \"sh***.mp3\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters.\n * For example:\n *      compressFileName(\"verylongfilename.txt\", 10) output: verylongfi***.txt\n *\n * @param fileName - The original file name to be compressed.\n * @param maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @returns The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\nstd::string compressFileName(const std::string& fileName, int maxLength = 18){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters.\n * For example:\n *      compressFileName(\"verylongfilename.txt\", 10) output: \"verylongfi***.txt\"\n *\n * @param fileName - The original file name to be compressed.\n * @param maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @return The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\npublic static String compressFileName(String fileName, int maxLength) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void shouldReturnFilenameUnchangedIfUnderMaxLength() {\n        assertEquals(\"file.txt\", compressFilename(\"file.txt\", 10));\n    }\n\n    @Test\n    public void shouldTruncateAndAppendIfFilenameExceedsMaxLength() {\n        assertEquals(\"verylongfi***.txt\", compressFilename(\"verylongfilename.txt\", 10));\n    }\n\n    @Test\n    public void shouldPreserveFileExtensionAfterCompression() {\n        assertEquals(\"docum***.pdf\", compressFilename(\"document.pdf\", 5));\n    }\n\n    @Test\n    public void shouldTruncateAndAppendIfFilenameExceeds() {\n        assertEquals(\"sh***.mp3\", compressFilename(\"short.mp3\", 2));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters.\n * For example:\n *      compressFileName(\"verylongfilename.txt\", 10) output: \"verylongfi***.txt\"\n *\n * @param fileName - The original file name to be compressed.\n * @param maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @return The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\npublic static String compressFileName(String fileName, int maxLength) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 161, "code_type": "method", "original_language": "typescript", "question_type": "Algorithm and data structure", "summary": "Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array", "language_version_list": {"python": {"code_signature": "from typing import Dict, List\n\n\ndef generate_combinations(map: Dict[str, List[int]]) -> List[List[int]]:\n    \"\"\"\n    Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array.\n\n    Args:\n        map (Dict[str, List[int]]): A map where each key is a string, and each value is an array of numbers.\n\n    Returns:\n        List[List[int]]: An array of arrays, where each sub-array is a unique combination of numbers from the map's values.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGenerateCombinations(unittest.TestCase):\n\n    def test_single_key_multiple_values(self):\n        # Test: generates combinations for a single key with multiple values\n        map_data = {'a': [1, 2, 3]}\n        expected = [[1], [2], [3]]\n        self.assertEqual(generate_combinations(map_data), expected)\n\n    def test_multiple_keys_single_values(self):\n        # Test: generates combinations for multiple keys with single values\n        map_data = {'a': [1], 'b': [2]}\n        expected = [[1, 2]]\n        self.assertEqual(generate_combinations(map_data), expected)\n\n    def test_multiple_keys_multiple_values(self):\n        # Test: generates combinations for multiple keys with multiple values\n        map_data = {'a': [1, 2], 'b': [3, 4]}\n        expected = [\n            [1, 3], [1, 4],\n            [2, 3], [2, 4]\n        ]\n        self.assertEqual(generate_combinations(map_data), expected)\n\n    def test_empty_map(self):\n        # Test: handles an empty map\n        map_data = {}\n        expected = [[]]\n        self.assertEqual(generate_combinations(map_data), expected)\n\n    def test_empty_array_values(self):\n        # Test: handles keys with empty arrays as values\n        map_data = {'a': [], 'b': [1, 2]}\n        expected = []\n        self.assertEqual(generate_combinations(map_data), expected)\n", "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef generate_combinations(map: Dict[str, List[int]]) -> List[List[int]]:\n    \"\"\"\n    Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array.\n\n    Args:\n        map (Dict[str, List[int]]): A map where each key is a string, and each value is an array of numbers.\n\n    Returns:\n        List[List[int]]: An array of arrays, where each sub-array is a unique combination of numbers from the map's values.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array\n *\n * @param {Map<string, number[]>} map - A map where each key is a string, and each value is an array of numbers.\n * @returns {number[][]} An array of arrays, where each sub-array is a unique combination of numbers from the Map's values.\n */\nfunction generateCombinations(map) {\n    // Function implementation goes here\n}", "test_code": "describe('generateCombinations', () => {\n    test('generates combinations for a single key with multiple values', () => {\n        const map = new Map([['a', [1, 2, 3]]]);\n        const expected = [[1], [2], [3]];\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('generates combinations for multiple keys with single values', () => {\n        const map = new Map([['a', [1]], ['b', [2]]]);\n        const expected = [[1, 2]];\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('generates combinations for multiple keys with multiple values', () => {\n        const map = new Map([['a', [1, 2]], ['b', [3, 4]]]);\n        const expected = [\n            [1, 3], [1, 4],\n            [2, 3], [2, 4]\n        ];\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('handles an empty map', () => {\n        const map = new Map();\n        const expected = [[]];\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('handles keys with empty arrays as values', () => {\n        const map = new Map([['a', []], ['b', [1, 2]]]);\n        const expected = [];\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array\n *\n * @param {Map<string, number[]>} map - A map where each key is a string, and each value is an array of numbers.\n * @returns {number[][]} An array of arrays, where each sub-array is a unique combination of numbers from the Map's values.\n */\nfunction generateCombinations(map) {\n    // Function implementation goes here\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array\n *\n * @param {Map<string, number[]>} map - A map where each key is a string, and each value is an array of numbers.\n * @returns {number[][]} An array of arrays, where each sub-array is a unique combination of numbers from the Map's values.\n */\n// @ts-ignore\nfunction generateCombinations(map: Map<string, number[]>): number[][] {\n\n}", "test_code": "describe('generateCombinations', () => {\n    test('generates combinations for a single key with multiple values', () => {\n        const map = new Map<string, number[]>([['a', [1, 2, 3]]]);\n        const expected = [[1], [2], [3]];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('generates combinations for multiple keys with single values', () => {\n        const map = new Map<string, number[]>([['a', [1]], ['b', [2]]]);\n        const expected = [[1, 2]];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('generates combinations for multiple keys with multiple values', () => {\n        const map = new Map<string, number[]>([['a', [1, 2]], ['b', [3, 4]]]);\n        const expected = [\n            [1, 3], [1, 4],\n            [2, 3], [2, 4]\n        ];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('handles an empty map', () => {\n        const map = new Map<string, number[]>();\n        const expected: number[][] = [[]];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('handles keys with empty arrays as values', () => {\n        const map = new Map<string, number[]>([['a', []], ['b', [1, 2]]]);\n        const expected: number[][] = [];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array\n *\n * @param {Map<string, number[]>} map - A map where each key is a string, and each value is an array of numbers.\n * @returns {number[][]} An array of arrays, where each sub-array is a unique combination of numbers from the Map's values.\n */\n// @ts-ignore\nfunction generateCombinations(map: Map<string, number[]>): number[][] {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array\n *\n * @param inputMap A map where each key is a string, and each value is a vector of integers.\n * @returns A vector of vectors, where each sub-vector is a unique combination of numbers from the map's values.\n */\nstd::vector<std::vector<int>> generateCombinations(const std::map<std::string, std::vector<int>>& inputMap) {\n    // Function implementation here\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <map>\n#include <vector>\n#include <string>\n\n// Function prototype\nstd::vector<std::vector<int>> generateCombinations(const std::map<std::string, std::vector<int>>& inputMap);\n\nTEST_CASE(\"generateCombinations\") {\n    SECTION(\"generates combinations for a single key with multiple values\") {\n        std::map<std::string, std::vector<int>> map = {{\"a\", {1, 2, 3}}};\n        std::vector<std::vector<int>> expected = {{1}, {2}, {3}};\n        REQUIRE(generateCombinations(map) == expected);\n    }\n\n    SECTION(\"generates combinations for multiple keys with single values\") {\n        std::map<std::string, std::vector<int>> map = {{\"a\", {1}}, {\"b\", {2}}};\n        std::vector<std::vector<int>> expected = {{1, 2}};\n        REQUIRE(generateCombinations(map) == expected);\n    }\n\n    SECTION(\"generates combinations for multiple keys with multiple values\") {\n        std::map<std::string, std::vector<int>> map = {{\"a\", {1, 2}}, {\"b\", {3, 4}}};\n        std::vector<std::vector<int>> expected = {\n            {1, 3}, {1, 4},\n            {2, 3}, {2, 4}\n        };\n        REQUIRE(generateCombinations(map) == expected);\n    }\n\n    SECTION(\"handles an empty map\") {\n        std::map<std::string, std::vector<int>> map;\n        std::vector<std::vector<int>> expected = {{}};\n        REQUIRE(generateCombinations(map) == expected);\n    }\n\n    SECTION(\"handles keys with empty arrays as values\") {\n        std::map<std::string, std::vector<int>> map = {{\"a\", {}}, {\"b\", {1, 2}}};\n        std::vector<std::vector<int>> expected = {};\n        REQUIRE(generateCombinations(map) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array\n *\n * @param inputMap A map where each key is a string, and each value is a vector of integers.\n * @returns A vector of vectors, where each sub-vector is a unique combination of numbers from the map's values.\n */\nstd::vector<std::vector<int>> generateCombinations(const std::map<std::string, std::vector<int>>& inputMap) {\n    // Function implementation here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Produces all combinations of numeric arrays for each key in the given map object\n * and returns them as a two-dimensional array.\n *\n * @param map A map where each key is a string, and each value is a list of integers.\n * @return A list of lists, where each sub-list is a unique combination of numbers from the map's values.\n */\npublic List<List<Integer>> generateCombinations(Map<String, List<Integer>> map) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport org.junit.Assert;\n\nimport java.util.*;\n\npublic class Tester {\n\n    @Test\n    public void testGeneratesCombinationsForSingleKeyWithMultipleValues() {\n        Map<String, List<Integer>> map = new HashMap<>();\n        map.put(\"a\", Arrays.asList(1, 2, 3));\n        List<List<Integer>> expected = Arrays.asList(Arrays.asList(1), Arrays.asList(2), Arrays.asList(3));\n        Assert.assertEquals(expected, generateCombinations(map));\n    }\n\n    @Test\n    public void testGeneratesCombinationsForMultipleKeysWithSingleValues() {\n        Map<String, List<Integer>> map = new HashMap<>();\n        map.put(\"a\", Collections.singletonList(1));\n        map.put(\"b\", Collections.singletonList(2));\n        List<List<Integer>> expected = Collections.singletonList(Arrays.asList(1, 2));\n        Assert.assertEquals(expected, generateCombinations(map));\n    }\n\n    @Test\n    public void testGeneratesCombinationsForMultipleKeysWithMultipleValues() {\n        Map<String, List<Integer>> map = new HashMap<>();\n        map.put(\"a\", Arrays.asList(1, 2));\n        map.put(\"b\", Arrays.asList(3, 4));\n        List<List<Integer>> expected = Arrays.asList(\n                Arrays.asList(1, 3), Arrays.asList(1, 4),\n                Arrays.asList(2, 3), Arrays.asList(2, 4)\n        );\n        Assert.assertEquals(expected, generateCombinations(map));\n    }\n\n    @Test\n    public void testHandlesEmptyMap() {\n        Map<String, List<Integer>> map = new HashMap<>();\n        List<List<Integer>> expected = Collections.singletonList(Collections.emptyList());\n        Assert.assertEquals(expected, generateCombinations(map));\n    }\n\n    @Test\n    public void testHandlesKeysWithEmptyArraysAsValues() {\n        Map<String, List<Integer>> map = new HashMap<>();\n        map.put(\"a\", Collections.emptyList());\n        map.put(\"b\", Arrays.asList(1, 2));\n        List<List<Integer>> expected = Collections.emptyList();\n        Assert.assertEquals(expected, generateCombinations(map));\n    }\n\n    // Assuming generateCombinations method is implemented in this class or imported\n    public List<List<Integer>> generateCombinations(Map<String, List<Integer>> map) {\n        // Implementation goes here\n        return new ArrayList<>(); // Placeholder\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Produces all combinations of numeric arrays for each key in the given map object\n * and returns them as a two-dimensional array.\n *\n * @param map A map where each key is a string, and each value is a list of integers.\n * @return A list of lists, where each sub-list is a unique combination of numbers from the map's values.\n */\npublic List<List<Integer>> generateCombinations(Map<String, List<Integer>> map) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 162, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Converts the array of Boolean values to a binary string representation, which converts to the character 1 if the Boolean value is true. Otherwise, it is converted to the character 0, and the final string is returned", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef bool_array_to_binary_string(bool_array: List[bool]) -> str:\n    \"\"\"\n    Converts the array of Boolean values to a binary string representation,\n    which converts to the character '1' if the Boolean value is true.\n    Otherwise, it is converted to the character '0', and the final string is returned.\n\n    Args:\n        bool_array (list[bool]): An array of boolean values.\n\n    Returns:\n        str: A binary string where '1' represents true and '0' represents false.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestBoolArrayToBinaryString(unittest.TestCase):\n\n    def test_converts_all_true_values(self):\n        bool_array = [True, True, True]\n        expected = '111'\n        self.assertEqual(bool_array_to_binary_string(bool_array), expected)\n\n    def test_converts_all_false_values(self):\n        bool_array = [False, False, False]\n        expected = '000'\n        self.assertEqual(bool_array_to_binary_string(bool_array), expected)\n\n    def test_converts_mixed_true_and_false_values(self):\n        bool_array = [True, False, True, False]\n        expected = '1010'\n        self.assertEqual(bool_array_to_binary_string(bool_array), expected)\n\n    def test_handles_empty_array(self):\n        bool_array = []\n        expected = ''\n        self.assertEqual(bool_array_to_binary_string(bool_array), expected)\n\n    def test_handles_single_boolean_value(self):\n        bool_array = [True]\n        expected = '1'\n        self.assertEqual(bool_array_to_binary_string(bool_array), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef bool_array_to_binary_string(bool_array: List[bool]) -> str:\n    \"\"\"\n    Converts the array of Boolean values to a binary string representation,\n    which converts to the character '1' if the Boolean value is true.\n    Otherwise, it is converted to the character '0', and the final string is returned.\n\n    Args:\n        bool_array (list[bool]): An array of boolean values.\n\n    Returns:\n        str: A binary string where '1' represents true and '0' represents false.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts the array of Boolean values to a binary string representation, which converts to the character 1 if the Boolean value is true. Otherwise, it is converted to the character 0, and the final string is returned\n *\n * @param {boolean[]} boolArray - An array of boolean values.\n * @returns {string} A binary string where '1' represents true and '0' represents false.\n */\n// @ts-ignore\nfunction boolArrayToBinaryString(boolArray) {\n\n}", "test_code": "describe('boolArrayToBinaryString', () => {\n    test('converts an array of all true values', () => {\n        const boolArray = [true, true, true];\n        const expected = '111';\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('converts an array of all false values', () => {\n        const boolArray = [false, false, false];\n        const expected = '000';\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('converts an array with a mix of true and false values', () => {\n        const boolArray = [true, false, true, false];\n        const expected = '1010';\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('handles an empty array', () => {\n        const boolArray = [];\n        const expected = '';\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('handles a single boolean value', () => {\n        const boolArray = [true];\n        const expected = '1';\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts the array of Boolean values to a binary string representation, which converts to the character 1 if the Boolean value is true. Otherwise, it is converted to the character 0, and the final string is returned\n *\n * @param {boolean[]} boolArray - An array of boolean values.\n * @returns {string} A binary string where '1' represents true and '0' represents false.\n */\n// @ts-ignore\nfunction boolArrayToBinaryString(boolArray) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts the array of Boolean values to a binary string representation, which converts to the character 1 if the Boolean value is true. Otherwise, it is converted to the character 0, and the final string is returned\n *\n * @param {boolean[]} boolArray - An array of boolean values.\n * @returns {string} A binary string where '1' represents true and '0' represents false.\n */\n// @ts-ignore\nfunction boolArrayToBinaryString(boolArray: boolean[]): string {\n\n}", "test_code": "describe('boolArrayToBinaryString', () => {\n    test('converts an array of all true values', () => {\n        const boolArray = [true, true, true];\n        const expected = '111';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('converts an array of all false values', () => {\n        const boolArray = [false, false, false];\n        const expected = '000';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('converts an array with a mix of true and false values', () => {\n        const boolArray = [true, false, true, false];\n        const expected = '1010';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('handles an empty array', () => {\n        const boolArray: boolean[] = [];\n        const expected = '';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('handles a single boolean value', () => {\n        const boolArray = [true];\n        const expected = '1';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts the array of Boolean values to a binary string representation, which converts to the character 1 if the Boolean value is true. Otherwise, it is converted to the character 0, and the final string is returned\n *\n * @param {boolean[]} boolArray - An array of boolean values.\n * @returns {string} A binary string where '1' represents true and '0' represents false.\n */\n// @ts-ignore\nfunction boolArrayToBinaryString(boolArray: boolean[]): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts the array of Boolean values to a binary string representation,\n * which converts to the character '1' if the Boolean value is true.\n * Otherwise, it is converted to the character '0', and the final string is returned.\n *\n * @param boolArray An array of boolean values.\n * @returns A binary string where '1' represents true and '0' represents false.\n */\nstd::string boolArrayToBinaryString(const std::vector<bool>& boolArray) {\n    // Implementation will go here\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <vector>\n#include <string>\n\nstd::string boolArrayToBinaryString(const std::vector<bool>& boolArray);\n\nTEST_CASE(\"boolArrayToBinaryString\") {\n    SECTION(\"converts an array of all true values\") {\n        std::vector<bool> boolArray = {true, true, true};\n        std::string expected = \"111\";\n        REQUIRE(boolArrayToBinaryString(boolArray) == expected);\n    }\n\n    SECTION(\"converts an array of all false values\") {\n        std::vector<bool> boolArray = {false, false, false};\n        std::string expected = \"000\";\n        REQUIRE(boolArrayToBinaryString(boolArray) == expected);\n    }\n\n    SECTION(\"converts an array with a mix of true and false values\") {\n        std::vector<bool> boolArray = {true, false, true, false};\n        std::string expected = \"1010\";\n        REQUIRE(boolArrayToBinaryString(boolArray) == expected);\n    }\n\n    SECTION(\"handles an empty array\") {\n        std::vector<bool> boolArray = {};\n        std::string expected = \"\";\n        REQUIRE(boolArrayToBinaryString(boolArray) == expected);\n    }\n\n    SECTION(\"handles a single boolean value\") {\n        std::vector<bool> boolArray = {true};\n        std::string expected = \"1\";\n        REQUIRE(boolArrayToBinaryString(boolArray) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts the array of Boolean values to a binary string representation,\n * which converts to the character '1' if the Boolean value is true.\n * Otherwise, it is converted to the character '0', and the final string is returned.\n *\n * @param boolArray An array of boolean values.\n * @returns A binary string where '1' represents true and '0' represents false.\n */\nstd::string boolArrayToBinaryString(const std::vector<bool>& boolArray) {\n    // Implementation will go here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts the array of Boolean values to a binary string representation,\n * which converts to the character '1' if the Boolean value is true.\n * Otherwise, it is converted to the character '0', and the final string is returned.\n *\n * @param boolArray An array of boolean values.\n * @return A binary string where '1' represents true and '0' represents false.\n */\npublic static String boolArrayToBinaryString(boolean[] boolArray) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    /**\n     * Converts the array of Boolean values to a binary string representation,\n     * which converts to the character '1' if the Boolean value is true.\n     * Otherwise, it is converted to the character '0', and the final string is returned.\n     *\n     * @param boolArray An array of boolean values.\n     * @return A binary string where '1' represents true and '0' represents false.\n     */\n    public static String boolArrayToBinaryString(boolean[] boolArray) {\n        StringBuilder binaryString = new StringBuilder();\n        for (boolean value : boolArray) {\n            binaryString.append(value ? \"1\" : \"0\");\n        }\n        return binaryString.toString();\n    }\n\n    @Test\n    public void testConvertsAllTrueValues() {\n        boolean[] boolArray = {true, true, true};\n        String expected = \"111\";\n        assertEquals(expected, boolArrayToBinaryString(boolArray));\n    }\n\n    @Test\n    public void testConvertsAllFalseValues() {\n        boolean[] boolArray = {false, false, false};\n        String expected = \"000\";\n        assertEquals(expected, boolArrayToBinaryString(boolArray));\n    }\n\n    @Test\n    public void testConvertsMixedValues() {\n        boolean[] boolArray = {true, false, true, false};\n        String expected = \"1010\";\n        assertEquals(expected, boolArrayToBinaryString(boolArray));\n    }\n\n    @Test\n    public void testHandlesEmptyArray() {\n        boolean[] boolArray = {};\n        String expected = \"\";\n        assertEquals(expected, boolArrayToBinaryString(boolArray));\n    }\n\n    @Test\n    public void testHandlesSingleBooleanValue() {\n        boolean[] boolArray = {true};\n        String expected = \"1\";\n        assertEquals(expected, boolArrayToBinaryString(boolArray));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts the array of Boolean values to a binary string representation,\n * which converts to the character '1' if the Boolean value is true.\n * Otherwise, it is converted to the character '0', and the final string is returned.\n *\n * @param boolArray An array of boolean values.\n * @return A binary string where '1' represents true and '0' represents false.\n */\npublic static String boolArrayToBinaryString(boolean[] boolArray) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 163, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Stores a second-level string in a set of 8-bit conversion integers in a Unit8Array and returns", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Stores a second-level string in a set of 8-bit conversion integers in a Uint8Array and returns\n *\n * @param {string} binaryStr - The binary string to be converted.\n * @returns {Uint8Array} - The resulting Uint8Array containing the binary question.\n */\n// @ts-ignore\nfunction binaryStringToUint8Array(binaryStr) {\n\n}", "test_code": "describe('binaryStringToUint8Array', () => {\n    test('should convert a full byte binary string', () => {\n        const binaryStr = '11001010';\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([202]));\n    });\n\n    test('should convert multiple full byte binary strings', () => {\n        const binaryStr = '1100101011110000';\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([202, 240]));\n    });\n\n    test('should handle an empty binary string', () => {\n        const binaryStr = '';\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([]));\n    });\n\n    test('should correctly convert binary string with leading zeros', () => {\n        const binaryStr = '00101101';\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([45]));\n    });\n\n    test('should handle binary string with end padding of zeros', () => {\n        const binaryStr = '11001010000'; // should be treated as '11001010 00000000'\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([202, 0]));\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Stores a second-level string in a set of 8-bit conversion integers in a Uint8Array and returns\n *\n * @param {string} binaryStr - The binary string to be converted.\n * @returns {Uint8Array} - The resulting Uint8Array containing the binary question.\n */\n// @ts-ignore\nfunction binaryStringToUint8Array(binaryStr) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Stores a second-level string in a set of 8-bit conversion integers in a Unit8Array and returns\n *\n * @param {string} binaryStr - The binary string to be converted.\n * @returns {Uint8Array} - The resulting Uint8Array containing the binary question.\n */\n// @ts-ignore\nfunction binaryStringToUint8Array(binaryStr: string): Uint8Array {\n\n}", "test_code": "describe('binaryStringToUint8Array', () => {\n    test('should convert a full byte binary string', () => {\n        const binaryStr = '11001010';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([202]));\n    });\n\n    test('should convert multiple full byte binary strings', () => {\n        const binaryStr = '1100101011110000';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([202, 240]));\n    });\n\n\n    test('should handle an empty binary string', () => {\n        const binaryStr = '';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([]));\n    });\n\n    test('should correctly convert binary string with leading zeros', () => {\n        const binaryStr = '00101101';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([45]));\n    });\n    test('should handle binary string with end padding of zeros', () => {\n    const binaryStr = '11001010000'; // should be treated as '11001010 00000000'\n    // @ts-ignore\n    const result = binaryStringToUint8Array(binaryStr);\n    expect(result).toEqual(new Uint8Array([202, 0]));\n});\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Stores a second-level string in a set of 8-bit conversion integers in a Unit8Array and returns\n *\n * @param {string} binaryStr - The binary string to be converted.\n * @returns {Uint8Array} - The resulting Uint8Array containing the binary question.\n */\n// @ts-ignore\nfunction binaryStringToUint8Array(binaryStr: string): Uint8Array {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 164, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "The Unit8 array is converted into 4 Base64 characters as a group of 3 bytes for processing, and the output of less than 3 is filled with =, and the resulting Base64 string is returned", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * The Uint8 array is converted into 4 Base64 characters as a group of 3 bytes for processing, and the output of less than 3 is filled with =, and the resulting Base64 string is returned\n *\n * @param {Uint8Array} uint8Array - The Uint8Array to be converted.\n * @returns {string} - The resulting Base64-encoded string.\n */\nfunction uint8ArrayToBase64(uint8Array) {\n}", "test_code": "describe('uint8ArrayToBase64', () => {\n    test('should convert an empty Uint8Array', () => {\n        const uint8Array = new Uint8Array([]);\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('');\n    });\n\n    test('should convert a Uint8Array with one byte', () => {\n        const uint8Array = new Uint8Array([255]);\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('/w==');\n    });\n\n    test('should convert a Uint8Array with two bytes', () => {\n        const uint8Array = new Uint8Array([255, 255]);\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('//8=');\n    });\n\n    test('should convert a Uint8Array with three bytes', () => {\n        const uint8Array = new Uint8Array([255, 255, 255]);\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('////');\n    });\n\n    test('should convert a Uint8Array with four bytes', () => {\n        const uint8Array = new Uint8Array([72, 101, 108, 108]);\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('SGVsbA==');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * The Uint8 array is converted into 4 Base64 characters as a group of 3 bytes for processing, and the output of less than 3 is filled with =, and the resulting Base64 string is returned\n *\n * @param {Uint8Array} uint8Array - The Uint8Array to be converted.\n * @returns {string} - The resulting Base64-encoded string.\n */\nfunction uint8ArrayToBase64(uint8Array) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * The Unit8 array is converted into 4 Base64 characters as a group of 3 bytes for processing, and the output of less than 3 is filled with =, and the resulting Base64 string is returned\n *\n * @param {Uint8Array} uint8Array - The Uint8Array to be converted.\n * @returns {string} - The resulting Base64-encoded string.\n */\nfunction uint8ArrayToBase64(uint8Array: Uint8Array): string {\n}", "test_code": "describe('uint8ArrayToBase64', () => {\n    test('should convert an empty Uint8Array', () => {\n        const uint8Array = new Uint8Array([]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('');\n    });\n\n    test('should convert a Uint8Array with one byte', () => {\n        const uint8Array = new Uint8Array([255]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('/w==');\n    });\n\n    test('should convert a Uint8Array with two bytes', () => {\n        const uint8Array = new Uint8Array([255, 255]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('//8=');\n    });\n\n    test('should convert a Uint8Array with three bytes', () => {\n        const uint8Array = new Uint8Array([255, 255, 255]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('////');\n    });\n\n    test('should convert a Uint8Array with four bytes', () => {\n        const uint8Array = new Uint8Array([72, 101, 108, 108]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('SGVsbA==');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * The Unit8 array is converted into 4 Base64 characters as a group of 3 bytes for processing, and the output of less than 3 is filled with =, and the resulting Base64 string is returned\n *\n * @param {Uint8Array} uint8Array - The Uint8Array to be converted.\n * @returns {string} - The resulting Base64-encoded string.\n */\nfunction uint8ArrayToBase64(uint8Array: Uint8Array): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 165, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "\nPlease convert a standard Base64 encoded string into a URL-safe Base64 encoded string. The steps include replacing \"+\" with \"-\", replacing \"/\" with \"_\", and removing the trailing \"=\" characters. The resulting string should be suitable for use in URLs.", "language_version_list": {"python": {"code_signature": "def base64_to_url_safe(base64: str) -> str:\n    \"\"\"\n    Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n\n    Args:\n        base64 (str): The standard Base64 encoded string to be converted.\n\n    Returns:\n        str: The URL-safe Base64 encoded string, which replaces '+' with '-' and '/' with '_'\n             and may remove any trailing '=' padding.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestBase64ToUrlSafe(unittest.TestCase):\n\n    def test_correct_conversion_to_url_safe_format(self):\n        base64 = \"YW55IGNhcm5hbCBwbGVhc3VyZS4+/w==\"\n        result = base64_to_url_safe(base64)\n        self.assertEqual(result, \"YW55IGNhcm5hbCBwbGVhc3VyZS4-_w\")\n\n    def test_empty_string_input(self):\n        base64 = \"\"\n        result = base64_to_url_safe(base64)\n        self.assertEqual(result, \"\")\n\n    def test_remove_trailing_equals(self):\n        base64 = \"dGVzdA==\"\n        result = base64_to_url_safe(base64)\n        self.assertEqual(result, \"dGVzdA\")\n\n    def test_no_replacement_needed(self):\n        base64 = \"dGVzdA\"\n        result = base64_to_url_safe(base64)\n        self.assertEqual(result, \"dGVzdA\")\n\n    def test_multiple_plus_and_slash(self):\n        base64 = \"aGVsbG8rL3dvcmxkLw==\"\n        result = base64_to_url_safe(base64)\n        self.assertEqual(result, \"aGVsbG8rL3dvcmxkLw\")", "prompt": "please write a python function , the function signature as below def base64_to_url_safe(base64: str) -> str:\n    \"\"\"\n    Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n\n    Args:\n        base64 (str): The standard Base64 encoded string to be converted.\n\n    Returns:\n        str: The URL-safe Base64 encoded string, which replaces '+' with '-' and '/' with '_'\n             and may remove any trailing '=' padding.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param {string} base64 - The standard Base64 encoded string to be converted.\n * @returns {string} The URL-safe Base64 encoded string.\n */\nexport function base64ToUrlSafe(base64) {\n    // Implementation goes here\n}", "test_code": "describe('base64ToUrlSafe', () => {\n\n    test('should correctly convert a standard Base64 string to URL-safe format', () => {\n        const base64 = \"YW55IGNhcm5hbCBwbGVhc3VyZS4+/w==\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"YW55IGNhcm5hbCBwbGVhc3VyZS4-_w\");\n    });\n\n    test('should return an empty string when the input is an empty string', () => {\n        const base64 = \"\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"\");\n    });\n\n    test('should remove only the trailing \"=\" characters', () => {\n        const base64 = \"dGVzdA==\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"dGVzdA\");\n    });\n\n    test('should handle strings without any characters that need replacement', () => {\n        const base64 = \"dGVzdA\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"dGVzdA\");\n    });\n\n    test('should handle a base64 string with multiple \"+\" and \"/\" characters', () => {\n        const base64 = \"aGVsbG8rL3dvcmxkLw==\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"aGVsbG8rL3dvcmxkLw\");\n    });\n\n    test('should throw an error when input is not a string', () => {\n        expect(() => base64ToUrlSafe(null)).toThrow(TypeError);\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param {string} base64 - The standard Base64 encoded string to be converted.\n * @returns {string} The URL-safe Base64 encoded string.\n */\nexport function base64ToUrlSafe(base64) {\n    // Implementation goes here\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param {string} base64 - The standard Base64 encoded string to be converted.\n * @returns {string} The URL-safe Base64 encoded string.\n */\nexport function base64ToUrlSafe(base64: string): string {\n\n}", "test_code": "describe('base64ToUrlSafe', () => {\n\n    test('should correctly convert a standard Base64 string to URL-safe format', () => {\n        const base64 = \"YW55IGNhcm5hbCBwbGVhc3VyZS4+/w==\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"YW55IGNhcm5hbCBwbGVhc3VyZS4-_w\");\n    });\n\n    test('should return an empty string when the input is an empty string', () => {\n        const base64 = \"\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"\");\n    });\n\n    test('should remove only the trailing \"=\" characters', () => {\n        const base64 = \"dGVzdA==\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"dGVzdA\");\n    });\n\n    test('should handle strings without any characters that need replacement', () => {\n        const base64 = \"dGVzdA\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"dGVzdA\");\n    });\n\n    test('should handle a base64 string with multiple \"+\" and \"/\" characters', () => {\n        const base64 = \"aGVsbG8rL3dvcmxkLw==\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"aGVsbG8rL3dvcmxkLw\");\n    });\n\n    test('should throw an error when input is not a string', () => {\n        expect(() => base64ToUrlSafe((null as unknown) as string)).toThrow(TypeError);\n    });\n\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param {string} base64 - The standard Base64 encoded string to be converted.\n * @returns {string} The URL-safe Base64 encoded string.\n */\nexport function base64ToUrlSafe(base64: string): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param base64 - The standard Base64 encoded string to be converted.\n * @returns The URL-safe Base64 encoded string.\n */\nstd::string base64ToUrlSafe(const std::string& base64) {\n    // Function implementation goes here\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\n// Assuming base64ToUrlSafe is defined somewhere\nstd::string base64ToUrlSafe(const std::string& base64);\n\nTEST_CASE(\"base64ToUrlSafe\") {\n\n    SECTION(\"should correctly convert a standard Base64 string to URL-safe format\") {\n        std::string base64 = \"YW55IGNhcm5hbCBwbGVhc3VyZS4+/w==\";\n        std::string result = base64ToUrlSafe(base64);\n        REQUIRE(result == \"YW55IGNhcm5hbCBwbGVhc3VyZS4-_w\");\n    }\n\n    SECTION(\"should return an empty string when the input is an empty string\") {\n        std::string base64 = \"\";\n        std::string result = base64ToUrlSafe(base64);\n        REQUIRE(result == \"\");\n    }\n\n    SECTION(\"should remove only the trailing '=' characters\") {\n        std::string base64 = \"dGVzdA==\";\n        std::string result = base64ToUrlSafe(base64);\n        REQUIRE(result == \"dGVzdA\");\n    }\n\n    SECTION(\"should handle strings without any characters that need replacement\") {\n        std::string base64 = \"dGVzdA\";\n        std::string result = base64ToUrlSafe(base64);\n        REQUIRE(result == \"dGVzdA\");\n    }\n\n    SECTION(\"should handle a base64 string with multiple '+' and '/' characters\") {\n        std::string base64 = \"aGVsbG8rL3dvcmxkLw==\";\n        std::string result = base64ToUrlSafe(base64);\n        REQUIRE(result == \"aGVsbG8rL3dvcmxkLw\");\n    }\n\n    SECTION(\"should throw an error when input is not a string\") {\n        // Catch2 doesn't directly support throwing for invalid input types,\n        // so this section might be omitted or adjusted for your use case.\n        REQUIRE_THROWS_AS(base64ToUrlSafe(nullptr), std::invalid_argument);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param base64 - The standard Base64 encoded string to be converted.\n * @returns The URL-safe Base64 encoded string.\n */\nstd::string base64ToUrlSafe(const std::string& base64) {\n    // Function implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param base64 The standard Base64 encoded string to be converted.\n * @return The URL-safe Base64 encoded string.\n */\npublic static String base64ToUrlSafe(String base64) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testBase64ToUrlSafe_ConvertsStandardBase64() {\n        String base64 = \"YW55IGNhcm5hbCBwbGVhc3VyZS4+/w==\";\n        String result = base64ToUrlSafe(base64);\n        assertEquals(\"YW55IGNhcm5hbCBwbGVhc3VyZS4-_w\", result);\n    }\n\n    @Test\n    public void testBase64ToUrlSafe_EmptyString() {\n        String base64 = \"\";\n        String result = base64ToUrlSafe(base64);\n        assertEquals(\"\", result);\n    }\n\n    @Test\n    public void testBase64ToUrlSafe_RemovesTrailingEquals() {\n        String base64 = \"dGVzdA==\";\n        String result = base64ToUrlSafe(base64);\n        assertEquals(\"dGVzdA\", result);\n    }\n\n    @Test\n    public void testBase64ToUrlSafe_NoReplacementNeeded() {\n        String base64 = \"dGVzdA\";\n        String result = base64ToUrlSafe(base64);\n        assertEquals(\"dGVzdA\", result);\n    }\n\n    @Test\n    public void testBase64ToUrlSafe_MultipleCharacters() {\n        String base64 = \"aGVsbG8rL3dvcmxkLw==\";\n        String result = base64ToUrlSafe(base64);\n        assertEquals(\"aGVsbG8rL3dvcmxkLw\", result);\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param base64 The standard Base64 encoded string to be converted.\n * @return The URL-safe Base64 encoded string.\n */\npublic static String base64ToUrlSafe(String base64) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 166, "code_type": "method", "original_language": "typescript", "question_type": "Algorithm and data structure", "summary": "Write a function that uses a binary search algorithm to find and return the smallest letter in a sorted array that is larger than a given target letter. If the target letter is greater than or equal to all the letters in the array, return the first letter in the array.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef next_greatest_letter(letters: List[str], target: str) -> str:\n    \"\"\"\n    Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n    If the target letter is greater than or equal to all letters in the array, the function returns\n    the first letter in the array.\n\n    Args:\n        letters (List[str]): A sorted array of letters (assumed to be unique and lowercase).\n        target (str): The target letter to find the next greatest letter for.\n\n    Returns:\n        str: The smallest letter in the array that is larger than the target letter.\n             If the target is greater than or equal to all letters, returns the first letter in the array.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestNextGreatestLetter(unittest.TestCase):\n\n    def test_target_greater_than_all_letters(self):\n        letters = ['c', 'f', 'j']\n        target = 'j'\n        result = next_greatest_letter(letters, target)\n        self.assertEqual(result, 'c')  # Expected output: 'c'\n\n    def test_typical_input(self):\n        letters = ['c', 'f', 'j']\n        target = 'a'\n        result = next_greatest_letter(letters, target)\n        self.assertEqual(result, 'c')  # Expected output: 'c'\n\n    def test_edge_case_between_two_letters(self):\n        letters = ['c', 'f', 'j']\n        target = 'd'\n        result = next_greatest_letter(letters, target)\n        self.assertEqual(result, 'f')  # Expected output: 'f'\n\n    def test_target_equal_to_largest_letter(self):\n        letters = ['a', 'b', 'c', 'd']\n        target = 'd'\n        result = next_greatest_letter(letters, target)\n        self.assertEqual(result, 'a')  # Expected output: 'a'\n\n    def test_single_letter_array(self):\n        letters = ['a']\n        target = 'z'\n        result = next_greatest_letter(letters, target)\n        self.assertEqual(result, 'a')  # Expected output: 'a'", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef next_greatest_letter(letters: List[str], target: str) -> str:\n    \"\"\"\n    Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n    If the target letter is greater than or equal to all letters in the array, the function returns\n    the first letter in the array.\n\n    Args:\n        letters (List[str]): A sorted array of letters (assumed to be unique and lowercase).\n        target (str): The target letter to find the next greatest letter for.\n\n    Returns:\n        str: The smallest letter in the array that is larger than the target letter.\n             If the target is greater than or equal to all letters, returns the first letter in the array.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param {string[]} letters - A sorted array of letters.\n * @param {string} target - The target letter to find the next greatest letter for.\n * @returns {string} The smallest letter in the array that is larger than the target letter.\n */\nexport function nextGreatestLetter(letters, target) {\n    // Implementation goes here\n}", "test_code": "describe('nextGreatestLetter', () => {\n\n    test('should return the first letter when target is greater than all letters in the array', () => {\n        const letters = ['c', 'f', 'j'];\n        const target = 'j';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('c'); // Expected output: 'c'\n    });\n\n    test('should return the next greatest letter for a typical input', () => {\n        const letters = ['c', 'f', 'j'];\n        const target = 'a';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('c'); // Expected output: 'c'\n    });\n\n    test('should handle the edge case where target is in between two letters', () => {\n        const letters = ['c', 'f', 'j'];\n        const target = 'd';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('f'); // Expected output: 'f'\n    });\n\n    test('should return the first letter when the target is equal to the largest letter', () => {\n        const letters = ['a', 'b', 'c', 'd'];\n        const target = 'd';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('a'); // Expected output: 'a'\n    });\n\n    test('should return the correct letter when the array contains only one letter', () => {\n        const letters = ['a'];\n        const target = 'z';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('a'); // Expected output: 'a'\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param {string[]} letters - A sorted array of letters.\n * @param {string} target - The target letter to find the next greatest letter for.\n * @returns {string} The smallest letter in the array that is larger than the target letter.\n */\nexport function nextGreatestLetter(letters, target) {\n    // Implementation goes here\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param {string[]} letters - A sorted array of letters.\n * @param {string} target - The target letter to find the next greatest letter for.\n * @returns {string} The smallest letter in the array that is larger than the target letter.\n */\nexport function nextGreatestLetter(letters: string[], target: string): string {\n\n}", "test_code": "describe('nextGreatestLetter', () => {\n\n    test('should return the first letter when target is greater than all letters in the array', () => {\n        const letters = ['c', 'f', 'j'];\n        const target = 'j';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('c'); // Expected output: 'c'\n    });\n\n    test('should return the next greatest letter for a typical input', () => {\n        const letters = ['c', 'f', 'j'];\n        const target = 'a';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('c'); // Expected output: 'c'\n    });\n\n    test('should handle the edge case where target is in between two letters', () => {\n        const letters = ['c', 'f', 'j'];\n        const target = 'd';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('f'); // Expected output: 'f'\n    });\n\n    test('should return the first letter when the target is equal to the largest letter', () => {\n        const letters = ['a', 'b', 'c', 'd'];\n        const target = 'd';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('a'); // Expected output: 'a'\n    });\n\n    test('should return the correct letter when the array contains only one letter', () => {\n        const letters = ['a'];\n        const target = 'z';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('a'); // Expected output: 'a'\n    });\n\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param {string[]} letters - A sorted array of letters.\n * @param {string} target - The target letter to find the next greatest letter for.\n * @returns {string} The smallest letter in the array that is larger than the target letter.\n */\nexport function nextGreatestLetter(letters: string[], target: string): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param letters A sorted array of letters.\n * @param target The target letter to find the next greatest letter for.\n * @returns The smallest letter in the array that is larger than the target letter.\n */\nstd::string nextGreatestLetter(const std::vector<std::string>& letters, const std::string& target) {\n    // Function implementation...\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <vector>\n#include <string>\n\nstd::string nextGreatestLetter(const std::vector<std::string>& letters, const std::string& target);\n\nTEST_CASE(\"nextGreatestLetter\") {\n    SECTION(\"should return the first letter when target is greater than all letters in the array\") {\n        std::vector<std::string> letters = {\"c\", \"f\", \"j\"};\n        std::string target = \"j\";\n        std::string result = nextGreatestLetter(letters, target);\n        REQUIRE(result == \"c\"); // Expected output: 'c'\n    }\n\n    SECTION(\"should return the next greatest letter for a typical input\") {\n        std::vector<std::string> letters = {\"c\", \"f\", \"j\"};\n        std::string target = \"a\";\n        std::string result = nextGreatestLetter(letters, target);\n        REQUIRE(result == \"c\"); // Expected output: 'c'\n    }\n\n    SECTION(\"should handle the edge case where target is in between two letters\") {\n        std::vector<std::string> letters = {\"c\", \"f\", \"j\"};\n        std::string target = \"d\";\n        std::string result = nextGreatestLetter(letters, target);\n        REQUIRE(result == \"f\"); // Expected output: 'f'\n    }\n\n    SECTION(\"should return the first letter when the target is equal to the largest letter\") {\n        std::vector<std::string> letters = {\"a\", \"b\", \"c\", \"d\"};\n        std::string target = \"d\";\n        std::string result = nextGreatestLetter(letters, target);\n        REQUIRE(result == \"a\"); // Expected output: 'a'\n    }\n\n    SECTION(\"should return the correct letter when the array contains only one letter\") {\n        std::vector<std::string> letters = {\"a\"};\n        std::string target = \"z\";\n        std::string result = nextGreatestLetter(letters, target);\n        REQUIRE(result == \"a\"); // Expected output: 'a'\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param letters A sorted array of letters.\n * @param target The target letter to find the next greatest letter for.\n * @returns The smallest letter in the array that is larger than the target letter.\n */\nstd::string nextGreatestLetter(const std::vector<std::string>& letters, const std::string& target) {\n    // Function implementation...\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param letters - A sorted array of letters.\n * @param target - The target letter to find the next greatest letter for.\n * @returns The smallest letter in the array that is larger than the target letter.\n */\npublic static char nextGreatestLetter(char[] letters, char target) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testFirstLetterWhenTargetGreaterThanAll() {\n        char[] letters = {'c', 'f', 'j'};\n        char target = 'j';\n        char result = nextGreatestLetter(letters, target);\n        assertEquals('c', result); // Expected output: 'c'\n    }\n\n    @Test\n    public void testNextGreatestLetterForTypicalInput() {\n        char[] letters = {'c', 'f', 'j'};\n        char target = 'a';\n        char result = nextGreatestLetter(letters, target);\n        assertEquals('c', result); // Expected output: 'c'\n    }\n\n    @Test\n    public void testEdgeCaseWhereTargetInBetween() {\n        char[] letters = {'c', 'f', 'j'};\n        char target = 'd';\n        char result = nextGreatestLetter(letters, target);\n        assertEquals('f', result); // Expected output: 'f'\n    }\n\n    @Test\n    public void testFirstLetterWhenTargetEqualToLargest() {\n        char[] letters = {'a', 'b', 'c', 'd'};\n        char target = 'd';\n        char result = nextGreatestLetter(letters, target);\n        assertEquals('a', result); // Expected output: 'a'\n    }\n\n    @Test\n    public void testCorrectLetterWithSingleElementArray() {\n        char[] letters = {'a'};\n        char target = 'z';\n        char result = nextGreatestLetter(letters, target);\n        assertEquals('a', result); // Expected output: 'a'\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param letters - A sorted array of letters.\n * @param target - The target letter to find the next greatest letter for.\n * @returns The smallest letter in the array that is larger than the target letter.\n */\npublic static char nextGreatestLetter(char[] letters, char target) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 167, "code_type": "method", "original_language": "typescript", "question_type": "Program input code", "summary": "Write a function that determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer (ranging from 0 to 999) after removing the \".bit\" suffix. The function should involve removing the \".bit\" suffix, converting the remaining part to an integer, and using a regular expression to verify if it is a 3-digit number. The function should return a boolean indicating whether the string meets this criterion.", "language_version_list": {"python": {"code_signature": "def assert_999(bit_name: str) -> bool:\n    \"\"\"\n    Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.\n    Removes the \".bit\" suffix, checks if the remaining part is a number,\n    and verifies if it falls within the range of 0 to 999.\n\n    Args:\n        bit_name (str): The string to validate, which should end with \".bit\".\n\n    Returns:\n        bool: True if the remaining part after removing \".bit\" is a valid 3-digit integer (0-999);\n              otherwise, False.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestAssert999(unittest.TestCase):\n    def test_valid_three_digit_number_with_suffix(self):\n        \"\"\"Test case for a valid 3-digit number with the \".bit\" suffix. Expected to return true.\"\"\"\n        input_value = \"123.bit\"\n        result = assert_999(input_value)\n        self.assertTrue(result)\n\n    def test_valid_two_digit_number_with_suffix(self):\n        \"\"\"Test case for a valid 2-digit number with the \".bit\" suffix. Expected to return true.\"\"\"\n        input_value = \"12.bit\"\n        result = assert_999(input_value)\n        self.assertTrue(result)\n\n    def test_non_numeric_characters_after_suffix(self):\n        \"\"\"Test case for a string containing non-numeric characters after removing \".bit\". Expected to return false.\"\"\"\n        input_value = \"12a.bit\"\n        result = assert_999(input_value)\n        self.assertFalse(result)\n\n    def test_lower_boundary_value(self):\n        \"\"\"Test case for the lower boundary value \"0.bit\". Expected to return true.\"\"\"\n        input_value = \"0.bit\"\n        result = assert_999(input_value)\n        self.assertTrue(result)\n\n    def test_upper_boundary_value(self):\n        \"\"\"Test case for the upper boundary value \"999.bit\". Expected to return true.\"\"\"\n        input_value = \"999.bit\"\n        result = assert_999(input_value)\n        self.assertTrue(result)", "prompt": "please write a python function , the function signature as below def assert_999(bit_name: str) -> bool:\n    \"\"\"\n    Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.\n    Removes the \".bit\" suffix, checks if the remaining part is a number,\n    and verifies if it falls within the range of 0 to 999.\n\n    Args:\n        bit_name (str): The string to validate, which should end with \".bit\".\n\n    Returns:\n        bool: True if the remaining part after removing \".bit\" is a valid 3-digit integer (0-999);\n              otherwise, False.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.\n * Removes the \".bit\" suffix, checks if the remaining part is a number and verifies if it falls within the range of 0 to 999.\n *\n * @param {string} bitName - The string to validate.\n * @returns {boolean} True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\nfunction assert999(bitName) {\n}", "test_code": "describe('assert999', () => {\n    /**\n     * Test case for a valid 3-digit number with the \".bit\" suffix.\n     * Expected to return true.\n     */\n    test('should return true for a valid 3-digit number with \".bit\" suffix', () => {\n        const input = \"123.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n\n    /**\n     * Test case for a valid 2-digit number with the \".bit\" suffix.\n     * Expected to return true.\n     */\n    test('should return true for a valid 2-digit number with \".bit\" suffix', () => {\n        const input = \"12.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n\n    /**\n     * Test case for a string containing non-numeric characters after removing \".bit\".\n     * Expected to return false.\n     */\n    test('should return false for a string with non-numeric characters after removing \".bit\"', () => {\n        const input = \"12a.bit\";\n        const result = assert999(input);\n        expect(result).toBe(false);\n    });\n\n    /**\n     * Test case for the lower boundary value \"0.bit\".\n     * Expected to return true.\n     */\n    test('should return true for the lower boundary value \"0.bit\"', () => {\n        const input = \"0.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n\n    /**\n     * Test case for the upper boundary value \"999.bit\".\n     * Expected to return true.\n     */\n    test('should return true for the upper boundary value \"999.bit\"', () => {\n        const input = \"999.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.\n * Removes the \".bit\" suffix, checks if the remaining part is a number and verifies if it falls within the range of 0 to 999.\n *\n * @param {string} bitName - The string to validate.\n * @returns {boolean} True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\nfunction assert999(bitName) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.removes the \".bit\" suffix, checks if the remaining part is a number and verifies if it falls within the range of 0 to 999.\n *\n * @param {string} bitName - The string to validate.\n * @returns {boolean} True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\nfunction assert999(bitName: string): boolean {\n}", "test_code": "describe('assert999', () => {\n    /**\n     * Test case for a valid 3-digit number with the \".bit\" suffix.\n     * Expected to return true.\n     */\n    test('should return true for a valid 3-digit number with \".bit\" suffix', () => {\n        const input = \"123.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n\n    /**\n     * Test case for a string without the \".bit\" suffix.\n     * Expected to return false.\n     */\n    test('should return true for a valid 2-digit number with \".bit\" suffix', () => {\n        const input = \"12.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n\n    /**\n     * Test case for a string containing non-numeric characters after removing \".bit\".\n     * Expected to return false.\n     */\n    test('should return false for a string with non-numeric characters after removing \".bit\"', () => {\n        const input = \"12a.bit\";\n        const result = assert999(input);\n        expect(result).toBe(false);\n    });\n\n    /**\n     * Test case for the lower boundary value \"0.bit\".\n     * Expected to return true.\n     */\n    test('should return true for the lower boundary value \"0.bit\"', () => {\n        const input = \"0.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n\n    /**\n     * Test case for the upper boundary value \"999.bit\".\n     * Expected to return true.\n     */\n    test('should return true for the upper boundary value \"999.bit\"', () => {\n        const input = \"999.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n});\n\n", "prompt": "please write a typescript function , the function signature as below /**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.removes the \".bit\" suffix, checks if the remaining part is a number and verifies if it falls within the range of 0 to 999.\n *\n * @param {string} bitName - The string to validate.\n * @returns {boolean} True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\nfunction assert999(bitName: string): boolean {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.\n * Removes the \".bit\" suffix, checks if the remaining part is a number and verifies if it falls within the range of 0 to 999.\n *\n * @param bitName - The string to validate.\n * @returns True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\nbool assert999(const std::string& bitName) {\n    // Implementation goes here\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\n// Assuming assert999 function is defined elsewhere\n\nTEST_CASE(\"assert999\") {\n    /**\n     * Test case for a valid 3-digit number with the \".bit\" suffix.\n     * Expected to return true.\n     */\n    SECTION(\"should return true for a valid 3-digit number with '.bit' suffix\") {\n        std::string input = \"123.bit\";\n        bool result = assert999(input);\n        REQUIRE(result == true);\n    }\n\n    /**\n     * Test case for a valid 2-digit number with the \".bit\" suffix.\n     * Expected to return true.\n     */\n    SECTION(\"should return true for a valid 2-digit number with '.bit' suffix\") {\n        std::string input = \"12.bit\";\n        bool result = assert999(input);\n        REQUIRE(result == true);\n    }\n\n    /**\n     * Test case for a string containing non-numeric characters after removing \".bit\".\n     * Expected to return false.\n     */\n    SECTION(\"should return false for a string with non-numeric characters after removing '.bit'\") {\n        std::string input = \"12a.bit\";\n        bool result = assert999(input);\n        REQUIRE(result == false);\n    }\n\n    /**\n     * Test case for the lower boundary value \"0.bit\".\n     * Expected to return true.\n     */\n    SECTION(\"should return true for the lower boundary value '0.bit'\") {\n        std::string input = \"0.bit\";\n        bool result = assert999(input);\n        REQUIRE(result == true);\n    }\n\n    /**\n     * Test case for the upper boundary value \"999.bit\".\n     * Expected to return true.\n     */\n    SECTION(\"should return true for the upper boundary value '999.bit'\") {\n        std::string input = \"999.bit\";\n        bool result = assert999(input);\n        REQUIRE(result == true);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.\n * Removes the \".bit\" suffix, checks if the remaining part is a number and verifies if it falls within the range of 0 to 999.\n *\n * @param bitName - The string to validate.\n * @returns True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\nbool assert999(const std::string& bitName) {\n    // Implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.\n * Removes the \".bit\" suffix, checks if the remaining part is a number and verifies if it falls within the range of 0 to 999.\n *\n * @param bitName The string to validate.\n * @return True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\npublic static boolean assert999(String bitName) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    /**\n     * Test case for a valid 3-digit number with the \".bit\" suffix.\n     * Expected to return true.\n     */\n    @Test\n    public void testValidThreeDigitNumber() {\n        String input = \"123.bit\";\n        boolean result = assert999(input);\n        assertTrue(result);\n    }\n\n    /**\n     * Test case for a valid 2-digit number with the \".bit\" suffix.\n     * Expected to return true.\n     */\n    @Test\n    public void testValidTwoDigitNumber() {\n        String input = \"12.bit\";\n        boolean result = assert999(input);\n        assertTrue(result);\n    }\n\n    /**\n     * Test case for a string containing non-numeric characters after removing \".bit\".\n     * Expected to return false.\n     */\n    @Test\n    public void testNonNumericCharacters() {\n        String input = \"12a.bit\";\n        boolean result = assert999(input);\n        assertFalse(result);\n    }\n\n    /**\n     * Test case for the lower boundary value \"0.bit\".\n     * Expected to return true.\n     */\n    @Test\n    public void testLowerBoundaryValue() {\n        String input = \"0.bit\";\n        boolean result = assert999(input);\n        assertTrue(result);\n    }\n\n    /**\n     * Test case for the upper boundary value \"999.bit\".\n     * Expected to return true.\n     */\n    @Test\n    public void testUpperBoundaryValue() {\n        String input = \"999.bit\";\n        boolean result = assert999(input);\n        assertTrue(result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.\n * Removes the \".bit\" suffix, checks if the remaining part is a number and verifies if it falls within the range of 0 to 999.\n *\n * @param bitName The string to validate.\n * @return True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\npublic static boolean assert999(String bitName) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 168, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Please convert a date string into a relative time description. Based on the time difference between the current time and the input date, generate a string that represents the relative time, such as \"X days ago,\" \"X hours ago,\" \"X minutes ago,\" or \"X seconds ago.\" Ensure the output displays the time difference in a user-friendly manner.", "language_version_list": {"python": {"code_signature": "def format_date(date_string: str) -> str:\n    \"\"\"\n    Converts a date string into a relative time description.\n    For example, now time 2024-08-25T12:00:00\n         input: 2024-08-24T12:00:00 output: 1 day ago\n         input: 2024-08-25T07:00:00 output: 5 hours ago\n\n    Args:\n        date_string (str): The date string to convert.\n\n    Returns:\n        str: A user-friendly string representing the relative time difference from the current date.\n    \"\"\"", "test_code": "import unittest\nfrom datetime import datetime\nfrom unittest.mock import patch\n\n\nclass TestFormatDate(unittest.TestCase):\n\n    def setUp(self, mock_datetime):\n        # Set the system time to a fixed date for consistent testing\n        mock_datetime.now.return_value = datetime(2024, 8, 25, 12, 0, 0)\n\n    def test_one_day_ago(self):\n        date_string = '2024-08-24T12:00:00' \n        result = format_date(date_string)\n        self.assertIn(result, ['1 day ago', '24 hours ago'])\n\n    def test_five_hours_ago(self):\n        date_string = '2024-08-25T07:00:00'\n        result = format_date(date_string)\n        self.assertEqual(result, '5 hours ago')\n\n    def test_two_minutes_ago(self):\n        date_string = '2024-08-25T11:58:00'\n        result = format_date(date_string)\n        self.assertEqual(result, '2 minutes ago')\n\n    def test_just_now(self):\n        date_string = '2024-08-25T11:59:59'\n        result = format_date(date_string)\n        self.assertIn(result, ['1 second ago', '1 seconds ago'])\n", "prompt": "please write a python function , the function signature as below def format_date(date_string: str) -> str:\n    \"\"\"\n    Converts a date string into a relative time description.\n    For example, now time 2024-08-25T12:00:00\n         input: 2024-08-24T12:00:00 output: 1 day ago\n         input: 2024-08-25T07:00:00 output: 5 hours ago\n\n    Args:\n        date_string (str): The date string to convert.\n\n    Returns:\n        str: A user-friendly string representing the relative time difference from the current date.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a date string into a relative time description.\n * For example, now time 2024-08-25T12:00:00\n *      input: 2024-08-24T12:00:00 output 1 day ago\n *      input: 2024-08-25T07:00:00 output: 5 hours ago\n *\n * @param {string} dateString - The date string to convert.\n * @returns {string} A user-friendly string representing the relative time difference from the current date.\n */\nfunction formatDate(dateString) {\n    // Function implementation goes here\n}", "test_code": "describe('formatDate', () => {\n    beforeAll(() => {\n        // Set the system time to a fixed date for consistent testing\n        jest.useFakeTimers().setSystemTime(new Date('2024-08-25T12:00:00'));\n    });\n\n    afterAll(() => {\n        // Restore the real system time after tests\n        jest.useRealTimers();\n    });\n\n    test('should return \"1 day ago\" for a date exactly one day before', () => {\n        const dateString = '2024-08-24T12:00:00';\n        const result = formatDate(dateString);\n        expect(['1 day ago', '24 hours ago']).toContain(result);\n    });\n\n    test('should return \"5 hours ago\" for a date 5 hours before the current time', () => {\n        const dateString = '2024-08-25T07:00:00';\n        const result = formatDate(dateString);\n        expect(result).toBe('5 hours ago');\n    });\n\n    test('should return \"2 minutes ago\" for a date 2 minutes before the current time', () => {\n        const dateString = '2024-08-25T11:58:00';\n        const result = formatDate(dateString);\n        expect(result).toBe('2 minutes ago');\n    });\n\n    test('should return \"just now\" for a date within the last second', () => {\n        const dateString = '2024-08-25T11:59:59';\n        const result = formatDate(dateString);\n        expect(['1 second ago', '1 seconds ago']).toContain(result);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a date string into a relative time description.\n * For example, now time 2024-08-25T12:00:00\n *      input: 2024-08-24T12:00:00 output 1 day ago\n *      input: 2024-08-25T07:00:00 output: 5 hours ago\n *\n * @param {string} dateString - The date string to convert.\n * @returns {string} A user-friendly string representing the relative time difference from the current date.\n */\nfunction formatDate(dateString) {\n    // Function implementation goes here\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a date string into a relative time description.\n * For example,now time 2024-08-25T12:00:00\n *      input: 2024-08-24T12:00:00 output 1 day ago\n *      input: 2024-08-25T07:00:00 output: 5 hours ago\n *\n * @param {string} dateString - The date string to convert.\n * @returns {string} A user-friendly string representing the relative time difference from the current date.\n */\nfunction formatDate(dateString: string): string {\n\n}", "test_code": "describe('formatDate', () => {\n    beforeAll(() => {\n        // Set the system time to a fixed date for consistent testing\n        jest.useFakeTimers().setSystemTime(new Date('2024-08-25T12:00:00'));\n    });\n\n    afterAll(() => {\n        // Restore the real system time after tests\n        jest.useRealTimers();\n    });\n\n    test('should return \"1 day ago\" for a date exactly one day before', () => {\n        const dateString = '2024-08-24T12:00:00';\n        const result = formatDate(dateString);\n        expect(['1 day ago', '24 hours ago']).toContain(result)\n    });\n\n    test('should return \"5 hours ago\" for a date 5 hours before the current time', () => {\n        const dateString = '2024-08-25T07:00:00';\n        const result = formatDate(dateString);\n        expect(result).toBe('5 hours ago');\n    });\n\n    test('should return \"2 minutes ago\" for a date 2 minutes before the current time', () => {\n        const dateString = '2024-08-25T11:58:00';\n        const result = formatDate(dateString);\n        expect(result).toBe('2 minutes ago');\n    });\n\n    test('should return \"just now\" for a date within the last second', () => {\n        const dateString = '2024-08-25T11:59:59';\n        const result = formatDate(dateString);\n        expect(['1 second ago', '1 seconds ago']).toContain(result)\n    });\n\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a date string into a relative time description.\n * For example,now time 2024-08-25T12:00:00\n *      input: 2024-08-24T12:00:00 output 1 day ago\n *      input: 2024-08-25T07:00:00 output: 5 hours ago\n *\n * @param {string} dateString - The date string to convert.\n * @returns {string} A user-friendly string representing the relative time difference from the current date.\n */\nfunction formatDate(dateString: string): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts a date string into a relative time description.\n * For example, now time 2024-08-25T12:00:00\n *      input: 2024-08-24T12:00:00 output: 1 day ago\n *      input: 2024-08-25T07:00:00 output: 5 hours ago\n *\n * @param dateString The date string to convert.\n * @returns A user-friendly string representing the relative time difference from the current date.\n */\nstd::string formatDate(const std::string& dateString){\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <chrono>\n#include <iomanip>\n#include <sstream>\n#include \"your_header_file.h\" // Include the header file with formatDate\n\nTEST_CASE(\"formatDate\") {\n    // Set the system time to a fixed date for consistent testing\n    std::tm fixedTime = {};\n    std::istringstream ss(\"2024-08-25 12:00:00\");\n    ss >> std::get_time(&fixedTime, \"%Y-%m-%d %H:%M:%S\");\n    time_t currentTime = mktime(&fixedTime);\n    std::time(nullptr) = currentTime; // Note: Adjust as needed for your test environment\n\n    SECTION(\"should return '1 day ago' for a date exactly one day before\") {\n        std::string dateString = \"2024-08-24T12:00:00\";\n        std::string result = formatDate(dateString);\n        REQUIRE((result == \"1 day ago\" || result == \"24 hours ago\"));\n    }\n\n    SECTION(\"should return '5 hours ago' for a date 5 hours before the current time\") {\n        std::string dateString = \"2024-08-25T07:00:00\";\n        std::string result = formatDate(dateString);\n        REQUIRE(result == \"5 hours ago\");\n    }\n\n    SECTION(\"should return '2 minutes ago' for a date 2 minutes before the current time\") {\n        std::string dateString = \"2024-08-25T11:58:00\";\n        std::string result = formatDate(dateString);\n        REQUIRE(result == \"2 minutes ago\");\n    }\n\n    SECTION(\"should return 'just now' for a date within the last second\") {\n        std::string dateString = \"2024-08-25T11:59:59\";\n        std::string result = formatDate(dateString);\n        REQUIRE((result == \"1 second ago\" || result == \"1 seconds ago\"));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts a date string into a relative time description.\n * For example, now time 2024-08-25T12:00:00\n *      input: 2024-08-24T12:00:00 output: 1 day ago\n *      input: 2024-08-25T07:00:00 output: 5 hours ago\n *\n * @param dateString The date string to convert.\n * @returns A user-friendly string representing the relative time difference from the current date.\n */\nstd::string formatDate(const std::string& dateString){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a date string into a relative time description.\n * For example, now time 2024-08-25T12:00:00\n *      input: 2024-08-24T12:00:00 output: 1 day ago\n *      input: 2024-08-25T07:00:00 output: 5 hours ago\n *\n * @param dateString The date string to convert.\n * @return A user-friendly string representing the relative time difference from the current date.\n * @throws IllegalArgumentException If the date string is invalid.\n */\npublic static String formatDate(String dateString) throws IllegalArgumentException {}", "test_code": "package org.real.temp;\n\nimport org.junit.BeforeClass;\nimport org.junit.AfterClass;\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @BeforeClass\n    public static void setUp() {\n        // Set the system time to a fixed date for consistent testing\n        // Note: Java does not allow changing system time directly;\n        // consider using a library for time manipulation in tests.\n        // This is a placeholder to indicate intent.\n    }\n\n    @AfterClass\n    public static void tearDown() {\n        // Restore the real system time after tests\n        // Placeholder for restoring time\n    }\n\n    @Test\n    public void testOneDayAgo() {\n        String dateString = \"2024-08-24T12:00:00\";\n        String result = DateFormatter.formatDate(dateString);\n        assertTrue(result.equals(\"1 day ago\") || result.equals(\"24 hours ago\"));\n    }\n\n    @Test\n    public void testFiveHoursAgo() {\n        String dateString = \"2024-08-25T07:00:00\";\n        String result = DateFormatter.formatDate(dateString);\n        assertEquals(\"5 hours ago\", result);\n    }\n\n    @Test\n    public void testTwoMinutesAgo() {\n        String dateString = \"2024-08-25T11:58:00\";\n        String result = DateFormatter.formatDate(dateString);\n        assertEquals(\"2 minutes ago\", result);\n    }\n\n    @Test\n    public void testJustNow() {\n        String dateString = \"2024-08-25T11:59:59\";\n        String result = DateFormatter.formatDate(dateString);\n        assertTrue(result.equals(\"1 second ago\") || result.equals(\"1 seconds ago\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a date string into a relative time description.\n * For example, now time 2024-08-25T12:00:00\n *      input: 2024-08-24T12:00:00 output: 1 day ago\n *      input: 2024-08-25T07:00:00 output: 5 hours ago\n *\n * @param dateString The date string to convert.\n * @return A user-friendly string representing the relative time difference from the current date.\n * @throws IllegalArgumentException If the date string is invalid.\n */\npublic static String formatDate(String dateString) throws IllegalArgumentException {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 169, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Convert an Arabic numeral to a Roman numeral", "language_version_list": {"python": {"code_signature": "def convert_to_roman(num: int) -> str:\n    \"\"\"\n    Converts an Arabic numeral to its Roman numeral equivalent.\n\n    Args:\n        num (int): The number to convert.\n\n    Returns:\n        str: The Roman numeral representation of the input number.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestConvertToRoman(unittest.TestCase):\n    def test_typical_number(self):\n        result = convert_to_roman(1987)\n        self.assertEqual(result, 'MCMLXXXVII')  # 1987 = M + CM + LXXX + VII\n\n    def test_minimum_value(self):\n        result = convert_to_roman(1)\n        self.assertEqual(result, 'I')  # 1 = I\n\n    def test_large_number(self):\n        result = convert_to_roman(3999)\n        self.assertEqual(result, 'MMMCMXCIX')  # 3999 = MMM + CM + XC + IX\n\n    def test_different_numeral_repeats(self):\n        result = convert_to_roman(1666)\n        self.assertEqual(result, 'MDCLXVI')  # 1666 = M + D + CLX + VI\n\n    def test_no_fives_and_ones(self):\n        result = convert_to_roman(2000)\n        self.assertEqual(result, 'MM')  # 2000 = MM\n", "prompt": "please write a python function , the function signature as below def convert_to_roman(num: int) -> str:\n    \"\"\"\n    Converts an Arabic numeral to its Roman numeral equivalent.\n\n    Args:\n        num (int): The number to convert.\n\n    Returns:\n        str: The Roman numeral representation of the input number.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param {number} num - The number to convert.\n * @returns {string} The Roman numeral representation of the input number.\n */\nfunction convertToRoman(num) {\n    // Function implementation goes here\n}", "test_code": "describe('convertToRoman', () => {\n    test('should return the correct Roman numeral for a typical number', () => {\n        const result = convertToRoman(1987);\n        expect(result).toBe('MCMLXXXVII'); // 1987 = M + CM + LXXX + VII\n    });\n\n    test('should return the correct Roman numeral for the minimum value (1)', () => {\n        const result = convertToRoman(1);\n        expect(result).toBe('I'); // 1 = I\n    });\n\n    test('should return the correct Roman numeral for a large number (3999)', () => {\n        const result = convertToRoman(3999);\n        expect(result).toBe('MMMCMXCIX'); // 3999 = MMM + CM + XC + IX\n    });\n\n    test('should return the correct Roman numeral for a number with different numeral repeats', () => {\n        const result = convertToRoman(1666);\n        expect(result).toBe('MDCLXVI'); // 1666 = M + D + CLX + VI\n    });\n\n    test('should return the correct Roman numeral for number with no 5s and 1s', () => {\n        const result = convertToRoman(2000);\n        expect(result).toBe('MM'); // 2000 = MM\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param {number} num - The number to convert.\n * @returns {string} The Roman numeral representation of the input number.\n */\nfunction convertToRoman(num) {\n    // Function implementation goes here\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param {number} num - The number to convert.\n * @returns {string} The Roman numeral representation of the input number.\n */\nfunction convertToRoman(num: number): string {}", "test_code": "describe('convertToRoman', () => {\n\n    test('should return the correct Roman numeral for a typical number', () => {\n        const result = convertToRoman(1987);\n        expect(result).toBe('MCMLXXXVII'); // 1987 = M + CM + LXXX + VII\n    });\n\n    test('should return the correct Roman numeral for the minimum value (1)', () => {\n        const result = convertToRoman(1);\n        expect(result).toBe('I'); // 1 = I\n    });\n\n    test('should return the correct Roman numeral for a large number (3999)', () => {\n        const result = convertToRoman(3999);\n        expect(result).toBe('MMMCMXCIX'); // 3999 = MMM + CM + XC + IX\n    });\n\n    test('should return the correct Roman numeral for a number with different numeral repeats', () => {\n        const result = convertToRoman(1666);\n        expect(result).toBe('MDCLXVI'); // 1666 = M + D + CLX + VI\n    });\n\n    test('should return the correct Roman numeral for number with no 5s and 1s', () => {\n        const result = convertToRoman(2000);\n        expect(result).toBe('MM'); // 2000 = MM\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param {number} num - The number to convert.\n * @returns {string} The Roman numeral representation of the input number.\n */\nfunction convertToRoman(num: number): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param num The number to convert.\n * @returns The Roman numeral representation of the input number.\n */\nstd::string convertToRoman(int num){\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include \"your_header_file.h\" // Include the header where convertToRoman is declared\n\nTEST_CASE(\"convertToRoman\", \"[roman]\") {\n    SECTION(\"should return the correct Roman numeral for a typical number\") {\n        std::string result = convertToRoman(1987);\n        REQUIRE(result == \"MCMLXXXVII\"); // 1987 = M + CM + LXXX + VII\n    }\n\n    SECTION(\"should return the correct Roman numeral for the minimum value (1)\") {\n        std::string result = convertToRoman(1);\n        REQUIRE(result == \"I\"); // 1 = I\n    }\n\n    SECTION(\"should return the correct Roman numeral for a large number (3999)\") {\n        std::string result = convertToRoman(3999);\n        REQUIRE(result == \"MMMCMXCIX\"); // 3999 = MMM + CM + XC + IX\n    }\n\n    SECTION(\"should return the correct Roman numeral for a number with different numeral repeats\") {\n        std::string result = convertToRoman(1666);\n        REQUIRE(result == \"MDCLXVI\"); // 1666 = M + D + CLX + VI\n    }\n\n    SECTION(\"should return the correct Roman numeral for number with no 5s and 1s\") {\n        std::string result = convertToRoman(2000);\n        REQUIRE(result == \"MM\"); // 2000 = MM\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param num The number to convert.\n * @returns The Roman numeral representation of the input number.\n */\nstd::string convertToRoman(int num){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param num The number to convert.\n * @return The Roman numeral representation of the input number.\n */\npublic String convertToRoman(int num) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testConvertToRomanTypicalNumber() {\n        String result = convertToRoman(1987);\n        assertEquals(\"MCMLXXXVII\", result); // 1987 = M + CM + LXXX + VII\n    }\n\n    @Test\n    public void testConvertToRomanMinimumValue() {\n        String result = convertToRoman(1);\n        assertEquals(\"I\", result); // 1 = I\n    }\n\n    @Test\n    public void testConvertToRomanLargeNumber() {\n        String result = convertToRoman(3999);\n        assertEquals(\"MMMCMXCIX\", result); // 3999 = MMM + CM + XC + IX\n    }\n\n    @Test\n    public void testConvertToRomanNumeralRepeats() {\n        String result = convertToRoman(1666);\n        assertEquals(\"MDCLXVI\", result); // 1666 = M + D + CLX + VI\n    }\n\n    @Test\n    public void testConvertToRomanNoFivesAndOnes() {\n        String result = convertToRoman(2000);\n        assertEquals(\"MM\", result); // 2000 = MM\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param num The number to convert.\n * @return The Roman numeral representation of the input number.\n */\npublic String convertToRoman(int num) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 331, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Calculates  the final price after applying a discount to the original price.Both price and discount are expected as strings and should represent valid numbers.The discount should be a percentage value between 0 and 100.\n", "language_version_list": {"python": {"code_signature": "def calculate_final_price(price: str, discount: str) -> float:\n    \"\"\"\n    Calculates the final price after applying a discount to the original price.\n    Both price and discount are expected as strings and should represent valid numbers.\n    The discount should be a percentage value between 0 and 100.\n\n    Args:\n        price (str): The original price as a string.\n        discount (str): The discount percentage as a string.\n\n    Returns:\n        float: The final price after applying the discount, rounded to two decimal places.\n\n    Raises:\n        ValueError: Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCalculateFinalPrice(unittest.TestCase):\n\n    def test_calculate_final_price_with_valid_inputs(self):\n        \"\"\"\n        should calculate the final price correctly with valid inputs\n        \"\"\"\n        result = calculate_final_price('200', '10')\n        self.assertEqual(result, 180.0)\n\n    def test_discount_is_zero(self):\n        \"\"\"\n        should return the original price when the discount is 0%\n        \"\"\"\n        result = calculate_final_price('150', '0')\n        self.assertEqual(result, 150.0)\n\n    def test_discount_is_hundred(self):\n        \"\"\"\n        should return zero when the discount is 100%\n        \"\"\"\n        result = calculate_final_price('100', '100')\n        self.assertEqual(result, 0.0)\n", "prompt": "please write a python function , the function signature as below def calculate_final_price(price: str, discount: str) -> float:\n    \"\"\"\n    Calculates the final price after applying a discount to the original price.\n    Both price and discount are expected as strings and should represent valid numbers.\n    The discount should be a percentage value between 0 and 100.\n\n    Args:\n        price (str): The original price as a string.\n        discount (str): The discount percentage as a string.\n\n    Returns:\n        float: The final price after applying the discount, rounded to two decimal places.\n\n    Raises:\n        ValueError: Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\nfunction calculateFinalPrice(price, discount) {\n    // Function implementation goes here\n}", "test_code": "describe('calculateFinalPrice', () => {\n    test('should calculate the final price correctly with valid inputs', () => {\n        const result = calculateFinalPrice('200', '10');\n        expect(result).toBe(180);\n    });\n\n    test('should return the original price when the discount is 0%', () => {\n        const result = calculateFinalPrice('150', '0');\n        expect(result).toBe(150);\n    });\n\n    test('should return zero when the discount is 100%', () => {\n        const result = calculateFinalPrice('100', '100');\n        expect(result).toBe(0);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\nfunction calculateFinalPrice(price, discount) {\n    // Function implementation goes here\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\nfunction calculateFinalPrice(price: string, discount: string): number {\n\n}", "test_code": "describe('calculateFinalPrice', () => {\n    test('should calculate the final price correctly with valid inputs', () => {\n        const result = calculateFinalPrice('200', '10');\n        expect(result).toBe(180);\n    });\n\n    test('should return the original price when the discount is 0%', () => {\n        const result = calculateFinalPrice('150', '0');\n        expect(result).toBe(150);\n    });\n\n    test('should return zero when the discount is 100%', () => {\n        const result = calculateFinalPrice('100', '100');\n        expect(result).toBe(0);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\nfunction calculateFinalPrice(price: string, discount: string): number {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\ndouble calculateFinalPrice(const std::string& price, const std::string& discount) {\n    // Function implementation goes here\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <stdexcept>\n\n// Assuming the calculateFinalPrice function is declared above or in another included file\n\nTEST_CASE(\"calculateFinalPrice\", \"[calculateFinalPrice]\") {\n    SECTION(\"should calculate the final price correctly with valid inputs\") {\n        double result = calculateFinalPrice(\"200\", \"10\");\n        REQUIRE(result == 180);\n    }\n\n    SECTION(\"should return the original price when the discount is 0%\") {\n        double result = calculateFinalPrice(\"150\", \"0\");\n        REQUIRE(result == 150);\n    }\n\n    SECTION(\"should return zero when the discount is 100%\") {\n        double result = calculateFinalPrice(\"100\", \"100\");\n        REQUIRE(result == 0);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\ndouble calculateFinalPrice(const std::string& price, const std::string& discount) {\n    // Function implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws IllegalArgumentException if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\npublic static double calculateFinalPrice(String price, String discount) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testCalculateFinalPriceWithValidInputs() {\n        double result = PriceCalculator.calculateFinalPrice(\"200\", \"10\");\n        assertEquals(180.0, result, 0.01);\n    }\n\n    @Test\n    public void testCalculateFinalPriceWithZeroDiscount() {\n        double result = PriceCalculator.calculateFinalPrice(\"150\", \"0\");\n        assertEquals(150.0, result, 0.01);\n    }\n\n    @Test\n    public void testCalculateFinalPriceWithHundredPercentDiscount() {\n        double result = PriceCalculator.calculateFinalPrice(\"100\", \"100\");\n        assertEquals(0.0, result, 0.01);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws IllegalArgumentException if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\npublic static double calculateFinalPrice(String price, String discount) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 334, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Calculate the date of Good Friday in a given year", "language_version_list": {"python": {"code_signature": "from datetime import date\n\n\ndef calculate_good_friday(year: int) -> str:\n    \"\"\"\n    Calculate the date of Good Friday in a given year.\n\n    For example:\n        input: 2024\n        output: Fri Mar 29 2024\n\n    Args:\n        year (int): The year for which to calculate Good Friday.\n\n    Returns:\n        str: The date of Good Friday.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestCalculateGoodFriday(unittest.TestCase):\n\n    def test_calculate_good_friday_2024(self):\n        result = calculate_good_friday(2024)\n        self.assertEqual(result.strftime('%a %b %d %Y'), 'Fri Mar 29 2024')\n\n    def test_calculate_good_friday_2021(self):\n        result = calculate_good_friday(2021)\n        self.assertEqual(result.strftime('%a %b %d %Y'), 'Fri Apr 02 2021')\n\n    def test_calculate_good_friday_2000(self):\n        result = calculate_good_friday(2000)\n        self.assertEqual(result.strftime('%a %b %d %Y'), 'Fri Apr 21 2000')\n\n    def test_calculate_good_friday_2019(self):\n        result = calculate_good_friday(2019)\n        self.assertEqual(result.strftime('%a %b %d %Y'), 'Fri Apr 19 2019')\n\n    def test_calculate_good_friday_1999(self):\n        result = calculate_good_friday(1999)\n        self.assertEqual(result.strftime('%a %b %d %Y'), 'Fri Apr 02 1999')\n\n    def test_calculate_good_friday_1981(self):\n        result = calculate_good_friday(1981)\n        self.assertEqual(result.strftime('%a %b %d %Y'), 'Fri Apr 17 1981')\n\n    def test_calculate_good_friday_1954(self):\n        result = calculate_good_friday(1954)\n        self.assertEqual(result.strftime('%a %b %d %Y'), 'Fri Apr 16 1954')\n", "prompt": "please write a python function , the function signature as below from datetime import date\n\n\ndef calculate_good_friday(year: int) -> str:\n    \"\"\"\n    Calculate the date of Good Friday in a given year.\n\n    For example:\n        input: 2024\n        output: Fri Mar 29 2024\n\n    Args:\n        year (int): The year for which to calculate Good Friday.\n\n    Returns:\n        str: The date of Good Friday.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * calculate the date of Good Friday in a given year\n * For example:\n *      input: 2024\n *      output: Fri Mar 29 2024\n * @param year\n */\nfunction calculateGoodFriday(year) {\n    // Implementation goes here\n}", "test_code": "describe('calculateGoodFriday', () => {\n    it('should correctly calculate Good Friday for 2024', () => {\n        const result = calculateGoodFriday(2024);\n        expect(result.toDateString()).toBe('Fri Mar 29 2024');\n    });\n\n    it('should correctly calculate Good Friday for 2021', () => {\n        const result = calculateGoodFriday(2021);\n        expect(result.toDateString()).toBe('Fri Apr 02 2021');\n    });\n\n    it('should correctly calculate Good Friday for 2000', () => {\n        const result = calculateGoodFriday(2000);\n        expect(result.toDateString()).toBe('Fri Apr 21 2000');\n    });\n\n    it('should correctly calculate Good Friday for 2019', () => {\n        const result = calculateGoodFriday(2019);\n        expect(result.toDateString()).toBe('Fri Apr 19 2019');\n    });\n\n    it('should correctly calculate Good Friday for 1999', () => {\n        const result = calculateGoodFriday(1999);\n        expect(result.toDateString()).toBe('Fri Apr 02 1999');\n    });\n\n    it('should correctly calculate Good Friday for 1981', () => {\n        const result = calculateGoodFriday(1981);\n        expect(result.toDateString()).toBe('Fri Apr 17 1981');\n    });\n\n    it('should correctly calculate Good Friday for 1954', () => {\n        const result = calculateGoodFriday(1954);\n        expect(result.toDateString()).toBe('Fri Apr 16 1954');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * calculate the date of Good Friday in a given year\n * For example:\n *      input: 2024\n *      output: Fri Mar 29 2024\n * @param year\n */\nfunction calculateGoodFriday(year) {\n    // Implementation goes here\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * calculate the date of Good Friday in a given year\n * For example:\n *      input: 2024\n *      output: Fri Mar 29 2024\n * @param year\n */\nfunction calculateGoodFriday(year: number): Date {\n\n}", "test_code": "describe('calculateGoodFriday', () => {\n    it('should correctly calculate Good Friday for 2024', () => {\n        const result = calculateGoodFriday(2024);\n        expect(result.toDateString()).toBe('Fri Mar 29 2024');\n    });\n\n    it('should correctly calculate Good Friday for 2021', () => {\n        const result = calculateGoodFriday(2021);\n        expect(result.toDateString()).toBe('Fri Apr 02 2021');\n    });\n\n    it('should correctly calculate Good Friday for 2000', () => {\n        const result = calculateGoodFriday(2000);\n        expect(result.toDateString()).toBe('Fri Apr 21 2000');\n    });\n\n    it('should correctly calculate Good Friday for 2019', () => {\n        const result = calculateGoodFriday(2019);\n        expect(result.toDateString()).toBe('Fri Apr 19 2019');\n    });\n\n    it('should correctly calculate Good Friday for 1999', () => {\n        const result = calculateGoodFriday(1999);\n        expect(result.toDateString()).toBe('Fri Apr 02 1999');\n    });\n\n    it('should correctly calculate Good Friday for 1981', () => {\n        const result = calculateGoodFriday(1981);\n        expect(result.toDateString()).toBe('Fri Apr 17 1981');\n    });\n\n    it('should correctly calculate Good Friday for 1954', () => {\n        const result = calculateGoodFriday(1954);\n        expect(result.toDateString()).toBe('Fri Apr 16 1954');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * calculate the date of Good Friday in a given year\n * For example:\n *      input: 2024\n *      output: Fri Mar 29 2024\n * @param year\n */\nfunction calculateGoodFriday(year: number): Date {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculate the date of Good Friday in a given year\n * For example:\n *      input: 2024\n *      output: Fri Mar 29 2024\n * @param year The year for which to calculate Good Friday\n * @return std::tm structure representing Good Friday\n */\nstd::tm calculateGoodFriday(int year){\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <iomanip>\n#include <sstream>\n#include <ctime>\n\nstd::tm calculateGoodFriday(int year); // Declaration of the function\n\nstd::string formatDate(const std::tm& date) {\n    std::ostringstream oss;\n    oss << std::put_time(&date, \"%a %b %d %Y\");\n    return oss.str();\n}\n\nTEST_CASE(\"calculateGoodFriday\", \"[GoodFriday]\") {\n    SECTION(\"should correctly calculate Good Friday for 2024\") {\n        std::tm result = calculateGoodFriday(2024);\n        REQUIRE(formatDate(result) == \"Fri Mar 29 2024\");\n    }\n\n    SECTION(\"should correctly calculate Good Friday for 2021\") {\n        std::tm result = calculateGoodFriday(2021);\n        REQUIRE(formatDate(result) == \"Fri Apr 02 2021\");\n    }\n\n    SECTION(\"should correctly calculate Good Friday for 2000\") {\n        std::tm result = calculateGoodFriday(2000);\n        REQUIRE(formatDate(result) == \"Fri Apr 21 2000\");\n    }\n\n    SECTION(\"should correctly calculate Good Friday for 2019\") {\n        std::tm result = calculateGoodFriday(2019);\n        REQUIRE(formatDate(result) == \"Fri Apr 19 2019\");\n    }\n\n    SECTION(\"should correctly calculate Good Friday for 1999\") {\n        std::tm result = calculateGoodFriday(1999);\n        REQUIRE(formatDate(result) == \"Fri Apr 02 1999\");\n    }\n\n    SECTION(\"should correctly calculate Good Friday for 1981\") {\n        std::tm result = calculateGoodFriday(1981);\n        REQUIRE(formatDate(result) == \"Fri Apr 17 1981\");\n    }\n\n    SECTION(\"should correctly calculate Good Friday for 1954\") {\n        std::tm result = calculateGoodFriday(1954);\n        REQUIRE(formatDate(result) == \"Fri Apr 16 1954\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculate the date of Good Friday in a given year\n * For example:\n *      input: 2024\n *      output: Fri Mar 29 2024\n * @param year The year for which to calculate Good Friday\n * @return std::tm structure representing Good Friday\n */\nstd::tm calculateGoodFriday(int year){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate the date of Good Friday in a given year.\n * For example:\n *      input: 2024\n *      output: Fri Mar 29 2024\n * @param year the year for which to calculate Good Friday\n * @return the date of Good Friday\n */\npublic static Date calculateGoodFriday(int year) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport java.util.Date;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n    @Test\n    public void testCalculateGoodFriday2024() {\n        Date result = EasterCalculator.calculateGoodFriday(2024);\n        assertEquals(\"Fri Mar 29 00:00:00 UTC 2024\", result.toString());\n    }\n\n    @Test\n    public void testCalculateGoodFriday2021() {\n        Date result = EasterCalculator.calculateGoodFriday(2021);\n        assertEquals(\"Fri Apr 02 00:00:00 UTC 2021\", result.toString());\n    }\n\n    @Test\n    public void testCalculateGoodFriday2000() {\n        Date result = EasterCalculator.calculateGoodFriday(2000);\n        assertEquals(\"Fri Apr 21 00:00:00 UTC 2000\", result.toString());\n    }\n\n    @Test\n    public void testCalculateGoodFriday2019() {\n        Date result = EasterCalculator.calculateGoodFriday(2019);\n        assertEquals(\"Fri Apr 19 00:00:00 UTC 2019\", result.toString());\n    }\n\n    @Test\n    public void testCalculateGoodFriday1999() {\n        Date result = EasterCalculator.calculateGoodFriday(1999);\n        assertEquals(\"Fri Apr 02 00:00:00 UTC 1999\", result.toString());\n    }\n\n    @Test\n    public void testCalculateGoodFriday1981() {\n        Date result = EasterCalculator.calculateGoodFriday(1981);\n        assertEquals(\"Fri Apr 17 00:00:00 UTC 1981\", result.toString());\n    }\n\n    @Test\n    public void testCalculateGoodFriday1954() {\n        Date result = EasterCalculator.calculateGoodFriday(1954);\n        assertEquals(\"Fri Apr 16 00:00:00 UTC 1954\", result.toString());\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculate the date of Good Friday in a given year.\n * For example:\n *      input: 2024\n *      output: Fri Mar 29 2024\n * @param year the year for which to calculate Good Friday\n * @return the date of Good Friday\n */\npublic static Date calculateGoodFriday(int year) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 341, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.", "language_version_list": {"python": {"code_signature": "def convert_time_hms_string_to_ms(time_str: str) -> int:\n    \"\"\"\n    Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n\n    Args:\n        time_str (str): The input string representing the time duration.\n\n    Returns:\n        int: The time in milliseconds.\n\n    Raises:\n        ValueError: If the input string does not match the expected format.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestConvertTimeHmsStringToMs(unittest.TestCase):\n\n    def test_converts_typical_time_string_correctly(self):\n        result = convert_time_hms_string_to_ms('1h30m15s')\n        self.assertEqual(result, 5415000)  # 1 hour + 30 minutes + 15 seconds in ms\n\n    def test_correctly_converts_string_with_zero_values(self):\n        result = convert_time_hms_string_to_ms('0h0m0s')\n        self.assertEqual(result, 0)  # 0 ms\n\n    def test_converts_maximum_single_digit_values(self):\n        result = convert_time_hms_string_to_ms('9h59m59s')\n        self.assertEqual(result, 35999000)  # 9 hours + 59 minutes + 59 seconds in ms\n\n    def test_handles_large_values(self):\n        result = convert_time_hms_string_to_ms('100h0m0s')\n        self.assertEqual(result, 360000000)  # 100 hours in ms\n\n    def test_correctly_converts_strings_with_leading_zeros(self):\n        result = convert_time_hms_string_to_ms('01h01m01s')\n        self.assertEqual(result, 3661000)  # 1 hour + 1 minute + 1 second in ms\n", "prompt": "please write a python function , the function signature as below def convert_time_hms_string_to_ms(time_str: str) -> int:\n    \"\"\"\n    Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n\n    Args:\n        time_str (str): The input string representing the time duration.\n\n    Returns:\n        int: The time in milliseconds.\n\n    Raises:\n        ValueError: If the input string does not match the expected format.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @returns The time in milliseconds.\n * @throws Error if the input string does not match the expected format.\n */\nfunction convertTimeHmsStringToMs(str) {\n}", "test_code": "describe('convertTimeHmsStringToMs', () => {\n    test('converts typical time string correctly (1h30m15s)', () => {\n        const result = convertTimeHmsStringToMs('1h30m15s');\n        expect(result).toBe(5415000);  // 1 hour + 30 minutes + 15 seconds in ms\n    });\n\n    test('correctly converts string with zero values (0h0m0s)', () => {\n        const result = convertTimeHmsStringToMs('0h0m0s');\n        expect(result).toBe(0);  // 0 ms\n    });\n\n    test('converts maximum single digit values (9h59m59s)', () => {\n        const result = convertTimeHmsStringToMs('9h59m59s');\n        expect(result).toBe(35999000); // 9 hours + 59 minutes + 59 seconds in ms\n    });\n\n    test('handles large values (100h0m0s)', () => {\n        const result = convertTimeHmsStringToMs('100h0m0s');\n        expect(result).toBe(360000000); // 100 hours in ms\n    });\n\n    test('correctly converts strings with leading zeros (01h01m01s)', () => {\n        const result = convertTimeHmsStringToMs('01h01m01s');\n        expect(result).toBe(3661000); // 1 hour + 1 minute + 1 second in ms\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @returns The time in milliseconds.\n * @throws Error if the input string does not match the expected format.\n */\nfunction convertTimeHmsStringToMs(str) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @returns The time in milliseconds.\n * @throws Error if the input string does not match the expected format.\n */\nfunction convertTimeHmsStringToMs(str: string): number {\n}", "test_code": "describe('convertTimeHmsStringToMs', () => {\n    test('converts typical time string correctly (1h30m15s)', () => {\n        const result = convertTimeHmsStringToMs('1h30m15s');\n        expect(result).toBe(5415000);  // 1 hour + 30 minutes + 15 seconds in ms\n    });\n\n    test('correctly converts string with zero values (0h0m0s)', () => {\n        const result = convertTimeHmsStringToMs('0h0m0s');\n        expect(result).toBe(0);  // 0 ms\n    });\n\n    test('converts maximum single digit values (9h59m59s)', () => {\n        const result = convertTimeHmsStringToMs('9h59m59s');\n        expect(result).toBe(35999000); // 9 hours + 59 minutes + 59 seconds in ms\n    });\n\n    test('handles large values (100h0m0s)', () => {\n        const result = convertTimeHmsStringToMs('100h0m0s');\n        expect(result).toBe(360000000); // 100 hours in ms\n    });\n\n\n    test('correctly converts strings with leading zeros (01h01m01s)', () => {\n        const result = convertTimeHmsStringToMs('01h01m01s');\n        expect(result).toBe(3661000); // 1 hour + 1 minute + 1 second in ms\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @returns The time in milliseconds.\n * @throws Error if the input string does not match the expected format.\n */\nfunction convertTimeHmsStringToMs(str: string): number {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @returns The time in milliseconds.\n * @throws std::invalid_argument if the input string does not match the expected format.\n */\nlong long convertTimeHmsStringToMs(const std::string& str) {\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include \"your_header_file.h\" // Include the header file where your function is declared\n\nTEST_CASE(\"convertTimeHmsStringToMs\", \"[conversion]\") {\n    SECTION(\"converts typical time string correctly (1h30m15s)\") {\n        long long result = convertTimeHmsStringToMs(\"1h30m15s\");\n        REQUIRE(result == 5415000);  // 1 hour + 30 minutes + 15 seconds in ms\n    }\n\n    SECTION(\"correctly converts string with zero values (0h0m0s)\") {\n        long long result = convertTimeHmsStringToMs(\"0h0m0s\");\n        REQUIRE(result == 0);  // 0 ms\n    }\n\n    SECTION(\"converts maximum single digit values (9h59m59s)\") {\n        long long result = convertTimeHmsStringToMs(\"9h59m59s\");\n        REQUIRE(result == 35999000); // 9 hours + 59 minutes + 59 seconds in ms\n    }\n\n    SECTION(\"handles large values (100h0m0s)\") {\n        long long result = convertTimeHmsStringToMs(\"100h0m0s\");\n        REQUIRE(result == 360000000); // 100 hours in ms\n    }\n\n    SECTION(\"correctly converts strings with leading zeros (01h01m01s)\") {\n        long long result = convertTimeHmsStringToMs(\"01h01m01s\");\n        REQUIRE(result == 3661000); // 1 hour + 1 minute + 1 second in ms\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @returns The time in milliseconds.\n * @throws std::invalid_argument if the input string does not match the expected format.\n */\nlong long convertTimeHmsStringToMs(const std::string& str) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @return The time in milliseconds.\n * @throws IllegalArgumentException if the input string does not match the expected format.\n */\npublic static long convertTimeHmsStringToMs(String str) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testConvertTypicalTimeString() {\n        long result = TimeConverter.convertTimeHmsStringToMs(\"1h30m15s\");\n        assertEquals(5415000, result);  // 1 hour + 30 minutes + 15 seconds in ms\n    }\n\n    @Test\n    public void testConvertZeroValues() {\n        long result = TimeConverter.convertTimeHmsStringToMs(\"0h0m0s\");\n        assertEquals(0, result);  // 0 ms\n    }\n\n    @Test\n    public void testConvertMaxSingleDigitValues() {\n        long result = TimeConverter.convertTimeHmsStringToMs(\"9h59m59s\");\n        assertEquals(35999000, result); // 9 hours + 59 minutes + 59 seconds in ms\n    }\n\n    @Test\n    public void testHandleLargeValues() {\n        long result = TimeConverter.convertTimeHmsStringToMs(\"100h0m0s\");\n        assertEquals(360000000, result); // 100 hours in ms\n    }\n\n    @Test\n    public void testConvertLeadingZeros() {\n        long result = TimeConverter.convertTimeHmsStringToMs(\"01h01m01s\");\n        assertEquals(3661000, result); // 1 hour + 1 minute + 1 second in ms\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @return The time in milliseconds.\n * @throws IllegalArgumentException if the input string does not match the expected format.\n */\npublic static long convertTimeHmsStringToMs(String str) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 342, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Parses the Markdown string title, extracts the first-level title, second-level title, third-level title, and returns it in the form of a dictionary array", "language_version_list": {"python": {"code_signature": "from typing import Dict, List\n\n\ndef parse_markdown_titles(markdown: str) -> Dict[str, List[str]]:\n    \"\"\"\n    Parses markdown text to extract titles of different levels.\n\n    This function takes a string of markdown content as input and returns an\n    object containing arrays of titles categorized by their level:\n    level 1 (H1), level 2 (H2), and level 3 (H3).\n\n    Args:\n        markdown (str): A string containing markdown formatted text.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary with three properties: level1, level2, and level3,\n                               each holding a list of corresponding titles found in the markdown.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestParseMarkdownTitles(unittest.TestCase):\n\n    def test_extract_first_second_and_third_level_titles(self):\n        markdown = \"\"\"        \n        # Title 1\n        Content here.\n        ## Subtitle 1.1\n        More content.\n        ### Subsubtitle 1.1.1\n        Even more content.\n        # Title 2\n        Another content.\n        \"\"\"\n        result = parse_markdown_titles(markdown)\n        self.assertEqual(result, {\n            'level1': [\"Title 1\", \"Title 2\"],\n            'level2': [\"Subtitle 1.1\"],\n            'level3': [\"Subsubtitle 1.1.1\"],\n        })\n\n    def test_handle_missing_headers(self):\n        markdown = \"\"\"        \n        This is just some text without headers.\n        \"\"\"\n        result = parse_markdown_titles(markdown)\n        self.assertEqual(result, {\n            'level1': [],\n            'level2': [],\n            'level3': [],\n        })\n\n    def test_handle_only_first_level_headers(self):\n        markdown = \"\"\"        \n        # Only Title 1\n        Content without subtitles.\n\n        # Only Title 2\n        More content.\n        \"\"\"\n        result = parse_markdown_titles(markdown)\n        self.assertEqual(result, {\n            'level1': [\"Only Title 1\", \"Only Title 2\"],\n            'level2': [],\n            'level3': [],\n        })\n\n    def test_handle_mixed_headers_with_empty_lines(self):\n        markdown = \"\"\"        \n        # Title 1\n        ## Subtitle 1.1\n        Some content here.\n        ### Subsubtitle 1.1.1\n\n        # Title 2\n        \"\"\"\n        result = parse_markdown_titles(markdown)\n        self.assertEqual(result, {\n            'level1': [\"Title 1\", \"Title 2\"],\n            'level2': [\"Subtitle 1.1\"],\n            'level3': [\"Subsubtitle 1.1.1\"],\n        })\n\n    def test_handle_headers_with_special_characters(self):\n        markdown = \"\"\"        \n        # Title 1 - Special Characters!\n        ## Subtitle 1.1: The Beginning\n        ### Subsubtitle 1.1.1 (Note)\n        \"\"\"\n        result = parse_markdown_titles(markdown)\n        self.assertEqual(result, {\n            'level1': [\"Title 1 - Special Characters!\"],\n            'level2': [\"Subtitle 1.1: The Beginning\"],\n            'level3': [\"Subsubtitle 1.1.1 (Note)\"],\n        })\n", "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef parse_markdown_titles(markdown: str) -> Dict[str, List[str]]:\n    \"\"\"\n    Parses markdown text to extract titles of different levels.\n\n    This function takes a string of markdown content as input and returns an\n    object containing arrays of titles categorized by their level:\n    level 1 (H1), level 2 (H2), and level 3 (H3).\n\n    Args:\n        markdown (str): A string containing markdown formatted text.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary with three properties: level1, level2, and level3,\n                               each holding a list of corresponding titles found in the markdown.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Parses markdown text to extract titles of different levels.\n *\n * This function takes a string of markdown content as input and returns an\n * object containing arrays of titles categorized by their level:\n * level 1 (H1), level 2 (H2), and level 3 (H3).\n *\n * @param markdown - A string containing markdown formatted text.\n * @returns An object with three properties: level1, level2, and level3,\n *          each holding an array of corresponding titles found in the markdown.\n */\nfunction parseMarkdownTitles(markdown) {\n    // Function implementation goes here\n}", "test_code": "describe('parseMarkdownTitles', () => {\n    test('should extract first, second, and third level titles', () => {\n        const markdown = `\n        # Title 1\n        Content here.\n\n        ## Subtitle 1.1\n        More content.\n\n        ### Subsubtitle 1.1.1\n        Even more content.\n\n        # Title 2\n        Another content.\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [\"Title 1\", \"Title 2\"],\n            level2: [\"Subtitle 1.1\"],\n            level3: [\"Subsubtitle 1.1.1\"],\n        });\n    });\n\n    test('should handle missing headers', () => {\n        const markdown = `\n        This is just some text without headers.\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [],\n            level2: [],\n            level3: [],\n        });\n    });\n\n    test('should handle only first-level headers', () => {\n        const markdown = `\n        # Only Title 1\n        Content without subtitles.\n        \n        # Only Title 2\n        More content.\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [\"Only Title 1\", \"Only Title 2\"],\n            level2: [],\n            level3: [],\n        });\n    });\n\n    test('should handle mixed headers with empty lines', () => {\n        const markdown = `\n        # Title 1\n\n        ## Subtitle 1.1\n\n        Some content here.\n\n        ### Subsubtitle 1.1.1\n        \n        # Title 2\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [\"Title 1\", \"Title 2\"],\n            level2: [\"Subtitle 1.1\"],\n            level3: [\"Subsubtitle 1.1.1\"],\n        });\n    });\n\n    test('should handle headers with special characters', () => {\n        const markdown = `\n        # Title 1 - Special Characters!\n        ## Subtitle 1.1: The Beginning\n        ### Subsubtitle 1.1.1 (Note)\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [\"Title 1 - Special Characters!\"],\n            level2: [\"Subtitle 1.1: The Beginning\"],\n            level3: [\"Subsubtitle 1.1.1 (Note)\"],\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Parses markdown text to extract titles of different levels.\n *\n * This function takes a string of markdown content as input and returns an\n * object containing arrays of titles categorized by their level:\n * level 1 (H1), level 2 (H2), and level 3 (H3).\n *\n * @param markdown - A string containing markdown formatted text.\n * @returns An object with three properties: level1, level2, and level3,\n *          each holding an array of corresponding titles found in the markdown.\n */\nfunction parseMarkdownTitles(markdown) {\n    // Function implementation goes here\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Parses markdown text to extract titles of different levels.\n *\n * This function takes a string of markdown content as input and returns an\n * object containing arrays of titles categorized by their level:\n * level 1 (H1), level 2 (H2), and level 3 (H3).\n *\n * @param markdown - A string containing markdown formatted text.\n * @returns An object with three properties: level1, level2, and level3,\n *          each holding an array of corresponding titles found in the markdown.\n */\nfunction parseMarkdownTitles(markdown: string): { level1: string[]; level2: string[]; level3: string[] } {\n\n}\n", "test_code": "describe('parseMarkdownTitles', () => {\n    test('should extract first, second, and third level titles', () => {\n        const markdown = `\n        # Title 1\n        Content here.\n\n        ## Subtitle 1.1\n        More content.\n\n        ### Subsubtitle 1.1.1\n        Even more content.\n\n        # Title 2\n        Another content.\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [\"Title 1\", \"Title 2\"],\n            level2: [\"Subtitle 1.1\"],\n            level3: [\"Subsubtitle 1.1.1\"],\n        });\n    });\n\n    test('should handle missing headers', () => {\n        const markdown = `\n        This is just some text without headers.\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [],\n            level2: [],\n            level3: [],\n        });\n    });\n\n    test('should handle only first-level headers', () => {\n        const markdown = `\n        # Only Title 1\n        Content without subtitles.\n        \n        # Only Title 2\n        More content.\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [\"Only Title 1\", \"Only Title 2\"],\n            level2: [],\n            level3: [],\n        });\n    });\n\n    test('should handle mixed headers with empty lines', () => {\n        const markdown = `\n        # Title 1\n\n        ## Subtitle 1.1\n\n        Some content here.\n\n        ### Subsubtitle 1.1.1\n        \n        # Title 2\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [\"Title 1\", \"Title 2\"],\n            level2: [\"Subtitle 1.1\"],\n            level3: [\"Subsubtitle 1.1.1\"],\n        });\n    });\n\n\n    test('should handle headers with special characters', () => {\n        const markdown = `\n        # Title 1 - Special Characters!\n        ## Subtitle 1.1: The Beginning\n        ### Subsubtitle 1.1.1 (Note)\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [\"Title 1 - Special Characters!\"],\n            level2: [\"Subtitle 1.1: The Beginning\"],\n            level3: [\"Subsubtitle 1.1.1 (Note)\"],\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Parses markdown text to extract titles of different levels.\n *\n * This function takes a string of markdown content as input and returns an\n * object containing arrays of titles categorized by their level:\n * level 1 (H1), level 2 (H2), and level 3 (H3).\n *\n * @param markdown - A string containing markdown formatted text.\n * @returns An object with three properties: level1, level2, and level3,\n *          each holding an array of corresponding titles found in the markdown.\n */\nfunction parseMarkdownTitles(markdown: string): { level1: string[]; level2: string[]; level3: string[] } {\n\n}\n", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Parses markdown text to extract titles of different levels.\n *\n * This function takes a string of markdown content as input and returns an\n * object containing arrays of titles categorized by their level:\n * level 1 (H1), level 2 (H2), and level 3 (H3).\n *\n * @param markdown - A string containing markdown formatted text.\n * @returns An unordered_map with three keys: \"level1\", \"level2\", and \"level3\",\n *          each holding a vector of corresponding titles found in the markdown.\n */\nstd::unordered_map<std::string, std::vector<std::string>> parseMarkdownTitles(const std::string& markdown){\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include \"your_header_file.h\" // Replace with the actual header file containing the function\n\nTEST_CASE(\"parseMarkdownTitles\") {\n    SECTION(\"should extract first, second, and third level titles\") {\n        std::string markdown = R\"(\n        # Title 1\n        Content here.\n\n        ## Subtitle 1.1\n        More content.\n\n        ### Subsubtitle 1.1.1\n        Even more content.\n\n        # Title 2\n        Another content.\n        )\";\n\n        auto result = parseMarkdownTitles(markdown);\n        REQUIRE(result[\"level1\"] == std::vector<std::string>{\"Title 1\", \"Title 2\"});\n        REQUIRE(result[\"level2\"] == std::vector<std::string>{\"Subtitle 1.1\"});\n        REQUIRE(result[\"level3\"] == std::vector<std::string>{\"Subsubtitle 1.1.1\"});\n    }\n\n    SECTION(\"should handle missing headers\") {\n        std::string markdown = R\"(\n        This is just some text without headers.\n        )\";\n\n        auto result = parseMarkdownTitles(markdown);\n        REQUIRE(result[\"level1\"].empty());\n        REQUIRE(result[\"level2\"].empty());\n        REQUIRE(result[\"level3\"].empty());\n    }\n\n    SECTION(\"should handle only first-level headers\") {\n        std::string markdown = R\"(\n        # Only Title 1\n        Content without subtitles.\n\n        # Only Title 2\n        More content.\n        )\";\n\n        auto result = parseMarkdownTitles(markdown);\n        REQUIRE(result[\"level1\"] == std::vector<std::string>{\"Only Title 1\", \"Only Title 2\"});\n        REQUIRE(result[\"level2\"].empty());\n        REQUIRE(result[\"level3\"].empty());\n    }\n\n    SECTION(\"should handle mixed headers with empty lines\") {\n        std::string markdown = R\"(\n        # Title 1\n\n        ## Subtitle 1.1\n\n        Some content here.\n\n        ### Subsubtitle 1.1.1\n\n        # Title 2\n        )\";\n\n        auto result = parseMarkdownTitles(markdown);\n        REQUIRE(result[\"level1\"] == std::vector<std::string>{\"Title 1\", \"Title 2\"});\n        REQUIRE(result[\"level2\"] == std::vector<std::string>{\"Subtitle 1.1\"});\n        REQUIRE(result[\"level3\"] == std::vector<std::string>{\"Subsubtitle 1.1.1\"});\n    }\n\n    SECTION(\"should handle headers with special characters\") {\n        std::string markdown = R\"(\n        # Title 1 - Special Characters!\n        ## Subtitle 1.1: The Beginning\n        ### Subsubtitle 1.1.1 (Note)\n        )\";\n\n        auto result = parseMarkdownTitles(markdown);\n        REQUIRE(result[\"level1\"] == std::vector<std::string>{\"Title 1 - Special Characters!\"});\n        REQUIRE(result[\"level2\"] == std::vector<std::string>{\"Subtitle 1.1: The Beginning\"});\n        REQUIRE(result[\"level3\"] == std::vector<std::string>{\"Subsubtitle 1.1.1 (Note)\"});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Parses markdown text to extract titles of different levels.\n *\n * This function takes a string of markdown content as input and returns an\n * object containing arrays of titles categorized by their level:\n * level 1 (H1), level 2 (H2), and level 3 (H3).\n *\n * @param markdown - A string containing markdown formatted text.\n * @returns An unordered_map with three keys: \"level1\", \"level2\", and \"level3\",\n *          each holding a vector of corresponding titles found in the markdown.\n */\nstd::unordered_map<std::string, std::vector<std::string>> parseMarkdownTitles(const std::string& markdown){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Parses markdown text to extract titles of different levels.\n *\n * This function takes a string of markdown content as input and returns an\n * object containing lists of titles categorized by their level:\n * level 1 (H1), level 2 (H2), and level 3 (H3).\n *\n * @param markdown - A string containing markdown formatted text.\n * @return A map with three keys: level1, level2, and level3,\n *         each holding a list of corresponding titles found in the markdown.\n */\npublic static Map<String, List<String>> parseMarkdownTitles(String markdown) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport java.util.List;\nimport java.util.Map;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testExtractFirstSecondAndThirdLevelTitles() {\n        String markdown = \"# Title 1\\n\" +\n                          \"Content here.\\n\\n\" +\n                          \"## Subtitle 1.1\\n\" +\n                          \"More content.\\n\\n\" +\n                          \"### Subsubtitle 1.1.1\\n\" +\n                          \"Even more content.\\n\\n\" +\n                          \"# Title 2\\n\" +\n                          \"Another content.\";\n\n        Map<String, List<String>> result = MarkdownParser.parseMarkdownTitles(markdown);\n\n        assertEquals(List.of(\"Title 1\", \"Title 2\"), result.get(\"level1\"));\n        assertEquals(List.of(\"Subtitle 1.1\"), result.get(\"level2\"));\n        assertEquals(List.of(\"Subsubtitle 1.1.1\"), result.get(\"level3\"));\n    }\n\n    @Test\n    public void testHandleMissingHeaders() {\n        String markdown = \"This is just some text without headers.\";\n\n        Map<String, List<String>> result = MarkdownParser.parseMarkdownTitles(markdown);\n\n        assertEquals(List.of(), result.get(\"level1\"));\n        assertEquals(List.of(), result.get(\"level2\"));\n        assertEquals(List.of(), result.get(\"level3\"));\n    }\n\n    @Test\n    public void testHandleOnlyFirstLevelHeaders() {\n        String markdown = \"# Only Title 1\\n\" +\n                          \"Content without subtitles.\\n\\n\" +\n                          \"# Only Title 2\\n\" +\n                          \"More content.\";\n\n        Map<String, List<String>> result = MarkdownParser.parseMarkdownTitles(markdown);\n\n        assertEquals(List.of(\"Only Title 1\", \"Only Title 2\"), result.get(\"level1\"));\n        assertEquals(List.of(), result.get(\"level2\"));\n        assertEquals(List.of(), result.get(\"level3\"));\n    }\n\n    @Test\n    public void testHandleMixedHeadersWithEmptyLines() {\n        String markdown = \"# Title 1\\n\\n\" +\n                          \"## Subtitle 1.1\\n\\n\" +\n                          \"Some content here.\\n\\n\" +\n                          \"### Subsubtitle 1.1.1\\n\\n\" +\n                          \"# Title 2\\n\";\n\n        Map<String, List<String>> result = MarkdownParser.parseMarkdownTitles(markdown);\n\n        assertEquals(List.of(\"Title 1\", \"Title 2\"), result.get(\"level1\"));\n        assertEquals(List.of(\"Subtitle 1.1\"), result.get(\"level2\"));\n        assertEquals(List.of(\"Subsubtitle 1.1.1\"), result.get(\"level3\"));\n    }\n\n    @Test\n    public void testHandleHeadersWithSpecialCharacters() {\n        String markdown = \"# Title 1 - Special Characters!\\n\" +\n                          \"## Subtitle 1.1: The Beginning\\n\" +\n                          \"### Subsubtitle 1.1.1 (Note)\\n\";\n\n        Map<String, List<String>> result = MarkdownParser.parseMarkdownTitles(markdown);\n\n        assertEquals(List.of(\"Title 1 - Special Characters!\"), result.get(\"level1\"));\n        assertEquals(List.of(\"Subtitle 1.1: The Beginning\"), result.get(\"level2\"));\n        assertEquals(List.of(\"Subsubtitle 1.1.1 (Note)\"), result.get(\"level3\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Parses markdown text to extract titles of different levels.\n *\n * This function takes a string of markdown content as input and returns an\n * object containing lists of titles categorized by their level:\n * level 1 (H1), level 2 (H2), and level 3 (H3).\n *\n * @param markdown - A string containing markdown formatted text.\n * @return A map with three keys: level1, level2, and level3,\n *         each holding a list of corresponding titles found in the markdown.\n */\npublic static Map<String, List<String>> parseMarkdownTitles(String markdown) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 343, "code_type": "method", "original_language": "typescript", "question_type": "Algorithm and data structure", "summary": "Compare two objects for equal depth", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Compares two objects to determine if they have the same depth and structure.\n *\n * @param obj1 - The first object to compare.\n * @param obj2 - The second object to compare.\n * @returns True if the objects have equal depth, otherwise false.\n */\nfunction compareObjectsDepth(obj1, obj2) {\n}", "test_code": "describe('compareObjectsDepth function tests', () => {\n    test('should return true for equal depth and structure', () => {\n        const objA = { a: { b: { c: 1 } }, d: 2 };\n        const objB = { a: { b: { c: 3 } }, d: 4 };\n        expect(compareObjectsDepth(objA, objB)).toBe(false); // Same structure\n    });\n\n    test('should return false for different structure (missing key)', () => {\n        const objA = { a: { b: { c: 1 } }, d: 2 };\n        const objC = { a: { b: { c: 3 } }, e: 4 };\n        expect(compareObjectsDepth(objA, objC)).toBe(false); // Different structure\n    });\n\n    test('should return false for different depth', () => {\n        const objA = { a: { b: { c: 1 } }, d: 2 };\n        const objD = { a: { b: 1 }, d: 2 };\n        expect(compareObjectsDepth(objA, objD)).toBe(false); // Different depth\n    });\n\n    test('should return false for non-object inputs', () => {\n        const objA = { a: { b: { c: 1 } }, d: 2 };\n        const objE = null;\n        expect(compareObjectsDepth(objA, objE)).toBe(false); // Non-object input\n    });\n\n    test('should return false for different types (number vs object)', () => {\n        const objA = { a: { b: 1 }, d: 2 };\n        const objF = { a: { b: { c: 3 } }, d: 4 };\n        expect(compareObjectsDepth(objA, objF)).toBe(false); // Different types\n    });\n\n    test('should return true for identical empty objects', () => {\n        const objG = {};\n        const objH = {};\n        expect(compareObjectsDepth(objG, objH)).toBe(true); // Both are empty\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Compares two objects to determine if they have the same depth and structure.\n *\n * @param obj1 - The first object to compare.\n * @param obj2 - The second object to compare.\n * @returns True if the objects have equal depth, otherwise false.\n */\nfunction compareObjectsDepth(obj1, obj2) {\n}", "addition_info": ""}, "typescript": {"code_signature": "type AnyObject = { [key: string]: any };\n\n/**\n * Compares two objects to determine if they have the same depth and structure.\n *\n * @param obj1 - The first object to compare.\n * @param obj2 - The second object to compare.\n * @returns True if the objects have equal depth, otherwise false.\n */\nfunction compareObjectsDepth(obj1: AnyObject, obj2: AnyObject): boolean {\n}", "test_code": "describe('compareObjectsDepth function tests', () => {\n    test('should return true for equal depth and structure', () => {\n        const objA = { a: { b: { c: 1 } }, d: 2 };\n        const objB = { a: { b: { c: 3 } }, d: 4 };\n        expect(compareObjectsDepth(objA, objB)).toBe(false); // Same structure\n    });\n\n    test('should return false for different structure (missing key)', () => {\n        const objA = { a: { b: { c: 1 } }, d: 2 };\n        const objC = { a: { b: { c: 3 } }, e: 4 };\n        expect(compareObjectsDepth(objA, objC)).toBe(false); // Different structure\n    });\n\n    test('should return false for different depth', () => {\n        const objA = { a: { b: { c: 1 } }, d: 2 };\n        const objD = { a: { b: 1 }, d: 2 };\n        expect(compareObjectsDepth(objA, objD)).toBe(false); // Different depth\n    });\n\n    test('should return false for non-object inputs', () => {\n        const objA = { a: { b: { c: 1 } }, d: 2 };\n        const objE = null;\n        expect(compareObjectsDepth(objA, objE)).toBe(false); // Non-object input\n    });\n\n    test('should return false for different types (number vs object)', () => {\n        const objA = { a: { b: 1 }, d: 2 };\n        const objF = { a: { b: { c: 3 } }, d: 4 };\n        expect(compareObjectsDepth(objA, objF)).toBe(false); // Different types\n    });\n\n    test('should return true for identical empty objects', () => {\n        const objG = {};\n        const objH = {};\n        expect(compareObjectsDepth(objG, objH)).toBe(true); // Both are empty\n    });\n});", "prompt": "please write a typescript function , the function signature as below type AnyObject = { [key: string]: any };\n\n/**\n * Compares two objects to determine if they have the same depth and structure.\n *\n * @param obj1 - The first object to compare.\n * @param obj2 - The second object to compare.\n * @returns True if the objects have equal depth, otherwise false.\n */\nfunction compareObjectsDepth(obj1: AnyObject, obj2: AnyObject): boolean {\n}", "addition_info": "type AnyObject = { [key: string]: any };"}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 565, "code_type": "method", "original_language": "typescript", "question_type": "Algorithm and data structure", "summary": "Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.", "language_version_list": {"python": {"code_signature": "from typing import List, Dict\n\n\ndef get_bezier_point(t: float, points: List[Dict[str, float]]) -> Dict[str, float]:\n    \"\"\"\n    Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n\n    Args:\n        t(float): A value between 0 and 1 representing the interpolation parameter.\n        points(List[Dict[str, float]]): A list of control points defining the B\u00e9zier curve.\n\n    Returns:\n        The calculated Coordinates at the given parameter t.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestGetBezierPoint(unittest.TestCase):\n\n    # Test case 1: Test with a simple linear curve\n    def test_midpoint_of_two_points(self):\n        points = [{'x': 0, 'y': 0}, {'x': 2, 'y': 2}]\n        result = get_bezier_point(0.5, points)\n        self.assertEqual(result, {'x': 1, 'y': 1})\n\n    # Test case 2: Test with three points (quadratic curve)\n    def test_quadratic_bezier_curve(self):\n        points = [\n            {'x': 0, 'y': 0},\n            {'x': 1, 'y': 2},\n            {'x': 2, 'y': 0}\n        ]\n        result = get_bezier_point(0.5, points)\n        self.assertEqual(result, {'x': 1, 'y': 1})\n\n    # Test case 3: Test with four points (cubic curve)\n    def test_cubic_bezier_curve(self):\n        points = [\n            {'x': 0, 'y': 0},\n            {'x': 1, 'y': 3},\n            {'x': 3, 'y': 1},\n            {'x': 4, 'y': 0}\n        ]\n        result = get_bezier_point(0.5, points)\n        self.assertEqual(result, {'x': 2, 'y': 1.5})\n\n    # Test case 4: Test with a single point (edge case)\n    def test_single_control_point(self):\n        points = [{'x': 5, 'y': 5}]\n        result = get_bezier_point(0.5, points)\n        self.assertEqual(result, {'x': 5, 'y': 5})\n\n    # Test case 5: Test with extreme t value (0)\n    def test_extreme_t_value_zero(self):\n        points = [\n            {'x': 0, 'y': 0},\n            {'x': 5, 'y': 5}\n        ]\n        result = get_bezier_point(0, points)\n        self.assertEqual(result, {'x': 0, 'y': 0})\n\n    # Test case 6: Test with extreme t value (1)\n    def test_extreme_t_value_one(self):\n        points = [\n            {'x': 0, 'y': 0},\n            {'x': 5, 'y': 5}\n        ]\n        result = get_bezier_point(1, points)\n        self.assertEqual(result, {'x': 5, 'y': 5})\n", "prompt": "please write a python function , the function signature as below from typing import List, Dict\n\n\ndef get_bezier_point(t: float, points: List[Dict[str, float]]) -> Dict[str, float]:\n    \"\"\"\n    Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n\n    Args:\n        t(float): A value between 0 and 1 representing the interpolation parameter.\n        points(List[Dict[str, float]]): A list of control points defining the B\u00e9zier curve.\n\n    Returns:\n        The calculated Coordinates at the given parameter t.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n *\n * @param {number} t - A value between 0 and 1 representing the interpolation parameter.\n * @param {Array<{x: number, y: number}>} points - An array of control points defining the B\u00e9zier curve.\n * @returns {{x: number, y: number}} The calculated Coordinates at the given parameter t.\n */\nfunction getBezierPoint(t, points) {\n}", "test_code": "describe('getBezierPoint', () => {\n    // Test case 1: Test with a simple linear curve\n    test('should return the midpoint of two points', () => {\n        const points = [{ x: 0, y: 0 }, { x: 2, y: 2 }];\n        const result = getBezierPoint(0.5, points);\n        expect(result).toEqual({ x: 1, y: 1 });\n    });\n\n    // Test case 2: Test with three points (quadratic curve)\n    test('should return the correct point on a quadratic B\u00e9zier curve', () => {\n        const points = [\n            { x: 0, y: 0 },\n            { x: 1, y: 2 },\n            { x: 2, y: 0 }\n        ];\n        const result = getBezierPoint(0.5, points);\n        expect(result).toEqual({ x: 1, y: 1 });\n    });\n\n    // Test case 3: Test with four points (cubic curve)\n    test('should return the correct point on a cubic B\u00e9zier curve', () => {\n        const points = [\n            { x: 0, y: 0 },\n            { x: 1, y: 3 },\n            { x: 3, y: 1 },\n            { x: 4, y: 0 }\n        ];\n        const result = getBezierPoint(0.5, points);\n        expect(result).toEqual({ x: 2, y: 1.5 });\n    });\n\n    // Test case 4: Test with single point (edge case)\n    test('should return the only point when there is a single control point', () => {\n        const points = [{ x: 5, y: 5 }];\n        const result = getBezierPoint(0.5, points);\n        expect(result).toEqual({ x: 5, y: 5 });\n    });\n\n    // Test case 5: Test with extreme t value (0)\n    test('should return the first control point when t is 0', () => {\n        const points = [\n            { x: 0, y: 0 },\n            { x: 5, y: 5 }\n        ];\n        const result = getBezierPoint(0, points);\n        expect(result).toEqual({ x: 0, y: 0 });\n    });\n\n    // Test case 6: Test with extreme t value (1)\n    test('should return the last control point when t is 1', () => {\n        const points = [\n            { x: 0, y: 0 },\n            { x: 5, y: 5 }\n        ];\n        const result = getBezierPoint(1, points);\n        expect(result).toEqual({ x: 5, y: 5 });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n *\n * @param {number} t - A value between 0 and 1 representing the interpolation parameter.\n * @param {Array<{x: number, y: number}>} points - An array of control points defining the B\u00e9zier curve.\n * @returns {{x: number, y: number}} The calculated Coordinates at the given parameter t.\n */\nfunction getBezierPoint(t, points) {\n}", "addition_info": ""}, "typescript": {"code_signature": "// Define the Coordinates type to represent a point in 2D space\ntype Coordinates = {\n    x: number;\n    y: number;\n};\n\n/**\n * Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n *\n * @param t - A value between 0 and 1 representing the interpolation parameter.\n * @param points - An array of control points defining the B\u00e9zier curve.\n * @returns The calculated Coordinates at the given parameter t.\n */\nfunction getBezierPoint(t: number, points: Coordinates[]): Coordinates {\n}", "test_code": "describe('getBezierPoint', () => {\n    // Test case 1: Test with a simple linear curve\n    test('should return the midpoint of two points', () => {\n        const points: Coordinates[] = [{ x: 0, y: 0 }, { x: 2, y: 2 }];\n        const result = getBezierPoint(0.5, points);\n        expect(result).toEqual({ x: 1, y: 1 });\n    });\n\n    // Test case 2: Test with three points (quadratic curve)\n    test('should return the correct point on a quadratic B\u00e9zier curve', () => {\n        const points: Coordinates[] = [\n            { x: 0, y: 0 },\n            { x: 1, y: 2 },\n            { x: 2, y: 0 }\n        ];\n        const result = getBezierPoint(0.5, points);\n        expect(result).toEqual({ x: 1, y: 1 });\n    });\n\n    // Test case 3: Test with four points (cubic curve)\n    test('should return the correct point on a cubic B\u00e9zier curve', () => {\n        const points: Coordinates[] = [\n            { x: 0, y: 0 },\n            { x: 1, y: 3 },\n            { x: 3, y: 1 },\n            { x: 4, y: 0 }\n        ];\n        const result = getBezierPoint(0.5, points);\n        expect(result).toEqual({ x: 2, y: 1.5 });\n    });\n\n    // Test case 4: Test with single point (edge case)\n    test('should return the only point when there is a single control point', () => {\n        const points: Coordinates[] = [{ x: 5, y: 5 }];\n        const result = getBezierPoint(0.5, points);\n        expect(result).toEqual({ x: 5, y: 5 });\n    });\n\n    // Test case 5: Test with extreme t value (0)\n    test('should return the first control point when t is 0', () => {\n        const points: Coordinates[] = [\n            { x: 0, y: 0 },\n            { x: 5, y: 5 }\n        ];\n        const result = getBezierPoint(0, points);\n        expect(result).toEqual({ x: 0, y: 0 });\n    });\n\n    // Test case 6: Test with extreme t value (1)\n    test('should return the last control point when t is 1', () => {\n        const points: Coordinates[] = [\n            { x: 0, y: 0 },\n            { x: 5, y: 5 }\n        ];\n        const result = getBezierPoint(1, points);\n        expect(result).toEqual({ x: 5, y: 5 });\n    });\n\n});", "prompt": "please write a typescript function , the function signature as below // Define the Coordinates type to represent a point in 2D space\ntype Coordinates = {\n    x: number;\n    y: number;\n};\n\n/**\n * Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n *\n * @param t - A value between 0 and 1 representing the interpolation parameter.\n * @param points - An array of control points defining the B\u00e9zier curve.\n * @returns The calculated Coordinates at the given parameter t.\n */\nfunction getBezierPoint(t: number, points: Coordinates[]): Coordinates {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n *\n * @param t - A value between 0 and 1 representing the interpolation parameter.\n * @param points - A vector of control points defining the B\u00e9zier curve.\n * @returns The calculated Coordinates at the given parameter t.\n */\nCoordinates getBezierPoint(double t, const std::vector<Coordinates>& points) {\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <vector>\n\nstruct Coordinates {\n    double x;\n    double y;\n};\n\n// Function prototype\nCoordinates getBezierPoint(double t, const std::vector<Coordinates>& points);\n\nTEST_CASE(\"getBezierPoint\", \"[Bezier]\") {\n    // Test case 1: Test with a simple linear curve\n    SECTION(\"should return the midpoint of two points\") {\n        std::vector<Coordinates> points = {{0, 0}, {2, 2}};\n        Coordinates result = getBezierPoint(0.5, points);\n        REQUIRE(result.x == Approx(1));\n        REQUIRE(result.y == Approx(1));\n    }\n\n    // Test case 2: Test with three points (quadratic curve)\n    SECTION(\"should return the correct point on a quadratic B\u00e9zier curve\") {\n        std::vector<Coordinates> points = {{0, 0}, {1, 2}, {2, 0}};\n        Coordinates result = getBezierPoint(0.5, points);\n        REQUIRE(result.x == Approx(1));\n        REQUIRE(result.y == Approx(1));\n    }\n\n    // Test case 3: Test with four points (cubic curve)\n    SECTION(\"should return the correct point on a cubic B\u00e9zier curve\") {\n        std::vector<Coordinates> points = {{0, 0}, {1, 3}, {3, 1}, {4, 0}};\n        Coordinates result = getBezierPoint(0.5, points);\n        REQUIRE(result.x == Approx(2));\n        REQUIRE(result.y == Approx(1.5));\n    }\n\n    // Test case 4: Test with single point (edge case)\n    SECTION(\"should return the only point when there is a single control point\") {\n        std::vector<Coordinates> points = {{5, 5}};\n        Coordinates result = getBezierPoint(0.5, points);\n        REQUIRE(result.x == Approx(5));\n        REQUIRE(result.y == Approx(5));\n    }\n\n    // Test case 5: Test with extreme t value (0)\n    SECTION(\"should return the first control point when t is 0\") {\n        std::vector<Coordinates> points = {{0, 0}, {5, 5}};\n        Coordinates result = getBezierPoint(0, points);\n        REQUIRE(result.x == Approx(0));\n        REQUIRE(result.y == Approx(0));\n    }\n\n    // Test case 6: Test with extreme t value (1)\n    SECTION(\"should return the last control point when t is 1\") {\n        std::vector<Coordinates> points = {{0, 0}, {5, 5}};\n        Coordinates result = getBezierPoint(1, points);\n        REQUIRE(result.x == Approx(5));\n        REQUIRE(result.y == Approx(5));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n *\n * @param t - A value between 0 and 1 representing the interpolation parameter.\n * @param points - A vector of control points defining the B\u00e9zier curve.\n * @returns The calculated Coordinates at the given parameter t.\n */\nCoordinates getBezierPoint(double t, const std::vector<Coordinates>& points) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n *\n * @param t - A value between 0 and 1 representing the interpolation parameter.\n * @param points - An array of control points defining the B\u00e9zier curve.\n * @return The calculated Coordinates at the given parameter t.\n */\nstatic class Coordinates {\n    double x;\n    double y;\n\n    Coordinates(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\npublic static Coordinates getBezierPoint(double t, Coordinates[] points) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    // Test case 1: Test with a simple linear curve\n    @Test\n    public void testMidpointOfTwoPoints() {\n        Coordinates[] points = { new Coordinates(0, 0), new Coordinates(2, 2) };\n        Coordinates result = BezierCurve.getBezierPoint(0.5, points);\n        assertEquals(1.0, result.x, 0.001);\n        assertEquals(1.0, result.y, 0.001);\n    }\n\n    // Test case 2: Test with three points (quadratic curve)\n    @Test\n    public void testQuadraticBezierCurve() {\n        Coordinates[] points = {\n            new Coordinates(0, 0),\n            new Coordinates(1, 2),\n            new Coordinates(2, 0)\n        };\n        Coordinates result = BezierCurve.getBezierPoint(0.5, points);\n        assertEquals(1.0, result.x, 0.001);\n        assertEquals(1.0, result.y, 0.001);\n    }\n\n    // Test case 3: Test with four points (cubic curve)\n    @Test\n    public void testCubicBezierCurve() {\n        Coordinates[] points = {\n            new Coordinates(0, 0),\n            new Coordinates(1, 3),\n            new Coordinates(3, 1),\n            new Coordinates(4, 0)\n        };\n        Coordinates result = BezierCurve.getBezierPoint(0.5, points);\n        assertEquals(2.0, result.x, 0.001);\n        assertEquals(1.5, result.y, 0.001);\n    }\n\n    // Test case 4: Test with single point (edge case)\n    @Test\n    public void testSingleControlPoint() {\n        Coordinates[] points = { new Coordinates(5, 5) };\n        Coordinates result = BezierCurve.getBezierPoint(0.5, points);\n        assertEquals(5.0, result.x, 0.001);\n        assertEquals(5.0, result.y, 0.001);\n    }\n\n    // Test case 5: Test with extreme t value (0)\n    @Test\n    public void testExtremeTValueZero() {\n        Coordinates[] points = {\n            new Coordinates(0, 0),\n            new Coordinates(5, 5)\n        };\n        Coordinates result = BezierCurve.getBezierPoint(0, points);\n        assertEquals(0.0, result.x, 0.001);\n        assertEquals(0.0, result.y, 0.001);\n    }\n\n    // Test case 6: Test with extreme t value (1)\n    @Test\n    public void testExtremeTValueOne() {\n        Coordinates[] points = {\n            new Coordinates(0, 0),\n            new Coordinates(5, 5)\n        };\n        Coordinates result = BezierCurve.getBezierPoint(1, points);\n        assertEquals(5.0, result.x, 0.001);\n        assertEquals(5.0, result.y, 0.001);\n    }\n}package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    // Test case 1: Test with a simple linear curve\n    @Test\n    public void testMidpointOfTwoPoints() {\n        Coordinates[] points = { new Coordinates(0, 0), new Coordinates(2, 2) };\n        Coordinates result = BezierCurve.getBezierPoint(0.5, points);\n        assertEquals(1.0, result.x, 0.001);\n        assertEquals(1.0, result.y, 0.001);\n    }\n\n    // Test case 2: Test with three points (quadratic curve)\n    @Test\n    public void testQuadraticBezierCurve() {\n        Coordinates[] points = {\n            new Coordinates(0, 0),\n            new Coordinates(1, 2),\n            new Coordinates(2, 0)\n        };\n        Coordinates result = BezierCurve.getBezierPoint(0.5, points);\n        assertEquals(1.0, result.x, 0.001);\n        assertEquals(1.0, result.y, 0.001);\n    }\n\n    // Test case 3: Test with four points (cubic curve)\n    @Test\n    public void testCubicBezierCurve() {\n        Coordinates[] points = {\n            new Coordinates(0, 0),\n            new Coordinates(1, 3),\n            new Coordinates(3, 1),\n            new Coordinates(4, 0)\n        };\n        Coordinates result = BezierCurve.getBezierPoint(0.5, points);\n        assertEquals(2.0, result.x, 0.001);\n        assertEquals(1.5, result.y, 0.001);\n    }\n\n    // Test case 4: Test with single point (edge case)\n    @Test\n    public void testSingleControlPoint() {\n        Coordinates[] points = { new Coordinates(5, 5) };\n        Coordinates result = BezierCurve.getBezierPoint(0.5, points);\n        assertEquals(5.0, result.x, 0.001);\n        assertEquals(5.0, result.y, 0.001);\n    }\n\n    // Test case 5: Test with extreme t value (0)\n    @Test\n    public void testExtremeTValueZero() {\n        Coordinates[] points = {\n            new Coordinates(0, 0),\n            new Coordinates(5, 5)\n        };\n        Coordinates result = BezierCurve.getBezierPoint(0, points);\n        assertEquals(0.0, result.x, 0.001);\n        assertEquals(0.0, result.y, 0.001);\n    }\n\n    // Test case 6: Test with extreme t value (1)\n    @Test\n    public void testExtremeTValueOne() {\n        Coordinates[] points = {\n            new Coordinates(0, 0),\n            new Coordinates(5, 5)\n        };\n        Coordinates result = BezierCurve.getBezierPoint(1, points);\n        assertEquals(5.0, result.x, 0.001);\n        assertEquals(5.0, result.y, 0.001);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n *\n * @param t - A value between 0 and 1 representing the interpolation parameter.\n * @param points - An array of control points defining the B\u00e9zier curve.\n * @return The calculated Coordinates at the given parameter t.\n */\nstatic class Coordinates {\n    double x;\n    double y;\n\n    Coordinates(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\npublic static Coordinates getBezierPoint(double t, Coordinates[] points) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 566, "code_type": "method", "original_language": "typescript", "question_type": "Algorithm and data structure", "summary": "Checks if two timestamps correspond to the same day.", "language_version_list": {"python": {"code_signature": "def is_same_day(timestamp1: int, timestamp2: int) -> bool:\n    \"\"\"\n    Checks if two timestamps correspond to the same day.\n\n    Args:\n        timestamp1 (int): The first timestamp to compare.\n        timestamp2 (int): The second timestamp to compare.\n\n    Returns:\n        bool: True if both timestamps are on the same day;\n              False otherwise.\n    \"\"\"", "test_code": "import unittest\nfrom datetime import datetime\n\n\nclass TestIsSameDay(unittest.TestCase):\n\n    def test_different_days(self):\n        timestamp1 = int(datetime(2024, 10, 1, 10, 0, 0).timestamp())  # October 1, 2024, 10:00 AM UTC\n        timestamp2 = int(datetime(2024, 10, 2, 10, 0, 0).timestamp())  # October 2, 2024, 10:00 AM UTC\n        self.assertFalse(is_same_day(timestamp1, timestamp2))\n\n    def test_same_day_different_times(self):\n        timestamp1 = int(datetime(2024, 10, 1, 0, 0, 0).timestamp())  # October 1, 2024, 12:00 AM UTC\n        timestamp2 = int(datetime(2024, 10, 1, 12, 30, 0).timestamp())  # October 1, 2024, 12:30 PM UTC\n        self.assertTrue(is_same_day(timestamp1, timestamp2))\n\n    def test_same_day_different_time_zones(self):\n        timestamp1 = int(datetime(2024, 10, 1, 10, 0, 0).timestamp())  # UTC\n        timestamp2 = int(datetime.fromisoformat('2024-10-01T12:00:00+02:00').timestamp())  # October 1, 2024, 12:00 PM UTC+2\n        self.assertTrue(is_same_day(timestamp1, timestamp2))\n\n    def test_midnight_same_day(self):\n        timestamp1 = int(datetime(2024, 10, 1, 0, 0, 0).timestamp())  # October 1, 2024, 12:00 AM UTC\n        timestamp2 = int(datetime(2024, 10, 1, 0, 0, 0).timestamp())  # Same timestamp\n        self.assertTrue(is_same_day(timestamp1, timestamp2))\n\n    def test_different_years(self):\n        timestamp1 = int(datetime(2023, 10, 1, 10, 0, 0).timestamp())  # October 1, 2023, 10:00 AM UTC\n        timestamp2 = int(datetime(2024, 10, 1, 10, 0, 0).timestamp())  # October 1, 2024, 10:00 AM UTC\n        self.assertFalse(is_same_day(timestamp1, timestamp2))\n", "prompt": "please write a python function , the function signature as below def is_same_day(timestamp1: int, timestamp2: int) -> bool:\n    \"\"\"\n    Checks if two timestamps correspond to the same day.\n\n    Args:\n        timestamp1 (int): The first timestamp to compare.\n        timestamp2 (int): The second timestamp to compare.\n\n    Returns:\n        bool: True if both timestamps are on the same day;\n              False otherwise.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Checks if two timestamps correspond to the same day.\n *\n * @param timestamp1 - The first timestamp to compare.\n * @param timestamp2 - The second timestamp to compare.\n * @returns True if both timestamps are on the same day, false otherwise.\n */\nfunction isSameDay(timestamp1, timestamp2) {\n    // Convert timestamps to Date objects\n    const date1 = new Date(timestamp1);\n    const date2 = new Date(timestamp2);\n\n    // Compare the year, month, and date of both Date objects\n    return (\n        date1.getFullYear() === date2.getFullYear() &&\n        date1.getMonth() === date2.getMonth() &&\n        date1.getDate() === date2.getDate()\n    );\n}", "test_code": "describe('isSameDay', () => {\n    test('should return false for timestamps on different days', () => {\n        const timestamp1 = new Date(Date.UTC(2024, 9, 1, 10, 0, 0)).getTime(); // October 1, 2024, 10:00 AM UTC\n        const timestamp2 = new Date(Date.UTC(2024, 9, 2, 10, 0, 0)).getTime(); // October 2, 2024, 10:00 AM UTC\n        expect(isSameDay(timestamp1, timestamp2)).toBe(false);\n    });\n\n    test('should return true for timestamps on the same day but different times', () => {\n        const timestamp1 = new Date(Date.UTC(2024, 9, 1, 0, 0, 0)).getTime(); // October 1, 2024, 12:00 AM UTC\n        const timestamp2 = new Date(Date.UTC(2024, 9, 1, 12, 30, 0)).getTime(); // October 1, 2024, 12:30 PM UTC\n        expect(isSameDay(timestamp1, timestamp2)).toBe(true);\n    });\n\n    test('should return true for timestamps on the same day in different time zones', () => {\n        const timestamp1 = new Date(Date.UTC(2024, 9, 1, 10, 0, 0)).getTime(); // UTC\n        const timestamp2 = new Date('2024-10-01T12:00:00+02:00').getTime(); // October 1, 2024, 12:00 PM UTC+2\n        expect(isSameDay(timestamp1, timestamp2)).toBe(true);\n    });\n\n    test('should return true for timestamps at midnight on the same day', () => {\n        const timestamp1 = new Date(Date.UTC(2024, 9, 1, 0, 0, 0)).getTime(); // October 1, 2024, 12:00 AM UTC\n        const timestamp2 = new Date(Date.UTC(2024, 9, 1, 0, 0, 0)).getTime(); // Same timestamp\n        expect(isSameDay(timestamp1, timestamp2)).toBe(true);\n    });\n\n    test('should return false for timestamps in different years', () => {\n        const timestamp1 = new Date(Date.UTC(2023, 9, 1, 10, 0, 0)).getTime(); // October 1, 2023, 10:00 AM UTC\n        const timestamp2 = new Date(Date.UTC(2024, 9, 1, 10, 0, 0)).getTime(); // October 1, 2024, 10:00 AM UTC\n        expect(isSameDay(timestamp1, timestamp2)).toBe(false);\n    });\n\n    test('should return false for invalid timestamps', () => {\n        const timestamp1 = new Date('invalid').getTime(); // Invalid timestamp\n        const timestamp2 = new Date(Date.UTC(2024, 9, 1, 10, 0, 0)).getTime(); // Valid timestamp\n        expect(isSameDay(timestamp1, timestamp2)).toBe(false);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Checks if two timestamps correspond to the same day.\n *\n * @param timestamp1 - The first timestamp to compare.\n * @param timestamp2 - The second timestamp to compare.\n * @returns True if both timestamps are on the same day, false otherwise.\n */\nfunction isSameDay(timestamp1, timestamp2) {\n    // Convert timestamps to Date objects\n    const date1 = new Date(timestamp1);\n    const date2 = new Date(timestamp2);\n\n    // Compare the year, month, and date of both Date objects\n    return (\n        date1.getFullYear() === date2.getFullYear() &&\n        date1.getMonth() === date2.getMonth() &&\n        date1.getDate() === date2.getDate()\n    );\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Checks if two timestamps correspond to the same day.\n *\n * @param timestamp1 - The first timestamp to compare.\n * @param timestamp2 - The second timestamp to compare.\n * @returns True if both timestamps are on the same day, false otherwise.\n */\nfunction isSameDay(timestamp1: number, timestamp2: number): boolean {\n}", "test_code": "describe('isSameDay', () => {\n    test('should return false for timestamps on different days', () => {\n        const timestamp1 = new Date(Date.UTC(2024, 9, 1, 10, 0, 0)).getTime(); // October 1, 2024, 10:00 AM UTC\n        const timestamp2 = new Date(Date.UTC(2024, 9, 2, 10, 0, 0)).getTime(); // October 2, 2024, 10:00 AM UTC\n        expect(isSameDay(timestamp1, timestamp2)).toBe(false);\n    });\n\n    test('should return true for timestamps on the same day but different times', () => {\n        const timestamp1 = new Date(Date.UTC(2024, 9, 1, 0, 0, 0)).getTime(); // October 1, 2024, 12:00 AM UTC\n        const timestamp2 = new Date(Date.UTC(2024, 9, 1, 12, 30, 0)).getTime(); // October 1, 2024, 12:30 PM UTC\n        expect(isSameDay(timestamp1, timestamp2)).toBe(true);\n    });\n\n    test('should return true for timestamps on the same day in different time zones', () => {\n        const timestamp1 = new Date(Date.UTC(2024, 9, 1, 10, 0, 0)).getTime(); // UTC\n        const timestamp2 = new Date('2024-10-01T12:00:00+02:00').getTime(); // October 1, 2024, 12:00 PM UTC+2\n        expect(isSameDay(timestamp1, timestamp2)).toBe(true);\n    });\n\n    test('should return true for timestamps at midnight on the same day', () => {\n        const timestamp1 = new Date(Date.UTC(2024, 9, 1, 0, 0, 0)).getTime(); // October 1, 2024, 12:00 AM UTC\n        const timestamp2 = new Date(Date.UTC(2024, 9, 1, 0, 0, 0)).getTime(); // Same timestamp\n        expect(isSameDay(timestamp1, timestamp2)).toBe(true);\n    });\n\n\n    test('should return false for timestamps in different years', () => {\n        const timestamp1 = new Date(Date.UTC(2023, 9, 1, 10, 0, 0)).getTime(); // October 1, 2023, 10:00 AM UTC\n        const timestamp2 = new Date(Date.UTC(2024, 9, 1, 10, 0, 0)).getTime(); // October 1, 2024, 10:00 AM UTC\n        expect(isSameDay(timestamp1, timestamp2)).toBe(false);\n    });\n\n    test('should return false for invalid timestamps', () => {\n        const timestamp1 = new Date('invalid').getTime(); // Invalid timestamp\n        const timestamp2 = new Date(Date.UTC(2024, 9, 1, 10, 0, 0)).getTime(); // Valid timestamp\n        expect(isSameDay(timestamp1, timestamp2)).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Checks if two timestamps correspond to the same day.\n *\n * @param timestamp1 - The first timestamp to compare.\n * @param timestamp2 - The second timestamp to compare.\n * @returns True if both timestamps are on the same day, false otherwise.\n */\nfunction isSameDay(timestamp1: number, timestamp2: number): boolean {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Checks if two timestamps correspond to the same day.\n *\n * @param timestamp1 - The first timestamp to compare.\n * @param timestamp2 - The second timestamp to compare.\n * @returns True if both timestamps are on the same day, false otherwise.\n */\nbool isSameDay(std::time_t timestamp1, std::time_t timestamp2) {\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <ctime>\n\n// Function declaration (assuming it is defined elsewhere)\nbool isSameDay(std::time_t timestamp1, std::time_t timestamp2);\n\nTEST_CASE(\"isSameDay\", \"[timestamp]\") {\n    SECTION(\"should return false for timestamps on different days\") {\n        std::time_t timestamp1 = std::mktime(new std::tm{0, 0, 10, 1, 9, 124}); // October 1, 2024, 10:00 AM UTC\n        std::time_t timestamp2 = std::mktime(new std::tm{0, 0, 10, 2, 9, 124}); // October 2, 2024, 10:00 AM UTC\n        REQUIRE(isSameDay(timestamp1, timestamp2) == false);\n    }\n\n    SECTION(\"should return true for timestamps on the same day but different times\") {\n        std::time_t timestamp1 = std::mktime(new std::tm{0, 0, 0, 1, 9, 124}); // October 1, 2024, 12:00 AM UTC\n        std::time_t timestamp2 = std::mktime(new std::tm{0, 30, 12, 1, 9, 124}); // October 1, 2024, 12:30 PM UTC\n        REQUIRE(isSameDay(timestamp1, timestamp2) == true);\n    }\n\n    SECTION(\"should return true for timestamps on the same day in different time zones\") {\n        std::time_t timestamp1 = std::mktime(new std::tm{0, 0, 10, 1, 9, 124}); // UTC\n        std::tm tm = {0};\n        tm.tm_year = 124; // Year 2024\n        tm.tm_mon = 9;    // October\n        tm.tm_mday = 1;   // 1st\n        tm.tm_hour = 12;  // 12 PM\n        tm.tm_min = 0;\n        tm.tm_sec = 0;\n        tm.tm_isdst = 0;  // Not daylight saving time\n        std::time_t timestamp2 = std::mktime(&tm) + 2 * 3600; // UTC+2\n        REQUIRE(isSameDay(timestamp1, timestamp2) == true);\n    }\n\n    SECTION(\"should return true for timestamps at midnight on the same day\") {\n        std::time_t timestamp1 = std::mktime(new std::tm{0, 0, 0, 1, 9, 124}); // October 1, 2024, 12:00 AM UTC\n        std::time_t timestamp2 = std::mktime(new std::tm{0, 0, 0, 1, 9, 124}); // Same timestamp\n        REQUIRE(isSameDay(timestamp1, timestamp2) == true);\n    }\n\n    SECTION(\"should return false for timestamps in different years\") {\n        std::time_t timestamp1 = std::mktime(new std::tm{0, 0, 10, 1, 9, 123}); // October 1, 2023, 10:00 AM UTC\n        std::time_t timestamp2 = std::mktime(new std::tm{0, 0, 10, 1, 9, 124}); // October 1, 2024, 10:00 AM UTC\n        REQUIRE(isSameDay(timestamp1, timestamp2) == false);\n    }\n\n    SECTION(\"should return false for invalid timestamps\") {\n        std::time_t timestamp1 = -1; // Invalid timestamp\n        std::time_t timestamp2 = std::mktime(new std::tm{0, 0, 10, 1, 9, 124}); // Valid timestamp\n        REQUIRE(isSameDay(timestamp1, timestamp2) == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Checks if two timestamps correspond to the same day.\n *\n * @param timestamp1 - The first timestamp to compare.\n * @param timestamp2 - The second timestamp to compare.\n * @returns True if both timestamps are on the same day, false otherwise.\n */\nbool isSameDay(std::time_t timestamp1, std::time_t timestamp2) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks if two timestamps correspond to the same day.\n *\n * @param timestamp1 - The first timestamp to compare.\n * @param timestamp2 - The second timestamp to compare.\n * @return True if both timestamps are on the same day, false otherwise.\n */\npublic static boolean isSameDay(long timestamp1, long timestamp2) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void testDifferentDays() {\n        long timestamp1 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 1, 10, 0, 0)).getTime(); // October 1, 2024, 10:00 AM UTC\n        long timestamp2 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 2, 10, 0, 0)).getTime(); // October 2, 2024, 10:00 AM UTC\n        assertFalse(isSameDay(timestamp1, timestamp2));\n    }\n\n    @Test\n    public void testSameDayDifferentTimes() {\n        long timestamp1 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 1, 0, 0, 0)).getTime(); // October 1, 2024, 12:00 AM UTC\n        long timestamp2 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 1, 12, 30, 0)).getTime(); // October 1, 2024, 12:30 PM UTC\n        assertTrue(isSameDay(timestamp1, timestamp2));\n    }\n\n    @Test\n    public void testSameDayDifferentTimeZones() {\n        long timestamp1 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 1, 10, 0, 0)).getTime(); // UTC\n        long timestamp2 = java.util.Date.parse(\"2024-10-01T12:00:00+02:00\"); // October 1, 2024, 12:00 PM UTC+2\n        assertTrue(isSameDay(timestamp1, timestamp2));\n    }\n\n    @Test\n    public void testMidnightSameDay() {\n        long timestamp1 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 1, 0, 0, 0)).getTime(); // October 1, 2024, 12:00 AM UTC\n        long timestamp2 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 1, 0, 0, 0)).getTime(); // Same timestamp\n        assertTrue(isSameDay(timestamp1, timestamp2));\n    }\n\n    @Test\n    public void testDifferentYears() {\n        long timestamp1 = new java.util.Date(java.util.Date.UTC(2023 - 1900, 9, 1, 10, 0, 0)).getTime(); // October 1, 2023, 10:00 AM UTC\n        long timestamp2 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 1, 10, 0, 0)).getTime(); // October 1, 2024, 10:00 AM UTC\n        assertFalse(isSameDay(timestamp1, timestamp2));\n    }\n\n    @Test\n    public void testInvalidTimestamps() {\n        long timestamp1 = new java.util.Date(\"invalid\").getTime(); // Invalid timestamp\n        long timestamp2 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 1, 10, 0, 0)).getTime(); // Valid timestamp\n        assertFalse(isSameDay(timestamp1, timestamp2));\n    }\n\n    // Assuming isSameDay method is defined elsewhere in this class\n    public static boolean isSameDay(long timestamp1, long timestamp2) {\n        // Implement the isSameDay method logic here\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks if two timestamps correspond to the same day.\n *\n * @param timestamp1 - The first timestamp to compare.\n * @param timestamp2 - The second timestamp to compare.\n * @return True if both timestamps are on the same day, false otherwise.\n */\npublic static boolean isSameDay(long timestamp1, long timestamp2) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 567, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Returns a string of relative times, based on when the given message was created. If the message was created Today: Return \"Today\".\nIf the message was created Yesterday: return \"Yesterday\".\nIf the message was created within the past week but not today or yesterday: Return the corresponding day of the week.\nIf the message was created earlier than one week ago: Return the formatted date string", "language_version_list": {"python": {"code_signature": "from datetime import datetime\n\n\ndef get_relative_time(message_date: datetime) -> str:\n    \"\"\"\n    Returns a string representing the relative time since the given message was created.\n\n    - If the message was created today, it returns \"Today\".\n    - If the message was created yesterday, it returns \"Yesterday\".\n    - If the message was created within the past week (but not today or yesterday),\n      it returns the corresponding day of the week (e.g., \"Monday\").\n    - If the message was created earlier than one week ago, it returns a formatted date string\n      (e.g., \"YYYY/MM/DD\").\n\n    Args:\n        message_date (datetime): The date when the message was created. This should be a valid datetime object.\n\n    Returns:\n        str: A string indicating the relative time from the current date to the message creation date.\n    \"\"\"", "test_code": "import unittest\nfrom datetime import datetime, timedelta\nfrom unittest.mock import patch\n\n\nclass TestGetRelativeTime(unittest.TestCase):\n\n    @patch('datetime.datetime')\n    def setUp(self, mock_datetime):\n        # Mock the current date to ensure consistent test results\n        self.mock_now = datetime(2024, 10, 1)\n        mock_datetime.now.return_value = self.mock_now\n\n    def test_should_return_today_for_a_message_created_today(self):\n        message_date = datetime.now()  # Current date\n        self.assertEqual(get_relative_time(message_date), \"Today\")\n\n    def test_should_return_yesterday_for_a_message_created_yesterday(self):\n        message_date = datetime.now() - timedelta(days=1)  # Yesterday\n        self.assertEqual(get_relative_time(message_date), \"Yesterday\")\n\n    def test_should_return_formatted_date_string_for_a_message_created_10_days_ago(self):\n        message_date = datetime.now() - timedelta(days=10)  # 10 days ago\n        self.assertEqual(get_relative_time(message_date), \"2024/09/21\")  # Adjust based on the mock date\n\n    def test_should_return_formatted_date_string_for_a_message_created_15_days_ago(self):\n        message_date = datetime.now() - timedelta(days=15)  # 15 days ago\n        self.assertEqual(get_relative_time(message_date), \"2024/09/16\")  # Adjust based on the mock date\n", "prompt": "please write a python function , the function signature as below from datetime import datetime\n\n\ndef get_relative_time(message_date: datetime) -> str:\n    \"\"\"\n    Returns a string representing the relative time since the given message was created.\n\n    - If the message was created today, it returns \"Today\".\n    - If the message was created yesterday, it returns \"Yesterday\".\n    - If the message was created within the past week (but not today or yesterday),\n      it returns the corresponding day of the week (e.g., \"Monday\").\n    - If the message was created earlier than one week ago, it returns a formatted date string\n      (e.g., \"YYYY/MM/DD\").\n\n    Args:\n        message_date (datetime): The date when the message was created. This should be a valid datetime object.\n\n    Returns:\n        str: A string indicating the relative time from the current date to the message creation date.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Returns a string representing the relative time since the given message was created.\n *\n * - If the message was created today, it returns \"Today\".\n * - If the message was created yesterday, it returns \"Yesterday\".\n * - If the message was created within the past week (but not today or yesterday),\n *   it returns the corresponding day of the week (e.g., \"Monday\").\n * - If the message was created earlier than one week ago, it returns a formatted date string\n *   (e.g., \"YYYY/MM/DD\").\n *\n * @param messageDate - The date when the message was created. This should be a valid Date object.\n * @returns A string indicating the relative time from the current date to the message creation date.\n */\nfunction getRelativeTime(messageDate) {\n}", "test_code": "describe('getRelativeTime', () => {\n    beforeAll(() => {\n        // Mock the current date to ensure consistent test results\n        jest.useFakeTimers().setSystemTime(new Date('2024-10-01'));\n    });\n\n    afterAll(() => {\n        jest.useRealTimers();\n    });\n\n    test('should return \"Today\" for a message created today', () => {\n        const messageDate = new Date(); // Current date\n        expect(getRelativeTime(messageDate)).toBe(\"Today\");\n    });\n\n    test('should return \"Yesterday\" for a message created yesterday', () => {\n        const messageDate = new Date(Date.now() - 1000 * 60 * 60 * 24); // Yesterday\n        expect(getRelativeTime(messageDate)).toBe(\"Yesterday\");\n    });\n\n    test('should return formatted date string for a message created 10 days ago', () => {\n        const messageDate = new Date(Date.now() - 1000 * 60 * 60 * 24 * 10); // 10 days ago\n        expect(getRelativeTime(messageDate)).toBe(\"2024/09/21\"); // Adjust based on the mock date\n    });\n\n    test('should return formatted date string for a message created 15 days ago', () => {\n        const messageDate = new Date(Date.now() - 1000 * 60 * 60 * 24 * 15); // 15 days ago\n        expect(getRelativeTime(messageDate)).toBe(\"2024/09/16\"); // Adjust based on the mock date\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Returns a string representing the relative time since the given message was created.\n *\n * - If the message was created today, it returns \"Today\".\n * - If the message was created yesterday, it returns \"Yesterday\".\n * - If the message was created within the past week (but not today or yesterday),\n *   it returns the corresponding day of the week (e.g., \"Monday\").\n * - If the message was created earlier than one week ago, it returns a formatted date string\n *   (e.g., \"YYYY/MM/DD\").\n *\n * @param messageDate - The date when the message was created. This should be a valid Date object.\n * @returns A string indicating the relative time from the current date to the message creation date.\n */\nfunction getRelativeTime(messageDate) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Returns a string representing the relative time since the given message was created.\n *\n * - If the message was created today, it returns \"Today\".\n * - If the message was created yesterday, it returns \"Yesterday\".\n * - If the message was created within the past week (but not today or yesterday),\n *   it returns the corresponding day of the week (e.g., \"Monday\").\n * - If the message was created earlier than one week ago, it returns a formatted date string\n *   (e.g., \"YYYY/MM/DD\").\n *\n * @param messageDate - The date when the message was created. This should be a valid Date object.\n * @returns A string indicating the relative time from the current date to the message creation date.\n */\nfunction getRelativeTime(messageDate: Date): string {\n}", "test_code": "describe('getRelativeTime', () => {\n    beforeAll(() => {\n        // Mock the current date to ensure consistent test results\n        jest.useFakeTimers().setSystemTime(new Date('2024-10-01'));\n    });\n\n    afterAll(() => {\n        jest.useRealTimers();\n    });\n\n    test('should return \"Today\" for a message created today', () => {\n        const messageDate = new Date(); // Current date\n        expect(getRelativeTime(messageDate)).toBe(\"Today\");\n    });\n\n    test('should return \"Yesterday\" for a message created yesterday', () => {\n        const messageDate = new Date(Date.now() - 1000 * 60 * 60 * 24); // Yesterday\n        expect(getRelativeTime(messageDate)).toBe(\"Yesterday\");\n    });\n\n    test('should return formatted date string for a message created 10 days ago', () => {\n        const messageDate = new Date(Date.now() - 1000 * 60 * 60 * 24 * 10); // 10 days ago\n        expect(getRelativeTime(messageDate)).toBe(\"2024/09/21\"); // Adjust based on the mock date\n    });\n\n    test('should return formatted date string for a message created 15 days ago', () => {\n        const messageDate = new Date(Date.now() - 1000 * 60 * 60 * 24 * 15); // 15 days ago\n        expect(getRelativeTime(messageDate)).toBe(\"2024/09/16\"); // Adjust based on the mock date\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Returns a string representing the relative time since the given message was created.\n *\n * - If the message was created today, it returns \"Today\".\n * - If the message was created yesterday, it returns \"Yesterday\".\n * - If the message was created within the past week (but not today or yesterday),\n *   it returns the corresponding day of the week (e.g., \"Monday\").\n * - If the message was created earlier than one week ago, it returns a formatted date string\n *   (e.g., \"YYYY/MM/DD\").\n *\n * @param messageDate - The date when the message was created. This should be a valid Date object.\n * @returns A string indicating the relative time from the current date to the message creation date.\n */\nfunction getRelativeTime(messageDate: Date): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Returns a string representing the relative time since the given message was created.\n *\n * - If the message was created today, it returns \"Today\".\n * - If the message was created yesterday, it returns \"Yesterday\".\n * - If the message was created within the past week (but not today or yesterday),\n *   it returns the corresponding day of the week (e.g., \"Monday\").\n * - If the message was created earlier than one week ago, it returns a formatted date string\n *   (e.g., \"YYYY/MM/DD\").\n *\n * @param messageDate - The date when the message was created. This should be a valid time_point.\n * @returns A string indicating the relative time from the current date to the message creation date.\n */\nstd::string getRelativeTime(const std::chrono::system_clock::time_point& messageDate){\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <chrono>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Assuming getRelativeTime is defined elsewhere\nstd::string getRelativeTime(const std::chrono::system_clock::time_point& messageDate);\n\nTEST_CASE(\"getRelativeTime\", \"[time]\") {\n    // Mock the current date\n    auto mockNow = std::chrono::system_clock::time_point(std::chrono::seconds(1729468800)); // 2024-10-01\n\n    SECTION(\"should return 'Today' for a message created today\") {\n        auto messageDate = mockNow; // Current date\n        REQUIRE(getRelativeTime(messageDate) == \"Today\");\n    }\n\n    SECTION(\"should return 'Yesterday' for a message created yesterday\") {\n        auto messageDate = mockNow - std::chrono::hours(24); // Yesterday\n        REQUIRE(getRelativeTime(messageDate) == \"Yesterday\");\n    }\n\n    SECTION(\"should return formatted date string for a message created 10 days ago\") {\n        auto messageDate = mockNow - std::chrono::hours(24 * 10); // 10 days ago\n        REQUIRE(getRelativeTime(messageDate) == \"2024/09/21\"); // Adjust based on the mock date\n    }\n\n    SECTION(\"should return formatted date string for a message created 15 days ago\") {\n        auto messageDate = mockNow - std::chrono::hours(24 * 15); // 15 days ago\n        REQUIRE(getRelativeTime(messageDate) == \"2024/09/16\"); // Adjust based on the mock date\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Returns a string representing the relative time since the given message was created.\n *\n * - If the message was created today, it returns \"Today\".\n * - If the message was created yesterday, it returns \"Yesterday\".\n * - If the message was created within the past week (but not today or yesterday),\n *   it returns the corresponding day of the week (e.g., \"Monday\").\n * - If the message was created earlier than one week ago, it returns a formatted date string\n *   (e.g., \"YYYY/MM/DD\").\n *\n * @param messageDate - The date when the message was created. This should be a valid time_point.\n * @returns A string indicating the relative time from the current date to the message creation date.\n */\nstd::string getRelativeTime(const std::chrono::system_clock::time_point& messageDate){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Returns a string representing the relative time since the given message was created.\n *\n * - If the message was created today, it returns \"Today\".\n * - If the message was created yesterday, it returns \"Yesterday\".\n * - If the message was created within the past week (but not today or yesterday),\n *   it returns the corresponding day of the week (e.g., \"Monday\").\n * - If the message was created earlier than one week ago, it returns a formatted date string\n *   (e.g., \"YYYY/MM/DD\").\n *\n * @param messageDate - The date when the message was created. This should be a valid Date object.\n * @returns A string indicating the relative time from the current date to the message creation date.\n */\npublic static String getRelativeTime(Date messageDate) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    private final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy/MM/dd\");\n\n    @Before\n    public void setUp() {\n        // Mock the current date to ensure consistent test results\n        // (In Java, we will just set a fixed date in the test cases)\n    }\n\n    @After\n    public void tearDown() {\n        // No specific teardown needed\n    }\n\n    @Test\n    public void testToday() {\n        Date messageDate = new Date(); // Current date\n        assertEquals(\"Today\", DateUtils.getRelativeTime(messageDate));\n    }\n\n    @Test\n    public void testYesterday() {\n        Date messageDate = new Date(System.currentTimeMillis() - 1000 * 60 * 60 * 24); // Yesterday\n        assertEquals(\"Yesterday\", DateUtils.getRelativeTime(messageDate));\n    }\n\n    @Test\n    public void testTenDaysAgo() {\n        Date messageDate = new Date(System.currentTimeMillis() - 1000 * 60 * 60 * 24 * 10); // 10 days ago\n        assertEquals(\"2024/09/21\", DateUtils.getRelativeTime(messageDate)); // Adjust based on the mock date\n    }\n\n    @Test\n    public void testFifteenDaysAgo() {\n        Date messageDate = new Date(System.currentTimeMillis() - 1000 * 60 * 60 * 24 * 15); // 15 days ago\n        assertEquals(\"2024/09/16\", DateUtils.getRelativeTime(messageDate)); // Adjust based on the mock date\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Returns a string representing the relative time since the given message was created.\n *\n * - If the message was created today, it returns \"Today\".\n * - If the message was created yesterday, it returns \"Yesterday\".\n * - If the message was created within the past week (but not today or yesterday),\n *   it returns the corresponding day of the week (e.g., \"Monday\").\n * - If the message was created earlier than one week ago, it returns a formatted date string\n *   (e.g., \"YYYY/MM/DD\").\n *\n * @param messageDate - The date when the message was created. This should be a valid Date object.\n * @returns A string indicating the relative time from the current date to the message creation date.\n */\npublic static String getRelativeTime(Date messageDate) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 569, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Compresses a string to ensure its length does not exceed the specified maximum length.\nIf the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").", "language_version_list": {"python": {"code_signature": "def compress_string(input: str, max_length: int = 18) -> str:\n    \"\"\"\n    Compresses a string to ensure its length does not exceed the specified maximum length.\n    If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n\n    Args:\n        input (str): The string to be compressed.\n        max_length (int, optional): The maximum allowed length of the string (default is 18).\n\n    Returns:\n        str: A compressed string that does not exceed the specified length.\n             If truncation occurs, an ellipsis (\"...\") is appended.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCompressString(unittest.TestCase):\n    def test_short_string(self):\n        \"\"\" should return the original string if it is shorter than the max length \"\"\"\n        input_str = \"Short string\"\n        result = compress_string(input_str)\n        self.assertEqual(result, input_str)\n\n    def test_exact_length_string(self):\n        \"\"\" should return the original string if it is exactly equal to the max length \"\"\"\n        input_str = \"Exactly 18 chars\"\n        result = compress_string(input_str)\n        self.assertEqual(result, input_str)\n\n    def test_truncate_long_string(self):\n        \"\"\" should truncate the string and append \"...\" if it exceeds the max length \"\"\"\n        input_str = \"This is a long string that needs to be compressed.\"\n        result = compress_string(input_str)\n        self.assertEqual(result, \"This is a long ...\")\n\n    def test_truncate_with_custom_max_length(self):\n        \"\"\" should truncate the string to maxLength - 3 and append \"...\" when maxLength is specified \"\"\"\n        input_str = \"Another long string that is definitely too long.\"\n        result = compress_string(input_str, 25)\n        self.assertEqual(result, \"Another long string th...\")\n\n    def test_default_max_length(self):\n        \"\"\" should use default max length of 18 if no maxLength is provided \"\"\"\n        input_str = \"This string is way too long.\"\n        result = compress_string(input_str)\n        self.assertEqual(result, \"This string is ...\")\n\n    def test_empty_string(self):\n        \"\"\" should return the original string if it is empty \"\"\"\n        input_str = \"\"\n        result = compress_string(input_str)\n        self.assertEqual(result, input_str)\n", "prompt": "please write a python function , the function signature as below def compress_string(input: str, max_length: int = 18) -> str:\n    \"\"\"\n    Compresses a string to ensure its length does not exceed the specified maximum length.\n    If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n\n    Args:\n        input (str): The string to be compressed.\n        max_length (int, optional): The maximum allowed length of the string (default is 18).\n\n    Returns:\n        str: A compressed string that does not exceed the specified length.\n             If truncation occurs, an ellipsis (\"...\") is appended.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Compresses a string to ensure its length does not exceed the specified maximum length.\n * If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n *\n * @param input - The string to be compressed.\n * @param maxLength - The maximum allowed length of the string (default is 18).\n * @returns A compressed string that does not exceed the specified length.\n */\nfunction compressString(input, maxLength = 18) {\n    // Function implementation goes here\n}", "test_code": "describe('compressString', () => {\n    it('should return the original string if it is shorter than the max length', () => {\n        const input = \"Short string\";\n        const result = compressString(input);\n        expect(result).toBe(input);\n    });\n\n    it('should return the original string if it is exactly equal to the max length', () => {\n        const input = \"Exactly 18 chars\";\n        const result = compressString(input);\n        expect(result).toBe(input);\n    });\n\n    it('should truncate the string and append \"...\" if it exceeds the max length', () => {\n        const input = \"This is a long string that needs to be compressed.\";\n        const result = compressString(input);\n        expect(result).toBe(\"This is a long ...\");\n    });\n\n    it('should truncate the string to maxLength - 3 and append \"...\" when maxLength is specified', () => {\n        const input = \"Another long string that is definitely too long.\";\n        const result = compressString(input, 25);\n        expect(result).toBe(\"Another long string th...\");\n    });\n\n    it('should use default max length of 18 if no maxLength is provided', () => {\n        const input = \"This string is way too long.\";\n        const result = compressString(input);\n        expect(result).toBe(\"This string is ...\");\n    });\n\n    it('should return the original string if it is empty', () => {\n        const input = \"\";\n        const result = compressString(input);\n        expect(result).toBe(input);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Compresses a string to ensure its length does not exceed the specified maximum length.\n * If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n *\n * @param input - The string to be compressed.\n * @param maxLength - The maximum allowed length of the string (default is 18).\n * @returns A compressed string that does not exceed the specified length.\n */\nfunction compressString(input, maxLength = 18) {\n    // Function implementation goes here\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Compresses a string to ensure its length does not exceed the specified maximum length.\n * If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n *\n * @param input - The string to be compressed.\n * @param maxLength - The maximum allowed length of the string (default is 18).\n * @returns A compressed string that does not exceed the specified length.\n */\nfunction compressString(input: string, maxLength: number = 18): string {\n}", "test_code": "describe('compressString', () => {\n    it('should return the original string if it is shorter than the max length', () => {\n        const input = \"Short string\";\n        const result = compressString(input);\n        expect(result).toBe(input);\n    });\n\n    it('should return the original string if it is exactly equal to the max length', () => {\n        const input = \"Exactly 18 chars\";\n        const result = compressString(input);\n        expect(result).toBe(input);\n    });\n\n    it('should truncate the string and append \"...\" if it exceeds the max length', () => {\n        const input = \"This is a long string that needs to be compressed.\";\n        const result = compressString(input);\n        expect(result).toBe(\"This is a long ...\");\n    });\n\n    it('should truncate the string to maxLength - 3 and append \"...\" when maxLength is specified', () => {\n        const input = \"Another long string that is definitely too long.\";\n        const result = compressString(input, 25);\n        expect(result).toBe(\"Another long string th...\");\n    });\n\n    it('should use default max length of 18 if no maxLength is provided', () => {\n        const input = \"This string is way too long.\";\n        const result = compressString(input);\n        expect(result).toBe(\"This string is ...\");\n    });\n\n    it('should return the original string if it is empty', () => {\n        const input = \"\";\n        const result = compressString(input);\n        expect(result).toBe(input);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Compresses a string to ensure its length does not exceed the specified maximum length.\n * If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n *\n * @param input - The string to be compressed.\n * @param maxLength - The maximum allowed length of the string (default is 18).\n * @returns A compressed string that does not exceed the specified length.\n */\nfunction compressString(input: string, maxLength: number = 18): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Compresses a string to ensure its length does not exceed the specified maximum length.\n * If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n *\n * @param input - The string to be compressed.\n * @param maxLength - The maximum allowed length of the string (default is 18).\n * @returns A compressed string that does not exceed the specified length.\n */\nstd::string compressString(const std::string& input, size_t maxLength = 18){\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\n// Assuming the compressString function is defined here or included.\n\nTEST_CASE(\"compressString\", \"[compressString]\") {\n\n    SECTION(\"should return the original string if it is shorter than the max length\") {\n        std::string input = \"Short string\";\n        std::string result = compressString(input);\n        REQUIRE(result == input);\n    }\n\n    SECTION(\"should return the original string if it is exactly equal to the max length\") {\n        std::string input = \"Exactly 18 chars\";\n        std::string result = compressString(input);\n        REQUIRE(result == input);\n    }\n\n    SECTION(\"should truncate the string and append '...' if it exceeds the max length\") {\n        std::string input = \"This is a long string that needs to be compressed.\";\n        std::string result = compressString(input);\n        REQUIRE(result == \"This is a long ...\");\n    }\n\n    SECTION(\"should truncate the string to maxLength - 3 and append '...' when maxLength is specified\") {\n        std::string input = \"Another long string that is definitely too long.\";\n        std::string result = compressString(input, 25);\n        REQUIRE(result == \"Another long string th...\");\n    }\n\n    SECTION(\"should use default max length of 18 if no maxLength is provided\") {\n        std::string input = \"This string is way too long.\";\n        std::string result = compressString(input);\n        REQUIRE(result == \"This string is ...\");\n    }\n\n    SECTION(\"should return the original string if it is empty\") {\n        std::string input = \"\";\n        std::string result = compressString(input);\n        REQUIRE(result == input);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Compresses a string to ensure its length does not exceed the specified maximum length.\n * If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n *\n * @param input - The string to be compressed.\n * @param maxLength - The maximum allowed length of the string (default is 18).\n * @returns A compressed string that does not exceed the specified length.\n */\nstd::string compressString(const std::string& input, size_t maxLength = 18){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Compresses a string to ensure its length does not exceed the specified maximum length.\n * If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n *\n * @param input - The string to be compressed.\n * @param maxLength - The maximum allowed length of the string (default is 18).\n * @returns A compressed string that does not exceed the specified length.\n */\npublic static String compressString(String input, int maxLength) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testOriginalStringShorterThanMaxLength() {\n        String input = \"Short string\";\n        String result = StringCompressor.compressString(input);\n        assertEquals(input, result);\n    }\n\n    @Test\n    public void testOriginalStringEqualToMaxLength() {\n        String input = \"Exactly 18 chars\";\n        String result = StringCompressor.compressString(input);\n        assertEquals(input, result);\n    }\n\n    @Test\n    public void testTruncateStringExceedsMaxLength() {\n        String input = \"This is a long string that needs to be compressed.\";\n        String result = StringCompressor.compressString(input);\n        assertEquals(\"This is a long ...\", result);\n    }\n\n    @Test\n    public void testTruncateWithSpecifiedMaxLength() {\n        String input = \"Another long string that is definitely too long.\";\n        String result = StringCompressor.compressString(input, 25);\n        assertEquals(\"Another long string th...\", result);\n    }\n\n    @Test\n    public void testDefaultMaxLength() {\n        String input = \"This string is way too long.\";\n        String result = StringCompressor.compressString(input);\n        assertEquals(\"This string is ...\", result);\n    }\n\n    @Test\n    public void testEmptyString() {\n        String input = \"\";\n        String result = StringCompressor.compressString(input);\n        assertEquals(input, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Compresses a string to ensure its length does not exceed the specified maximum length.\n * If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n *\n * @param input - The string to be compressed.\n * @param maxLength - The maximum allowed length of the string (default is 18).\n * @returns A compressed string that does not exceed the specified length.\n */\npublic static String compressString(String input, int maxLength) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 570, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Deeply merges two objects.\nIf properties are objects in both objects, they are recursively merged.\nIf a property exists in both objects but is not an object, the value from obj1 is used.", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Deeply merges two objects.\n * If properties are objects in both objects, they are recursively merged.\n * If a property exists in both objects but is not an object, the value from obj1 is used.\n *\n * @param {Object} obj1 - The first object to merge.\n * @param {Object|null|undefined} obj2 - The second object to merge.\n * @returns {Object} A new object that is the result of the merge.\n */\nconst deepMergeObjects = (obj1, obj2) => {\n    // Implementation here\n};", "test_code": "describe('deepMergeObjects', () => {\n    test('handles null values in obj2', () => {\n        const obj1 = { a: 1, b: 2 };\n        const obj2 = null;\n        const result = deepMergeObjects(obj1, obj2);\n        expect(result).toEqual(obj1); // Should return obj1\n    });\n\n    test('handles undefined values in obj2', () => {\n        const obj1 = { a: 1, b: 2 };\n        const obj2 = undefined;\n        const result = deepMergeObjects(obj1, obj2);\n        expect(result).toEqual(obj1); // Should return obj1\n    });\n\n    test('merges deeply nested objects', () => {\n        const obj1 = { a: { b: { c: 1 } }, d: 2 };\n        const obj2 = { a: { b: { d: 3 } }, e: 4 };\n        const result = deepMergeObjects(obj1, obj2);\n        expect(result).toEqual({\n            a: {\n                b: {\n                    c: 1\n                }\n            },\n            d: 2\n        });\n    });\n\n    test('does not merge arrays but takes them from obj1', () => {\n        const obj1 = { a: [1, 2, 3] };\n        const obj2 = { a: [4, 5] };\n        const result = deepMergeObjects(obj1, obj2);\n        expect(result).toEqual({ a: [1, 2, 3] }); // Should keep array from obj1\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Deeply merges two objects.\n * If properties are objects in both objects, they are recursively merged.\n * If a property exists in both objects but is not an object, the value from obj1 is used.\n *\n * @param {Object} obj1 - The first object to merge.\n * @param {Object|null|undefined} obj2 - The second object to merge.\n * @returns {Object} A new object that is the result of the merge.\n */\nconst deepMergeObjects = (obj1, obj2) => {\n    // Implementation here\n};", "addition_info": ""}, "typescript": {"code_signature": "type PlainObject = { [key: string]: any };\n\n/**\n * Deeply merges two objects.\n * If properties are objects in both objects, they are recursively merged.\n * If a property exists in both objects but is not an object, the value from obj1 is used.\n *\n * @param obj1 - The first object to merge.\n * @param obj2 - The second object to merge.\n * @returns A new object that is the result of the merge.\n */\nconst deepMergeObjects = (obj1: PlainObject, obj2: PlainObject | null | undefined): PlainObject => {\n}", "test_code": "describe('deepMergeObjects', () => {\n\n\n    test('handles null values in obj2', () => {\n        const obj1 = {a: 1, b: 2};\n        const obj2 = null;\n        const result = deepMergeObjects(obj1, obj2);\n        expect(result).toEqual(obj1); // Should return obj1\n    });\n\n    test('handles undefined values in obj2', () => {\n        const obj1 = {a: 1, b: 2};\n        const obj2 = undefined;\n        const result = deepMergeObjects(obj1, obj2);\n        expect(result).toEqual(obj1); // Should return obj1\n    });\n\n    test('merges deeply nested objects', () => {\n        const obj1 = {a: {b: {c: 1}}, d: 2};\n        const obj2 = {a: {b: {d: 3}}, e: 4};\n        const result = deepMergeObjects(obj1, obj2);\n        expect(result).toEqual({\n            \"a\": {\n                \"b\": {\n                    \"c\": 1\n                }\n            },\n            \"d\": 2\n        });\n    });\n\n    test('does not merge arrays but takes them from obj1', () => {\n    const obj1 = {a: [1, 2, 3]};\n    const obj2 = {a: [4, 5]};\n    const result = deepMergeObjects(obj1, obj2);\n    expect(result).toEqual({a: [1, 2, 3]}); // Should keep array from obj1\n});\n});", "prompt": "please write a typescript function , the function signature as below type PlainObject = { [key: string]: any };\n\n/**\n * Deeply merges two objects.\n * If properties are objects in both objects, they are recursively merged.\n * If a property exists in both objects but is not an object, the value from obj1 is used.\n *\n * @param obj1 - The first object to merge.\n * @param obj2 - The second object to merge.\n * @returns A new object that is the result of the merge.\n */\nconst deepMergeObjects = (obj1: PlainObject, obj2: PlainObject | null | undefined): PlainObject => {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 571, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Checks whether the string conforms to the latitude and longitude identification specification", "language_version_list": {"python": {"code_signature": "def is_valid_coordinate(coord: str) -> bool:\n    \"\"\"\n    Checks if the string conforms to the latitude and longitude identification specification.\n\n    Args:\n        coord: The coordinate string to check (can be latitude or longitude).\n\n    Returns:\n        A boolean indicating whether the coordinate is valid.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsValidCoordinate(unittest.TestCase):\n\n    def test_valid_latitude_with_direction(self):\n        coord = \"45.123N\"\n        self.assertTrue(is_valid_coordinate(coord))\n\n    def test_valid_latitude_without_direction(self):\n        coord = \"90.0\"\n        self.assertTrue(is_valid_coordinate(coord))\n\n    def test_valid_longitude_with_direction(self):\n        coord = \"180.0E\"\n        self.assertTrue(is_valid_coordinate(coord))\n\n    def test_valid_longitude_without_direction(self):\n        coord = \"-120.456\"\n        self.assertTrue(is_valid_coordinate(coord))\n\n    def test_invalid_longitude_exceeding_range(self):\n        coord = \"-200.5\"\n        self.assertFalse(is_valid_coordinate(coord))", "prompt": "please write a python function , the function signature as below def is_valid_coordinate(coord: str) -> bool:\n    \"\"\"\n    Checks if the string conforms to the latitude and longitude identification specification.\n\n    Args:\n        coord: The coordinate string to check (can be latitude or longitude).\n\n    Returns:\n        A boolean indicating whether the coordinate is valid.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Checks if the string conforms to the latitude and longitude identification specification.\n *\n * @param {string} coord - The coordinate string to check (can be latitude or longitude).\n * @returns {boolean} A boolean indicating whether the coordinate is valid.\n */\nfunction isValidCoordinate(coord) {\n}", "test_code": "describe('isValidCoordinate', () => {\n    test('valid latitude with direction', () => {\n        const coord = \"45.123N\";\n        expect(isValidCoordinate(coord)).toBe(true);\n    });\n\n    test('valid latitude without direction', () => {\n        const coord = \"90.0\";\n        expect(isValidCoordinate(coord)).toBe(true);\n    });\n\n    test('valid longitude with direction', () => {\n        const coord = \"180.0E\";\n        expect(isValidCoordinate(coord)).toBe(true);\n    });\n\n    test('valid longitude without direction', () => {\n        const coord = \"-120.456\";\n        expect(isValidCoordinate(coord)).toBe(true);\n    });\n\n    test('invalid longitude exceeding range', () => {\n        const coord = \"-200.5\";\n        expect(isValidCoordinate(coord)).toBe(false);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Checks if the string conforms to the latitude and longitude identification specification.\n *\n * @param {string} coord - The coordinate string to check (can be latitude or longitude).\n * @returns {boolean} A boolean indicating whether the coordinate is valid.\n */\nfunction isValidCoordinate(coord) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Checks if the string conforms to the latitude and longitude identification specification.\n *\n * @param coord - The coordinate string to check (can be latitude or longitude).\n * @returns A boolean indicating whether the coordinate is valid.\n */\nfunction isValidCoordinate(coord: string): boolean {\n}", "test_code": "describe('isValidCoordinate', () => {\n    test('valid latitude with direction', () => {\n        const coord = \"45.123N\";\n        expect(isValidCoordinate(coord)).toBe(true);\n    });\n\n    test('valid latitude without direction', () => {\n        const coord = \"90.0\";\n        expect(isValidCoordinate(coord)).toBe(true);\n    });\n\n    test('valid longitude with direction', () => {\n        const coord = \"180.0E\";\n        expect(isValidCoordinate(coord)).toBe(true);\n    });\n\n    test('valid longitude without direction', () => {\n        const coord = \"-120.456\";\n        expect(isValidCoordinate(coord)).toBe(true);\n    });\n\n\n    test('invalid longitude exceeding range', () => {\n        const coord = \"-200.5\";\n        expect(isValidCoordinate(coord)).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Checks if the string conforms to the latitude and longitude identification specification.\n *\n * @param coord - The coordinate string to check (can be latitude or longitude).\n * @returns A boolean indicating whether the coordinate is valid.\n */\nfunction isValidCoordinate(coord: string): boolean {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Checks if the string conforms to the latitude and longitude identification specification.\n *\n * @param coord - The coordinate string to check (can be latitude or longitude).\n * @returns A boolean indicating whether the coordinate is valid.\n */\nbool isValidCoordinate(const std::string& coord) {\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\n// Assume isValidCoordinate is defined elsewhere\n\nTEST_CASE(\"isValidCoordinate\") {\n    SECTION(\"valid latitude with direction\") {\n        std::string coord = \"45.123N\";\n        REQUIRE(isValidCoordinate(coord) == true);\n    }\n\n    SECTION(\"valid latitude without direction\") {\n        std::string coord = \"90.0\";\n        REQUIRE(isValidCoordinate(coord) == true);\n    }\n\n    SECTION(\"valid longitude with direction\") {\n        std::string coord = \"180.0E\";\n        REQUIRE(isValidCoordinate(coord) == true);\n    }\n\n    SECTION(\"valid longitude without direction\") {\n        std::string coord = \"-120.456\";\n        REQUIRE(isValidCoordinate(coord) == true);\n    }\n\n    SECTION(\"invalid longitude exceeding range\") {\n        std::string coord = \"-200.5\";\n        REQUIRE(isValidCoordinate(coord) == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Checks if the string conforms to the latitude and longitude identification specification.\n *\n * @param coord - The coordinate string to check (can be latitude or longitude).\n * @returns A boolean indicating whether the coordinate is valid.\n */\nbool isValidCoordinate(const std::string& coord) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks if the string conforms to the latitude and longitude identification specification.\n *\n * @param coord - The coordinate string to check (can be latitude or longitude).\n * @returns A boolean indicating whether the coordinate is valid.\n */\npublic static boolean isValidCoordinate(String coord) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\npublic class Tester {\n\n    @Test\n    public void testValidLatitudeWithDirection() {\n        String coord = \"45.123N\";\n        assertTrue(CoordinateValidator.isValidCoordinate(coord));\n    }\n\n    @Test\n    public void testValidLatitudeWithoutDirection() {\n        String coord = \"90.0\";\n        assertTrue(CoordinateValidator.isValidCoordinate(coord));\n    }\n\n    @Test\n    public void testValidLongitudeWithDirection() {\n        String coord = \"180.0E\";\n        assertTrue(CoordinateValidator.isValidCoordinate(coord));\n    }\n\n    @Test\n    public void testValidLongitudeWithoutDirection() {\n        String coord = \"-120.456\";\n        assertTrue(CoordinateValidator.isValidCoordinate(coord));\n    }\n\n    @Test\n    public void testInvalidLongitudeExceedingRange() {\n        String coord = \"-200.5\";\n        assertFalse(CoordinateValidator.isValidCoordinate(coord));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks if the string conforms to the latitude and longitude identification specification.\n *\n * @param coord - The coordinate string to check (can be latitude or longitude).\n * @returns A boolean indicating whether the coordinate is valid.\n */\npublic static boolean isValidCoordinate(String coord) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 572, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Merges two arrays of objects, updating items in the first array with items\nfrom the second array based on a unique identifier. If an ID exists in both\narrays, the item from the second array will replace the one in the first.", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Merges two arrays of objects, updating items in the first array with items\n * from the second array based on a unique identifier. If an ID exists in both\n * arrays, the item from the second array will replace the one in the first.\n *\n * @param arr1 - The first array of objects to merge.\n * @param arr2 - The second array of objects to merge, which may update\n *               items in the first array.\n * @param getId - A function that takes an object and returns its unique ID\n *                as a string, used to identify items for merging.\n * @returns An array of merged objects, including all unique items from both\n *          input arrays, with updates applied from the second array.\n */\nfunction mergeOrUpdate(arr1, arr2, getId) {\n    // Function implementation goes here\n}", "test_code": "describe('mergeOrUpdate', () => {\n    test('merges two arrays with unique items', () => {\n        const arr1 = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n        const arr2 = [\n            { id: '3', name: 'Item 3' },\n            { id: '4', name: 'Item 4' }\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' },\n            { id: '3', name: 'Item 3' },\n            { id: '4', name: 'Item 4' }\n        ]);\n    });\n\n    test('updates existing items when IDs match', () => {\n        const arr1 = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n        const arr2 = [\n            { id: '2', name: 'Updated Item 2' },\n            { id: '3', name: 'Item 3' }\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Updated Item 2' },\n            { id: '3', name: 'Item 3' }\n        ]);\n    });\n\n    test('handles empty arrays', () => {\n        const arr1 = [];\n        const arr2 = [];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([]);\n    });\n\n    test('merges with an empty first array', () => {\n        const arr1 = [];\n        const arr2 = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ]);\n    });\n\n    test('merges with an empty second array', () => {\n        const arr1 = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n        const arr2 = [];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ]);\n    });\n\n    test('handles duplicate IDs in the first array', () => {\n        const arr1 = [\n            { id: '1', name: 'Item 1' },\n            { id: '1', name: 'Duplicate Item 1' } // Duplicate ID\n        ];\n        const arr2 = [\n            { id: '2', name: 'Item 2' }\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Duplicate Item 1' }, // Last occurrence takes precedence\n            { id: '2', name: 'Item 2' }\n        ]);\n    });\n\n    test('handles duplicate IDs in the second array', () => {\n        const arr1 = [\n            { id: '1', name: 'Item 1' }\n        ];\n        const arr2 = [\n            { id: '2', name: 'Item 2' },\n            { id: '2', name: 'Duplicate Item 2' } // Duplicate ID\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Duplicate Item 2' } // Last occurrence takes precedence\n        ]);\n    });\n\n    test('merges arrays with mixed unique and duplicate IDs', () => {\n        const arr1 = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n        const arr2 = [\n            { id: '2', name: 'Updated Item 2' },\n            { id: '3', name: 'Item 3' },\n            { id: '1', name: 'New Item 1' } // Updated item with same ID\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'New Item 1' }, // Updated\n            { id: '2', name: 'Updated Item 2' }, // Updated\n            { id: '3', name: 'Item 3' }\n        ]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Merges two arrays of objects, updating items in the first array with items\n * from the second array based on a unique identifier. If an ID exists in both\n * arrays, the item from the second array will replace the one in the first.\n *\n * @param arr1 - The first array of objects to merge.\n * @param arr2 - The second array of objects to merge, which may update\n *               items in the first array.\n * @param getId - A function that takes an object and returns its unique ID\n *                as a string, used to identify items for merging.\n * @returns An array of merged objects, including all unique items from both\n *          input arrays, with updates applied from the second array.\n */\nfunction mergeOrUpdate(arr1, arr2, getId) {\n    // Function implementation goes here\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Merges two arrays of objects, updating items in the first array with items\n * from the second array based on a unique identifier. If an ID exists in both\n * arrays, the item from the second array will replace the one in the first.\n *\n * @param arr1 - The first array of objects to merge.\n * @param arr2 - The second array of objects to merge, which may update\n *               items in the first array.\n * @param getId - A function that takes an object and returns its unique ID\n *                as a string, used to identify items for merging.\n * @returns An array of merged objects, including all unique items from both\n *          input arrays, with updates applied from the second array.\n */\nfunction mergeOrUpdate<O>(\n    arr1: Array<O>,\n    arr2: Array<O>,\n    getId: (item: O) => string\n): Array<O> {\n}", "test_code": "interface Item {\n    id: string;\n    name: string;\n}\n\ndescribe('mergeOrUpdate', () => {\n    test('merges two arrays with unique items', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n        const arr2: Item[] = [\n            { id: '3', name: 'Item 3' },\n            { id: '4', name: 'Item 4' }\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' },\n            { id: '3', name: 'Item 3' },\n            { id: '4', name: 'Item 4' }\n        ]);\n    });\n\n    test('updates existing items when IDs match', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n        const arr2: Item[] = [\n            { id: '2', name: 'Updated Item 2' },\n            { id: '3', name: 'Item 3' }\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Updated Item 2' },\n            { id: '3', name: 'Item 3' }\n        ]);\n    });\n\n    test('handles empty arrays', () => {\n        const arr1: Item[] = [];\n        const arr2: Item[] = [];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([]);\n    });\n\n    test('merges with an empty first array', () => {\n        const arr1: Item[] = [];\n        const arr2: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ]);\n    });\n\n    test('merges with an empty second array', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n        const arr2: Item[] = [];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ]);\n    });\n\n    test('handles duplicate IDs in the first array', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '1', name: 'Duplicate Item 1' } // Duplicate ID\n        ];\n        const arr2: Item[] = [\n            { id: '2', name: 'Item 2' }\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Duplicate Item 1' }, // Last occurrence takes precedence\n            { id: '2', name: 'Item 2' }\n        ]);\n    });\n\n    test('handles duplicate IDs in the second array', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' }\n        ];\n        const arr2: Item[] = [\n            { id: '2', name: 'Item 2' },\n            { id: '2', name: 'Duplicate Item 2' } // Duplicate ID\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Duplicate Item 2' } // Last occurrence takes precedence\n        ]);\n    });\n\n    test('merges arrays with mixed unique and duplicate IDs', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n        const arr2: Item[] = [\n            { id: '2', name: 'Updated Item 2' },\n            { id: '3', name: 'Item 3' },\n            { id: '1', name: 'New Item 1' } // Updated item with same ID\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'New Item 1' }, // Updated\n            { id: '2', name: 'Updated Item 2' }, // Updated\n            { id: '3', name: 'Item 3' }\n        ]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Merges two arrays of objects, updating items in the first array with items\n * from the second array based on a unique identifier. If an ID exists in both\n * arrays, the item from the second array will replace the one in the first.\n *\n * @param arr1 - The first array of objects to merge.\n * @param arr2 - The second array of objects to merge, which may update\n *               items in the first array.\n * @param getId - A function that takes an object and returns its unique ID\n *                as a string, used to identify items for merging.\n * @returns An array of merged objects, including all unique items from both\n *          input arrays, with updates applied from the second array.\n */\nfunction mergeOrUpdate<O>(\n    arr1: Array<O>,\n    arr2: Array<O>,\n    getId: (item: O) => string\n): Array<O> {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 575, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Formats the thread count into a user-friendly string.", "language_version_list": {"python": {"code_signature": "def format_thread_count(count: int) -> str:\n    \"\"\"\n    Formats the thread count into a user-friendly string.\n\n    The function formats the number of threads into a two-digit string\n    followed by \"Thread\" or \"Threads\" based on the count.\n\n    For example:\n        - Input: 3  Output: \"03 Threads\"\n        - Input: 1  Output: \"01 Thread\"\n\n    Args:\n        count (int): The number of threads.\n\n    Returns:\n        str: A formatted string indicating the number of threads.\n             The string will be in the format \"XX Thread\" or \"XX Threads\",\n             where XX is the count formatted as a two-digit number.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFormatThreadCount(unittest.TestCase):\n\n    def test_count_of_one(self):\n        \"\"\"should return '01 Thread' for a count of 1\"\"\"\n        self.assertEqual(format_thread_count(1), \"01 Thread\")\n\n    def test_count_of_five(self):\n        \"\"\"should return '05 Threads' for a count of 5\"\"\"\n        self.assertEqual(format_thread_count(5), \"05 Threads\")\n\n    def test_count_of_ten(self):\n        \"\"\"should return '10 Threads' for a count of 10\"\"\"\n        self.assertEqual(format_thread_count(10), \"10 Threads\")\n\n    def test_count_of_ninety_nine(self):\n        \"\"\"should return '99 Threads' for a count of 99\"\"\"\n        self.assertEqual(format_thread_count(99), \"99 Threads\")", "prompt": "please write a python function , the function signature as below def format_thread_count(count: int) -> str:\n    \"\"\"\n    Formats the thread count into a user-friendly string.\n\n    The function formats the number of threads into a two-digit string\n    followed by \"Thread\" or \"Threads\" based on the count.\n\n    For example:\n        - Input: 3  Output: \"03 Threads\"\n        - Input: 1  Output: \"01 Thread\"\n\n    Args:\n        count (int): The number of threads.\n\n    Returns:\n        str: A formatted string indicating the number of threads.\n             The string will be in the format \"XX Thread\" or \"XX Threads\",\n             where XX is the count formatted as a two-digit number.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Formats the thread count into a user-friendly string.\n * For example:\n *      input: 3 output: 03 Threads\n *      input: 1 output: 01 Thread\n *\n * @param {number} count - The number of threads.\n * @returns {string} - A formatted string indicating the number of threads.\n */\nfunction formatThreadCount(count) {}", "test_code": "describe('formatThreadCount', () => {\n    test('should return \"01 Thread\" for a count of 1', () => {\n        expect(formatThreadCount(1)).toBe(\"01 Thread\");\n    });\n\n    test('should return \"05 Threads\" for a count of 5', () => {\n        expect(formatThreadCount(5)).toBe(\"05 Threads\");\n    });\n\n    test('should return \"10 Threads\" for a count of 10', () => {\n        expect(formatThreadCount(10)).toBe(\"10 Threads\");\n    });\n\n    test('should return \"99 Threads\" for a count of 99', () => {\n        expect(formatThreadCount(99)).toBe(\"99 Threads\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Formats the thread count into a user-friendly string.\n * For example:\n *      input: 3 output: 03 Threads\n *      input: 1 output: 01 Thread\n *\n * @param {number} count - The number of threads.\n * @returns {string} - A formatted string indicating the number of threads.\n */\nfunction formatThreadCount(count) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Formats the thread count into a user-friendly string.\n * For example:\n *      input: 3 output: 03 Threads\n *      input: 1 output: 01 Thread\n *\n * @param {number} count - The number of threads.\n * @returns {string} - A formatted string indicating the number of threads.\n */\nfunction formatThreadCount(count) {\n}", "test_code": "describe('formatThreadCount', () => {\n    test('should return \"01 Thread\" for a count of 1', () => {\n        expect(formatThreadCount(1)).toBe(\"01 Thread\");\n    });\n\n    test('should return \"05 Threads\" for a count of 5', () => {\n        expect(formatThreadCount(5)).toBe(\"05 Threads\");\n    });\n\n    test('should return \"10 Threads\" for a count of 10', () => {\n        expect(formatThreadCount(10)).toBe(\"10 Threads\");\n    });\n\n    test('should return \"99 Threads\" for a count of 99', () => {\n        expect(formatThreadCount(99)).toBe(\"99 Threads\");\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Formats the thread count into a user-friendly string.\n * For example:\n *      input: 3 output: 03 Threads\n *      input: 1 output: 01 Thread\n *\n * @param {number} count - The number of threads.\n * @returns {string} - A formatted string indicating the number of threads.\n */\nfunction formatThreadCount(count) {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Formats the thread count into a user-friendly string.\n * For example:\n *      input: 3 output: 03 Threads\n *      input: 1 output: 01 Thread\n *\n * @param count - The number of threads.\n * @returns A formatted string indicating the number of threads.\n */\nstd::string formatThreadCount(int count) {}", "test_code": "TEST_CASE(\"formatThreadCount\", \"[formatThreadCount]\") {\n    REQUIRE(formatThreadCount(1) == \"01 Thread\");\n    REQUIRE(formatThreadCount(5) == \"05 Threads\");\n    REQUIRE(formatThreadCount(10) == \"10 Threads\");\n    REQUIRE(formatThreadCount(99) == \"99 Threads\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Formats the thread count into a user-friendly string.\n * For example:\n *      input: 3 output: 03 Threads\n *      input: 1 output: 01 Thread\n *\n * @param count - The number of threads.\n * @returns A formatted string indicating the number of threads.\n */\nstd::string formatThreadCount(int count) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Formats the thread count into a user-friendly string.\n * For example:\n *      input: 3 output: 03 Threads\n *      input: 1 output: 01 Thread\n *\n * @param count - The number of threads.\n * @return - A formatted string indicating the number of threads.\n */\npublic String formatThreadCount(int count) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testFormatThreadCountForOne() {\n        assertEquals(\"01 Thread\", formatThreadCount(1));\n    }\n\n    @Test\n    public void testFormatThreadCountForFive() {\n        assertEquals(\"05 Threads\", formatThreadCount(5));\n    }\n\n    @Test\n    public void testFormatThreadCountForTen() {\n        assertEquals(\"10 Threads\", formatThreadCount(10));\n    }\n\n    @Test\n    public void testFormatThreadCountForNinetyNine() {\n        assertEquals(\"99 Threads\", formatThreadCount(99));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Formats the thread count into a user-friendly string.\n * For example:\n *      input: 3 output: 03 Threads\n *      input: 1 output: 01 Thread\n *\n * @param count - The number of threads.\n * @return - A formatted string indicating the number of threads.\n */\npublic String formatThreadCount(int count) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 576, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Hides the sensitive part of a bank account number with 17 characters only show the last 4 characters.", "language_version_list": {"python": {"code_signature": "def hide_bank_account(account: str) -> str:\n    \"\"\"\n    Hides the sensitive part of a bank account number with 17 digits, showing only the last 4 characters.\n\n    For example:\n        - Input: 12345678901234567\n        - Output: ****4567\n\n    Args:\n        account (str): The bank account number to hide. This must be exactly 17 characters long.\n\n    Returns:\n        str: The bank account number with the first part hidden, formatted as \"****XXXX\",\n             where \"XXXX\" are the last four digits of the account.\n\n    Raises:\n        ValueError: If the account number is not exactly 17 characters long.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestHideBankAccount(unittest.TestCase):\n    def test_should_return_hidden_part_for_valid_account(self):\n        self.assertEqual(hide_bank_account('12345678901234567'), '****4567')\n\n    def test_should_return_hidden_part_for_another_valid_account(self):\n        self.assertEqual(hide_bank_account('98765432109876543'), '****6543')\n\n    def test_should_return_hidden_part_for_yet_another_valid_account(self):\n        self.assertEqual(hide_bank_account('11111111111111100'), '****1100')\n\n    def test_should_throw_error_for_shorter_account(self):\n        with self.assertRaises(Exception):\n            hide_bank_account('1234567890123456')\n\n    def test_should_throw_error_for_longer_account(self):\n        with self.assertRaises(Exception):\n            hide_bank_account('123456789012345678')\n\n    def test_should_throw_error_for_empty_account(self):\n        with self.assertRaises(Exception):\n            hide_bank_account('')\n", "prompt": "please write a python function , the function signature as below def hide_bank_account(account: str) -> str:\n    \"\"\"\n    Hides the sensitive part of a bank account number with 17 digits, showing only the last 4 characters.\n\n    For example:\n        - Input: 12345678901234567\n        - Output: ****4567\n\n    Args:\n        account (str): The bank account number to hide. This must be exactly 17 characters long.\n\n    Returns:\n        str: The bank account number with the first part hidden, formatted as \"****XXXX\",\n             where \"XXXX\" are the last four digits of the account.\n\n    Raises:\n        ValueError: If the account number is not exactly 17 characters long.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Hides the sensitive part of a bank account number with 17 numbers, only showing the last 4 characters.\n * For example:\n *      input: 12345678901234567\n *      output: ****4567\n * @param {string} account - The bank account number to hide.\n * @returns {string} - The bank account number with the first part hidden.\n * @throws {Error} - Throws an error if the account number is not exactly 17 characters long.\n */\nfunction hideBankAccount(account) {}", "test_code": "describe('hideBankAccount', () => {\n    test('should return \"****4567\" for an account number of \"12345678901234567\"', () => {\n        expect(hideBankAccount('12345678901234567')).toBe('****4567');\n    });\n\n    test('should return \"****6543\" for an account number of \"98765432109876543\"', () => {\n        expect(hideBankAccount('98765432109876543')).toBe('****6543');\n    });\n\n    test('should return \"****1100\" for an account number of \"11111111111111100\"', () => {\n        expect(hideBankAccount('11111111111111100')).toBe('****1100');\n    });\n\n    test('should throw an error for an account number shorter than 17 characters', () => {\n        expect(() => hideBankAccount('1234567890123456')).toThrow();\n    });\n\n    test('should throw an error for an account number longer than 17 characters', () => {\n        expect(() => hideBankAccount('123456789012345678')).toThrow();\n    });\n\n    test('should throw an error for an account number with 0 characters', () => {\n        expect(() => hideBankAccount('')).toThrow();\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Hides the sensitive part of a bank account number with 17 numbers, only showing the last 4 characters.\n * For example:\n *      input: 12345678901234567\n *      output: ****4567\n * @param {string} account - The bank account number to hide.\n * @returns {string} - The bank account number with the first part hidden.\n * @throws {Error} - Throws an error if the account number is not exactly 17 characters long.\n */\nfunction hideBankAccount(account) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Hides the sensitive part of a bank account number with 17 number only show the last 4 characters.\n * For example:\n *      input: 12345678901234567\n *      output: ****4567\n * @param {string} account - The bank account number to hide.\n * @returns {string} - The bank account number with the first part hidden.\n * @throws {Error} - Throws an error if the account number is not longer than 17 characters.\n */\nfunction hideBankAccount(account: string): string {\n}", "test_code": "describe('hideBankAccount', () => {\n    test('should return \"****4567\" for an account number of \"12345678901234567\"', () => {\n        expect(hideBankAccount('12345678901234567')).toBe('****4567');\n    });\n\n    test('should return \"****6543\" for an account number of \"98765432109876543\"', () => {\n        expect(hideBankAccount('98765432109876543')).toBe('****6543');\n    });\n\n    test('should return \"****1100\" for an account number of \"11111111111111100\"', () => {\n        expect(hideBankAccount('11111111111111100')).toBe('****1100');\n    });\n\n    test('should throw an error for an account number shorter than 17 characters', () => {\n        expect(() => hideBankAccount('1234567890123456')).toThrow();\n    });\n\n    test('should throw an error for an account number longer than 17 characters', () => {\n        expect(() => hideBankAccount('123456789012345678')).toThrow();\n    });\n\n    test('should throw an error for an account number with 0 characters', () => {\n        expect(() => hideBankAccount('')).toThrow();\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Hides the sensitive part of a bank account number with 17 number only show the last 4 characters.\n * For example:\n *      input: 12345678901234567\n *      output: ****4567\n * @param {string} account - The bank account number to hide.\n * @returns {string} - The bank account number with the first part hidden.\n * @throws {Error} - Throws an error if the account number is not longer than 17 characters.\n */\nfunction hideBankAccount(account: string): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Hides the sensitive part of a bank account number with 17 numbers, only showing the last 4 characters.\n * For example:\n *      input: 12345678901234567\n *      output: ****4567\n * @param account - The bank account number to hide.\n * @returns The bank account number with the first part hidden.\n * @throws std::invalid_argument - Throws an error if the account number is not exactly 17 characters long.\n */\nstd::string hideBankAccount(const std::string& account){}", "test_code": "TEST_CASE(\"hideBankAccount\", \"[hideBankAccount]\") {\n    SECTION(\"should return \\\"****4567\\\" for an account number of \\\"12345678901234567\\\"\") {\n        REQUIRE(hideBankAccount(\"12345678901234567\") == \"****4567\");\n    }\n\n    SECTION(\"should return \\\"****6543\\\" for an account number of \\\"98765432109876543\\\"\") {\n        REQUIRE(hideBankAccount(\"98765432109876543\") == \"****6543\");\n    }\n\n    SECTION(\"should return \\\"****1100\\\" for an account number of \\\"11111111111111100\\\"\") {\n        REQUIRE(hideBankAccount(\"11111111111111100\") == \"****1100\");\n    }\n\n    SECTION(\"should throw an error for an account number shorter than 17 characters\") {\n        REQUIRE_THROWS_AS(hideBankAccount(\"1234567890123456\"), std::invalid_argument);\n    }\n\n    SECTION(\"should throw an error for an account number longer than 17 characters\") {\n        REQUIRE_THROWS_AS(hideBankAccount(\"123456789012345678\"), std::invalid_argument);\n    }\n\n    SECTION(\"should throw an error for an account number with 0 characters\") {\n        REQUIRE_THROWS_AS(hideBankAccount(\"\"), std::invalid_argument);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Hides the sensitive part of a bank account number with 17 numbers, only showing the last 4 characters.\n * For example:\n *      input: 12345678901234567\n *      output: ****4567\n * @param account - The bank account number to hide.\n * @returns The bank account number with the first part hidden.\n * @throws std::invalid_argument - Throws an error if the account number is not exactly 17 characters long.\n */\nstd::string hideBankAccount(const std::string& account){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Hides the sensitive part of a bank account number with 17 numbers, only showing the last 4 characters.\n * For example:\n *      input: 12345678901234567\n *      output: ****4567\n * @param account The bank account number to hide.\n * @return The bank account number with the first part hidden.\n * @throws IllegalArgumentException Throws an exception if the account number is not exactly 17 characters long.\n */\npublic static String hideBankAccount(String account) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void testHideBankAccountValidCases() {\n        assertEquals(\"****4567\", BankAccountHider.hideBankAccount(\"12345678901234567\"));\n        assertEquals(\"****6543\", BankAccountHider.hideBankAccount(\"98765432109876543\"));\n        assertEquals(\"****1100\", BankAccountHider.hideBankAccount(\"11111111111111100\"));\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testHideBankAccountShorterThan17Characters() {\n        BankAccountHider.hideBankAccount(\"1234567890123456\");\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testHideBankAccountLongerThan17Characters() {\n        BankAccountHider.hideBankAccount(\"123456789012345678\");\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testHideBankAccountWithZeroCharacters() {\n        BankAccountHider.hideBankAccount(\"\");\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Hides the sensitive part of a bank account number with 17 numbers, only showing the last 4 characters.\n * For example:\n *      input: 12345678901234567\n *      output: ****4567\n * @param account The bank account number to hide.\n * @return The bank account number with the first part hidden.\n * @throws IllegalArgumentException Throws an exception if the account number is not exactly 17 characters long.\n */\npublic static String hideBankAccount(String account) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 577, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Formats the post count into a human-readable string.", "language_version_list": {"python": {"code_signature": "def format_post_count(count: int) -> str:\n    \"\"\"\n    Formats the post count into a human-readable string.\n\n    The function formats the number of posts into a two-digit string\n    followed by \"Post\" or \"Posts\" based on the count.\n\n    For example:\n        - Input: 3  Output: \"02 Posts\"\n        - Input: 1  Output: \"01 Post\"\n\n    Args:\n        count (int): The number of posts.\n\n    Returns:\n        str: A formatted string indicating the number of posts.\n             The string will be in the format \"XX Post\" or \"XX Posts\",\n             where XX is the count formatted as a two-digit number.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFormatPostCount(unittest.TestCase):\n\n    def test_return_one_post(self):\n        \"\"\"Should return \"01 Post\" for count of 1.\"\"\"\n        self.assertEqual(format_post_count(1), \"01 Post\")\n\n    def test_return_two_posts(self):\n        \"\"\"Should return \"02 Posts\" for count of 2.\"\"\"\n        self.assertEqual(format_post_count(2), \"02 Posts\")\n\n    def test_return_ten_posts(self):\n        \"\"\"Should return \"10 Posts\" for count of 10.\"\"\"\n        self.assertEqual(format_post_count(10), \"10 Posts\")\n\n    def test_return_ninety_nine_posts(self):\n        \"\"\"Should return \"99 Posts\" for count of 99.\"\"\"\n        self.assertEqual(format_post_count(99), \"99 Posts\")\n\n    def test_return_five_posts(self):\n        \"\"\"Should return \"05 Posts\" for count of 5.\"\"\"\n        self.assertEqual(format_post_count(5), \"05 Posts\")\n", "prompt": "please write a python function , the function signature as below def format_post_count(count: int) -> str:\n    \"\"\"\n    Formats the post count into a human-readable string.\n\n    The function formats the number of posts into a two-digit string\n    followed by \"Post\" or \"Posts\" based on the count.\n\n    For example:\n        - Input: 3  Output: \"02 Posts\"\n        - Input: 1  Output: \"01 Post\"\n\n    Args:\n        count (int): The number of posts.\n\n    Returns:\n        str: A formatted string indicating the number of posts.\n             The string will be in the format \"XX Post\" or \"XX Posts\",\n             where XX is the count formatted as a two-digit number.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Formats the post count into a human-readable string.\n * For example:\n *      input: 3 output: 02 Posts\n *      input: 1 output: 01 Post\n *\n * @param {number} count - The number of posts.\n * @returns {string} - A formatted string indicating the number of posts.\n */\nfunction formatPostCount(count) {}", "test_code": "describe('formatPostCount', () => {\n    test('should return \"01 Post\" for count of 1', () => {\n        expect(formatPostCount(1)).toBe('01 Post');\n    });\n\n    test('should return \"02 Posts\" for count of 2', () => {\n        expect(formatPostCount(2)).toBe('02 Posts');\n    });\n\n    test('should return \"10 Posts\" for count of 10', () => {\n        expect(formatPostCount(10)).toBe('10 Posts');\n    });\n\n    test('should return \"99 Posts\" for count of 99', () => {\n        expect(formatPostCount(99)).toBe('99 Posts');\n    });\n\n    test('should return \"05 Posts\" for count of 5', () => {\n        expect(formatPostCount(5)).toBe('05 Posts');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Formats the post count into a human-readable string.\n * For example:\n *      input: 3 output: 02 Posts\n *      input: 1 output: 01 Post\n *\n * @param {number} count - The number of posts.\n * @returns {string} - A formatted string indicating the number of posts.\n */\nfunction formatPostCount(count) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Formats the post count into a human-readable string.\n * For example:\n *      input: 3 output: 02 Posts\n *      input: 1 output: 01 Post\n *\n * @param {number} count - The number of posts.\n * @returns {string} - A formatted string indicating the number of posts.\n */\nfunction formatPostCount(count: number): string {\n}", "test_code": "describe('formatPostCount', () => {\n    test('should return \"01 Post\" for count of 1', () => {\n        expect(formatPostCount(1)).toBe('01 Post');\n    });\n\n    test('should return \"02 Posts\" for count of 2', () => {\n        expect(formatPostCount(2)).toBe('02 Posts');\n    });\n\n    test('should return \"10 Posts\" for count of 10', () => {\n        expect(formatPostCount(10)).toBe('10 Posts');\n    });\n\n    test('should return \"99 Posts\" for count of 99', () => {\n        expect(formatPostCount(99)).toBe('99 Posts');\n    });\n\n    test('should return \"05 Posts\" for count of 5', () => {\n        expect(formatPostCount(5)).toBe('05 Posts');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Formats the post count into a human-readable string.\n * For example:\n *      input: 3 output: 02 Posts\n *      input: 1 output: 01 Post\n *\n * @param {number} count - The number of posts.\n * @returns {string} - A formatted string indicating the number of posts.\n */\nfunction formatPostCount(count: number): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Formats the post count into a human-readable string.\n * For example:\n *      input: 3 output: 02 Posts\n *      input: 1 output: 01 Post\n *\n * @param count - The number of posts.\n * @returns A formatted string indicating the number of posts.\n */\nstd::string formatPostCount(int count) {}", "test_code": "TEST_CASE(\"formatPostCount\", \"[formatPostCount]\") {\n    REQUIRE(formatPostCount(1) == \"01 Post\");\n    REQUIRE(formatPostCount(2) == \"02 Posts\");\n    REQUIRE(formatPostCount(10) == \"10 Posts\");\n    REQUIRE(formatPostCount(99) == \"99 Posts\");\n    REQUIRE(formatPostCount(5) == \"05 Posts\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Formats the post count into a human-readable string.\n * For example:\n *      input: 3 output: 02 Posts\n *      input: 1 output: 01 Post\n *\n * @param count - The number of posts.\n * @returns A formatted string indicating the number of posts.\n */\nstd::string formatPostCount(int count) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Formats the post count into a human-readable string.\n * For example:\n *      input: 3 output: 02 Posts\n *      input: 1 output: 01 Post\n *\n * @param count - The number of posts.\n * @return - A formatted string indicating the number of posts.\n */\npublic static String formatPostCount(int count) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testFormatPostCount_SinglePost() {\n        assertEquals(\"01 Post\", formatPostCount(1));\n    }\n\n    @Test\n    public void testFormatPostCount_TwoPosts() {\n        assertEquals(\"02 Posts\", formatPostCount(2));\n    }\n\n    @Test\n    public void testFormatPostCount_TenPosts() {\n        assertEquals(\"10 Posts\", formatPostCount(10));\n    }\n\n    @Test\n    public void testFormatPostCount_NinetyNinePosts() {\n        assertEquals(\"99 Posts\", formatPostCount(99));\n    }\n\n    @Test\n    public void testFormatPostCount_FivePosts() {\n        assertEquals(\"05 Posts\", formatPostCount(5));\n    }\n    }", "prompt": "please write a java function , the function signature as below /**\n * Formats the post count into a human-readable string.\n * For example:\n *      input: 3 output: 02 Posts\n *      input: 1 output: 01 Post\n *\n * @param count - The number of posts.\n * @return - A formatted string indicating the number of posts.\n */\npublic static String formatPostCount(int count) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 578, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Detects whether the string is KEBAB_CASE", "language_version_list": {"python": {"code_signature": "def is_kebab_case(input: str) -> bool:\n    \"\"\"\n    Detects whether the string is in KEBAB_CASE.\n\n    KEBAB_CASE is defined as a string that:\n    - Contains only lowercase letters (a-z).\n    - May contain digits (0-9).\n    - Uses hyphens (-) as word separators.\n    - Does not start or end with a hyphen.\n    - Does not contain consecutive hyphens.\n\n    Args:\n        input (str): The string to check.\n\n    Returns:\n        bool: True if the string is in KEBAB_CASE, otherwise False.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsKebabCase(unittest.TestCase):\n\n    def test_valid_kebab_case(self):\n        \"\"\"Should return True for a valid kebab-case string.\"\"\"\n        self.assertTrue(is_kebab_case('kebab-case'))\n\n    def test_valid_kebab_case_multiple_words(self):\n        \"\"\"Should return True for a valid kebab-case string with multiple words.\"\"\"\n        self.assertTrue(is_kebab_case('this-is-a-valid-kebab-case'))\n\n    def test_uppercase_letters(self):\n        \"\"\"Should return False for a string with uppercase letters.\"\"\"\n        self.assertFalse(is_kebab_case('Kebab-Case'))\n\n    def test_consecutive_hyphens(self):\n        \"\"\"Should return False for a string with consecutive hyphens.\"\"\"\n        self.assertFalse(is_kebab_case('kebab--case'))\n\n    def test_empty_string(self):\n        \"\"\"Should return False for an empty string.\"\"\"\n        self.assertFalse(is_kebab_case(''))\n", "prompt": "please write a python function , the function signature as below def is_kebab_case(input: str) -> bool:\n    \"\"\"\n    Detects whether the string is in KEBAB_CASE.\n\n    KEBAB_CASE is defined as a string that:\n    - Contains only lowercase letters (a-z).\n    - May contain digits (0-9).\n    - Uses hyphens (-) as word separators.\n    - Does not start or end with a hyphen.\n    - Does not contain consecutive hyphens.\n\n    Args:\n        input (str): The string to check.\n\n    Returns:\n        bool: True if the string is in KEBAB_CASE, otherwise False.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Detects whether the string is in KEBAB_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in KEBAB_CASE, otherwise false.\n */\nfunction isKebabCase(input) {}", "test_code": "describe('isKebabCase', () => {\n    test('should return true for a valid kebab-case string', () => {\n        expect(isKebabCase('kebab-case')).toBe(true);\n    });\n\n    test('should return true for a valid kebab-case string with multiple words', () => {\n        expect(isKebabCase('this-is-a-valid-kebab-case')).toBe(true);\n    });\n\n    test('should return false for a string with uppercase letters', () => {\n        expect(isKebabCase('Kebab-Case')).toBe(false);\n    });\n\n    test('should return false for a string with consecutive hyphens', () => {\n        expect(isKebabCase('kebab--case')).toBe(false);\n    });\n\n    test('should return false for an empty string', () => {\n        expect(isKebabCase('')).toBe(false);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Detects whether the string is in KEBAB_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in KEBAB_CASE, otherwise false.\n */\nfunction isKebabCase(input) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Detects whether the string is in KEBAB_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in KEBAB_CASE, otherwise false.\n */\nfunction isKebabCase(input: string): boolean {\n}", "test_code": "describe('isKebabCase', () => {\n    test('should return true for a valid kebab-case string', () => {\n        expect(isKebabCase('kebab-case')).toBe(true);\n    });\n\n    test('should return true for a valid kebab-case string with multiple words', () => {\n        expect(isKebabCase('this-is-a-valid-kebab-case')).toBe(true);\n    });\n\n    test('should return false for a string with uppercase letters', () => {\n        expect(isKebabCase('Kebab-Case')).toBe(false);\n    });\n\n    test('should return false for a string with consecutive hyphens', () => {\n        expect(isKebabCase('kebab--case')).toBe(false);\n    });\n\n    test('should return false for an empty string', () => {\n        expect(isKebabCase('')).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Detects whether the string is in KEBAB_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in KEBAB_CASE, otherwise false.\n */\nfunction isKebabCase(input: string): boolean {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Detects whether the string is in KEBAB_CASE.\n *\n * @param input - The string to check.\n * @returns True if the string is in KEBAB_CASE, otherwise false.\n */\nbool isKebabCase(const std::string& input){}", "test_code": "TEST_CASE(\"isKebabCase\", \"[kebab-case]\") {\n    SECTION(\"should return true for a valid kebab-case string\") {\n        REQUIRE(isKebabCase(\"kebab-case\") == true);\n    }\n\n    SECTION(\"should return true for a valid kebab-case string with multiple words\") {\n        REQUIRE(isKebabCase(\"this-is-a-valid-kebab-case\") == true);\n    }\n\n    SECTION(\"should return false for a string with uppercase letters\") {\n        REQUIRE(isKebabCase(\"Kebab-Case\") == false);\n    }\n\n    SECTION(\"should return false for a string with consecutive hyphens\") {\n        REQUIRE(isKebabCase(\"kebab--case\") == false);\n    }\n\n    SECTION(\"should return false for an empty string\") {\n        REQUIRE(isKebabCase(\"\") == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Detects whether the string is in KEBAB_CASE.\n *\n * @param input - The string to check.\n * @returns True if the string is in KEBAB_CASE, otherwise false.\n */\nbool isKebabCase(const std::string& input){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Detects whether the string is in KEBAB_CASE.\n *\n * @param input - The string to check.\n * @returns True if the string is in KEBAB_CASE, otherwise false.\n */\npublic boolean isKebabCase(String input) {\n    // Regular expression to match KEBAB_CASE\n    String kebabCaseRegex = \"^[a-z]+(-[a-z]+)*$\";\n    return input.matches(kebabCaseRegex);\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void testValidKebabCase() {\n        assertTrue(isKebabCase(\"kebab-case\"));\n    }\n\n    @Test\n    public void testValidKebabCaseWithMultipleWords() {\n        assertTrue(isKebabCase(\"this-is-a-valid-kebab-case\"));\n    }\n\n    @Test\n    public void testUppercaseLetters() {\n        assertFalse(isKebabCase(\"Kebab-Case\"));\n    }\n\n    @Test\n    public void testConsecutiveHyphens() {\n        assertFalse(isKebabCase(\"kebab--case\"));\n    }\n\n    @Test\n    public void testEmptyString() {\n        assertFalse(isKebabCase(\"\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Detects whether the string is in KEBAB_CASE.\n *\n * @param input - The string to check.\n * @returns True if the string is in KEBAB_CASE, otherwise false.\n */\npublic boolean isKebabCase(String input) {\n    // Regular expression to match KEBAB_CASE\n    String kebabCaseRegex = \"^[a-z]+(-[a-z]+)*$\";\n    return input.matches(kebabCaseRegex);\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 581, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Abbreviates a number to a string with a suffix based on its magnitude.", "language_version_list": {"python": {"code_signature": "def abbreviate_number(number: float) -> str:\n    \"\"\"\n    Abbreviates a number to a string with a suffix based on its magnitude.\n\n    The function uses the following suffixes based on the number's magnitude:\n    - \"\" (no suffix) for values less than 1,000\n    - \"k\" for thousands (1,000)\n    - \"M\" for millions (1,000,000)\n    - \"B\" for billions (1,000,000,000)\n    - \"T\" for trillions (1,000,000,000,000)\n\n    For example:\n        - Input: 999             Output: \"999\"\n        - Input: 1549            Output: \"1.5k\"\n        - Input: 1000            Output: \"1k\"\n        - Input: 1234567890123   Output: \"1.2T\"\n\n    Args:\n        number (float): The number to abbreviate.\n\n    Returns:\n        str: The abbreviated string representation of the number.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestAbbreviateNumber(unittest.TestCase):\n\n    def test_less_than_1000(self):\n        # should return the same number for values less than 1000\n        self.assertEqual(abbreviate_number(999), '999')\n\n    def test_one_thousand(self):\n        # should return \"1k\" for 1000\n        result = abbreviate_number(1000)\n        self.assertIn(result, ['1k', '1.0k'])\n\n    def test_one_thousand_five_hundred(self):\n        # should return \"1.5k\" for 1500\n        self.assertEqual(abbreviate_number(1500), '1.5k')\n\n    def test_one_million(self):\n        # should return \"1M\" for 1 million\n        result = abbreviate_number(1000000)\n        self.assertIn(result, ['1M', '1.0M'])\n\n    def test_twenty_five_million(self):\n        # should return \"25M\" for 25 million\n        self.assertEqual(abbreviate_number(25000000), '25M')\n\n    def test_one_billion(self):\n        # should return \"1B\" for 1 billion\n        result = abbreviate_number(1000000000)\n        self.assertIn(result, ['1B', '1.0B'])\n\n    def test_one_point_two_trillion(self):\n        # should return \"1.2T\" for 1.2 trillion\n        self.assertEqual(abbreviate_number(1234567890123), '1.2T')\n", "prompt": "please write a python function , the function signature as below def abbreviate_number(number: float) -> str:\n    \"\"\"\n    Abbreviates a number to a string with a suffix based on its magnitude.\n\n    The function uses the following suffixes based on the number's magnitude:\n    - \"\" (no suffix) for values less than 1,000\n    - \"k\" for thousands (1,000)\n    - \"M\" for millions (1,000,000)\n    - \"B\" for billions (1,000,000,000)\n    - \"T\" for trillions (1,000,000,000,000)\n\n    For example:\n        - Input: 999             Output: \"999\"\n        - Input: 1549            Output: \"1.5k\"\n        - Input: 1000            Output: \"1k\"\n        - Input: 1234567890123   Output: \"1.2T\"\n\n    Args:\n        number (float): The number to abbreviate.\n\n    Returns:\n        str: The abbreviated string representation of the number.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Abbreviates a number to a string with a suffix based on its magnitude. \n * Suffixes: [\"\", \"k\", \"M\", \"B\", \"T\"]; 1000 is k, 1000000 is M, 1000000000 is B.\n * For example:\n *      input: 999 output: 999\n *      input: 1549 output: 1.5k\n *      input: 1000 output: 1k\n *      input: 1234567890123 output: 1.2T\n * @param {number} number - The number to abbreviate.\n * @returns {string} - The abbreviated string representation of the number.\n */\nfunction abbreviateNumber(number) {\n}", "test_code": "describe('abbreviateNumber', () => {\n    test('should return the same number for values less than 1000', () => {\n        expect(abbreviateNumber(999)).toBe('999');\n    });\n\n    test('should return \"1k\" for 1000', () => {\n        const result = abbreviateNumber(1000);\n        expect(['1k', '1.0k']).toContain(result);\n    });\n\n    test('should return \"1.5k\" for 1500', () => {\n        expect(abbreviateNumber(1500)).toBe('1.5k');\n    });\n\n    test('should return \"1M\" for 1 million', () => {\n        const result = abbreviateNumber(1000000);\n        expect(['1M', '1.0M']).toContain(result);\n    });\n\n    test('should return \"25M\" for 25 million', () => {\n        expect(abbreviateNumber(25000000)).toBe('25M');\n    });\n\n    test('should return \"1B\" for 1 billion', () => {\n        const result = abbreviateNumber(1000000000);\n        expect(['1B', '1.0B']).toContain(result);\n    });\n\n    test('should return \"1.2T\" for 1.2 trillion', () => {\n        expect(abbreviateNumber(1234567890123)).toBe('1.2T');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Abbreviates a number to a string with a suffix based on its magnitude. \n * Suffixes: [\"\", \"k\", \"M\", \"B\", \"T\"]; 1000 is k, 1000000 is M, 1000000000 is B.\n * For example:\n *      input: 999 output: 999\n *      input: 1549 output: 1.5k\n *      input: 1000 output: 1k\n *      input: 1234567890123 output: 1.2T\n * @param {number} number - The number to abbreviate.\n * @returns {string} - The abbreviated string representation of the number.\n */\nfunction abbreviateNumber(number) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Abbreviates a number to a string with a suffix based on its magnitude.suffix [\"\", \"k\", \"M\", \"B\", \"T\"] 1000 is k,1000000 is M,1000000000 is B\n * For example:\n *      input: 999 output: 999\n *      input: 1549 output: 1.5k\n *      input: 1000 output: 1k\n *      input: 1234567890123 output: 1.2T\n * @param {number} number - The number to abbreviate.\n * @returns {string} - The abbreviated string representation of the number.\n */\nfunction abbreviateNumber(number: number): string {\n}", "test_code": "describe('abbreviateNumber', () => {\n    test('should return the same number for values less than 1000', () => {\n        expect(abbreviateNumber(999)).toBe('999');\n    });\n\n    test('should return \"1k\" for 1000', () => {\n        const result= abbreviateNumber(1000)\n        expect(['1k', '1.0k']).toContain(result);\n    });\n\n    test('should return \"1.5k\" for 1500', () => {\n        expect(abbreviateNumber(1500)).toBe('1.5k');\n    });\n\n    test('should return \"1M\" for 1 million', () => {\n        const result = abbreviateNumber(1000000);\n        expect(['1M', '1.0M']).toContain(result);\n    });\n\n    test('should return \"25M\" for 25 million', () => {\n        expect(abbreviateNumber(25000000)).toBe('25M');\n    });\n\n    test('should return \"1B\" for 1 billion', () => {\n        const result = abbreviateNumber(1000000000)\n        expect(['1B', '1.0B']).toContain(result);\n    });\n\n    test('should return \"1.2T\" for 1.2 trillion', () => {\n        expect(abbreviateNumber(1234567890123)).toBe('1.2T');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Abbreviates a number to a string with a suffix based on its magnitude.suffix [\"\", \"k\", \"M\", \"B\", \"T\"] 1000 is k,1000000 is M,1000000000 is B\n * For example:\n *      input: 999 output: 999\n *      input: 1549 output: 1.5k\n *      input: 1000 output: 1k\n *      input: 1234567890123 output: 1.2T\n * @param {number} number - The number to abbreviate.\n * @returns {string} - The abbreviated string representation of the number.\n */\nfunction abbreviateNumber(number: number): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Abbreviates a number to a string with a suffix based on its magnitude. \n * Suffixes: [\"\", \"k\", \"M\", \"B\", \"T\"] \n * 1000 is k, 1000000 is M, 1000000000 is B.\n * For example:\n *      input: 999 output: 999\n *      input: 1549 output: 1.5k\n *      input: 1000 output: 1k\n *      input: 1234567890123 output: 1.2T\n * @param number - The number to abbreviate.\n * @return The abbreviated string representation of the number.\n */\nstd::string abbreviateNumber(double number){}", "test_code": "TEST_CASE(\"abbreviateNumber\") {\n    SECTION(\"should return the same number for values less than 1000\") {\n        REQUIRE(abbreviateNumber(999) == \"999\");\n    }\n\n    SECTION(\"should return '1k' for 1000\") {\n        std::string result = abbreviateNumber(1000);\n        REQUIRE(result == \"1k\" || result == \"1.0k\");\n    }\n\n    SECTION(\"should return '1.5k' for 1500\") {\n        REQUIRE(abbreviateNumber(1500) == \"1.5k\");\n    }\n\n    SECTION(\"should return '1M' for 1 million\") {\n        std::string result = abbreviateNumber(1000000);\n        REQUIRE(result == \"1M\" || result == \"1.0M\");\n    }\n\n    SECTION(\"should return '25M' for 25 million\") {\n        REQUIRE(abbreviateNumber(25000000) == \"25M\");\n    }\n\n    SECTION(\"should return '1B' for 1 billion\") {\n        std::string result = abbreviateNumber(1000000000);\n        REQUIRE(result == \"1B\" || result == \"1.0B\");\n    }\n\n    SECTION(\"should return '1.2T' for 1.2 trillion\") {\n        REQUIRE(abbreviateNumber(1234567890123) == \"1.2T\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Abbreviates a number to a string with a suffix based on its magnitude. \n * Suffixes: [\"\", \"k\", \"M\", \"B\", \"T\"] \n * 1000 is k, 1000000 is M, 1000000000 is B.\n * For example:\n *      input: 999 output: 999\n *      input: 1549 output: 1.5k\n *      input: 1000 output: 1k\n *      input: 1234567890123 output: 1.2T\n * @param number - The number to abbreviate.\n * @return The abbreviated string representation of the number.\n */\nstd::string abbreviateNumber(double number){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Abbreviates a number to a string with a suffix based on its magnitude. \n * Suffix [\"\", \"k\", \"M\", \"B\", \"T\"]; 1000 is k, 1000000 is M, 1000000000 is B.\n * For example:\n *      input: 999 output: 999\n *      input: 1549 output: 1.5k\n *      input: 1000 output: 1k\n *      input: 1234567890123 output: 1.2T\n * @param number - The number to abbreviate.\n * @return - The abbreviated string representation of the number.\n */\npublic static String abbreviateNumber(double number) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void testAbbreviateNumber_LessThan1000() {\n        assertEquals(\"999\", NumberAbbreviator.abbreviateNumber(999));\n    }\n\n    @Test\n    public void testAbbreviateNumber_Exactly1000() {\n        String result = NumberAbbreviator.abbreviateNumber(1000);\n        assertTrue(result.equals(\"1k\") || result.equals(\"1.0k\"));\n    }\n\n    @Test\n    public void testAbbreviateNumber_1500() {\n        assertEquals(\"1.5k\", NumberAbbreviator.abbreviateNumber(1500));\n    }\n\n    @Test\n    public void testAbbreviateNumber_OneMillion() {\n        String result = NumberAbbreviator.abbreviateNumber(1000000);\n        assertTrue(result.equals(\"1M\") || result.equals(\"1.0M\"));\n    }\n\n    @Test\n    public void testAbbreviateNumber_TwentyFiveMillion() {\n        assertEquals(\"25M\", NumberAbbreviator.abbreviateNumber(25000000));\n    }\n\n    @Test\n    public void testAbbreviateNumber_OneBillion() {\n        String result = NumberAbbreviator.abbreviateNumber(1000000000);\n        assertTrue(result.equals(\"1B\") || result.equals(\"1.0B\"));\n    }\n\n    @Test\n    public void testAbbreviateNumber_OnePointTwoTrillion() {\n        assertEquals(\"1.2T\", NumberAbbreviator.abbreviateNumber(1234567890123));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Abbreviates a number to a string with a suffix based on its magnitude. \n * Suffix [\"\", \"k\", \"M\", \"B\", \"T\"]; 1000 is k, 1000000 is M, 1000000000 is B.\n * For example:\n *      input: 999 output: 999\n *      input: 1549 output: 1.5k\n *      input: 1000 output: 1k\n *      input: 1234567890123 output: 1.2T\n * @param number - The number to abbreviate.\n * @return - The abbreviated string representation of the number.\n */\npublic static String abbreviateNumber(double number) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 582, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Converts the parameter dictionary to the query parameter in the url", "language_version_list": {"python": {"code_signature": "def to_query_string(params: dict) -> str:\n    \"\"\"\n    Converts a dictionary of parameters to a query string.\n\n    For example:\n        - Input: {'search': 'test', 'page': 1, 'size': 10}\n        - Output: '?search=test&page=1&size=10'\n\n    Args:\n        params (dict): The parameters to convert. The keys should be strings\n                       and values can be of any type that can be converted to a string.\n\n    Returns:\n        str: The query string representation of the parameters.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestToQueryString(unittest.TestCase):\n\n    def test_convert_simple_object_to_query_string(self):\n        params = {'search': 'test', 'page': 1, 'size': 10}\n        result = to_query_string(params)\n        self.assertEqual(result, '?search=test&page=1&size=10')\n\n    def test_encode_special_characters_in_query_string(self):\n        params = {'search': 'hello world', 'filter': 'price < \\$50'}\n        result = to_query_string(params)\n        self.assertEqual(result, '?search=hello%20world&filter=price%20%3C%20%2450')\n\n    def test_handle_empty_string_values(self):\n        params = {'search': '', 'page': 1}\n        result = to_query_string(params)\n        self.assertEqual(result, '?search=&page=1')\n\n    def test_handle_boolean_values(self):\n        params = {'isActive': True, 'isVerified': False}\n        result = to_query_string(params)\n        self.assertEqual(result, '?isActive=True&isVerified=False')\n\n", "prompt": "please write a python function , the function signature as below def to_query_string(params: dict) -> str:\n    \"\"\"\n    Converts a dictionary of parameters to a query string.\n\n    For example:\n        - Input: {'search': 'test', 'page': 1, 'size': 10}\n        - Output: '?search=test&page=1&size=10'\n\n    Args:\n        params (dict): The parameters to convert. The keys should be strings\n                       and values can be of any type that can be converted to a string.\n\n    Returns:\n        str: The query string representation of the parameters.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts an object to a query string.\n * For example:\n *      input: { search: 'test', page: 1, size: 10 };\n *      output: ?search=test&page=1&size=10\n *\n * @param {Object} params - The parameters to convert.\n * @returns {string} - The query string.\n */\nfunction toQueryString(params) {}", "test_code": "describe('toQueryString', () => {\n\n    test('should convert a simple object to a query string', () => {\n        const params = { search: 'test', page: 1, size: 10 };\n        const result = toQueryString(params);\n        expect(result).toBe('?search=test&page=1&size=10');\n    });\n\n    test('should encode special characters in the query string', () => {\n        const params = { search: 'hello world', filter: 'price < $50' };\n        const result = toQueryString(params);\n        expect(result).toBe('?search=hello%20world&filter=price%20%3C%20%2450');\n    });\n\n    test('should handle empty string values', () => {\n        const params = { search: '', page: 1 };\n        const result = toQueryString(params);\n        expect(result).toBe('?search=&page=1');\n    });\n\n    test('should handle boolean values', () => {\n        const params = { isActive: true, isVerified: false };\n        const result = toQueryString(params);\n        expect(result).toBe('?isActive=true&isVerified=false');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts an object to a query string.\n * For example:\n *      input: { search: 'test', page: 1, size: 10 };\n *      output: ?search=test&page=1&size=10\n *\n * @param {Object} params - The parameters to convert.\n * @returns {string} - The query string.\n */\nfunction toQueryString(params) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts an object to a query string.\n * For example:\n *      input: { search: 'test', page: 1, size: 10 };\n *      output: ?search=test&page=1&size=10\n *\n * @param {Record<string, any>} params - The parameters to convert.\n * @returns {string} - The query string.\n */\nfunction toQueryString(params: Record<string, any>): string {\n}", "test_code": "describe('toQueryString', () => {\n\n    test('should convert a simple object to a query string', () => {\n        const params = {search: 'test', page: 1, size: 10};\n        const result = toQueryString(params);\n        expect(result).toBe('?search=test&page=1&size=10');\n    });\n\n\n    test('should encode special characters in the query string', () => {\n        const params = {search: 'hello world', filter: 'price < \\$50'};\n        const result = toQueryString(params);\n        expect(result).toBe('?search=hello%20world&filter=price%20%3C%20%2450');\n    });\n\n    test('should handle empty string values', () => {\n        const params = {search: '', page: 1};\n        const result = toQueryString(params);\n        expect(result).toBe('?search=&page=1');\n    });\n\n    test('should handle boolean values', () => {\n        const params = {isActive: true, isVerified: false};\n        const result = toQueryString(params);\n        expect(result).toBe('?isActive=true&isVerified=false');\n    });\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Converts an object to a query string.\n * For example:\n *      input: { search: 'test', page: 1, size: 10 };\n *      output: ?search=test&page=1&size=10\n *\n * @param {Record<string, any>} params - The parameters to convert.\n * @returns {string} - The query string.\n */\nfunction toQueryString(params: Record<string, any>): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts an object to a query string.\n * For example:\n *      input: { \"search\": \"test\", \"page\": \"1\", \"size\": \"10\" };\n *      output: ?search=test&page=1&size=10\n *\n * @param params - The parameters to convert.\n * @returns The query string.\n */\nstd::string toQueryString(const std::map<std::string, std::string>& params){}", "test_code": "TEST_CASE(\"toQueryString\") {\n    SECTION(\"should convert a simple object to a query string\") {\n        std::map<std::string, std::string> params = {{\"search\", \"test\"}, {\"page\", \"1\"}, {\"size\", \"10\"}};\n        std::string result = toQueryString(params);\n        REQUIRE(result == \"?search=test&page=1&size=10\");\n    }\n\n    SECTION(\"should encode special characters in the query string\") {\n        std::map<std::string, std::string> params = {{\"search\", \"hello world\"}, {\"filter\", \"price < $50\"}};\n        std::string result = toQueryString(params);\n        REQUIRE(result == \"?search=hello%20world&filter=price%20%3C%20%2450\");\n    }\n\n    SECTION(\"should handle empty string values\") {\n        std::map<std::string, std::string> params = {{\"search\", \"\"}, {\"page\", \"1\"}};\n        std::string result = toQueryString(params);\n        REQUIRE(result == \"?search=&page=1\");\n    }\n\n    SECTION(\"should handle boolean values\") {\n        std::map<std::string, std::string> params = {{\"isActive\", \"true\"}, {\"isVerified\", \"false\"}};\n        std::string result = toQueryString(params);\n        REQUIRE(result == \"?isActive=true&isVerified=false\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts an object to a query string.\n * For example:\n *      input: { \"search\": \"test\", \"page\": \"1\", \"size\": \"10\" };\n *      output: ?search=test&page=1&size=10\n *\n * @param params - The parameters to convert.\n * @returns The query string.\n */\nstd::string toQueryString(const std::map<std::string, std::string>& params){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a map to a query string.\n *\n * @param params - The parameters to convert.\n * @return - The query string.\n */\npublic static String toQueryString(Map<String, Object> params) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Tester {\n\n    @Test\n    public void testToQueryString_SimpleObject() {\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"search\", \"test\");\n        params.put(\"page\", 1);\n        params.put(\"size\", 10);\n\n        String result = QueryStringConverter.toQueryString(params);\n        assertEquals(\"?search=test&page=1&size=10\", result);\n    }\n\n    @Test\n    public void testToQueryString_EncodeSpecialCharacters() {\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"search\", \"hello world\");\n        params.put(\"filter\", \"price < $50\");\n\n        String result = QueryStringConverter.toQueryString(params);\n        assertEquals(\"?search=hello%20world&filter=price%20%3C%20%2450\", result);\n    }\n\n    @Test\n    public void testToQueryString_HandleEmptyStringValues() {\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"search\", \"\");\n        params.put(\"page\", 1);\n\n        String result = QueryStringConverter.toQueryString(params);\n        assertEquals(\"?search=&page=1\", result);\n    }\n\n    @Test\n    public void testToQueryString_HandleBooleanValues() {\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"isActive\", true);\n        params.put(\"isVerified\", false);\n\n        String result = QueryStringConverter.toQueryString(params);\n        assertEquals(\"?isActive=true&isVerified=false\", result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a map to a query string.\n *\n * @param params - The parameters to convert.\n * @return - The query string.\n */\npublic static String toQueryString(Map<String, Object> params) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 583, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Removes the parameters in the url query based on the given key", "language_version_list": {"python": {"code_signature": "def remove_query_param(url: str, key: str) -> str:\n    \"\"\"\n    Removes the specified parameter from the URL query string.\n\n    This function parses the URL, removes the specified query parameter,\n    and returns the modified URL. If the parameter does not exist,\n    the original URL is returned.\n\n    For example:\n        - Input: 'http://example.com/page?search=test&page=1', 'search'\n        - Output: 'http://example.com/page?page=1'\n\n    Args:\n        url (str): The URL from which to remove the parameter.\n        key (str): The key of the parameter to remove.\n\n    Returns:\n        str: The modified URL with the specified parameter removed.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestRemoveQueryParam(unittest.TestCase):\n\n    def test_remove_existing_parameter(self):\n        url = 'https://example.com?page=1&sort=asc&filter=red'\n        result = remove_query_param(url, 'sort')\n        self.assertEqual(result, 'https://example.com/?page=1&filter=red')\n\n    def test_no_modification_if_parameter_does_not_exist(self):\n        url = 'https://example.com?page=1&filter=red'\n        result = remove_query_param(url, 'sort')\n        self.assertEqual(result, 'https://example.com/?page=1&filter=red')\n\n    def test_return_original_url_if_no_query_parameters(self):\n        url = 'https://example.com'\n        result = remove_query_param(url, 'sort')\n        self.assertEqual(result, 'https://example.com/')\n\n    def test_remove_multiple_occurrences_of_a_parameter(self):\n        url = 'https://example.com?page=1&filter=red&filter=blue'\n        result = remove_query_param(url, 'filter')\n        self.assertEqual(result, 'https://example.com/?page=1')\n\n    def test_handle_encoded_characters_in_parameter(self):\n        url = 'https://example.com?page=1&sort=asc&filter=hello%20world'\n        result = remove_query_param(url, 'filter')\n        self.assertEqual(result, 'https://example.com/?page=1&sort=asc')\n\n    def test_handle_case_when_parameter_is_only_one_in_url(self):\n        url = 'https://example.com?sort=asc'\n        result = remove_query_param(url, 'sort')\n        self.assertEqual(result, 'https://example.com/')\n", "prompt": "please write a python function , the function signature as below def remove_query_param(url: str, key: str) -> str:\n    \"\"\"\n    Removes the specified parameter from the URL query string.\n\n    This function parses the URL, removes the specified query parameter,\n    and returns the modified URL. If the parameter does not exist,\n    the original URL is returned.\n\n    For example:\n        - Input: 'http://example.com/page?search=test&page=1', 'search'\n        - Output: 'http://example.com/page?page=1'\n\n    Args:\n        url (str): The URL from which to remove the parameter.\n        key (str): The key of the parameter to remove.\n\n    Returns:\n        str: The modified URL with the specified parameter removed.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Removes the specified parameter from the URL query string.\n *\n * @param {string} url - The URL from which to remove the parameter.\n * @param {string} key - The key of the parameter to remove.\n * @returns {string} - The modified URL with the specified parameter removed.\n */\nfunction removeQueryParam(url, key) {}", "test_code": "describe('removeQueryParam', () => {\n    test('should remove an existing parameter from the URL', () => {\n        const url = 'https://example.com?page=1&sort=asc&filter=red';\n        const result = removeQueryParam(url, 'sort');\n        expect(result).toBe('https://example.com/?page=1&filter=red');\n    });\n\n    test('should not modify the URL if the parameter does not exist', () => {\n        const url = 'https://example.com?page=1&filter=red';\n        const result = removeQueryParam(url, 'sort');\n        expect(result).toBe('https://example.com/?page=1&filter=red');\n    });\n\n    test('should return the original URL if there are no query parameters', () => {\n        const url = 'https://example.com';\n        const result = removeQueryParam(url, 'sort');\n        expect(result).toBe('https://example.com/');\n    });\n\n    test('should remove multiple occurrences of a parameter', () => {\n        const url = 'https://example.com?page=1&filter=red&filter=blue';\n        const result = removeQueryParam(url, 'filter');\n        expect(result).toBe('https://example.com/?page=1');\n    });\n\n    test('should handle encoded characters in the parameter', () => {\n        const url = 'https://example.com?page=1&sort=asc&filter=hello%20world';\n        const result = removeQueryParam(url, 'filter');\n        expect(result).toBe('https://example.com/?page=1&sort=asc');\n    });\n\n    test('should handle the case when the parameter is the only one in the URL', () => {\n        const url = 'https://example.com?sort=asc';\n        const result = removeQueryParam(url, 'sort');\n        expect(result).toBe('https://example.com/');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Removes the specified parameter from the URL query string.\n *\n * @param {string} url - The URL from which to remove the parameter.\n * @param {string} key - The key of the parameter to remove.\n * @returns {string} - The modified URL with the specified parameter removed.\n */\nfunction removeQueryParam(url, key) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Removes the specified parameter from the URL query string.\n *\n * @param {string} url - The URL from which to remove the parameter.\n * @param {string} key - The key of the parameter to remove.\n * @returns {string} - The modified URL with the specified parameter removed.\n */\nfunction removeQueryParam(url: string, key: string): string {\n}", "test_code": "describe('removeQueryParam', () => {\n    test('should remove an existing parameter from the URL', () => {\n        const url = 'https://example.com?page=1&sort=asc&filter=red';\n        const result = removeQueryParam(url, 'sort');\n        expect(result).toBe('https://example.com/?page=1&filter=red');\n    });\n\n    test('should not modify the URL if the parameter does not exist', () => {\n        const url = 'https://example.com?page=1&filter=red';\n        const result = removeQueryParam(url, 'sort');\n        expect(result).toBe('https://example.com/?page=1&filter=red');\n    });\n\n    test('should return the original URL if there are no query parameters', () => {\n        const url = 'https://example.com';\n        const result = removeQueryParam(url, 'sort');\n        expect(result).toBe('https://example.com/');\n    });\n\n    test('should remove multiple occurrences of a parameter', () => {\n        const url = 'https://example.com?page=1&filter=red&filter=blue';\n        const result = removeQueryParam(url, 'filter');\n        expect(result).toBe('https://example.com/?page=1');\n    });\n\n    test('should handle encoded characters in the parameter', () => {\n        const url = 'https://example.com?page=1&sort=asc&filter=hello%20world';\n        const result = removeQueryParam(url, 'filter');\n        expect(result).toBe('https://example.com/?page=1&sort=asc');\n    });\n\n    test('should handle the case when the parameter is the only one in the URL', () => {\n        const url = 'https://example.com?sort=asc';\n        const result = removeQueryParam(url, 'sort');\n        expect(result).toBe('https://example.com/');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Removes the specified parameter from the URL query string.\n *\n * @param {string} url - The URL from which to remove the parameter.\n * @param {string} key - The key of the parameter to remove.\n * @returns {string} - The modified URL with the specified parameter removed.\n */\nfunction removeQueryParam(url: string, key: string): string {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "please write a cpp function , the function signature as below ", "addition_info": ""}, "java": {"code_signature": "/**\n * Removes the specified parameter from the URL query string.\n *\n * @param url The URL from which to remove the parameter.\n * @param key The key of the parameter to remove.\n * @return The modified URL with the specified parameter removed.\n * @throws URISyntaxException If the URL is malformed.\n */\npublic static String removeQueryParam(String url, String key) throws URISyntaxException {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void testRemoveExistingParameter() throws Exception {\n        String url = \"https://example.com?page=1&sort=asc&filter=red\";\n        String result = UrlUtils.removeQueryParam(url, \"sort\");\n        assertEquals(\"https://example.com/?page=1&filter=red\", result);\n    }\n\n    @Test\n    public void testNoModificationIfParameterDoesNotExist() throws Exception {\n        String url = \"https://example.com?page=1&filter=red\";\n        String result = UrlUtils.removeQueryParam(url, \"sort\");\n        assertEquals(\"https://example.com/?page=1&filter=red\", result);\n    }\n\n    @Test\n    public void testReturnOriginalUrlIfNoQueryParameters() throws Exception {\n        String url = \"https://example.com\";\n        String result = UrlUtils.removeQueryParam(url, \"sort\");\n        assertEquals(\"https://example.com/\", result);\n    }\n\n    @Test\n    public void testRemoveMultipleOccurrencesOfParameter() throws Exception {\n        String url = \"https://example.com?page=1&filter=red&filter=blue\";\n        String result = UrlUtils.removeQueryParam(url, \"filter\");\n        assertEquals(\"https://example.com/?page=1\", result);\n    }\n\n    @Test\n    public void testHandleEncodedCharactersInParameter() throws Exception {\n        String url = \"https://example.com?page=1&sort=asc&filter=hello%20world\";\n        String result = UrlUtils.removeQueryParam(url, \"filter\");\n        assertEquals(\"https://example.com/?page=1&sort=asc\", result);\n    }\n\n    @Test\n    public void testParameterIsOnlyOneInUrl() throws Exception {\n        String url = \"https://example.com?sort=asc\";\n        String result = UrlUtils.removeQueryParam(url, \"sort\");\n        assertEquals(\"https://example.com/\", result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Removes the specified parameter from the URL query string.\n *\n * @param url The URL from which to remove the parameter.\n * @param key The key of the parameter to remove.\n * @return The modified URL with the specified parameter removed.\n * @throws URISyntaxException If the URL is malformed.\n */\npublic static String removeQueryParam(String url, String key) throws URISyntaxException {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 584, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Detects whether the string is KEBAB_CASE", "language_version_list": {"python": {"code_signature": "def is_pascal_case(input: str) -> bool:\n    \"\"\"\n    Detects whether the string is in PASCAL_CASE.\n\n    In PASCAL_CASE, each word starts with an uppercase letter and\n    there are no spaces or underscores separating the words.\n\n    Args:\n        input (str): The string to check.\n\n    Returns:\n        bool: True if the string is in PASCAL_CASE, otherwise False.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsPascalCase(unittest.TestCase):\n\n    def test_valid_pascal_case(self):\n        \"\"\"Should return true for a valid PascalCase string.\"\"\"\n        self.assertTrue(is_pascal_case('PascalCase'))\n\n    def test_valid_pascal_case_multiple_words(self):\n        \"\"\"Should return true for a valid PascalCase string with multiple words.\"\"\"\n        self.assertTrue(is_pascal_case('PascalCaseExample'))\n\n    def test_starts_with_lowercase(self):\n        \"\"\"Should return false for a string that starts with a lowercase letter.\"\"\"\n        self.assertFalse(is_pascal_case('pascalCase'))\n\n    def test_with_underscores(self):\n        \"\"\"Should return false for a string with underscores.\"\"\"\n        self.assertFalse(is_pascal_case('Pascal_case'))\n\n    def test_empty_string(self):\n        \"\"\"Should return false for a string that is empty.\"\"\"\n        self.assertFalse(is_pascal_case(''))\n", "prompt": "please write a python function , the function signature as below def is_pascal_case(input: str) -> bool:\n    \"\"\"\n    Detects whether the string is in PASCAL_CASE.\n\n    In PASCAL_CASE, each word starts with an uppercase letter and\n    there are no spaces or underscores separating the words.\n\n    Args:\n        input (str): The string to check.\n\n    Returns:\n        bool: True if the string is in PASCAL_CASE, otherwise False.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Detects whether the string is in PASCAL_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in PASCAL_CASE, otherwise false.\n */\nfunction isPascalCase(input) {}", "test_code": "describe('isPascalCase', () => {\n    test('should return true for a valid PascalCase string', () => {\n        expect(isPascalCase('PascalCase')).toBe(true);\n    });\n\n    test('should return true for a valid PascalCase string with multiple words', () => {\n        expect(isPascalCase('PascalCaseExample')).toBe(true);\n    });\n\n    test('should return false for a string that starts with a lowercase letter', () => {\n        expect(isPascalCase('pascalCase')).toBe(false);\n    });\n\n    test('should return false for a string with underscores', () => {\n        expect(isPascalCase('Pascal_case')).toBe(false);\n    });\n\n    test('should return false for a string that is empty', () => {\n        expect(isPascalCase('')).toBe(false);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Detects whether the string is in PASCAL_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in PASCAL_CASE, otherwise false.\n */\nfunction isPascalCase(input) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Detects whether the string is in PASCAL_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in PASCAL_CASE, otherwise false.\n */\nfunction isPascalCase(input: string): boolean {\n}", "test_code": "describe('isPascalCase', () => {\n    test('should return true for a valid PascalCase string', () => {\n        expect(isPascalCase('PascalCase')).toBe(true);\n    });\n\n    test('should return true for a valid PascalCase string with multiple words', () => {\n        expect(isPascalCase('PascalCaseExample')).toBe(true);\n    });\n\n    test('should return false for a string that starts with a lowercase letter', () => {\n        expect(isPascalCase('pascalCase')).toBe(false);\n    });\n\n    test('should return false for a string with underscores', () => {\n        expect(isPascalCase('Pascal_case')).toBe(false);\n    });\n\n    test('should return false for a string that is empty', () => {\n        expect(isPascalCase('')).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Detects whether the string is in PASCAL_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in PASCAL_CASE, otherwise false.\n */\nfunction isPascalCase(input: string): boolean {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Detects whether the string is in PASCAL_CASE.\n *\n * @param input - The string to check.\n * @returns True if the string is in PASCAL_CASE, otherwise false.\n */\nbool isPascalCase(const std::string& input) {}", "test_code": "TEST_CASE(\"isPascalCase\", \"[PascalCase]\") {\n    REQUIRE(isPascalCase(\"PascalCase\") == true);\n    REQUIRE(isPascalCase(\"PascalCaseExample\") == true);\n    REQUIRE(isPascalCase(\"pascalCase\") == false);\n    REQUIRE(isPascalCase(\"Pascal_case\") == false);\n    REQUIRE(isPascalCase(\"\") == false);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Detects whether the string is in PASCAL_CASE.\n *\n * @param input - The string to check.\n * @returns True if the string is in PASCAL_CASE, otherwise false.\n */\nbool isPascalCase(const std::string& input) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Detects whether the string is in PASCAL_CASE.\n *\n * @param input - The string to check.\n * @return True if the string is in PASCAL_CASE, otherwise false.\n */\npublic boolean isPascalCase(String input) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void shouldReturnTrueForValidPascalCaseString() {\n        assertTrue(isPascalCase(\"PascalCase\"));\n    }\n\n    @Test\n    public void shouldReturnTrueForValidPascalCaseStringWithMultipleWords() {\n        assertTrue(isPascalCase(\"PascalCaseExample\"));\n    }\n\n    @Test\n    public void shouldReturnFalseForStringThatStartsWithLowercaseLetter() {\n        assertFalse(isPascalCase(\"pascalCase\"));\n    }\n\n    @Test\n    public void shouldReturnFalseForStringWithUnderscores() {\n        assertFalse(isPascalCase(\"Pascal_case\"));\n    }\n\n    @Test\n    public void shouldReturnFalseForEmptyString() {\n        assertFalse(isPascalCase(\"\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Detects whether the string is in PASCAL_CASE.\n *\n * @param input - The string to check.\n * @return True if the string is in PASCAL_CASE, otherwise false.\n */\npublic boolean isPascalCase(String input) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 585, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": " Detects whether the string is in CAMEL_CASE.", "language_version_list": {"python": {"code_signature": "def is_camel_case(input: str) -> bool:\n    \"\"\"\n    Detects whether the string is in CAMEL_CASE.\n\n    In CAMEL_CASE, the first letter of the first word is lowercase,\n    and each subsequent word starts with an uppercase letter, with no spaces or underscores\n    separating the words.\n\n    Args:\n        input (str): The string to check.\n\n    Returns:\n        bool: True if the string is in CAMEL_CASE, otherwise False.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsCamelCase(unittest.TestCase):\n\n    def test_valid_camel_case(self):\n        \"\"\"Should return true for a valid camelCase string.\"\"\"\n        self.assertTrue(is_camel_case('camelCase'))\n\n    def test_valid_camel_case_multiple_words(self):\n        \"\"\"Should return true for a valid camelCase string with multiple words.\"\"\"\n        self.assertTrue(is_camel_case('camelCaseExample'))\n\n    def test_uppercase_start(self):\n        \"\"\"Should return false for a string that starts with an uppercase letter.\"\"\"\n        self.assertFalse(is_camel_case('CamelCase'))\n\n    def test_underscores(self):\n        \"\"\"Should return false for a string with underscores.\"\"\"\n        self.assertFalse(is_camel_case('camel_case'))\n\n    def test_empty_string(self):\n        \"\"\"Should return false for an empty string.\"\"\"\n        self.assertFalse(is_camel_case(''))\n", "prompt": "please write a python function , the function signature as below def is_camel_case(input: str) -> bool:\n    \"\"\"\n    Detects whether the string is in CAMEL_CASE.\n\n    In CAMEL_CASE, the first letter of the first word is lowercase,\n    and each subsequent word starts with an uppercase letter, with no spaces or underscores\n    separating the words.\n\n    Args:\n        input (str): The string to check.\n\n    Returns:\n        bool: True if the string is in CAMEL_CASE, otherwise False.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Detects whether the string is in CAMEL_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in CAMEL_CASE, otherwise false.\n */\nfunction isCamelCase(input) {}", "test_code": "describe('isCamelCase', () => {\n    test('should return true for a valid camelCase string', () => {\n        expect(isCamelCase('camelCase')).toBe(true);\n    });\n\n    test('should return true for a valid camelCase string with multiple words', () => {\n        expect(isCamelCase('camelCaseExample')).toBe(true);\n    });\n\n    test('should return false for a string that starts with an uppercase letter', () => {\n        expect(isCamelCase('CamelCase')).toBe(false);\n    });\n\n    test('should return false for a string with underscores', () => {\n        expect(isCamelCase('camel_case')).toBe(false);\n    });\n\n    test('should return false for an empty string', () => {\n        expect(isCamelCase('')).toBe(false);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Detects whether the string is in CAMEL_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in CAMEL_CASE, otherwise false.\n */\nfunction isCamelCase(input) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Detects whether the string is in CAMEL_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in CAMEL_CASE, otherwise false.\n */\nfunction isCamelCase(input: string): boolean {\n}", "test_code": "describe('isCamelCase', () => {\n    test('should return true for a valid camelCase string', () => {\n        expect(isCamelCase('camelCase')).toBe(true);\n    });\n\n    test('should return true for a valid camelCase string with multiple words', () => {\n        expect(isCamelCase('camelCaseExample')).toBe(true);\n    });\n\n    test('should return false for a string that starts with an uppercase letter', () => {\n        expect(isCamelCase('CamelCase')).toBe(false);\n    });\n\n    test('should return false for a string with underscores', () => {\n        expect(isCamelCase('camel_case')).toBe(false);\n    });\n\n    test('should return false for an empty string', () => {\n        expect(isCamelCase('')).toBe(false);\n    });\n\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Detects whether the string is in CAMEL_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in CAMEL_CASE, otherwise false.\n */\nfunction isCamelCase(input: string): boolean {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Detects whether the string is in CAMEL_CASE.\n *\n * @param input - The string to check.\n * @returns true if the string is in CAMEL_CASE, otherwise false.\n */\nbool isCamelCase(const std::string& input) {}", "test_code": "TEST_CASE(\"isCamelCase\") {\n    SECTION(\"should return true for a valid camelCase string\") {\n        REQUIRE(isCamelCase(\"camelCase\") == true);\n    }\n\n    SECTION(\"should return true for a valid camelCase string with multiple words\") {\n        REQUIRE(isCamelCase(\"camelCaseExample\") == true);\n    }\n\n    SECTION(\"should return false for a string that starts with an uppercase letter\") {\n        REQUIRE(isCamelCase(\"CamelCase\") == false);\n    }\n\n    SECTION(\"should return false for a string with underscores\") {\n        REQUIRE(isCamelCase(\"camel_case\") == false);\n    }\n\n    SECTION(\"should return false for an empty string\") {\n        REQUIRE(isCamelCase(\"\") == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Detects whether the string is in CAMEL_CASE.\n *\n * @param input - The string to check.\n * @returns true if the string is in CAMEL_CASE, otherwise false.\n */\nbool isCamelCase(const std::string& input) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Detects whether the string is in CAMEL_CASE.\n *\n * @param input - The string to check.\n * @return True if the string is in CAMEL_CASE, otherwise false.\n */\npublic static boolean isCamelCase(String input) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\npublic class Tester {\n\n    @Test\n    public void testValidCamelCaseString() {\n        assertTrue(isCamelCase(\"camelCase\"));\n    }\n\n    @Test\n    public void testValidCamelCaseStringWithMultipleWords() {\n        assertTrue(isCamelCase(\"camelCaseExample\"));\n    }\n\n    @Test\n    public void testStringStartingWithUppercaseLetter() {\n        assertFalse(isCamelCase(\"CamelCase\"));\n    }\n\n    @Test\n    public void testStringWithUnderscores() {\n        assertFalse(isCamelCase(\"camel_case\"));\n    }\n\n    @Test\n    public void testEmptyString() {\n        assertFalse(isCamelCase(\"\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Detects whether the string is in CAMEL_CASE.\n *\n * @param input - The string to check.\n * @return True if the string is in CAMEL_CASE, otherwise false.\n */\npublic static boolean isCamelCase(String input) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 586, "code_type": "method", "original_language": "typescript", "question_type": "Data processing and transformation", "summary": "Detects whether the string is in SNAKE_CASE.", "language_version_list": {"python": {"code_signature": "def is_snake_case(input: str) -> bool:\n    \"\"\"\n    Detects whether the string is in SNAKE_CASE.\n\n    In SNAKE_CASE, all letters are lowercase, and words are separated by underscores.\n    There should be no leading or trailing underscores, and no spaces or other special characters.\n\n    Args:\n        input (str): The string to check.\n\n    Returns:\n        bool: True if the string is in SNAKE_CASE, otherwise False.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsSnakeCase(unittest.TestCase):\n\n    def test_valid_snake_case(self):\n        \"\"\"should return true for a valid snake_case string\"\"\"\n        self.assertTrue(is_snake_case('snake_case'))\n\n    def test_valid_snake_case_multiple_words(self):\n        \"\"\"should return true for a valid snake_case string with multiple words\"\"\"\n        self.assertTrue(is_snake_case('snake_case_example'))\n\n    def test_uppercase_start(self):\n        \"\"\"should return false for a string that starts with an uppercase letter\"\"\"\n        self.assertFalse(is_snake_case('Snake_Case'))\n\n    def test_mixed_case_letters(self):\n        \"\"\"should return false for a string with mixed case letters\"\"\"\n        self.assertFalse(is_snake_case('snakeCASE'))\n\n    def test_string_with_numbers(self):\n        \"\"\"should return false for a string with numbers\"\"\"\n        self.assertFalse(is_snake_case('snake_case_123'))\n\n    def test_empty_string(self):\n        \"\"\"should return false for an empty string\"\"\"\n        self.assertFalse(is_snake_case(''))\n", "prompt": "please write a python function , the function signature as below def is_snake_case(input: str) -> bool:\n    \"\"\"\n    Detects whether the string is in SNAKE_CASE.\n\n    In SNAKE_CASE, all letters are lowercase, and words are separated by underscores.\n    There should be no leading or trailing underscores, and no spaces or other special characters.\n\n    Args:\n        input (str): The string to check.\n\n    Returns:\n        bool: True if the string is in SNAKE_CASE, otherwise False.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Detects whether the string is in SNAKE_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in SNAKE_CASE, otherwise false.\n */\nfunction isSnakeCase(input) {}", "test_code": "describe('isSnakeCase', () => {\n    test('should return true for a valid snake_case string', () => {\n        expect(isSnakeCase('snake_case')).toBe(true);\n    });\n\n    test('should return true for a valid snake_case string with multiple words', () => {\n        expect(isSnakeCase('snake_case_example')).toBe(true);\n    });\n\n    test('should return false for a string that starts with an uppercase letter', () => {\n        expect(isSnakeCase('Snake_Case')).toBe(false);\n    });\n\n    test('should return false for a string with mixed case letters', () => {\n        expect(isSnakeCase('snakeCASE')).toBe(false);\n    });\n\n    test('should return false for a string with numbers', () => {\n        expect(isSnakeCase('snake_case_123')).toBe(false);\n    });\n\n    test('should return false for an empty string', () => {\n        expect(isSnakeCase('')).toBe(false);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Detects whether the string is in SNAKE_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in SNAKE_CASE, otherwise false.\n */\nfunction isSnakeCase(input) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Detects whether the string is in SNAKE_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in SNAKE_CASE, otherwise false.\n */\nfunction isSnakeCase(input: string): boolean {\n}", "test_code": "describe('isSnakeCase', () => {\n    test('should return true for a valid snake_case string', () => {\n        expect(isSnakeCase('snake_case')).toBe(true);\n    });\n\n    test('should return true for a valid snake_case string with multiple words', () => {\n        expect(isSnakeCase('snake_case_example')).toBe(true);\n    });\n\n    test('should return false for a string that starts with an uppercase letter', () => {\n        expect(isSnakeCase('Snake_Case')).toBe(false);\n    });\n\n    test('should return false for a string with mixed case letters', () => {\n        expect(isSnakeCase('snakeCASE')).toBe(false);\n    });\n\n    test('should return false for a string with numbers', () => {\n        expect(isSnakeCase('snake_case_123')).toBe(false);\n    });\n\n    test('should return false for an empty string', () => {\n        expect(isSnakeCase('')).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Detects whether the string is in SNAKE_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in SNAKE_CASE, otherwise false.\n */\nfunction isSnakeCase(input: string): boolean {\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Detects whether the string is in SNAKE_CASE.\n *\n * @param input - The string to check.\n * @returns True if the string is in SNAKE_CASE, otherwise false.\n */\nbool isSnakeCase(const std::string& input) {}", "test_code": "TEST_CASE(\"isSnakeCase\") {\n    SECTION(\"should return true for a valid snake_case string\") {\n        REQUIRE(isSnakeCase(\"snake_case\") == true);\n    }\n\n    SECTION(\"should return true for a valid snake_case string with multiple words\") {\n        REQUIRE(isSnakeCase(\"snake_case_example\") == true);\n    }\n\n    SECTION(\"should return false for a string that starts with an uppercase letter\") {\n        REQUIRE(isSnakeCase(\"Snake_Case\") == false);\n    }\n\n    SECTION(\"should return false for a string with mixed case letters\") {\n        REQUIRE(isSnakeCase(\"snakeCASE\") == false);\n    }\n\n    SECTION(\"should return false for a string with numbers\") {\n        REQUIRE(isSnakeCase(\"snake_case_123\") == false);\n    }\n\n    SECTION(\"should return false for an empty string\") {\n        REQUIRE(isSnakeCase(\"\") == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Detects whether the string is in SNAKE_CASE.\n *\n * @param input - The string to check.\n * @returns True if the string is in SNAKE_CASE, otherwise false.\n */\nbool isSnakeCase(const std::string& input) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Detects whether the string is in SNAKE_CASE.\n *\n * @param input The string to check.\n * @return True if the string is in SNAKE_CASE, otherwise false.\n */\npublic static boolean isSnakeCase(String input) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testValidSnakeCase() {\n        assertTrue(StringUtil.isSnakeCase(\"snake_case\"));\n    }\n\n    @Test\n    public void testValidSnakeCaseMultipleWords() {\n        assertTrue(StringUtil.isSnakeCase(\"snake_case_example\"));\n    }\n\n    @Test\n    public void testStartsWithUppercase() {\n        assertFalse(StringUtil.isSnakeCase(\"Snake_Case\"));\n    }\n\n    @Test\n    public void testMixedCaseLetters() {\n        assertFalse(StringUtil.isSnakeCase(\"snakeCASE\"));\n    }\n\n    @Test\n    public void testWithNumbers() {\n        assertFalse(StringUtil.isSnakeCase(\"snake_case_123\"));\n    }\n\n    @Test\n    public void testEmptyString() {\n        assertFalse(StringUtil.isSnakeCase(\"\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Detects whether the string is in SNAKE_CASE.\n *\n * @param input The string to check.\n * @return True if the string is in SNAKE_CASE, otherwise false.\n */\npublic static boolean isSnakeCase(String input) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
