[{"task_id": 1, "code_type": "method", "original_language": "python", "file_path": "sd12key.github.io\\8af95a6737f9fa2f7bebe49425e4c59068230b3b\\src\\parser.py", "question_type": "Data processing and transformation", "summary": "convert the input string, first see if it is an integer, if it is converted to an integer, if it is not, see if it is a floating point number, if yes, convert to a floating point number, if neither, return the original string", "language_version_list": {"python": {"code_signature": "from typing import Union\n\n\ndef numerical_str_convert(value: str) -> Union[int, float, str]:\n    \"\"\"\n    convert the input string, first see if it is an integer, if it is converted to an integer, if it is not, see if it is a floating point number, if yes, convert to a floating point number, if neither, return the original string\n\n    Args:\n        value (str): input value str\n    Returns:\n       Union[int, float, str]: convert model_answer_result\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSmartConvert(unittest.TestCase):\n    def test_convert_integer(self):\n        self.assertEqual(numerical_str_convert(\"123\"), 123, \"Should convert to integer\")\n\n    def test_convert_float(self):\n        self.assertEqual(numerical_str_convert(\"123.45\"), 123.45, \"Should convert to float\")\n\n    def test_convert_non_numeric_string(self):\n        self.assertEqual(numerical_str_convert(\"abc\"), \"abc\", \"Should remain a string\")\n\n    def test_convert_negative_integer(self):\n        self.assertEqual(numerical_str_convert(\"-456\"), -456, \"Should convert to negative integer\")\n\n    def test_convert_negative_float(self):\n        self.assertEqual(numerical_str_convert(\"-456.78\"), -456.78, \"Should convert to negative float\")\n", "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef numerical_str_convert(value: str) -> Union[int, float, str]:\n    \"\"\"\n    convert the input string, first see if it is an integer, if it is converted to an integer, if it is not, see if it is a floating point number, if yes, convert to a floating point number, if neither, return the original string\n\n    Args:\n        value (str): input value str\n    Returns:\n       Union[int, float, str]: convert model_answer_result\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "union convertresult {\n    int intValue;\n    float floatValue;\n    std::string stringValue;\n\n    // Destructor to handle cleanup\n    ~ConvertResult() {\n        // Free memory if stringValue is used\n        if (stringValue.data() != nullptr) {\n            stringValue.~basic_string();\n        }\n    }\n\n    // Equality operator to compare union values\n    bool operator==(const int& other) const {\n        return intValue == other;\n    }\n\n    bool operator==(const float& other) const {\n        return floatValue == other;\n    }\n\n    bool operator==(const std::string& other) const {\n        return stringValue == other;\n    }\n};\n/**\n * @brief Convert the input string, first see if it is an integer, if it is converted to an integer,\n * if it is not, see if it is a floating point number, if yes, convert to a floating point number,\n * if neither, return the original string.\n *\n * @param value The input string value.\n * @return A union containing the converted value (int, float, or original string).\n */\nConvertResult numerical_str_convert(const std::string& value) {}", "test_code": "TEST_CASE(\"Test Smart Convert\") {\n    SECTION(\"Convert Integer\") {\n        REQUIRE(numerical_str_convert(\"123\").intValue == 123);\n    }\n\n    SECTION(\"Convert Float\") {\n        REQUIRE(numerical_str_convert(\"123.45\").floatValue == Approx(123.45f));\n    }\n\n    SECTION(\"Convert Non-Numeric String\") {\n        REQUIRE(numerical_str_convert(\"abc\").stringValue == \"abc\");\n    }\n\n    SECTION(\"Convert Negative Integer\") {\n        REQUIRE(numerical_str_convert(\"-456\").intValue == -456);\n    }\n\n    SECTION(\"Convert Negative Float\") {\n        REQUIRE(numerical_str_convert(\"-456.78\").floatValue == Approx(-456.78f));\n    }\n}", "prompt": "please write a cpp function , the function signature as below union convertresult {\n    int intValue;\n    float floatValue;\n    std::string stringValue;\n\n    // Destructor to handle cleanup\n    ~ConvertResult() {\n        // Free memory if stringValue is used\n        if (stringValue.data() != nullptr) {\n            stringValue.~basic_string();\n        }\n    }\n\n    // Equality operator to compare union values\n    bool operator==(const int& other) const {\n        return intValue == other;\n    }\n\n    bool operator==(const float& other) const {\n        return floatValue == other;\n    }\n\n    bool operator==(const std::string& other) const {\n        return stringValue == other;\n    }\n};\n/**\n * @brief Convert the input string, first see if it is an integer, if it is converted to an integer,\n * if it is not, see if it is a floating point number, if yes, convert to a floating point number,\n * if neither, return the original string.\n *\n * @param value The input string value.\n * @return A union containing the converted value (int, float, or original string).\n */\nConvertResult numerical_str_convert(const std::string& value) {}", "addition_info": "union ConvertResult {\n    int intValue;\n    float floatValue;\n    std::string stringValue;\n\n    // Destructor to handle cleanup\n    ~ConvertResult() {\n        // Free memory if stringValue is used\n        if (stringValue.data() != nullptr) {\n            stringValue.~basic_string();\n        }\n    }\n\n    // Equality operator to compare union values\n    bool operator==(const int& other) const {\n        return intValue == other;\n    }\n\n    bool operator==(const float& other) const {\n        return floatValue == other;\n    }\n\n    bool operator==(const std::string& other) const {\n        return stringValue == other;\n    }\n};"}, "java": {"code_signature": "/**\n * Converts the input string to an integer or a float if possible.\n * If the string cannot be converted to a number, it returns the original string.\n *\n * @param value the input string to be converted\n * @return the converted value as an Integer, Float, or the original String\n */\npublic static Object numericalStrConvert(String value) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n\npublic class Tester {\n\n    /**\n     * Tests conversion of an integer string.\n     */\n    @Test\n    public void testConvertInteger() {\n        assertEquals(\"Should convert to integer\", 123, numericalStrConvert(\"123\"));\n    }\n\n    /**\n     * Tests conversion of a float string.\n     */\n    @Test\n    public void testConvertFloat() {\n        assertEquals(\"Should convert to float\", 123.45f, (Float) numericalStrConvert(\"123.45\"), 0.001f);\n    }\n\n    /**\n     * Tests conversion of a non-numeric string.\n     */\n    @Test\n    public void testConvertNonNumericString() {\n        assertEquals(\"Should remain a string\", \"abc\", numericalStrConvert(\"abc\"));\n    }\n\n    /**\n     * Tests conversion of a negative integer string.\n     */\n    @Test\n    public void testConvertNegativeInteger() {\n        assertEquals(\"Should convert to negative integer\", -456, numericalStrConvert(\"-456\"));\n    }\n\n    /**\n     * Tests conversion of a negative float string.\n     */\n    @Test\n    public void testConvertNegativeFloat() {\n        assertEquals(\"Should convert to negative float\", -456.78f, (Float) numericalStrConvert(\"-456.78\"), 0.001f);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts the input string to an integer or a float if possible.\n * If the string cannot be converted to a number, it returns the original string.\n *\n * @param value the input string to be converted\n * @return the converted value as an Integer, Float, or the original String\n */\npublic static Object numericalStrConvert(String value) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 5, "code_type": "method", "original_language": "python", "file_path": "lglsi2-24\\ffe7f23207afeacb1c4e6dab20a013ef91f9051e\\generated-code\\matrix_operations.py", "question_type": "Algorithm and data structure", "summary": "Implementing matrix multiplication\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef matrix_multiply(matrixA: List[List[int]], matrixB: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Implementing matrix multiplication\n\n    Args:\n        matrixA (List[List[int]]): matrix A\n        matrixB (List[List[int]]): matrix B\n\n    Returns:\n        List[List[int]]: matrixA matrixB multiplication model_answer_result\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestMatrixMultiplication(unittest.TestCase):\n    def test_standard_matrices(self):\n        mat1 = [[1, 2], [3, 4]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[19, 22], [43, 50]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected, \"Should correctly multiply standard matrices\")\n\n    def test_identity_matrix(self):\n        mat1 = [[1, 0], [0, 1]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[5, 6], [7, 8]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected,\n                         \"Multiplying by the identity matrix should yield the answer.py matrix\")\n\n    def test_zero_matrix(self):\n        mat1 = [[0, 0], [0, 0]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[0, 0], [0, 0]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected,\n                         \"Multiplying by the zero matrix should yield a zero matrix\")\n\n    def test_square_matrix_multiplication(self):\n        mat1 = [[1, 2], [3, 4]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[19, 22], [43, 50]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected,\n                         \"The multiplication of two square matrices should yield the correct product\")\n\n    def test_large_identity_matrix(self):\n        mat1 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n        mat2 = [[5, 6, 7], [8, 9, 10], [11, 12, 13]]\n        expected = [[5, 6, 7], [8, 9, 10], [11, 12, 13]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected,\n                         \"Multiplying by the larger identity matrix should yield the answer matrix\")\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef matrix_multiply(matrixA: List[List[int]], matrixB: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Implementing matrix multiplication\n\n    Args:\n        matrixA (List[List[int]]): matrix A\n        matrixB (List[List[int]]): matrix B\n\n    Returns:\n        List[List[int]]: matrixA matrixB multiplication model_answer_result\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Implements matrix multiplication.\n *\n * @param matrixA The first matrix.\n * @param matrixB The second matrix.\n *\n * @return std::vector<std::vector<int>> The result of multiplying matrixA by matrixB.\n */\nstd::vector<std::vector<int>> matrix_multiply(const std::vector<std::vector<int>>& matrixA, const std::vector<std::vector<int>>& matrixB) {}", "test_code": "TEST_CASE(\"Test Matrix Multiplication\", \"[matrix_multiply]\") {\n    SECTION(\"Standard Matrices\") {\n        std::vector<std::vector<int>> mat1 = {{1, 2}, {3, 4}};\n        std::vector<std::vector<int>> mat2 = {{5, 6}, {7, 8}};\n        std::vector<std::vector<int>> expected = {{19, 22}, {43, 50}};\n        \n        REQUIRE(matrix_multiply(mat1, mat2) == expected);\n    }\n\n    SECTION(\"Identity Matrix\") {\n        std::vector<std::vector<int>> mat1 = {{1, 0}, {0, 1}};\n        std::vector<std::vector<int>> mat2 = {{5, 6}, {7, 8}};\n        std::vector<std::vector<int>> expected = {{5, 6}, {7, 8}};\n        \n        REQUIRE(matrix_multiply(mat1, mat2) == expected);\n    }\n\n    SECTION(\"Zero Matrix\") {\n        std::vector<std::vector<int>> mat1 = {{0, 0}, {0, 0}};\n        std::vector<std::vector<int>> mat2 = {{5, 6}, {7, 8}};\n        std::vector<std::vector<int>> expected = {{0, 0}, {0, 0}};\n        \n        REQUIRE(matrix_multiply(mat1, mat2) == expected);\n    }\n\n    SECTION(\"Square Matrix Multiplication\") {\n        std::vector<std::vector<int>> mat1 = {{1, 2}, {3, 4}};\n        std::vector<std::vector<int>> mat2 = {{5, 6}, {7, 8}};\n        std::vector<std::vector<int>> expected = {{19, 22}, {43, 50}};\n        \n        REQUIRE(matrix_multiply(mat1, mat2) == expected);\n    }\n\n    SECTION(\"Large Identity Matrix\") {\n        std::vector<std::vector<int>> mat1 = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};\n        std::vector<std::vector<int>> mat2 = {{5, 6, 7}, {8, 9, 10}, {11, 12, 13}};\n        std::vector<std::vector<int>> expected = {{5, 6, 7}, {8, 9, 10}, {11, 12, 13}};\n        \n        REQUIRE(matrix_multiply(mat1, mat2) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Implements matrix multiplication.\n *\n * @param matrixA The first matrix.\n * @param matrixB The second matrix.\n *\n * @return std::vector<std::vector<int>> The result of multiplying matrixA by matrixB.\n */\nstd::vector<std::vector<int>> matrix_multiply(const std::vector<std::vector<int>>& matrixA, const std::vector<std::vector<int>>& matrixB) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Implements matrix multiplication.\n *\n * @param matrixA The first matrix.\n * @param matrixB The second matrix.\n * @return The result of multiplying matrixA by matrixB.\n * @throws IllegalArgumentException If the matrices cannot be multiplied due to incompatible dimensions.\n */\npublic static List<List<Integer>> matrixMultiply(List<List<Integer>> matrixA, List<List<Integer>> matrixB) {}", "test_code": "package org.real.temp;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class Tester {\n\n    @Test\n    public void testStandardMatrices() {\n        List<List<Integer>> mat1 = new ArrayList<>();\n        mat1.add(new ArrayList<>(List.of(1, 2)));\n        mat1.add(new ArrayList<>(List.of(3, 4)));\n\n        List<List<Integer>> mat2 = new ArrayList<>();\n        mat2.add(new ArrayList<>(List.of(5, 6)));\n        mat2.add(new ArrayList<>(List.of(7, 8)));\n\n        List<List<Integer>> expected = new ArrayList<>();\n        expected.add(new ArrayList<>(List.of(19, 22)));\n        expected.add(new ArrayList<>(List.of(43, 50)));\n\n        assertEquals(expected, matrixMultiply(mat1, mat2), \"Should correctly multiply standard matrices\");\n    }\n\n    @Test\n    public void testIdentityMatrix() {\n        List<List<Integer>> mat1 = new ArrayList<>();\n        mat1.add(new ArrayList<>(List.of(1, 0)));\n        mat1.add(new ArrayList<>(List.of(0, 1)));\n\n        List<List<Integer>> mat2 = new ArrayList<>();\n        mat2.add(new ArrayList<>(List.of(5, 6)));\n        mat2.add(new ArrayList<>(List.of(7, 8)));\n\n        List<List<Integer>> expected = new ArrayList<>();\n        expected.add(new ArrayList<>(List.of(5, 6)));\n        expected.add(new ArrayList<>(List.of(7, 8)));\n\n        assertEquals(expected, matrixMultiply(mat1, mat2), \"Multiplying by the identity matrix should yield the answer matrix\");\n    }\n\n    @Test\n    public void testZeroMatrix() {\n        List<List<Integer>> mat1 = new ArrayList<>();\n        mat1.add(new ArrayList<>(List.of(0, 0)));\n        mat1.add(new ArrayList<>(List.of(0, 0)));\n\n        List<List<Integer>> mat2 = new ArrayList<>();\n        mat2.add(new ArrayList<>(List.of(5, 6)));\n        mat2.add(new ArrayList<>(List.of(7, 8)));\n\n        List<List<Integer>> expected = new ArrayList<>();\n        expected.add(new ArrayList<>(List.of(0, 0)));\n        expected.add(new ArrayList<>(List.of(0, 0)));\n\n        assertEquals(expected, matrixMultiply(mat1, mat2), \"Multiplying by the zero matrix should yield a zero matrix\");\n    }\n\n    @Test\n    public void testSquareMatrixMultiplication() {\n        List<List<Integer>> mat1 = new ArrayList<>();\n        mat1.add(new ArrayList<>(List.of(1, 2)));\n        mat1.add(new ArrayList<>(List.of(3, 4)));\n\n        List<List<Integer>> mat2 = new ArrayList<>();\n        mat2.add(new ArrayList<>(List.of(5, 6)));\n        mat2.add(new ArrayList<>(List.of(7, 8)));\n\n        List<List<Integer>> expected = new ArrayList<>();\n        expected.add(new ArrayList<>(List.of(19, 22)));\n        expected.add(new ArrayList<>(List.of(43, 50)));\n\n        assertEquals(expected, matrixMultiply(mat1, mat2), \"The multiplication of two square matrices should yield the correct product\");\n    }\n\n    @Test\n    public void testLargeIdentityMatrix() {\n        List<List<Integer>> mat1 = new ArrayList<>();\n        mat1.add(new ArrayList<>(List.of(1, 0, 0)));\n        mat1.add(new ArrayList<>(List.of(0, 1, 0)));\n        mat1.add(new ArrayList<>(List.of(0, 0, 1)));\n\n        List<List<Integer>> mat2 = new ArrayList<>();\n        mat2.add(new ArrayList<>(List.of(5, 6, 7)));\n        mat2.add(new ArrayList<>(List.of(8, 9, 10)));\n        mat2.add(new ArrayList<>(List.of(11, 12, 13)));\n\n        List<List<Integer>> expected = new ArrayList<>();\n        expected.add(new ArrayList<>(List.of(5, 6, 7)));\n        expected.add(new ArrayList<>(List.of(8, 9, 10)));\n        expected.add(new ArrayList<>(List.of(11, 12, 13)));\n\n        assertEquals(expected, matrixMultiply(mat1, mat2), \"Multiplying by the larger identity matrix should yield the answer matrix\");\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Implements matrix multiplication.\n *\n * @param matrixA The first matrix.\n * @param matrixB The second matrix.\n * @return The result of multiplying matrixA by matrixB.\n * @throws IllegalArgumentException If the matrices cannot be multiplied due to incompatible dimensions.\n */\npublic static List<List<Integer>> matrixMultiply(List<List<Integer>> matrixA, List<List<Integer>> matrixB) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 6, "code_type": "method", "original_language": "python", "file_path": "brickflow\\49ec3c352b56fed12ee38cf357ee4c10e75cda53\\tools\\modify_schema.py", "question_type": "Data processing and transformation", "summary": "simplify file paths in windows systems into name strings, for example, D:\\downlaod\\text.py is simplified to D_download_text.py\n", "language_version_list": {"python": {"code_signature": "def simplify_windows_path(path: str) -> str:\n    \"\"\"\n    simplify file paths in windows systems into name strings.\n    For example:\n        input: C:\\\\Users\\\\User\\\\file.txt\n        output: C_Users_User_file.txt\n    Args:\n        path (str): windows file path str\n\n    Returns:\n        str: simplify path str\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSimplifyWindowsPath(unittest.TestCase):\n    def test_simple_path(self):\n        self.assertEqual(simplify_windows_path(r\"C:\\Users\\User\\file.txt\"), \"C_Users_User_file.txt\")\n\n    def test_simple_path2(self):\n        self.assertEqual(simplify_windows_path(r\"D:\\User\\file.txt\"), \"D_User_file.txt\")\n\n    def test_path_with_spaces(self):\n        self.assertEqual(simplify_windows_path(r\"E:\\New Folder\\my file.docx\"), \"E_New Folder_my file.docx\")\n\n    def test_nested_directories(self):\n        self.assertEqual(simplify_windows_path(r\"G:\\folder1\\folder2\\folder3\\file.jpeg\"),\n                         \"G_folder1_folder2_folder3_file.jpeg\")\n", "prompt": "please write a python function , the function signature as below def simplify_windows_path(path: str) -> str:\n    \"\"\"\n    simplify file paths in windows systems into name strings.\n    For example:\n        input: C:\\\\Users\\\\User\\\\file.txt\n        output: C_Users_User_file.txt\n    Args:\n        path (str): windows file path str\n\n    Returns:\n        str: simplify path str\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Simplify file paths in Windows systems into name strings.\n * For example:\n *     Input: C:\\\\Users\\\\User\\\\file.txt\n *     Output: C_Users_User_file.txt\n *\n * @param path The Windows file path string.\n * @return The simplified path string.\n */\nstd::string simplifyWindowsPath(const std::string& path) {}", "test_code": "TEST_CASE(\"Test Simplify Windows Path\") {\n    SECTION(\"Simple Path\") {\n        CHECK(simplifyWindowsPath(\"C:\\\\Users\\\\User\\\\file.txt\") == \"C_Users_User_file.txt\");\n    }\n\n    SECTION(\"Simple Path 2\") {\n        CHECK(simplifyWindowsPath(\"D:\\\\User\\\\file.txt\") == \"D_User_file.txt\");\n    }\n\n    SECTION(\"Path with Spaces\") {\n        CHECK(simplifyWindowsPath(\"E:\\\\New Folder\\\\my file.docx\") == \"E_New Folder_my file.docx\");\n    }\n\n    SECTION(\"Nested Directories\") {\n        CHECK(simplifyWindowsPath(\"G:\\\\folder1\\\\folder2\\\\folder3\\\\file.jpeg\") == \"G_folder1_folder2_folder3_file.jpeg\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Simplify file paths in Windows systems into name strings.\n * For example:\n *     Input: C:\\\\Users\\\\User\\\\file.txt\n *     Output: C_Users_User_file.txt\n *\n * @param path The Windows file path string.\n * @return The simplified path string.\n */\nstd::string simplifyWindowsPath(const std::string& path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Simplifies a given Windows path by replacing the drive letter and colon with the drive letter followed by an underscore,\n * replacing all backslashes with underscores, and removing any leading or trailing underscores.\n *\n * @param path The Windows path to be simplified.\n * @return The simplified path.\n */\npublic static String simplifyWindowsPath(String path) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testSimplePath() {\n        assertEquals(\"C_Users_User_file.txt\", simplifyWindowsPath(\"C:\\\\Users\\\\User\\\\file.txt\"));\n    }\n\n    @Test\n    public void testSimplePath2() {\n        assertEquals(\"D_User_file.txt\", simplifyWindowsPath(\"D:\\\\User\\\\file.txt\"));\n    }\n\n    @Test\n    public void testPathWithSpaces() {\n        assertEquals(\"E_New Folder_my file.docx\", simplifyWindowsPath(\"E:\\\\New Folder\\\\my file.docx\"));\n    }\n\n    @Test\n    public void testNestedDirectories() {\n        assertEquals(\"G_folder1_folder2_folder3_file.jpeg\", simplifyWindowsPath(\"G:\\\\folder1\\\\folder2\\\\folder3\\\\file.jpeg\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Simplifies a given Windows path by replacing the drive letter and colon with the drive letter followed by an underscore,\n * replacing all backslashes with underscores, and removing any leading or trailing underscores.\n *\n * @param path The Windows path to be simplified.\n * @return The simplified path.\n */\npublic static String simplifyWindowsPath(String path) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 8, "code_type": "method", "original_language": "python", "file_path": "PQC_Seminar_S2024\\d29c067dec5571a529bc2d95e1d62f1a6b75b32c\\Kyber_Decrypt.py", "question_type": "Algorithm and data structure", "summary": "Implement decryption based on polynomials and keys\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef perform_polynomial_decryption(degree: int, modulus: int, key: List[int], encrypted_data: List[int]) -> List[int]:\n    \"\"\"\n    Implement decryption based on polynomials and keys\n    Args:\n        degree (int): The highest degree of a polynomial is added by one\n        modulus (int): Modulus to use when encrypting question\n        key (List[int]): An array of encrypted keys\n        encrypted_data (List[int]): An array of encrypted question\n\n    Returns: decrypted question\n\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestDecryptFunction(unittest.TestCase):\n    def test_basic_functionality(self):\n        self.assertEqual(perform_polynomial_decryption(4, 5, [1, 2, 3, 4], [5, 6, 7, 8]), [4, 4, 4, 4])\n\n    def test_zero_secret_key(self):\n        self.assertEqual(perform_polynomial_decryption(3, 7, [0, 0, 0], [6, 13, 20]), [6, 6, 6])\n\n    def test_zero_ciphertext(self):\n        self.assertEqual(perform_polynomial_decryption(3, 9, [1, 2, 3], [0, 0, 0]), [8, 7, 6])\n\n    def test_large_values(self):\n        self.assertEqual(perform_polynomial_decryption(2, 1000, [500, 500], [1000, 1000]), [500, 500])\n\n\ndef perform_polynomial_decryption(degree, modulus, key, encrypted_data):\n    # Decrypts the polynomial based encryption by reversing the encryption steps\n    decrypted_data = [0] * degree\n\n    for index in range(degree):\n        # Reversing encryption: subtract key and take modulo\n        decrypted_data[index] = (encrypted_data[index] - key[index]) % modulus\n\n    return decrypted_data\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef perform_polynomial_decryption(degree: int, modulus: int, key: List[int], encrypted_data: List[int]) -> List[int]:\n    \"\"\"\n    Implement decryption based on polynomials and keys\n    Args:\n        degree (int): The highest degree of a polynomial is added by one\n        modulus (int): Modulus to use when encrypting question\n        key (List[int]): An array of encrypted keys\n        encrypted_data (List[int]): An array of encrypted question\n\n    Returns: decrypted question\n\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Implement decryption based on polynomials and keys\n *\n * @param degree The highest degree of a polynomial is added by one\n * @param modulus Modulus to use when encrypting question\n * @param key An array of encrypted keys\n * @param encrypted_data An array of encrypted question\n *\n * @return Decrypted question\n */\nstd::vector<int> perform_polynomial_decryption(int degree, int modulus, const std::vector<int>& key, const std::vector<int>& encrypted_data) {}", "test_code": "TEST_CASE(\"Test Decrypt Function\", \"[decrypt]\") {\n    SECTION(\"Basic functionality\") {\n        REQUIRE(perform_polynomial_decryption(4, 5, {1, 2, 3, 4}, {5, 6, 7, 8}) == std::vector<int>({4, 4, 4, 4}));\n    }\n\n    SECTION(\"Zero secret key\") {\n        REQUIRE(perform_polynomial_decryption(3, 7, {0, 0, 0}, {6, 13, 20}) == std::vector<int>({6, 6, 6}));\n    }\n\n    SECTION(\"Zero ciphertext\") {\n        REQUIRE(perform_polynomial_decryption(3, 9, {1, 2, 3}, {0, 0, 0}) == std::vector<int>({8, 7, 6}));\n    }\n\n    SECTION(\"Large values\") {\n        REQUIRE(perform_polynomial_decryption(2, 1000, {500, 500}, {1000, 1000}) == std::vector<int>({500, 500}));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Implement decryption based on polynomials and keys\n *\n * @param degree The highest degree of a polynomial is added by one\n * @param modulus Modulus to use when encrypting question\n * @param key An array of encrypted keys\n * @param encrypted_data An array of encrypted question\n *\n * @return Decrypted question\n */\nstd::vector<int> perform_polynomial_decryption(int degree, int modulus, const std::vector<int>& key, const std::vector<int>& encrypted_data) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Implement decryption based on polynomials and keys.\n *\n * @param degree The highest degree of a polynomial is added by one.\n * @param modulus Modulus to use when encrypting the question.\n * @param key An array of encrypted keys.\n * @param encryptedData An array of encrypted question.\n * @return Decrypted question as a List of integers.\n */\npublic static List<Integer> performPolynomialDecryption(int degree, int modulus, List<Integer> key, List<Integer> encryptedData) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testBasicFunctionality() {\n        assertEquals(Arrays.asList(4, 4, 4, 4),\n                     performPolynomialDecryption(4, 5, Arrays.asList(1, 2, 3, 4), Arrays.asList(5, 6, 7, 8)));\n    }\n\n    @Test\n    public void testZeroSecretKey() {\n        assertEquals(Arrays.asList(6, 6, 6),\n                     performPolynomialDecryption(3, 7, Arrays.asList(0, 0, 0), Arrays.asList(6, 13, 20)));\n    }\n\n    @Test\n    public void testZeroCiphertext() {\n        assertEquals(Arrays.asList(8, 7, 6),\n                     performPolynomialDecryption(3, 9, Arrays.asList(1, 2, 3), Arrays.asList(0, 0, 0)));\n    }\n\n    @Test\n    public void testLargeValues() {\n        assertEquals(Arrays.asList(500, 500),\n                     performPolynomialDecryption(2, 1000, Arrays.asList(500, 500), Arrays.asList(1000, 1000)));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Implement decryption based on polynomials and keys.\n *\n * @param degree The highest degree of a polynomial is added by one.\n * @param modulus Modulus to use when encrypting the question.\n * @param key An array of encrypted keys.\n * @param encryptedData An array of encrypted question.\n * @return Decrypted question as a List of integers.\n */\npublic static List<Integer> performPolynomialDecryption(int degree, int modulus, List<Integer> key, List<Integer> encryptedData) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 9, "code_type": "method", "original_language": "python", "file_path": "polygon_problem\\74813e88e55dcb2b442e127658b714df489b16a4\\Graph.py", "question_type": "Data processing and transformation", "summary": "Check whether A point is on a line formed by two points, such as point C is on a line formed by points A and B", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef is_point_on_line(A: List[int], B: List[int], C: List[int]) -> bool:\n    \"\"\"\n    Check whether A point is on a line formed by two points, such as point C is on a line formed by points A and B\n    Args:\n        A (List[int]): point A xy\n        B (List[int]): point B xy\n        C (List[int]): point C xy\n\n    Returns: is C in line of A B\n\n    \"\"\"", "test_code": "import unittest\n\n\ndef is_point_on_line(A, B, C):\n    (x_a, y_a), (x_b, y_b), (x_c, y_c) = A, B, C\n    if x_a == x_b:  # Check for vertical line\n        return x_c == x_a\n    return (y_c - y_a) * (x_b - x_a) == (y_b - y_a) * (x_c - x_a)\n\n\nclass TestPointOnLine(unittest.TestCase):\n    def test_point_on_line(self):\n        A = (0, 0)\n        B = (10, 10)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_point_not_on_line(self):\n        A = (0, 0)\n        B = (10, 10)\n        C = (5, 6)\n        self.assertFalse(is_point_on_line(A, B, C))\n\n    def test_vertical_line(self):\n        A = (5, 0)\n        B = (5, 10)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_horizontal_line(self):\n        A = (0, 5)\n        B = (10, 5)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_point_not_on_vertical_line(self):\n        A = (5, 0)\n        B = (5, 10)\n        C = (6, 5)\n        self.assertFalse(is_point_on_line(A, B, C))\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef is_point_on_line(A: List[int], B: List[int], C: List[int]) -> bool:\n    \"\"\"\n    Check whether A point is on a line formed by two points, such as point C is on a line formed by points A and B\n    Args:\n        A (List[int]): point A xy\n        B (List[int]): point B xy\n        C (List[int]): point C xy\n\n    Returns: is C in line of A B\n\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Check whether a point is on a line formed by two points, such as point C is on a line formed by points A and B.\n *\n * @param A A vector containing the x and y coordinates of point A.\n * @param B A vector containing the x and y coordinates of point B.\n * @param C A vector containing the x and y coordinates of point C.\n *\n * @return True if point C is on the line formed by points A and B, false otherwise.\n */\nbool is_point_on_line(const std::vector<int>& A, const std::vector<int>& B, const std::vector<int>& C) {}", "test_code": "TEST_CASE(\"Test Point On Line\", \"[point_on_line]\") {\n    SECTION(\"Point on line\") {\n        std::vector<int> A = {0, 0};\n        std::vector<int> B = {10, 10};\n        std::vector<int> C = {5, 5};\n        REQUIRE(is_point_on_line(A, B, C));\n    }\n\n    SECTION(\"Point not on line\") {\n        std::vector<int> A = {0, 0};\n        std::vector<int> B = {10, 10};\n        std::vector<int> C = {5, 6};\n        REQUIRE_FALSE(is_point_on_line(A, B, C));\n    }\n\n    SECTION(\"Vertical line\") {\n        std::vector<int> A = {5, 0};\n        std::vector<int> B = {5, 10};\n        std::vector<int> C = {5, 5};\n        REQUIRE(is_point_on_line(A, B, C));\n    }\n\n    SECTION(\"Horizontal line\") {\n        std::vector<int> A = {0, 5};\n        std::vector<int> B = {10, 5};\n        std::vector<int> C = {5, 5};\n        REQUIRE(is_point_on_line(A, B, C));\n    }\n\n    SECTION(\"Point not on vertical line\") {\n        std::vector<int> A = {5, 0};\n        std::vector<int> B = {5, 10};\n        std::vector<int> C = {6, 5};\n        REQUIRE_FALSE(is_point_on_line(A, B, C));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Check whether a point is on a line formed by two points, such as point C is on a line formed by points A and B.\n *\n * @param A A vector containing the x and y coordinates of point A.\n * @param B A vector containing the x and y coordinates of point B.\n * @param C A vector containing the x and y coordinates of point C.\n *\n * @return True if point C is on the line formed by points A and B, false otherwise.\n */\nbool is_point_on_line(const std::vector<int>& A, const std::vector<int>& B, const std::vector<int>& C) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks whether point C is on the line formed by points A and B.\n *\n * @param A an array of two integers representing point A (x, y)\n * @param B an array of two integers representing point B (x, y)\n * @param C an array of two integers representing point C (x, y)\n * @return true if point C is on the line formed by points A and B, false otherwise\n */\npublic static boolean isPointOnLine(int[] A, int[] B, int[] C) {}", "test_code": "package org.real.temp;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport org.junit.Test;\npublic class Tester {\n    @Test\n    public void testPointOnLine() {\n        int[] A = {0, 0};\n        int[] B = {10, 10};\n        int[] C = {5, 5};\n        assertTrue(isPointOnLine(A, B, C));\n    }\n\n    @Test\n    public void testPointNotOnLine() {\n        int[] A = {0, 0};\n        int[] B = {10, 10};\n        int[] C = {5, 6};\n        assertFalse(isPointOnLine(A, B, C));\n    }\n\n    @Test\n    public void testVerticalLine() {\n        int[] A = {5, 0};\n        int[] B = {5, 10};\n        int[] C = {5, 5};\n        assertTrue(isPointOnLine(A, B, C));\n    }\n\n    @Test\n    public void testHorizontalLine() {\n        int[] A = {0, 5};\n        int[] B = {10, 5};\n        int[] C = {5, 5};\n        assertTrue(isPointOnLine(A, B, C));\n    }\n\n    @Test\n    public void testPointNotOnVerticalLine() {\n        int[] A = {5, 0};\n        int[] B = {5, 10};\n        int[] C = {6, 5};\n        assertFalse(isPointOnLine(A, B, C));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks whether point C is on the line formed by points A and B.\n *\n * @param A an array of two integers representing point A (x, y)\n * @param B an array of two integers representing point B (x, y)\n * @param C an array of two integers representing point C (x, y)\n * @return true if point C is on the line formed by points A and B, false otherwise\n */\npublic static boolean isPointOnLine(int[] A, int[] B, int[] C) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 11, "code_type": "class", "original_language": "python", "file_path": "metadata-extraction\\f8a36bb0e7f0ad483a8cef3f4e20d45e623d6db8\\text\\compare.py", "question_type": "Algorithm and data structure", "summary": "Implement a dictionary tree for fast string retrieval and storage\n", "language_version_list": {"python": {"code_signature": "class Trie:\n    \"\"\"\n    Implement a dictionary tree for fast string retrieval and storage\n    \"\"\"\n\n    def insert(self, word):\n        pass\n\n    def search(self, word):\n        pass\n\n    def starts_with(self, prefix):\n        pass\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n", "test_code": "import unittest\n\n\nclass TestTrie(unittest.TestCase):\n    def setUp(self):\n        self.trie = Trie()\n        self.trie.insert(\"apple\")\n        self.trie.insert(\"app\")\n        self.trie.insert(\"apricot\")\n        self.trie.insert(\"banana\")\n        self.trie.insert(\"carrot\")\n        self.trie.insert(\"car\")\n        self.trie.insert(\"care\")\n        self.trie.insert(\"\")\n        self.trie.insert(\"Hello\")\n        self.trie.insert(\"hello\")\n\n    def test_basic_search(self):\n        self.assertTrue(self.trie.search(\"apple\"))\n        self.assertTrue(self.trie.search(\"app\"))\n        self.assertTrue(self.trie.search(\"apricot\"))\n\n    def test_unsuccessful_search(self):\n        self.assertFalse(self.trie.search(\"bandana\"))\n\n    def test_prefix_search(self):\n        self.assertTrue(self.trie.starts_with(\"car\"))\n        self.assertTrue(self.trie.starts_with(\"care\"))\n        self.assertFalse(self.trie.starts_with(\"cat\"))\n\n    def test_empty_string(self):\n        self.assertTrue(self.trie.search(\"\"))\n        self.assertTrue(self.trie.starts_with(\"\"))\n\n    def test_case_sensitivity(self):\n        self.assertTrue(self.trie.search(\"Hello\"))\n        self.assertTrue(self.trie.search(\"hello\"))\n        self.assertFalse(self.trie.search(\"HELLO\"))\n", "prompt": "please write a python class , the class signature as below class Trie:\n    \"\"\"\n    Implement a dictionary tree for fast string retrieval and storage\n    \"\"\"\n\n    def insert(self, word):\n        pass\n\n    def search(self, word):\n        pass\n\n    def starts_with(self, prefix):\n        pass\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "// TrieNode class\nclass TrieNode {\npublic:\n    std::unordered_map<char, TrieNode*> children;\n\n    TrieNode() {}\n};\n\n// Trie class\nclass Trie {\npublic:\n    /**\n     * Implement a dictionary tree for fast string retrieval and storage\n     */\n    TrieNode* root;\n\n    Trie() : root(new TrieNode()) {}\n\n    ~Trie() {\n        delete root;\n    }\n\n    // Insert a word into the trie\n    void insert(const std::string& word);\n\n    // Search for a word in the trie\n    bool search(const std::string& word);\n\n    // Check if there is any word in the trie that starts with the given prefix\n    bool starts_with(const std::string& prefix);\n};\n\n// Implementation of the insert method\nvoid Trie::insert(const std::string& word) {\n    // Implementation goes here\n    // ...\n}\n\n// Implementation of the search method\nbool Trie::search(const std::string& word) {\n    // Implementation goes here\n    // ...\n}\n\n// Implementation of the starts_with method\nbool Trie::starts_with(const std::string& prefix) {\n    // Implementation goes here\n    // ...\n}", "test_code": "TEST_CASE(\"Test Trie operations\", \"[Trie]\") {\n    Trie trie;\n    trie.insert(\"apple\");\n    trie.insert(\"app\");\n    trie.insert(\"apricot\");\n    trie.insert(\"banana\");\n    trie.insert(\"carrot\");\n    trie.insert(\"car\");\n    trie.insert(\"care\");\n    trie.insert(\"\");\n    trie.insert(\"Hello\");\n    trie.insert(\"hello\");\n\n    SECTION(\"Basic search\") {\n        REQUIRE(trie.search(\"apple\"));\n        REQUIRE(trie.search(\"app\"));\n        REQUIRE(trie.search(\"apricot\"));\n    }\n\n    SECTION(\"Unsuccessful search\") {\n        REQUIRE_FALSE(trie.search(\"bandana\"));\n    }\n\n    SECTION(\"Prefix search\") {\n        REQUIRE(trie.starts_with(\"car\"));\n        REQUIRE(trie.starts_with(\"care\"));\n        REQUIRE_FALSE(trie.starts_with(\"cat\"));\n    }\n\n    SECTION(\"Empty string\") {\n        REQUIRE(trie.search(\"\"));\n        REQUIRE(trie.starts_with(\"\"));\n    }\n\n    SECTION(\"Case sensitivity\") {\n        REQUIRE(trie.search(\"Hello\"));\n        REQUIRE(trie.search(\"hello\"));\n        REQUIRE_FALSE(trie.search(\"HELLO\"));\n    }\n}", "prompt": "please write a cpp class , the class signature as below // TrieNode class\nclass TrieNode {\npublic:\n    std::unordered_map<char, TrieNode*> children;\n\n    TrieNode() {}\n};\n\n// Trie class\nclass Trie {\npublic:\n    /**\n     * Implement a dictionary tree for fast string retrieval and storage\n     */\n    TrieNode* root;\n\n    Trie() : root(new TrieNode()) {}\n\n    ~Trie() {\n        delete root;\n    }\n\n    // Insert a word into the trie\n    void insert(const std::string& word);\n\n    // Search for a word in the trie\n    bool search(const std::string& word);\n\n    // Check if there is any word in the trie that starts with the given prefix\n    bool starts_with(const std::string& prefix);\n};\n\n// Implementation of the insert method\nvoid Trie::insert(const std::string& word) {\n    // Implementation goes here\n    // ...\n}\n\n// Implementation of the search method\nbool Trie::search(const std::string& word) {\n    // Implementation goes here\n    // ...\n}\n\n// Implementation of the starts_with method\nbool Trie::starts_with(const std::string& prefix) {\n    // Implementation goes here\n    // ...\n}", "addition_info": ""}, "java": {"code_signature": "public class Trie {\n\n    /**\n     * Inserts a word into the Trie.\n     *\n     * @param word the word to insert\n     */\n    public void insert(String word) {\n        // Implementation goes here\n    }\n\n    /**\n     * Searches for a word in the Trie.\n     *\n     * @param word the word to search for\n     * @return true if the word is found, false otherwise\n     */\n    public boolean search(String word) {\n        // Implementation goes here\n    }\n\n    /**\n     * Checks if there is any word in the Trie that starts with the given prefix.\n     *\n     * @param prefix the prefix to check\n     * @return true if there is a word starting with the prefix, false otherwise\n     */\n    public boolean startsWith(String prefix) {\n        // Implementation goes here\n    }\n}\n\n/**\n * Represents a node in the Trie.\n */\npublic class TrieNode {\n\n    /**\n     * A map of child nodes indexed by characters.\n     */\n    private final java.util.Map<Character, TrieNode> children = new java.util.HashMap<>();\n\n    /**\n     * Constructs a new TrieNode.\n     */\n    public TrieNode() {\n        // Constructor implementation goes here\n    }\n\n    /**\n     * Checks if this node has a child with the specified character.\n     *\n     * @param ch the character to check\n     * @return true if the child exists, false otherwise\n     */\n    public boolean hasChild(char ch) {\n        return children.containsKey(ch);\n    }\n\n    /**\n     * Gets the child node with the specified character.\n     *\n     * @param ch the character of the child\n     * @return the child node, or null if it does not exist\n     */\n    public TrieNode getChild(char ch) {\n        return children.get(ch);\n    }\n\n    /**\n     * Adds a child node with the specified character.\n     *\n     * @param ch the character of the child\n     */\n    public void addChild(char ch) {\n        if (!children.containsKey(ch)) {\n            children.put(ch, new TrieNode());\n        }\n    }\n\n    /**\n     * Sets the end-of-word flag for this node.\n     */\n    public void setEndOfWord() {\n        // Implementation goes here\n    }\n\n    /**\n     * Checks if this node represents the end of a word.\n     *\n     * @return true if this node is the end of a word, false otherwise\n     */\n    public boolean isEndOfWord() {\n        // Implementation goes here\n    }\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    private Trie trie;\n\n    @Before\n    public void setUp() {\n        trie = new Trie();\n        trie.insert(\"apple\");\n        trie.insert(\"app\");\n        trie.insert(\"apricot\");\n        trie.insert(\"banana\");\n        trie.insert(\"carrot\");\n        trie.insert(\"car\");\n        trie.insert(\"care\");\n        trie.insert(\"\");\n        trie.insert(\"Hello\");\n        trie.insert(\"hello\");\n    }\n\n    @Test\n    public void testBasicSearch() {\n        assertTrue(trie.search(\"apple\"));\n        assertTrue(trie.search(\"app\"));\n        assertTrue(trie.search(\"apricot\"));\n    }\n\n    @Test\n    public void testUnsuccessfulSearch() {\n        assertFalse(trie.search(\"bandana\"));\n    }\n\n    @Test\n    public void testPrefixSearch() {\n        assertTrue(trie.startsWith(\"car\"));\n        assertTrue(trie.startsWith(\"care\"));\n        assertFalse(trie.startsWith(\"cat\"));\n    }\n\n    @Test\n    public void testEmptyString() {\n        assertTrue(trie.search(\"\"));\n        assertTrue(trie.startsWith(\"\"));\n    }\n\n    @Test\n    public void testCaseSensitivity() {\n        assertTrue(trie.search(\"Hello\"));\n        assertTrue(trie.search(\"hello\"));\n        assertFalse(trie.search(\"HELLO\"));\n    }\n}", "prompt": "please write a java class , the function signature as below public class Trie {\n\n    /**\n     * Inserts a word into the Trie.\n     *\n     * @param word the word to insert\n     */\n    public void insert(String word) {\n        // Implementation goes here\n    }\n\n    /**\n     * Searches for a word in the Trie.\n     *\n     * @param word the word to search for\n     * @return true if the word is found, false otherwise\n     */\n    public boolean search(String word) {\n        // Implementation goes here\n    }\n\n    /**\n     * Checks if there is any word in the Trie that starts with the given prefix.\n     *\n     * @param prefix the prefix to check\n     * @return true if there is a word starting with the prefix, false otherwise\n     */\n    public boolean startsWith(String prefix) {\n        // Implementation goes here\n    }\n}\n\n/**\n * Represents a node in the Trie.\n */\npublic class TrieNode {\n\n    /**\n     * A map of child nodes indexed by characters.\n     */\n    private final java.util.Map<Character, TrieNode> children = new java.util.HashMap<>();\n\n    /**\n     * Constructs a new TrieNode.\n     */\n    public TrieNode() {\n        // Constructor implementation goes here\n    }\n\n    /**\n     * Checks if this node has a child with the specified character.\n     *\n     * @param ch the character to check\n     * @return true if the child exists, false otherwise\n     */\n    public boolean hasChild(char ch) {\n        return children.containsKey(ch);\n    }\n\n    /**\n     * Gets the child node with the specified character.\n     *\n     * @param ch the character of the child\n     * @return the child node, or null if it does not exist\n     */\n    public TrieNode getChild(char ch) {\n        return children.get(ch);\n    }\n\n    /**\n     * Adds a child node with the specified character.\n     *\n     * @param ch the character of the child\n     */\n    public void addChild(char ch) {\n        if (!children.containsKey(ch)) {\n            children.put(ch, new TrieNode());\n        }\n    }\n\n    /**\n     * Sets the end-of-word flag for this node.\n     */\n    public void setEndOfWord() {\n        // Implementation goes here\n    }\n\n    /**\n     * Checks if this node represents the end of a word.\n     *\n     * @return true if this node is the end of a word, false otherwise\n     */\n    public boolean isEndOfWord() {\n        // Implementation goes here\n    }\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 12, "code_type": "method", "original_language": "python", "file_path": "MARLLPettingZoo\\e519dab2f60ac9ede7f932cc39793e293a249be6\\Custom-Environment\\custom-environment\\marll_v0.1.py", "question_type": "Data processing and transformation", "summary": "Calculates the Euclidean distance between two agents based on their coordinates in the observations.", "language_version_list": {"python": {"code_signature": "def calculate_distance(agent1: str, agent2: str, observations: dict) -> float:\n    \"\"\"\n    Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n\n    Args:\n        agent1 (str): String representation of agent1's identifier.\n        agent2 (str): String representation of agent2's identifier.\n        observations (dict): Dictionary containing observation question with agent identifiers as keys.Each value is a dictionary with 'x' and 'y' keys representing coordinates.\n\n    Returns:\n        float: Euclidean distance between the two agents.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestCalculateDistance(unittest.TestCase):\n\n    def test_same_point(self):\n        # Both agents are at the same point\n        observations = {\n            \"agent1\": {\"x\": 0, \"y\": 0},\n            \"agent2\": {\"x\": 0, \"y\": 0}\n        }\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), 0.0)\n\n    def test_horizontal_distance(self):\n        # Agents are horizontally apart\n        observations = {\n            \"agent1\": {\"x\": 0, \"y\": 0},\n            \"agent2\": {\"x\": 3, \"y\": 0}\n        }\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), 3.0)\n\n    def test_vertical_distance(self):\n        # Agents are vertically apart\n        observations = {\n            \"agent1\": {\"x\": 0, \"y\": 0},\n            \"agent2\": {\"x\": 0, \"y\": 4}\n        }\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), 4.0)\n\n    def test_diagonal_distance(self):\n        # Agents are diagonally apart\n        observations = {\n            \"agent1\": {\"x\": 1, \"y\": 2},\n            \"agent2\": {\"x\": 4, \"y\": 6}\n        }\n        expected_distance = np.sqrt((4 - 1) ** 2 + (6 - 2) ** 2)\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), expected_distance)\n\n    def test_negative_coordinates(self):\n        # Agents have negative coordinates\n        observations = {\n            \"agent1\": {\"x\": -1, \"y\": -1},\n            \"agent2\": {\"x\": -4, \"y\": -5}\n        }\n        expected_distance = np.sqrt((-4 + 1) ** 2 + (-5 + 1) ** 2)\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), expected_distance)", "prompt": "please write a python function , the function signature as below def calculate_distance(agent1: str, agent2: str, observations: dict) -> float:\n    \"\"\"\n    Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n\n    Args:\n        agent1 (str): String representation of agent1's identifier.\n        agent2 (str): String representation of agent2's identifier.\n        observations (dict): Dictionary containing observation question with agent identifiers as keys.Each value is a dictionary with 'x' and 'y' keys representing coordinates.\n\n    Returns:\n        float: Euclidean distance between the two agents.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n *\n * @param agent1 A string representation of agent1's identifier.\n * @param agent2 A string representation of agent2's identifier.\n * @param observations A map containing observation data with agent identifiers as keys.\n *                     Each value is a map with 'x' and 'y' keys representing coordinates.\n * @return The Euclidean distance between the two agents.\n */\nfloat calculate_distance(const std::string& agent1, const std::string& agent2, \n                         const std::map<std::string, std::map<std::string, float>>& observations) {}", "test_code": "TEST_CASE(\"Test Calculate Distance\") {\n    SECTION(\"Same Point\") {\n        // Both agents are at the same point\n        std::map<std::string, std::map<std::string, float>> observations = {\n            {\"agent1\", {{\"x\", 0.0f}, {\"y\", 0.0f}}},\n            {\"agent2\", {{\"x\", 0.0f}, {\"y\", 0.0f}}}\n        };\n        REQUIRE(calculate_distance(\"agent1\", \"agent2\", observations) == Approx(0.0f));\n    }\n\n    SECTION(\"Horizontal Distance\") {\n        // Agents are horizontally apart\n        std::map<std::string, std::map<std::string, float>> observations = {\n            {\"agent1\", {{\"x\", 0.0f}, {\"y\", 0.0f}}},\n            {\"agent2\", {{\"x\", 3.0f}, {\"y\", 0.0f}}}\n        };\n        REQUIRE(calculate_distance(\"agent1\", \"agent2\", observations) == Approx(3.0f));\n    }\n\n    SECTION(\"Vertical Distance\") {\n        // Agents are vertically apart\n        std::map<std::string, std::map<std::string, float>> observations = {\n            {\"agent1\", {{\"x\", 0.0f}, {\"y\", 0.0f}}},\n            {\"agent2\", {{\"x\", 0.0f}, {\"y\", 4.0f}}}\n        };\n        REQUIRE(calculate_distance(\"agent1\", \"agent2\", observations) == Approx(4.0f));\n    }\n\n    SECTION(\"Diagonal Distance\") {\n        // Agents are diagonally apart\n        std::map<std::string, std::map<std::string, float>> observations = {\n            {\"agent1\", {{\"x\", 1.0f}, {\"y\", 2.0f}}},\n            {\"agent2\", {{\"x\", 4.0f}, {\"y\", 6.0f}}}\n        };\n        float expected_distance = std::sqrt(std::pow(4.0f - 1.0f, 2) + std::pow(6.0f - 2.0f, 2));\n        REQUIRE(calculate_distance(\"agent1\", \"agent2\", observations) == Approx(expected_distance));\n    }\n\n    SECTION(\"Negative Coordinates\") {\n        // Agents have negative coordinates\n        std::map<std::string, std::map<std::string, float>> observations = {\n            {\"agent1\", {{\"x\", -1.0f}, {\"y\", -1.0f}}},\n            {\"agent2\", {{\"x\", -4.0f}, {\"y\", -5.0f}}}\n        };\n        float expected_distance = std::sqrt(std::pow(-4.0f + 1.0f, 2) + std::pow(-5.0f + 1.0f, 2));\n        REQUIRE(calculate_distance(\"agent1\", \"agent2\", observations) == Approx(expected_distance));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n *\n * @param agent1 A string representation of agent1's identifier.\n * @param agent2 A string representation of agent2's identifier.\n * @param observations A map containing observation data with agent identifiers as keys.\n *                     Each value is a map with 'x' and 'y' keys representing coordinates.\n * @return The Euclidean distance between the two agents.\n */\nfloat calculate_distance(const std::string& agent1, const std::string& agent2, \n                         const std::map<std::string, std::map<std::string, float>>& observations) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n *\n * @param agent1      String representation of agent1's identifier.\n * @param agent2      String representation of agent2's identifier.\n * @param observations Map containing observation data with agent identifiers as keys.\n *                     Each value is a Map with 'x' and 'y' keys representing coordinates.\n * @return The Euclidean distance between the two agents.\n */\npublic static double calculateDistance(String agent1, String agent2, Map<String, Map<String, Double>> observations) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Tester {\n\n    @Test\n    public void testSamePoint() {\n        // Both agents are at the same point\n        Map<String, Map<String, Double>> observations = new HashMap<>();\n        Map<String, Double> agent1Coordinates = new HashMap<>();\n        agent1Coordinates.put(\"x\", 0.0);\n        agent1Coordinates.put(\"y\", 0.0);\n        Map<String, Double> agent2Coordinates = new HashMap<>();\n        agent2Coordinates.put(\"x\", 0.0);\n        agent2Coordinates.put(\"y\", 0.0);\n\n        observations.put(\"agent1\", agent1Coordinates);\n        observations.put(\"agent2\", agent2Coordinates);\n\n        double distance = calculateDistance(\"agent1\", \"agent2\", observations);\n        assertEquals(0.0, distance, 0.001);\n    }\n\n    @Test\n    public void testHorizontalDistance() {\n        // Agents are horizontally apart\n        Map<String, Map<String, Double>> observations = new HashMap<>();\n        Map<String, Double> agent1Coordinates = new HashMap<>();\n        agent1Coordinates.put(\"x\", 0.0);\n        agent1Coordinates.put(\"y\", 0.0);\n        Map<String, Double> agent2Coordinates = new HashMap<>();\n        agent2Coordinates.put(\"x\", 3.0);\n        agent2Coordinates.put(\"y\", 0.0);\n\n        observations.put(\"agent1\", agent1Coordinates);\n        observations.put(\"agent2\", agent2Coordinates);\n\n        double distance = calculateDistance(\"agent1\", \"agent2\", observations);\n        assertEquals(3.0, distance, 0.001);\n    }\n\n    @Test\n    public void testVerticalDistance() {\n        // Agents are vertically apart\n        Map<String, Map<String, Double>> observations = new HashMap<>();\n        Map<String, Double> agent1Coordinates = new HashMap<>();\n        agent1Coordinates.put(\"x\", 0.0);\n        agent1Coordinates.put(\"y\", 0.0);\n        Map<String, Double> agent2Coordinates = new HashMap<>();\n        agent2Coordinates.put(\"x\", 0.0);\n        agent2Coordinates.put(\"y\", 4.0);\n\n        observations.put(\"agent1\", agent1Coordinates);\n        observations.put(\"agent2\", agent2Coordinates);\n\n        double distance = calculateDistance(\"agent1\", \"agent2\", observations);\n        assertEquals(4.0, distance, 0.001);\n    }\n\n    @Test\n    public void testDiagonalDistance() {\n        // Agents are diagonally apart\n        Map<String, Map<String, Double>> observations = new HashMap<>();\n        Map<String, Double> agent1Coordinates = new HashMap<>();\n        agent1Coordinates.put(\"x\", 1.0);\n        agent1Coordinates.put(\"y\", 2.0);\n        Map<String, Double> agent2Coordinates = new HashMap<>();\n        agent2Coordinates.put(\"x\", 4.0);\n        agent2Coordinates.put(\"y\", 6.0);\n\n        observations.put(\"agent1\", agent1Coordinates);\n        observations.put(\"agent2\", agent2Coordinates);\n\n        double expectedDistance = Math.sqrt(Math.pow(4.0 - 1.0, 2) + Math.pow(6.0 - 2.0, 2));\n        double distance = calculateDistance(\"agent1\", \"agent2\", observations);\n        assertEquals(expectedDistance, distance, 0.001);\n    }\n\n    @Test\n    public void testNegativeCoordinates() {\n        // Agents have negative coordinates\n        Map<String, Map<String, Double>> observations = new HashMap<>();\n        Map<String, Double> agent1Coordinates = new HashMap<>();\n        agent1Coordinates.put(\"x\", -1.0);\n        agent1Coordinates.put(\"y\", -1.0);\n        Map<String, Double> agent2Coordinates = new HashMap<>();\n        agent2Coordinates.put(\"x\", -4.0);\n        agent2Coordinates.put(\"y\", -5.0);\n\n        observations.put(\"agent1\", agent1Coordinates);\n        observations.put(\"agent2\", agent2Coordinates);\n\n        double expectedDistance = Math.sqrt(Math.pow(-4.0 + 1.0, 2) + Math.pow(-5.0 + 1.0, 2));\n        double distance = calculateDistance(\"agent1\", \"agent2\", observations);\n        assertEquals(expectedDistance, distance, 0.001);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n *\n * @param agent1      String representation of agent1's identifier.\n * @param agent2      String representation of agent2's identifier.\n * @param observations Map containing observation data with agent identifiers as keys.\n *                     Each value is a Map with 'x' and 'y' keys representing coordinates.\n * @return The Euclidean distance between the two agents.\n */\npublic static double calculateDistance(String agent1, String agent2, Map<String, Map<String, Double>> observations) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 13, "code_type": "method", "original_language": "python", "file_path": "markpickle\\f29202998c0d5ae3ebc2bd22de57bc1c2c6bacbb\\markpickle\\python_to_tables.py", "question_type": "Data processing and transformation", "summary": "Parse the string of the table in Markdown format and return a list of tuples, one for each row in the table", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef parse_markdown_table(md_table: str) -> List[tuple]:\n    \"\"\"\n    Parses a Markdown formatted table into a list of tuples, each tuple representing a row.\n\n    Args:\n        md_table (str): A string representing a Markdown table.\n\n    Returns:\n        list of tuples: A list where each tuple represents a row in the table.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestParseMarkdownTable(unittest.TestCase):\n    def test_standard_table(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        | Row1Col1 | Row1Col2 | Row1Col3 |\n        | Row2Col1 | Row2Col2 | Row2Col3 |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('Row1Col1', 'Row1Col2', 'Row1Col3'),\n            ('Row2Col1', 'Row2Col2', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_inconsistent_columns(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 |\n        |----------|----------|\n        | Row1     | Row1Col2 | ExtraCol |\n        | Row2     |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2'),\n            ('Row1', 'Row1Col2', 'ExtraCol'),\n            ('Row2',)\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_empty_cells(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          | Row1Col2 |          |\n        | Row2Col1 |          | Row2Col3 |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('', 'Row1Col2', ''),\n            ('Row2Col1', '', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_all_empty_rows(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          |          |          |\n        |          |          |          |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('', '', ''),\n            ('', '', '')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_excessive_whitespace(self):\n        md_table = \"\"\"\n        |  Header 1  |  Header 2  |  Header 3  |\n        |------------|------------|------------|\n        |  Row1Col1  |  Row1Col2  |  Row1Col3  |\n        |  Row2Col1  |  Row2Col2  |  Row2Col3  |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('Row1Col1', 'Row1Col2', 'Row1Col3'),\n            ('Row2Col1', 'Row2Col2', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n\ndef parse_markdown_table(md_table):\n    \"\"\"\n    Parses a Markdown formatted table into a list of tuples, each tuple representing a row.\n\n    Args:\n        md_table (str): A string representing a Markdown table.\n\n    Returns:\n        list of tuples: A list where each tuple represents a row in the table.\n    \"\"\"\n    # Split the input string into lines and strip whitespace\n    lines = md_table.strip().split('\\n')\n\n    # Filter out the separator line for the header (which usually contains \"---\")\n    lines = [line for line in lines if not line.strip().startswith('|---')]\n\n    # Initialize the list to store each row as a tuple\n    table_data = []\n\n    # Process each line\n    for line in lines:\n        # Strip leading and trailing spaces and pipes, then split by \"|\"\n        row = line.strip('| \\n').split('|')\n        # Strip spaces from each cell, handle empty cells, and create a tuple\n        table_data.append(tuple(cell.strip() for cell in row if cell.strip() or cell == ''))\n\n    return table_data\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef parse_markdown_table(md_table: str) -> List[tuple]:\n    \"\"\"\n    Parses a Markdown formatted table into a list of tuples, each tuple representing a row.\n\n    Args:\n        md_table (str): A string representing a Markdown table.\n\n    Returns:\n        list of tuples: A list where each tuple represents a row in the table.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Parses a Markdown formatted table into a vector of tuples, each tuple representing a row.\n *\n * @param md_table A string representing a Markdown table.\n * @return A vector where each tuple represents a row in the table.\n */\nstd::vector<std::tuple<std::string, std::string, std::string>> parse_markdown_table(const std::string& md_table) {}", "test_code": "TEST_CASE(\"Test parse_markdown_table\", \"[parse_markdown_table]\") {\n    SECTION(\"test_standard_table\") {\n        std::string md_table = R\"(\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        | Row1Col1 | Row1Col2 | Row1Col3 |\n        | Row2Col1 | Row2Col2 | Row2Col3 |\n        )\";\n        std::vector<std::tuple<std::string, std::string, std::string>> expected = {\n            {\"Header 1\", \"Header 2\", \"Header 3\"},\n            {\"Row1Col1\", \"Row1Col2\", \"Row1Col3\"},\n            {\"Row2Col1\", \"Row2Col2\", \"Row2Col3\"}\n        };\n        auto result = parse_markdown_table(md_table);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_inconsistent_columns\") {\n        std::string md_table = R\"(\n        | Header 1 | Header 2 |\n        |----------|----------|\n        | Row1     | Row1Col2 | ExtraCol |\n        | Row2     |\n        )\";\n        std::vector<std::tuple<std::string, std::string, std::string>> expected = {\n            {\"Header 1\", \"Header 2\"},\n            {\"Row1\", \"Row1Col2\", \"ExtraCol\"},\n            {\"Row2\"}\n        };\n        auto result = parse_markdown_table(md_table);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_empty_cells\") {\n        std::string md_table = R\"(\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          | Row1Col2 |          |\n        | Row2Col1 |          | Row2Col3 |\n        )\";\n        std::vector<std::tuple<std::string, std::string, std::string>> expected = {\n            {\"Header 1\", \"Header 2\", \"Header 3\"},\n            {\"\", \"Row1Col2\", \"\"},\n            {\"Row2Col1\", \"\", \"Row2Col3\"}\n        };\n        auto result = parse_markdown_table(md_table);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_all_empty_rows\") {\n        std::string md_table = R\"(\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          |          |          |\n        |          |          |          |\n        )\";\n        std::vector<std::tuple<std::string, std::string, std::string>> expected = {\n            {\"Header 1\", \"Header 2\", \"Header 3\"},\n            {\"\", \"\", \"\"},\n            {\"\", \"\", \"\"}\n        };\n        auto result = parse_markdown_table(md_table);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_excessive_whitespace\") {\n        std::string md_table = R\"(\n        |  Header 1  |  Header 2  |  Header 3  |\n        |------------|------------|------------|\n        |  Row1Col1  |  Row1Col2  |  Row1Col3  |\n        |  Row2Col1  |  Row2Col2  |  Row2Col3  |\n        )\";\n        std::vector<std::tuple<std::string, std::string, std::string>> expected = {\n            {\"Header 1\", \"Header 2\", \"Header 3\"},\n            {\"Row1Col1\", \"Row1Col2\", \"Row1Col3\"},\n            {\"Row2Col1\", \"Row2Col2\", \"Row2Col3\"}\n        };\n        auto result = parse_markdown_table(md_table);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Parses a Markdown formatted table into a vector of tuples, each tuple representing a row.\n *\n * @param md_table A string representing a Markdown table.\n * @return A vector where each tuple represents a row in the table.\n */\nstd::vector<std::tuple<std::string, std::string, std::string>> parse_markdown_table(const std::string& md_table) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Parses a Markdown formatted table into a list of arrays, each array representing a row.\n *\n * @param mdTable A string representing a Markdown table.\n * @return A list where each array represents a row in the table.\n */\npublic static List<String[]> parseMarkdownTable(String mdTable) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testStandardTable() {\n        String mdTable = \"| Header 1 | Header 2 | Header 3 |\\n\" +\n                         \"|----------|----------|----------|\\n\" +\n                         \"| Row1Col1 | Row1Col2 | Row1Col3 |\\n\" +\n                         \"| Row2Col1 | Row2Col2 | Row2Col3 |\";\n\n        List<String[]> expected = Arrays.asList(\n            new String[]{\"Header 1\", \"Header 2\", \"Header 3\"},\n            new String[]{\"Row1Col1\", \"Row1Col2\", \"Row1Col3\"},\n            new String[]{\"Row2Col1\", \"Row2Col2\", \"Row2Col3\"}\n        );\n\n        List<String[]> result = parseMarkdownTable(mdTable);\n\n        assertEquals(expected.size(), result.size());\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(Arrays.asList(expected.get(i)), Arrays.asList(result.get(i)));\n        }\n    }\n\n    @Test\n    public void testInconsistentColumns() {\n        String mdTable = \"| Header 1 | Header 2 |\\n\" +\n                         \"|----------|----------|\\n\" +\n                         \"| Row1     | Row1Col2 | ExtraCol |\\n\" +\n                         \"| Row2     |\";\n\n        List<String[]> expected = Arrays.asList(\n            new String[]{\"Header 1\", \"Header 2\"},\n            new String[]{\"Row1\", \"Row1Col2\", \"ExtraCol\"},\n            new String[]{\"Row2\"}\n        );\n\n        List<String[]> result = parseMarkdownTable(mdTable);\n\n        assertEquals(expected.size(), result.size());\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(Arrays.asList(expected.get(i)), Arrays.asList(result.get(i)));\n        }\n    }\n\n    @Test\n    public void testEmptyCells() {\n        String mdTable = \"| Header 1 | Header 2 | Header 3 |\\n\" +\n                         \"|----------|----------|----------|\\n\" +\n                         \"|          | Row1Col2 |          |\\n\" +\n                         \"| Row2Col1 |          | Row2Col3 |\";\n\n        List<String[]> expected = Arrays.asList(\n            new String[]{\"Header 1\", \"Header 2\", \"Header 3\"},\n            new String[]{\"\", \"Row1Col2\", \"\"},\n            new String[]{\"Row2Col1\", \"\", \"Row2Col3\"}\n        );\n\n        List<String[]> result = parseMarkdownTable(mdTable);\n\n        assertEquals(expected.size(), result.size());\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(Arrays.asList(expected.get(i)), Arrays.asList(result.get(i)));\n        }\n    }\n\n    @Test\n    public void testAllEmptyRows() {\n        String mdTable = \"| Header 1 | Header 2 | Header 3 |\\n\" +\n                         \"|----------|----------|----------|\\n\" +\n                         \"|          |          |          |\\n\" +\n                         \"|          |          |          |\";\n\n        List<String[]> expected = Arrays.asList(\n            new String[]{\"Header 1\", \"Header 2\", \"Header 3\"},\n            new String[]{\"\", \"\", \"\"},\n            new String[]{\"\", \"\", \"\"}\n        );\n\n        List<String[]> result = parseMarkdownTable(mdTable);\n\n        assertEquals(expected.size(), result.size());\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(Arrays.asList(expected.get(i)), Arrays.asList(result.get(i)));\n        }\n    }\n\n    @Test\n    public void testExcessiveWhitespace() {\n        String mdTable = \"|  Header 1  |  Header 2  |  Header 3  |\\n\" +\n                         \"|------------|------------|------------|\\n\" +\n                         \"|  Row1Col1  |  Row1Col2  |  Row1Col3  |\\n\" +\n                         \"|  Row2Col1  |  Row2Col2  |  Row2Col3  |\";\n\n        List<String[]> expected = Arrays.asList(\n            new String[]{\"Header 1\", \"Header 2\", \"Header 3\"},\n            new String[]{\"Row1Col1\", \"Row1Col2\", \"Row1Col3\"},\n            new String[]{\"Row2Col1\", \"Row2Col2\", \"Row2Col3\"}\n        );\n\n        List<String[]> result = parseMarkdownTable(mdTable);\n\n        assertEquals(expected.size(), result.size());\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(Arrays.asList(expected.get(i)), Arrays.asList(result.get(i)));\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Parses a Markdown formatted table into a list of arrays, each array representing a row.\n *\n * @param mdTable A string representing a Markdown table.\n * @return A list where each array represents a row in the table.\n */\npublic static List<String[]> parseMarkdownTable(String mdTable) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 17, "code_type": "method", "original_language": "python", "file_path": "directional-positioning-error-bachelors-thesis\\4e281251a4a587eb076606817288c31a48536d61\\calculate-distance.py", "question_type": "Scientific computation and numerical analysis", "summary": "calculate the distance between two points on the earth based on their latitude and longitude\n", "language_version_list": {"python": {"code_signature": "def haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the distance between two points on the earth based on their latitude and longitude\n    Args:\n        lat1 (float): Latitude of the first point in degrees.\n        lon1 (float): Longitude of the first point in degrees.\n        lat2 (float): Latitude of the second point in degrees.\n        lon2 (float): Longitude of the second point in degrees.\n\n    Returns:\n        Distance between the two points in kilometers.\n    \"\"\"", "test_code": "    import unittest\n\n\n    class TestHaversineDistance(unittest.TestCase):\n\n        def test_same_point(self):\n            # Same point should return a distance of 0\n            lat, lon = 52.2296756, 21.0122287\n            result = haversine_distance(lat, lon, lat, lon)\n            self.assertAlmostEqual(result, 0.0, places=6)\n\n        def test_small_distance(self):\n            # Points that are very close together (few meters apart)\n            lat1, lon1 = 52.2296756, 21.0122287  # Warsaw, Poland\n            lat2, lon2 = 52.2296756, 21.0122297  # Very close to the previous point\n            result = haversine_distance(lat1, lon1, lat2, lon2)\n            self.assertAlmostEqual(result, 0.0001, places=4)  # Expected small distance\n\n        def test_large_distance(self):\n            # Points that are far apart\n            lat1, lon1 = 52.2296756, 21.0122287  # Warsaw, Poland\n            lat2, lon2 = 41.8919300, 12.5113300  # Rome, Italy\n            result = haversine_distance(lat1, lon1, lat2, lon2)\n            self.assertAlmostEqual(result, 1315.514, places=2)  # Approx distance in km\n\n        def test_equator_distance(self):\n            # Points on the equator\n            lat1, lon1 = 0.0, 0.0  # Gulf of Guinea (Equator and Prime Meridian intersection)\n            lat2, lon2 = 0.0, 90.0  # On the Equator, 90 degrees east\n            result = haversine_distance(lat1, lon1, lat2, lon2)\n            self.assertAlmostEqual(result, 10007.54, places=2)  # Approx quarter of Earth's circumference\n\n        def test_pole_to_pole(self):\n            # Distance from North Pole to South Pole\n            lat1, lon1 = 90.0, 0.0  # North Pole\n            lat2, lon2 = -90.0, 0.0  # South Pole\n            result = haversine_distance(lat1, lon1, lat2, lon2)\n            self.assertAlmostEqual(result, 20015.09, places=2)  # Approx half of Earth's circumference\n", "prompt": "please write a python function , the function signature as below def haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the distance between two points on the earth based on their latitude and longitude\n    Args:\n        lat1 (float): Latitude of the first point in degrees.\n        lon1 (float): Longitude of the first point in degrees.\n        lat2 (float): Latitude of the second point in degrees.\n        lon2 (float): Longitude of the second point in degrees.\n\n    Returns:\n        Distance between the two points in kilometers.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the distance between two points on the Earth's surface using the Haversine formula.\n *\n * @param lat1 Latitude of the first point in degrees.\n * @param lon1 Longitude of the first point in degrees.\n * @param lat2 Latitude of the second point in degrees.\n * @param lon2 Longitude of the second point in degrees.\n *\n * @return Distance between the two points in kilometers. The result is a double precision floating-point\n *         number representing the shortest distance over the Earth's surface, accounting for its curvature.\n *\n * @note This implementation assumes the Earth is a perfect sphere, which may introduce slight errors in distance\n *       calculations, especially for long distances. For most practical purposes, the results are sufficiently accurate.\n */\ndouble haversine_distance(double lat1, double lon1, double lat2, double lon2) {}\n", "test_code": "TEST_CASE(\"Test Haversine Distance\", \"[haversine_distance]\") {\n    SECTION(\"Same point should return a distance of 0\") {\n        double lat = 52.2296756;\n        double lon = 21.0122287;\n        double result = haversine_distance(lat, lon, lat, lon);\n        REQUIRE(std::abs(result - 0.0) < 1e-6);\n    }\n\n    SECTION(\"Points that are very close together (few meters apart)\") {\n        double lat1 = 52.2296756;\n        double lon1 = 21.0122287;  // Warsaw, Poland\n        double lat2 = 52.2296756;\n        double lon2 = 21.0122297;  // Very close to the previous point\n        double result = haversine_distance(lat1, lon1, lat2, lon2);\n        REQUIRE(std::abs(result - 0.0001) < 1e-4);\n    }\n\n    SECTION(\"Points that are far apart\") {\n        double lat1 = 52.2296756;\n        double lon1 = 21.0122287;  // Warsaw, Poland\n        double lat2 = 41.8919300;\n        double lon2 = 12.5113300;  // Rome, Italy\n        double result = haversine_distance(lat1, lon1, lat2, lon2);\n        REQUIRE(std::abs(result - 1315.514) < 1e-2);\n    }\n\n    SECTION(\"Points on the equator\") {\n        double lat1 = 0.0;\n        double lon1 = 0.0;  // Gulf of Guinea (Equator and Prime Meridian intersection)\n        double lat2 = 0.0;\n        double lon2 = 90.0;  // On the Equator, 90 degrees east\n        double result = haversine_distance(lat1, lon1, lat2, lon2);\n        REQUIRE(std::abs(result - 10007.54) < 1e-2);\n    }\n\n    SECTION(\"Distance from North Pole to South Pole\") {\n        double lat1 = 90.0;\n        double lon1 = 0.0;  // North Pole\n        double lat2 = -90.0;\n        double lon2 = 0.0;  // South Pole\n        double result = haversine_distance(lat1, lon1, lat2, lon2);\n        REQUIRE(std::abs(result - 20015.09) < 1e-2);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the distance between two points on the Earth's surface using the Haversine formula.\n *\n * @param lat1 Latitude of the first point in degrees.\n * @param lon1 Longitude of the first point in degrees.\n * @param lat2 Latitude of the second point in degrees.\n * @param lon2 Longitude of the second point in degrees.\n *\n * @return Distance between the two points in kilometers. The result is a double precision floating-point\n *         number representing the shortest distance over the Earth's surface, accounting for its curvature.\n *\n * @note This implementation assumes the Earth is a perfect sphere, which may introduce slight errors in distance\n *       calculations, especially for long distances. For most practical purposes, the results are sufficiently accurate.\n */\ndouble haversine_distance(double lat1, double lon1, double lat2, double lon2) {}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the distance between two points on the Earth based on their latitude and longitude.\n *\n * @param lat1 Latitude of the first point in degrees.\n * @param lon1 Longitude of the first point in degrees.\n * @param lat2 Latitude of the second point in degrees.\n * @param lon2 Longitude of the second point in degrees.\n * @return Distance between the two points in kilometers.\n */\npublic static double haversineDistance(double lat1, double lon1, double lat2, double lon2) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals; \nimport static org.junit.Assert.assertFalse; \nimport static org.junit.Assert.assertTrue;  \nimport org.junit.Test; \n\npublic class Tester {\n\n    private static final double DELTA = 1e-6; // Tolerance for floating-point comparisons\n\n    @Test\n    public void testSamePoint() {\n        // Same point should return a distance of 0\n        double lat = 52.2296756;\n        double lon = 21.0122287;\n        double result = haversineDistance(lat, lon, lat, lon);\n        assertEquals(0.0, result, DELTA);\n    }\n\n    @Test\n    public void testSmallDistance() {\n        // Points that are very close together (few meters apart)\n        double lat1 = 52.2296756;\n        double lon1 = 21.0122287;  // Warsaw, Poland\n        double lat2 = 52.2296756;\n        double lon2 = 21.0122297;  // Very close to the previous point\n        double result = haversineDistance(lat1, lon1, lat2, lon2);\n        assertEquals(0.0001, result, 1e-4);  // Expected small distance\n    }\n\n    @Test\n    public void testLargeDistance() {\n        // Points that are far apart\n        double lat1 = 52.2296756;\n        double lon1 = 21.0122287;  // Warsaw, Poland\n        double lat2 = 41.8919300;\n        double lon2 = 12.5113300;  // Rome, Italy\n        double result = haversineDistance(lat1, lon1, lat2, lon2);\n        assertEquals(1315.514, result, 1e-2);  // Approx distance in km\n    }\n\n    @Test\n    public void testEquatorDistance() {\n        // Points on the equator\n        double lat1 = 0.0;\n        double lon1 = 0.0;  // Gulf of Guinea (Equator and Prime Meridian intersection)\n        double lat2 = 0.0;\n        double lon2 = 90.0;  // On the Equator, 90 degrees east\n        double result = haversineDistance(lat1, lon1, lat2, lon2);\n        assertEquals(10007.54, result, 1e-2);  // Approx quarter of Earth's circumference\n    }\n\n    @Test\n    public void testPoleToPole() {\n        // Distance from North Pole to South Pole\n        double lat1 = 90.0;\n        double lon1 = 0.0;  // North Pole\n        double lat2 = -90.0;\n        double lon2 = 0.0;  // South Pole\n        double result = haversineDistance(lat1, lon1, lat2, lon2);\n        assertEquals(20015.09, result, 1e-2);  // Approx half of Earth's circumference\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Calculates the distance between two points on the Earth based on their latitude and longitude.\n *\n * @param lat1 Latitude of the first point in degrees.\n * @param lon1 Longitude of the first point in degrees.\n * @param lat2 Latitude of the second point in degrees.\n * @param lon2 Longitude of the second point in degrees.\n * @return Distance between the two points in kilometers.\n */\npublic static double haversineDistance(double lat1, double lon1, double lat2, double lon2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 18, "code_type": "method", "original_language": "python", "file_path": "boba-walks\\8449cb77916b4fb07e2d393370699fea7193a0df\\utils.py", "question_type": "Data processing and transformation", "summary": "Convert a floating point number between 0 and 1 to a color from red to green in the color format RGB", "language_version_list": {"python": {"code_signature": "def float_to_rgb(value: float) -> tuple:\n    \"\"\"\n    convert a floating point number between 0 and 1 to a color from red to green in the color format RGB\n    Args:\n        value (float): a float between 0 and 1.\n\n    Returns:\n        a tuple representing the RGB color.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFloatToRGB(unittest.TestCase):\n\n    def test_pure_red(self):\n        # Value at the lower boundary (0.0) should return pure red\n        result = float_to_rgb(0.0)\n        self.assertEqual(result, (255, 0, 0))\n\n    def test_pure_green(self):\n        # Value at the upper boundary (1.0) should return pure green\n        result = float_to_rgb(1.0)\n        self.assertEqual(result, (0, 255, 0))\n\n    def test_midpoint(self):\n        # Value at 0.5 should return an equal mix of red and green, resulting in yellow\n        result = float_to_rgb(0.5)\n        self.assertEqual(result, (127, 127, 0))\n\n    def test_quarter_point(self):\n        # Value at 0.25 should return more red than green\n        result = float_to_rgb(0.25)\n        self.assertEqual(result, (191, 63, 0))\n\n    def test_invalid_value(self):\n        # Value outside the range [0, 1] should raise a ValueError\n        with self.assertRaises(ValueError):\n            float_to_rgb(1.5)", "prompt": "please write a python function , the function signature as below def float_to_rgb(value: float) -> tuple:\n    \"\"\"\n    convert a floating point number between 0 and 1 to a color from red to green in the color format RGB\n    Args:\n        value (float): a float between 0 and 1.\n\n    Returns:\n        a tuple representing the RGB color.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert a floating-point number between 0 and 1 to a color from red to green in the RGB format.\n *\n * @param value A float between 0 and 1.\n * @return A tuple representing the RGB color.\n */\nstd::tuple<int, int, int> float_to_rgb(float value) {}", "test_code": "TEST_CASE(\"Test Float to RGB Conversion\") {\n    SECTION(\"Pure Red\") {\n        // Value at the lower boundary (0.0) should return pure red\n        auto result = float_to_rgb(0.0f);\n        REQUIRE(std::get<0>(result) == 255);\n        REQUIRE(std::get<1>(result) == 0);\n        REQUIRE(std::get<2>(result) == 0);\n    }\n\n    SECTION(\"Pure Green\") {\n        // Value at the upper boundary (1.0) should return pure green\n        auto result = float_to_rgb(1.0f);\n        REQUIRE(std::get<0>(result) == 0);\n        REQUIRE(std::get<1>(result) == 255);\n        REQUIRE(std::get<2>(result) == 0);\n    }\n\n    SECTION(\"Midpoint\") {\n        // Value at 0.5 should return an equal mix of red and green, resulting in yellow\n        auto result = float_to_rgb(0.5f);\n        REQUIRE(std::get<0>(result) == 127);\n        REQUIRE(std::get<1>(result) == 127);\n        REQUIRE(std::get<2>(result) == 0);\n    }\n\n    SECTION(\"Quarter Point\") {\n        // Value at 0.25 should return more red than green\n        auto result = float_to_rgb(0.25f);\n        REQUIRE(std::get<0>(result) == 191);\n        REQUIRE(std::get<1>(result) == 63);\n        REQUIRE(std::get<2>(result) == 0);\n    }\n\n    SECTION(\"Invalid Value\") {\n        // Value outside the range [0, 1] should throw an exception\n        REQUIRE_THROWS_AS(float_to_rgb(1.5f), std::invalid_argument);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert a floating-point number between 0 and 1 to a color from red to green in the RGB format.\n *\n * @param value A float between 0 and 1.\n * @return A tuple representing the RGB color.\n */\nstd::tuple<int, int, int> float_to_rgb(float value) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a floating-point number between 0 and 1 to a color from red to green in the RGB format.\n *\n * @param value a float between 0 and 1.\n * @return an array representing the RGB color.\n * @throws IllegalArgumentException if the value is not between 0 and 1 inclusive.\n */\npublic static int[] floatToRGB(float value) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n\npublic class Tester {\n\n    /**\n     * Tests that a value at the lower boundary (0.0) returns pure red.\n     */\n    @Test\n    public void testPureRed() {\n        int[] result = floatToRGB(0.0f);\n        assertArrayEquals(new int[]{255, 0, 0}, result);\n    }\n\n    /**\n     * Tests that a value at the upper boundary (1.0) returns pure green.\n     */\n    @Test\n    public void testPureGreen() {\n        int[] result = floatToRGB(1.0f);\n        assertArrayEquals(new int[]{0, 255, 0}, result);\n    }\n\n    /**\n     * Tests that a value at 0.5 returns an equal mix of red and green, resulting in yellow.\n     */\n    @Test\n    public void testMidpoint() {\n        int[] result = floatToRGB(0.5f);\n        assertArrayEquals(new int[]{127, 127, 0}, result);\n    }\n\n    /**\n     * Tests that a value at 0.25 returns more red than green.\n     */\n    @Test\n    public void testQuarterPoint() {\n        int[] result = floatToRGB(0.25f);\n        assertArrayEquals(new int[]{191, 63, 0}, result);\n    }\n\n    /**\n     * Tests that a value outside the range [0, 1] raises an IllegalArgumentException.\n     */\n    @Test(expected = IllegalArgumentException.class)\n    public void testInvalidValue() {\n        floatToRGB(1.5f);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a floating-point number between 0 and 1 to a color from red to green in the RGB format.\n *\n * @param value a float between 0 and 1.\n * @return an array representing the RGB color.\n * @throws IllegalArgumentException if the value is not between 0 and 1 inclusive.\n */\npublic static int[] floatToRGB(float value) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 19, "code_type": "method", "original_language": "python", "file_path": "athina-sdk\\50646629f89f8e25d0a7b7a8edb69305605fcabb\\magik\\evaluators.py", "question_type": "Data processing and transformation", "summary": "Determines whether the string contains a phone number; a possible format for a phone number is +1-800-555-1234, 555-555-1234, 555 555 1234", "language_version_list": {"python": {"code_signature": "def is_hava_phone_number(s: str) -> bool:\n    \"\"\"\n    determines whether the string contains a phone number; a possible format for a phone number is +1-800-555-1234, 555-555-1234, 555 555 1234\n    Args:\n        s (str): input str maybe contain phone number\n\n    Returns: weather this str contain phone number\n\n    \"\"\"\n", "test_code": "import re\nimport unittest\n\n\nclass TestPhoneNumberDetection(unittest.TestCase):\n    def test_with_international_prefix(self):\n        self.assertTrue(is_hava_phone_number(\"+1-800-555-1234\"), \"Should detect international prefix\")\n\n    def test_with_standard_dashes(self):\n        self.assertTrue(is_hava_phone_number(\"800-555-1234\"), \"Should detect standard format with dashes\")\n\n    def test_with_spaces(self):\n        self.assertTrue(is_hava_phone_number(\"800 555 1234\"), \"Should detect standard format with spaces\")\n\n    def test_without_phone_number(self):\n        self.assertFalse(is_hava_phone_number(\"Hello, world!\"), \"Should not detect any phone number\")\n\n    def test_with_text_containing_numbers(self):\n        self.assertTrue(is_hava_phone_number(\"Call me at 800-555-1234 today!\"), \"Should detect phone number in text\")", "prompt": "please write a python function , the function signature as below def is_hava_phone_number(s: str) -> bool:\n    \"\"\"\n    determines whether the string contains a phone number; a possible format for a phone number is +1-800-555-1234, 555-555-1234, 555 555 1234\n    Args:\n        s (str): input str maybe contain phone number\n\n    Returns: weather this str contain phone number\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Determines whether the string contains a phone number.\n * A possible format for a phone number is +1-800-555-1234, 555-555-1234, or 555 555 1234.\n *\n * @param s The input string which may contain a phone number.\n * @return True if the string contains a phone number, false otherwise.\n */\nbool contains_phone_number(const std::string& s){}", "test_code": "TEST_CASE(\"Test PhoneNumber Detection\", \"[PhoneNumberDetection]\") {\n    SECTION(\"with international prefix\") {\n        REQUIRE(contains_phone_number(\"+1-800-555-1234\"));\n    }\n\n    SECTION(\"with standard dashes\") {\n        REQUIRE(contains_phone_number(\"800-555-1234\"));\n    }\n\n    SECTION(\"with spaces\") {\n        REQUIRE(contains_phone_number(\"800 555 1234\"));\n    }\n\n    SECTION(\"without phone number\") {\n        REQUIRE_FALSE(contains_phone_number(\"Hello, world!\"));\n    }\n\n    SECTION(\"with text containing numbers\") {\n        REQUIRE(contains_phone_number(\"Call me at 800-555-1234 today!\"));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Determines whether the string contains a phone number.\n * A possible format for a phone number is +1-800-555-1234, 555-555-1234, or 555 555 1234.\n *\n * @param s The input string which may contain a phone number.\n * @return True if the string contains a phone number, false otherwise.\n */\nbool contains_phone_number(const std::string& s){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Determines whether the string contains a phone number.\n * A possible format for a phone number is +1-800-555-1234, 555-555-1234, 555 555 1234.\n *\n * @param s the input string that may contain a phone number\n * @return true if the string contains a phone number, false otherwise\n */\npublic static boolean containsPhoneNumber(String s) {}", "test_code": "package org.real.temp;\nimport org.junit.Test;  \nimport static org.junit.Assert.*; \n\npublic class Tester {\n\n    @Test\n    public void testWithInternationalPrefix() {\n        assertTrue(containsPhoneNumber(\"+1-800-555-1234\"), \"Should detect international prefix\");\n    }\n\n    @Test\n    public void testWithStandardDashes() {\n        assertTrue(containsPhoneNumber(\"800-555-1234\"), \"Should detect standard format with dashes\");\n    }\n\n    @Test\n    public void testWithSpaces() {\n        assertTrue(containsPhoneNumber(\"800 555 1234\"), \"Should detect standard format with spaces\");\n    }\n\n    @Test\n    public void testWithoutPhoneNumber() {\n        assertFalse(containsPhoneNumber(\"Hello, world!\"), \"Should not detect any phone number\");\n    }\n\n    @Test\n    public void testWithTextContainingNumbers() {\n        assertTrue(containsPhoneNumber(\"Call me at 800-555-1234 today!\"), \"Should detect phone number in text\");\n    }\n\n    // Assuming this method exists as part of the class or is defined elsewhere\n    private boolean containsPhoneNumber(String text) {\n        // Placeholder for the actual implementation\n        return text.matches(\".*\\\\+?\\\\d{1,3}[-\\\\s]?\\\\d{3}[-\\\\s]?\\\\d{3}[-\\\\s]?\\\\d{4}.*\");\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Determines whether the string contains a phone number.\n * A possible format for a phone number is +1-800-555-1234, 555-555-1234, 555 555 1234.\n *\n * @param s the input string that may contain a phone number\n * @return true if the string contains a phone number, false otherwise\n */\npublic static boolean containsPhoneNumber(String s) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 20, "code_type": "method", "original_language": "python", "file_path": "exa-py\\a3d4c480cb99854656924e83696cfb5546bc7118\\docs\\repair_markdown_docs.py", "question_type": "Data processing and transformation", "summary": "Match the text with (*... *) The inner asterisks in the part of the format are removed and the outer parts (* and *) are left unchanged. For example,(*he*l*lo*) would be converted to (*hello*)\n", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef remove_inner_asterisks(text: str) -> str:\n    \"\"\"\n    Transforms the input text by finding and modifying patterns that match the format '(*...*)'.\n    Specifically, it removes any asterisks inside the parentheses while preserving the outer format.\n    For example:\n        input: *he*l*lo*\n        output: *hello*\n\n    Args:\n        text (str): The input text containing patterns to be transformed.\n\n    Returns:\n        str: The transformed text with asterisks inside '(*...*)' patterns removed.\n    \"\"\"\n", "test_code": "import unittest\nimport re\n\n\nclass TestTransformParentheses(unittest.TestCase):\n\n    def test_basic_case(self):\n        text = \"Hello (*wo*rld*)!\"\n        expected = \"Hello (*world*)!\"\n        self.assertEqual(remove_inner_asterisks(text), expected)\n\n    def test_multiple_asterisks(self):\n        text = \"(*he*l*lo*)\"\n        expected = \"(*hello*)\"\n        self.assertEqual(remove_inner_asterisks(text), expected)\n\n    def test_no_asterisks_inside(self):\n        text = \"(*hello*)\"\n        expected = \"(*hello*)\"\n        self.assertEqual(remove_inner_asterisks(text), expected)\n\n    def test_multiple_patterns(self):\n        text = \"(*hi*), (*there*), (*world*)!\"\n        expected = \"(*hi*), (*there*), (*world*)!\"\n        self.assertEqual(remove_inner_asterisks(text), expected)\n\n    def test_no_matching_pattern(self):\n        text = \"This is a test without matching parentheses.\"\n        expected = \"This is a test without matching parentheses.\"\n        self.assertEqual(remove_inner_asterisks(text), expected)\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef remove_inner_asterisks(text: str) -> str:\n    \"\"\"\n    Transforms the input text by finding and modifying patterns that match the format '(*...*)'.\n    Specifically, it removes any asterisks inside the parentheses while preserving the outer format.\n    For example:\n        input: *he*l*lo*\n        output: *hello*\n\n    Args:\n        text (str): The input text containing patterns to be transformed.\n\n    Returns:\n        str: The transformed text with asterisks inside '(*...*)' patterns removed.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Processes a string containing Markdown-like asterisks.\n * \n * This function removes asterisks ('*') found between the first and last occurrence\n * if there are more than two asterisks in the string. If the number of asterisks\n * is two or fewer, the original string is returned unchanged.\n *\n * @param s The input string that may contain asterisks.\n * @return A string with the asterisks between the first and last occurrence removed,\n *         or the original string if there are two or fewer asterisks.\n */\n std::string process_markdown(const std::string& s) {}", "test_code": "#define CATCH_CONFIG_MAIN  // This tells Catch to provide a main() - only do this in one cpp file\n#include \"catch.hpp\"\n#include <string>\n\n// Assuming the process_markdown function is defined elsewhere\nstd::string process_markdown(const std::string& s);\n\nTEST_CASE(\"Tests for process_markdown function\") {\n\n    SECTION(\"Test single asterisk pair\") {\n        std::string content = \"This is a *test.js* string.\";\n        std::string expected = \"This is a *test.js* string.\";\n        REQUIRE(process_markdown(content) == expected);\n    }\n\n    SECTION(\"Test nested asterisks\") {\n        std::string content = \"Example of **nested *asterisks***.\";\n        std::string expected = \"Example of *nested asterisks*.\";\n        REQUIRE(process_markdown(content) == expected);\n    }\n\n    SECTION(\"Test multiple asterisk pairs\") {\n        std::string content = \"*Multiple* pairs of *asterisks* in *one* sentence.\";\n        std::string expected = \"*Multiple pairs of asterisks in one* sentence.\";\n        REQUIRE(process_markdown(content) == expected);\n    }\n\n    SECTION(\"Test asterisks with no text\") {\n        std::string content = \"Asterisks with ** no text.\";\n        std::string expected = \"Asterisks with ** no text.\";\n        REQUIRE(process_markdown(content) == expected);\n    }\n\n    SECTION(\"Test asterisks around spaces\") {\n        std::string content = \"Asterisks around * *spaces* * are tricky.\";\n        std::string expected = \"Asterisks around * spaces * are tricky.\";\n        REQUIRE(process_markdown(content) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Processes a string containing Markdown-like asterisks.\n * \n * This function removes asterisks ('*') found between the first and last occurrence\n * if there are more than two asterisks in the string. If the number of asterisks\n * is two or fewer, the original string is returned unchanged.\n *\n * @param s The input string that may contain asterisks.\n * @return A string with the asterisks between the first and last occurrence removed,\n *         or the original string if there are two or fewer asterisks.\n */\n std::string process_markdown(const std::string& s) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Transforms the input text by finding and modifying patterns that match the format '(...)'.\n * Specifically, it removes any asterisks inside the parentheses while preserving the outer format.\n * \n * For example:\n * input: hello\n * output: hello\n *\n * @param text The input text containing patterns to be transformed.\n * @return The transformed text with asterisks inside '(*...*)' patterns removed.\n */\npublic static String removeInnerAsterisks(String text) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testBasicCase() {\n        String text = \"Hello (*wo*rld*)!\";\n        String expected = \"Hello (*world*)!\";\n        assertEquals(expected, removeInnerAsterisks(text));\n    }\n\n    @Test\n    public void testMultipleAsterisks() {\n        String text = \"(*he*l*lo*)\";\n        String expected = \"(*hello*)\";\n        assertEquals(expected, removeInnerAsterisks(text));\n    }\n\n    @Test\n    public void testNoAsterisksInside() {\n        String text = \"(*hello*)\";\n        String expected = \"(*hello*)\";\n        assertEquals(expected, removeInnerAsterisks(text));\n    }\n\n    @Test\n    public void testMultiplePatterns() {\n        String text = \"(*hi*), (*there*), (*world*)!\";\n        String expected = \"(*hi*), (*there*), (*world*)!\";\n        assertEquals(expected, removeInnerAsterisks(text));\n    }\n\n    @Test\n    public void testNoMatchingPattern() {\n        String text = \"This is a test without matching parentheses.\";\n        String expected = \"This is a test without matching parentheses.\";\n        assertEquals(expected, removeInnerAsterisks(text));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Transforms the input text by finding and modifying patterns that match the format '(...)'.\n * Specifically, it removes any asterisks inside the parentheses while preserving the outer format.\n * \n * For example:\n * input: hello\n * output: hello\n *\n * @param text The input text containing patterns to be transformed.\n * @return The transformed text with asterisks inside '(*...*)' patterns removed.\n */\npublic static String removeInnerAsterisks(String text) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 21, "code_type": "method", "original_language": "python", "file_path": "ecosim-ontology\\44a380ef9b04577b15cbed22110a1691c2a08ae0\\utils\\fortran2params.py", "question_type": "Data processing and transformation", "summary": " compare the contents of two files and print the differences in unified diff format.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef diff_files(file1_path: str, file2_path: str) -> List[str]:\n    \"\"\"\n    Compare the contents of two files and print the differences in unified diff format.\n\n    Args:\n    file1_path (str): Path to the first file.\n    file2_path (str): Path to the second file.\n\n    Returns:\n    List[str]: A list containing the lines of differences, if any.\n\n    Raises:\n    FileNotFoundError: If either file does not exist.\n    IOError: If there is an error reading the files.\n    \"\"\"\n", "test_code": "import os\nimport unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestCompareFiles(unittest.TestCase):\n\n    def setUp(self):\n        # \u521b\u5efa\u6587\u4ef6\u7528\u4e8e\u6d4b\u8bd5\n        self.file1_path = 'file1.txt'\n        self.file2_path = 'file2.txt'\n\n    def tearDown(self):\n        # \u5220\u9664\u521b\u5efa\u7684\u6587\u4ef6\n        if os.path.exists(self.file1_path):\n            os.remove(self.file1_path)\n        if os.path.exists(self.file2_path):\n            os.remove(self.file2_path)\n\n    def test_identical_files(self):\n        # Mock question for two identical files\n        file1_content = \"Line1\\nLine2\\nLine3\\n\"\n        file2_content = \"Line1\\nLine2\\nLine3\\n\"\n\n        with open(self.file1_path, 'w') as f1, open(self.file2_path, 'w') as f2:\n            f1.write(file1_content)\n            f2.write(file2_content)\n\n        result = diff_files(self.file1_path, self.file2_path)\n        self.assertEqual(len(result), 0, \"There should be no differences detected\")\n\n    def test_files_with_differences(self):\n        # Mock question for two different files\n        file1_content = \"Line1\\nLine2\\nLine3\\n\"\n        file2_content = \"Line1\\nLineChanged\\nLine3\\n\"\n\n        with open(self.file1_path, 'w') as f1, open(self.file2_path, 'w') as f2:\n            f1.write(file1_content)\n            f2.write(file2_content)\n\n        result = diff_files(self.file1_path, self.file2_path)\n        self.assertNotEqual(len(result), 0, \"There should be differences detected\")\n\n    def test_nonexistent_file(self):\n        # Test when one of the files does not exist\n        with patch('builtins.open', side_effect=FileNotFoundError(\"File not found\")):\n            with self.assertRaises(FileNotFoundError):\n                diff_files('nonexistent.txt', 'file2.txt')\n\n    def test_file_reading_error(self):\n        # Test when there's an error reading the file\n        with patch('builtins.open', side_effect=IOError(\"Error reading file\")):\n            with self.assertRaises(IOError):\n                diff_files('file1.txt', 'file2.txt')\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef diff_files(file1_path: str, file2_path: str) -> List[str]:\n    \"\"\"\n    Compare the contents of two files and print the differences in unified diff format.\n\n    Args:\n    file1_path (str): Path to the first file.\n    file2_path (str): Path to the second file.\n\n    Returns:\n    List[str]: A list containing the lines of differences, if any.\n\n    Raises:\n    FileNotFoundError: If either file does not exist.\n    IOError: If there is an error reading the files.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief compare the contents of two files and print the differences in unified diff format.\n *\n * @param file1_path Path to the first file.\n * @param file2_path Path to the second file.\n *\n * @return A vector containing the lines of differences, if any.\n *\n * @throws std::runtime_error If either file does not exist or there is an error reading the files.\n */\nstd::vector<std::string> compare_files(const std::string& file1_path, const std::string& file2_path) {}", "test_code": "TEST_CASE(\"Test Compare Files\") {\n    // Create temporary files for testing\n    const std::string file1_path = \"file1.txt\";\n    const std::string file2_path = \"file2.txt\";\n\n    SECTION(\"Identical Files\") {\n        std::string file1_content = \"Line1\\nLine2\\nLine3\\n\";\n        std::string file2_content = \"Line1\\nLine2\\nLine3\\n\";\n\n        std::ofstream f1(file1_path);\n        std::ofstream f2(file2_path);\n        f1 << file1_content;\n        f2 << file2_content;\n\n        REQUIRE(compare_files(file1_path, file2_path).empty());\n    }\n\n    SECTION(\"Files with Differences\") {\n        std::string file1_content = \"Line1\\nLine2\\nLine3\\n\";\n        std::string file2_content = \"Line1\\nLineChanged\\nLine3\\n\";\n\n        std::ofstream f1(file1_path);\n        std::ofstream f2(file2_path);\n        f1 << file1_content;\n        f2 << file2_content;\n\n        auto result = compare_files(file1_path, file2_path);\n        REQUIRE(!result.empty());\n    }\n\n    SECTION(\"Nonexistent File\") {\n        REQUIRE_THROWS_AS(compare_files(\"nonexistent.txt\", file2_path), std::runtime_error);\n    }\n\n    SECTION(\"File Reading Error\") {\n        // Simulate file reading error by creating a file that cannot be read\n        std::ofstream f1(file1_path);\n        f1 << \"Line1\\nLine2\\nLine3\\n\";\n\n        // Change file permissions to make it unreadable\n        fs::permissions(file1_path, fs::perms::none);\n\n        REQUIRE_THROWS_AS(compare_files(file1_path, file2_path), std::runtime_error);\n\n        // Restore file permissions\n        fs::permissions(file1_path, fs::perms::owner_read | fs::perms::owner_write);\n    }\n\n    // Clean up temporary files\n    if (fs::exists(file1_path)) {\n        fs::remove(file1_path);\n    }\n    if (fs::exists(file2_path)) {\n        fs::remove(file2_path);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief compare the contents of two files and print the differences in unified diff format.\n *\n * @param file1_path Path to the first file.\n * @param file2_path Path to the second file.\n *\n * @return A vector containing the lines of differences, if any.\n *\n * @throws std::runtime_error If either file does not exist or there is an error reading the files.\n */\nstd::vector<std::string> compare_files(const std::string& file1_path, const std::string& file2_path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Compare the contents of two files and print the differences in unified diff format.\n *\n * @param file1Path Path to the first file.\n * @param file2Path Path to the second file.\n * @return A list containing the lines of differences, if any.\n * @throws java.io.FileNotFoundException If either file does not exist.\n * @throws java.io.IOException If there is an error reading the files.\n */\npublic static List<String> compareFiles(String file1Path, String file2Path) throws java.io.FileNotFoundException, IOException {}", "test_code": "package org.real.temp;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.util.List;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Mock;\nimport org.mockito.Mockito;\nimport org.mockito.MockitoAnnotations;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\npublic class Tester {\n\n    private static final String FILE1_CONTENT = \"Line1\\nLine2\\nLine3\\n\";\n    private static final String FILE2_CONTENT = \"Line1\\nLineChanged\\nLine3\\n\";\n\n    private Path file1Path;\n    private Path file2Path;\n\n    @BeforeEach\n    public void setUp(@TempDir Path tempDir) {\n        file1Path = tempDir.resolve(\"file1.txt\");\n        file2Path = tempDir.resolve(\"file2.txt\");\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (file1Path.toFile().exists()) {\n            file1Path.toFile().delete();\n        }\n        if (file2Path.toFile().exists()) {\n            file2Path.toFile().delete();\n        }\n    }\n\n    @Test\n    public void testIdenticalFiles() throws IOException {\n        writeToFile(file1Path, FILE1_CONTENT);\n        writeToFile(file2Path, FILE1_CONTENT);\n\n        List<String> result = compareFiles(file1Path.toString(), file2Path.toString());\n        assertEquals(0, result.size(), \"There should be no differences detected\");\n    }\n\n    @Test\n    public void testFilesWithDifferences() throws IOException {\n        writeToFile(file1Path, FILE1_CONTENT);\n        writeToFile(file2Path, FILE2_CONTENT);\n\n        List<String> result = compareFiles(file1Path.toString(), file2Path.toString());\n        assertNotEquals(0, result.size(), \"There should be differences detected\");\n    }\n\n    @Test\n    public void testNonexistentFile() {\n        try (MockedStatic<Answer> mockedStatic = Mockito.mockStatic(Answer.class)) {\n            mockedStatic.when(() -> Answer.readFile(\"nonexistent.txt\"))\n                    .thenThrow(new java.io.FileNotFoundException(\"File not found\"));\n\n            Exception exception = assertThrows(java.io.FileNotFoundException.class,\n                    () -> compareFiles(\"nonexistent.txt\", file2Path.toString()));\n            assertEquals(\"File not found\", exception.getMessage());\n        }\n    }\n\n    @Test\n    public void testFileReadingError() {\n        try (MockedStatic<Answer> mockedStatic = Mockito.mockStatic(Answer.class)) {\n            mockedStatic.when(() -> Answer.readFile(file1Path.toString()))\n                    .thenThrow(new java.io.IOException(\"Error reading file\"));\n\n            Exception exception = assertThrows(java.io.IOException.class,\n                    () -> compareFiles(file1Path.toString(), file2Path.toString()));\n            assertEquals(\"Error reading file\", exception.getMessage());\n        }\n    }\n\n    private void writeToFile(Path filePath, String content) throws IOException {\n        try (FileWriter writer = new FileWriter(filePath.toFile())) {\n            writer.write(content);\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Compare the contents of two files and print the differences in unified diff format.\n *\n * @param file1Path Path to the first file.\n * @param file2Path Path to the second file.\n * @return A list containing the lines of differences, if any.\n * @throws java.io.FileNotFoundException If either file does not exist.\n * @throws java.io.IOException If there is an error reading the files.\n */\npublic static List<String> compareFiles(String file1Path, String file2Path) throws java.io.FileNotFoundException, IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 22, "code_type": "method", "original_language": "python", "file_path": "python-2draycasting-lines\\e848288fd0a6ceb9e53f9092579624ea43effdf0\\utils.py", "question_type": "Algorithm and data structure", "summary": "calculate the Euclidean distance between two points", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef calculate_euclidean_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n    \"\"\"\n    calculate the Euclidean distance between two points in a 2D space.\n\n    Args:\n        point1 (Tuple[float, float]): The first point as a tuple of coordinates (x1, y1).\n        point2 (Tuple[float, float]): The second point as a tuple of coordinates (x2, y2).\n\n    Returns:\n        float: The Euclidean distance between the two points.\n\n    \"\"\"\n", "test_code": "import unittest\nfrom typing import Tuple\n\nclass TestCalculateEuclideanDistance(unittest.TestCase):\n\n    def test_basic_functionality(self):\n        # Basic logic functionality test.js\n        point1 = (0, 0)\n        point2 = (3, 4)\n        expected_distance = 5.0\n        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, \"Should calculate the distance correctly\")\n\n    def test_negative_coordinates(self):\n        # Test with negative coordinates\n        point1 = (-1, -1)\n        point2 = (-4, -5)\n        expected_distance = 5.0\n        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, \"Should handle negative coordinates correctly\")\n\n    def test_zero_distance(self):\n        # Boundary test.js: points are the same\n        point1 = (2, 3)\n        point2 = (2, 3)\n        expected_distance = 0.0\n        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, \"Should return 0 when both points are the same\")\n\n    def test_large_coordinates(self):\n        # Boundary test.js: large coordinates\n        point1 = (1e6, 1e6)\n        point2 = (1e6 + 3, 1e6 + 4)\n        expected_distance = 5.0\n        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, \"Should handle large coordinates correctly\")\n\n    def test_invalid_input(self):\n        # Exception handling test.js: invalid input (non-tuple)\n        with self.assertRaises(TypeError):\n            calculate_euclidean_distance(\"invalid\", (0, 0))\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef calculate_euclidean_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n    \"\"\"\n    calculate the Euclidean distance between two points in a 2D space.\n\n    Args:\n        point1 (Tuple[float, float]): The first point as a tuple of coordinates (x1, y1).\n        point2 (Tuple[float, float]): The second point as a tuple of coordinates (x2, y2).\n\n    Returns:\n        float: The Euclidean distance between the two points.\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the Euclidean distance between two points in a 2D space.\n *\n * This function computes the Euclidean distance between two points represented \n * as tuples of coordinates (x, y).\n *\n * @param point1 A tuple representing the first point (x1, y1).\n * @param point2 A tuple representing the second point (x2, y2).\n * @return The Euclidean distance between the two points as a float.\n */\nfloat calculate_euclidean_distance(const std::tuple<float, float>& point1, const std::tuple<float, float>& point2) {}", "test_code": "TEST_CASE(\"Test basic functionality\") {\n    // Basic logic functionality test\n    auto point1 = std::make_tuple(0.0f, 0.0f);\n    auto point2 = std::make_tuple(3.0f, 4.0f);\n    float expected_distance = 5.0f;\n\n    REQUIRE(calculate_euclidean_distance(point1, point2) == Approx(expected_distance));\n}\n\nTEST_CASE(\"Test with negative coordinates\") {\n    // Test with negative coordinates\n    auto point1 = std::make_tuple(-1.0f, -1.0f);\n    auto point2 = std::make_tuple(-4.0f, -5.0f);\n    float expected_distance = 5.0f;\n\n    REQUIRE(calculate_euclidean_distance(point1, point2) == Approx(expected_distance));\n}\n\nTEST_CASE(\"Test zero distance\") {\n    // Boundary test: points are the same\n    auto point1 = std::make_tuple(2.0f, 3.0f);\n    auto point2 = std::make_tuple(2.0f, 3.0f);\n    float expected_distance = 0.0f;\n\n    REQUIRE(calculate_euclidean_distance(point1, point2) == Approx(expected_distance));\n}\n\nTEST_CASE(\"Test large coordinates\") {\n    // Boundary test: large coordinates\n    auto point1 = std::make_tuple(1e6f, 1e6f);\n    auto point2 = std::make_tuple(1e6f + 3.0f, 1e6f + 4.0f);\n    float expected_distance = 5.0f;\n\n    REQUIRE(calculate_euclidean_distance(point1, point2) == Approx(expected_distance));\n}\n\nTEST_CASE(\"Test invalid input\") {\n    // Exception handling test: invalid input (non-tuple)\n    REQUIRE_THROWS_AS(calculate_euclidean_distance(std::make_tuple(\"invalid\", 0.0f), std::make_tuple(0.0f, 0.0f)), std::invalid_argument);\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the Euclidean distance between two points in a 2D space.\n *\n * This function computes the Euclidean distance between two points represented \n * as tuples of coordinates (x, y).\n *\n * @param point1 A tuple representing the first point (x1, y1).\n * @param point2 A tuple representing the second point (x2, y2).\n * @return The Euclidean distance between the two points as a float.\n */\nfloat calculate_euclidean_distance(const std::tuple<float, float>& point1, const std::tuple<float, float>& point2) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the Euclidean distance between two points in a 2D space.\n *\n * @param point1 The first point as an array of coordinates [x1, y1].\n * @param point2 The second point as an array of coordinates [x2, y2].\n * @return The Euclidean distance between the two points.\n */\npublic static double calculateEuclideanDistance(double[] point1, double[] point2) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\npublic class Tester {\n\n    @Test\n    public void testBasicFunctionality() {\n        // Basic logic functionality test\n        double[] point1 = {0.0, 0.0};\n        double[] point2 = {3.0, 4.0};\n        double expectedDistance = 5.0;\n        assertEquals(expectedDistance, calculateEuclideanDistance(point1, point2), 0.001, \"Should calculate the distance correctly\");\n    }\n\n    @Test\n    public void testNegativeCoordinates() {\n        // Test with negative coordinates\n        double[] point1 = {-1.0, -1.0};\n        double[] point2 = {-4.0, -5.0};\n        double expectedDistance = 5.0;\n        assertEquals(expectedDistance, calculateEuclideanDistance(point1, point2), 0.001, \"Should handle negative coordinates correctly\");\n    }\n\n    @Test\n    public void testZeroDistance() {\n        // Boundary test: points are the same\n        double[] point1 = {2.0, 3.0};\n        double[] point2 = {2.0, 3.0};\n        double expectedDistance = 0.0;\n        assertEquals(expectedDistance, calculateEuclideanDistance(point1, point2), 0.001, \"Should return 0 when both points are the same\");\n    }\n\n    @Test\n    public void testLargeCoordinates() {\n        // Boundary test: large coordinates\n        double[] point1 = {1e6, 1e6};\n        double[] point2 = {1e6 + 3, 1e6 + 4};\n        double expectedDistance = 5.0;\n        assertEquals(expectedDistance, calculateEuclideanDistance(point1, point2), 0.001, \"Should handle large coordinates correctly\");\n    }\n\n    @Test\n    public void testInvalidInput() {\n        // Exception handling test: invalid input (null)\n        assertThrows(IllegalArgumentException.class, () -> {\n            calculateEuclideanDistance(null, new double[]{0.0, 0.0});\n        });\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Calculates the Euclidean distance between two points in a 2D space.\n *\n * @param point1 The first point as an array of coordinates [x1, y1].\n * @param point2 The second point as an array of coordinates [x2, y2].\n * @return The Euclidean distance between the two points.\n */\npublic static double calculateEuclideanDistance(double[] point1, double[] point2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 23, "code_type": "method", "original_language": "python", "file_path": "python-2draycasting-lines\\e848288fd0a6ceb9e53f9092579624ea43effdf0\\utils.py", "question_type": "Algorithm and data structure", "summary": "calculate the intersection point of two line segments.", "language_version_list": {"python": {"code_signature": "from typing import Union\n\n\ndef check_segments_intersection(seg1: tuple, seg2: tuple) -> Union[tuple, None]:\n    \"\"\"\n    Calculate the intersection point of two line segments, if it exists.\n\n    Args:\n        seg1 (tuple): Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n        seg2 (tuple): Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n\n    Returns:\n        Union[tuple, None]: The (x, y) coordinates of the intersection point if the line segments intersect,\n                            otherwise None.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestLineSegmentIntersection(unittest.TestCase):\n\n    def test_intersection(self):\n        seg1 = ((1, 1), (4, 4))\n        seg2 = ((1, 4), (4, 1))\n        expected = (2.5, 2.5)\n        result = check_segments_intersection(seg1, seg2)\n        self.assertEqual(result, expected, \"The intersection should be at (2.5, 2.5)\")\n\n    def test_no_intersection(self):\n        seg1 = ((1, 1), (2, 2))\n        seg2 = ((3, 3), (4, 4))\n        result = check_segments_intersection(seg1, seg2)\n        self.assertIsNone(result, \"There should be no intersection\")\n\n    def test_parallel_segments(self):\n        seg1 = ((1, 1), (2, 2))\n        seg2 = ((1, 2), (2, 3))\n        result = check_segments_intersection(seg1, seg2)\n        self.assertIsNone(result, \"Parallel segments should not intersect\")\n\n    def test_no_intersection_due_to_offset(self):\n        seg1 = ((1, 1), (3, 3))\n        seg2 = ((3, 2), (4, 2))\n        result = check_segments_intersection(seg1, seg2)\n        self.assertIsNone(result, \"There should be no intersection due to offset between segments\")\n\n    def test_intersection_with_large_coordinates(self):\n        seg1 = ((1000, 1000), (2000, 2000))\n        seg2 = ((1000, 2000), (2000, 1000))\n        expected = (1500.0, 1500.0)\n        result = check_segments_intersection(seg1, seg2)\n        self.assertEqual(result, expected, \"The intersection should be at (1500.0, 1500.0)\")\n\n\n", "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef check_segments_intersection(seg1: tuple, seg2: tuple) -> Union[tuple, None]:\n    \"\"\"\n    Calculate the intersection point of two line segments, if it exists.\n\n    Args:\n        seg1 (tuple): Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n        seg2 (tuple): Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n\n    Returns:\n        Union[tuple, None]: The (x, y) coordinates of the intersection point if the line segments intersect,\n                            otherwise None.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "union IntersectionResult {\n    std::pair<double, double> point;\n    bool isNone;\n\n    IntersectionResult() : isNone(true) {}\n    IntersectionResult(double x, double y) : point(x, y), isNone(false) {}\n\n    // Destructor\n    ~IntersectionResult() {}\n\n    // Equality operator for checking if the result is None\n    bool operator==(const std::pair<double, double>& p) const {\n        return !isNone && point == p;\n    }\n\n    // Equality operator for checking if the result is None\n    bool operator==(bool none) const {\n        return isNone == none;\n    }\n};\n\n/**\n * @brief Calculate the intersection point of two line segments, if it exists.\n *\n * @param seg1 Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n * @param seg2 Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n * @return The (x, y) coordinates of the intersection point if the line segments intersect,\n *         otherwise an empty IntersectionResult indicating no intersection.\n */\nIntersectionResult get_line_segment_intersection(const std::pair<std::pair<double, double>, std::pair<double, double>>& seg1,\n                                              const std::pair<std::pair<double, double>, std::pair<double, double>>& seg2) {}", "test_code": "TEST_CASE(\"Test Line Segment Intersection\") {\n    SECTION(\"Intersection\") {\n        auto seg1 = std::make_pair(std::make_pair(1.0, 1.0), std::make_pair(4.0, 4.0));\n        auto seg2 = std::make_pair(std::make_pair(1.0, 4.0), std::make_pair(4.0, 1.0));\n        auto expected = std::make_pair(2.5, 2.5);\n        auto result = get_line_segment_intersection(seg1, seg2);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"No Intersection\") {\n        auto seg1 = std::make_pair(std::make_pair(1.0, 1.0), std::make_pair(2.0, 2.0));\n        auto seg2 = std::make_pair(std::make_pair(3.0, 3.0), std::make_pair(4.0, 4.0));\n        auto result = get_line_segment_intersection(seg1, seg2);\n        REQUIRE(result == true); // True indicates no intersection\n    }\n\n    SECTION(\"Parallel Segments\") {\n        auto seg1 = std::make_pair(std::make_pair(1.0, 1.0), std::make_pair(2.0, 2.0));\n        auto seg2 = std::make_pair(std::make_pair(1.0, 2.0), std::make_pair(2.0, 3.0));\n        auto result = get_line_segment_intersection(seg1, seg2);\n        REQUIRE(result == true); // True indicates no intersection\n    }\n\n    SECTION(\"No Intersection Due to Offset\") {\n        auto seg1 = std::make_pair(std::make_pair(1.0, 1.0), std::make_pair(3.0, 3.0));\n        auto seg2 = std::make_pair(std::make_pair(3.0, 2.0), std::make_pair(4.0, 2.0));\n        auto result = get_line_segment_intersection(seg1, seg2);\n        REQUIRE(result == true); // True indicates no intersection\n    }\n\n    SECTION(\"Intersection with Large Coordinates\") {\n        auto seg1 = std::make_pair(std::make_pair(1000.0, 1000.0), std::make_pair(2000.0, 2000.0));\n        auto seg2 = std::make_pair(std::make_pair(1000.0, 2000.0), std::make_pair(2000.0, 1000.0));\n        auto expected = std::make_pair(1500.0, 1500.0);\n        auto result = get_line_segment_intersection(seg1, seg2);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below union IntersectionResult {\n    std::pair<double, double> point;\n    bool isNone;\n\n    IntersectionResult() : isNone(true) {}\n    IntersectionResult(double x, double y) : point(x, y), isNone(false) {}\n\n    // Destructor\n    ~IntersectionResult() {}\n\n    // Equality operator for checking if the result is None\n    bool operator==(const std::pair<double, double>& p) const {\n        return !isNone && point == p;\n    }\n\n    // Equality operator for checking if the result is None\n    bool operator==(bool none) const {\n        return isNone == none;\n    }\n};\n\n/**\n * @brief Calculate the intersection point of two line segments, if it exists.\n *\n * @param seg1 Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n * @param seg2 Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n * @return The (x, y) coordinates of the intersection point if the line segments intersect,\n *         otherwise an empty IntersectionResult indicating no intersection.\n */\nIntersectionResult get_line_segment_intersection(const std::pair<std::pair<double, double>, std::pair<double, double>>& seg1,\n                                              const std::pair<std::pair<double, double>, std::pair<double, double>>& seg2) {}", "addition_info": "union IntersectionResult {\n    std::pair<double, double> point;\n    bool isNone;\n\n    IntersectionResult() : isNone(true) {}\n    IntersectionResult(double x, double y) : point(x, y), isNone(false) {}\n\n    // Destructor\n    ~IntersectionResult() {}\n\n    // Equality operator for checking if the result is None\n    bool operator==(const std::pair<double, double>& p) const {\n        return !isNone && point == p;\n    }\n\n    // Equality operator for checking if the result is None\n    bool operator==(bool none) const {\n        return isNone == none;\n    }\n};"}, "java": {"code_signature": "/**\n * Calculates the intersection point of two line segments, if it exists.\n *\n * @param seg1 Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n * @param seg2 Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n * @return A Point representing the (x, y) coordinates of the intersection point if the line segments intersect,\n *         otherwise null.\n */\npublic static Point getLineSegmentIntersection(Point seg1Start, Point seg1End, Point seg2Start, Point seg2End) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void testIntersection() {\n        Point seg1Start = new Point(1, 1);\n        Point seg1End = new Point(4, 4);\n        Point seg2Start = new Point(1, 4);\n        Point seg2End = new Point(4, 1);\n        Point expected = new Point(2.5, 2.5);\n\n        Point result = getLineSegmentIntersection(seg1Start, seg1End, seg2Start, seg2End);\n        assertEquals(\"The intersection should be at (2.5, 2.5)\", expected, result);\n    }\n\n    @Test\n    public void testNoIntersection() {\n        Point seg1Start = new Point(1, 1);\n        Point seg1End = new Point(2, 2);\n        Point seg2Start = new Point(3, 3);\n        Point seg2End = new Point(4, 4);\n\n        Point result = getLineSegmentIntersection(seg1Start, seg1End, seg2Start, seg2End);\n        assertNull(\"There should be no intersection\", result);\n    }\n\n    @Test\n    public void testParallelSegments() {\n        Point seg1Start = new Point(1, 1);\n        Point seg1End = new Point(2, 2);\n        Point seg2Start = new Point(1, 2);\n        Point seg2End = new Point(2, 3);\n\n        Point result = getLineSegmentIntersection(seg1Start, seg1End, seg2Start, seg2End);\n        assertNull(\"Parallel segments should not intersect\", result);\n    }\n\n    @Test\n    public void testNoIntersectionDueToOffset() {\n        Point seg1Start = new Point(1, 1);\n        Point seg1End = new Point(3, 3);\n        Point seg2Start = new Point(3, 2);\n        Point seg2End = new Point(4, 2);\n\n        Point result = getLineSegmentIntersection(seg1Start, seg1End, seg2Start, seg2End);\n        assertNull(\"There should be no intersection due to offset between segments\", result);\n    }\n\n    @Test\n    public void testIntersectionWithLargeCoordinates() {\n        Point seg1Start = new Point(1000, 1000);\n        Point seg1End = new Point(2000, 2000);\n        Point seg2Start = new Point(1000, 2000);\n        Point seg2End = new Point(2000, 1000);\n        Point expected = new Point(1500.0, 1500.0);\n\n        Point result = getLineSegmentIntersection(seg1Start, seg1End, seg2Start, seg2End);\n        assertEquals(\"The intersection should be at (1500.0, 1500.0)\", expected, result);\n    }\n    /**\n     * Represents a point with x and y coordinates.\n     */\n    static class Point {\n        double x, y;\n\n        /**\n         * Constructs a new Point with the specified coordinates.\n         *\n         * @param x The x-coordinate.\n         * @param y The y-coordinate.\n         */\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        /**\n         * Compares this Point with another Point for equality.\n         *\n         * @param obj The other Point to compare with.\n         * @return true if the Points are equal, false otherwise.\n         */\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null || getClass() != obj.getClass()) {\n                return false;\n            }\n            Point other = (Point) obj;\n            return Double.compare(x, other.x) == 0 && Double.compare(y, other.y) == 0;\n        }\n\n        /**\n         * Returns a string representation of the Point.\n         *\n         * @return A string in the format \"(x, y)\".\n         */\n        @Override\n        public String toString() {\n            return \"(\" + x + \", \" + y + \")\";\n        }\n\n        /**\n         * Generates a hash code for the Point.\n         *\n         * @return The hash code.\n         */\n        @Override\n        public int hashCode() {\n            return Objects.hash(x, y);\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the intersection point of two line segments, if it exists.\n *\n * @param seg1 Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n * @param seg2 Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n * @return A Point representing the (x, y) coordinates of the intersection point if the line segments intersect,\n *         otherwise null.\n */\npublic static Point getLineSegmentIntersection(Point seg1Start, Point seg1End, Point seg2Start, Point seg2End) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 24, "code_type": "method", "original_language": "python", "file_path": "Hypothesizer-CLI\\51c51a4562228c44f26e13e24cbe998932fe82c4\\Parsers\\SemgrepConversion.py", "question_type": "Data processing and transformation", "summary": "convert yaml format files to json format files\n", "language_version_list": {"python": {"code_signature": "def convert_yaml_to_json(yaml_file: str, json_file: str) -> None:\n    \"\"\"\n    convert yaml format files to json format files\n    Args:\n        yaml_file (str): path to the input YAML file.\n        json_file (str): path to the output JSON file.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\nimport os\nimport json\nimport yaml\n\n\nclass TestConvertYamlToJson(unittest.TestCase):\n\n    def setUp(self):\n        # Create temporary YAML files for testing\n        self.simple_yaml = 'simple.yaml'\n        self.nested_yaml = 'nested.yaml'\n        self.empty_yaml = 'empty.yaml'\n        self.list_yaml = 'list.yaml'\n        self.invalid_yaml = 'invalid.yaml'\n\n        with open(self.simple_yaml, 'w') as file:\n            file.write(\"name: John Doe\\nage: 30\\n\")\n\n        with open(self.nested_yaml, 'w') as file:\n            file.write(\"person:\\n  name: Jane Doe\\n  age: 25\\n  address:\\n    city: New York\\n    zip: 10001\\n\")\n\n        with open(self.empty_yaml, 'w') as file:\n            file.write(\"\")\n\n        with open(self.list_yaml, 'w') as file:\n            file.write(\"- item1\\n- item2\\n- item3\\n\")\n\n        with open(self.invalid_yaml, 'w') as file:\n            file.write(\"{ invalid: YAML: structure }\\n\")\n\n    def tearDown(self):\n        # Remove temporary files after testing\n        os.remove(self.simple_yaml)\n        os.remove(self.nested_yaml)\n        os.remove(self.empty_yaml)\n        os.remove(self.list_yaml)\n        os.remove(self.invalid_yaml)\n\n        if os.path.exists('output.json'):\n            os.remove('output.json')\n\n    def test_simple_yaml_conversion(self):\n        convert_yaml_to_json(self.simple_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        self.assertEqual(data, {\"name\": \"John Doe\", \"age\": 30})\n\n    def test_nested_yaml_conversion(self):\n        convert_yaml_to_json(self.nested_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        expected_data = {\n            \"person\": {\n                \"name\": \"Jane Doe\",\n                \"age\": 25,\n                \"address\": {\n                    \"city\": \"New York\",\n                    \"zip\": 10001\n                }\n            }\n        }\n        self.assertEqual(data, expected_data)\n\n    def test_empty_yaml_conversion(self):\n        convert_yaml_to_json(self.empty_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        self.assertEqual(data, None)  # YAML.safe_load() returns None for empty files\n\n    def test_list_yaml_conversion(self):\n        convert_yaml_to_json(self.list_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        self.assertEqual(data, [\"item1\", \"item2\", \"item3\"])\n\n    def test_invalid_yaml_conversion(self):\n        with self.assertRaises(yaml.YAMLError):\n            convert_yaml_to_json(self.invalid_yaml, 'output.json')\n", "prompt": "please write a python function , the function signature as below def convert_yaml_to_json(yaml_file: str, json_file: str) -> None:\n    \"\"\"\n    convert yaml format files to json format files\n    Args:\n        yaml_file (str): path to the input YAML file.\n        json_file (str): path to the output JSON file.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert a YAML file to a JSON file.\n *\n * @param yaml_file Path to the input YAML file.\n * @param json_file Path to the output JSON file.\n */\nvoid convert_yaml_to_json(const std::string& yaml_file, const std::string& json_file) {}", "test_code": "TEST_CASE(\"Test conversion of YAML files to JSON\") {\n    // Create temporary YAML files for testing\n    const std::string simple_yaml = \"simple.yaml\";\n    const std::string nested_yaml = \"nested.yaml\";\n    const std::string empty_yaml = \"empty.yaml\";\n    const std::string list_yaml = \"list.yaml\";\n    const std::string invalid_yaml = \"invalid.yaml\";\n\n    SECTION(\"Setup temporary files\") {\n        // Write simple YAML file\n        std::ofstream simpleFile(simple_yaml);\n        simpleFile << \"name: John Doe\\nage: 30\\n\";\n        simpleFile.close();\n\n        // Write nested YAML file\n        std::ofstream nestedFile(nested_yaml);\n        nestedFile << \"person:\\n  name: Jane Doe\\n  age: 25\\n  address:\\n    city: New York\\n    zip: 10001\\n\";\n        nestedFile.close();\n\n        // Write empty YAML file\n        std::ofstream emptyFile(empty_yaml);\n        emptyFile.close();\n\n        // Write list YAML file\n        std::ofstream listFile(list_yaml);\n        listFile << \"- item1\\n- item2\\n- item3\\n\";\n        listFile.close();\n\n        // Write invalid YAML file\n        std::ofstream invalidFile(invalid_yaml);\n        invalidFile << \"{ invalid: YAML: structure }\\n\";\n        invalidFile.close();\n    }\n\n    SECTION(\"Test simple YAML conversion\") {\n        convert_yaml_to_json(simple_yaml, \"output.json\");\n        std::ifstream jsonFile(\"output.json\");\n        REQUIRE(jsonFile.is_open());\n        json jsonData;\n        jsonFile >> jsonData;\n        REQUIRE(jsonData == (json{{\"name\", \"John Doe\"}, {\"age\", 30}}));\n    }\n\n    SECTION(\"Test nested YAML conversion\") {\n        convert_yaml_to_json(nested_yaml, \"output.json\");\n        std::ifstream jsonFile(\"output.json\");\n        REQUIRE(jsonFile.is_open());\n        json jsonData;\n        jsonFile >> jsonData;\n        REQUIRE(jsonData == (json{\n            {\"person\", {\n                {\"name\", \"Jane Doe\"},\n                {\"age\", 25},\n                {\"address\", {\n                    {\"city\", \"New York\"},\n                    {\"zip\", 10001}\n                }}\n            }}\n        }));\n    }\n\n    SECTION(\"Test empty YAML conversion\") {\n        convert_yaml_to_json(empty_yaml, \"output.json\");\n        std::ifstream jsonFile(\"output.json\");\n        REQUIRE(jsonFile.is_open());\n        json jsonData;\n        jsonFile >> jsonData;\n        REQUIRE(jsonData.is_null());\n    }\n\n    SECTION(\"Test list YAML conversion\") {\n        convert_yaml_to_json(list_yaml, \"output.json\");\n        std::ifstream jsonFile(\"output.json\");\n        REQUIRE(jsonFile.is_open());\n        json jsonData;\n        jsonFile >> jsonData;\n        REQUIRE(jsonData == (json{\"item1\", \"item2\", \"item3\"}));\n    }\n\n    SECTION(\"Test invalid YAML conversion\") {\n        REQUIRE_THROWS_AS(convert_yaml_to_json(invalid_yaml, \"output.json\"), YAML::Exception);\n    }\n\n    SECTION(\"Teardown temporary files\") {\n        std::remove(simple_yaml.c_str());\n        std::remove(nested_yaml.c_str());\n        std::remove(empty_yaml.c_str());\n        std::remove(list_yaml.c_str());\n        std::remove(invalid_yaml.c_str());\n        if (std::ifstream(\"output.json\").is_open()) {\n            std::remove(\"output.json\");\n        }\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert a YAML file to a JSON file.\n *\n * @param yaml_file Path to the input YAML file.\n * @param json_file Path to the output JSON file.\n */\nvoid convert_yaml_to_json(const std::string& yaml_file, const std::string& json_file) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a YAML file to a JSON file.\n *\n * @param yamlFilePath  Path to the input YAML file.\n * @param jsonFilePath  Path to the output JSON file.\n */\npublic static void convertYamlToJson(String yamlFilePath, String jsonFilePath) {}", "test_code": "package org.real.temp;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\nimport com.fasterxml.jackson.core.JsonProcessingException;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.Rule;\nimport org.junit.rules.TemporaryFolder;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Path;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\n/**\n * Tests for converting YAML files to JSON files.\n */\npublic class Tester {\n\n    private static final String SIMPLE_YAML = \"simple.yaml\";\n    private static final String NESTED_YAML = \"nested.yaml\";\n    private static final String EMPTY_YAML = \"empty.yaml\";\n    private static final String LIST_YAML = \"list.yaml\";\n    private static final String INVALID_YAML = \"invalid.yaml\";\n\n    @Rule\n    public TemporaryFolder tempFolder = new TemporaryFolder();\n\n    private Path tempDir;\n\n    @Before\n    public void setUp() throws IOException {\n        this.tempDir = tempFolder.newFolder().toPath();\n\n        // Create temporary YAML files for testing\n        writeYamlFile(tempDir.resolve(SIMPLE_YAML), \"name: John Doe\\nage: 30\\n\");\n        writeYamlFile(tempDir.resolve(NESTED_YAML), \"person:\\n  name: Jane Doe\\n  age: 25\\n  address:\\n    city: New York\\n    zip: 10001\\n\");\n        writeYamlFile(tempDir.resolve(EMPTY_YAML), \"\");\n        writeYamlFile(tempDir.resolve(LIST_YAML), \"- item1\\n- item2\\n- item3\\n\");\n        writeYamlFile(tempDir.resolve(INVALID_YAML), \"{ invalid: YAML: structure }\\n\");\n    }\n\n    @After\n    public void tearDown() {\n        // No explicit cleanup required with TemporaryFolder\n    }\n\n    @Test\n    public void testSimpleYamlConversion() throws IOException {\n        convertYamlToJson(tempDir.resolve(SIMPLE_YAML).toString(), \"output.json\");\n        assertEquals(\"{\\\"name\\\":\\\"John Doe\\\",\\\"age\\\":30}\", readFileContent(tempDir.resolve(\"output.json\")));\n    }\n\n    @Test\n    public void testNestedYamlConversion() throws IOException {\n        convertYamlToJson(tempDir.resolve(NESTED_YAML).toString(), \"output.json\");\n        assertEquals(\"{\\\"person\\\":{\\\"name\\\":\\\"Jane Doe\\\",\\\"age\\\":25,\\\"address\\\":{\\\"city\\\":\\\"New York\\\",\\\"zip\\\":10001}}}\", readFileContent(tempDir.resolve(\"output.json\")));\n    }\n\n    @Test\n    public void testEmptyYamlConversion() throws IOException {\n        convertYamlToJson(tempDir.resolve(EMPTY_YAML).toString(), \"output.json\");\n        assertEquals(\"\", readFileContent(tempDir.resolve(\"output.json\")));  // YAML.safe_load() returns null, but JSON dump of null is \"\"\n    }\n\n    @Test\n    public void testListYamlConversion() throws IOException {\n        convertYamlToJson(tempDir.resolve(LIST_YAML).toString(), \"output.json\");\n        assertEquals(\"[\\\"item1\\\",\\\"item2\\\",\\\"item3\\\"]\", readFileContent(tempDir.resolve(\"output.json\")));\n    }\n\n    @Test\n    public void testInvalidYamlConversion() {\n        assertThrows(Exception.class, () -> convertYamlToJson(tempDir.resolve(INVALID_YAML).toString(), \"output.json\"));\n    }\n\n    private void writeYamlFile(Path filePath, String content) throws IOException {\n        try (FileWriter writer = new FileWriter(filePath.toFile())) {\n            writer.write(content);\n        }\n    }\n\n    private String readFileContent(Path filePath) throws IOException {\n        return new String(java.nio.file.Files.readAllBytes(filePath));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts a YAML file to a JSON file.\n *\n * @param yamlFilePath  Path to the input YAML file.\n * @param jsonFilePath  Path to the output JSON file.\n */\npublic static void convertYamlToJson(String yamlFilePath, String jsonFilePath) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 25, "code_type": "method", "original_language": "python", "file_path": "website-2024\\252065dd22d32491fb30866fac26c7125f433d3c\\static\\python-scripts\\poster_filter.py", "question_type": "Data processing and transformation", "summary": "read the JSON file data based on whether the pid field in the object is included in a specified pid_list. These objects are then classified into two categories based on matches and mismatches and saved in different files", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef classify_json_objects_by_pid(source_file: str, pid_list: List[int], match_file: str, mismatch_file: str) -> None:\n    \"\"\"\n    read the JSON file question based on whether the pid field in the object is included in a specified pid_list. These objects are then classified into two categories based on matches and mismatches and saved in different files\n\n    Args:\n        source_file (str): Path to the source JSON file.\n        pid_list (list): List of pids to match.\n        match_file (str): Path to save matching objects JSON.\n        mismatch_file (str): Path to save mismatching objects JSON.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\nimport json\nimport tempfile\nimport os\n\nclass TestClassifyJsonObjectsByPid(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory\n        self.temp_dir = tempfile.mkdtemp()\n\n        # Create temporary files for testing\n        self.source_file = os.path.join(self.temp_dir, 'source.json')\n        self.match_file = os.path.join(self.temp_dir, 'match.json')\n        self.mismatch_file = os.path.join(self.temp_dir, 'mismatch.json')\n\n        # Example question\n        self.data = [\n            {\"name\": \"Alice\", \"pid\": 1},\n            {\"name\": \"Bob\", \"pid\": 2},\n            {\"name\": \"Charlie\", \"pid\": 3}\n        ]\n        self.pid_list = [1, 3]\n\n        # Write example question to source file\n        with open(self.source_file, 'w') as f:\n            json.dump(self.data, f)\n\n    def test_all_match(self):\n        # Test where all items match\n        classify_json_objects_by_pid(self.source_file, [1, 2, 3], self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 3)\n        self.assertEqual(len(mismatches), 0)\n\n    def test_no_match(self):\n        # Test where no items match\n        classify_json_objects_by_pid(self.source_file, [4, 5], self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 0)\n        self.assertEqual(len(mismatches), 3)\n\n    def test_partial_match(self):\n        # Test where some items match\n        classify_json_objects_by_pid(self.source_file, self.pid_list, self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 2)\n        self.assertEqual(len(mismatches), 1)\n\n    def test_empty_pid_list(self):\n        # Test with an empty PID list\n        classify_json_objects_by_pid(self.source_file, [], self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 0)\n        self.assertEqual(len(mismatches), 3)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef classify_json_objects_by_pid(source_file: str, pid_list: List[int], match_file: str, mismatch_file: str) -> None:\n    \"\"\"\n    read the JSON file question based on whether the pid field in the object is included in a specified pid_list. These objects are then classified into two categories based on matches and mismatches and saved in different files\n\n    Args:\n        source_file (str): Path to the source JSON file.\n        pid_list (list): List of pids to match.\n        match_file (str): Path to save matching objects JSON.\n        mismatch_file (str): Path to save mismatching objects JSON.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Classifies JSON objects from a source file based on a list of PIDs.\n * \n * This function reads JSON data from a specified source file, classifies each object \n * into matches and mismatches based on the presence of their 'pid' in a provided list,\n * and then saves the classified objects into separate JSON files.\n *\n * @param source_file The path to the input JSON file containing the objects.\n * @param pid_list A vector of PIDs to match against the 'pid' field of the JSON objects.\n * @param match_file The path to the output JSON file where matched objects will be saved.\n * @param mismatch_file The path to the output JSON file where unmatched objects will be saved.\n */\n void classify_json_objects_by_pid(const string &source_file, const vector<string> &pid_list, const string &match_file, const string &mismatch_file) {}", "test_code": "TEST_CASE(\"classify_json_objects_by_pid all match\", \"[classify]\") {\n    // Sample data\n    nlohmann::json data = R\"([\n        {\"name\": \"Alice\", \"pid\": 1},\n        {\"name\": \"Bob\", \"pid\": 2},\n        {\"name\": \"Charlie\", \"pid\": 3}\n    ])\"_json;\n    \n    // Convert JSON to string for file writing\n    const std::string json_content = data.dump(4);\n\n    std::string source_file = create_temp_file(json_content);\n    std::string match_file = create_temp_file(\"\");\n    std::string mismatch_file = create_temp_file(\"\");\n\n    std::vector<std::string> pid_list = {\"1\", \"2\", \"3\"};\n    classify_json_objects_by_pid(source_file, pid_list, match_file, mismatch_file);\n\n    // Verify match file content\n    std::ifstream match_in(match_file);\n    nlohmann::json matches;\n    match_in >> matches;\n\n    // Verify mismatch file content\n    std::ifstream mismatch_in(mismatch_file);\n    nlohmann::json mismatches;\n    mismatch_in >> mismatches;\n\n    REQUIRE(matches.size() == 3);\n    REQUIRE(mismatches.size() == 0);\n\n    // Clean up\n    std::remove(source_file.c_str());\n    std::remove(match_file.c_str());\n    std::remove(mismatch_file.c_str());\n}\n\nTEST_CASE(\"classify_json_objects_by_pid no match\", \"[classify]\") {\n    // Sample data\n    nlohmann::json data = R\"([\n        {\"name\": \"Alice\", \"pid\": 1},\n        {\"name\": \"Bob\", \"pid\": 2},\n        {\"name\": \"Charlie\", \"pid\": 3}\n    ])\"_json;\n\n    // Convert JSON to string for file writing\n    const std::string json_content = data.dump(4);\n\n    std::string source_file = create_temp_file(json_content);\n    std::string match_file = create_temp_file(\"\");\n    std::string mismatch_file = create_temp_file(\"\");\n\n    std::vector<std::string> pid_list = {\"4\", \"5\"};\n    classify_json_objects_by_pid(source_file, pid_list, match_file, mismatch_file);\n\n    // Verify match file content\n    std::ifstream match_in(match_file);\n    nlohmann::json matches;\n    match_in >> matches;\n\n    // Verify mismatch file content\n    std::ifstream mismatch_in(mismatch_file);\n    nlohmann::json mismatches;\n    mismatch_in >> mismatches;\n\n    REQUIRE(matches.size() == 0);\n    REQUIRE(mismatches.size() == 3);\n\n    // Clean up\n    std::remove(source_file.c_str());\n    std::remove(match_file.c_str());\n    std::remove(mismatch_file.c_str());\n}\n\nTEST_CASE(\"classify_json_objects_by_pid partial match\", \"[classify]\") {\n    // Sample data\n    nlohmann::json data = R\"([\n        {\"name\": \"Alice\", \"pid\": 1},\n        {\"name\": \"Bob\", \"pid\": 2},\n        {\"name\": \"Charlie\", \"pid\": 3}\n    ])\"_json;\n\n    // Convert JSON to string for file writing\n    const std::string json_content = data.dump(4);\n\n    std::string source_file = create_temp_file(json_content);\n    std::string match_file = create_temp_file(\"\");\n    std::string mismatch_file = create_temp_file(\"\");\n\n    std::vector<std::string> pid_list = {\"1\", \"3\"};\n    classify_json_objects_by_pid(source_file, pid_list, match_file, mismatch_file);\n\n    // Verify match file content\n    std::ifstream match_in(match_file);\n    nlohmann::json matches;\n    match_in >> matches;\n\n    // Verify mismatch file content\n    std::ifstream mismatch_in(mismatch_file);\n    nlohmann::json mismatches;\n    mismatch_in >> mismatches;\n\n    REQUIRE(matches.size() == 2);\n    REQUIRE(mismatches.size() == 1);\n\n    // Clean up\n    std::remove(source_file.c_str());\n    std::remove(match_file.c_str());\n    std::remove(mismatch_file.c_str());\n}\n\nTEST_CASE(\"classify_json_objects_by_pid empty pid list\", \"[classify]\") {\n    // Sample data\n    nlohmann::json data = R\"([\n        {\"name\": \"Alice\", \"pid\": 1},\n        {\"name\": \"Bob\", \"pid\": 2},\n        {\"name\": \"Charlie\", \"pid\": 3}\n    ])\"_json;\n\n    // Convert JSON to string for file writing\n    const std::string json_content = data.dump(4);\n\n    std::string source_file = create_temp_file(json_content);\n    std::string match_file = create_temp_file(\"\");\n    std::string mismatch_file = create_temp_file(\"\");\n\n    std::vector<std::string> pid_list = {};\n    classify_json_objects_by_pid(source_file, pid_list, match_file, mismatch_file);\n\n    // Verify match file content\n    std::ifstream match_in(match_file);\n    nlohmann::json matches;\n    match_in >> matches;\n\n    // Verify mismatch file content\n    std::ifstream mismatch_in(mismatch_file);\n    nlohmann::json mismatches;\n    mismatch_in >> mismatches;\n\n    REQUIRE(matches.size() == 0);\n    REQUIRE(mismatches.size() == 3);\n\n    // Clean up\n    std::remove(source_file.c_str());\n    std::remove(match_file.c_str());\n    std::remove(mismatch_file.c_str());\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Classifies JSON objects from a source file based on a list of PIDs.\n * \n * This function reads JSON data from a specified source file, classifies each object \n * into matches and mismatches based on the presence of their 'pid' in a provided list,\n * and then saves the classified objects into separate JSON files.\n *\n * @param source_file The path to the input JSON file containing the objects.\n * @param pid_list A vector of PIDs to match against the 'pid' field of the JSON objects.\n * @param match_file The path to the output JSON file where matched objects will be saved.\n * @param mismatch_file The path to the output JSON file where unmatched objects will be saved.\n */\n void classify_json_objects_by_pid(const string &source_file, const vector<string> &pid_list, const string &match_file, const string &mismatch_file) {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 26, "code_type": "method", "original_language": "python", "file_path": "Deep-Learning-Project\\993ae1ef77ec317fd8ab7e6686b5e66a3db0fdad\\src\\trainers\\cnn_trainer.py", "question_type": "Framework and library", "summary": "convert input strings that contain multiple separators (for example, * ; /) to comma-separated formatted strings\n", "language_version_list": {"python": {"code_signature": "def convert_to_comma_separated(input_string: str) -> str:\n    \"\"\"\n    convert input strings that contain multiple separators (for example, * ; /) to comma-separated formatted strings\n\n    Args:\n        input_string (str): The input string containing various separators like *, ;, /, -, :\n\n    Returns:\n        str: A comma-separated string where all specified separators have been replaced with commas.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestConvertToCommaSeparated(unittest.TestCase):\n    def test_basic_separators(self):\n        self.assertEqual(convert_to_comma_separated(\"apple;banana*orange/mango\"), \"apple,banana,orange,mango\",\n                         \"Failed to convert basic separators.\")\n\n    def test_mixed_separators(self):\n        self.assertEqual(convert_to_comma_separated(\"grapes;lemon/melon*kiwi;litchi\"), \"grapes,lemon,melon,kiwi,litchi\",\n                         \"Failed to convert mixed separators in a string.\")\n    def test_mixed_separators2(self):\n        self.assertEqual(convert_to_comma_separated(\"grapes/lemon/melon*kiwi*litchi\"), \"grapes,lemon,melon,kiwi,litchi\",\n                         \"Failed to convert mixed separators in a string.\")\n\n    def test_no_separators(self):\n        self.assertEqual(convert_to_comma_separated(\"watermelon\"), \"watermelon\",\n                         \"Failed when no separators are present.\")", "prompt": "please write a python function , the function signature as below def convert_to_comma_separated(input_string: str) -> str:\n    \"\"\"\n    convert input strings that contain multiple separators (for example, * ; /) to comma-separated formatted strings\n\n    Args:\n        input_string (str): The input string containing various separators like *, ;, /, -, :\n\n    Returns:\n        str: A comma-separated string where all specified separators have been replaced with commas.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts an input string with multiple separators to a comma-separated string.\n *\n * This function handles additional separators such as hyphens (-) and colons (:).\n *\n * @param input_string The input string containing various separators like *, ;, /, -, :.\n * @return A comma-separated string where all specified separators have been replaced with commas.\n */\nstd::string convert_to_comma_separated(const std::string& input_string) {}", "test_code": "TEST_CASE(\"TestConvertToCommaSeparated\", \"[convert_to_comma_separated]\") {\n    SECTION(\"test_basic_separators\") {\n        CHECK(convert_to_comma_separated(\"apple;banana*orange/mango\") == \"apple,banana,orange,mango\");\n        INFO(\"Failed to convert basic separators.\");\n    }\n\n    SECTION(\"test_mixed_separators\") {\n        CHECK(convert_to_comma_separated(\"grapes;lemon/melon*kiwi;litchi\") == \"grapes,lemon,melon,kiwi,litchi\");\n        INFO(\"Failed to convert mixed separators in a string.\");\n    }\n\n    SECTION(\"test_mixed_separators2\") {\n        CHECK(convert_to_comma_separated(\"grapes/lemon/melon*kiwi*litchi\") == \"grapes,lemon,melon,kiwi,litchi\");\n        INFO(\"Failed to convert mixed separators in a string.\");\n    }\n\n    SECTION(\"test_no_separators\") {\n        CHECK(convert_to_comma_separated(\"watermelon\") == \"watermelon\");\n        INFO(\"Failed when no separators are present.\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts an input string with multiple separators to a comma-separated string.\n *\n * This function handles additional separators such as hyphens (-) and colons (:).\n *\n * @param input_string The input string containing various separators like *, ;, /, -, :.\n * @return A comma-separated string where all specified separators have been replaced with commas.\n */\nstd::string convert_to_comma_separated(const std::string& input_string) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts input strings that contain multiple separators (for example, *, ;, /, -, :) \n * to comma-separated formatted strings.\n *\n * @param inputString The input string containing various separators like *, ;, /, -, :\n * @return A comma-separated string where all specified separators have been replaced with commas.\n */\npublic static String convertToCommaSeparated(String inputString) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    /**\n     * Tests conversion of basic separators.\n     */\n    @Test\n    public void testBasicSeparators() {\n        assertEquals(\"Failed to convert basic separators.\",\n                     \"apple,banana,orange,mango\",\n                     convertToCommaSeparated(\"apple;banana*orange/mango\"));\n    }\n\n    /**\n     * Tests conversion of mixed separators in a string.\n     */\n    @Test\n    public void testMixedSeparators() {\n        assertEquals(\"Failed to convert mixed separators in a string.\",\n                     \"grapes,lemon,melon,kiwi,litchi\",\n                     convertToCommaSeparated(\"grapes;lemon/melon*kiwi;litchi\"));\n    }\n\n    /**\n     * Tests conversion of mixed separators in another string.\n     */\n    @Test\n    public void testMixedSeparators2() {\n        assertEquals(\"Failed to convert mixed separators in a string.\",\n                     \"grapes,lemon,melon,kiwi,litchi\",\n                     convertToCommaSeparated(\"grapes/lemon/melon*kiwi*litchi\"));\n    }\n\n    /**\n     * Tests the case where no separators are present.\n     */\n    @Test\n    public void testNoSeparators() {\n        assertEquals(\"Failed when no separators are present.\",\n                     \"watermelon\",\n                     convertToCommaSeparated(\"watermelon\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts input strings that contain multiple separators (for example, *, ;, /, -, :) \n * to comma-separated formatted strings.\n *\n * @param inputString The input string containing various separators like *, ;, /, -, :\n * @return A comma-separated string where all specified separators have been replaced with commas.\n */\npublic static String convertToCommaSeparated(String inputString) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 27, "code_type": "method", "original_language": "python", "file_path": "Spotify_Wayback\\956bf4b21beec2ff51750963d4d9c7f81f1b12b0\\combine_json.py", "question_type": "Data processing and transformation", "summary": "concatenate the root-level array JSON files in the specified directory", "language_version_list": {"python": {"code_signature": "import os\nimport json\nfrom typing import List\n\n\ndef concatenate_json_arrays(directory: str) -> List:\n    \"\"\"\n    concatenate the root-level array JSON files in the specified directory\n    Args:\n        directory (str): directory dir path\n\n    Returns: merged question\n\n    \"\"\"\n", "test_code": "import json\nimport os\nimport unittest\n\n\nclass TestConcatenateJsonArrays(unittest.TestCase):\n\n    def setUp(self):\n        # Set up a test.js directory and test.js files\n        self.test_dir = 'test_json'\n        os.makedirs(self.test_dir, exist_ok=True)\n        # Create test.js JSON files\n        self.create_test_file('array1.json', [1, 2, 3])\n        self.create_test_file('array2.json', ['a', 'b', 'c'])\n        self.create_test_file('not_array.json', {'key': 'value'})\n        self.create_test_file('empty.json', [])\n        self.create_test_file('non_json.txt', \"This is not a JSON file.\")\n\n    def tearDown(self):\n        # Clean up: Remove created files and directory\n        for filename in os.listdir(self.test_dir):\n            os.remove(os.path.join(self.test_dir, filename))\n        os.rmdir(self.test_dir)\n\n    def create_test_file(self, filename, content):\n        # Helper method to create JSON files\n        with open(os.path.join(self.test_dir, filename), 'w') as f:\n            json.dump(content, f)\n\n    def test_concatenate_valid_json_arrays(self):\n        # Test with valid JSON arrays\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertCountEqual(result, [1, 2, 3, 'a', 'b', 'c'])\n\n    def test_ignore_non_array_json(self):\n        # Test that non-array JSON files are ignored\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertNotIn('key', result)\n\n    def test_ignore_non_json_files(self):\n        # Test that non-JSON files are ignored\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertNotIn(\"This is not a JSON file.\", result)\n\n    def test_handle_empty_arrays(self):\n        # Test concatenation includes empty arrays\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertNotIn([], result)\n\n    def test_empty_directory(self):\n        # Test with no JSON files in the directory\n        empty_dir = 'empty_test_json'\n        os.makedirs(empty_dir, exist_ok=True)\n        result = concatenate_json_arrays(empty_dir)\n        self.assertEqual(result, [])\n        os.rmdir(empty_dir)\n", "prompt": "please write a python function , the function signature as below import os\nimport json\nfrom typing import List\n\n\ndef concatenate_json_arrays(directory: str) -> List:\n    \"\"\"\n    concatenate the root-level array JSON files in the specified directory\n    Args:\n        directory (str): directory dir path\n\n    Returns: merged question\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "/**\n * Concatenates JSON arrays from all JSON files in a specified directory into a single list.\n *\n * @param directory The path to the directory containing JSON files.\n * @return A list of JSONObject instances, representing the combined data from all JSON arrays found.\n */\npublic List<JSONObject> concatenateJsonArrays(String directory) {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\n\nimport static org.junit.Assert.*;\n\npublic class Tester {\n    private String testDir;\n\n    @Before\n    public void setUp() throws IOException {\n        // Set up a test directory and JSON files\n        testDir = \"test_json\";\n        Files.createDirectories(Paths.get(testDir));\n        createTestFile(\"array1.json\", Arrays.asList(1, 2, 3));\n        createTestFile(\"array2.json\", Arrays.asList(\"a\", \"b\", \"c\"));\n        createTestFile(\"not_array.json\", \"{\\\"key\\\": \\\"value\\\"}\");\n        createTestFile(\"empty.json\", Arrays.asList());\n        createTestFile(\"non_json.txt\", \"This is not a JSON file.\");\n    }\n\n    @After\n    public void tearDown() throws IOException {\n        // Clean up: Remove created files and directory\n        File dir = new File(testDir);\n        for (File file : dir.listFiles()) {\n            file.delete();\n        }\n        dir.delete();\n    }\n\n    private void createTestFile(String filename, Object content) throws IOException {\n        // Helper method to create JSON files\n        try (FileWriter writer = new FileWriter(new File(testDir, filename))) {\n            if (content instanceof String) {\n                writer.write((String) content);\n            } else {\n                writer.write(new com.google.gson.Gson().toJson(content));\n            }\n        }\n    }\n\n    @Test\n    public void testConcatenateValidJsonArrays() {\n        // Test with valid JSON arrays\n        Object result = ConcatenateJsonArrays.concatenate(testDir);\n        assertArrayEquals(new Object[]{1, 2, 3, \"a\", \"b\", \"c\"}, (Object[]) result);\n    }\n\n    @Test\n    public void testIgnoreNonArrayJson() {\n        // Test that non-array JSON files are ignored\n        Object result = ConcatenateJsonArrays.concatenate(testDir);\n        assertFalse(Arrays.asList((Object[]) result).contains(\"key\"));\n    }\n\n    @Test\n    public void testIgnoreNonJsonFiles() {\n        // Test that non-JSON files are ignored\n        Object result = ConcatenateJsonArrays.concatenate(testDir);\n        assertFalse(Arrays.asList((Object[]) result).contains(\"This is not a JSON file.\"));\n    }\n\n    @Test\n    public void testHandleEmptyArrays() {\n        // Test concatenation includes empty arrays\n        Object result = ConcatenateJsonArrays.concatenate(testDir);\n        assertFalse(Arrays.asList((Object[]) result).contains(Arrays.asList()));\n    }\n\n    @Test\n    public void testEmptyDirectory() throws IOException {\n        // Test with no JSON files in the directory\n        String emptyDir = \"empty_test_json\";\n        Files.createDirectories(Paths.get(emptyDir));\n        Object result = ConcatenateJsonArrays.concatenate(emptyDir);\n        assertEquals(0, ((Object[]) result).length);\n        new File(emptyDir).delete();\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Concatenates JSON arrays from all JSON files in a specified directory into a single list.\n *\n * @param directory The path to the directory containing JSON files.\n * @return A list of JSONObject instances, representing the combined data from all JSON arrays found.\n */\npublic List<JSONObject> concatenateJsonArrays(String directory) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 28, "code_type": "method", "original_language": "python", "file_path": "WD65C02_FPGA\\174bb2e32be1f70311bbba6a239ed2a2763c7fa4\\ASM\\GameOfLife\\DumpGameBoardMem.py", "question_type": "File operations and I/O operation", "summary": "Read a section of memory, printing the status of each bit 0 or 1", "language_version_list": {"python": {"code_signature": "def print_memory_bits(memory_section: bytes):\n    \"\"\"\n    Prints the status of each bit (0 or 1) in the given section of memory.\n    For example:\n        input: 0b10101010\n        output: 10101010\n    If have multiple bytes use \\n split\n    For example:\n        input: [0b11001100, 0b11110000]\n        output: 11001100\\n11110000\n\n    Args:\n        memory_section (bytes): A bytes object representing the section of memory to be read.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\nfrom io import StringIO\nimport sys\n\n\nclass TestPrintMemoryBits(unittest.TestCase):\n\n    def setUp(self):\n        # Capture the output during each test\n        self.held_stdout = StringIO()\n        sys.stdout = self.held_stdout\n\n    def tearDown(self):\n        # Restore the normal stdout\n        sys.stdout = sys.__stdout__\n\n    def test_single_byte(self):\n        memory_section = bytes([0b10101010])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"10101010\"\n        self.assertEqual(output, expected_output)\n\n    def test_multiple_bytes(self):\n        memory_section = bytes([0b11001100, 0b11110000])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"11001100\\n11110000\"\n        self.assertEqual(output, expected_output)\n\n    def test_all_zeros(self):\n        memory_section = bytes([0b00000000])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"00000000\"\n        self.assertEqual(output, expected_output)\n\n    def test_all_ones(self):\n        memory_section = bytes([0b11111111])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"11111111\"\n        self.assertEqual(output, expected_output)", "prompt": "please write a python function , the function signature as below def print_memory_bits(memory_section: bytes):\n    \"\"\"\n    Prints the status of each bit (0 or 1) in the given section of memory.\n    For example:\n        input: 0b10101010\n        output: 10101010\n    If have multiple bytes use \\n split\n    For example:\n        input: [0b11001100, 0b11110000]\n        output: 11001100\\n11110000\n\n    Args:\n        memory_section (bytes): A bytes object representing the section of memory to be read.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Prints the status of each bit (0 or 1) in the given section of memory.\n * For example:\n *     input: 0b10101010\n *     output: 10101010\n * If there are multiple bytes, they are split using \\n.\n * For example:\n *     input: [0b11001100, 0b11110000]\n *     output: 11001100\n *            11110000\n *\n * @param memory_section A vector of uint8_t representing the section of memory to be read.\n */\nvoid print_memory_bits(const std::vector<uint8_t>& memory_section) {}", "test_code": "TEST_CASE(\"TestPrintMemoryBits\", \"[print_memory_bits]\") {\n    struct RedirectStdout {\n        std::streambuf* orig;\n        std::stringstream buffer;\n\n        RedirectStdout() : orig(std::cout.rdbuf(buffer.rdbuf())) {}\n        ~RedirectStdout() { std::cout.rdbuf(orig); }\n\n        std::string str() const { return buffer.str(); }\n    };\n\n    SECTION(\"test_single_byte\") {\n        std::vector<uint8_t> memory_section = {0b10101010};\n        RedirectStdout redirector;\n        print_memory_bits(memory_section);\n        std::string output = redirector.str().substr(0, 8); // Remove newline\n        REQUIRE(output == \"10101010\");\n    }\n\n    SECTION(\"test_multiple_bytes\") {\n        std::vector<uint8_t> memory_section = {0b11001100, 0b11110000};\n        RedirectStdout redirector;\n        print_memory_bits(memory_section);\n        std::string output = redirector.str();\n        REQUIRE(output == \"11001100\\n11110000\\n\");\n    }\n\n    SECTION(\"test_all_zeros\") {\n        std::vector<uint8_t> memory_section = {0b00000000};\n        RedirectStdout redirector;\n        print_memory_bits(memory_section);\n        std::string output = redirector.str().substr(0, 8); // Remove newline\n        REQUIRE(output == \"00000000\");\n    }\n\n    SECTION(\"test_all_ones\") {\n        std::vector<uint8_t> memory_section = {0b11111111};\n        RedirectStdout redirector;\n        print_memory_bits(memory_section);\n        std::string output = redirector.str().substr(0, 8); // Remove newline\n        REQUIRE(output == \"11111111\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Prints the status of each bit (0 or 1) in the given section of memory.\n * For example:\n *     input: 0b10101010\n *     output: 10101010\n * If there are multiple bytes, they are split using \\n.\n * For example:\n *     input: [0b11001100, 0b11110000]\n *     output: 11001100\n *            11110000\n *\n * @param memory_section A vector of uint8_t representing the section of memory to be read.\n */\nvoid print_memory_bits(const std::vector<uint8_t>& memory_section) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Prints the status of each bit (0 or 1) in the given section of memory.\n * For example:\n *     input: 0b10101010\n *     output: 10101010\n * If have multiple bytes use \\n split\n * For example:\n *     input: [0b11001100, 0b11110000]\n *     output: 11001100\\n11110000\n *\n * @param memorySection A byte array representing the section of memory to be read.\n */\npublic static void printMemoryBits(byte[] memorySection) {}\n", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();\n    private final PrintStream originalOut = System.out;\n\n    @Before\n    public void setUp() {\n        // Redirect System.out to capture the output\n        System.setOut(new PrintStream(outContent));\n    }\n\n    @After\n    public void tearDown() {\n        // Restore the normal System.out\n        System.setOut(originalOut);\n    }\n\n    @Test\n    public void testSingleByte() {\n        byte[] memorySection = new byte[]{(byte) 0b10101010};\n        printMemoryBits(memorySection);\n        String output = outContent.toString().trim();\n        String expectedOutput = \"10101010\";\n        assertEquals(expectedOutput, output);\n    }\n\n    @Test\n    public void testMultipleBytes() {\n        byte[] memorySection = new byte[]{(byte) 0b11001100, (byte) 0b11110000};\n        printMemoryBits(memorySection);\n        String output = outContent.toString().trim();\n        String expectedOutput = \"11001100\\n11110000\";\n        assertEquals(expectedOutput, output);\n    }\n\n    @Test\n    public void testAllZeros() {\n        byte[] memorySection = new byte[]{(byte) 0b00000000};\n        printMemoryBits(memorySection);\n        String output = outContent.toString().trim();\n        String expectedOutput = \"00000000\";\n        assertEquals(expectedOutput, output);\n    }\n\n    @Test\n    public void testAllOnes() {\n        byte[] memorySection = new byte[]{(byte) 0b11111111};\n        printMemoryBits(memorySection);\n        String output = outContent.toString().trim();\n        String expectedOutput = \"11111111\";\n        assertEquals(expectedOutput, output);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Prints the status of each bit (0 or 1) in the given section of memory.\n * For example:\n *     input: 0b10101010\n *     output: 10101010\n * If have multiple bytes use \\n split\n * For example:\n *     input: [0b11001100, 0b11110000]\n *     output: 11001100\\n11110000\n *\n * @param memorySection A byte array representing the section of memory to be read.\n */\npublic static void printMemoryBits(byte[] memorySection) {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 31, "code_type": "method", "original_language": "python", "file_path": "PicHooven\\2fac49a8fd58d3605f7b099939e54731b1c33ba7\\helper.py", "question_type": "Data processing and transformation", "summary": "Analyze a list of pixels, each represented by rgb, and calculate the proportion of red in the list", "language_version_list": {"python": {"code_signature": "from typing import List, Tuple\n\n\ndef calculate_red_proportion(pixels: List[Tuple[int, int, int]]) -> float:\n    \"\"\"\n    Analyze a list of pixels, each represented by rgb, and calculate the proportion of red in the list.\n\n    Args:\n        pixels (List[Tuple[int, int, int]]): A list of pixels, where each pixel is represented as a tuple of (R, G, B).\n\n    Returns:\n        float: The proportion of red in the list of pixels, as a value between 0 and 1.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCalculateRedProportion(unittest.TestCase):\n\n    def test_all_red_pixels(self):\n        # All pixels are fully red\n        pixels = [(255, 0, 0), (255, 0, 0), (255, 0, 0)]\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 1.0)\n\n    def test_no_red_pixels(self):\n        # No red component in any pixel\n        pixels = [(0, 255, 0), (0, 0, 255), (0, 255, 255)]\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 0.0)\n\n    def test_empty_pixel_list(self):\n        # Empty list of pixels\n        pixels = []\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 0.0)\n\n    def test_all_black_pixels(self):\n        # All pixels are black\n        pixels = [(0, 0, 0), (0, 0, 0), (0, 0, 0)]\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 0.0)\n", "prompt": "please write a python function , the function signature as below from typing import List, Tuple\n\n\ndef calculate_red_proportion(pixels: List[Tuple[int, int, int]]) -> float:\n    \"\"\"\n    Analyze a list of pixels, each represented by rgb, and calculate the proportion of red in the list.\n\n    Args:\n        pixels (List[Tuple[int, int, int]]): A list of pixels, where each pixel is represented as a tuple of (R, G, B).\n\n    Returns:\n        float: The proportion of red in the list of pixels, as a value between 0 and 1.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculates the proportion of red in a list of pixels.\n *\n * Each pixel is represented as a tuple of (R, G, B).\n *\n * @param pixels A list of pixels, where each pixel is represented as a tuple of (R, G, B).\n *               This is a constant reference to a vector of tuples.\n * @return The proportion of red in the list of pixels, as a value between 0 and 1.\n */\nfloat calculate_red_proportion(const std::vector<std::tuple<int, int, int>>& pixels) {}", "test_code": "TEST_CASE(\"Test calculate_red_proportion\", \"[calculate_red_proportion]\") {\n    SECTION(\"All red pixels\") {\n        // All pixels are fully red\n        std::vector<std::tuple<int, int, int>> pixels = {{255, 0, 0}, {255, 0, 0}, {255, 0, 0}};\n        float result = calculate_red_proportion(pixels);\n        REQUIRE_THAT(result, Catch::Matchers::WithinAbs(1.0f, 0.001));\n    }\n\n    SECTION(\"No red pixels\") {\n        // No red component in any pixel\n        std::vector<std::tuple<int, int, int>> pixels = {{0, 255, 0}, {0, 0, 255}, {0, 255, 255}};\n        float result = calculate_red_proportion(pixels);\n        REQUIRE_THAT(result, Catch::Matchers::WithinAbs(0.0f, 0.001));\n    }\n\n    SECTION(\"Empty pixel list\") {\n        // Empty list of pixels\n        std::vector<std::tuple<int, int, int>> pixels = {};\n        float result = calculate_red_proportion(pixels);\n        REQUIRE_THAT(result, Catch::Matchers::WithinAbs(0.0f, 0.001));\n    }\n\n    SECTION(\"All black pixels\") {\n        // All pixels are black\n        std::vector<std::tuple<int, int, int>> pixels = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};\n        float result = calculate_red_proportion(pixels);\n        REQUIRE_THAT(result, Catch::Matchers::WithinAbs(0.0f, 0.001));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculates the proportion of red in a list of pixels.\n *\n * Each pixel is represented as a tuple of (R, G, B).\n *\n * @param pixels A list of pixels, where each pixel is represented as a tuple of (R, G, B).\n *               This is a constant reference to a vector of tuples.\n * @return The proportion of red in the list of pixels, as a value between 0 and 1.\n */\nfloat calculate_red_proportion(const std::vector<std::tuple<int, int, int>>& pixels) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Analyze a list of pixels, each represented by RGB, and calculate the proportion of red in the list.\n *\n * @param pixels A list of pixels, where each pixel is represented as an array of [R, G, B].\n * @return The proportion of red in the list of pixels, as a value between 0 and 1.\n */\npublic static double calculateRedProportion(List<int[]> pixels) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.real.temp.Answer;\n/**\n * Test class for the calculateRedProportion method.\n */\npublic class Tester {\n\n    /**\n     * Test case for all fully red pixels.\n     */\n    @Test\n    public void testAllRedPixels() {\n        List<int[]> pixels = Arrays.asList(\n                new int[]{255, 0, 0},\n                new int[]{255, 0, 0},\n                new int[]{255, 0, 0}\n        );\n        double result = Answer.calculateRedProportion(pixels);\n        assertEquals(1.0, result, 0.001);\n    }\n\n    /**\n     * Test case for no red component in any pixel.\n     */\n    @Test\n    public void testNoRedPixels() {\n        List<int[]> pixels = Arrays.asList(\n                new int[]{0, 255, 0},\n                new int[]{0, 0, 255},\n                new int[]{0, 255, 255}\n        );\n        double result = Answer.calculateRedProportion(pixels);\n        assertEquals(0.0, result, 0.001);\n    }\n\n    /**\n     * Test case for an empty list of pixels.\n     */\n    @Test\n    public void testEmptyPixelList() {\n        List<int[]> pixels = new ArrayList<>();\n        double result = Answer.calculateRedProportion(pixels);\n        assertEquals(0.0, result, 0.001);\n    }\n\n    /**\n     * Test case for all black pixels.\n     */\n    @Test\n    public void testAllBlackPixels() {\n        List<int[]> pixels = Arrays.asList(\n                new int[]{0, 0, 0},\n                new int[]{0, 0, 0},\n                new int[]{0, 0, 0}\n        );\n        double result = Answer.calculateRedProportion(pixels);\n        assertEquals(0.0, result, 0.001);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Analyze a list of pixels, each represented by RGB, and calculate the proportion of red in the list.\n *\n * @param pixels A list of pixels, where each pixel is represented as an array of [R, G, B].\n * @return The proportion of red in the list of pixels, as a value between 0 and 1.\n */\npublic static double calculateRedProportion(List<int[]> pixels) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 33, "code_type": "method", "original_language": "python", "file_path": "experiments\\d8c3e48eb51b21b8e27e8183cbafbde0954a8c13\\mlx\\lora\\lib\\reference_extraction.py", "question_type": "Data processing and transformation", "summary": "convert the XML file into a pandas DataFrame, where each <sequence>tag is treated as a row record in the XML, and the tag and text content of each sub-element are treated as columns and data of the DataFrame\n", "language_version_list": {"python": {"code_signature": "import pandas as pd\n\n\ndef parse_xml_to_dataframe(xml_file: str) -> pd.DataFrame:\n    \"\"\"\n    Convert the XML file into a pandas DataFrame, where each <sequence> tag is treated as a row record in the XML,\n    and the tag and text content of each sub-element are treated as columns of the DataFrame.\n\n    Args:\n        xml_file (str): Path to the XML file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the data extracted from the XML file.\n    \"\"\"\n", "test_code": "import unittest\nimport pandas as pd\nfrom io import StringIO\nimport xml.etree.ElementTree as ET\n\nclass TestXmlToDataFrame(unittest.TestCase):\n    def test_single_sequence(self):\n        xml_data = \"\"\"<root>\n                        <sequence>\n                            <name>John</name>\n                            <age>30</age>\n                        </sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = parse_xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{'name': 'John', 'age': '30'}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_multiple_sequences(self):\n        xml_data = \"\"\"<root>\n                        <sequence>\n                            <name>Alice</name>\n                            <age>25</age>\n                        </sequence>\n                        <sequence>\n                            <name>Bob</name>\n                            <age>22</age>\n                        </sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = parse_xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{'name': 'Alice', 'age': '25'}, {'name': 'Bob', 'age': '22'}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_empty_sequence(self):\n        xml_data = \"\"\"<root>\n                        <sequence></sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = parse_xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_mixed_content(self):\n        xml_data = \"\"\"<root>\n                        <sequence>\n                            <name>Chris</name>\n                        </sequence>\n                        <sequence>\n                            <age>28</age>\n                        </sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = parse_xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{'name': 'Chris', 'age': None}, {'name': None, 'age': '28'}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_no_sequences(self):\n        xml_data = \"\"\"<root></root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = parse_xml_to_dataframe(xml_input)\n        expected = pd.DataFrame()\n        pd.testing.assert_frame_equal(df, expected)\n", "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef parse_xml_to_dataframe(xml_file: str) -> pd.DataFrame:\n    \"\"\"\n    Convert the XML file into a pandas DataFrame, where each <sequence> tag is treated as a row record in the XML,\n    and the tag and text content of each sub-element are treated as columns of the DataFrame.\n\n    Args:\n        xml_file (str): Path to the XML file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the data extracted from the XML file.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 35, "code_type": "method", "original_language": "python", "file_path": "scratch-code\\33615a13bfd8b8dc301045581e1ac382fdd3b43f\\point_in_shape.py", "question_type": "Data processing and transformation", "summary": "calculates whether a point lies within a defined polygon with a series of points\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef is_point_in_polygon(point: tuple, polygon: List[tuple]) -> bool:\n    \"\"\"\n    Determine if the point (x, y) is inside the given polygon.\n    The polygon is defined as a list of tuples (x, y) representing the vertices.\n\n    Args:\n    point: A tuple (x, y) representing the point to check.\n    polygon: A list of tuples (x, y) representing the vertices of the polygon.\n\n    Returns:\n    bool: True if the point is inside the polygon, False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestPointInPolygon(unittest.TestCase):\n    def setUp(self):\n        # Define some polygons to use in tests\n        self.square = [(0, 0), (0, 10), (10, 10), (10, 0)]\n        self.triangle = [(0, 0), (5, 10), (10, 0)]\n        self.concave = [(0, 0), (5, 5), (10, 0), (5, 10), (0, 10)]\n\n    def test_point_inside_square(self):\n        # Point inside the square\n        self.assertTrue(is_point_in_polygon((5, 5), self.square))\n\n    def test_point_outside_square(self):\n        # Point outside the square\n        self.assertFalse(is_point_in_polygon((15, 5), self.square))\n\n    def test_point_on_edge_of_triangle(self):\n        # Point on the edge of the triangle\n        self.assertFalse(is_point_in_polygon((5, 0), self.triangle))\n\n    def test_point_inside_concave_polygon(self):\n        # Point inside concave polygon\n        self.assertTrue(is_point_in_polygon((5, 9), self.concave))\n\n    def test_point_outside_concave_polygon(self):\n        # Point outside concave polygon\n        self.assertFalse(is_point_in_polygon((5, 1), self.concave))", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef is_point_in_polygon(point: tuple, polygon: List[tuple]) -> bool:\n    \"\"\"\n    Determine if the point (x, y) is inside the given polygon.\n    The polygon is defined as a list of tuples (x, y) representing the vertices.\n\n    Args:\n    point: A tuple (x, y) representing the point to check.\n    polygon: A list of tuples (x, y) representing the vertices of the polygon.\n\n    Returns:\n    bool: True if the point is inside the polygon, False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Determines if a point (x, y) is inside a given polygon.\n *\n * The polygon is defined as a vector of pairs (x, y) representing the vertices.\n *\n * @param point A pair (x, y) representing the point to check.\n * @param polygon A vector of pairs (x, y) representing the vertices of the polygon.\n * @return True if the point is inside the polygon, false otherwise.\n */\nbool is_point_in_polygon(const std::pair<double, double>& point, const std::vector<std::pair<double, double>>& polygon) {}\n", "test_code": "TEST_CASE(\"Test point in polygon\", \"[point_in_polygon]\") {\n    // Define some polygons to use in tests\n    std::vector<std::pair<double, double>> square = {{0, 0}, {0, 10}, {10, 10}, {10, 0}};\n    std::vector<std::pair<double, double>> triangle = {{0, 0}, {5, 10}, {10, 0}};\n    std::vector<std::pair<double, double>> concave = {{0, 0}, {5, 5}, {10, 0}, {5, 10}, {0, 10}};\n\n    SECTION(\"Point inside the square\") {\n        REQUIRE(is_point_in_polygon({5, 5}, square));\n    }\n\n    SECTION(\"Point outside the square\") {\n        REQUIRE_FALSE(is_point_in_polygon({15, 5}, square));\n    }\n\n    SECTION(\"Point on the edge of the triangle\") {\n        REQUIRE_FALSE(is_point_in_polygon({5, 0}, triangle));\n    }\n\n    SECTION(\"Point inside concave polygon\") {\n        REQUIRE(is_point_in_polygon({5, 9}, concave));\n    }\n\n    SECTION(\"Point outside concave polygon\") {\n        REQUIRE_FALSE(is_point_in_polygon({5, 1}, concave));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Determines if a point (x, y) is inside a given polygon.\n *\n * The polygon is defined as a vector of pairs (x, y) representing the vertices.\n *\n * @param point A pair (x, y) representing the point to check.\n * @param polygon A vector of pairs (x, y) representing the vertices of the polygon.\n * @return True if the point is inside the polygon, false otherwise.\n */\nbool is_point_in_polygon(const std::pair<double, double>& point, const std::vector<std::pair<double, double>>& polygon) {}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Determines if the point (x, y) is inside the given polygon.\n * The polygon is defined as a list of tuples (x, y) representing the vertices.\n *\n * @param point  A tuple (x, y) representing the point to check.\n * @param polygon A list of tuples (x, y) representing the vertices of the polygon.\n * @return True if the point is inside the polygon, False otherwise.\n */\npublic static boolean isPointInPolygon(Point point, List<Point> polygon) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.real.temp.Answer;\n\npublic class Tester {\n\n    private List<Point> square;\n    private List<Point> triangle;\n    private List<Point> concave;\n\n    @Before // Updated annotation for JUnit 5\n    public void setUp() {\n        // Define some polygons to use in tests\n        square = new ArrayList<>();\n        square.add(new Point(0, 0));\n        square.add(new Point(0, 10));\n        square.add(new Point(10, 10));\n        square.add(new Point(10, 0));\n\n        triangle = new ArrayList<>();\n        triangle.add(new Point(0, 0));\n        triangle.add(new Point(5, 10));\n        triangle.add(new Point(10, 0));\n\n        concave = new ArrayList<>();\n        concave.add(new Point(0, 0));\n        concave.add(new Point(5, 5));\n        concave.add(new Point(10, 0));\n        concave.add(new Point(5, 10));\n        concave.add(new Point(0, 10));\n    }\n\n    @Test\n    public void testPointInsideSquare() {\n        // Point inside the square\n        assertTrue(Answer.isPointInPolygon(new Point(5, 5), square));\n    }\n\n    @Test\n    public void testPointOutsideSquare() {\n        // Point outside the square\n        assertFalse(Answer.isPointInPolygon(new Point(15, 5), square));\n    }\n\n    @Test\n    public void testPointOnEdgeOfTriangle() {\n        // Point on the edge of the triangle\n        assertFalse(Answer.isPointInPolygon(new Point(5, 0), triangle));\n    }\n\n    @Test\n    public void testPointInsideConcavePolygon() {\n        // Point inside concave polygon\n        assertTrue(Answer.isPointInPolygon(new Point(5, 9), concave));\n    }\n\n    @Test\n    public void testPointOutsideConcavePolygon() {\n        // Point outside concave polygon\n        assertFalse(Answer.isPointInPolygon(new Point(5, 1), concave));\n    }\n\n\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Determines if the point (x, y) is inside the given polygon.\n * The polygon is defined as a list of tuples (x, y) representing the vertices.\n *\n * @param point  A tuple (x, y) representing the point to check.\n * @param polygon A list of tuples (x, y) representing the vertices of the polygon.\n * @return True if the point is inside the polygon, False otherwise.\n */\npublic static boolean isPointInPolygon(Point point, List<Point> polygon) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 36, "code_type": "method", "original_language": "python", "file_path": "algorithms-assignments\\ddc1c94196634e7686062e3f6b86bf0abd2737c9\\floyd_dijkstra.py", "question_type": "Algorithm and data structure", "summary": "Implementing Floyd's algorithm", "language_version_list": {"python": {"code_signature": "from typing import List, Union\n\ndef find_shortest_paths_by_floyd_warshall(adjacency_matrix: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]:\n    \"\"\"\n    Implements Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n    in a graph represented by an adjacency matrix.\n\n    Args:\n        adjacency_matrix (List[List[Union[int, float]]]): The adjacency matrix representing the graph,\n        where adjacency_matrix[i][j] is the weight of the edge from vertex i to vertex j. If there is\n        no edge, the weight should be represented as float('inf').\n\n    Returns:\n        List[List[Union[int, float]]]: The matrix representing the shortest paths between all pairs of vertices.\n        shortest_paths[i][j] will hold the shortest distance from vertex i to vertex j.\n    \"\"\"", "test_code": "import unittest\n\nclass TestFloydWarshallShortestPaths(unittest.TestCase):\n    def test_basic_functionality(self):\n        # Basic test.js case with a simple graph\n        matrix = [\n            [0, 3, float('inf'), 7],\n            [8, 0, 2, float('inf')],\n            [5, float('inf'), 0, 1],\n            [2, float('inf'), float('inf'), 0]\n        ]\n        expected = [\n            [0, 3, 5, 6],\n            [5, 0, 2, 3],\n            [3, 6, 0, 1],\n            [2, 5, 7, 0]\n        ]\n        result = find_shortest_paths_by_floyd_warshall(matrix)\n        self.assertEqual(result, expected, \"Basic functionality test.js failed\")\n\n    def test_single_vertex_graph(self):\n        # Test case with a single vertex graph (1x1 matrix)\n        matrix = [\n            [0]\n        ]\n        expected = [\n            [0]\n        ]\n        result = find_shortest_paths_by_floyd_warshall(matrix)\n        self.assertEqual(result, expected, \"Single vertex graph test.js failed\")\n\n    def test_two_vertices_graph(self):\n        # Test case with two vertices\n        matrix = [\n            [0, 1],\n            [1, 0]\n        ]\n        expected = [\n            [0, 1],\n            [1, 0]\n        ]\n        result = find_shortest_paths_by_floyd_warshall(matrix)\n        self.assertEqual(result, expected, \"Two vertices graph test.js failed\")\n\n    def test_large_infinite_weights(self):\n        # Test case with infinite weights\n        matrix = [\n            [0, float('inf')],\n            [float('inf'), 0]\n        ]\n        expected = [\n            [0, float('inf')],\n            [float('inf'), 0]\n        ]\n        result = find_shortest_paths_by_floyd_warshall(matrix)\n        self.assertEqual(result, expected, \"Large infinite weights test.js failed\")\n\n    def test_negative_cycle(self):\n        # Test case with a negative cycle\n        matrix = [\n            [0, 1, float('inf')],\n            [float('inf'), 0, -1],\n            [-1, float('inf'), 0]\n        ]\n        expected = [\n            [-1, 0, -1],\n            [-2, -1, -2],\n            [-2, -1, -2]\n        ]\n        result = find_shortest_paths_by_floyd_warshall(matrix)\n        self.assertEqual(result, expected, \"Negative cycle test.js failed\")\n\n\n", "prompt": "please write a python function , the function signature as below from typing import List, Union\n\ndef find_shortest_paths_by_floyd_warshall(adjacency_matrix: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]:\n    \"\"\"\n    Implements Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n    in a graph represented by an adjacency matrix.\n\n    Args:\n        adjacency_matrix (List[List[Union[int, float]]]): The adjacency matrix representing the graph,\n        where adjacency_matrix[i][j] is the weight of the edge from vertex i to vertex j. If there is\n        no edge, the weight should be represented as float('inf').\n\n    Returns:\n        List[List[Union[int, float]]]: The matrix representing the shortest paths between all pairs of vertices.\n        shortest_paths[i][j] will hold the shortest distance from vertex i to vertex j.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Implements the Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n * in a graph represented by an adjacency matrix.\n *\n * @param adjacency_matrix A 2D vector representing the graph, where adjacency_matrix[i][j] is the weight\n *                         of the edge from vertex i to vertex j. If there is no edge, the weight should\n *                         be represented as INT_MAX.\n * @return A 2D vector representing the shortest paths between all pairs of vertices. shortest_paths[i][j]\n *         will hold the shortest distance from vertex i to vertex j.\n */\nstd::vector<std::vector<int>> floyd_warshall_shortest_paths(const std::vector<std::vector<int>>& adjacency_matrix) {}", "test_code": "TEST_CASE(\"Test Floyd-Warshall Shortest Paths\", \"[floyd-warshall]\") {\n    SECTION(\"Basic functionality\") {\n        // Basic test case with a simple graph\n        std::vector<std::vector<int>> matrix = {\n            {0, 3, INT_MAX, 7},\n            {8, 0, 2, INT_MAX},\n            {5, INT_MAX, 0, 1},\n            {2, INT_MAX, INT_MAX, 0}\n        };\n        std::vector<std::vector<int>> expected = {\n            {0, 3, 5, 6},\n            {5, 0, 2, 3},\n            {3, 6, 0, 1},\n            {2, 5, 7, 0}\n        };\n        auto result = floyd_warshall_shortest_paths(matrix);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Single vertex graph\") {\n        // Test case with a single vertex graph (1x1 matrix)\n        std::vector<std::vector<int>> matrix = {\n            {0}\n        };\n        std::vector<std::vector<int>> expected = {\n            {0}\n        };\n        auto result = floyd_warshall_shortest_paths(matrix);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Two vertices graph\") {\n        // Test case with two vertices\n        std::vector<std::vector<int>> matrix = {\n            {0, 1},\n            {1, 0}\n        };\n        std::vector<std::vector<int>> expected = {\n            {0, 1},\n            {1, 0}\n        };\n        auto result = floyd_warshall_shortest_paths(matrix);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Large infinite weights\") {\n        // Test case with infinite weights\n        std::vector<std::vector<int>> matrix = {\n            {0, INT_MAX},\n            {INT_MAX, 0}\n        };\n        std::vector<std::vector<int>> expected = {\n            {0, INT_MAX},\n            {INT_MAX, 0}\n        };\n        auto result = floyd_warshall_shortest_paths(matrix);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Negative cycle\") {\n        // Test case with a negative cycle\n        std::vector<std::vector<int>> matrix = {\n            {0, 1, INT_MAX},\n            {INT_MAX, 0, -1},\n            {-1, INT_MAX, 0}\n        };\n        std::vector<std::vector<int>> expected = {\n            {-1, 0, -1},\n            {-2, -1, -2},\n            {-2, -1, -2}\n        };\n        auto result = floyd_warshall_shortest_paths(matrix);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Implements the Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n * in a graph represented by an adjacency matrix.\n *\n * @param adjacency_matrix A 2D vector representing the graph, where adjacency_matrix[i][j] is the weight\n *                         of the edge from vertex i to vertex j. If there is no edge, the weight should\n *                         be represented as INT_MAX.\n * @return A 2D vector representing the shortest paths between all pairs of vertices. shortest_paths[i][j]\n *         will hold the shortest distance from vertex i to vertex j.\n */\nstd::vector<std::vector<int>> floyd_warshall_shortest_paths(const std::vector<std::vector<int>>& adjacency_matrix) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Implements the Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n * in a graph represented by an adjacency matrix.\n *\n * @param adjacencyMatrix The adjacency matrix representing the graph,\n *                        where adjacencyMatrix[i][j] is the weight of the edge from vertex i to vertex j.\n *                        If there is no edge, the weight should be represented as Double.POSITIVE_INFINITY.\n * @return The matrix representing the shortest paths between all pairs of vertices.\n *         shortestPaths[i][j] will hold the shortest distance from vertex i to vertex j.\n */\npublic static List<List<Double>> floydWarshallShortestPaths(List<List<Double>> adjacencyMatrix) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.real.temp.Answer;\n\npublic class Tester {\n\n    @Test\n    public void testBasicFunctionality() {\n        // Basic test case with a simple graph\n        List<List<Double>> matrix = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0, 3.0, Double.POSITIVE_INFINITY, 7.0)),\n            new ArrayList<>(Arrays.asList(8.0, 0.0, 2.0, Double.POSITIVE_INFINITY)),\n            new ArrayList<>(Arrays.asList(5.0, Double.POSITIVE_INFINITY, 0.0, 1.0)),\n            new ArrayList<>(Arrays.asList(2.0, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 0.0))\n        ));\n        List<List<Double>> expected = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0, 3.0, 5.0, 6.0)),\n            new ArrayList<>(Arrays.asList(5.0, 0.0, 2.0, 3.0)),\n            new ArrayList<>(Arrays.asList(3.0, 6.0, 0.0, 1.0)),\n            new ArrayList<>(Arrays.asList(2.0, 5.0, 7.0, 0.0))\n        ));\n        List<List<Double>> result = Answer.floydWarshallShortestPaths(matrix);\n        assertEquals(expected, result, \"Basic functionality test failed\");\n    }\n\n    @Test\n    public void testSingleVertexGraph() {\n        // Test case with a single vertex graph (1x1 matrix)\n        List<List<Double>> matrix = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0))\n        ));\n        List<List<Double>> expected = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0))\n        ));\n        List<List<Double>> result = Answer.floydWarshallShortestPaths(matrix);\n        assertEquals(expected, result, \"Single vertex graph test failed\");\n    }\n\n    @Test\n    public void testTwoVerticesGraph() {\n        // Test case with two vertices\n        List<List<Double>> matrix = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0, 1.0)),\n            new ArrayList<>(Arrays.asList(1.0, 0.0))\n        ));\n        List<List<Double>> expected = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0, 1.0)),\n            new ArrayList<>(Arrays.asList(1.0, 0.0))\n        ));\n        List<List<Double>> result = Answer.floydWarshallShortestPaths(matrix);\n        assertEquals(expected, result, \"Two vertices graph test failed\");\n    }\n\n    @Test\n    public void testLargeInfiniteWeights() {\n        // Test case with infinite weights\n        List<List<Double>> matrix = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0, Double.POSITIVE_INFINITY)),\n            new ArrayList<>(Arrays.asList(Double.POSITIVE_INFINITY, 0.0))\n        ));\n        List<List<Double>> expected = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0, Double.POSITIVE_INFINITY)),\n            new ArrayList<>(Arrays.asList(Double.POSITIVE_INFINITY, 0.0))\n        ));\n        List<List<Double>> result = Answer.floydWarshallShortestPaths(matrix);\n        assertEquals(expected, result, \"Large infinite weights test failed\");\n    }\n\n    @Test\n    public void testNegativeCycle() {\n        // Test case with a negative cycle\n        List<List<Double>> matrix = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0, 1.0, Double.POSITIVE_INFINITY)),\n            new ArrayList<>(Arrays.asList(Double.POSITIVE_INFINITY, 0.0, -1.0)),\n            new ArrayList<>(Arrays.asList(-1.0, Double.POSITIVE_INFINITY, 0.0))\n        ));\n        List<List<Double>> expected = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(-1.0, 0.0, -1.0)),\n            new ArrayList<>(Arrays.asList(-2.0, -1.0, -2.0)),\n            new ArrayList<>(Arrays.asList(-2.0, -1.0, -2.0))\n        ));\n        List<List<Double>> result = Answer.floydWarshallShortestPaths(matrix);\n        assertEquals(expected, result, \"Negative cycle test failed\");\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Implements the Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n * in a graph represented by an adjacency matrix.\n *\n * @param adjacencyMatrix The adjacency matrix representing the graph,\n *                        where adjacencyMatrix[i][j] is the weight of the edge from vertex i to vertex j.\n *                        If there is no edge, the weight should be represented as Double.POSITIVE_INFINITY.\n * @return The matrix representing the shortest paths between all pairs of vertices.\n *         shortestPaths[i][j] will hold the shortest distance from vertex i to vertex j.\n */\npublic static List<List<Double>> floydWarshallShortestPaths(List<List<Double>> adjacencyMatrix) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 37, "code_type": "method", "original_language": "python", "file_path": "orthojax\\e8f1b733e8d1a64eefe2e443c2d3909b859d2121\\orthojax\\orthpol.py", "question_type": "Algorithm and data structure", "summary": "Implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\nimport numpy as np\n\n\nclass QuadratureRule:\n    def __init__(self, x: np.ndarray, w: np.ndarray):\n        self.x = x\n        self.w = w\n\n\ndef lanczos(n: int, quadrature_rule: QuadratureRule) -> Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n    implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials\n    Args:\n        n (int): the number of orthogonal polynomials to generate\n        quadrature_rule (QuadratureRule): An object containing x (nodes) and w (weights) for the quadrature.\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass QuadratureRule:\n    def __init__(self, x, w):\n        self.x = np.array(x)\n        self.w = np.array(w)\n\n\nclass TestOrthogonalPolynomial(unittest.TestCase):\n    def test_lanczos_basic(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.333, 0.333, 0.334]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 2\n        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)\n\n        self.assertEqual(len(alpha), n)\n        self.assertEqual(len(beta), n - 1)\n        self.assertEqual(len(gamma), n)\n\n    def test_lanczos_n_greater_than_length(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.333, 0.333, 0.334]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 4\n\n        with self.assertRaises(ValueError):\n            lanczos(n, quadrature_rule)\n\n    def test_lanczos_n_zero(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.333, 0.333, 0.334]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 0\n\n        with self.assertRaises(ValueError):\n            lanczos(n, quadrature_rule)\n\n    def test_lanczos_weights_nonuniform(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.1, 0.4, 0.5]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 3\n        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)\n\n        self.assertEqual(len(alpha), n)\n        self.assertEqual(len(beta), n - 1)\n        self.assertEqual(len(gamma), n)\n        self.assertTrue(np.all(gamma > 0))\n\n    def test_lanczos_single_node(self):\n        x = [0.5]\n        w = [1.0]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 1\n        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)\n\n        self.assertEqual(len(alpha), n)\n        self.assertEqual(len(beta), n - 1)\n        self.assertEqual(len(gamma), n)\n        self.assertTrue(np.all(gamma > 0))", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\nimport numpy as np\n\n\nclass QuadratureRule:\n    def __init__(self, x: np.ndarray, w: np.ndarray):\n        self.x = x\n        self.w = w\n\n\ndef lanczos(n: int, quadrature_rule: QuadratureRule) -> Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n    implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials\n    Args:\n        n (int): the number of orthogonal polynomials to generate\n        quadrature_rule (QuadratureRule): An object containing x (nodes) and w (weights) for the quadrature.\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 41, "code_type": "class", "original_language": "python", "file_path": "imgt_657_examples\\d3cc758de270f8507d772e46a48d8355d2efe799\\bloom_filters\\bloom_filter.py", "question_type": "Algorithm and data structure", "summary": "Implement a bloom filter class with an add method that adds an element to the Bloom filter.Callers can check for the presence of an element directly using the in keyword", "language_version_list": {"python": {"code_signature": "class BloomFilter:\n    \"\"\"\n    Implement a bloom filter class with an add method that adds an element to the Bloom filter.Callers can check for the presence of an element directly using the in keyword\n    \"\"\"\n\n    def __init__(self, size, hash_count):\n        pass\n\n    def add(self, item):\n        # Add an item to the bloom filter\n        pass\n", "test_code": "import unittest\n\n\nclass TestBloomFilter(unittest.TestCase):\n\n    def setUp(self):\n        # Initialize BloomFilter with reasonable size and hash count for testing\n        self.bf = BloomFilter(1000, 5)\n\n    def test_add_and_check_presence(self):\n        # Test that added elements are reported as present\n        test_item = \"hello world\"\n        self.bf.add(test_item)\n        self.assertIn(test_item, self.bf)\n\n    def test_check_absence(self):\n        # Test that an unadded element is not present\n        self.assertNotIn(\"random item\", self.bf)\n\n    def test_false_positives(self):\n        # Adding some elements and check for a false positive\n        items_to_add = [\"item1\", \"item2\", \"item3\"]\n        for item in items_to_add:\n            self.bf.add(item)\n        # Check for an item not added, expecting a very low chance of false positive due to size and hash count\n        self.assertNotIn(\"item4\", self.bf)\n\n    def test_collision_handling(self):\n        # Test how the Bloom filter handles hash collisions by adding similar items\n        self.bf.add(\"item123\")\n        self.bf.add(\"item124\")\n        self.assertIn(\"item123\", self.bf)\n        self.assertIn(\"item124\", self.bf)\n\n    def test_empty_bloom_filter(self):\n        # Ensure that an empty Bloom Filter reports no items\n        self.assertNotIn(\"anything\", self.bf)", "prompt": "please write a python class , the class signature as below class BloomFilter:\n    \"\"\"\n    Implement a bloom filter class with an add method that adds an element to the Bloom filter.Callers can check for the presence of an element directly using the in keyword\n    \"\"\"\n\n    def __init__(self, size, hash_count):\n        pass\n\n    def add(self, item):\n        # Add an item to the bloom filter\n        pass\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Implement a Bloom filter class with an add method that adds an element to the Bloom filter.\n * Callers can check for the presence of an element directly using the in keyword.\n */\nclass BloomFilter {\npublic:\n    /**\n     * Constructor for the BloomFilter class.\n     *\n     * @param size The size of the bit array.\n     * @param hash_count The number of hash functions to use.\n     */\n    BloomFilter(size_t size, size_t hash_count);\n\n    /**\n     * Add an item to the Bloom filter.\n     *\n     * @param item The item to add.\n     */\n    void add(const std::string& item);\n\nprivate:\n    size_t size;          // Size of the bit array\n    size_t hash_count;    // Number of hash functions\n    std::vector<bool> bit_array; // Bit array for the Bloom filter\n};", "test_code": "TEST_CASE(\"Test BloomFilter functionality\", \"[BloomFilter]\") {\n    SECTION(\"Test add and check presence\") {\n        BloomFilter bf(1000, 5);\n        std::string test_item = \"hello world\";\n        bf.add(test_item);\n        REQUIRE(bf.contains(test_item));\n    }\n\n    SECTION(\"Test check absence\") {\n        BloomFilter bf(1000, 5);\n        REQUIRE_FALSE(bf.contains(\"random item\"));\n    }\n\n    SECTION(\"Test false positives\") {\n        BloomFilter bf(1000, 5);\n        std::vector<std::string> items_to_add = {\"item1\", \"item2\", \"item3\"};\n        for (const auto& item : items_to_add) {\n            bf.add(item);\n        }\n        REQUIRE_FALSE(bf.contains(\"item4\"));\n    }\n\n    SECTION(\"Test collision handling\") {\n        BloomFilter bf(1000, 5);\n        bf.add(\"item123\");\n        bf.add(\"item124\");\n        REQUIRE(bf.contains(\"item123\"));\n        REQUIRE(bf.contains(\"item124\"));\n    }\n\n    SECTION(\"Test empty Bloom Filter\") {\n        BloomFilter bf(1000, 5);\n        REQUIRE_FALSE(bf.contains(\"anything\"));\n    }\n}", "prompt": "please write a cpp class , the class signature as below /**\n * Implement a Bloom filter class with an add method that adds an element to the Bloom filter.\n * Callers can check for the presence of an element directly using the in keyword.\n */\nclass BloomFilter {\npublic:\n    /**\n     * Constructor for the BloomFilter class.\n     *\n     * @param size The size of the bit array.\n     * @param hash_count The number of hash functions to use.\n     */\n    BloomFilter(size_t size, size_t hash_count);\n\n    /**\n     * Add an item to the Bloom filter.\n     *\n     * @param item The item to add.\n     */\n    void add(const std::string& item);\n\nprivate:\n    size_t size;          // Size of the bit array\n    size_t hash_count;    // Number of hash functions\n    std::vector<bool> bit_array; // Bit array for the Bloom filter\n};", "addition_info": ""}, "java": {"code_signature": "/**\n * Implements a Bloom filter class with an add method that adds an element to the Bloom filter.\n * Callers can check for the presence of an element directly.\n */\npublic class BloomFilter {\n\n    /**\n     * Constructs a Bloom filter with the specified size and number of hash functions.\n     *\n     * @param size       the size of the Bloom filter\n     * @param hashCount  the number of hash functions to use\n     */\n    public BloomFilter(int size, int hashCount) {\n        // Constructor implementation goes here\n    }\n\n    /**\n     * Adds an item to the Bloom filter.\n     *\n     * @param item the item to add\n     */\n    public void add(String item) {\n        // Add an item to the Bloom filter\n        // Implementation goes here\n    }\n\n    /**\n     * Checks if an item is possibly present in the Bloom filter.\n     *\n     * @param item the item to check\n     * @return true if the item might be present, false otherwise\n     */\n    public boolean contains(String item) {\n        // Check if the item is possibly present in the Bloom filter\n        // Implementation goes here\n    }\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Test class for the BloomFilter implementation.\n */\npublic class Tester {\n\n    private Answer.BloomFilter bf;\n\n    @Before\n    public void setUp() {\n        // Initialize BloomFilter with reasonable size and hash count for testing\n        bf = new Answer.BloomFilter(1000, 5);\n    }\n\n    @Test\n    public void testAddAndCheckPresence() {\n        // Test that added elements are reported as present\n        String testItem = \"hello world\";\n        bf.add(testItem);\n        assertTrue(bf.contains(testItem));\n    }\n\n    @Test\n    public void testCheckAbsence() {\n        // Test that an unadded element is not present\n        assertFalse(bf.contains(\"random item\"));\n    }\n\n    @Test\n    public void testFalsePositives() {\n        // Adding some elements and check for a false positive\n        String[] itemsToAdd = {\"item1\", \"item2\", \"item3\"};\n        for (String item : itemsToAdd) {\n            bf.add(item);\n        }\n        // Check for an item not added, expecting a very low chance of false positive due to size and hash count\n        assertFalse(bf.contains(\"item4\"));\n    }\n\n    @Test\n    public void testCollisionHandling() {\n        // Test how the Bloom filter handles hash collisions by adding similar items\n        bf.add(\"item123\");\n        bf.add(\"item124\");\n        assertTrue(bf.contains(\"item123\"));\n        assertTrue(bf.contains(\"item124\"));\n    }\n\n    @Test\n    public void testEmptyBloomFilter() {\n        // Ensure that an empty Bloom Filter reports no items\n        assertFalse(bf.contains(\"anything\"));\n    }\n}\n", "prompt": "please write a java class , the function signature as below /**\n * Implements a Bloom filter class with an add method that adds an element to the Bloom filter.\n * Callers can check for the presence of an element directly.\n */\npublic class BloomFilter {\n\n    /**\n     * Constructs a Bloom filter with the specified size and number of hash functions.\n     *\n     * @param size       the size of the Bloom filter\n     * @param hashCount  the number of hash functions to use\n     */\n    public BloomFilter(int size, int hashCount) {\n        // Constructor implementation goes here\n    }\n\n    /**\n     * Adds an item to the Bloom filter.\n     *\n     * @param item the item to add\n     */\n    public void add(String item) {\n        // Add an item to the Bloom filter\n        // Implementation goes here\n    }\n\n    /**\n     * Checks if an item is possibly present in the Bloom filter.\n     *\n     * @param item the item to check\n     * @return true if the item might be present, false otherwise\n     */\n    public boolean contains(String item) {\n        // Check if the item is possibly present in the Bloom filter\n        // Implementation goes here\n    }\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 42, "code_type": "method", "original_language": "python", "file_path": "UNR\\463fd47f7c3b018dbe930d48fa9b46e92ca48d8b\\Fall-2023\\482-AI\\project-1-section482-682-ChristopherHowe\\naive_bayes_filter.py", "question_type": "Program input code", "summary": "replace all phones in the string with the string [PHONE_NUM]", "language_version_list": {"python": {"code_signature": "def replace_phone_numbers(text: str):\n    \"\"\"\n    replace all phones(phone formats in many) in the string with the string [PHONE_NUM]\n    For example:\n        input: Call me at 123-456-7890.\n        output: Call me at [PHONE_NUM].\n\n    Args:\n        text (str): The input string that may contain phone numbers.\n\n    Returns:\n        str: The modified string with phone numbers replaced by '[PHONE_NUM]'.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestReplacePhoneNumbers(unittest.TestCase):\n    def test_basic_number(self):\n        msg = \"Call me at 123-456-7890.\"\n        expected = \"Call me at [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n\n    def test_number_with_parentheses(self):\n        msg = \"Our office number is 123 456-7890.\"\n        expected = \"Our office number is [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n    def test_number_with_dots(self):\n        msg = \"Fax us at 123.456.7890.\"\n        expected = \"Fax us at [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n    def test_no_phone_number(self):\n        msg = \"Hello, please reply to this email.\"\n        expected = \"Hello, please reply to this email.\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n", "prompt": "please write a python function , the function signature as below def replace_phone_numbers(text: str):\n    \"\"\"\n    replace all phones(phone formats in many) in the string with the string [PHONE_NUM]\n    For example:\n        input: Call me at 123-456-7890.\n        output: Call me at [PHONE_NUM].\n\n    Args:\n        text (str): The input string that may contain phone numbers.\n\n    Returns:\n        str: The modified string with phone numbers replaced by '[PHONE_NUM]'.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Replaces all phone numbers in the given string with the string [PHONE_NUM].\n *\n * Example:\n *     Input: \"Call me at 123-456-7890.\"\n *     Output: \"Call me at [PHONE_NUM].\"\n *\n * @param text The input string that may contain phone numbers.\n * @return The modified string with phone numbers replaced by '[PHONE_NUM]'.\n */\nstd::string replace_phone_numbers(const std::string& text) {}", "test_code": "TEST_CASE(\"Test Replace Phone Numbers\") {\n    SECTION(\"Basic Number\") {\n        std::string msg = \"Call me at 123-456-7890.\";\n        std::string expected = \"Call me at [PHONE_NUM].\";\n        REQUIRE(replace_phone_numbers(msg) == expected);\n    }\n\n    SECTION(\"Number with Parentheses\") {\n        std::string msg = \"Our office number is 123 456-7890.\";\n        std::string expected = \"Our office number is [PHONE_NUM].\";\n        REQUIRE(replace_phone_numbers(msg) == expected);\n    }\n\n    SECTION(\"Number with Dots\") {\n        std::string msg = \"Fax us at 123.456.7890.\";\n        std::string expected = \"Fax us at [PHONE_NUM].\";\n        REQUIRE(replace_phone_numbers(msg) == expected);\n    }\n\n    SECTION(\"No Phone Number\") {\n        std::string msg = \"Hello, please reply to this email.\";\n        std::string expected = \"Hello, please reply to this email.\";\n        REQUIRE(replace_phone_numbers(msg) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Replaces all phone numbers in the given string with the string [PHONE_NUM].\n *\n * Example:\n *     Input: \"Call me at 123-456-7890.\"\n *     Output: \"Call me at [PHONE_NUM].\"\n *\n * @param text The input string that may contain phone numbers.\n * @return The modified string with phone numbers replaced by '[PHONE_NUM]'.\n */\nstd::string replace_phone_numbers(const std::string& text) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Replaces all phone numbers in the given string with \"[PHONE_NUM]\".\n * <p>\n * Example usage:\n * <pre>\n *     Input: Call me at 123-456-7890.\n *     Output: Call me at [PHONE_NUM].\n * </pre>\n *\n * @param text The input string that may contain phone numbers.\n * @return The modified string with phone numbers replaced by \"[PHONE_NUM]\".\n */\npublic static String replacePhoneNumbers(String text) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; // Import JUnit 4 Test annotation\nimport static org.junit.Assert.assertEquals; // Import assertEquals from JUnit 4 assertions\nimport org.real.temp.Answer;\n/**\n * Test cases for the replacePhoneNumbers method.\n */\npublic class Tester {\n\n    /**\n     * Tests replacing a basic phone number.\n     */\n    @Test\n    public void testBasicNumber() {\n        String msg = \"Call me at 123-456-7890.\";\n        String expected = \"Call me at [PHONE_NUM].\";\n        assertEquals(expected, Answer.replacePhoneNumbers(msg));\n    }\n\n    /**\n     * Tests replacing a phone number with spaces.\n     */\n    @Test\n    public void testNumberWithSpaces() {\n        String msg = \"Our office number is 123 456-7890.\";\n        String expected = \"Our office number is [PHONE_NUM].\";\n        assertEquals(expected, Answer.replacePhoneNumbers(msg));\n    }\n\n    /**\n     * Tests replacing a phone number with dots.\n     */\n    @Test\n    public void testNumberWithDots() {\n        String msg = \"Fax us at 123.456.7890.\";\n        String expected = \"Fax us at [PHONE_NUM].\";\n        assertEquals(expected, Answer.replacePhoneNumbers(msg));\n    }\n\n    /**\n     * Tests a message without a phone number.\n     */\n    @Test\n    public void testNoPhoneNumber() {\n        String msg = \"Hello, please reply to this email.\";\n        String expected = \"Hello, please reply to this email.\";\n        assertEquals(expected, Answer.replacePhoneNumbers(msg));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Replaces all phone numbers in the given string with \"[PHONE_NUM]\".\n * <p>\n * Example usage:\n * <pre>\n *     Input: Call me at 123-456-7890.\n *     Output: Call me at [PHONE_NUM].\n * </pre>\n *\n * @param text The input string that may contain phone numbers.\n * @return The modified string with phone numbers replaced by \"[PHONE_NUM]\".\n */\npublic static String replacePhoneNumbers(String text) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 43, "code_type": "method", "original_language": "python", "file_path": "OpenTPG\\e26269386fc3ee9c8e47749314b3c89a0c5230f9\\transf\\transformCSVtoJSON.py", "question_type": "Data processing and transformation", "summary": "Convert RGB color to HSV color\n", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef rgb_to_hsv(r: int, g: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    convert RGB color to HSV color.\n    For example:\n        input: 0, 0, 255\n        output: 240, 100, 100\n    Args:\n        r (int): rgb read value\n        g (int): rgb green value\n        b (int): rgb blue value\n\n    Returns:\n       Tuple[int, int, int]: HSV value\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestRGBtoHSV(unittest.TestCase):\n\n    def test_rgb_to_hsv_red(self):\n        # Test conversion of pure red color\n        r, g, b = 255, 0, 0\n        expected_result = (0, 100, 100)  # Hue should be 0, Saturation 1, Value 1 for red\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_green(self):\n        # Test conversion of pure green color\n        r, g, b = 0, 255, 0\n        expected_result = (120, 100, 100)  # Hue should be 120, Saturation 1, Value 1 for green\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_blue(self):\n        # Test conversion of pure blue color\n        r, g, b = 0, 0, 255\n        expected_result = (240, 100, 100)  # Hue should be 240, Saturation 1, Value 1 for blue\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_white(self):\n        # Test conversion of white color\n        r, g, b = 255, 255, 255\n        expected_result = (0, 0, 100)  # Hue is undefined, typically 0; Saturation 0, Value 1 for white\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_black(self):\n        # Test conversion of black color\n        r, g, b = 0, 0, 0\n        expected_result = (0, 0, 0)  # Hue is undefined, typically 0; Saturation 0, Value 0 for black\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef rgb_to_hsv(r: int, g: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    convert RGB color to HSV color.\n    For example:\n        input: 0, 0, 255\n        output: 240, 100, 100\n    Args:\n        r (int): rgb read value\n        g (int): rgb green value\n        b (int): rgb blue value\n\n    Returns:\n       Tuple[int, int, int]: HSV value\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert RGB color to HSV color.\n * \n * Example:\n *     Input: 0, 0, 255\n *     Output: 240, 100, 100\n * \n * @param r The red value of the RGB color.\n * @param g The green value of the RGB color.\n * @param b The blue value of the RGB color.\n * \n * @return A tuple containing the HSV values.\n */\nstd::tuple<double, double, double> rgb_to_hsv(int r, int g, int b) {}", "test_code": "TEST_CASE(\"Test RGB to HSV conversion\") {\n    SECTION(\"Test conversion of pure red color\") {\n        int r = 255, g = 0, b = 0;\n        auto expected_result = std::make_tuple(0.0, 100.0, 100.0);\n        auto result = rgb_to_hsv(r, g, b);\n        REQUIRE(std::get<0>(result) == std::get<0>(expected_result));\n        REQUIRE(std::get<1>(result) == std::get<1>(expected_result));\n        REQUIRE(std::get<2>(result) == std::get<2>(expected_result));\n    }\n\n    SECTION(\"Test conversion of pure green color\") {\n        int r = 0, g = 255, b = 0;\n        auto expected_result = std::make_tuple(120.0, 100.0, 100.0);\n        auto result = rgb_to_hsv(r, g, b);\n        REQUIRE(std::get<0>(result) == std::get<0>(expected_result));\n        REQUIRE(std::get<1>(result) == std::get<1>(expected_result));\n        REQUIRE(std::get<2>(result) == std::get<2>(expected_result));\n    }\n\n    SECTION(\"Test conversion of pure blue color\") {\n        int r = 0, g = 0, b = 255;\n        auto expected_result = std::make_tuple(240.0, 100.0, 100.0);\n        auto result = rgb_to_hsv(r, g, b);\n        REQUIRE(std::get<0>(result) == std::get<0>(expected_result));\n        REQUIRE(std::get<1>(result) == std::get<1>(expected_result));\n        REQUIRE(std::get<2>(result) == std::get<2>(expected_result));\n    }\n\n    SECTION(\"Test conversion of white color\") {\n        int r = 255, g = 255, b = 255;\n        auto expected_result = std::make_tuple(0.0, 0.0, 100.0);\n        auto result = rgb_to_hsv(r, g, b);\n        REQUIRE(std::get<0>(result) == std::get<0>(expected_result));\n        REQUIRE(std::get<1>(result) == std::get<1>(expected_result));\n        REQUIRE(std::get<2>(result) == std::get<2>(expected_result));\n    }\n\n    SECTION(\"Test conversion of black color\") {\n        int r = 0, g = 0, b = 0;\n        auto expected_result = std::make_tuple(0.0, 0.0, 0.0);\n        auto result = rgb_to_hsv(r, g, b);\n        REQUIRE(std::get<0>(result) == std::get<0>(expected_result));\n        REQUIRE(std::get<1>(result) == std::get<1>(expected_result));\n        REQUIRE(std::get<2>(result) == std::get<2>(expected_result));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert RGB color to HSV color.\n * \n * Example:\n *     Input: 0, 0, 255\n *     Output: 240, 100, 100\n * \n * @param r The red value of the RGB color.\n * @param g The green value of the RGB color.\n * @param b The blue value of the RGB color.\n * \n * @return A tuple containing the HSV values.\n */\nstd::tuple<double, double, double> rgb_to_hsv(int r, int g, int b) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts RGB color values to HSV (Hue, Saturation, Value).\n *\n * @param r the red component of the RGB color (0-255)\n * @param g the green component of the RGB color (0-255)\n * @param b the blue component of the RGB color (0-255)\n * @return an array containing the HSV values: [H, S, V]\n */\npublic static double[] rgbToHsv(int r, int g, int b) {}\n", "test_code": "package org.real.temp;\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\nimport org.real.temp.Answer;\npublic class Tester {\n\n    @Test\n    public void testRgbToHsvRed() {\n        // Test conversion of pure red color\n        int r = 255, g = 0, b = 0;\n        double[] expectedResult = {0, 100, 100}; // Hue should be 0, Saturation 100%, Value 100%\n        double[] result = Answer.rgbToHsv(r, g, b);\n        assertArrayEquals(expectedResult, result, 0.01); // Assert with a delta for floating point comparison\n    }\n\n    @Test\n    public void testRgbToHsvGreen() {\n        // Test conversion of pure green color\n        int r = 0, g = 255, b = 0;\n        double[] expectedResult = {120, 100, 100}; // Hue should be 120, Saturation 100%, Value 100%\n        double[] result = Answer.rgbToHsv(r, g, b);\n        assertArrayEquals(expectedResult, result, 0.01); // Assert with a delta for floating point comparison\n    }\n\n    @Test\n    public void testRgbToHsvBlue() {\n        // Test conversion of pure blue color\n        int r = 0, g = 0, b = 255;\n        double[] expectedResult = {240, 100, 100}; // Hue should be 240, Saturation 100%, Value 100%\n        double[] result = Answer.rgbToHsv(r, g, b);\n        assertArrayEquals(expectedResult, result, 0.01); // Assert with a delta for floating point comparison\n    }\n\n    @Test\n    public void testRgbToHsvWhite() {\n        // Test conversion of white color\n        int r = 255, g = 255, b = 255;\n        double[] expectedResult = {0, 0, 100}; // Hue is undefined, typically 0; Saturation 0%, Value 100%\n        double[] result = Answer.rgbToHsv(r, g, b);\n        assertArrayEquals(expectedResult, result, 0.01); // Assert with a delta for floating point comparison\n    }\n\n    @Test\n    public void testRgbToHsvBlack() {\n        // Test conversion of black color\n        int r = 0, g = 0, b = 0;\n        double[] expectedResult = {0, 0, 0}; // Hue is undefined, typically 0; Saturation 0%, Value 0%\n        double[] result = Answer.rgbToHsv(r, g, b);\n        assertArrayEquals(expectedResult, result, 0.01); // Assert with a delta for floating point comparison\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts RGB color values to HSV (Hue, Saturation, Value).\n *\n * @param r the red component of the RGB color (0-255)\n * @param g the green component of the RGB color (0-255)\n * @param b the blue component of the RGB color (0-255)\n * @return an array containing the HSV values: [H, S, V]\n */\npublic static double[] rgbToHsv(int r, int g, int b) {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 44, "code_type": "method", "original_language": "python", "file_path": "search-algorithms\\5ac08e08b690884ec300d257a6d417f9697cd020\\utils\\string_side_by_side.py", "question_type": "Data processing and transformation", "summary": "Align two lines of string to the left, supplementing with Spaces if the length is not enough", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef align_lines_left(str1: str, str2: str) -> Tuple[str, str]:\n    \"\"\"\n    Align two lines of string to the left, supplementing with Spaces if the length is not enough\n\n    Args:\n        str1 (str): str1\n        str2 (str): str2\n\n    Returns:\n        Tuple[str,str]: aligned str1 aligned str2\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestAlignLinesLeft(unittest.TestCase):\n\n    def test_equal_length_strings(self):\n        str1 = \"Hello\"\n        str2 = \"World\"\n        expected_str1 = \"Hello\"\n        expected_str2 = \"World\"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_first_string_longer(self):\n        str1 = \"Hello, World!\"\n        str2 = \"Hi\"\n        expected_str1 = \"Hello, World!\"\n        expected_str2 = \"Hi           \"  # 14 spaces after \"Hi\"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_second_string_longer(self):\n        str1 = \"Hey\"\n        str2 = \"Goodbye, friend!\"\n        expected_str1 = \"Hey             \"  # 15 spaces after \"Hey\"\n        expected_str2 = \"Goodbye, friend!\"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_empty_first_string(self):\n        str1 = \"\"\n        str2 = \"World\"\n        expected_str1 = \"     \"  # 5 spaces\n        expected_str2 = \"World\"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_empty_second_string(self):\n        str1 = \"Hello\"\n        str2 = \"\"\n        expected_str1 = \"Hello\"\n        expected_str2 = \"     \"  # 5 spaces\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_both_strings_empty(self):\n        str1 = \"\"\n        str2 = \"\"\n        expected_str1 = \"\"\n        expected_str2 = \"\"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_strings_with_spaces(self):\n        str1 = \"Hello \"\n        str2 = \"World  \"\n        expected_str1 = \"Hello  \"\n        expected_str2 = \"World  \"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef align_lines_left(str1: str, str2: str) -> Tuple[str, str]:\n    \"\"\"\n    Align two lines of string to the left, supplementing with Spaces if the length is not enough\n\n    Args:\n        str1 (str): str1\n        str2 (str): str2\n\n    Returns:\n        Tuple[str,str]: aligned str1 aligned str2\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Align two lines of string to the left, supplementing with spaces if the length is not enough.\n *\n * @param str1 The first string.\n * @param str2 The second string.\n * @return A pair of aligned strings (aligned_str1, aligned_str2).\n */\nstd::pair<std::string, std::string> align_lines_left(const std::string& str1, const std::string& str2) {}", "test_code": "TEST_CASE(\"Test align_lines_left function\", \"[align_lines_left]\") {\n    SECTION(\"Equal length strings\") {\n        std::string str1 = \"Hello\";\n        std::string str2 = \"World\";\n        std::string expected_str1 = \"Hello\";\n        std::string expected_str2 = \"World\";\n        auto [aligned_str1, aligned_str2] = align_lines_left(str1, str2);\n        REQUIRE(aligned_str1 == expected_str1);\n        REQUIRE(aligned_str2 == expected_str2);\n    }\n\n    SECTION(\"First string longer\") {\n        std::string str1 = \"Hello, World!\";\n        std::string str2 = \"Hi\";\n        std::string expected_str1 = \"Hello, World!\";\n        std::string expected_str2 = \"Hi           \";  // 14 spaces after \"Hi\"\n        auto [aligned_str1, aligned_str2] = align_lines_left(str1, str2);\n        REQUIRE(aligned_str1 == expected_str1);\n        REQUIRE(aligned_str2 == expected_str2);\n    }\n\n    SECTION(\"Second string longer\") {\n        std::string str1 = \"Hey\";\n        std::string str2 = \"Goodbye, friend!\";\n        std::string expected_str1 = \"Hey             \";  // 15 spaces after \"Hey\"\n        std::string expected_str2 = \"Goodbye, friend!\";\n        auto [aligned_str1, aligned_str2] = align_lines_left(str1, str2);\n        REQUIRE(aligned_str1 == expected_str1);\n        REQUIRE(aligned_str2 == expected_str2);\n    }\n\n    SECTION(\"Empty first string\") {\n        std::string str1 = \"\";\n        std::string str2 = \"World\";\n        std::string expected_str1 = \"     \";  // 5 spaces\n        std::string expected_str2 = \"World\";\n        auto [aligned_str1, aligned_str2] = align_lines_left(str1, str2);\n        REQUIRE(aligned_str1 == expected_str1);\n        REQUIRE(aligned_str2 == expected_str2);\n    }\n\n    SECTION(\"Empty second string\") {\n        std::string str1 = \"Hello\";\n        std::string str2 = \"\";\n        std::string expected_str1 = \"Hello\";\n        std::string expected_str2 = \"     \";  // 5 spaces\n        auto [aligned_str1, aligned_str2] = align_lines_left(str1, str2);\n        REQUIRE(aligned_str1 == expected_str1);\n        REQUIRE(aligned_str2 == expected_str2);\n    }\n\n    SECTION(\"Both strings empty\") {\n        std::string str1 = \"\";\n        std::string str2 = \"\";\n        std::string expected_str1 = \"\";\n        std::string expected_str2 = \"\";\n        auto [aligned_str1, aligned_str2] = align_lines_left(str1, str2);\n        REQUIRE(aligned_str1 == expected_str1);\n        REQUIRE(aligned_str2 == expected_str2);\n    }\n\n    SECTION(\"Strings with spaces\") {\n        std::string str1 = \"Hello \";\n        std::string str2 = \"World  \";\n        std::string expected_str1 = \"Hello  \";\n        std::string expected_str2 = \"World  \";\n        auto [aligned_str1, aligned_str2] = align_lines_left(str1, str2);\n        REQUIRE(aligned_str1 == expected_str1);\n        REQUIRE(aligned_str2 == expected_str2);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Align two lines of string to the left, supplementing with spaces if the length is not enough.\n *\n * @param str1 The first string.\n * @param str2 The second string.\n * @return A pair of aligned strings (aligned_str1, aligned_str2).\n */\nstd::pair<std::string, std::string> align_lines_left(const std::string& str1, const std::string& str2) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Aligns two lines of string to the left, supplementing with spaces if the length is not enough.\n *\n * @param str1 the first string\n * @param str2 the second string\n * @return an array containing the aligned strings (aligned str1, aligned str2)\n */\npublic static String[] alignLinesLeft(String str1, String str2) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static junit.framework.TestCase.assertEquals;\nimport static org.junit.Assert.assertArrayEquals; // Import for JUnit 4 assertions\n/**\n * Test class for aligning strings to the left.\n */\npublic class Tester {\n\n    /**\n     * Tests aligning strings of equal length.\n     */\n    @Test\n    public void testEqualLengthStrings() {\n        String str1 = \"Hello\";\n        String str2 = \"World\";\n        String expectedStr1 = \"Hello\";\n        String expectedStr2 = \"World\";\n        String[] alignedStrings = Answer.alignLinesLeft(str1, str2);\n        assertEquals(expectedStr1, alignedStrings[0]);\n        assertEquals(expectedStr2, alignedStrings[1]);\n    }\n\n    /**\n     * Tests aligning strings where the first string is longer.\n     */\n    @Test\n    public void testFirstStringLonger() {\n        String str1 = \"Hello, World!\";\n        String str2 = \"Hi\";\n        String expectedStr1 = \"Hello, World!\";\n        String expectedStr2 = \"Hi           \";  // 14 spaces after \"Hi\"\n        String[] alignedStrings = Answer.alignLinesLeft(str1, str2);\n        assertEquals(expectedStr1, alignedStrings[0]);\n        assertEquals(expectedStr2, alignedStrings[1]);\n    }\n\n    /**\n     * Tests aligning strings where the second string is longer.\n     */\n    @Test\n    public void testSecondStringLonger() {\n        String str1 = \"Hey\";\n        String str2 = \"Goodbye, friend!\";\n        String expectedStr1 = \"Hey             \";  // 15 spaces after \"Hey\"\n        String expectedStr2 = \"Goodbye, friend!\";\n        String[] alignedStrings = Answer.alignLinesLeft(str1, str2);\n        assertEquals(expectedStr1, alignedStrings[0]);\n        assertEquals(expectedStr2, alignedStrings[1]);\n    }\n\n    /**\n     * Tests aligning strings where the first string is empty.\n     */\n    @Test\n    public void testEmptyFirstString() {\n        String str1 = \"\";\n        String str2 = \"World\";\n        String expectedStr1 = \"     \";  // 5 spaces\n        String expectedStr2 = \"World\";\n        String[] alignedStrings = Answer.alignLinesLeft(str1, str2);\n        assertEquals(expectedStr1, alignedStrings[0]);\n        assertEquals(expectedStr2, alignedStrings[1]);\n    }\n\n    /**\n     * Tests aligning strings where the second string is empty.\n     */\n    @Test\n    public void testEmptySecondString() {\n        String str1 = \"Hello\";\n        String str2 = \"\";\n        String expectedStr1 = \"Hello\";\n        String expectedStr2 = \"     \";  // 5 spaces\n        String[] alignedStrings = Answer.alignLinesLeft(str1, str2);\n        assertEquals(expectedStr1, alignedStrings[0]);\n        assertEquals(expectedStr2, alignedStrings[1]);\n    }\n\n    /**\n     * Tests aligning strings with trailing spaces.\n     */\n    @Test\n    public void testStringsWithSpaces() {\n        String str1 = \"Hello \";\n        String str2 = \"World  \";\n        String expectedStr1 = \"Hello  \";\n        String expectedStr2 = \"World  \";\n        String[] alignedStrings = Answer.alignLinesLeft(str1, str2);\n        assertEquals(expectedStr1, alignedStrings[0]);\n        assertEquals(expectedStr2, alignedStrings[1]);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Aligns two lines of string to the left, supplementing with spaces if the length is not enough.\n *\n * @param str1 the first string\n * @param str2 the second string\n * @return an array containing the aligned strings (aligned str1, aligned str2)\n */\npublic static String[] alignLinesLeft(String str1, String str2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 45, "code_type": "method", "original_language": "python", "file_path": "libcolab\\aa179d3014b5e00b3a6d9eff415241c698d812f1\\review_calendar\\today.py", "question_type": "Data processing and transformation", "summary": "Returns the current time information including year, month, week of the month, and day of.eg {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }", "language_version_list": {"python": {"code_signature": "import datetime\n\n\ndef get_current_date_info(test_date: datetime.date) -> dict:\n    \"\"\"\n    Returns the current time information including year, month, week of the month, and day of.eg {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }\n\n    Args:\n        test_date (datetime.date): The date to compute information for, defaults to today's date if not provided.\n\n    Returns:\n        dict: A dictionary containing the year, month, week of the month, and day of the week.\n    \"\"\"\n", "test_code": "import unittest\nimport datetime\n\n\nclass TestGetCurrentDateInfo(unittest.TestCase):\n\n    def test_beginning_of_month(self):\n        result = get_current_date_info(datetime.date(2023, 1, 1))\n        expected = {\n            'year': 2023,\n            'month': 'January',\n            'week_of_the_month': 1,\n            'day_of_the_week': 'Sunday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_middle_of_month(self):\n        result = get_current_date_info(datetime.date(2023, 1, 15))\n        expected = {\n            'year': 2023,\n            'month': 'January',\n            'week_of_the_month': 3,\n            'day_of_the_week': 'Sunday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_leap_year(self):\n        result = get_current_date_info(datetime.date(2024, 2, 29))\n        expected = {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_change_of_year(self):\n        result = get_current_date_info(datetime.date(2022, 12, 31))\n        expected = {\n            'year': 2022,\n            'month': 'December',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Saturday'\n        }\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below import datetime\n\n\ndef get_current_date_info(test_date: datetime.date) -> dict:\n    \"\"\"\n    Returns the current time information including year, month, week of the month, and day of.eg {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }\n\n    Args:\n        test_date (datetime.date): The date to compute information for, defaults to today's date if not provided.\n\n    Returns:\n        dict: A dictionary containing the year, month, week of the month, and day of the week.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Returns the current time information including year, month, week of the month, and day of the week.\n *\n * Example output:\n * {\n *     'year': 2024,\n *     'month': 'February',\n *     'week_of_the_month': 5,\n *     'day_of_the_week': 'Thursday'\n * }\n *\n * @param test_date The date to compute information for, defaults to today's date if not provided.\n * @return A map containing the year, month, week of the month, and day of the week.\n */\nstd::map<std::string, std::string> get_current_date_info(const std::tm* test_date = nullptr) {", "test_code": "TEST_CASE(\"TestGetCurrentDateInfo\") {\n    SECTION(\"Beginning of the month\") {\n        std::tm date = {};\n        date.tm_year = 2023 - 1900; // Year since 1900\n        date.tm_mon = 0; // Month (0-based)\n        date.tm_mday = 1; // Day of the month\n        date.tm_isdst = -1; // Daylight saving time flag\n\n        auto result = get_current_date_info(&date);\n        std::map<std::string, std::string> expected = {\n            {\"year\", \"2023\"},\n            {\"month\", \"January\"},\n            {\"week_of_the_month\", \"1\"},\n            {\"day_of_the_week\", \"Sunday\"}\n        };\n\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Middle of the month\") {\n        std::tm date = {};\n        date.tm_year = 2023 - 1900; // Year since 1900\n        date.tm_mon = 0; // Month (0-based)\n        date.tm_mday = 15; // Day of the month\n        date.tm_isdst = -1; // Daylight saving time flag\n\n        auto result = get_current_date_info(&date);\n        std::map<std::string, std::string> expected = {\n            {\"year\", \"2023\"},\n            {\"month\", \"January\"},\n            {\"week_of_the_month\", \"3\"},\n            {\"day_of_the_week\", \"Sunday\"}\n        };\n\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Leap year\") {\n        std::tm date = {};\n        date.tm_year = 2024 - 1900; // Year since 1900\n        date.tm_mon = 1; // Month (0-based)\n        date.tm_mday = 29; // Day of the month\n        date.tm_isdst = -1; // Daylight saving time flag\n\n        auto result = get_current_date_info(&date);\n        std::map<std::string, std::string> expected = {\n            {\"year\", \"2024\"},\n            {\"month\", \"February\"},\n            {\"week_of_the_month\", \"5\"},\n            {\"day_of_the_week\", \"Thursday\"}\n        };\n\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Change of year\") {\n        std::tm date = {};\n        date.tm_year = 2022 - 1900; // Year since 1900\n        date.tm_mon = 11; // Month (0-based)\n        date.tm_mday = 31; // Day of the month\n        date.tm_isdst = -1; // Daylight saving time flag\n\n        auto result = get_current_date_info(&date);\n        std::map<std::string, std::string> expected = {\n            {\"year\", \"2022\"},\n            {\"month\", \"December\"},\n            {\"week_of_the_month\", \"5\"},\n            {\"day_of_the_week\", \"Saturday\"}\n        };\n\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Returns the current time information including year, month, week of the month, and day of the week.\n *\n * Example output:\n * {\n *     'year': 2024,\n *     'month': 'February',\n *     'week_of_the_month': 5,\n *     'day_of_the_week': 'Thursday'\n * }\n *\n * @param test_date The date to compute information for, defaults to today's date if not provided.\n * @return A map containing the year, month, week of the month, and day of the week.\n */\nstd::map<std::string, std::string> get_current_date_info(const std::tm* test_date = nullptr) {", "addition_info": ""}, "java": {"code_signature": "/**\n * Returns the current time information including year, month, week of the month, and day of the week.\n * Optionally takes a date object for testing purposes.\n *\n * @param testDate The date to compute information for, defaults to today's date if not provided.\n * @return A map containing the year, month, week of the month, and day of the week.\n */\npublic static Map<String, Object> getCurrentDateInfo(LocalDate testDate) {}", "test_code": "package org.real.temp;\n\nimport java.time.LocalDate;\nimport java.time.DayOfWeek;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.Test; // JUnit 4 Test annotation\nimport static org.junit.Assert.assertEquals; // JUnit 4 assertion methods\n\npublic class Tester {\n\n\n    @Test\n    public void testBeginningOfMonth() {\n        LocalDate testDate = LocalDate.of(2023, 1, 1);\n        Map<String, Object> result = Answer.getCurrentDateInfo(testDate);\n        Map<String, Object> expected = new HashMap<>();\n        expected.put(\"year\", 2023);\n        expected.put(\"month\", \"January\".toUpperCase());\n        expected.put(\"week_of_the_month\", 1);\n        expected.put(\"day_of_the_week\", \"SUNDAY\");\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testMiddleOfMonth() {\n        LocalDate testDate = LocalDate.of(2023, 1, 15);\n        Map<String, Object> result = Answer.getCurrentDateInfo(testDate);\n        Map<String, Object> expected = new HashMap<>();\n        expected.put(\"year\", 2023);\n        expected.put(\"month\", \"January\".toUpperCase());\n        expected.put(\"week_of_the_month\", 3);\n        expected.put(\"day_of_the_week\", \"SUNDAY\");\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testLeapYear() {\n        LocalDate testDate = LocalDate.of(2024, 2, 29);\n        Map<String, Object> result = Answer.getCurrentDateInfo(testDate);\n        Map<String, Object> expected = new HashMap<>();\n        expected.put(\"year\", 2024);\n        expected.put(\"month\", \"FEBRUARY\");\n        expected.put(\"week_of_the_month\", 5);\n        expected.put(\"day_of_the_week\", \"THURSDAY\");\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testChangeOfYear() {\n        LocalDate testDate = LocalDate.of(2022, 12, 31);\n        Map<String, Object> result = Answer.getCurrentDateInfo(testDate);\n        Map<String, Object> expected = new HashMap<>();\n        expected.put(\"year\", 2022);\n        expected.put(\"month\", \"DECEMBER\");\n        expected.put(\"week_of_the_month\", 5);\n        expected.put(\"day_of_the_week\", \"SATURDAY\");\n        assertEquals(expected, result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Returns the current time information including year, month, week of the month, and day of the week.\n * Optionally takes a date object for testing purposes.\n *\n * @param testDate The date to compute information for, defaults to today's date if not provided.\n * @return A map containing the year, month, week of the month, and day of the week.\n */\npublic static Map<String, Object> getCurrentDateInfo(LocalDate testDate) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 46, "code_type": "class", "original_language": "python", "file_path": "python_fiddle\\c54e8adb893ff70d825892aa6715cadb0ad27d73\\psdsa\\chatgpt\\binary_tree.py", "question_type": "Algorithm and data structure", "summary": "Create a binary tree class, and implement its preorder traversal, inorder traversal, postorder traversal", "language_version_list": {"python": {"code_signature": "class TreeNode:\n    \"\"\"\n    binary tree node\n    \"\"\"\n\n    def __init__(self, value=0, left=None, right=None):\n        pass\n\n\nclass BinaryTree:\n    \"\"\"\n    binary tree\n    \"\"\"\n\n    def __init__(self, root=None):\n        pass\n\n    def preorder_traversal(self, node, result=None):\n        pass\n\n    def inorder_traversal(self, node, result=None):\n        pass\n\n    def postorder_traversal(self, node, result=None):\n        pass\n", "test_code": "import unittest\n\n\nclass TestBinaryTree(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Setup basic tree structure for testing.\"\"\"\n        # Tree structure:\n        #      1\n        #     / \\\n        #    2   3\n        #   / \\\n        #  4   5\n        self.tree = BinaryTree(TreeNode(1))\n        self.tree.root.left = TreeNode(2, TreeNode(4), TreeNode(5))\n        self.tree.root.right = TreeNode(3)\n\n    def test_preorder_traversal(self):\n        \"\"\"Test preorder traversal.\"\"\"\n        result = self.tree.preorder_traversal(self.tree.root)\n        self.assertEqual(result, [1, 2, 4, 5, 3])\n\n    def test_inorder_traversal(self):\n        \"\"\"Test inorder traversal.\"\"\"\n        result = self.tree.inorder_traversal(self.tree.root)\n        self.assertEqual(result, [4, 2, 5, 1, 3])\n\n    def test_postorder_traversal(self):\n        \"\"\"Test postorder traversal.\"\"\"\n        result = self.tree.postorder_traversal(self.tree.root)\n        self.assertEqual(result, [4, 5, 2, 3, 1])\n\n    def test_empty_tree(self):\n        \"\"\"Test traversals on an empty tree.\"\"\"\n        empty_tree = BinaryTree()\n        self.assertEqual(empty_tree.preorder_traversal(empty_tree.root), [])\n        self.assertEqual(empty_tree.inorder_traversal(empty_tree.root), [])\n        self.assertEqual(empty_tree.postorder_traversal(empty_tree.root), [])\n\n    def test_single_node_tree(self):\n        \"\"\"Test all traversals on a tree with only one node.\"\"\"\n        single_node_tree = BinaryTree(TreeNode(10))\n        self.assertEqual(single_node_tree.preorder_traversal(single_node_tree.root), [10])\n        self.assertEqual(single_node_tree.inorder_traversal(single_node_tree.root), [10])\n        self.assertEqual(single_node_tree.postorder_traversal(single_node_tree.root), [10])\n", "prompt": "please write a python class , the class signature as below class TreeNode:\n    \"\"\"\n    binary tree node\n    \"\"\"\n\n    def __init__(self, value=0, left=None, right=None):\n        pass\n\n\nclass BinaryTree:\n    \"\"\"\n    binary tree\n    \"\"\"\n\n    def __init__(self, root=None):\n        pass\n\n    def preorder_traversal(self, node, result=None):\n        pass\n\n    def inorder_traversal(self, node, result=None):\n        pass\n\n    def postorder_traversal(self, node, result=None):\n        pass\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "// TreeNode class definition\nclass TreeNode {\npublic:\n    // Binary tree node\n    int value;\n    TreeNode* left;\n    TreeNode* right;\n\n    // Constructor for TreeNode\n    TreeNode(int val = 0, TreeNode* l = nullptr, TreeNode* r = nullptr) \n        : value(val), left(l), right(r) {}\n};\n\n// BinaryTree class definition\nclass BinaryTree {\npublic:\n    // Binary tree\n    TreeNode* root;\n\n    // Constructor for BinaryTree\n    BinaryTree(TreeNode* r = nullptr) : root(r) {}\n\n    // Recursive Preorder Traversal\n    std::vector<int> preorder_traversal(TreeNode* node, std::vector<int>* result = nullptr) {}\n\n    // Recursive Inorder Traversal\n    std::vector<int> inorder_traversal(TreeNode* node, std::vector<int>* result = nullptr) {}\n\n    // Recursive Postorder Traversal\n    std::vector<int> postorder_traversal(TreeNode* node, std::vector<int>* result = nullptr) {}\n};", "test_code": "TEST_CASE(\"TestBinaryTree\", \"[BinaryTree]\") {\n    TestBinaryTree test;\n\n    SECTION(\"Test preorder traversal\") {\n        test.setup();\n        std::vector<int> result = test.tree.preorder_traversal(test.tree.root);\n        REQUIRE_THAT(result, Catch::Matchers::Equals(std::vector<int>({1, 2, 4, 5, 3})));\n        test.teardown();\n    }\n\n    SECTION(\"Test inorder traversal\") {\n        test.setup();\n        std::vector<int> result = test.tree.inorder_traversal(test.tree.root);\n        REQUIRE_THAT(result, Catch::Matchers::Equals(std::vector<int>({4, 2, 5, 1, 3})));\n        test.teardown();\n    }\n\n    SECTION(\"Test postorder traversal\") {\n        test.setup();\n        std::vector<int> result = test.tree.postorder_traversal(test.tree.root);\n        REQUIRE_THAT(result, Catch::Matchers::Equals(std::vector<int>({4, 5, 2, 3, 1})));\n        test.teardown();\n    }\n\n    SECTION(\"Test empty tree\") {\n        BinaryTree empty_tree;\n        REQUIRE_THAT(empty_tree.preorder_traversal(empty_tree.root), Catch::Matchers::Equals(std::vector<int>({})));\n        REQUIRE_THAT(empty_tree.inorder_traversal(empty_tree.root), Catch::Matchers::Equals(std::vector<int>({})));\n        REQUIRE_THAT(empty_tree.postorder_traversal(empty_tree.root), Catch::Matchers::Equals(std::vector<int>({})));\n    }\n\n    SECTION(\"Test single node tree\") {\n        BinaryTree single_node_tree(new TreeNode(10));\n        REQUIRE_THAT(single_node_tree.preorder_traversal(single_node_tree.root), Catch::Matchers::Equals(std::vector<int>({10})));\n        REQUIRE_THAT(single_node_tree.inorder_traversal(single_node_tree.root), Catch::Matchers::Equals(std::vector<int>({10})));\n        REQUIRE_THAT(single_node_tree.postorder_traversal(single_node_tree.root), Catch::Matchers::Equals(std::vector<int>({10})));\n    }\n}", "prompt": "please write a cpp class , the class signature as below // TreeNode class definition\nclass TreeNode {\npublic:\n    // Binary tree node\n    int value;\n    TreeNode* left;\n    TreeNode* right;\n\n    // Constructor for TreeNode\n    TreeNode(int val = 0, TreeNode* l = nullptr, TreeNode* r = nullptr) \n        : value(val), left(l), right(r) {}\n};\n\n// BinaryTree class definition\nclass BinaryTree {\npublic:\n    // Binary tree\n    TreeNode* root;\n\n    // Constructor for BinaryTree\n    BinaryTree(TreeNode* r = nullptr) : root(r) {}\n\n    // Recursive Preorder Traversal\n    std::vector<int> preorder_traversal(TreeNode* node, std::vector<int>* result = nullptr) {}\n\n    // Recursive Inorder Traversal\n    std::vector<int> inorder_traversal(TreeNode* node, std::vector<int>* result = nullptr) {}\n\n    // Recursive Postorder Traversal\n    std::vector<int> postorder_traversal(TreeNode* node, std::vector<int>* result = nullptr) {}\n};", "addition_info": ""}, "java": {"code_signature": "/**\n * Represents a binary tree node.\n */\npublic class TreeNode {\n    private int value;\n    private TreeNode left;\n    private TreeNode right;\n\n    /**\n     * Constructs a new TreeNode with the specified value and optional children.\n     *\n     * @param value the value of the node\n     * @param left  the left child of the node\n     * @param right the right child of the node\n     */\n    public TreeNode(int value, TreeNode left, TreeNode right) {\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n\n    /**\n     * Constructs a new TreeNode with the specified value and no children.\n     *\n     * @param value the value of the node\n     */\n    public TreeNode(int value) {\n        this(value, null, null);\n    }\n\n    // Getters and setters for the fields\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public TreeNode getLeft() {\n        return left;\n    }\n\n    public void setLeft(TreeNode left) {\n        this.left = left;\n    }\n\n    public TreeNode getRight() {\n        return right;\n    }\n\n    public void setRight(TreeNode right) {\n        this.right = right;\n    }\n}\n\n/**\n * Represents a binary tree.\n */\npublic class BinaryTree {\n    private TreeNode root;\n\n    /**\n     * Constructs a new BinaryTree with the specified root node.\n     *\n     * @param root the root node of the tree\n     */\n    public BinaryTree(TreeNode root) {\n        this.root = root;\n    }\n\n    /**\n     * Constructs a new BinaryTree with no root node.\n     */\n    public BinaryTree() {\n        this(null);\n    }\n\n    /**\n     * Performs a preorder traversal of the binary tree.\n     *\n     * @param node   the current node being visited\n     * @param result the list to store the traversal results\n     * @return the list containing the preorder traversal results\n     */\n    public List<Integer> preorderTraversal(TreeNode node) {}\n\n    /**\n     * Performs an inorder traversal of the binary tree.\n     *\n     * @param node   the current node being visited\n     * @param result the list to store the traversal results\n     * @return the list containing the inorder traversal results\n     */\n    public List<Integer> inorderTraversal(TreeNode node) {}\n\n    /**\n     * Performs a postorder traversal of the binary tree.\n     *\n     * @param node   the current node being visited\n     * @param result the list to store the traversal results\n     * @return the list containing the postorder traversal results\n     */\n    public List<Integer> postorderTraversal(TreeNode node) {}\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport java.util.List;\nimport org.real.temp.Answer.TreeNode;\nimport org.real.temp.Answer.BinaryTree;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for BinaryTree operations.\n */\npublic class Tester {\n\n    private BinaryTree tree;\n    private BinaryTree emptyTree;\n    private BinaryTree singleNodeTree;\n\n    @Before\n    public void setUp() {\n        // Tree structure:\n        //      1\n        //     / \\\n        //    2   3\n        //   / \\\n        //  4   5\n        tree = new Answer.BinaryTree(new TreeNode(1));\n        tree.root.left = new Answer.TreeNode(2, new TreeNode(4), new TreeNode(5));\n        tree.root.right = new TreeNode(3);\n\n        emptyTree = new BinaryTree();\n\n        singleNodeTree = new BinaryTree(new TreeNode(10));\n    }\n\n    @Test\n    public void testPreorderTraversal() {\n        // Test preorder traversal\n        List<Integer> result = tree.preorderTraversal(tree.root);\n        assertEquals(\"[1, 2, 4, 5, 3]\", result.toString());\n    }\n\n    @Test\n    public void testInorderTraversal() {\n        // Test inorder traversal\n        List<Integer> result = tree.inorderTraversal(tree.root);\n        assertEquals(\"[4, 2, 5, 1, 3]\", result.toString());\n    }\n\n    @Test\n    public void testPostorderTraversal() {\n        // Test postorder traversal\n        List<Integer> result = tree.postorderTraversal(tree.root);\n        assertEquals(\"[4, 5, 2, 3, 1]\", result.toString());\n    }\n\n    @Test\n    public void testEmptyTree() {\n        // Test traversals on an empty tree\n        assertEquals(\"[]\", emptyTree.preorderTraversal(emptyTree.root).toString());\n        assertEquals(\"[]\", emptyTree.inorderTraversal(emptyTree.root).toString());\n        assertEquals(\"[]\", emptyTree.postorderTraversal(emptyTree.root).toString());\n    }\n\n    @Test\n    public void testSingleNodeTree() {\n        // Test all traversals on a tree with only one node\n        assertEquals(\"[10]\", singleNodeTree.preorderTraversal(singleNodeTree.root).toString());\n        assertEquals(\"[10]\", singleNodeTree.inorderTraversal(singleNodeTree.root).toString());\n        assertEquals(\"[10]\", singleNodeTree.postorderTraversal(singleNodeTree.root).toString());\n    }\n}", "prompt": "please write a java class , the function signature as below /**\n * Represents a binary tree node.\n */\npublic class TreeNode {\n    private int value;\n    private TreeNode left;\n    private TreeNode right;\n\n    /**\n     * Constructs a new TreeNode with the specified value and optional children.\n     *\n     * @param value the value of the node\n     * @param left  the left child of the node\n     * @param right the right child of the node\n     */\n    public TreeNode(int value, TreeNode left, TreeNode right) {\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n\n    /**\n     * Constructs a new TreeNode with the specified value and no children.\n     *\n     * @param value the value of the node\n     */\n    public TreeNode(int value) {\n        this(value, null, null);\n    }\n\n    // Getters and setters for the fields\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public TreeNode getLeft() {\n        return left;\n    }\n\n    public void setLeft(TreeNode left) {\n        this.left = left;\n    }\n\n    public TreeNode getRight() {\n        return right;\n    }\n\n    public void setRight(TreeNode right) {\n        this.right = right;\n    }\n}\n\n/**\n * Represents a binary tree.\n */\npublic class BinaryTree {\n    private TreeNode root;\n\n    /**\n     * Constructs a new BinaryTree with the specified root node.\n     *\n     * @param root the root node of the tree\n     */\n    public BinaryTree(TreeNode root) {\n        this.root = root;\n    }\n\n    /**\n     * Constructs a new BinaryTree with no root node.\n     */\n    public BinaryTree() {\n        this(null);\n    }\n\n    /**\n     * Performs a preorder traversal of the binary tree.\n     *\n     * @param node   the current node being visited\n     * @param result the list to store the traversal results\n     * @return the list containing the preorder traversal results\n     */\n    public List<Integer> preorderTraversal(TreeNode node) {}\n\n    /**\n     * Performs an inorder traversal of the binary tree.\n     *\n     * @param node   the current node being visited\n     * @param result the list to store the traversal results\n     * @return the list containing the inorder traversal results\n     */\n    public List<Integer> inorderTraversal(TreeNode node) {}\n\n    /**\n     * Performs a postorder traversal of the binary tree.\n     *\n     * @param node   the current node being visited\n     * @param result the list to store the traversal results\n     * @return the list containing the postorder traversal results\n     */\n    public List<Integer> postorderTraversal(TreeNode node) {}\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 47, "code_type": "method", "original_language": "python", "file_path": "libcolab\\aa179d3014b5e00b3a6d9eff415241c698d812f1\\review_calendar\\weekday.py", "question_type": "Data processing and transformation", "summary": "calculate the nth occurrence of a specific working day (k) in a given month (m) and year (y).\nIf there is no nth date in the month, the last date of the month is returned", "language_version_list": {"python": {"code_signature": "import datetime\n\n\ndef calculate_nth_weekday_in_month(year: int, month: int, occurrence: int, weekday: int) -> datetime.date:\n    \"\"\"\n    Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n    If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n    This function extends the capability to handle edge cases where the nth weekday might not be present,\n    by providing the closest previous weekday in such cases\n    Args:\n        y (int): The year for which the date is to be calculated.\n        m (int): The month for which the date is to be calculated, where January is 1 and December is 12.\n        n (int): The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n        k (int): The weekday, where Monday is 0 and Sunday is 6.\n\n    Returns:\n        datetime: The calculated date of the nth occurrence of the weekday in the given month and year.\n      If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n    \"\"\"\n", "test_code": "import unittest\nimport datetime\n\n\nclass TestFindNthWeekdayOfSpecificYear(unittest.TestCase):\n\n    def test_regular_occurrence(self):\n        # Test for the 2nd Monday of May 2023\n        result = calculate_nth_weekday_in_month(2023, 5, 2, 0)  # Monday is 0\n        expected = datetime.date(2023, 5, 8)\n        self.assertEqual(result, expected)\n\n    def test_last_occurrence(self):\n        # Test for the 5th Monday of May 2023, which doesn't exist, should return the last Monday\n        result = calculate_nth_weekday_in_month(2023, 5, 5, 0)  # Monday is 0\n        expected = datetime.date(2023, 5, 29)\n        self.assertEqual(result, expected)\n\n    def test_first_day_is_weekday(self):\n        # Test for when the first day of the month is the weekday in question, 1st Tuesday of August 2023\n        result = calculate_nth_weekday_in_month(2023, 8, 1, 1)  # Tuesday is 1\n        expected = datetime.date(2023, 8, 1)\n        self.assertEqual(result, expected)\n\n    def test_edge_year_transition(self):\n        # Test for the 1st Friday of December 2023\n        result = calculate_nth_weekday_in_month(2023, 12, 1, 4)  # Friday is 4\n        expected = datetime.date(2023, 12, 1)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below import datetime\n\n\ndef calculate_nth_weekday_in_month(year: int, month: int, occurrence: int, weekday: int) -> datetime.date:\n    \"\"\"\n    Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n    If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n    This function extends the capability to handle edge cases where the nth weekday might not be present,\n    by providing the closest previous weekday in such cases\n    Args:\n        y (int): The year for which the date is to be calculated.\n        m (int): The month for which the date is to be calculated, where January is 1 and December is 12.\n        n (int): The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n        k (int): The weekday, where Monday is 0 and Sunday is 6.\n\n    Returns:\n        datetime: The calculated date of the nth occurrence of the weekday in the given month and year.\n      If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n* @brief Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n* If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n* This function extends the capability to handle edge cases where the nth weekday might not be present,\n* by providing the closest previous weekday in such cases.\n*\n* @param y The year for which the date is to be calculated.\n* @param m The month for which the date is to be calculated, where January is 1 and December is 12.\n* @param n The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n* @param k The weekday, where Monday is 0 and Sunday is 6.\n*\n* @return The calculated date of the nth occurrence of the weekday in the given month and year.\n*         If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n*/\nstd::chrono::sys_days find_nth_weekday_of_specific_year(int y, int m, int n, int k) {}\n", "test_code": "TEST_CASE(\"Test find_nth_weekday_of_specific_year\", \"[find_nth_weekday_of_specific_year]\") {\n    SECTION(\"Regular occurrence\") {\n        // Test for the 2nd Monday of May 2023\n        auto result = find_nth_weekday_of_specific_year(2023, 5, 2, 0);  // Monday is 0\n        auto expected = std::chrono::sys_days{std::chrono::year_month_day{std::chrono::year{2023}, std::chrono::month{5}, std::chrono::day{8}}};\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Last occurrence\") {\n        // Test for the 5th Monday of May 2023, which doesn't exist, should return the last Monday\n        auto result = find_nth_weekday_of_specific_year(2023, 5, 5, 0);  // Monday is 0\n        auto expected = std::chrono::sys_days{std::chrono::year_month_day{std::chrono::year{2023}, std::chrono::month{5}, std::chrono::day{29}}};\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"First day is weekday\") {\n        // Test for when the first day of the month is the weekday in question, 1st Tuesday of August 2023\n        auto result = find_nth_weekday_of_specific_year(2023, 8, 1, 1);  // Tuesday is 1\n        auto expected = std::chrono::sys_days{std::chrono::year_month_day{std::chrono::year{2023}, std::chrono::month{8}, std::chrono::day{1}}};\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Edge year transition\") {\n        // Test for the 1st Friday of December 2023\n        auto result = find_nth_weekday_of_specific_year(2023, 12, 1, 4);  // Friday is 4\n        auto expected = std::chrono::sys_days{std::chrono::year_month_day{std::chrono::year{2023}, std::chrono::month{12}, std::chrono::day{1}}};\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n* @brief Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n* If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n* This function extends the capability to handle edge cases where the nth weekday might not be present,\n* by providing the closest previous weekday in such cases.\n*\n* @param y The year for which the date is to be calculated.\n* @param m The month for which the date is to be calculated, where January is 1 and December is 12.\n* @param n The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n* @param k The weekday, where Monday is 0 and Sunday is 6.\n*\n* @return The calculated date of the nth occurrence of the weekday in the given month and year.\n*         If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n*/\nstd::chrono::sys_days find_nth_weekday_of_specific_year(int y, int m, int n, int k) {}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the date of the nth occurrence of a specific weekday in a given month and year.\n * \n * @param y The year for which the date is to be calculated.\n * @param m The month for which the date is to be calculated, where January is 1 and December is 12.\n * @param n The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n * @param k The weekday, where Monday is 0 and Sunday is 6.\n * @return LocalDate The calculated date of the nth occurrence of the weekday in the given month and year.\n *         If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n */\npublic static LocalDate findNthWeekdayOfSpecificYear(int y, int m, int n, int k) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; // JUnit 4 Test annotation\nimport static org.junit.Assert.assertEquals; // JUnit 4 assertion method\nimport java.time.LocalDate;\n\npublic class Tester {\n\n    @Test\n    public void testRegularOccurrence() {\n        // Test for the 2nd Monday of May 2023\n        LocalDate result = findNthWeekdayOfSpecificYear(2023, 5, 2, 0);  // Monday is 0\n        LocalDate expected = LocalDate.of(2023, 5, 8);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testLastOccurrence() {\n        // Test for the 5th Monday of May 2023, which doesn't exist, should return the last Monday\n        LocalDate result = findNthWeekdayOfSpecificYear(2023, 5, 5, 0);  // Monday is 0\n        LocalDate expected = LocalDate.of(2023, 5, 29);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testFirstDayIsWeekday() {\n        // Test for when the first day of the month is the weekday in question, 1st Tuesday of August 2023\n        LocalDate result = findNthWeekdayOfSpecificYear(2023, 8, 1, 1);  // Tuesday is 1\n        LocalDate expected = LocalDate.of(2023, 8, 1);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testEdgeYearTransition() {\n        // Test for the 1st Friday of December 2023\n        LocalDate result = findNthWeekdayOfSpecificYear(2023, 12, 1, 4);  // Friday is 4\n        LocalDate expected = LocalDate.of(2023, 12, 1);\n        assertEquals(expected, result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Calculates the date of the nth occurrence of a specific weekday in a given month and year.\n * \n * @param y The year for which the date is to be calculated.\n * @param m The month for which the date is to be calculated, where January is 1 and December is 12.\n * @param n The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n * @param k The weekday, where Monday is 0 and Sunday is 6.\n * @return LocalDate The calculated date of the nth occurrence of the weekday in the given month and year.\n *         If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n */\npublic static LocalDate findNthWeekdayOfSpecificYear(int y, int m, int n, int k) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 51, "code_type": "method", "original_language": "python", "file_path": "facemocap_dataset\\a44395f9c13cda203ef33c10740605ce6980a276\\seqpc.py", "question_type": "Data processing and transformation", "summary": "convert a point cloud data from the current coordinate system to coordinates in a coordinate system defined by three reference points\n", "language_version_list": {"python": {"code_signature": "from typing import List\nimport numpy as np\n\n\ndef transform_point_cloud_to_reference_frame(point_cloud: np.array, ref_frame_points: List[np.array]) -> np.array:\n    \"\"\"\n    Transforms a point cloud to a new reference frame defined by three points.\n\n    Parameters:\n        point_cloud (np.array): The Nx3 array of points in the original reference frame.\n        ref_frame_points (List): A list of three points (np.array), defining the new reference frame.\n\n    Returns:\n        np.array: Transformed point cloud in the new reference frame.\n    \"\"\"\n", "test_code": "import unittest\nimport numpy as np\n\nclass TestChangeReferenceFrame(unittest.TestCase):\n    def setUp(self):\n        # Basic setup for tests, initialize some common point clouds and frames\n        self.point_cloud = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        self.ref_frame_points = [np.array([0, 0, 0]), np.array([1, 0, 0]), np.array([0, 1, 0])]\n\n    def test_identity_transformation(self):\n        # Test with an identity transformation where the reference frame is the standard basis\n        result = transform_point_cloud_to_reference_frame(self.point_cloud, self.ref_frame_points)\n        np.testing.assert_array_almost_equal(result, self.point_cloud - np.array([0, 0, 0]))\n\n    def test_translation(self):\n        # Only translation no rotation; move the origin\n        frame_points = [np.array([1, 1, 1]), np.array([2, 1, 1]), np.array([1, 2, 1])]\n        result = transform_point_cloud_to_reference_frame(self.point_cloud, frame_points)\n        expected = np.array([[-1. , 0.,  1.], [ 2. , 3.,  4.], [ 5.,  6. , 7.]])\n        np.testing.assert_array_almost_equal(result, expected)\n\n    def test_rotation(self):\n        # Rotation about z-axis by 90 degrees\n        frame_points = [np.array([0, 0, 0]), np.array([0, 1, 0]), np.array([0, 1, 1])]\n        result = transform_point_cloud_to_reference_frame(self.point_cloud, frame_points)\n        expected = np.array([[2. , 3.,  1.], [ 5. , 6.,  4.], [ 8.,  9. , 7.]])\n        np.testing.assert_array_almost_equal(result, expected)\n\n    def test_non_orthonormal_frame(self):\n        # Use non-orthonormal frame to see how function handles it (should normalize internally)\n        frame_points = [np.array([0, 0, 0]), np.array([1, 0, 0]), np.array([1, 1, 0])]\n        result = transform_point_cloud_to_reference_frame(self.point_cloud, frame_points)\n        # Manually compute expected model_answer_result\n        u = np.array([1, 0, 0])\n        v = np.array([0, 1, 0])\n        w = np.cross(u, v)\n        rotation_matrix = np.column_stack((u, v, w))\n        expected = np.dot(self.point_cloud, rotation_matrix.T)\n        np.testing.assert_array_almost_equal(result, expected)\n\n    def test_inverted_frame(self):\n        # Inverting the frame to see if negatives are handled\n        frame_points = [np.array([0, 0, 0]), np.array([-1, 0, 0]), np.array([0, -1, 0])]\n        result = transform_point_cloud_to_reference_frame(self.point_cloud, frame_points)\n        expected = np.dot(self.point_cloud, np.array([[-1, 0, 0], [0, -1, 0], [0, 0, 1]]))\n        np.testing.assert_array_almost_equal(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\nimport numpy as np\n\n\ndef transform_point_cloud_to_reference_frame(point_cloud: np.array, ref_frame_points: List[np.array]) -> np.array:\n    \"\"\"\n    Transforms a point cloud to a new reference frame defined by three points.\n\n    Parameters:\n        point_cloud (np.array): The Nx3 array of points in the original reference frame.\n        ref_frame_points (List): A list of three points (np.array), defining the new reference frame.\n\n    Returns:\n        np.array: Transformed point cloud in the new reference frame.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 52, "code_type": "method", "original_language": "python", "file_path": "scratchScripts\\f2e7f54c168e69f9c48c0935baf5ce28f277e8d0\\renameFiles.py", "question_type": "File operations and I/O operation", "summary": "rename the windows file path string, replacing the colon: in the file name with the \"_\"", "language_version_list": {"python": {"code_signature": "def rename_file_path(path: str) -> str:\n    \"\"\"\n    Renames a Windows file path by replacing colons in the filename with underscores.\n\n    Parameters:\n        path (str): The original file path.\n\n    Returns:\n        str: The modified file path with colons in the filename replaced by underscores.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestRenameFilePath(unittest.TestCase):\n    def test_rename_with_colon_in_filename(self):\n        # Test path with colon in the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\report:2023.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\report_2023.txt'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_without_colon_in_filename(self):\n        # Test path without colon in the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_with_multiple_colons_in_filename(self):\n        # Test path with multiple colons in the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\project:report:2023.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\project_report_2023.txt'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_with_colon_at_end_of_filename(self):\n        # Test path with a colon at the end of the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\backup:'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\backup_'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_with_colon_at_start_of_filename(self):\n        # Test path with a colon at the start of the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\:initial_setup.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\_initial_setup.txt'\n        self.assertEqual(rename_file_path(path), expected)\n", "prompt": "please write a python function , the function signature as below def rename_file_path(path: str) -> str:\n    \"\"\"\n    Renames a Windows file path by replacing colons in the filename with underscores.\n\n    Parameters:\n        path (str): The original file path.\n\n    Returns:\n        str: The modified file path with colons in the filename replaced by underscores.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Renames a Windows file path by replacing colons in the filename with underscores.\n *\n * @param path The original file path.\n * @return The modified file path with colons in the filename replaced by underscores.\n */\nstd::string rename_file_path(const std::string& path) {}", "test_code": "TEST_CASE(\"Test rename_file_path function\", \"[rename_file_path]\") {\n    SECTION(\"Test path with colon in the filename\") {\n        // Test path with colon in the filename\n        std::string path = \"C:\\\\Users\\\\example\\\\Documents\\\\report:2023.txt\";\n        std::string expected = \"C:\\\\Users\\\\example\\\\Documents\\\\report_2023.txt\";\n        REQUIRE(rename_file_path(path) == expected);\n    }\n\n    SECTION(\"Test path without colon in the filename\") {\n        // Test path without colon in the filename\n        std::string path = \"C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt\";\n        std::string expected = \"C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt\";\n        REQUIRE(rename_file_path(path) == expected);\n    }\n\n    SECTION(\"Test path with multiple colons in the filename\") {\n        // Test path with multiple colons in the filename\n        std::string path = \"C:\\\\Users\\\\example\\\\Documents\\\\project:report:2023.txt\";\n        std::string expected = \"C:\\\\Users\\\\example\\\\Documents\\\\project_report_2023.txt\";\n        REQUIRE(rename_file_path(path) == expected);\n    }\n\n    SECTION(\"Test path with a colon at the end of the filename\") {\n        // Test path with a colon at the end of the filename\n        std::string path = \"C:\\\\Users\\\\example\\\\Documents\\\\backup:\";\n        std::string expected = \"C:\\\\Users\\\\example\\\\Documents\\\\backup_\";\n        REQUIRE(rename_file_path(path) == expected);\n    }\n\n    SECTION(\"Test path with a colon at the start of the filename\") {\n        // Test path with a colon at the start of the filename\n        std::string path = \"C:\\\\Users\\\\example\\\\Documents\\\\:initial_setup.txt\";\n        std::string expected = \"C:\\\\Users\\\\example\\\\Documents\\\\_initial_setup.txt\";\n        REQUIRE(rename_file_path(path) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Renames a Windows file path by replacing colons in the filename with underscores.\n *\n * @param path The original file path.\n * @return The modified file path with colons in the filename replaced by underscores.\n */\nstd::string rename_file_path(const std::string& path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Renames a Windows file path by replacing colons in the filename with underscores.\n *\n * @param path The original file path.\n * @return The modified file path with colons in the filename replaced by underscores.\n */\npublic static String renameFilePath(String path) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; // Change to JUnit 4 Test import\n\nimport static org.junit.Assert.assertEquals; // Change to JUnit 4 assertion\nimport static org.real.temp.Answer.*;\n\n/**\n * Test cases for the renameFilePath method.\n */\npublic class Tester {\n\n    /**\n     * Tests renaming a file path with a colon in the filename.\n     */\n    @Test\n    public void testRenameWithColonInFilename() {\n        // Test path with colon in the filename\n        String path = \"C:\\\\Users\\\\example\\\\Documents\\\\report:2023.txt\";\n        String expected = \"C:\\\\Users\\\\example\\\\Documents\\\\report_2023.txt\";\n        assertEquals(expected, renameFilePath(path));\n    }\n\n    /**\n     * Tests renaming a file path without a colon in the filename.\n     */\n    @Test\n    public void testRenameWithoutColonInFilename() {\n        // Test path without colon in the filename\n        String path = \"C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt\";\n        String expected = \"C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt\";\n        assertEquals(expected, renameFilePath(path));\n    }\n\n    /**\n     * Tests renaming a file path with multiple colons in the filename.\n     */\n    @Test\n    public void testRenameWithMultipleColonsInFilename() {\n        // Test path with multiple colons in the filename\n        String path = \"C:\\\\Users\\\\example\\\\Documents\\\\project:report:2023.txt\";\n        String expected = \"C:\\\\Users\\\\example\\\\Documents\\\\project_report_2023.txt\";\n        assertEquals(expected, renameFilePath(path));\n    }\n\n    /**\n     * Tests renaming a file path with a colon at the end of the filename.\n     */\n    @Test\n    public void testRenameWithColonAtEndOfFilename() {\n        // Test path with a colon at the end of the filename\n        String path = \"C:\\\\Users\\\\example\\\\Documents\\\\backup:\";\n        String expected = \"C:\\\\Users\\\\example\\\\Documents\\\\backup_\";\n        assertEquals(expected, renameFilePath(path));\n    }\n\n    /**\n     * Tests renaming a file path with a colon at the start of the filename.\n     */\n    @Test\n    public void testRenameWithColonAtStartOfFilename() {\n        // Test path with a colon at the start of the filename\n        String path = \"C:\\\\Users\\\\example\\\\Documents\\\\:initial_setup.txt\";\n        String expected = \"C:\\\\Users\\\\example\\\\Documents\\\\_initial_setup.txt\";\n        assertEquals(expected, renameFilePath(path));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Renames a Windows file path by replacing colons in the filename with underscores.\n *\n * @param path The original file path.\n * @return The modified file path with colons in the filename replaced by underscores.\n */\npublic static String renameFilePath(String path) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 53, "code_type": "method", "original_language": "python", "file_path": "2D-programmable-waveguide\\bb7c6a3a88ba69769323160c1c0b694e6e09ee22\\tdwg\\lib\\misc_utils.py", "question_type": "Data processing and transformation", "summary": "computes and returns the size of an object in bytes in memory\n", "language_version_list": {"python": {"code_signature": "def size_in_bytes(obj) -> int:\n    \"\"\"\n    computes and returns the size of an object in bytes in memory\n\n    Args:\n        obj (any): question object\n\n    Returns: the size of this object in bytes in memory\n\n    \"\"\"\n", "test_code": "import unittest\nimport sys\n\nclass TestSizeInBytes(unittest.TestCase):\n\n    def test_size_of_integer(self):\n        # Test the size of an integer\n        integer_value = 42\n        expected_size = sys.getsizeof(integer_value)\n        result_size = size_in_bytes(integer_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_string(self):\n        # Test the size of a string\n        string_value = \"Hello, world!\"\n        expected_size = sys.getsizeof(string_value)\n        result_size = size_in_bytes(string_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_list(self):\n        # Test the size of a list\n        list_value = [1, 2, 3, 4, 5]\n        expected_size = sys.getsizeof(list_value)\n        result_size = size_in_bytes(list_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_dictionary(self):\n        # Test the size of a dictionary\n        dict_value = {'key1': 'value1', 'key2': 'value2'}\n        expected_size = sys.getsizeof(dict_value)\n        result_size = size_in_bytes(dict_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_custom_object(self):\n        # Test the size of a custom object\n        class CustomObject:\n            def __init__(self):\n                self.attr1 = 'a'\n                self.attr2 = 123\n        custom_obj = CustomObject()\n        expected_size = sys.getsizeof(custom_obj)  # Note: Does not include size of attributes unless explicitly calculated\n        result_size = size_in_bytes(custom_obj)\n        self.assertEqual(result_size, expected_size)", "prompt": "please write a python function , the function signature as below def size_in_bytes(obj) -> int:\n    \"\"\"\n    computes and returns the size of an object in bytes in memory\n\n    Args:\n        obj (any): question object\n\n    Returns: the size of this object in bytes in memory\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 54, "code_type": "method", "original_language": "python", "file_path": "chatgpt-scripts\\27413237472c6b1228294fed76b3cc46d66bec41\\stratechery-translator\\translator.py", "question_type": "Data processing and transformation", "summary": "process a list of strings, removing the three consecutive backticks from each string", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef remove_triple_backticks(string_list: List[str]) -> List[str]:\n    \"\"\"\n    process a list of strings, removing the three consecutive backticks from each string\n    Args:\n        string_list (List[str]): The list of strings to process.\n\n    Returns:\n        A new list with all instances of three consecutive backticks removed from each string.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestRemoveTripleBackticks(unittest.TestCase):\n\n    def test_remove_triple_backticks_basic(self):\n        # Test basic functionality\n        input_strings = ['Here is ```code``` example', 'Another ```example``` here', 'No backticks here']\n        expected_output = ['Here is code example', 'Another example here', 'No backticks here']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_strings_with_multiple_instances(self):\n        # Test strings containing multiple instances of triple backticks\n        input_strings = ['Multiple ```backticks``` in ```one``` string']\n        expected_output = ['Multiple backticks in one string']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_empty_strings(self):\n        # Test with empty strings\n        input_strings = ['']\n        expected_output = ['']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_no_triple_backticks(self):\n        # Test strings that do not contain triple backticks\n        input_strings = ['Just a normal string', 'Another normal string']\n        expected_output = ['Just a normal string', 'Another normal string']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_edge_cases(self):\n        # Test edge cases like strings made entirely of triple backticks\n        input_strings = ['```', '```more```', 'text``````']\n        expected_output = ['', 'more', 'text']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef remove_triple_backticks(string_list: List[str]) -> List[str]:\n    \"\"\"\n    process a list of strings, removing the three consecutive backticks from each string\n    Args:\n        string_list (List[str]): The list of strings to process.\n\n    Returns:\n        A new list with all instances of three consecutive backticks removed from each string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Processes a list of strings, removing all occurrences of three consecutive backticks from each string.\n *\n * @param string_list The list of strings to process.\n * @return A new list with all instances of three consecutive backticks removed from each string.\n */\nstd::vector<std::string> remove_triple_backticks(const std::vector<std::string>& string_list) {}", "test_code": "TEST_CASE(\"Test remove_triple_backticks functionality\") {\n    SECTION(\"Basic functionality\") {\n        // Test basic functionality\n        std::vector<std::string> input_strings = {\"Here is ```code``` example\", \"Another ```example``` here\", \"No backticks here\"};\n        std::vector<std::string> expected_output = {\"Here is code example\", \"Another example here\", \"No backticks here\"};\n        REQUIRE(remove_triple_backticks(input_strings) == expected_output);\n    }\n\n    SECTION(\"Strings with multiple instances of triple backticks\") {\n        // Test strings containing multiple instances of triple backticks\n        std::vector<std::string> input_strings = {\"Multiple ```backticks``` in ```one``` string\"};\n        std::vector<std::string> expected_output = {\"Multiple backticks in one string\"};\n        REQUIRE(remove_triple_backticks(input_strings) == expected_output);\n    }\n\n    SECTION(\"Empty strings\") {\n        // Test with empty strings\n        std::vector<std::string> input_strings = {\"\"};\n        std::vector<std::string> expected_output = {\"\"};\n        REQUIRE(remove_triple_backticks(input_strings) == expected_output);\n    }\n\n    SECTION(\"Strings that do not contain triple backticks\") {\n        // Test strings that do not contain triple backticks\n        std::vector<std::string> input_strings = {\"Just a normal string\", \"Another normal string\"};\n        std::vector<std::string> expected_output = {\"Just a normal string\", \"Another normal string\"};\n        REQUIRE(remove_triple_backticks(input_strings) == expected_output);\n    }\n\n    SECTION(\"Edge cases\") {\n        // Test edge cases like strings made entirely of triple backticks\n        std::vector<std::string> input_strings = {\"```\", \"```more```\", \"text``````\"};\n        std::vector<std::string> expected_output = {\"\", \"more\", \"text\"};\n        REQUIRE(remove_triple_backticks(input_strings) == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Processes a list of strings, removing all occurrences of three consecutive backticks from each string.\n *\n * @param string_list The list of strings to process.\n * @return A new list with all instances of three consecutive backticks removed from each string.\n */\nstd::vector<std::string> remove_triple_backticks(const std::vector<std::string>& string_list) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Processes a list of strings, removing all occurrences of three consecutive backticks from each string.\n *\n * @param stringList The list of strings to process.\n * @return A new list with all instances of three consecutive backticks removed from each string.\n */\npublic static List<String> removeTripleBackticks(List<String> stringList) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; // JUnit 4 Test annotation\nimport static org.junit.Assert.assertEquals; // JUnit 4 assertion method\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testRemoveTripleBackticksBasic() {\n        // Test basic functionality\n        List<String> inputStrings = Arrays.asList(\"Here is ```code``` example\", \"Another ```example``` here\", \"No backticks here\");\n        List<String> expectedOutput = Arrays.asList(\"Here is code example\", \"Another example here\", \"No backticks here\");\n        assertEquals(expectedOutput, removeTripleBackticks(inputStrings));\n    }\n\n    @Test\n    public void testStringsWithMultipleInstances() {\n        // Test strings containing multiple instances of triple backticks\n        List<String> inputStrings = Arrays.asList(\"Multiple ```backticks``` in ```one``` string\");\n        List<String> expectedOutput = Arrays.asList(\"Multiple backticks in one string\");\n        assertEquals(expectedOutput, removeTripleBackticks(inputStrings));\n    }\n\n    @Test\n    public void testEmptyStrings() {\n        // Test with empty strings\n        List<String> inputStrings = Arrays.asList(\"\");\n        List<String> expectedOutput = Arrays.asList(\"\");\n        assertEquals(expectedOutput, removeTripleBackticks(inputStrings));\n    }\n\n    @Test\n    public void testNoTripleBackticks() {\n        // Test strings that do not contain triple backticks\n        List<String> inputStrings = Arrays.asList(\"Just a normal string\", \"Another normal string\");\n        List<String> expectedOutput = Arrays.asList(\"Just a normal string\", \"Another normal string\");\n        assertEquals(expectedOutput, removeTripleBackticks(inputStrings));\n    }\n\n    @Test\n    public void testEdgeCases() {\n        // Test edge cases like strings made entirely of triple backticks\n        List<String> inputStrings = Arrays.asList(\"```\", \"```more```\", \"text``````\");\n        List<String> expectedOutput = Arrays.asList(\"\", \"more\", \"text\");\n        assertEquals(expectedOutput, removeTripleBackticks(inputStrings));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Processes a list of strings, removing all occurrences of three consecutive backticks from each string.\n *\n * @param stringList The list of strings to process.\n * @return A new list with all instances of three consecutive backticks removed from each string.\n */\npublic static List<String> removeTripleBackticks(List<String> stringList) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 55, "code_type": "method", "original_language": "python", "file_path": "coding-challenges\\62dcf7e64edd4cfebd2c8167f504b6482ea4ce52\\codility\\mindistinct.py", "question_type": "Algorithm and data structure", "summary": "You are given an integer array nums. In one move, you can pick an index i where 0 <= i < nums.length and increment nums[i] by 1.Return the minimum number of moves to make every value in nums unique.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef min_removals_to_make_unique(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array, calculate the minimum number of elements to delete so that the elements in the array are not duplicate.\n    For example:\n        input: [3, 3, 1, 2, 2, 1]\n        output: 3\n\n    Args:\n        nums (List[int]): integer array of nums\n\n    Returns:\n        minimum number of moves to make every value in nums unique\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestMinRemovalsToMakeUnique(unittest.TestCase):\n    def test_basic_array(self):\n        \"\"\"Test with a basic array where multiple removals are needed.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([3, 3, 1, 2, 2, 1]), 3)\n\n    def test_all_identical(self):\n        \"\"\"Test an array where all elements are identical.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([4, 4, 4, 4]), 3)\n\n    def test_all_unique(self):\n        \"\"\"Test an array where all elements are already unique.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([1, 2, 3, 4]), 0)\n\n    def test_empty_array(self):\n        \"\"\"Test an empty array.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([]), 0)\n\n    def test_complex_case(self):\n        \"\"\"Test a more complex case with a larger array.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]), 6)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef min_removals_to_make_unique(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array, calculate the minimum number of elements to delete so that the elements in the array are not duplicate.\n    For example:\n        input: [3, 3, 1, 2, 2, 1]\n        output: 3\n\n    Args:\n        nums (List[int]): integer array of nums\n\n    Returns:\n        minimum number of moves to make every value in nums unique\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the minimum number of elements to delete so that the elements in the vector are not duplicate.\n *\n * Example:\n *      Input: {3, 3, 1, 2, 2, 1}\n *      Output: 3\n *\n * @param nums The vector of integers.\n * @return Minimum number of moves to make every value in nums unique.\n */\nint min_removals_to_make_unique(const std::vector<int>& nums) {\n", "test_code": "TEST_CASE(\"Test cases for min_removals_to_make_unique\", \"[min_removals_to_make_unique]\") {\n    SECTION(\"Test with a basic array where multiple removals are needed\") {\n        REQUIRE(min_removals_to_make_unique({3, 3, 1, 2, 2, 1}) == 3);\n    }\n\n    SECTION(\"Test an array where all elements are identical\") {\n        REQUIRE(min_removals_to_make_unique({4, 4, 4, 4}) == 3);\n    }\n\n    SECTION(\"Test an array where all elements are already unique\") {\n        REQUIRE(min_removals_to_make_unique({1, 2, 3, 4}) == 0);\n    }\n\n    SECTION(\"Test an empty array\") {\n        REQUIRE(min_removals_to_make_unique({}) == 0);\n    }\n\n    SECTION(\"Test a more complex case with a larger array\") {\n        REQUIRE(min_removals_to_make_unique({1, 2, 2, 3, 3, 3, 4, 4, 4, 4}) == 6);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the minimum number of elements to delete so that the elements in the vector are not duplicate.\n *\n * Example:\n *      Input: {3, 3, 1, 2, 2, 1}\n *      Output: 3\n *\n * @param nums The vector of integers.\n * @return Minimum number of moves to make every value in nums unique.\n */\nint min_removals_to_make_unique(const std::vector<int>& nums) {\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the minimum number of elements to delete so that the elements in the array are not duplicate.\n * \n * Example:\n *     Input: [3, 3, 1, 2, 2, 1]\n *     Output: 3\n * \n * @param nums The integer array.\n * @return The minimum number of moves to make every value in the array unique.\n */\npublic static int minRemovalsToMakeUnique(List<Integer> nums) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\n\npublic class Tester {\n\n    @Test\n    public void testBasicArray() {\n        // Test with a basic array where multiple removals are needed.\n        assertEquals(3, minRemovalsToMakeUnique(List.of(3, 3, 1, 2, 2, 1)));\n    }\n\n    @Test\n    public void testAllIdentical() {\n        // Test an array where all elements are identical.\n        assertEquals(3, minRemovalsToMakeUnique(List.of(4, 4, 4, 4)));\n    }\n\n    @Test\n    public void testAllUnique() {\n        // Test an array where all elements are already unique.\n        assertEquals(0, minRemovalsToMakeUnique(List.of(1, 2, 3, 4)));\n    }\n\n    @Test\n    public void testEmptyArray() {\n        // Test an empty array.\n        assertEquals(0, minRemovalsToMakeUnique(List.of()));\n    }\n\n    @Test\n    public void testComplexCase() {\n        // Test a more complex case with a larger array.\n        assertEquals(6, minRemovalsToMakeUnique(List.of(1, 2, 2, 3, 3, 3, 4, 4, 4, 4)));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the minimum number of elements to delete so that the elements in the array are not duplicate.\n * \n * Example:\n *     Input: [3, 3, 1, 2, 2, 1]\n *     Output: 3\n * \n * @param nums The integer array.\n * @return The minimum number of moves to make every value in the array unique.\n */\npublic static int minRemovalsToMakeUnique(List<Integer> nums) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 56, "code_type": "method", "original_language": "python", "file_path": "SoraTranslator\\afbf178ff30c1120d59bc2025e7a38e8b78127cd\\backend\\Integrators\\utils\\encoding_fix.py", "question_type": "Data processing and transformation", "summary": "find all the characters that can be represented in Shift-JIS, but not in GBK, and return them as an array", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef find_shiftjis_not_gbk() -> List:\n    \"\"\"\n    find all the characters that can be represented in Shift-JIS, but not in GBK, and return them as an array\n\n    Returns:\n        list: A list of characters that are unique to Shift-JIS, not encodable in GBK.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFindShiftJISNotGBK(unittest.TestCase):\n\n    def setUp(self):\n        # Pre-calculate the list once since it's computationally expensive\n        self.shiftjis_not_gbk = find_shiftjis_not_gbk()\n\n    def test_known_shiftjis_character_not_in_gbk(self):\n        # Test known characters (example values provided might not actually be in one and not the other; please adjust accordingly based on actual encoding tables)\n        known_shiftjis_only = '\u30f1'  # An example character, ensure this is correct as per your encodings\n        self.assertNotIn(known_shiftjis_only, self.shiftjis_not_gbk)\n\n    def test_character_in_both_encodings(self):\n        # Test characters known to be in both encodings\n        common_character = '\u6c34'  # Common in both, ensure accuracy\n        self.assertNotIn(common_character, self.shiftjis_not_gbk)\n\n    def test_character_in_neither_encoding(self):\n        # Character not typically found in either encoding\n        neither_encoding_char = '\\U0001F4A9'  # Emoji, not in basic Shift-JIS or GBK\n        self.assertNotIn(neither_encoding_char, self.shiftjis_not_gbk)\n\n    def test_bounds_of_bmp(self):\n        # Characters at the edge of the BMP should be checked\n        edge_of_bmp = '\\uffff'  # Last character in BMP\n        # Since this test.js is situational, we check based on the known state; may not be necessary\n        if edge_of_bmp in self.shiftjis_not_gbk:\n            self.assertIn(edge_of_bmp, self.shiftjis_not_gbk)\n        else:\n            self.assertNotIn(edge_of_bmp, self.shiftjis_not_gbk)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_shiftjis_not_gbk() -> List:\n    \"\"\"\n    find all the characters that can be represented in Shift-JIS, but not in GBK, and return them as an array\n\n    Returns:\n        list: A list of characters that are unique to Shift-JIS, not encodable in GBK.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds all the characters that can be represented in Shift-JIS, \n *        but not in GBK, and returns them as a vector.\n * \n * @return std::vector<wchar_t> A vector of characters that are unique to \n *         Shift-JIS and not encodable in GBK.\n */\nstd::vector<wchar_t> find_shiftjis_not_gbk() {}", "test_code": "TEST_CASE(\"TestFindShiftJISNotGBK\", \"[ShiftJISTest]\") {\n    // Pre-calculate the list once since it's computationally expensive\n    auto shiftjis_not_gbk = find_shiftjis_not_gbk();\n\n    SECTION(\"test_known_shiftjis_character_not_in_gbk\") {\n        // Test known characters (example values provided might not actually be in one and not the other; please adjust accordingly based on actual encoding tables)\n        wchar_t known_shiftjis_only = L'\u30f1';  // An example character, ensure this is correct as per your encodings\n        REQUIRE(std::find(shiftjis_not_gbk.begin(), shiftjis_not_gbk.end(), known_shiftjis_only) == shiftjis_not_gbk.end());\n    }\n\n    SECTION(\"test_character_in_both_encodings\") {\n        // Test characters known to be in both encodings\n        wchar_t common_character = L'\u6c34';  // Common in both, ensure accuracy\n        REQUIRE(std::find(shiftjis_not_gbk.begin(), shiftjis_not_gbk.end(), common_character) == shiftjis_not_gbk.end());\n    }\n\n    SECTION(\"test_character_in_neither_encoding\") {\n        // Character not typically found in either encoding\n        wchar_t neither_encoding_char = L'\\U0001F4A9';  // Emoji, not in basic Shift-JIS or GBK\n        REQUIRE(std::find(shiftjis_not_gbk.begin(), shiftjis_not_gbk.end(), neither_encoding_char) == shiftjis_not_gbk.end());\n    }\n\n    SECTION(\"test_bounds_of_bmp\") {\n        // Characters at the edge of the BMP should be checked\n        wchar_t edge_of_bmp = L'\\uffff';  // Last character in BMP\n        // Since this test is situational, we check based on the known state; may not be necessary\n        if (std::find(shiftjis_not_gbk.begin(), shiftjis_not_gbk.end(), edge_of_bmp) != shiftjis_not_gbk.end()) {\n            REQUIRE(std::find(shiftjis_not_gbk.begin(), shiftjis_not_gbk.end(), edge_of_bmp) != shiftjis_not_gbk.end());\n        } else {\n            REQUIRE(std::find(shiftjis_not_gbk.begin(), shiftjis_not_gbk.end(), edge_of_bmp) == shiftjis_not_gbk.end());\n        }\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds all the characters that can be represented in Shift-JIS, \n *        but not in GBK, and returns them as a vector.\n * \n * @return std::vector<wchar_t> A vector of characters that are unique to \n *         Shift-JIS and not encodable in GBK.\n */\nstd::vector<wchar_t> find_shiftjis_not_gbk() {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds all the characters that can be represented in Shift-JIS but not in GBK, and returns them as an array.\n *\n * @return An array of characters that are unique to Shift-JIS and not encodable in GBK.\n */\npublic static char[] findShiftJisNotGbk() {}", "test_code": "package org.real.temp;\n\nimport org.junit.Before; // JUnit 4 Before annotation\nimport org.junit.Test; // JUnit 4 Test annotation\nimport static org.junit.Assert.*; // JUnit 4 assertion methods\n\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.charset.CharsetEncoder;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Tester {\n\n    private char[] shiftjisNotGbk;\n\n    @Before\n    public void setUp() {\n        // Pre-calculate the list once since it's computationally expensive\n        shiftjisNotGbk = findShiftJisNotGbk();\n    }\n\n    @Test\n    public void testKnownShiftJISCharacterNotInGBK() {\n        // Test known characters (example values provided might not actually be in one and not the other; please adjust accordingly based on actual encoding tables)\n        char knownShiftJisOnly = '\u30f1';  // An example character, ensure this is correct as per your encodings\n        assertFalse(\"The character should not be in the list\", contains(shiftjisNotGbk, knownShiftJisOnly));\n    }\n\n    @Test\n    public void testCharacterInBothEncodings() {\n        // Test characters known to be in both encodings\n        char commonCharacter = '\u6c34';  // Common in both, ensure accuracy\n        assertFalse(\"The character should not be in the list\", contains(shiftjisNotGbk, commonCharacter));\n    }\n\n    @Test\n    public void testCharacterInNeitherEncoding() {\n        // Character not typically found in either encoding\n        char neitherEncodingChar = '\\u1F4A9';  // Emoji, not in basic Shift-JIS or GBK\n        assertFalse(\"The character should not be in the list\", contains(shiftjisNotGbk, neitherEncodingChar));\n    }\n\n    @Test\n    public void testBoundsOfBMP() {\n        // Characters at the edge of the BMP should be checked\n        char edgeOfBmp = '\\uFFFF';  // Last character in BMP\n        // Since this test is situational, we check based on the known state; may not be necessary\n        if (contains(shiftjisNotGbk, edgeOfBmp)) {\n            assertTrue(\"The character should be in the list\", contains(shiftjisNotGbk, edgeOfBmp));\n        } else {\n            assertFalse(\"The character should not be in the list\", contains(shiftjisNotGbk, edgeOfBmp));\n        }\n    }\n\n    // Dummy implementation for contains method\n    private boolean contains(char[] array, char value) {\n        for (char c : array) {\n            if (c == value) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Finds all the characters that can be represented in Shift-JIS but not in GBK, and returns them as an array.\n *\n * @return An array of characters that are unique to Shift-JIS and not encodable in GBK.\n */\npublic static char[] findShiftJisNotGbk() {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 57, "code_type": "method", "original_language": "python", "file_path": "Q-Tube\\7ad3d430b5eb2ef575c0c544abf1be3d89e07a47\\source\\png_to_icon.py", "question_type": "Machine learning and deep learning", "summary": "convert png images to ico files\n", "language_version_list": {"python": {"code_signature": "def convert_png_to_ico(png_file_path, ico_file_path, icon_sizes=[(32, 32)]):\n    \"\"\"\n    convert png images to ico files\n    Args:\n        png_file_path (str): Path to the source PNG image file.\n        ico_file_path (str): Path to save the ICO file.\n        icon_sizes (list): List of tuples specifying the sizes to include in the ICO file.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass TestConvertPngToIco(unittest.TestCase):\n    @patch('PIL.Image.open')\n    def test_single_icon_size(self, mock_open):\n        mock_image = mock_open.return_value.__enter__.return_value\n        convert_png_to_ico('source.png', 'output.ico', [(64, 64)])\n        mock_image.save.assert_called_with('output.ico', format='ICO', sizes=[(64, 64)])\n\n    @patch('PIL.Image.open')\n    def test_multiple_icon_sizes(self, mock_open):\n        mock_image = mock_open.return_value.__enter__.return_value\n        convert_png_to_ico('source.png', 'output.ico', [(16, 16), (32, 32), (64, 64)])\n        mock_image.save.assert_called_with('output.ico', format='ICO', sizes=[(16, 16), (32, 32), (64, 64)])\n\n    @patch('PIL.Image.open')\n    def test_default_icon_size(self, mock_open):\n        mock_image = mock_open.return_value.__enter__.return_value\n        convert_png_to_ico('source.png', 'output.ico')\n        mock_image.save.assert_called_with('output.ico', format='ICO', sizes=[(32, 32)])\n\n    @patch('PIL.Image.open')\n    def test_file_handling(self, mock_open):\n        mock_image = MagicMock()\n        mock_open.return_value.__enter__.return_value = mock_image\n        convert_png_to_ico('source.png', 'output.ico')\n        # Check if save was called correctly\n        mock_image.save.assert_called_once_with('output.ico', format='ICO', sizes=[(32, 32)])\n\n    @patch('PIL.Image.open')\n    def test_invalid_image_path(self, mock_open):\n        mock_open.side_effect = FileNotFoundError\n        with self.assertRaises(FileNotFoundError):\n            convert_png_to_ico('invalid.png', 'output.ico')\n", "prompt": "please write a python function , the function signature as below def convert_png_to_ico(png_file_path, ico_file_path, icon_sizes=[(32, 32)]):\n    \"\"\"\n    convert png images to ico files\n    Args:\n        png_file_path (str): Path to the source PNG image file.\n        ico_file_path (str): Path to save the ICO file.\n        icon_sizes (list): List of tuples specifying the sizes to include in the ICO file.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 58, "code_type": "method", "original_language": "python", "file_path": "python\\1af5d04c65ec5e38496d989b97e7c5833140a04d\\chooseNfromM.py", "question_type": "Data processing and transformation", "summary": "Calculate the probability that n red balls will be drawn when 15 balls are randomly returned from a jar containing x red balls and y blue balls", "language_version_list": {"python": {"code_signature": "def probability_of_red_balls(n: int, x: int, y: int) -> float:\n    \"\"\"\n    Calculate the probability that n red balls will be drawn when 15 balls are randomly returned from a jar containing x red balls and y blue balls.\n\n    Args:\n        n (int): Number of red balls to be drawn.\n        x (int): Number of red balls in the jar.\n        y (int): Number of blue balls in the jar.\n\n    Returns:\n        float: The probability of drawing exactly n red balls.\n    \"\"\"\n", "test_code": "import unittest\nfrom math import isclose\n\n\nclass TestProbabilityOfRedBalls(unittest.TestCase):\n\n    def test_half_red_balls(self):\n        # Scenario where half of the drawn balls are expected to be red\n        result = probability_of_red_balls(7, 10, 10)\n        expected_result = probability_of_red_balls(7, 10, 10)  # Calculate manually or from another tool\n        self.assertTrue(isclose(result, expected_result), \"Test with half red balls failed\")\n\n    def test_some_red_balls(self):\n        # Scenario with some red balls in the jar, expecting a few red draws\n        result = probability_of_red_balls(5, 5, 10)\n        expected_result = probability_of_red_balls(5, 5, 10)  # Calculate manually or from another tool\n        self.assertTrue(isclose(result, expected_result), \"Test with some red balls failed\")\n\n    def test_extreme_case(self):\n        # Extreme scenario where the probability is low for the chosen n\n        result = probability_of_red_balls(15, 1, 99)\n        expected_result = probability_of_red_balls(15, 1, 99)  # Calculate manually or from another tool\n        self.assertTrue(isclose(result, expected_result), \"Test with extreme case failed\")", "prompt": "please write a python function , the function signature as below def probability_of_red_balls(n: int, x: int, y: int) -> float:\n    \"\"\"\n    Calculate the probability that n red balls will be drawn when 15 balls are randomly returned from a jar containing x red balls and y blue balls.\n\n    Args:\n        n (int): Number of red balls to be drawn.\n        x (int): Number of red balls in the jar.\n        y (int): Number of blue balls in the jar.\n\n    Returns:\n        float: The probability of drawing exactly n red balls.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the probability that n red balls will be drawn when 15 balls are randomly drawn from a jar containing x red balls and y blue balls.\n *\n * @param n Number of red balls to be drawn.\n * @param x Number of red balls in the jar.\n * @param y Number of blue balls in the jar.\n * @return The probability of drawing exactly n red balls.\n */\ndouble probability_of_red_balls(int n, int x, int y) {}", "test_code": "bool isclose(double a, double b, double rel_tol = 1e-9, double abs_tol = 0.0) {\n    return std::abs(a - b) <= std::max(rel_tol * std::max(std::abs(a), std::abs(b)), abs_tol);\n}\n\n// Test suite for the probability_of_red_balls function\nTEST_CASE(\"Test probability_of_red_balls\", \"[probability_of_red_balls]\") {\n    SECTION(\"Test with half red balls\") {\n        // Scenario where half of the drawn balls are expected to be red\n        double result = probability_of_red_balls(7, 10, 10);\n        double expected_result = 0.0542635;  // Manually calculated or from another tool\n        REQUIRE(isclose(result, expected_result));\n    }\n\n    SECTION(\"Test with some red balls\") {\n        // Scenario with some red balls in the jar, expecting a few red draws\n        double result = probability_of_red_balls(5, 5, 10);\n        double expected_result = 0.00371398;  // Manually calculated or from another tool\n        REQUIRE(isclose(result, expected_result));\n    }\n\n    SECTION(\"Test with extreme case\") {\n        // Extreme scenario where the probability is low for the chosen n\n        double result = probability_of_red_balls(15, 1, 99);\n        double expected_result = 1.01168e-10;  // Manually calculated or from another tool\n        REQUIRE(isclose(result, expected_result));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the probability that n red balls will be drawn when 15 balls are randomly drawn from a jar containing x red balls and y blue balls.\n *\n * @param n Number of red balls to be drawn.\n * @param x Number of red balls in the jar.\n * @param y Number of blue balls in the jar.\n * @return The probability of drawing exactly n red balls.\n */\ndouble probability_of_red_balls(int n, int x, int y) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate the probability that n red balls will be drawn when 15 balls are randomly drawn from a jar containing x red balls and y blue balls.\n *\n * @param n The number of red balls to be drawn.\n * @param x The number of red balls in the jar.\n * @param y The number of blue balls in the jar.\n * @return The probability of drawing exactly n red balls.\n */\npublic static double probabilityOfRedBalls(int n, int x, int y) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; // JUnit 4 Test annotation\nimport static org.junit.Assert.assertTrue; // JUnit 4 assertion method\nimport static org.junit.Assert.assertEquals; // JUnit 4 assertion method\nimport static org.junit.Assert.fail; // JUnit 4 fail method\nimport org.real.temp.Answer.*;\npublic class Tester {\n\n    private static final double DELTA = 1e-15;\n\n    /**\n     * Test the probability of drawing half red balls.\n     */\n    @Test\n    public void testHalfRedBalls() {\n        // Scenario where half of the drawn balls are expected to be red\n        double result = probabilityOfRedBalls(7, 10, 10);\n        double expectedResult = 0.001376; // Replace with the actual expected result\n        assertTrue(\"Test with half red balls failed\", isClose(result, expectedResult, DELTA));\n    }\n\n    /**\n     * Test the probability of drawing some red balls.\n     */\n    @Test\n    public void testSomeRedBalls() {\n        // Scenario with some red balls in the jar, expecting a few red draws\n        double result = probabilityOfRedBalls(5, 5, 10);\n        double expectedResult = 0.02795; // Replace with the actual expected result\n        assertTrue(\"Test with some red balls failed\", isClose(result, expectedResult, DELTA));\n    }\n\n    /**\n     * Test the probability of drawing red balls in an extreme case.\n     */\n    @Test\n    public void testExtremeCase() {\n        // Extreme scenario where the probability is low for the chosen n\n        double result = probabilityOfRedBalls(15, 1, 99);\n        double expectedResult = 0.000001; // Replace with the actual expected result\n        assertTrue(\"Test with extreme case failed\", isClose(result, expectedResult, DELTA));\n    }\n\n    // Helper method to check if two doubles are close enough\n    private boolean isClose(double a, double b, double delta) {\n        return Math.abs(a - b) <= delta;\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Calculate the probability that n red balls will be drawn when 15 balls are randomly drawn from a jar containing x red balls and y blue balls.\n *\n * @param n The number of red balls to be drawn.\n * @param x The number of red balls in the jar.\n * @param y The number of blue balls in the jar.\n * @return The probability of drawing exactly n red balls.\n */\npublic static double probabilityOfRedBalls(int n, int x, int y) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 59, "code_type": "method", "original_language": "python", "file_path": "python\\1af5d04c65ec5e38496d989b97e7c5833140a04d\\chooseNfromM.py", "question_type": "Data processing and transformation", "summary": "calculate the probability that x balls will be randomly drawn from a jar containing n red balls and m blue balls, and all of them will be red balls\n", "language_version_list": {"python": {"code_signature": "def probability_red_balls(x: int, n: int, m: int) -> float:\n    \"\"\"\n    calculate the probability that x balls will be randomly drawn from a jar containing n red balls and m blue balls, and all of them will be red balls\n    Args:\n        x (int): Number of balls to draw.\n        n (int): Number of red balls in the jar.\n        m (int): Number of blue balls in the jar.\n\n    Returns:\n        The probability that all x drawn balls are red.\n    \"\"\"\n", "test_code": "import unittest\nfrom math import comb\n\n\nclass TestProbabilityRedBalls(unittest.TestCase):\n    def test_all_red(self):\n        # Case where all balls are red\n        self.assertEqual(probability_red_balls(5, 5, 0), 1)\n\n    def test_no_red(self):\n        # Case where no red balls are available\n        self.assertEqual(probability_red_balls(1, 0, 5), 0)\n\n    def test_typical_case(self):\n        # Typical scenario\n        self.assertAlmostEqual(probability_red_balls(2, 10, 5), comb(10, 2) / comb(15, 2))\n\n    def test_impossible_case(self):\n        # More balls requested than available\n        self.assertEqual(probability_red_balls(6, 5, 4), 0)\n\n    def test_high_combinations(self):\n        # Test with higher number of combinations\n        self.assertAlmostEqual(probability_red_balls(3, 20, 30), comb(20, 3) / comb(50, 3))", "prompt": "please write a python function , the function signature as below def probability_red_balls(x: int, n: int, m: int) -> float:\n    \"\"\"\n    calculate the probability that x balls will be randomly drawn from a jar containing n red balls and m blue balls, and all of them will be red balls\n    Args:\n        x (int): Number of balls to draw.\n        n (int): Number of red balls in the jar.\n        m (int): Number of blue balls in the jar.\n\n    Returns:\n        The probability that all x drawn balls are red.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the probability that x balls will be randomly drawn from a jar containing\n * n red balls and m blue balls, and all of them will be red balls.\n *\n * @param x Number of balls to draw.\n * @param n Number of red balls in the jar.\n * @param m Number of blue balls in the jar.\n *\n * @return The probability that all x drawn balls are red.\n */\ndouble probability_red_balls(int x, int n, int m) {}", "test_code": "TEST_CASE(\"Test Probability Red Balls\") {\n    SECTION(\"All balls are red\") {\n        REQUIRE(probability_red_balls(5, 5, 0) == Approx(1));\n    }\n\n    SECTION(\"No red balls are available\") {\n        REQUIRE(probability_red_balls(1, 0, 5) == Approx(0));\n    }\n\n    SECTION(\"Typical scenario\") {\n        REQUIRE(probability_red_balls(2, 10, 5) == Approx(static_cast<double>(binomial_coefficient(10, 2)) / binomial_coefficient(15, 2)));\n    }\n\n    SECTION(\"More balls requested than available\") {\n        REQUIRE(probability_red_balls(6, 5, 4) == Approx(0));\n    }\n\n    SECTION(\"High combinations\") {\n        REQUIRE(probability_red_balls(3, 20, 30) == Approx(static_cast<double>(binomial_coefficient(20, 3)) / binomial_coefficient(50, 3)));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the probability that x balls will be randomly drawn from a jar containing\n * n red balls and m blue balls, and all of them will be red balls.\n *\n * @param x Number of balls to draw.\n * @param n Number of red balls in the jar.\n * @param m Number of blue balls in the jar.\n *\n * @return The probability that all x drawn balls are red.\n */\ndouble probability_red_balls(int x, int n, int m) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the probability that x balls will be randomly drawn from a jar containing\n * n red balls and m blue balls, and all of them will be red balls.\n *\n * @param x Number of balls to draw.\n * @param n Number of red balls in the jar.\n * @param m Number of blue balls in the jar.\n * @return The probability that all x drawn balls are red.\n */\npublic static double probabilityRedBalls(int x, int n, int m) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\nimport java.math.BigInteger;\n\nimport static org.real.temp.Answer.*;\n\n/**\n * Test class for the probabilityRedBalls method.\n */\npublic class Tester {\n\n    /**\n     * Tests the case where all balls are red.\n     */\n    @Test\n    public void testAllRed() {\n        assertEquals(1.0, probabilityRedBalls(5, 5, 0), 0.0);\n    }\n\n    /**\n     * Tests the case where no red balls are available.\n     */\n    @Test\n    public void testNoRed() {\n        assertEquals(0.0, probabilityRedBalls(1, 0, 5), 0.0);\n    }\n\n    /**\n     * Tests a typical scenario.\n     */\n    @Test\n    public void testTypicalCase() {\n        double expected = comb(10, 2).doubleValue() / comb(15, 2).doubleValue();\n        assertEquals(expected, probabilityRedBalls(2, 10, 5), 0.0001);\n    }\n\n    /**\n     * Tests the case where more balls are requested than available.\n     */\n    @Test\n    public void testImpossibleCase() {\n        assertEquals(0.0, probabilityRedBalls(6, 5, 4), 0.0);\n    }\n\n    /**\n     * Tests the case with a higher number of combinations.\n     */\n    @Test\n    public void testHighCombinations() {\n        double expected = comb(20, 3).doubleValue() / comb(50, 3).doubleValue();\n        assertEquals(expected, probabilityRedBalls(3, 20, 30), 0.0001);\n    }\n\n    /**\n     * Calculates the number of combinations (n choose k).\n     *\n     * @param n The total number of items.\n     * @param k The number of items to choose.\n     * @return The number of combinations.\n     */\n    private BigInteger comb(int n, int k) {\n        BigInteger result = BigInteger.ONE;\n        for (int i = 0; i < k; i++) {\n            result = result.multiply(BigInteger.valueOf(n - i))\n                    .divide(BigInteger.valueOf(i + 1));\n        }\n        return result;\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Calculates the probability that x balls will be randomly drawn from a jar containing\n * n red balls and m blue balls, and all of them will be red balls.\n *\n * @param x Number of balls to draw.\n * @param n Number of red balls in the jar.\n * @param m Number of blue balls in the jar.\n * @return The probability that all x drawn balls are red.\n */\npublic static double probabilityRedBalls(int x, int n, int m) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 60, "code_type": "method", "original_language": "python", "file_path": "MTIProteinImputation\\cfadc49f01213a64443afa14da99c228a1ad8473\\src\\en\\in_patient\\common_df_cols.py", "question_type": "Data processing and transformation", "summary": "find the common columns of all csv files in a directory and return these column names as a list\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef get_common_columns_from_csvs(directory: str) -> List:\n    \"\"\"\n    find the common columns of all csv files in a directory and return these column names as a list\n    Args:\n        directory (str): directory path\n\n    Returns:\n        same column list\n    \"\"\"\n", "test_code": "import unittest\nimport pandas as pd\nimport os\n\n\nclass TestCommonColumns(unittest.TestCase):\n    def setUp(self):\n        # Set up a temporary directory\n        self.test_dir = \"test_dir\"\n        os.makedirs(self.test_dir, exist_ok=True)\n\n    def tearDown(self):\n        # Remove created files and directory after each test.js\n        for filename in os.listdir(self.test_dir):\n            os.remove(os.path.join(self.test_dir, filename))\n        os.rmdir(self.test_dir)\n\n    def test_all_same_columns(self):\n        # All CSV files have the same columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"A,B,C\\n4,5,6\"\n        data3 = \"A,B,C\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(set(get_common_columns_from_csvs(self.test_dir)), set(['C', 'B', 'A']))\n\n    def test_no_common_columns(self):\n        # No common columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"D,E,F\\n4,5,6\"\n        data3 = \"G,H,I\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(get_common_columns_from_csvs(self.test_dir), [])\n\n    def test_some_common_columns(self):\n        # Some common columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"B,C,D\\n4,5,6\"\n        data3 = \"C,D,E\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(get_common_columns_from_csvs(self.test_dir), ['C'])\n\n    def test_mixed_common_and_unique_columns(self):\n        # Mixed common and unique columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"B,C,D\\n4,5,6\"\n        data3 = \"B,C,E\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(set(get_common_columns_from_csvs(self.test_dir)), set(['B', 'C']))\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef get_common_columns_from_csvs(directory: str) -> List:\n    \"\"\"\n    find the common columns of all csv files in a directory and return these column names as a list\n    Args:\n        directory (str): directory path\n\n    Returns:\n        same column list\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Find the common columns of all CSV files in a directory and return these column names as a list.\n *\n * @param directory Directory path.\n * @return A vector containing the common column names.\n */\nstd::vector<std::string> find_common_columns(const std::string& directory) {}", "test_code": "TEST_CASE(\"Test common columns functionality\", \"[common-columns]\") {\n    // Set up a temporary directory\n    const std::string test_dir = \"test_dir\";\n    std::filesystem::create_directories(test_dir);\n\n    SECTION(\"All CSV files have the same columns\") {\n        const std::string data1 = \"A,B,C\\n1,2,3\";\n        const std::string data2 = \"A,B,C\\n4,5,6\";\n        const std::string data3 = \"A,B,C\\n7,8,9\";\n        const std::vector<std::string> filenames = {\"file1.csv\", \"file2.csv\", \"file3.csv\"};\n        const std::vector<std::string> datas = {data1, data2, data3};\n\n        for (size_t i = 0; i < filenames.size(); ++i) {\n            const std::string filepath = test_dir + \"/\" + filenames[i];\n            std::ofstream file(filepath);\n            file << datas[i];\n        }\n\n        REQUIRE(find_common_columns(test_dir) == std::vector<std::string>({\"A\", \"B\", \"C\"}));\n    }\n\n    SECTION(\"No common columns\") {\n        const std::string data1 = \"A,B,C\\n1,2,3\";\n        const std::string data2 = \"D,E,F\\n4,5,6\";\n        const std::string data3 = \"G,H,I\\n7,8,9\";\n        const std::vector<std::string> filenames = {\"file1.csv\", \"file2.csv\", \"file3.csv\"};\n        const std::vector<std::string> datas = {data1, data2, data3};\n\n        for (size_t i = 0; i < filenames.size(); ++i) {\n            const std::string filepath = test_dir + \"/\" + filenames[i];\n            std::ofstream file(filepath);\n            file << datas[i];\n        }\n\n        REQUIRE(find_common_columns(test_dir).empty());\n    }\n\n    SECTION(\"Some common columns\") {\n        const std::string data1 = \"A,B,C\\n1,2,3\";\n        const std::string data2 = \"B,C,D\\n4,5,6\";\n        const std::string data3 = \"C,D,E\\n7,8,9\";\n        const std::vector<std::string> filenames = {\"file1.csv\", \"file2.csv\", \"file3.csv\"};\n        const std::vector<std::string> datas = {data1, data2, data3};\n\n        for (size_t i = 0; i < filenames.size(); ++i) {\n            const std::string filepath = test_dir + \"/\" + filenames[i];\n            std::ofstream file(filepath);\n            file << datas[i];\n        }\n\n        REQUIRE(find_common_columns(test_dir) == std::vector<std::string>({\"C\"}));\n    }\n\n    SECTION(\"Mixed common and unique columns\") {\n        const std::string data1 = \"A,B,C\\n1,2,3\";\n        const std::string data2 = \"B,C,D\\n4,5,6\";\n        const std::string data3 = \"B,C,E\\n7,8,9\";\n        const std::vector<std::string> filenames = {\"file1.csv\", \"file2.csv\", \"file3.csv\"};\n        const std::vector<std::string> datas = {data1, data2, data3};\n\n        for (size_t i = 0; i < filenames.size(); ++i) {\n            const std::string filepath = test_dir + \"/\" + filenames[i];\n            std::ofstream file(filepath);\n            file << datas[i];\n        }\n\n        REQUIRE(find_common_columns(test_dir) == std::vector<std::string>({\"B\", \"C\"}));\n    }\n\n    // Clean up the temporary directory\n    for (const auto& entry : std::filesystem::directory_iterator(test_dir)) {\n        std::filesystem::remove(entry.path());\n    }\n    std::filesystem::remove_all(test_dir);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Find the common columns of all CSV files in a directory and return these column names as a list.\n *\n * @param directory Directory path.\n * @return A vector containing the common column names.\n */\nstd::vector<std::string> find_common_columns(const std::string& directory) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds the common columns of all CSV files in a directory and returns these column names as a list.\n *\n * @param directoryPath the path to the directory containing CSV files\n * @return a list of common column names\n */\npublic static List<String> findCommonColumns(String directoryPath) {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport static org.real.temp.Answer.*;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    private static final String TEST_DIR = \"test_dir\";\n\n    @Before\n    public void setUp() throws IOException {\n        // Set up a temporary directory\n        Files.createDirectories(new File(TEST_DIR).toPath());\n    }\n\n    @After\n    public void tearDown() throws IOException {\n        // Remove created files and directory after each test\n        File dir = new File(TEST_DIR);\n        File[] files = dir.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                file.delete();\n            }\n        }\n        dir.delete();\n    }\n\n    @Test\n    public void testAllSameColumns() throws IOException {\n        // All CSV files have the same columns\n        String data1 = \"A,B,C\\n1,2,3\";\n        String data2 = \"A,B,C\\n4,5,6\";\n        String data3 = \"A,B,C\\n7,8,9\";\n        List<String> filenames = Arrays.asList(\"file1.csv\", \"file2.csv\", \"file3.csv\");\n        List<String> datas = Arrays.asList(data1, data2, data3);\n\n        writeFiles(filenames, datas);\n\n        assertEquals(Arrays.asList(\"A\", \"B\", \"C\"), findCommonColumns(TEST_DIR));\n    }\n\n    @Test\n    public void testNoCommonColumns() throws IOException {\n        // No common columns\n        String data1 = \"A,B,C\\n1,2,3\";\n        String data2 = \"D,E,F\\n4,5,6\";\n        String data3 = \"G,H,I\\n7,8,9\";\n        List<String> filenames = Arrays.asList(\"file1.csv\", \"file2.csv\", \"file3.csv\");\n        List<String> datas = Arrays.asList(data1, data2, data3);\n\n        writeFiles(filenames, datas);\n\n        assertEquals(List.of(), findCommonColumns(TEST_DIR));\n    }\n\n    @Test\n    public void testSomeCommonColumns() throws IOException {\n        // Some common columns\n        String data1 = \"A,B,C\\n1,2,3\";\n        String data2 = \"B,C,D\\n4,5,6\";\n        String data3 = \"C,D,E\\n7,8,9\";\n        List<String> filenames = Arrays.asList(\"file1.csv\", \"file2.csv\", \"file3.csv\");\n        List<String> datas = Arrays.asList(data1, data2, data3);\n\n        writeFiles(filenames, datas);\n\n        assertEquals(List.of(\"C\"), findCommonColumns(TEST_DIR));\n    }\n\n    @Test\n    public void testMixedCommonAndUniqueColumns() throws IOException {\n        // Mixed common and unique columns\n        String data1 = \"A,B,C\\n1,2,3\";\n        String data2 = \"B,C,D\\n4,5,6\";\n        String data3 = \"B,C,E\\n7,8,9\";\n        List<String> filenames = Arrays.asList(\"file1.csv\", \"file2.csv\", \"file3.csv\");\n        List<String> datas = Arrays.asList(data1, data2, data3);\n\n        writeFiles(filenames, datas);\n\n        assertEquals(Arrays.asList(\"B\", \"C\"), findCommonColumns(TEST_DIR));\n    }\n\n    private void writeFiles(List<String> filenames, List<String> datas) throws IOException {\n        for (int i = 0; i < filenames.size(); i++) {\n            String filename = filenames.get(i);\n            String data = datas.get(i);\n            File file = new File(TEST_DIR, filename);\n            try (FileWriter writer = new FileWriter(file)) {\n                writer.write(data);\n            }\n        }\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Finds the common columns of all CSV files in a directory and returns these column names as a list.\n *\n * @param directoryPath the path to the directory containing CSV files\n * @return a list of common column names\n */\npublic static List<String> findCommonColumns(String directoryPath) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 62, "code_type": "class", "original_language": "python", "file_path": "cse-20312-sp24-examples\\310603a99881acc9924cb3b3a7b33e0f198a8e1b\\lecture39\\bst_chatgpt.py", "question_type": "Algorithm and data structure", "summary": "implement the tree in the data structure and implement its three traversal methods\n", "language_version_list": {"python": {"code_signature": "class TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\n\nclass BinaryTree:\n    \"\"\"\n    implement the tree in the question structure and implement its three traversal methods\n    \"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        pass\n\n    def _insert(self, node, key):\n        pass\n\n    def inorder_traversal(self):\n        pass\n\n    def _inorder_traversal(self, node, result):\n        pass\n\n    def preorder_traversal(self):\n        pass\n\n    def _preorder_traversal(self, node, result):\n        pass\n\n    def postorder_traversal(self):\n        pass\n\n    def _postorder_traversal(self, node, result):\n        pass\n", "test_code": "import unittest\n\n\nclass TestBinaryTree(unittest.TestCase):\n\n    def test_empty_tree(self):\n        bt = BinaryTree()\n        self.assertEqual(bt.inorder_traversal(), [])\n        self.assertEqual(bt.preorder_traversal(), [])\n        self.assertEqual(bt.postorder_traversal(), [])\n\n    def test_single_node_tree(self):\n        bt = BinaryTree()\n        bt.insert(10)\n        self.assertEqual(bt.inorder_traversal(), [10])\n        self.assertEqual(bt.preorder_traversal(), [10])\n        self.assertEqual(bt.postorder_traversal(), [10])\n\n    def test_balanced_tree(self):\n        bt = BinaryTree()\n        elements = [8, 3, 10, 1, 6, 9, 14]\n        for elem in elements:\n            bt.insert(elem)\n        self.assertEqual(bt.inorder_traversal(), [1, 3, 6, 8, 9, 10, 14])\n        self.assertEqual(bt.preorder_traversal(), [8, 3, 1, 6, 10, 9, 14])\n        self.assertEqual(bt.postorder_traversal(), [1, 6, 3, 9, 14, 10, 8])\n\n    def test_left_heavy_tree(self):\n        bt = BinaryTree()\n        for i in range(10, 0, -1):  # Inserts 10, 9, ..., 1\n            bt.insert(i)\n        self.assertEqual(bt.inorder_traversal(), [i for i in range(1, 11)])\n        self.assertEqual(bt.preorder_traversal(), [10-i for i in range(10)])\n        self.assertEqual(bt.postorder_traversal(), [i for i in range(1, 11)])\n\n    def test_right_heavy_tree(self):\n        bt = BinaryTree()\n        for i in range(1, 11):  # Inserts 1, 2, ..., 10\n            bt.insert(i)\n        self.assertEqual(bt.inorder_traversal(), [i for i in range(1, 11)])\n        self.assertEqual(bt.preorder_traversal(), [i for i in range(1, 11)])\n        self.assertEqual(bt.postorder_traversal(), [i for i in range(10, 0, -1)])", "prompt": "please write a python class , the class signature as below class TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\n\nclass BinaryTree:\n    \"\"\"\n    implement the tree in the question structure and implement its three traversal methods\n    \"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        pass\n\n    def _insert(self, node, key):\n        pass\n\n    def inorder_traversal(self):\n        pass\n\n    def _inorder_traversal(self, node, result):\n        pass\n\n    def preorder_traversal(self):\n        pass\n\n    def _preorder_traversal(self, node, result):\n        pass\n\n    def postorder_traversal(self):\n        pass\n\n    def _postorder_traversal(self, node, result):\n        pass\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "// TreeNode class represents a node in the binary tree.\nclass TreeNode {\npublic:\n    // Constructor initializes a new TreeNode with the given key.\n    TreeNode(int key) : val(key), left(nullptr), right(nullptr) {}\n\n    // Pointers to the left and right child nodes.\n    TreeNode* left;\n    TreeNode* right;\n\n    // Value stored in the node.\n    int val;\n};\n\n// BinaryTree class implements a binary tree with insertion and traversal methods.\nclass BinaryTree {\npublic:\n    // Constructor initializes the root of the binary tree to null.\n    BinaryTree() : root(nullptr) {}\n\n    // Inserts a new node with the given key into the binary tree.\n    void insert(int key);\n\nprivate:\n    // Helper function to insert a new node with the given key.\n    void _insert(TreeNode* node, int key);\n\npublic:\n    // Performs an inorder traversal of the binary tree and returns the result.\n    std::vector<int> inorder_traversal();\n\nprivate:\n    // Helper function to perform an inorder traversal.\n    void _inorder_traversal(TreeNode* node, std::vector<int>& result);\n\npublic:\n    // Performs a preorder traversal of the binary tree and returns the result.\n    std::vector<int> preorder_traversal();\n\nprivate:\n    // Helper function to perform a preorder traversal.\n    void _preorder_traversal(TreeNode* node, std::vector<int>& result);\n\npublic:\n    // Performs a postorder traversal of the binary tree and returns the result.\n    std::vector<int> postorder_traversal();\n\nprivate:\n    // Helper function to perform a postorder traversal.\n    void _postorder_traversal(TreeNode* node, std::vector<int>& result);\n\n    // Pointer to the root of the binary tree.\n    TreeNode* root;\n};", "test_code": "// Test cases using Catch2\nTEST_CASE(\"Test empty tree\", \"[BinaryTree]\") {\n    BinaryTree bt;\n    REQUIRE(bt.inorder_traversal() == std::vector<int>());\n    REQUIRE(bt.preorder_traversal() == std::vector<int>());\n    REQUIRE(bt.postorder_traversal() == std::vector<int>());\n}\n\nTEST_CASE(\"Test single node tree\", \"[BinaryTree]\") {\n    BinaryTree bt;\n    bt.insert(10);\n    REQUIRE(bt.inorder_traversal() == std::vector<int>({10}));\n    REQUIRE(bt.preorder_traversal() == std::vector<int>({10}));\n    REQUIRE(bt.postorder_traversal() == std::vector<int>({10}));\n}\n\nTEST_CASE(\"Test balanced tree\", \"[BinaryTree]\") {\n    BinaryTree bt;\n    std::vector<int> elements = {8, 3, 10, 1, 6, 9, 14};\n    for (int elem : elements) {\n        bt.insert(elem);\n    }\n    REQUIRE(bt.inorder_traversal() == std::vector<int>({1, 3, 6, 8, 9, 10, 14}));\n    REQUIRE(bt.preorder_traversal() == std::vector<int>({8, 3, 1, 6, 10, 9, 14}));\n    REQUIRE(bt.postorder_traversal() == std::vector<int>({1, 6, 3, 9, 14, 10, 8}));\n}\n\nTEST_CASE(\"Test left-heavy tree\", \"[BinaryTree]\") {\n    BinaryTree bt;\n    for (int i = 10; i >= 1; --i) {\n        bt.insert(i);\n    }\n    REQUIRE(bt.inorder_traversal() == std::vector<int>({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}));\n    REQUIRE(bt.preorder_traversal() == std::vector<int>({10, 9, 8, 7, 6, 5, 4, 3, 2, 1}));\n    REQUIRE(bt.postorder_traversal() == std::vector<int>({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}));\n}\n\nTEST_CASE(\"Test right-heavy tree\", \"[BinaryTree]\") {\n    BinaryTree bt;\n    for (int i = 1; i <= 10; ++i) {\n        bt.insert(i);\n    }\n    REQUIRE(bt.inorder_traversal() == std::vector<int>({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}));\n    REQUIRE(bt.preorder_traversal() == std::vector<int>({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}));\n    REQUIRE(bt.postorder_traversal() == std::vector<int>({10, 9, 8, 7, 6, 5, 4, 3, 2, 1}));\n}", "prompt": "please write a cpp class , the class signature as below // TreeNode class represents a node in the binary tree.\nclass TreeNode {\npublic:\n    // Constructor initializes a new TreeNode with the given key.\n    TreeNode(int key) : val(key), left(nullptr), right(nullptr) {}\n\n    // Pointers to the left and right child nodes.\n    TreeNode* left;\n    TreeNode* right;\n\n    // Value stored in the node.\n    int val;\n};\n\n// BinaryTree class implements a binary tree with insertion and traversal methods.\nclass BinaryTree {\npublic:\n    // Constructor initializes the root of the binary tree to null.\n    BinaryTree() : root(nullptr) {}\n\n    // Inserts a new node with the given key into the binary tree.\n    void insert(int key);\n\nprivate:\n    // Helper function to insert a new node with the given key.\n    void _insert(TreeNode* node, int key);\n\npublic:\n    // Performs an inorder traversal of the binary tree and returns the result.\n    std::vector<int> inorder_traversal();\n\nprivate:\n    // Helper function to perform an inorder traversal.\n    void _inorder_traversal(TreeNode* node, std::vector<int>& result);\n\npublic:\n    // Performs a preorder traversal of the binary tree and returns the result.\n    std::vector<int> preorder_traversal();\n\nprivate:\n    // Helper function to perform a preorder traversal.\n    void _preorder_traversal(TreeNode* node, std::vector<int>& result);\n\npublic:\n    // Performs a postorder traversal of the binary tree and returns the result.\n    std::vector<int> postorder_traversal();\n\nprivate:\n    // Helper function to perform a postorder traversal.\n    void _postorder_traversal(TreeNode* node, std::vector<int>& result);\n\n    // Pointer to the root of the binary tree.\n    TreeNode* root;\n};", "addition_info": ""}, "java": {"code_signature": "static class TreeNode {\n    TreeNode left;\n    TreeNode right;\n    int val;\n\n    public TreeNode(int key) {\n        this.left = null;\n        this.right = null;\n        this.val = key;\n    }\n}\n\nstatic class BinaryTree {\n    private TreeNode root;\n\n    public BinaryTree() {\n        this.root = null;\n    }\n\n    public void insert(int key) {\n\n    }\n\n    private void insertRecursive(TreeNode node, int key) {\n\n    }\n\n    public int[] inorderTraversal() {\n    }\n\n    private java.util.List<Integer> inorderTraversalRecursive(TreeNode node, java.util.List<Integer> result) {\n\n    }\n\n    public int[] preorderTraversal() {\n    }\n\n    private java.util.List<Integer> preorderTraversalRecursive(TreeNode node, java.util.List<Integer> result) {\n\n    }\n\n    public int[] postorderTraversal() {\n    }\n\n    private java.util.List<Integer> postorderTraversalRecursive(TreeNode node, java.util.List<Integer> result) {\n\n    }\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.real.temp.Answer.*;\n/**\n * Test class for BinaryTree operations.\n */\npublic class Tester {\n\n    @Test\n    public void testEmptyTree() {\n        BinaryTree bt = new BinaryTree();\n        assertArrayEquals(new int[]{}, bt.inorderTraversal());\n        assertArrayEquals(new int[]{}, bt.preorderTraversal());\n        assertArrayEquals(new int[]{}, bt.postorderTraversal());\n    }\n\n    @Test\n    public void testSingleNodeTree() {\n        BinaryTree bt = new BinaryTree();\n        bt.insert(10);\n        assertArrayEquals(new int[]{10}, bt.inorderTraversal());\n        assertArrayEquals(new int[]{10}, bt.preorderTraversal());\n        assertArrayEquals(new int[]{10}, bt.postorderTraversal());\n    }\n\n    @Test\n    public void testBalancedTree() {\n        BinaryTree bt = new BinaryTree();\n        int[] elements = {8, 3, 10, 1, 6, 9, 14};\n        for (int elem : elements) {\n            bt.insert(elem);\n        }\n        assertArrayEquals(new int[]{1, 3, 6, 8, 9, 10, 14}, bt.inorderTraversal());\n        assertArrayEquals(new int[]{8, 3, 1, 6, 10, 9, 14}, bt.preorderTraversal());\n        assertArrayEquals(new int[]{1, 6, 3, 9, 14, 10, 8}, bt.postorderTraversal());\n    }\n\n    @Test\n    public void testLeftHeavyTree() {\n        BinaryTree bt = new BinaryTree();\n        for (int i = 10; i > 0; i--) {\n            bt.insert(i);\n        }\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, bt.inorderTraversal());\n        assertArrayEquals(new int[]{10, 9, 8, 7, 6, 5, 4, 3, 2, 1}, bt.preorderTraversal());\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, bt.postorderTraversal());\n    }\n\n    @Test\n    public void testRightHeavyTree() {\n        BinaryTree bt = new BinaryTree();\n        for (int i = 1; i <= 10; i++) {\n            bt.insert(i);\n        }\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, bt.inorderTraversal());\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, bt.preorderTraversal());\n        assertArrayEquals(new int[]{10, 9, 8, 7, 6, 5, 4, 3, 2, 1}, bt.postorderTraversal());\n    }\n}", "prompt": "please write a java class , the function signature as below static class TreeNode {\n    TreeNode left;\n    TreeNode right;\n    int val;\n\n    public TreeNode(int key) {\n        this.left = null;\n        this.right = null;\n        this.val = key;\n    }\n}\n\nstatic class BinaryTree {\n    private TreeNode root;\n\n    public BinaryTree() {\n        this.root = null;\n    }\n\n    public void insert(int key) {\n\n    }\n\n    private void insertRecursive(TreeNode node, int key) {\n\n    }\n\n    public int[] inorderTraversal() {\n    }\n\n    private java.util.List<Integer> inorderTraversalRecursive(TreeNode node, java.util.List<Integer> result) {\n\n    }\n\n    public int[] preorderTraversal() {\n    }\n\n    private java.util.List<Integer> preorderTraversalRecursive(TreeNode node, java.util.List<Integer> result) {\n\n    }\n\n    public int[] postorderTraversal() {\n    }\n\n    private java.util.List<Integer> postorderTraversalRecursive(TreeNode node, java.util.List<Integer> result) {\n\n    }\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 63, "code_type": "method", "original_language": "python", "file_path": "prompt-optimizer\\ea72ca56973559ad5d37b38da96caa22cfb2310d\\evaluations\\utils.py\n", "question_type": "Data processing and transformation", "summary": "convert a DataFrame object to a table in markdown format", "language_version_list": {"python": {"code_signature": "import pandas as pd\n\n\ndef convert_dataframe_to_markdown(df: pd.DataFrame, md_path: str) -> str:\n    \"\"\"\n    convert a DataFrame object to a table in markdown format\n    For example:\n        input: dataframe {'Name': ['Alice', 'Bob'], 'Age': [25, 30]}\n        output: | Name | Age |\\n| --- | --- |\\n| Alice | 25 |\\n| Bob | 30 |\\n\n\n    Args:\n        df (DataFrame): DataFrame type question\n        md_path (str): output md file path\n\n    Returns:\n        markdown file content str\n    \"\"\"\n", "test_code": "import unittest\n=import pandas as pd\n\n\nclass TestDataframeToMarkdown(unittest.TestCase):\n    def setUp(self):\n        # Create a sample DataFrame\n        self.data = {'Name': ['Alice', 'Bob'], 'Age': [25, 30]}\n        self.df = pd.DataFrame(self.data)\n\n    def test_df_to_str(self):\n        # Test that the function writes the correct markdown to a file\n        expected_markdown = \"| Name   |   Age |\\n|:-------|------:|\\n| Alice  |    25 |\\n| Bob    |    30 |\"\n        result = convert_dataframe_to_markdown(self.df, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_empty_dataframe(self):\n        # Test how the function handles an empty DataFrame\n        df_empty = pd.DataFrame()\n        expected_markdown = \"\"\n        result = convert_dataframe_to_markdown(df_empty, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_single_row_dataframe(self):\n        # Test with a DataFrame that contains only one row\n        df_single_row = pd.DataFrame({'Name': ['Alice'], 'Age': [30]})\n        expected_markdown = \"| Name   |   Age |\\n|:-------|------:|\\n| Alice  |    30 |\"\n        result = convert_dataframe_to_markdown(df_single_row, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_non_string_columns(self):\n        # Test with non-string question types in the DataFrame\n        df_non_string = pd.DataFrame({'Name': ['Alice', 'Bob'], 'Age': [25, 30], 'Height': [5.5, 6.0]})\n        expected_markdown = ('| Name   |   Age |   Height |\\n'\n                             '|:-------|------:|---------:|\\n'\n                             '| Alice  |    25 |      5.5 |\\n'\n                             '| Bob    |    30 |      6   |')\n        result = convert_dataframe_to_markdown(df_non_string, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_special_characters(self):\n        # Test handling of special characters in DataFrame\n        df_special_chars = pd.DataFrame(\n            {'Name': ['Alice', 'Bob'], 'Comments': ['Good@Work!', 'Excellent & Commendable']})\n        expected_markdown = ('| Name   | Comments                |\\n'\n                             '|:-------|:------------------------|\\n'\n                             '| Alice  | Good@Work!              |\\n'\n                             '| Bob    | Excellent & Commendable |')\n        result = convert_dataframe_to_markdown(df_special_chars, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n", "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef convert_dataframe_to_markdown(df: pd.DataFrame, md_path: str) -> str:\n    \"\"\"\n    convert a DataFrame object to a table in markdown format\n    For example:\n        input: dataframe {'Name': ['Alice', 'Bob'], 'Age': [25, 30]}\n        output: | Name | Age |\\n| --- | --- |\\n| Alice | 25 |\\n| Bob | 30 |\\n\n\n    Args:\n        df (DataFrame): DataFrame type question\n        md_path (str): output md file path\n\n    Returns:\n        markdown file content str\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 64, "code_type": "method", "original_language": "python", "file_path": "TRGB-BikeComputer\\2537af5d089f764d74269c04410485827529af7b\\Tools\\csv2influx.py", "question_type": "Data processing and transformation", "summary": "Converts the contents of a csv file into an SQL insert statement with a table name with the suffix removed", "language_version_list": {"python": {"code_signature": "import csv\nimport os\n\n\ndef csv_to_sql_insert(csv_file_path: str) -> str:\n    \"\"\"\n    Converts the contents of a csv file into an SQL insert statement with a table name with the suffix removed.\n\n    Args:\n        csv_file_path (str): csv file path\n\n    Returns:\n        str: parsed sql str\n    \"\"\"\n", "test_code": "import unittest\nimport os\n\n\nclass TestCsvToSqlInsert(unittest.TestCase):\n\n    def setUp(self):\n        # Create sample CSV files for testing\n        self.test_files = {\n            'test1.csv': 'id,name,age\\n1,Alice,30\\n2,Bob,25',\n            'test2.csv': 'product_id,product_name,price\\n101,Widget,9.99\\n102,Gadget,12.49',\n            'test3.csv': 'user_id,email\\n3,test@example.com\\n4,user@domain.com',\n            'test4.csv': 'order_id,order_date,total\\n1001,2024-09-01,59.99',\n            'test5.csv': 'quote_id,quote\\n1,\"It\\'s a beautiful day.\"\\n2,\"She said, \"\"Hello!\"\"\"'\n        }\n        # Create the files on disk\n        for filename, content in self.test_files.items():\n            with open(filename, 'w') as f:\n                f.write(content)\n\n    def tearDown(self):\n        # Remove the test files after tests\n        for filename in self.test_files:\n            os.remove(filename)\n\n    def test_simple_csv(self):\n        expected_sql = (\n            \"INSERT INTO test1 (id, name, age) VALUES ('1', 'Alice', '30');\\n\"\n            \"INSERT INTO test1 (id, name, age) VALUES ('2', 'Bob', '25');\"\n        )\n        result = csv_to_sql_insert('test1.csv')\n        self.assertEqual(result, expected_sql)\n\n    def test_product_csv(self):\n        expected_sql = (\n            \"INSERT INTO test2 (product_id, product_name, price) VALUES ('101', 'Widget', '9.99');\\n\"\n            \"INSERT INTO test2 (product_id, product_name, price) VALUES ('102', 'Gadget', '12.49');\"\n        )\n        result = csv_to_sql_insert('test2.csv')\n        self.assertEqual(result, expected_sql)\n\n    def test_email_csv(self):\n        expected_sql = (\n            \"INSERT INTO test3 (user_id, email) VALUES ('3', 'test@example.com');\\n\"\n            \"INSERT INTO test3 (user_id, email) VALUES ('4', 'user@domain.com');\"\n        )\n        result = csv_to_sql_insert('test3.csv')\n        self.assertEqual(result, expected_sql)\n\n    def test_date_and_decimal_csv(self):\n        expected_sql = (\n            \"INSERT INTO test4 (order_id, order_date, total) VALUES ('1001', '2024-09-01', '59.99');\"\n        )\n        result = csv_to_sql_insert('test4.csv')\n        self.assertEqual(result, expected_sql)", "prompt": "please write a python function , the function signature as below import csv\nimport os\n\n\ndef csv_to_sql_insert(csv_file_path: str) -> str:\n    \"\"\"\n    Converts the contents of a csv file into an SQL insert statement with a table name with the suffix removed.\n\n    Args:\n        csv_file_path (str): csv file path\n\n    Returns:\n        str: parsed sql str\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts the contents of a CSV file into an SQL insert statement with the table name derived from the file name.\n *\n * @param csv_file_path The path to the CSV file.\n * @return A string containing the SQL insert statements.\n */\nstd::string csv_to_sql_insert(const std::string& csv_file_path) {}", "test_code": "TEST_CASE(\"TestCsvToSqlInsert\", \"[csv_to_sql_insert]\") {\n    // Create sample CSV files for testing\n    std::map<std::string, std::string> test_files = {\n        {\"test1.csv\", \"id,name,age\\n1,Alice,30\\n2,Bob,25\"},\n        {\"test2.csv\", \"product_id,product_name,price\\n101,Widget,9.99\\n102,Gadget,12.49\"},\n        {\"test3.csv\", \"user_id,email\\n3,test@example.com\\n4,user@domain.com\"},\n        {\"test4.csv\", \"order_id,order_date,total\\n1001,2024-09-01,59.99\"},\n        {\"test5.csv\", \"quote_id,quote\\n1,\\\"It's a beautiful day.\\\"\\n2,\\\"She said, \\\"\\\"Hello!\\\"\\\"\\\"\"}\n    };\n\n    // Create the files on disk\n    for (const auto& [filename, content] : test_files) {\n        std::ofstream file(filename);\n        file << content;\n        file.close();\n    }\n\n    SECTION(\"test_simple_csv\") {\n        std::string expected_sql = (\n            \"INSERT INTO test1 (id, name, age) VALUES ('1', 'Alice', '30');\\n\"\n            \"INSERT INTO test1 (id, name, age) VALUES ('2', 'Bob', '25');\"\n        );\n        std::string result = csv_to_sql_insert(\"test1.csv\");\n        REQUIRE(result == expected_sql);\n    }\n\n    SECTION(\"test_product_csv\") {\n        std::string expected_sql = (\n            \"INSERT INTO test2 (product_id, product_name, price) VALUES ('101', 'Widget', '9.99');\\n\"\n            \"INSERT INTO test2 (product_id, product_name, price) VALUES ('102', 'Gadget', '12.49');\"\n        );\n        std::string result = csv_to_sql_insert(\"test2.csv\");\n        REQUIRE(result == expected_sql);\n    }\n\n    SECTION(\"test_email_csv\") {\n        std::string expected_sql = (\n            \"INSERT INTO test3 (user_id, email) VALUES ('3', 'test@example.com');\\n\"\n            \"INSERT INTO test3 (user_id, email) VALUES ('4', 'user@domain.com');\"\n        );\n        std::string result = csv_to_sql_insert(\"test3.csv\");\n        REQUIRE(result == expected_sql);\n    }\n\n    SECTION(\"test_date_and_decimal_csv\") {\n        std::string expected_sql = (\n            \"INSERT INTO test4 (order_id, order_date, total) VALUES ('1001', '2024-09-01', '59.99');\"\n        );\n        std::string result = csv_to_sql_insert(\"test4.csv\");\n        REQUIRE(result == expected_sql);\n    }\n\n    // Remove the test files after tests\n    for (const auto& filename : test_files) {\n        fs::remove(filename.first);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts the contents of a CSV file into an SQL insert statement with the table name derived from the file name.\n *\n * @param csv_file_path The path to the CSV file.\n * @return A string containing the SQL insert statements.\n */\nstd::string csv_to_sql_insert(const std::string& csv_file_path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts the contents of a CSV file into an SQL insert statement with the table name derived from the file name.\n *\n * @param csvFilePath the path to the CSV file\n * @return a string containing the SQL insert statements\n */\npublic static String csvToSqlInsert(String csvFilePath) {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    private Map<String, String> testFiles = new HashMap<String, String>() {{\n        put(\"test1.csv\", \"id,name,age\\n1,Alice,30\\n2,Bob,25\");\n        put(\"test2.csv\", \"product_id,product_name,price\\n101,Widget,9.99\\n102,Gadget,12.49\");\n        put(\"test3.csv\", \"user_id,email\\n3,test@example.com\\n4,user@domain.com\");\n        put(\"test4.csv\", \"order_id,order_date,total\\n1001,2024-09-01,59.99\");\n        put(\"test5.csv\", \"quote_id,quote\\n1,\\\"It's a beautiful day.\\\"\\n2,\\\"She said, \\\"\\\"Hello!\\\"\\\"\\\"\");\n    }};\n\n    private Path tempDir;\n\n    @Before\n    public void setUp() throws IOException {\n        // Create a temporary directory\n        tempDir = Files.createTempDirectory(\"tempDir\");\n\n        // Create the sample CSV files in the temporary directory\n        for (Map.Entry<String, String> entry : testFiles.entrySet()) {\n            File file = tempDir.resolve(entry.getKey()).toFile();\n            try (FileWriter writer = new FileWriter(file)) {\n                writer.write(entry.getValue());\n            }\n        }\n    }\n\n    @After\n    public void tearDown() throws IOException {\n        // Delete the temporary directory and its contents\n        Files.walk(tempDir)\n                .sorted((path1, path2) -> path2.compareTo(path1)) // Sort in reverse order to delete files before directories\n                .map(Path::toFile)\n                .forEach(File::delete);\n    }\n\n    @Test\n    public void testSimpleCsv() throws IOException {\n        String expectedSql = \"INSERT INTO test1 (id, name, age) VALUES ('1', 'Alice', '30');\\n\"\n                + \"INSERT INTO test1 (id, name, age) VALUES ('2', 'Bob', '25');\";\n\n        String result = csvToSqlInsert(tempDir.resolve(\"test1.csv\").toString());\n        assertEquals(expectedSql, result);\n    }\n\n    @Test\n    public void testProductCsv() throws IOException {\n        String expectedSql = \"INSERT INTO test2 (product_id, product_name, price) VALUES ('101', 'Widget', '9.99');\\n\"\n                + \"INSERT INTO test2 (product_id, product_name, price) VALUES ('102', 'Gadget', '12.49');\";\n\n        String result = csvToSqlInsert(tempDir.resolve(\"test2.csv\").toString());\n        assertEquals(expectedSql, result);\n    }\n\n    @Test\n    public void testEmailCsv() throws IOException {\n        String expectedSql = \"INSERT INTO test3 (user_id, email) VALUES ('3', 'test@example.com');\\n\"\n                + \"INSERT INTO test3 (user_id, email) VALUES ('4', 'user@domain.com');\";\n\n        String result = csvToSqlInsert(tempDir.resolve(\"test3.csv\").toString());\n        assertEquals(expectedSql, result);\n    }\n\n    @Test\n    public void testDateAndDecimalCsv() throws IOException {\n        String expectedSql = \"INSERT INTO 'test4' (order_id, order_date, total) VALUES ('1001', '2024-09-01', '59.99');\";\n\n        String result = csvToSqlInsert(tempDir.resolve(\"test4.csv\").toString());\n        assertEquals(expectedSql, result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts the contents of a CSV file into an SQL insert statement with the table name derived from the file name.\n *\n * @param csvFilePath the path to the CSV file\n * @return a string containing the SQL insert statements\n */\npublic static String csvToSqlInsert(String csvFilePath) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 65, "code_type": "method", "original_language": "python", "file_path": "infra-config\\6353168dc698d8726ea75570000de7fe1f56674c\\ci\\ip_address_duplicates.py", "question_type": "File operations and I/O operation", "summary": "Find duplicate IPs in the given IP list and exclude IPs specified to ignore\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef find_duplicates_excluding_ips(ip_list: List[str], ignore_list: List[str]) -> List[str]:\n    \"\"\"\n    Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n\n    Args:\n        ip_list (List[str]): List of IP addresses\n        ignore_list (List[str]): List of IP addresses to ignor\n\n    Returns:\n        List[str]: A list of duplicate IPs excluding those in the ignore list.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFindDuplicateIPs(unittest.TestCase):\n\n    def test_basic_duplicates(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.1\"]\n        ignore_list = []\n        self.assertEqual(find_duplicates_excluding_ips(ip_list, ignore_list), [\"192.168.1.1\"])\n\n    def test_ignored_duplicates(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.2\"]\n        ignore_list = [\"192.168.1.1\"]\n        self.assertEqual(find_duplicates_excluding_ips(ip_list, ignore_list), [])\n\n    def test_no_duplicates(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.3\"]\n        ignore_list = []\n        self.assertEqual(find_duplicates_excluding_ips(ip_list, ignore_list), [])\n\n    def test_mixed_duplicates(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.1\", \"10.0.0.1\", \"192.168.1.2\"]\n        ignore_list = [\"192.168.1.2\"]\n        self.assertEqual(find_duplicates_excluding_ips(ip_list, ignore_list), [\"192.168.1.1\"])\n\n    def test_empty_input(self):\n        ip_list = []\n        ignore_list = []\n        self.assertEqual(find_duplicates_excluding_ips(ip_list, ignore_list), [])\n\n    def test_only_ignored_ips(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.1\"]\n        ignore_list = [\"192.168.1.1\"]\n        self.assertEqual(find_duplicates_excluding_ips(ip_list, ignore_list), [])\n\n    def test_all_duplicates(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.1\"]\n        ignore_list = []\n        self.assertEqual(find_duplicates_excluding_ips(ip_list, ignore_list), [\"192.168.1.1\"])", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_duplicates_excluding_ips(ip_list: List[str], ignore_list: List[str]) -> List[str]:\n    \"\"\"\n    Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n\n    Args:\n        ip_list (List[str]): List of IP addresses\n        ignore_list (List[str]): List of IP addresses to ignor\n\n    Returns:\n        List[str]: A list of duplicate IPs excluding those in the ignore list.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n *\n * @param ip_list A vector of IP addresses.\n * @param ignore_list A vector of IP addresses to ignore.\n * @return A vector of duplicate IPs excluding those in the ignore list.\n */\nstd::vector<std::string> findDuplicateIPs(const std::vector<std::string>& ipList, const std::vector<std::string>& ignoreList) {}", "test_code": "TEST_CASE(\"Test findDuplicateIPs function\") {\n    SECTION(\"Basic duplicates\") {\n        std::vector<std::string> ipList = {\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.1\"};\n        std::vector<std::string> ignoreList = {};\n        REQUIRE(findDuplicateIPs(ipList, ignoreList) == std::vector<std::string>({\"192.168.1.1\"}));\n    }\n\n    SECTION(\"Ignored duplicates\") {\n        std::vector<std::string> ipList = {\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.2\"};\n        std::vector<std::string> ignoreList = {\"192.168.1.1\"};\n        REQUIRE(findDuplicateIPs(ipList, ignoreList).empty());\n    }\n\n    SECTION(\"No duplicates\") {\n        std::vector<std::string> ipList = {\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.3\"};\n        std::vector<std::string> ignoreList = {};\n        REQUIRE(findDuplicateIPs(ipList, ignoreList).empty());\n    }\n\n    SECTION(\"Mixed duplicates\") {\n        std::vector<std::string> ipList = {\"192.168.1.1\", \"192.168.1.1\", \"10.0.0.1\", \"192.168.1.2\"};\n        std::vector<std::string> ignoreList = {\"192.168.1.2\"};\n        REQUIRE(findDuplicateIPs(ipList, ignoreList) == std::vector<std::string>({\"192.168.1.1\"}));\n    }\n\n    SECTION(\"Empty input\") {\n        std::vector<std::string> ipList = {};\n        std::vector<std::string> ignoreList = {};\n        REQUIRE(findDuplicateIPs(ipList, ignoreList).empty());\n    }\n\n    SECTION(\"Only ignored IPs\") {\n        std::vector<std::string> ipList = {\"192.168.1.1\", \"192.168.1.1\"};\n        std::vector<std::string> ignoreList = {\"192.168.1.1\"};\n        REQUIRE(findDuplicateIPs(ipList, ignoreList).empty());\n    }\n\n    SECTION(\"All duplicates\") {\n        std::vector<std::string> ipList = {\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.1\"};\n        std::vector<std::string> ignoreList = {};\n        REQUIRE(findDuplicateIPs(ipList, ignoreList) == std::vector<std::string>({\"192.168.1.1\"}));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n *\n * @param ip_list A vector of IP addresses.\n * @param ignore_list A vector of IP addresses to ignore.\n * @return A vector of duplicate IPs excluding those in the ignore list.\n */\nstd::vector<std::string> findDuplicateIPs(const std::vector<std::string>& ipList, const std::vector<std::string>& ignoreList) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n *\n * @param ipList      List of IP addresses\n * @param ignoreList  List of IP addresses to ignore\n * @return            A list of duplicate IPs excluding those in the ignore list\n */\npublic static List<String> findDuplicateIps(List<String> ipList, List<String> ignoreList) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testBasicDuplicates() {\n        List<String> ipList = Arrays.asList(\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.1\");\n        List<String> ignoreList = Arrays.asList();\n        assertEquals(Arrays.asList(\"192.168.1.1\"), findDuplicateIps(ipList, ignoreList));\n    }\n\n    @Test\n    public void testIgnoredDuplicates() {\n        List<String> ipList = Arrays.asList(\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.2\");\n        List<String> ignoreList = Arrays.asList(\"192.168.1.1\");\n        assertEquals(Arrays.asList(), findDuplicateIps(ipList, ignoreList));\n    }\n\n    @Test\n    public void testNoDuplicates() {\n        List<String> ipList = Arrays.asList(\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.3\");\n        List<String> ignoreList = Arrays.asList();\n        assertEquals(Arrays.asList(), findDuplicateIps(ipList, ignoreList));\n    }\n\n    @Test\n    public void testMixedDuplicates() {\n        List<String> ipList = Arrays.asList(\"192.168.1.1\", \"192.168.1.1\", \"10.0.0.1\", \"192.168.1.2\");\n        List<String> ignoreList = Arrays.asList(\"192.168.1.2\");\n        assertEquals(Arrays.asList(\"192.168.1.1\"), findDuplicateIps(ipList, ignoreList));\n    }\n\n    @Test\n    public void testEmptyInput() {\n        List<String> ipList = Arrays.asList();\n        List<String> ignoreList = Arrays.asList();\n        assertEquals(Arrays.asList(), findDuplicateIps(ipList, ignoreList));\n    }\n\n    @Test\n    public void testOnlyIgnoredIPs() {\n        List<String> ipList = Arrays.asList(\"192.168.1.1\", \"192.168.1.1\");\n        List<String> ignoreList = Arrays.asList(\"192.168.1.1\");\n        assertEquals(Arrays.asList(), findDuplicateIps(ipList, ignoreList));\n    }\n\n    @Test\n    public void testAllDuplicates() {\n        List<String> ipList = Arrays.asList(\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.1\");\n        List<String> ignoreList = Arrays.asList();\n        assertEquals(Arrays.asList(\"192.168.1.1\"), findDuplicateIps(ipList, ignoreList));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n *\n * @param ipList      List of IP addresses\n * @param ignoreList  List of IP addresses to ignore\n * @return            A list of duplicate IPs excluding those in the ignore list\n */\npublic static List<String> findDuplicateIps(List<String> ipList, List<String> ignoreList) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 67, "code_type": "method", "original_language": "python", "file_path": "ebusd-brink-hru\\534e9f7ea8524be980cb4b174dedc06a7bf6966b\\src\\parse_xaml.py", "question_type": "Data processing and transformation", "summary": "parse the XAML file, extract the key-value pairs within the String element, and return the result in a dictionary\n", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef parse_xaml_to_dict(xaml_file: str) -> Dict[str, str]:\n    \"\"\"\n    parse the XAML file, extract the key-value pairs within the String element, and return the model_answer_result in a dictionary\n    Args:\n        xaml_file (str): Path to the XAML file.\n\n    Returns:\n        A dictionary containing the key-value pairs extracted from 'String' elements.\n    \"\"\"\n", "test_code": "import unittest\nimport xml.etree.ElementTree as ET\nfrom io import StringIO\n\n\nclass TestParseXamlToDict(unittest.TestCase):\n    def test_valid_strings(self):\n        xaml_data = \"\"\"<root>\n                         <String Key=\"Username\">Alice</String>\n                         <String Key=\"Password\">secret</String>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {'Username': 'Alice', 'Password': 'secret'}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n\n    def test_missing_key_attribute(self):\n        xaml_data = \"\"\"<root>\n                         <String>Alice</String>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n\n\n    def test_no_string_tags(self):\n        xaml_data = \"\"\"<root>\n                         <Data>Some question</Data>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n\n    def test_nested_string_tags(self):\n        xaml_data = \"\"\"<root>\n                         <Container>\n                           <String Key=\"Username\">Bob</String>\n                         </Container>\n                         <String Key=\"Location\">Earth</String>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {'Username': 'Bob', 'Location': 'Earth'}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef parse_xaml_to_dict(xaml_file: str) -> Dict[str, str]:\n    \"\"\"\n    parse the XAML file, extract the key-value pairs within the String element, and return the model_answer_result in a dictionary\n    Args:\n        xaml_file (str): Path to the XAML file.\n\n    Returns:\n        A dictionary containing the key-value pairs extracted from 'String' elements.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Parse the XAML file, extract the key-value pairs within the String element, and return the result in a dictionary.\n *\n * @param xaml_file The path to the XAML file.\n * @return A map containing the key-value pairs extracted from 'String' elements.\n */\nstd::map<std::string, std::string> parse_xaml_to_dict(const std::string& xaml_file) {}", "test_code": "TEST_CASE(\"Test parse_xaml_to_dict\", \"[parse_xaml_to_dict]\") {\n    SECTION(\"test_valid_strings\") {\n        std::string xaml_data = R\"(<root>\n                                     <String Key=\"Username\">Alice</String>\n                                     <String Key=\"Password\">secret</String>\n                                   </root>)\";\n        std::map<std::string, std::string> expected = {{\"Username\", \"Alice\"}, {\"Password\", \"secret\"}};\n        std::map<std::string, std::string> result = parse_xaml_to_dict(xaml_data);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_missing_key_attribute\") {\n        std::string xaml_data = R\"(<root>\n                                     <String>Alice</String>\n                                   </root>)\";\n        std::map<std::string, std::string> expected = {};\n        std::map<std::string, std::string> result = parse_xaml_to_dict(xaml_data);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_no_string_tags\") {\n        std::string xaml_data = R\"(<root>\n                                     <Data>Some question</Data>\n                                   </root>)\";\n        std::map<std::string, std::string> expected = {};\n        std::map<std::string, std::string> result = parse_xaml_to_dict(xaml_data);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_nested_string_tags\") {\n        std::string xaml_data = R\"(<root>\n                                     <Container>\n                                       <String Key=\"Username\">Bob</String>\n                                     </Container>\n                                     <String Key=\"Location\">Earth</String>\n                                   </root>)\";\n        std::map<std::string, std::string> expected = {{\"Username\", \"Bob\"}, {\"Location\", \"Earth\"}};\n        std::map<std::string, std::string> result = parse_xaml_to_dict(xaml_data);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Parse the XAML file, extract the key-value pairs within the String element, and return the result in a dictionary.\n *\n * @param xaml_file The path to the XAML file.\n * @return A map containing the key-value pairs extracted from 'String' elements.\n */\nstd::map<std::string, std::string> parse_xaml_to_dict(const std::string& xaml_file) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Parses a XAML file, extracts the key-value pairs within the 'String' elements,\n * and returns the result in a dictionary.\n *\n * @param xamlFile Path to the XAML file.\n * @return A map containing the key-value pairs extracted from 'String' elements.\n */\npublic static Map<String, String> parseXamlToDict(String xamlFile) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport java.util.HashMap;\nimport java.util.Map;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testValidStrings() {\n        String xamlData = \"<root>\\n\" +\n                \"  <String Key=\\\"Username\\\">Alice</String>\\n\" +\n                \"  <String Key=\\\"Password\\\">secret</String>\\n\" +\n                \"</root>\";\n        Map<String, String> expected = new HashMap<>();\n        expected.put(\"Username\", \"Alice\");\n        expected.put(\"Password\", \"secret\");\n\n        Map<String, String> result = parseXamlToDict(xamlData);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testMissingKeyAttribute() {\n        String xamlData = \"<root>\\n\" +\n                \"  <String>Alice</String>\\n\" +\n                \"</root>\";\n        Map<String, String> expected = new HashMap<>();\n\n        Map<String, String> result = parseXamlToDict(xamlData);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testNoStringTags() {\n        String xamlData = \"<root>\\n\" +\n                \"  <Data>Some question</Data>\\n\" +\n                \"</root>\";\n        Map<String, String> expected = new HashMap<>();\n\n        Map<String, String> result = parseXamlToDict(xamlData);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testNestedStringTags() {\n        String xamlData = \"<root>\\n\" +\n                \"  <Container>\\n\" +\n                \"    <String Key=\\\"Username\\\">Bob</String>\\n\" +\n                \"  </Container>\\n\" +\n                \"  <String Key=\\\"Location\\\">Earth</String>\\n\" +\n                \"</root>\";\n        Map<String, String> expected = new HashMap<>();\n        expected.put(\"Username\", \"Bob\");\n        expected.put(\"Location\", \"Earth\");\n\n        Map<String, String> result = parseXamlToDict(xamlData);\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Parses a XAML file, extracts the key-value pairs within the 'String' elements,\n * and returns the result in a dictionary.\n *\n * @param xamlFile Path to the XAML file.\n * @return A map containing the key-value pairs extracted from 'String' elements.\n */\npublic static Map<String, String> parseXamlToDict(String xamlFile) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 68, "code_type": "method", "original_language": "python", "file_path": "CFK_Delete_Python\\db808d2f6992ab79a6795a41f864fcee8e07760c\\my_multiprocessing.py", "question_type": "Data processing and transformation", "summary": "divide a list evenly into n parts and return a list of these parts. If the list length is not divisible by n, additional elements are added to the previous sections one by one\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef split_list_into_parts(lst: List, n: int) -> List:\n    \"\"\"\n    divide a list evenly into n parts and return a list of these parts. If the list length is not divisible by n, additional elements are added to the previous sections one by one\n    Args:\n        lst (List): The list to be divided.\n        n (int): The number of parts to divide the list into.\n\n    Returns:\n        A list containing n sublists, where each sublist represents a part of the original list.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestDivideList(unittest.TestCase):\n    def test_even_division(self):\n        lst = [1, 2, 3, 4, 5, 6]\n        n = 3\n        expected = [[1, 2], [3, 4], [5, 6]]\n        self.assertEqual(split_list_into_parts(lst, n), expected)\n\n    def test_uneven_division(self):\n        lst = [1, 2, 3, 4, 5, 6, 7]\n        n = 3\n        expected = [[1, 2, 3], [4, 5], [6, 7]]\n        self.assertEqual(split_list_into_parts(lst, n), expected)\n\n    def test_more_parts_than_items(self):\n        lst = [1, 2, 3]\n        n = 5\n        expected = [[1], [2], [3], [], []]\n        self.assertEqual(split_list_into_parts(lst, n), expected)\n\n    def test_single_element(self):\n        lst = [1]\n        n = 1\n        expected = [[1]]\n        self.assertEqual(split_list_into_parts(lst, n), expected)\n\n    def test_empty_list(self):\n        lst = []\n        n = 3\n        expected = [[], [], []]\n        self.assertEqual(split_list_into_parts(lst, n), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef split_list_into_parts(lst: List, n: int) -> List:\n    \"\"\"\n    divide a list evenly into n parts and return a list of these parts. If the list length is not divisible by n, additional elements are added to the previous sections one by one\n    Args:\n        lst (List): The list to be divided.\n        n (int): The number of parts to divide the list into.\n\n    Returns:\n        A list containing n sublists, where each sublist represents a part of the original list.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Divide a vector evenly into n parts and return a vector of these parts.\n * If the vector length is not divisible by n, additional elements are added to the previous sections one by one.\n *\n * @param lst The vector to be divided.\n * @param n The number of parts to divide the vector into.\n * @return A vector containing n subvectors, where each subvector represents a part of the original vector.\n */\nstd::vector<std::vector<int>> divide_list(const std::vector<int>& lst, int n) {}", "test_code": "TEST_CASE(\"Test divide_list function\", \"[divide_list]\") {\n    SECTION(\"Even division\") {\n        std::vector<int> lst = {1, 2, 3, 4, 5, 6};\n        int n = 3;\n        std::vector<std::vector<int>> expected = {{1, 2}, {3, 4}, {5, 6}};\n        REQUIRE(divide_list(lst, n) == expected);\n    }\n\n    SECTION(\"Uneven division\") {\n        std::vector<int> lst = {1, 2, 3, 4, 5, 6, 7};\n        int n = 3;\n        std::vector<std::vector<int>> expected = {{1, 2, 3}, {4, 5}, {6, 7}};\n        REQUIRE(divide_list(lst, n) == expected);\n    }\n\n    SECTION(\"More parts than items\") {\n        std::vector<int> lst = {1, 2, 3};\n        int n = 5;\n        std::vector<std::vector<int>> expected = {{1}, {2}, {3}, {}, {}};\n        REQUIRE(divide_list(lst, n) == expected);\n    }\n\n    SECTION(\"Single element\") {\n        std::vector<int> lst = {1};\n        int n = 1;\n        std::vector<std::vector<int>> expected = {{1}};\n        REQUIRE(divide_list(lst, n) == expected);\n    }\n\n    SECTION(\"Empty list\") {\n        std::vector<int> lst = {};\n        int n = 3;\n        std::vector<std::vector<int>> expected = {{}, {}, {}};\n        REQUIRE(divide_list(lst, n) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Divide a vector evenly into n parts and return a vector of these parts.\n * If the vector length is not divisible by n, additional elements are added to the previous sections one by one.\n *\n * @param lst The vector to be divided.\n * @param n The number of parts to divide the vector into.\n * @return A vector containing n subvectors, where each subvector represents a part of the original vector.\n */\nstd::vector<std::vector<int>> divide_list(const std::vector<int>& lst, int n) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Divides a list evenly into n parts and returns a list of these parts.\n * If the list length is not divisible by n, additional elements are added to the previous sections one by one.\n *\n * @param lst The list to be divided.\n * @param n The number of parts to divide the list into.\n * @return A list containing n sublists, where each sublist represents a part of the original list.\n */\npublic static List<List<Integer>> divideList(List<Integer> lst, int n) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n\n    @Test\n    public void testEvenDivision() {\n        List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6);\n        int n = 3;\n        List<List<Integer>> expected = Arrays.asList(\n                Arrays.asList(1, 2),\n                Arrays.asList(3, 4),\n                Arrays.asList(5, 6)\n        );\n        assertEquals(expected, divideList(lst, n));\n    }\n\n    @Test\n    public void testUnevenDivision() {\n        List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7);\n        int n = 3;\n        List<List<Integer>> expected = Arrays.asList(\n                Arrays.asList(1, 2, 3),\n                Arrays.asList(4, 5),\n                Arrays.asList(6, 7)\n        );\n        assertEquals(expected, divideList(lst, n));\n    }\n\n    @Test\n    public void testMorePartsThanItems() {\n        List<Integer> lst = Arrays.asList(1, 2, 3);\n        int n = 5;\n        List<List<Integer>> expected = Arrays.asList(\n                Arrays.asList(1),\n                Arrays.asList(2),\n                Arrays.asList(3),\n                Arrays.asList(),\n                Arrays.asList()\n        );\n        assertEquals(expected, divideList(lst, n));\n    }\n\n    @Test\n    public void testSingleElement() {\n        List<Integer> lst = Arrays.asList(1);\n        int n = 1;\n        List<List<Integer>> expected = Arrays.asList(\n                Arrays.asList(1)\n        );\n        assertEquals(expected, divideList(lst, n));\n    }\n\n    @Test\n    public void testEmptyList() {\n        List<Integer> lst = Arrays.asList();\n        int n = 3;\n        List<List<Integer>> expected = Arrays.asList(\n                Arrays.asList(),\n                Arrays.asList(),\n                Arrays.asList()\n        );\n        assertEquals(expected, divideList(lst, n));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Divides a list evenly into n parts and returns a list of these parts.\n * If the list length is not divisible by n, additional elements are added to the previous sections one by one.\n *\n * @param lst The list to be divided.\n * @param n The number of parts to divide the list into.\n * @return A list containing n sublists, where each sublist represents a part of the original list.\n */\npublic static List<List<Integer>> divideList(List<Integer> lst, int n) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 70, "code_type": "method", "original_language": "python", "file_path": "SystemGPT\\222807b913f65574fff12f0ffd803a8e20952214\\sysGPT.py", "question_type": "Data processing and transformation", "summary": "extracts the contents of the code block from the given Markdown string\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef code_block_remover(markdown_string: str) -> List[str]:\n    \"\"\"\n    extracts the contents of the code block from the given Markdown string.\n\n    Args:\n        markdown_string (str): The input markdown string.\n\n    Returns:\n        list: A list of strings, each representing the content of a code block.\n              Returns an empty list if no code blocks are found.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestCodeBlockRemover(unittest.TestCase):\n\n    def test_single_code_block(self):\n        markdown = \"\"\"\n        This is a markdown with a code block.\n\n        ```python\n        print(\"Hello, World!\")\n        ```\n\n        End of markdown.\n        \"\"\"\n        expected = ['print(\"Hello, World!\")']\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_multiple_code_blocks(self):\n        markdown = \"\"\"\n        First code block:\n\n        ```python\n        print(\"Hello, World!\")\n        ```\n\n        Second code block:\n\n        ```javascript\n        console.log(\"Hello, World!\");\n        ```\n        \"\"\"\n        expected = [\n            'print(\"Hello, World!\")',\n            'console.log(\"Hello, World!\");'\n        ]\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_no_code_block(self):\n        markdown = \"\"\"\n        This markdown has no code blocks.\n\n        Just some plain text.\n        \"\"\"\n        expected = []\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_empty_code_block(self):\n        markdown = \"\"\"\n        Here is an empty code block:\n\n        ```python\n        ```\n\n        End of markdown.\n        \"\"\"\n        expected = ['']\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_malformed_code_block(self):\n        markdown = \"\"\"\n        This code block is missing ending:\n\n        ```python\n        print(\"Hello, World!\")\n\n        And some more text.\n        \"\"\"\n        expected = []\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef code_block_remover(markdown_string: str) -> List[str]:\n    \"\"\"\n    extracts the contents of the code block from the given Markdown string.\n\n    Args:\n        markdown_string (str): The input markdown string.\n\n    Returns:\n        list: A list of strings, each representing the content of a code block.\n              Returns an empty list if no code blocks are found.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extracts the contents of the code block from the given Markdown string.\n *\n * @param markdown_string The input markdown string.\n *\n * @return A vector of strings, each representing the content of a code block.\n *         Returns an empty vector if no code blocks are found.\n */\nstd::vector<std::string> code_block_remover(const std::string& markdown_string) {}", "test_code": "TEST_CASE(\"Test code_block_remover\", \"[code_block_remover]\") {\n    SECTION(\"Single code block\") {\n        std::string markdown = R\"(\n        This is a markdown with a code block.\n\n        ```python\n        print(\"Hello, World!\")\n        ```\n\n        End of markdown.\n        )\";\n        std::vector<std::string> expected = {\"print(\\\"Hello, World!\\\")\"};\n        std::vector<std::string> result = code_block_remover(markdown);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Multiple code blocks\") {\n        std::string markdown = R\"(\n        First code block:\n\n        ```python\n        print(\"Hello, World!\")\n        ```\n\n        Second code block:\n\n        ```javascript\n        console.log(\"Hello, World!\");\n        )\";\n        std::vector<std::string> expected = {\n            \"print(\\\"Hello, World!\\\")\",\n            \"console.log(\\\"Hello, World!\\\");\"\n        };\n        std::vector<std::string> result = code_block_remover(markdown);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"No code block\") {\n        std::string markdown = R\"(\n        This markdown has no code blocks.\n\n        Just some plain text.\n        )\";\n        std::vector<std::string> expected = {};\n        std::vector<std::string> result = code_block_remover(markdown);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Empty code block\") {\n        std::string markdown = R\"(\n        Here is an empty code block:\n\n        ```python\n        ```\n\n        End of markdown.\n        )\";\n        std::vector<std::string> expected = {\"\"};\n        std::vector<std::string> result = code_block_remover(markdown);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Malformed code block\") {\n        std::string markdown = R\"(\n        This code block is missing ending:\n\n        ```python\n        print(\"Hello, World!\")\n\n        And some more text.\n        )\";\n        std::vector<std::string> expected = {};\n        std::vector<std::string> result = code_block_remover(markdown);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts the contents of the code block from the given Markdown string.\n *\n * @param markdown_string The input markdown string.\n *\n * @return A vector of strings, each representing the content of a code block.\n *         Returns an empty vector if no code blocks are found.\n */\nstd::vector<std::string> code_block_remover(const std::string& markdown_string) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Extracts the contents of the code block from the given Markdown string.\n *\n * @param markdownString The input Markdown string.\n * @return A list of strings, each representing the content of a code block.\n *         Returns an empty list if no code blocks are found.\n */\npublic static List<String> codeBlockRemover(String markdownString) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testSingleCodeBlock() {\n        String markdown = \"This is a markdown with a code block.\\n\\n```python\\nprint(\\\"Hello, World!\\\")\\n```\\n\\nEnd of markdown.\";\n        List<String> expected = Arrays.asList(\"print(\\\"Hello, World!\\\")\");\n        List<String> result = codeBlockRemover(markdown);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testMultipleCodeBlocks() {\n        String markdown = \"First code block:\\n\\n```python\\nprint(\\\"Hello, World!\\\")\\n```\\n\\nSecond code block:\\n\\n```javascript\\nconsole.log(\\\"Hello, World!\\\");\\n```\\n\";\n        List<String> expected = Arrays.asList(\n            \"print(\\\"Hello, World!\\\")\",\n            \"console.log(\\\"Hello, World!\\\");\"\n        );\n        List<String> result = codeBlockRemover(markdown);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testNoCodeBlock() {\n        String markdown = \"This markdown has no code blocks.\\n\\nJust some plain text.\";\n        List<String> expected = Arrays.asList();\n        List<String> result = codeBlockRemover(markdown);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testEmptyCodeBlock() {\n        String markdown = \"Here is an empty code block:\\n\\n```python\\n```\\n\\nEnd of markdown.\";\n        List<String> expected = Arrays.asList(\"\");\n        List<String> result = codeBlockRemover(markdown);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testMalformedCodeBlock() {\n        String markdown = \"This code block is missing ending:\\n\\n```python\\nprint(\\\"Hello, World!\\\")\\n\\nAnd some more text.\";\n        List<String> expected = Arrays.asList();\n        List<String> result = codeBlockRemover(markdown);\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts the contents of the code block from the given Markdown string.\n *\n * @param markdownString The input Markdown string.\n * @return A list of strings, each representing the content of a code block.\n *         Returns an empty list if no code blocks are found.\n */\npublic static List<String> codeBlockRemover(String markdownString) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 71, "code_type": "method", "original_language": "python", "file_path": "BAD\\8f17432451f1cd9bef90581ed6cd4ce4df0c1a54\\BAD\\mag_reader.py", "question_type": "Data processing and transformation", "summary": "Reads numerical columns from a file starting from the line after the last line containing '/'.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef read_numerical_columns_from_file(file_name: str) -> np.array:\n    \"\"\"\n    Reads numerical columns from a file starting from the line after the last line containing '/'.\n\n    Args:\n        file_name (str): The name of the file to read.\n\n    Returns:\n        numpy.ndarray: A 2D numpy array containing the numerical question.\n\n    Raises:\n        ValueError: If the file does not contain any '/' character.\n    \"\"\"\n", "test_code": "import os\nimport unittest\nimport numpy as np\n\nclass TestReadColumns(unittest.TestCase):\n\n    def setUp(self):\n        # Setup a temporary directory to use for each test\n        self.test_file = 'test_file.txt'\n\n    def tearDown(self):\n        # Clean up the temporary file after each test\n        if os.path.exists(self.test_file):\n            os.remove(self.test_file)\n\n    def test_basic_functionality(self):\n        # Test reading a file with a valid structure and numerical question\n        content = \"\"\"Line 1\nLine 2\n/\n1.0 2.0 3.0\n4.0 5.0 6.0\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        result = read_numerical_columns_from_file(self.test_file)\n        expected_result = np.array([[1.0, 2.0, 3.0],\n                                    [4.0, 5.0, 6.0]])\n        np.testing.assert_array_equal(result, expected_result)\n\n    def test_no_slash_character(self):\n        # Test that a ValueError is raised if no '/' character is found\n        content = \"\"\"Line 1\nLine 2\nLine 3\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        with self.assertRaises(ValueError):\n            read_numerical_columns_from_file(self.test_file)\n\n    def test_file_with_comments_and_empty_lines(self):\n        # Test handling of comments and empty lines\n        content = \"\"\"Line 1\n/\n! This is a comment\n1.0 2.0 3.0\n\n4.0 5.0 6.0\n! Another comment\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        result = read_numerical_columns_from_file(self.test_file)\n        expected_result = np.array([[1.0, 2.0, 3.0],\n                                    [4.0, 5.0, 6.0]])\n        np.testing.assert_array_equal(result, expected_result)\n\n    def test_different_number_of_columns(self):\n        # Test that the function handles different number of columns correctly\n        content = \"\"\"Line 1\n/\n1.0 2.0\n3.0 4.0\n5.0 6.0 7.0\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        with self.assertRaises(ValueError):\n            read_numerical_columns_from_file(self.test_file)\n\n    def test_empty_file(self):\n        # Test handling of an empty file\n        content = \"\"\"\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        with self.assertRaises(ValueError):\n            read_numerical_columns_from_file(self.test_file)\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef read_numerical_columns_from_file(file_name: str) -> np.array:\n    \"\"\"\n    Reads numerical columns from a file starting from the line after the last line containing '/'.\n\n    Args:\n        file_name (str): The name of the file to read.\n\n    Returns:\n        numpy.ndarray: A 2D numpy array containing the numerical question.\n\n    Raises:\n        ValueError: If the file does not contain any '/' character.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads numerical columns from a file starting from the line after the last line containing '/'.\n *\n * @param file_name The name of the file to read.\n * @return A 2D vector containing the numerical data.\n * @throws std::runtime_error If the file does not contain any '/' character.\n */\nstd::vector<std::vector<double>> read_columns(const std::string& file_name) {}", "test_code": "TEST_CASE(\"Test read_columns function\", \"[read_columns]\") {\n    const std::string test_file = \"test_file.txt\";\n\n    SECTION(\"Basic functionality\") {\n        // Test reading a file with a valid structure and numerical question\n        std::string content = R\"(\nLine 1\nLine 2\n/\n1.0 2.0 3.0\n4.0 5.0 6.0\n)\";\n        std::ofstream file(test_file);\n        file << content;\n        file.close();\n\n        std::vector<std::vector<double>> result = read_columns(test_file);\n        std::vector<std::vector<double>> expected_result = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}};\n        REQUIRE(result == expected_result);\n\n        if (std::remove(test_file.c_str()) != 0) {\n            std::cerr << \"Failed to remove test file.\" << std::endl;\n        }\n    }\n\n    SECTION(\"No slash character\") {\n        // Test that a runtime_error is raised if no '/' character is found\n        std::string content = R\"(\nLine 1\nLine 2\nLine 3\n)\";\n        std::ofstream file(test_file);\n        file << content;\n        file.close();\n\n        REQUIRE_THROWS_AS(read_columns(test_file), std::runtime_error);\n\n        if (std::remove(test_file.c_str()) != 0) {\n            std::cerr << \"Failed to remove test file.\" << std::endl;\n        }\n    }\n\n    SECTION(\"File with comments and empty lines\") {\n        // Test handling of comments and empty lines\n        std::string content = R\"(\nLine 1\n/\n! This is a comment\n1.0 2.0 3.0\n\n4.0 5.0 6.0\n! Another comment\n)\";\n        std::ofstream file(test_file);\n        file << content;\n        file.close();\n\n        std::vector<std::vector<double>> result = read_columns(test_file);\n        std::vector<std::vector<double>> expected_result = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}};\n        REQUIRE(result == expected_result);\n\n        if (std::remove(test_file.c_str()) != 0) {\n            std::cerr << \"Failed to remove test file.\" << std::endl;\n        }\n    }\n\n    SECTION(\"Different number of columns\") {\n        // Test that the function handles different number of columns correctly\n        std::string content = R\"(\nLine 1\n/\n1.0 2.0\n3.0 4.0\n5.0 6.0 7.0\n)\";\n        std::ofstream file(test_file);\n        file << content;\n        file.close();\n\n        REQUIRE_THROWS_AS(read_columns(test_file), std::runtime_error);\n\n        if (std::remove(test_file.c_str()) != 0) {\n            std::cerr << \"Failed to remove test file.\" << std::endl;\n        }\n    }\n\n    SECTION(\"Empty file\") {\n        // Test handling of an empty file\n        std::string content = \"\";\n        std::ofstream file(test_file);\n        file << content;\n        file.close();\n\n        REQUIRE_THROWS_AS(read_columns(test_file), std::runtime_error);\n\n        if (std::remove(test_file.c_str()) != 0) {\n            std::cerr << \"Failed to remove test file.\" << std::endl;\n        }\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads numerical columns from a file starting from the line after the last line containing '/'.\n *\n * @param file_name The name of the file to read.\n * @return A 2D vector containing the numerical data.\n * @throws std::runtime_error If the file does not contain any '/' character.\n */\nstd::vector<std::vector<double>> read_columns(const std::string& file_name) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads numerical columns from a file starting from the line after the last line containing '/'.\n *\n * @param fileName The name of the file to read.\n * @return A 2D array containing the numerical data.\n * @throws IllegalArgumentException If the file does not contain any '/' character.\n * @throws IOException If an I/O error occurs.\n */\npublic static double[][] readColumns(String fileName) throws IOException {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\nimport static org.junit.Assert.assertArrayEquals;\n\npublic class Tester {\n\n    private static final String TEST_FILE = \"test_file.txt\";\n\n    @Before\n    public void setUp() throws IOException {\n        // Setup a temporary directory to use for each test\n        File testFile = new File(TEST_FILE);\n        if (!testFile.exists()) {\n            testFile.createNewFile();\n        }\n    }\n\n    @After\n    public void tearDown() {\n        // Clean up the temporary file after each test\n        File testFile = new File(TEST_FILE);\n        if (testFile.exists()) {\n            testFile.delete();\n        }\n    }\n\n    @Test\n    public void testBasicFunctionality() throws IOException {\n        // Test reading a file with a valid structure and numerical question\n        String content = \"Line 1\\n\" +\n                \"Line 2\\n\" +\n                \"/\\n\" +\n                \"1.0 2.0 3.0\\n\" +\n                \"4.0 5.0 6.0\\n\";\n\n        try (FileWriter writer = new FileWriter(TEST_FILE)) {\n            writer.write(content);\n        }\n\n        double[][] result = Answer.readColumns(TEST_FILE);\n        double[][] expectedResult = {\n                {1.0, 2.0, 3.0},\n                {4.0, 5.0, 6.0}\n        };\n\n        assertArrayEquals(expectedResult, result);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testNoSlashCharacter() throws IOException {\n        // Test that an IllegalArgumentException is raised if no '/' character is found\n        String content = \"Line 1\\n\" +\n                \"Line 2\\n\" +\n                \"Line 3\\n\";\n\n        try (FileWriter writer = new FileWriter(TEST_FILE)) {\n            writer.write(content);\n        }\n\n        Answer.readColumns(TEST_FILE);\n    }\n\n    @Test\n    public void testFileWithCommentsAndEmptyLines() throws IOException {\n        // Test handling of comments and empty lines\n        String content = \"Line 1\\n\" +\n                \"/\\n\" +\n                \"! This is a comment\\n\" +\n                \"1.0 2.0 3.0\\n\" +\n                \"\\n\" +\n                \"4.0 5.0 6.0\\n\" +\n                \"! Another comment\\n\";\n\n        try (FileWriter writer = new FileWriter(TEST_FILE)) {\n            writer.write(content);\n        }\n\n        double[][] result = Answer.readColumns(TEST_FILE);\n        double[][] expectedResult = {\n                {1.0, 2.0, 3.0},\n                {4.0, 5.0, 6.0}\n        };\n\n        assertArrayEquals(expectedResult, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Reads numerical columns from a file starting from the line after the last line containing '/'.\n *\n * @param fileName The name of the file to read.\n * @return A 2D array containing the numerical data.\n * @throws IllegalArgumentException If the file does not contain any '/' character.\n * @throws IOException If an I/O error occurs.\n */\npublic static double[][] readColumns(String fileName) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 72, "code_type": "method", "original_language": "python", "file_path": "motlee\\fb09c97977edf1be0118ad9bb8a7fd96dce6cad5\\motlee\\utils\\cam_utils.py", "question_type": "Data processing and transformation", "summary": "    converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef convert_pixel_to_3d_coordinates(K: np.array, d: float, x: float, y: float) -> np.array:\n    \"\"\"\n    Convert 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n\n    Args:\n        K (np.array): A (3, 3) camera intrinsic matrix, which includes focal lengths and optical center.\n        d (float): Depth (distance along the z-axis) from the camera to the point in 3D space.\n        x (float): The x coordinate of the pixel in 2D image space.\n        y (float): The y coordinate of the pixel in 2D image space.\n\n    Returns:\n        np.array: A numpy array containing the 3D coordinates (x, y, z) in the camera's right-handed coordinate frame.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestGet3DCoordinates(unittest.TestCase):\n    def setUp(self):\n        # Define a common intrinsic matrix for testing\n        self.K = np.array([[1000, 0, 320],\n                           [0, 1000, 240],\n                           [0, 0, 1]])\n\n    def test_center_coordinates(self):\n        \"\"\" Test with center pixel coordinates where x and y should map to zero in NDC. \"\"\"\n        result = convert_pixel_to_3d_coordinates(self.K, 100, 320, 240)\n        np.testing.assert_array_almost_equal(result, np.array([0.0, 0.0, 100]))\n\n    def test_boundary_coordinates(self):\n        \"\"\" Test with boundary values in the image frame. \"\"\"\n        result = convert_pixel_to_3d_coordinates(self.K, 50, 640, 480)\n        expected_x = (640 - 320) / 1000 * 50\n        expected_y = (480 - 240) / 1000 * 50\n        np.testing.assert_array_almost_equal(result, np.array([expected_x, expected_y, 50]))\n\n    def test_negative_depth(self):\n        \"\"\" Test with a negative depth to see if it handles incorrect input properly. \"\"\"\n        result = convert_pixel_to_3d_coordinates(self.K, -100, 320, 240)\n        np.testing.assert_array_almost_equal(result, np.array([0.0, 0.0, -100]))\n\n    def test_zero_depth(self):\n        \"\"\" Test with zero depth which should lead to a zero-length vector. \"\"\"\n        result = convert_pixel_to_3d_coordinates(self.K, 0, 320, 240)\n        np.testing.assert_array_almost_equal(result, np.array([0.0, 0.0, 0.0]))\n\n    def test_non_integer_values(self):\n        \"\"\" Test with non-integer pixel coordinates. \"\"\"\n        result = convert_pixel_to_3d_coordinates(self.K, 100, 320.5, 240.5)\n        expected_x = (320.5 - 320) / 1000 * 100\n        expected_y = (240.5 - 240) / 1000 * 100\n        np.testing.assert_array_almost_equal(result, np.array([expected_x, expected_y, 100]))\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef convert_pixel_to_3d_coordinates(K: np.array, d: float, x: float, y: float) -> np.array:\n    \"\"\"\n    Convert 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n\n    Args:\n        K (np.array): A (3, 3) camera intrinsic matrix, which includes focal lengths and optical center.\n        d (float): Depth (distance along the z-axis) from the camera to the point in 3D space.\n        x (float): The x coordinate of the pixel in 2D image space.\n        y (float): The y coordinate of the pixel in 2D image space.\n\n    Returns:\n        np.array: A numpy array containing the 3D coordinates (x, y, z) in the camera's right-handed coordinate frame.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n *\n * @param K A 3x3 matrix representing the camera intrinsic matrix.\n * @param d Depth (distance along the z-axis).\n * @param x Pixel x coordinate.\n * @param y Pixel y coordinate.\n *\n * @return A 3D vector containing the x, y, z coordinates in camera RDF coordinates.\n */\nVectorXd get_3d_coordinates(const MatrixXd& K, double d, double x, double y) {}", "test_code": "TEST_CASE(\"TestGet3DCoordinates\", \"[get_3d_coordinates]\") {\n    // Define a common intrinsic matrix for testing\n    MatrixXd K(3, 3);\n    K << 1000, 0, 320,\n         0, 1000, 240,\n         0, 0, 1;\n\n    SECTION(\"test_center_coordinates\") {\n        // Test with center pixel coordinates where x and y should map to zero in NDC.\n        VectorXd result = get_3d_coordinates(K, 100, 320, 240);\n        REQUIRE_THAT(result, Catch::Approx(VectorXd::Zero(3)).epsilon(1e-6));\n    }\n\n    SECTION(\"test_boundary_coordinates\") {\n        // Test with boundary values in the image frame.\n        VectorXd result = get_3d_coordinates(K, 50, 640, 480);\n        double expected_x = (640 - 320) / 1000 * 50;\n        double expected_y = (480 - 240) / 1000 * 50;\n        REQUIRE_THAT(result, Catch::Approx(VectorXd::Zero(3) + VectorXd({expected_x, expected_y, 50})).epsilon(1e-6));\n    }\n\n    SECTION(\"test_negative_depth\") {\n        // Test with a negative depth to see if it handles incorrect input properly.\n        VectorXd result = get_3d_coordinates(K, -100, 320, 240);\n        REQUIRE_THAT(result, Catch::Approx(VectorXd::Zero(3) + VectorXd({0.0, 0.0, -100})).epsilon(1e-6));\n    }\n\n    SECTION(\"test_zero_depth\") {\n        // Test with zero depth which should lead to a zero-length vector.\n        VectorXd result = get_3d_coordinates(K, 0, 320, 240);\n        REQUIRE_THAT(result, Catch::Approx(VectorXd::Zero(3)).epsilon(1e-6));\n    }\n\n    SECTION(\"test_non_integer_values\") {\n        // Test with non-integer pixel coordinates.\n        VectorXd result = get_3d_coordinates(K, 100, 320.5, 240.5);\n        double expected_x = (320.5 - 320) / 1000 * 100;\n        double expected_y = (240.5 - 240) / 1000 * 100;\n        REQUIRE_THAT(result, Catch::Approx(VectorXd::Zero(3) + VectorXd({expected_x, expected_y, 100})).epsilon(1e-6));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n *\n * @param K A 3x3 matrix representing the camera intrinsic matrix.\n * @param d Depth (distance along the z-axis).\n * @param x Pixel x coordinate.\n * @param y Pixel y coordinate.\n *\n * @return A 3D vector containing the x, y, z coordinates in camera RDF coordinates.\n */\nVectorXd get_3d_coordinates(const MatrixXd& K, double d, double x, double y) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n *\n * @param K A 3x3 matrix representing the camera intrinsic parameters.\n * @param d Depth (distance along the z-axis).\n * @param x Pixel x coordinate.\n * @param y Pixel y coordinate.\n * @return An array containing the 3D coordinates [x, y, z] in camera RDF coordinates.\n */\npublic static double[] get3DCoordinates(INDArray K, double d, double x, double y) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertArrayEquals;\n\nimport org.nd4j.linalg.api.ndarray.INDArray;\nimport org.nd4j.linalg.factory.Nd4j;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    private INDArray K;\n\n    @Before\n    public void setUp() {\n        // Define a common intrinsic matrix for testing\n        K = Nd4j.create(new double[][]{\n                {1000, 0, 320},\n                {0, 1000, 240},\n                {0, 0, 1}\n        });\n    }\n\n    @Test\n    public void testCenterCoordinates() {\n        // Test with center pixel coordinates where x and y should map to zero in NDC.\n        double[] result = get3DCoordinates(K, 100, 320, 240);\n        assertArrayEquals(new double[]{0.0, 0.0, 100}, result, 1e-6);\n    }\n\n    @Test\n    public void testBoundaryCoordinates() {\n        // Test with boundary values in the image frame.\n        double[] result = get3DCoordinates(K, 50, 640, 480);\n        double expectedX = (640 - 320) / 1000 * 50;\n        double expectedY = (480 - 240) / 1000 * 50;\n        assertArrayEquals(new double[]{expectedX, expectedY, 50}, result, 1e-6);\n    }\n\n    @Test\n    public void testNegativeDepth() {\n        // Test with a negative depth to see if it handles incorrect input properly.\n        double[] result = get3DCoordinates(K, -100, 320, 240);\n        assertArrayEquals(new double[]{0.0, 0.0, -100}, result, 1e-6);\n    }\n\n    @Test\n    public void testZeroDepth() {\n        // Test with zero depth which should lead to a zero-length vector.\n        double[] result = get3DCoordinates(K, 0, 320, 240);\n        assertArrayEquals(new double[]{0.0, 0.0, 0.0}, result, 1e-6);\n    }\n\n    @Test\n    public void testNonIntegerValues() {\n        // Test with non-integer pixel coordinates.\n        double[] result = get3DCoordinates(K, 100, 320.5, 240.5);\n        double expectedX = (320.5 - 320) / 1000 * 100;\n        double expectedY = (240.5 - 240) / 1000 * 100;\n        assertArrayEquals(new double[]{expectedX, expectedY, 100}, result, 1e-6);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n *\n * @param K A 3x3 matrix representing the camera intrinsic parameters.\n * @param d Depth (distance along the z-axis).\n * @param x Pixel x coordinate.\n * @param y Pixel y coordinate.\n * @return An array containing the 3D coordinates [x, y, z] in camera RDF coordinates.\n */\npublic static double[] get3DCoordinates(INDArray K, double d, double x, double y) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 73, "code_type": "method", "original_language": "python", "file_path": "gpt_react_repl_w_method_search\\9775bb5fb00d320b91340eb3b2bca3bc83d746af\\src\\react_repl_agent\\apis\\utils.py", "question_type": "Data processing and transformation", "summary": "convert a dictionary of lists to a list of dictionaries", "language_version_list": {"python": {"code_signature": "from typing import Dict, List\n\n\ndef dict_of_lists_to_list_of_dicts(dict_of_lists: Dict) -> List[Dict]:\n    \"\"\"\n    Convert a dictionary of lists into a list of dictionaries.\n    Args:\n        dict_of_lists (dict): A dictionary where each key has a list as its value.\n\n    Returns:\n        list of dicts: A list where each item is a dictionary formed by corresponding elements of lists in the input dictionary.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestDictOfListsToListOfDicts(unittest.TestCase):\n    def test_standard_conversion(self):\n        \"\"\"Test standard conversion with equal length lists.\"\"\"\n        dict_of_lists = {\n            \"name\": [\"Alice\", \"Bob\", \"Charlie\"],\n            \"age\": [25, 30, 35],\n            \"city\": [\"New York\", \"Los Angeles\", \"Chicago\"]\n        }\n        expected_result = [\n            {'name': 'Alice', 'age': 25, 'city': 'New York'},\n            {'name': 'Bob', 'age': 30, 'city': 'Los Angeles'},\n            {'name': 'Charlie', 'age': 35, 'city': 'Chicago'}\n        ]\n        result = dict_of_lists_to_list_of_dicts(dict_of_lists)\n        self.assertEqual(result, expected_result)\n\n    def test_empty_lists(self):\n        \"\"\"Test the function with empty lists.\"\"\"\n        dict_of_lists = {\n            \"name\": [],\n            \"age\": [],\n            \"city\": []\n        }\n        expected_result = []\n        result = dict_of_lists_to_list_of_dicts(dict_of_lists)\n        self.assertEqual(result, expected_result)\n\n    def test_single_element_lists(self):\n        \"\"\"Test the function with single-element lists.\"\"\"\n        dict_of_lists = {\n            \"name\": [\"Alice\"],\n            \"age\": [25],\n            \"city\": [\"New York\"]\n        }\n        expected_result = [\n            {'name': 'Alice', 'age': 25, 'city': 'New York'}\n        ]\n        result = dict_of_lists_to_list_of_dicts(dict_of_lists)\n        self.assertEqual(result, expected_result)\n", "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef dict_of_lists_to_list_of_dicts(dict_of_lists: Dict) -> List[Dict]:\n    \"\"\"\n    Convert a dictionary of lists into a list of dictionaries.\n    Args:\n        dict_of_lists (dict): A dictionary where each key has a list as its value.\n\n    Returns:\n        list of dicts: A list where each item is a dictionary formed by corresponding elements of lists in the input dictionary.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert a dictionary of lists into a list of dictionaries.\n *\n * @param dict_of_lists A map where each key has a vector as its value.\n * @return A vector of maps, where each map is formed by corresponding elements of vectors in the input map.\n */\nstd::vector<std::map<std::string, int>> dict_of_lists_to_list_of_dicts(const std::map<std::string, std::vector<int>>& dict_of_lists) {}", "test_code": "TEST_CASE(\"TestDictOfListsToListOfDicts\") {\n    SECTION(\"test_standard_conversion\") {\n        // Test standard conversion with equal length lists\n        std::map<std::string, std::vector<std::string>> dict_of_lists = {\n            {\"name\", {\"Alice\", \"Bob\", \"Charlie\"}},\n            {\"age\", {\"25\", \"30\", \"35\"}},\n            {\"city\", {\"New York\", \"Los Angeles\", \"Chicago\"}}\n        };\n        std::vector<std::map<std::string, std::string>> expected_result = {\n            {{\"name\", \"Alice\"}, {\"age\", \"25\"}, {\"city\", \"New York\"}},\n            {{\"name\", \"Bob\"}, {\"age\", \"30\"}, {\"city\", \"Los Angeles\"}},\n            {{\"name\", \"Charlie\"}, {\"age\", \"35\"}, {\"city\", \"Chicago\"}}\n        };\n\n        auto result = dict_of_lists_to_list_of_dicts(dict_of_lists);\n        REQUIRE(result == expected_result);\n    }\n\n    SECTION(\"test_empty_lists\") {\n        // Test the function with empty lists\n        std::map<std::string, std::vector<std::string>> dict_of_lists = {\n            {\"name\", {}},\n            {\"age\", {}},\n            {\"city\", {}}\n        };\n        std::vector<std::map<std::string, std::string>> expected_result = {};\n\n        auto result = dict_of_lists_to_list_of_dicts(dict_of_lists);\n        REQUIRE(result == expected_result);\n    }\n\n    SECTION(\"test_single_element_lists\") {\n        // Test the function with single-element lists\n        std::map<std::string, std::vector<std::string>> dict_of_lists = {\n            {\"name\", {\"Alice\"}},\n            {\"age\", {\"25\"}},\n            {\"city\", {\"New York\"}}\n        };\n        std::vector<std::map<std::string, std::string>> expected_result = {\n            {{\"name\", \"Alice\"}, {\"age\", \"25\"}, {\"city\", \"New York\"}}\n        };\n\n        auto result = dict_of_lists_to_list_of_dicts(dict_of_lists);\n        REQUIRE(result == expected_result);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert a dictionary of lists into a list of dictionaries.\n *\n * @param dict_of_lists A map where each key has a vector as its value.\n * @return A vector of maps, where each map is formed by corresponding elements of vectors in the input map.\n */\nstd::vector<std::map<std::string, int>> dict_of_lists_to_list_of_dicts(const std::map<std::string, std::vector<int>>& dict_of_lists) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Convert a map of lists into a list of maps.\n *\n * @param mapOfLists A map where each key has a list as its value.\n * @return A list where each item is a map formed by corresponding elements of lists in the input map.\n * @throws IllegalArgumentException If lists in the map are of different lengths.\n */\npublic static List<Map<String, Integer>> dictOfListsToListOfDicts(Map<String, List<Integer>> mapOfLists) throws IllegalArgumentException {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.*;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    private static final String NAME = \"name\";\n    private static final String AGE = \"age\";\n    private static final String CITY = \"city\";\n\n    /**\n     * Test standard conversion with equal length lists.\n     */\n    @Test\n    public void testStandardConversion() {\n        Map<String, List<Object>> dictOfLists = new HashMap<>();\n        dictOfLists.put(NAME, Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"));\n        dictOfLists.put(AGE, Arrays.asList(25, 30, 35));\n        dictOfLists.put(CITY, Arrays.asList(\"New York\", \"Los Angeles\", \"Chicago\"));\n\n        List<Map<String, Object>> expectedResult = Arrays.asList(\n            new HashMap<String, Object>() {{\n                put(NAME, \"Alice\");\n                put(AGE, 25);\n                put(CITY, \"New York\");\n            }},\n            new HashMap<String, Object>() {{\n                put(NAME, \"Bob\");\n                put(AGE, 30);\n                put(CITY, \"Los Angeles\");\n            }},\n            new HashMap<String, Object>() {{\n                put(NAME, \"Charlie\");\n                put(AGE, 35);\n                put(CITY, \"Chicago\");\n            }}\n        );\n\n        List<Map<String, Integer>> result = dictOfListsToListOfDicts(dictOfLists);\n        assertEquals(expectedResult, result);\n    }\n\n    /**\n     * Test the function with empty lists.\n     */\n    @Test\n    public void testEmptyLists() {\n        Map<String, List<Object>> dictOfLists = new HashMap<>();\n        dictOfLists.put(NAME, Collections.emptyList());\n        dictOfLists.put(AGE, Collections.emptyList());\n        dictOfLists.put(CITY, Collections.emptyList());\n\n        List<Map<String, Object>> expectedResult = Collections.emptyList();\n\n        List<Map<String, Integer>> result = dictOfListsToListOfDicts(dictOfLists);\n        assertEquals(expectedResult, result);\n    }\n\n    /**\n     * Test the function with single-element lists.\n     */\n    @Test\n    public void testSingleElementLists() {\n        Map<String, List<Object>> dictOfLists = new HashMap<>();\n        dictOfLists.put(NAME, Collections.singletonList(\"Alice\"));\n        dictOfLists.put(AGE, Collections.singletonList(25));\n        dictOfLists.put(CITY, Collections.singletonList(\"New York\"));\n\n        List<Map<String, Object>> expectedResult = Collections.singletonList(\n            new HashMap<String, Object>() {{\n                put(NAME, \"Alice\");\n                put(AGE, 25);\n                put(CITY, \"New York\");\n            }}\n        );\n\n        List<Map<String, Integer>> result = dictOfListsToListOfDicts(dictOfLists);\n        assertEquals(expectedResult, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Convert a map of lists into a list of maps.\n *\n * @param mapOfLists A map where each key has a list as its value.\n * @return A list where each item is a map formed by corresponding elements of lists in the input map.\n * @throws IllegalArgumentException If lists in the map are of different lengths.\n */\npublic static List<Map<String, Integer>> dictOfListsToListOfDicts(Map<String, List<Integer>> mapOfLists) throws IllegalArgumentException {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 74, "code_type": "method", "original_language": "python", "file_path": "unuseful_tools\\8fd726cec63c0d24c9dbd7b1d53fc835b861d39b\\decimal_to_binary\\decimal_to_binary.py", "question_type": "Data processing and transformation", "summary": "Convert a decimal number to a 32-bit or 64-bit binary representation.", "language_version_list": {"python": {"code_signature": "import struct\nfrom typing import Union\n\ndef convert_decimal_to_binary(decimal_value: float, bit_length: int) -> Union[str, None]:\n    \"\"\"\n    Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n    For example:\n        input: decimal 3.14 bit 32\n        output: 01000000010010001111010111000011\n\n    Args:\n        decimal_value (float): The decimal number to convert.\n        bit_length (int): The desired bit length for the binary representation (32 or 64).\n\n    Returns:\n        Union[str, None]: The binary string representation of the decimal number if the bit length\n                          is valid, otherwise `None`.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestConvertDecimalToBinary(unittest.TestCase):\n    def test_basic_32_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(3.14, 32),\n                         '01000000010010001111010111000011',\n                         \"3.14 should be correctly converted to 32-bit binary\")\n\n    def test_basic_64_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(3.14, 64),\n                         '0100000000001001000111101011100001010001111010111000010100011111',\n                         \"3.14 should be correctly converted to 64-bit binary\")\n\n    def test_advance_32_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(1.5, 32), '00111111110000000000000000000000',\n                         \"1.5 should be correctly converted to 32-bit binary\")\n\n    def test_advance_64_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(1.5, 64),\n                         '0011111111111000000000000000000000000000000000000000000000000000',\n                         \"1.5 should be correctly converted to 32-bit binary\")\n", "prompt": "please write a python function , the function signature as below import struct\nfrom typing import Union\n\ndef convert_decimal_to_binary(decimal_value: float, bit_length: int) -> Union[str, None]:\n    \"\"\"\n    Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n    For example:\n        input: decimal 3.14 bit 32\n        output: 01000000010010001111010111000011\n\n    Args:\n        decimal_value (float): The decimal number to convert.\n        bit_length (int): The desired bit length for the binary representation (32 or 64).\n\n    Returns:\n        Union[str, None]: The binary string representation of the decimal number if the bit length\n                          is valid, otherwise `None`.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 75, "code_type": "method", "original_language": "python", "file_path": "early_fonts_inventory\\88fc8faa3af50c2a61705cb122bda5610e16496a\\tools\\renumber.py", "question_type": "File operations and I/O operation", "summary": " Renames PNG files in a specified directory by appending a sequence number to each file.\n    The files are sorted alphabetically, and each base name is assigned sequential numbers.eg image1.png after change to be image1001.png", "language_version_list": {"python": {"code_signature": "def rename_png_files_in_directory(directory: str):\n    \"\"\"\n    Renames PNG files in a specified directory by appending a sequence number to each file.\n    The files are sorted alphabetically, and each base name is assigned sequential numbers.\n    For example:\n        director have three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\"\n        after renaming PNG files are \"image1001.png\", \"image2001.png\", \"image3001.png\"\n\n    Args:\n        directory (str): The path to the directory containing PNG files to be renamed.\n\n    Returns:\n        None\n    \"\"\"\n", "test_code": "import re\nimport unittest\nimport os\nimport shutil\nimport tempfile\nfrom pathlib import Path\n\n\n\nclass TestRenameFiles(unittest.TestCase):\n\n    def setUp(self):\n        # Create a temporary directory for each test\n        self.test_dir = tempfile.mkdtemp()\n\n    def tearDown(self):\n        # Remove the temporary directory after each test\n        shutil.rmtree(self.test_dir)\n\n    def create_png_files(self, filenames):\n        for filename in filenames:\n            file_path = Path(self.test_dir) / filename\n            file_path.touch()  # Create an empty file\n\n    def test_basic_renaming(self):\n        # Test renaming in a basic scenario with simple filenames\n        filenames = [\"image1.png\", \"image2.png\", \"image3.png\"]\n        self.create_png_files(filenames)\n\n        rename_png_files_in_directory(self.test_dir)\n\n        expected_files = ['image1001.png', 'image2001.png', 'image3001.png']\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)\n\n    def test_reset_counter_for_different_base_names(self):\n        # Test that the counter resets for different base names\n        filenames = [\"image1.png\", \"picture1.png\", \"image2.png\", \"picture2.png\"]\n        self.create_png_files(filenames)\n\n        rename_png_files_in_directory(self.test_dir)\n\n        expected_files = ['image1001.png', 'image2001.png', 'picture1001.png', 'picture2001.png']\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)\n\n    def test_no_png_files(self):\n        # Test handling of directories with no PNG files\n        filenames = [\"file1.txt\", \"file2.jpg\"]\n        self.create_png_files(filenames)\n\n        rename_png_files_in_directory(self.test_dir)\n\n        expected_files = filenames  # No changes expected\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)\n\n    def test_empty_directory(self):\n        # Test handling of an empty directory\n        rename_png_files_in_directory(self.test_dir)\n        expected_files = []  # No files to rename\n        result_files = os.listdir(self.test_dir)\n        self.assertEqual(result_files, expected_files)\n\n    def test_files_with_existing_numbers(self):\n        # Test renaming files that already have numbers in their names\n        filenames = [\"file001.png\", \"file002.png\", \"file003.png\"]\n        self.create_png_files(filenames)\n\n        rename_png_files_in_directory(self.test_dir)\n\n        expected_files = ['file001001.png', 'file002001.png', 'file003001.png']\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)", "prompt": "please write a python function , the function signature as below def rename_png_files_in_directory(directory: str):\n    \"\"\"\n    Renames PNG files in a specified directory by appending a sequence number to each file.\n    The files are sorted alphabetically, and each base name is assigned sequential numbers.\n    For example:\n        director have three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\"\n        after renaming PNG files are \"image1001.png\", \"image2001.png\", \"image3001.png\"\n\n    Args:\n        directory (str): The path to the directory containing PNG files to be renamed.\n\n    Returns:\n        None\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n* @brief Renames PNG files in a specified directory by appending a sequence number to each file.\n* The files are sorted alphabetically, and each base name is assigned sequential numbers.\n* For example:\n*     If the directory has three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\",\n*     after renaming, the PNG files will be \"image1001.png\", \"image2001.png\", \"image3001.png\".\n*\n* @param directory The path to the directory containing PNG files to be renamed.\n*/\nvoid rename_files(const std::string& directory) {}", "test_code": "TEST_CASE(\"TestRenameFiles\", \"[rename_files]\") {\n    TempDir temp_dir;\n\n    SECTION(\"test_basic_renaming\") {\n        std::vector<std::string> filenames = {\"image1.png\", \"image2.png\", \"image3.png\"};\n        create_png_files(temp_dir.path, filenames);\n\n        rename_files(temp_dir.path.string());\n\n        std::vector<std::string> expected_files = {\"image1001.png\", \"image2001.png\", \"image3001.png\"};\n        std::vector<std::string> result_files;\n        for (const auto& entry : fs::directory_iterator(temp_dir.path)) {\n            result_files.push_back(entry.path().filename().string());\n        }\n        std::sort(result_files.begin(), result_files.end());\n\n        REQUIRE(result_files == expected_files);\n    }\n\n    SECTION(\"test_reset_counter_for_different_base_names\") {\n        std::vector<std::string> filenames = {\"image1.png\", \"picture1.png\", \"image2.png\", \"picture2.png\"};\n        create_png_files(temp_dir.path, filenames);\n\n        rename_files(temp_dir.path.string());\n\n        std::vector<std::string> expected_files = {\"image1001.png\", \"image2001.png\", \"picture1001.png\", \"picture2001.png\"};\n        std::vector<std::string> result_files;\n        for (const auto& entry : fs::directory_iterator(temp_dir.path)) {\n            result_files.push_back(entry.path().filename().string());\n        }\n        std::sort(result_files.begin(), result_files.end());\n\n        REQUIRE(result_files == expected_files);\n    }\n\n    SECTION(\"test_no_png_files\") {\n        std::vector<std::string> filenames = {\"file1.txt\", \"file2.jpg\"};\n        create_png_files(temp_dir.path, filenames);\n\n        rename_files(temp_dir.path.string());\n\n        std::vector<std::string> expected_files = filenames;\n        std::vector<std::string> result_files;\n        for (const auto& entry : fs::directory_iterator(temp_dir.path)) {\n            result_files.push_back(entry.path().filename().string());\n        }\n        std::sort(result_files.begin(), result_files.end());\n\n        REQUIRE(result_files == expected_files);\n    }\n\n    SECTION(\"test_empty_directory\") {\n        rename_files(temp_dir.path.string());\n\n        std::vector<std::string> expected_files = {};\n        std::vector<std::string> result_files;\n        for (const auto& entry : fs::directory_iterator(temp_dir.path)) {\n            result_files.push_back(entry.path().filename().string());\n        }\n\n        REQUIRE(result_files.empty());\n    }\n\n    SECTION(\"test_files_with_existing_numbers\") {\n        std::vector<std::string> filenames = {\"file001.png\", \"file002.png\", \"file003.png\"};\n        create_png_files(temp_dir.path, filenames);\n\n        rename_files(temp_dir.path.string());\n\n        std::vector<std::string> expected_files = {\"file001001.png\", \"file002001.png\", \"file003001.png\"};\n        std::vector<std::string> result_files;\n        for (const auto& entry : fs::directory_iterator(temp_dir.path)) {\n            result_files.push_back(entry.path().filename().string());\n        }\n        std::sort(result_files.begin(), result_files.end());\n\n        REQUIRE(result_files == expected_files);\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n* @brief Renames PNG files in a specified directory by appending a sequence number to each file.\n* The files are sorted alphabetically, and each base name is assigned sequential numbers.\n* For example:\n*     If the directory has three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\",\n*     after renaming, the PNG files will be \"image1001.png\", \"image2001.png\", \"image3001.png\".\n*\n* @param directory The path to the directory containing PNG files to be renamed.\n*/\nvoid rename_files(const std::string& directory) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Renames PNG files in a specified directory by appending a sequence number to each file.\n * The files are sorted alphabetically, and each base name is assigned sequential numbers.\n * For example:\n *   If the directory contains three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\",\n *   after renaming, the PNG files will be \"image1001.png\", \"image2001.png\", \"image3001.png\".\n *\n * @param directory The path to the directory containing PNG files to be renamed.\n */\npublic static void renameFiles(String directory) {\n\n }", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Rule\n    public TemporaryFolder tempFolder = new TemporaryFolder();\n    private Path testDir;\n\n    @Before\n    public void setUp() throws IOException {\n        this.testDir = tempFolder.newFolder().toPath(); // Create a new temporary directory\n    }\n\n    @After\n    public void tearDown() {\n        // TemporaryFolder will automatically delete the folder after the test\n    }\n\n    private void createPngFiles(List<String> filenames) throws IOException {\n        for (String filename : filenames) {\n            Path filePath = testDir.resolve(filename);\n            Files.createFile(filePath);  // Create an empty file\n        }\n    }\n\n    @Test\n    public void testBasicRenaming() throws IOException {\n        // Test renaming in a basic scenario with simple filenames\n        List<String> filenames = Arrays.asList(\"image1.png\", \"image2.png\", \"image3.png\");\n        createPngFiles(filenames);\n\n        renameFiles(testDir.toString());\n\n        List<String> expectedFiles = Arrays.asList(\"image1001.png\", \"image2001.png\", \"image3001.png\");\n        List<String> resultFiles = Files.list(testDir)\n                .map(Path::getFileName)\n                .map(Path::toString)\n                .sorted()\n                .collect(Collectors.toList());\n        assertEquals(expectedFiles, resultFiles);\n    }\n\n    @Test\n    public void testResetCounterForDifferentBaseNames() throws IOException {\n        // Test that the counter resets for different base names\n        List<String> filenames = Arrays.asList(\"image1.png\", \"picture1.png\", \"image2.png\", \"picture2.png\");\n        createPngFiles(filenames);\n\n        renameFiles(testDir.toString());\n\n        List<String> expectedFiles = Arrays.asList(\"image1001.png\", \"image2001.png\", \"picture1001.png\", \"picture2001.png\");\n        List<String> resultFiles = Files.list(testDir)\n                .map(Path::getFileName)\n                .map(Path::toString)\n                .sorted()\n                .collect(Collectors.toList());\n        assertEquals(expectedFiles, resultFiles);\n    }\n\n    @Test\n    public void testNoPngFiles() throws IOException {\n        // Test handling of directories with no PNG files\n        List<String> filenames = Arrays.asList(\"file1.txt\", \"file2.jpg\");\n        createPngFiles(filenames);\n\n        renameFiles(testDir.toString());\n\n        List<String> expectedFiles = filenames;  // No changes expected\n        List<String> resultFiles = Files.list(testDir)\n                .map(Path::getFileName)\n                .map(Path::toString)\n                .sorted()\n                .collect(Collectors.toList());\n        assertEquals(expectedFiles, resultFiles);\n    }\n\n    @Test\n    public void testEmptyDirectory() throws IOException {\n        // Test handling of an empty directory\n        renameFiles(testDir.toString());\n\n        List<String> expectedFiles = Arrays.asList();  // No files to rename\n        List<String> resultFiles = Files.list(testDir)\n                .map(Path::getFileName)\n                .map(Path::toString)\n                .collect(Collectors.toList());\n        assertEquals(expectedFiles, resultFiles);\n    }\n\n    @Test\n    public void testFilesWithExistingNumbers() throws IOException {\n        // Test renaming files that already have numbers in their names\n        List<String> filenames = Arrays.asList(\"file001.png\", \"file002.png\", \"file003.png\");\n        createPngFiles(filenames);\n\n        renameFiles(testDir.toString());\n\n        List<String> expectedFiles = Arrays.asList(\"file001001.png\", \"file002001.png\", \"file003001.png\");\n        List<String> resultFiles = Files.list(testDir)\n                .map(Path::getFileName)\n                .map(Path::toString)\n                .sorted()\n                .collect(Collectors.toList());\n        assertEquals(expectedFiles, resultFiles);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Renames PNG files in a specified directory by appending a sequence number to each file.\n * The files are sorted alphabetically, and each base name is assigned sequential numbers.\n * For example:\n *   If the directory contains three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\",\n *   after renaming, the PNG files will be \"image1001.png\", \"image2001.png\", \"image3001.png\".\n *\n * @param directory The path to the directory containing PNG files to be renamed.\n */\npublic static void renameFiles(String directory) {\n\n },package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 76, "code_type": "method", "original_language": "python", "file_path": "visual_graph_datasets\\8b98d9d4005ba97e83037b5a5cb4edd989106d91\\visual_graph_datasets\\util.py", "question_type": "Data processing and transformation", "summary": "Write a function to process a given multi-line string. The function should calculate the minimum indentation of all lines in the string and remove that indentation from each line, eliminating the extra indentation. Make sure that the relative indentation of the string is preserved.", "language_version_list": {"python": {"code_signature": "def remove_common_indentation(multiline_text: str) -> str:\n    \"\"\"\n    Removes the common leading indentation from each line in a given multi-line string,\n    preserving the relative indentation of the text.\n\n    Args:\n        multiline_text (str): The input string containing multiple lines.\n\n    Returns:\n        str: The sanitized string with common leading indentation removed.\n    \"\"\"", "test_code": "import unittest\n\nclass TestRemoveCommonIndentation(unittest.TestCase):\n\n    def test_empty_string(self):\n        # Testing edge case with an empty string\n        self.assertEqual(remove_common_indentation(\"\"), \"\", \"Should return an empty string\")\n\n    def test_single_line_string(self):\n        # Testing a single line with no indentation\n        self.assertEqual(remove_common_indentation(\"No indentation here\"), \"No indentation here\", \"Should return the same string as input\")\n\n    def test_multiple_lines_with_uniform_indentation(self):\n        # Testing basic logic with uniform indentation across multiple lines\n        input_text = \"    Line one\\n    Line two\\n    Line three\"\n        expected_output = \"Line one\\nLine two\\nLine three\"\n        self.assertEqual(remove_common_indentation(input_text), expected_output, \"Should remove common leading indentation\")\n\n    def test_multiple_lines_with_mixed_indentation(self):\n        # Testing lines with mixed indentation levels\n        input_text = \"  Line one\\n  Line two\\n  Line three\"\n        expected_output = \"Line one\\nLine two\\nLine three\"\n        self.assertEqual(remove_common_indentation(input_text), expected_output, \"Should remove the minimum common indentation\")\n\n", "prompt": "please write a python function , the function signature as below def remove_common_indentation(multiline_text: str) -> str:\n    \"\"\"\n    Removes the common leading indentation from each line in a given multi-line string,\n    preserving the relative indentation of the text.\n\n    Args:\n        multiline_text (str): The input string containing multiple lines.\n\n    Returns:\n        str: The sanitized string with common leading indentation removed.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n* @brief Removes the common leading indentation from each line in a given multi-line string,\n* preserving the relative indentation of the text.\n*\n* @param multiline_text The input string containing multiple lines.\n* @return The sanitized string with common leading indentation removed.\n*/\nstd::string remove_common_indentation(const std::string& multiline_text) {}", "test_code": "TEST_CASE(\"Test remove_common_indentation function\", \"[remove_common_indentation]\") {\n    SECTION(\"test_empty_string\") {\n        // Testing edge case with an empty string\n        CHECK(remove_common_indentation(\"\") == \"\");\n    }\n\n    SECTION(\"test_single_line_string\") {\n        // Testing a single line with no indentation\n        CHECK(remove_common_indentation(\"No indentation here\") == \"No indentation here\");\n    }\n\n    SECTION(\"test_multiple_lines_with_uniform_indentation\") {\n        // Testing basic logic with uniform indentation across multiple lines\n        std::string input_text = \"    Line one\\n    Line two\\n    Line three\";\n        std::string expected_output = \"Line one\\nLine two\\nLine three\";\n        CHECK(remove_common_indentation(input_text) == expected_output);\n    }\n\n    SECTION(\"test_multiple_lines_with_mixed_indentation\") {\n        // Testing lines with mixed indentation levels\n        std::string input_text = \"  Line one\\n  Line two\\n  Line three\";\n        std::string expected_output = \"Line one\\nLine two\\nLine three\";\n        CHECK(remove_common_indentation(input_text) == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n* @brief Removes the common leading indentation from each line in a given multi-line string,\n* preserving the relative indentation of the text.\n*\n* @param multiline_text The input string containing multiple lines.\n* @return The sanitized string with common leading indentation removed.\n*/\nstd::string remove_common_indentation(const std::string& multiline_text) {}", "addition_info": ""}, "java": {"code_signature": "/**\n* Removes the common leading indentation from each line in a given multi-line string,\n* preserving the relative indentation of the text.\n*\n* @param multilineText The input string containing multiple lines.\n* @return The sanitized string with common leading indentation removed.\n*/\npublic static String removeCommonIndentation(String multilineText) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static junit.framework.TestCase.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    /**\n     * Tests the edge case with an empty string.\n     */\n    @Test\n    public void testEmptyString() {\n        // Testing edge case with an empty string\n        assertEquals(\"Should return an empty string\", \"\", removeCommonIndentation(\"\"));\n    }\n\n    /**\n     * Tests a single line with no indentation.\n     */\n    @Test\n    public void testSingleLineString() {\n        // Testing a single line with no indentation\n        assertEquals(\"Should return the same string as input\", \"No indentation here\", removeCommonIndentation(\"No indentation here\"));\n    }\n\n    /**\n     * Tests basic logic with uniform indentation across multiple lines.\n     */\n    @Test\n    public void testMultipleLinesWithUniformIndentation() {\n        // Testing basic logic with uniform indentation across multiple lines\n        String inputText = \"    Line one\\n    Line two\\n    Line three\";\n        String expectedOutput = \"Line one\\nLine two\\nLine three\";\n        assertEquals(\"Should remove common leading indentation\", expectedOutput, removeCommonIndentation(inputText));\n    }\n\n    /**\n     * Tests lines with mixed indentation levels.\n     */\n    @Test\n    public void testMultipleLinesWithMixedIndentation() {\n        // Testing lines with mixed indentation levels\n        String inputText = \"  Line one\\n  Line two\\n  Line three\";\n        String expectedOutput = \"Line one\\nLine two\\nLine three\";\n        assertEquals(\"Should remove the minimum common indentation\", expectedOutput, removeCommonIndentation(inputText));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n* Removes the common leading indentation from each line in a given multi-line string,\n* preserving the relative indentation of the text.\n*\n* @param multilineText The input string containing multiple lines.\n* @return The sanitized string with common leading indentation removed.\n*/\npublic static String removeCommonIndentation(String multilineText) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 77, "code_type": "method", "original_language": "python", "file_path": "web-mit-public\\95604408158ee62d72348ac24b99f0deee119cb0\\add-files-by-date.py", "question_type": "File operations and I/O operation", "summary": "Formats the given timestamp (mtime) as a string, according to the specified format (the default format is '%a %b %d %I:%M:%S %p %z %Y'), and uses the system's local time zone.", "language_version_list": {"python": {"code_signature": "from typing import Optional\n\n\ndef format_timestamp_to_string(timestamp: float, date_format: Optional[str] = '%a %b %d %I:%M:%S %p %z %Y') -> str:\n    \"\"\"\n    Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n\n    Args:\n        timestamp (float): The time value representing the seconds since the epoch.\n        date_format (Optional[str]): The format string to use for formatting the timestamp.\n                                     Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n\n    Returns:\n        str: The formatted date and time string.\n    \"\"\"\n", "test_code": "import unittest\nfrom typing import Optional\n\nclass TestFormatTimestampToString(unittest.TestCase):\n    def test_basic_functionality(self):\n        \"\"\"Test basic functionality with a known timestamp.\"\"\"\n        timestamp = 1655364000.0  # Corresponds to Thu Jun 16 12:00:00 PM UTC 2022\n        # Assuming the local timezone is UTC\n        expected_date_str = 'Thu Jun 16 03:20:00 PM +0800 2022'\n        self.assertEqual(format_timestamp_to_string(timestamp), expected_date_str, \"Should correctly format the timestamp\")\n\n    def test_default_format(self):\n        \"\"\"Test using the default format string.\"\"\"\n        timestamp = 1655364000.0\n        expected_date_str = 'Thu Jun 16 03:20:00 PM +0800 2022'\n        self.assertEqual(format_timestamp_to_string(timestamp), expected_date_str, \"Default format should match the expected date string\")\n\n    def test_custom_format(self):\n        \"\"\"Test with a custom format string.\"\"\"\n        timestamp = 1655364000.0\n        custom_format = '%Y-%m-%d %H:%M:%S'\n        expected_date_str = '2022-06-16 15:20:00'\n        self.assertEqual(format_timestamp_to_string(timestamp, custom_format), expected_date_str, \"Should correctly format the timestamp using the custom format\")\n\n\n    def test_edge_case_boundary_value(self):\n        \"\"\"Test with an edge case timestamp (e.g., Unix epoch start).\"\"\"\n        timestamp = 0.0  # Unix epoch start\n        expected_date_str = 'Thu Jan 01 08:00:00 AM +0800 1970'\n        self.assertEqual(format_timestamp_to_string(timestamp), expected_date_str, \"Should correctly format the Unix epoch start time\")", "prompt": "please write a python function , the function signature as below from typing import Optional\n\n\ndef format_timestamp_to_string(timestamp: float, date_format: Optional[str] = '%a %b %d %I:%M:%S %p %z %Y') -> str:\n    \"\"\"\n    Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n\n    Args:\n        timestamp (float): The time value representing the seconds since the epoch.\n        date_format (Optional[str]): The format string to use for formatting the timestamp.\n                                     Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n\n    Returns:\n        str: The formatted date and time string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n* @brief Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n*\n* @param timestamp The time value representing the seconds since the epoch.\n* @param date_format The format string to use for formatting the timestamp.\n*                    Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n* @return The formatted date and time string.\n*/\nstd::string format_timestamp_to_string(double timestamp, std::optional<std::string> date_format = std::nullopt) {}\n", "test_code": "TEST_CASE(\"TestFormatTimestampToString\", \"[format_timestamp_to_string]\") {\n    SECTION(\"test_basic_functionality\") {\n        double timestamp = 1655364000.0; // Corresponds to Thu Jun 16 12:00:00 PM UTC 2022\n        std::string expected_date_str = \"Thu Jun 16 03:20:00 PM +0800 2022\";\n        REQUIRE(format_timestamp_to_string(timestamp) == expected_date_str);\n    }\n\n    SECTION(\"test_default_format\") {\n        double timestamp = 1655364000.0;\n        std::string expected_date_str = \"Thu Jun 16 03:20:00 PM +0800 2022\";\n        REQUIRE(format_timestamp_to_string(timestamp) == expected_date_str);\n    }\n\n    SECTION(\"test_custom_format\") {\n        double timestamp = 1655364000.0;\n        std::string custom_format = \"%Y-%m-%d %H:%M:%S\";\n        std::string expected_date_str = \"2022-06-16 15:20:00\";\n        REQUIRE(format_timestamp_to_string(timestamp, custom_format) == expected_date_str);\n    }\n\n    SECTION(\"test_edge_case_boundary_value\") {\n        double timestamp = 0.0; // Unix epoch start\n        std::string expected_date_str = \"Thu Jan 01 08:00:00 AM +0800 1970\";\n        REQUIRE(format_timestamp_to_string(timestamp) == expected_date_str);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n* @brief Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n*\n* @param timestamp The time value representing the seconds since the epoch.\n* @param date_format The format string to use for formatting the timestamp.\n*                    Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n* @return The formatted date and time string.\n*/\nstd::string format_timestamp_to_string(double timestamp, std::optional<std::string> date_format = std::nullopt) {}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n *\n * @param timestamp   The time value representing the seconds since the epoch.\n * @param dateFormat  The format string to use for formatting the timestamp.\n *                    Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n * @return            The formatted date and time string.\n */\npublic static String formatTimestampToString(long timestamp, String dateFormat) {\n\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.time.ZoneId;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    private static final ZoneId LOCAL_TZ = ZoneId.of(\"Asia/Singapore\"); // Assuming Asia/Singapore as the local timezone\n\n    @Test\n    public void testBasicFunctionality() {\n        long timestamp = 1655364000L; // Corresponds to Thu Jun 16 12:00:00 PM UTC 2022\n        String expectedDateStr = \"Thu Jun 16 03:20:00 PM +0800 2022\";\n        assertEquals(\"Should correctly format the timestamp\", expectedDateStr, formatTimestampToString(timestamp, null));\n    }\n\n    @Test\n    public void testDefaultFormat() {\n        long timestamp = 1655364000L;\n        String expectedDateStr = \"Thu Jun 16 03:20:00 PM +0800 2022\";\n        assertEquals(\"Default format should match the expected date string\", expectedDateStr, formatTimestampToString(timestamp, null));\n    }\n\n    @Test\n    public void testCustomFormat() {\n        long timestamp = 1655364000L;\n        String customFormat = \"%Y-%m-%d %H:%M:%S\";\n        String expectedDateStr = \"2022-06-16 15:20:00\";\n        assertEquals(\"Should correctly format the timestamp using the custom format\", expectedDateStr, formatTimestampToString(timestamp, customFormat));\n    }\n\n    @Test\n    public void testEdgeCaseBoundaryValue() {\n        long timestamp = 0L; // Unix epoch start\n        String expectedDateStr = \"Thu Jan 01 08:00:00 AM +0800 1970\";\n        assertEquals(\"Should correctly format the Unix epoch start time\", expectedDateStr, formatTimestampToString(timestamp, null));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n *\n * @param timestamp   The time value representing the seconds since the epoch.\n * @param dateFormat  The format string to use for formatting the timestamp.\n *                    Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n * @return            The formatted date and time string.\n */\npublic static String formatTimestampToString(long timestamp, String dateFormat) {\n\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 78, "code_type": "method", "original_language": "python", "file_path": "CITS5505-group-project\\9037447caf192eee5c5f834c986fbfa12777502a\\app\\models.py", "question_type": "Framework and library", "summary": "Convert Euler angles (roll, pitch, yaw) to a rotation matrix.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef euler_to_rotation_matrix(roll: float, pitch: float, yaw: float) -> np.array:\n    \"\"\"\n    Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n\n    Args:\n        roll (float): Rotation around the x-axis in degrees.\n        pitch (float): Rotation around the y-axis in degrees.\n        yaw (float): Rotation around the z-axis in degrees.\n\n    Returns:\n        np.array: A 3x3 rotation matrix.\n    \"\"\"\n", "test_code": "import unittest\nimport numpy as np\n\nclass TestEulerToRotationMatrix(unittest.TestCase):\n    def test_zero_rotation(self):\n        # Test with zero rotation for all axes\n        R = euler_to_rotation_matrix(0, 0, 0)\n        np.testing.assert_array_almost_equal(R, np.identity(3))\n\n    def test_rotation_about_x(self):\n        # Test rotation about the x-axis\n        R = euler_to_rotation_matrix(90, 0, 0)\n        expected = np.array([\n            [1, 0, 0],\n            [0, 0, -1],\n            [0, 1, 0]\n        ])\n        np.testing.assert_array_almost_equal(R, expected)\n\n    def test_rotation_about_y(self):\n        # Test rotation about the y-axis\n        R = euler_to_rotation_matrix(0, 90, 0)\n        expected = np.array([\n            [0, 0, 1],\n            [0, 1, 0],\n            [-1, 0, 0]\n        ])\n        np.testing.assert_array_almost_equal(R, expected)\n\n    def test_rotation_about_z(self):\n        # Test rotation about the z-axis\n        R = euler_to_rotation_matrix(0, 0, 90)\n        expected = np.array([\n            [0, -1, 0],\n            [1, 0, 0],\n            [0, 0, 1]\n        ])\n        np.testing.assert_array_almost_equal(R, expected)\n\n    def test_combined_rotation(self):\n        # Test combined rotation\n        R = euler_to_rotation_matrix(30, 45, 60)\n        # Expected model_answer_result manually calculated or verified via a reliable source\n        expected = np.array([[ 0.35355339, -0.5732233,   0.73919892], [ 0.61237244 , 0.73919892,  0.28033009], [-0.70710678 , 0.35355339,  0.61237244]])\n        np.testing.assert_array_almost_equal(R, np.array(expected), decimal=5)", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef euler_to_rotation_matrix(roll: float, pitch: float, yaw: float) -> np.array:\n    \"\"\"\n    Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n\n    Args:\n        roll (float): Rotation around the x-axis in degrees.\n        pitch (float): Rotation around the y-axis in degrees.\n        yaw (float): Rotation around the z-axis in degrees.\n\n    Returns:\n        np.array: A 3x3 rotation matrix.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n* Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n*\n* @param roll The rotation around the x-axis in degrees.\n* @param pitch The rotation around the y-axis in degrees.\n* @param yaw The rotation around the z-axis in degrees.\n*\n* @return A 3x3 rotation matrix.\n*/\nMatrix3f euler_to_rotation_matrix(float roll, float pitch, float yaw) {}", "test_code": "TEST_CASE(\"Test Euler to Rotation Matrix\") {\n    SECTION(\"Zero Rotation\") {\n        // Test with zero rotation for all axes\n        Matrix3f R = euler_to_rotation_matrix(0, 0, 0);\n        Matrix3f expected = Matrix3f::Identity();\n        REQUIRE_THAT(R, Catch::Approx(expected).epsilon(1e-6));\n    }\n\n    SECTION(\"Rotation About X\") {\n        // Test rotation about the x-axis\n        Matrix3f R = euler_to_rotation_matrix(90, 0, 0);\n        Matrix3f expected = Matrix3f::Zero();\n        expected << 1, 0, 0,\n                    0, 0, -1,\n                    0, 1, 0;\n        REQUIRE_THAT(R, Catch::Approx(expected).epsilon(1e-6));\n    }\n\n    SECTION(\"Rotation About Y\") {\n        // Test rotation about the y-axis\n        Matrix3f R = euler_to_rotation_matrix(0, 90, 0);\n        Matrix3f expected = Matrix3f::Zero();\n        expected << 0, 0, 1,\n                    0, 1, 0,\n                    -1, 0, 0;\n        REQUIRE_THAT(R, Catch::Approx(expected).epsilon(1e-6));\n    }\n\n    SECTION(\"Rotation About Z\") {\n        // Test rotation about the z-axis\n        Matrix3f R = euler_to_rotation_matrix(0, 0, 90);\n        Matrix3f expected = Matrix3f::Zero();\n        expected << 0, -1, 0,\n                    1, 0, 0,\n                    0, 0, 1;\n        REQUIRE_THAT(R, Catch::Approx(expected).epsilon(1e-6));\n    }\n\n    SECTION(\"Combined Rotation\") {\n        // Test combined rotation\n        Matrix3f R = euler_to_rotation_matrix(30, 45, 60);\n        Matrix3f expected = Matrix3f::Zero();\n        expected << 0.35355339, -0.5732233, 0.73919892,\n                    0.61237244, 0.73919892, 0.28033009,\n                    -0.70710678, 0.35355339, 0.61237244;\n        REQUIRE_THAT(R, Catch::Approx(expected).epsilon(1e-5));\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n* Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n*\n* @param roll The rotation around the x-axis in degrees.\n* @param pitch The rotation around the y-axis in degrees.\n* @param yaw The rotation around the z-axis in degrees.\n*\n* @return A 3x3 rotation matrix.\n*/\nMatrix3f euler_to_rotation_matrix(float roll, float pitch, float yaw) {}", "addition_info": ""}, "java": {"code_signature": "public static double[][] eulerToRotationMatrix(double roll, double pitch, double yaw) {\n    /**\n     * Converts Euler angles (roll, pitch, yaw) to a rotation matrix.\n     *\n     * @param roll  the rotation around the x-axis in degrees\n     * @param pitch the rotation around the y-axis in degrees\n     * @param yaw   the rotation around the z-axis in degrees\n     * @return a 3x3 rotation matrix\n     */\n}\n\nprivate static double[][] multiplyMatrices(double[][] a, double[][] b) {\n     /**\n     * Multiplies two matrices.\n     *\n     * @param a the first matrix\n     * @param b the second matrix\n     * @return the result of multiplying the two matrices\n     */\n}", "test_code": "import org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\npublic class Tester {\n\n    @Test\n    public void testZeroRotation() {\n        // Test with zero rotation for all axes\n        double[][] R = eulerToRotationMatrix(0, 0, 0);\n        double[][] expected = {\n            {1, 0, 0},\n            {0, 1, 0},\n            {0, 0, 1}\n        };\n        assertArrayEquals(expected, R, 1e-6);\n    }\n\n    @Test\n    public void testRotationAboutX() {\n        // Test rotation about the x-axis\n        double[][] R = eulerToRotationMatrix(90, 0, 0);\n        double[][] expected = {\n            {1, 0, 0},\n            {0, 0, -1},\n            {0, 1, 0}\n        };\n        assertArrayEquals(expected, R, 1e-6);\n    }\n\n    @Test\n    public void testRotationAboutY() {\n        // Test rotation about the y-axis\n        double[][] R = eulerToRotationMatrix(90, 0, 0);\n        double[][] expected = {\n            {0, 0, 1},\n            {0, 1, 0},\n            {-1, 0, 0}\n        };\n        assertArrayEquals(expected, R, 1e-6);\n    }\n\n    @Test\n    public void testRotationAboutZ() {\n        // Test rotation about the z-axis\n        double[][] R = eulerToRotationMatrix(0, 0, 90);\n        double[][] expected = {\n            {0, -1, 0},\n            {1, 0, 0},\n            {0, 0, 1}\n        };\n        assertArrayEquals(expected, R, 1e-6);\n    }\n\n    @Test\n    public void testCombinedRotation() {\n        // Test combined rotation\n        double[][] R = eulerToRotationMatrix(30, 45, 60);\n        double[][] expected = {\n            {0.35355339, -0.5732233, 0.73919892},\n            {0.61237244, 0.73919892, 0.28033009},\n            {-0.70710678, 0.35355339, 0.61237244}\n        };\n        assertArrayEquals(expected, R, 1e-5);\n    }\n}", "prompt": "please write a java function , the function signature as below public static double[][] eulerToRotationMatrix(double roll, double pitch, double yaw) {\n    /**\n     * Converts Euler angles (roll, pitch, yaw) to a rotation matrix.\n     *\n     * @param roll  the rotation around the x-axis in degrees\n     * @param pitch the rotation around the y-axis in degrees\n     * @param yaw   the rotation around the z-axis in degrees\n     * @return a 3x3 rotation matrix\n     */\n}\n\nprivate static double[][] multiplyMatrices(double[][] a, double[][] b) {\n     /**\n     * Multiplies two matrices.\n     *\n     * @param a the first matrix\n     * @param b the second matrix\n     * @return the result of multiplying the two matrices\n     */\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 79, "code_type": "method", "original_language": "python", "file_path": "FRC-MatchBot\\7e618246256c651fcef7dc303c81ddb4a61e6a4b\\utils.py", "question_type": "Data processing and transformation", "summary": "Generates a string based on the entered start and end dates. If the start date and end date are in the same month, only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you enter the start date and end date as,\"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\"\n", "language_version_list": {"python": {"code_signature": "def generate_date_range_string(start_date: str, end_date: str) -> str:\n    \"\"\"\n    Generates a string based on the entered start and end dates. If the start date and end date are in the same month, only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you enter the start date and end date as,\"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n\n    For example:\n        input:\n            start_date: 2023-08-01\n            end_date: 2023-08-15\n        output:\n            August 1 to 15, 2023\n\n    Args:\n        start_date (str): The start date in 'YYYY-MM-DD' format.\n        end_date (str): The end date in 'YYYY-MM-DD' format.\n\n    Returns:\n        str: A string representing the date range in a human-readable format.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestDateRangeString(unittest.TestCase):\n    def test_same_month(self):\n        # Test dates within the same month\n        result = generate_date_range_string(\"2023-08-01\", \"2023-08-15\")\n        self.assertEqual(result, \"August 1 to 15, 2023\")\n\n    def test_same_month_star_end(self):\n        # Test dates within the same month\n        result = generate_date_range_string(\"2023-08-01\", \"2023-08-31\")\n        self.assertEqual(result, \"August 1 to 31, 2023\")\n\n    def test_different_months_same_year(self):\n        # Test dates across different months within the same year\n        result = generate_date_range_string(\"2023-08-30\", \"2023-09-05\")\n        self.assertEqual(result, \"August 30, 2023 to September 5, 2023\")\n\n    def test_different_years(self):\n        # Test dates across different years\n        result = generate_date_range_string(\"2023-12-30\", \"2024-01-02\")\n        self.assertEqual(result, \"December 30, 2023 to January 2, 2024\")\n", "prompt": "please write a python function , the function signature as below def generate_date_range_string(start_date: str, end_date: str) -> str:\n    \"\"\"\n    Generates a string based on the entered start and end dates. If the start date and end date are in the same month, only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you enter the start date and end date as,\"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n\n    For example:\n        input:\n            start_date: 2023-08-01\n            end_date: 2023-08-15\n        output:\n            August 1 to 15, 2023\n\n    Args:\n        start_date (str): The start date in 'YYYY-MM-DD' format.\n        end_date (str): The end date in 'YYYY-MM-DD' format.\n\n    Returns:\n        str: A string representing the date range in a human-readable format.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n* @brief Generates a string based on the entered start and end dates. If the start date and end date are in the same month,\n* only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you\n* enter the start date and end date as \"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n*\n* Example:\n*     Input:\n*         start_date: 2023-08-01\n*         end_date: 2023-08-15\n*     Output:\n*         August 1 to 15, 2023\n*\n* @param start_date The start date in 'YYYY-MM-DD' format.\n* @param end_date The end date in 'YYYY-MM-DD' format.\n* @return A string representing the date range in a human-readable format.\n*/\nstd::string date_range_string(const std::string& start_date, const std::string& end_date) {}", "test_code": "TEST_CASE(\"Test date_range_string function\") {\n    SECTION(\"Test dates within the same month\") {\n        std::string result = date_range_string(\"2023-08-01\", \"2023-08-15\");\n        REQUIRE(result == \"August 1 to 15, 2023\");\n    }\n\n    SECTION(\"Test dates within the same month (start and end)\") {\n        std::string result = date_range_string(\"2023-08-01\", \"2023-08-31\");\n        REQUIRE(result == \"August 1 to 31, 2023\");\n    }\n\n    SECTION(\"Test dates across different months within the same year\") {\n        std::string result = date_range_string(\"2023-08-30\", \"2023-09-05\");\n        REQUIRE(result == \"August 30, 2023 to September 5, 2023\");\n    }\n\n    SECTION(\"Test dates across different years\") {\n        std::string result = date_range_string(\"2023-12-30\", \"2024-01-02\");\n        REQUIRE(result == \"December 30, 2023 to January 2, 2024\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n* @brief Generates a string based on the entered start and end dates. If the start date and end date are in the same month,\n* only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you\n* enter the start date and end date as \"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n*\n* Example:\n*     Input:\n*         start_date: 2023-08-01\n*         end_date: 2023-08-15\n*     Output:\n*         August 1 to 15, 2023\n*\n* @param start_date The start date in 'YYYY-MM-DD' format.\n* @param end_date The end date in 'YYYY-MM-DD' format.\n* @return A string representing the date range in a human-readable format.\n*/\nstd::string date_range_string(const std::string& start_date, const std::string& end_date) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Generates a string based on the entered start and end dates. If the start date and end date are in the same month,\n * only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you\n * enter the start date and end date as \"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n *\n * Example:\n *     Input:\n *         start_date: 2023-08-01\n *         end_date: 2023-08-15\n *     Output:\n *         August 1 to 15, 2023\n *\n * @param startDate The start date in 'YYYY-MM-DD' format.\n * @param endDate The end date in 'YYYY-MM-DD' format.\n * @return A string representing the date range in a human-readable format.\n * @throws IllegalArgumentException If the startDate or endDate are not in the correct format or if startDate is after endDate.\n */\npublic static String dateRangeString(String startDate, String endDate) throws IllegalArgumentException {\n\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\nimport java.text.ParseException;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testSameMonth() throws ParseException {\n        // Test dates within the same month\n        String result = dateRangeString(\"2023-08-01\", \"2023-08-15\");\n        assertEquals(\"August 1 to 15, 2023\", result);\n    }\n\n    @Test\n    public void testSameMonthStartToEnd() throws ParseException {\n        // Test dates within the same month\n        String result = dateRangeString(\"2023-08-01\", \"2023-08-31\");\n        assertEquals(\"August 1 to 31, 2023\", result);\n    }\n\n    @Test\n    public void testDifferentMonthsSameYear() throws ParseException {\n        // Test dates across different months within the same year\n        String result = dateRangeString(\"2023-08-30\", \"2023-09-05\");\n        assertEquals(\"August 30, 2023 to September 5, 2023\", result);\n    }\n\n    @Test\n    public void testDifferentYears() throws ParseException {\n        // Test dates across different years\n        String result = dateRangeString(\"2023-12-30\", \"2024-01-02\");\n        assertEquals(\"December 30, 2023 to January 2, 2024\", result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Generates a string based on the entered start and end dates. If the start date and end date are in the same month,\n * only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you\n * enter the start date and end date as \"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n *\n * Example:\n *     Input:\n *         start_date: 2023-08-01\n *         end_date: 2023-08-15\n *     Output:\n *         August 1 to 15, 2023\n *\n * @param startDate The start date in 'YYYY-MM-DD' format.\n * @param endDate The end date in 'YYYY-MM-DD' format.\n * @return A string representing the date range in a human-readable format.\n * @throws IllegalArgumentException If the startDate or endDate are not in the correct format or if startDate is after endDate.\n */\npublic static String dateRangeString(String startDate, String endDate) throws IllegalArgumentException {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 80, "code_type": "method", "original_language": "python", "file_path": "CFK_Delete_Python\\8f5ef0df4ab0a9af0b7ba178919200819eb18801\\CFKdownload_subprocesses.py", "question_type": "Data processing and transformation", "summary": "remove illegal characters from strings and handle spaces and empty characters to make the modified string comply with windows file name rules\n", "language_version_list": {"python": {"code_signature": "def sanitize_filename(filename: str) -> str:\n    \"\"\"\n    remove illegal characters from windows file path string\n\n    Args:\n        filename (str): The original filename string to be sanitized.\n\n    Returns:\n        str: A sanitized string that is safe to use as a Windows filename.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSanitizeFilename(unittest.TestCase):\n\n    def test_valid_filename(self):\n        self.assertEqual(sanitize_filename(\"valid_filename.txt\"), \"valid_filename.txt\")\n\n    def test_illegal_characters(self):\n        self.assertEqual(sanitize_filename(\"invalid<filename>.txt\"), \"invalid_filename_.txt\")\n        self.assertEqual(sanitize_filename(\"file/name:with*illegal|chars?.txt\"), \"file_name_with_illegal_chars_.txt\")\n\n\n    def test_long_filename(self):\n        long_filename = \"a\" * 300 + \".txt\"\n        sanitized_filename = sanitize_filename(long_filename)\n        self.assertEqual(len(sanitized_filename), 255)\n        self.assertEqual(sanitized_filename, \"a\" * 255)\n\n    def test_empty_filename(self):\n        self.assertEqual(sanitize_filename(\"\"), \"\")", "prompt": "please write a python function , the function signature as below def sanitize_filename(filename: str) -> str:\n    \"\"\"\n    remove illegal characters from windows file path string\n\n    Args:\n        filename (str): The original filename string to be sanitized.\n\n    Returns:\n        str: A sanitized string that is safe to use as a Windows filename.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "\n/**\n* @brief Remove illegal characters from Windows file path string.\n*\n* This function sanitizes a given filename by replacing illegal characters\n* with underscores and limiting the length of the filename to ensure it is\n* safe to use as a Windows filename.\n*\n* @param filename The original filename string to be sanitized.\n* @return A sanitized string that is safe to use as a Windows filename.\n*/\nstd::string sanitize_filename(const std::string& filename) {}", "test_code": "TEST_CASE(\"TestSanitizeFilename\", \"[sanitize_filename]\") {\n    SECTION(\"test_valid_filename\") {\n        REQUIRE(sanitize_filename(\"valid_filename.txt\") == \"valid_filename.txt\");\n    }\n\n    SECTION(\"test_illegal_characters\") {\n        REQUIRE(sanitize_filename(\"invalid<filename>.txt\") == \"invalid_filename_.txt\");\n        REQUIRE(sanitize_filename(\"file/name:with*illegal|chars?.txt\") == \"file_name_with_illegal_chars_.txt\");\n    }\n\n    SECTION(\"test_long_filename\") {\n        std::string long_filename = std::string(300, 'a') + \".txt\";\n        std::string sanitized_filename = sanitize_filename(long_filename);\n        REQUIRE(sanitized_filename.length() == 255);\n        REQUIRE(sanitized_filename == std::string(255, 'a'));\n    }\n\n    SECTION(\"test_empty_filename\") {\n        REQUIRE(sanitize_filename(\"\") == \"\");\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below \n/**\n* @brief Remove illegal characters from Windows file path string.\n*\n* This function sanitizes a given filename by replacing illegal characters\n* with underscores and limiting the length of the filename to ensure it is\n* safe to use as a Windows filename.\n*\n* @param filename The original filename string to be sanitized.\n* @return A sanitized string that is safe to use as a Windows filename.\n*/\nstd::string sanitize_filename(const std::string& filename) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Removes illegal characters from a Windows file path string.\n *\n * @param filename The original filename string to be sanitized.\n * @return A sanitized string that is safe to use as a Windows filename.\n */\npublic static String sanitizeFilename(String filename) {}", "test_code": "package org.real.temp;\n\nimport static junit.framework.TestCase.assertEquals;\nimport static org.real.temp.Answer.*;\nimport org.junit.Test;\npublic class Tester {\n\n    @Test\n    public void testValidFilename() {\n        assertEquals(\"valid_filename.txt\", sanitizeFilename(\"valid_filename.txt\"));\n    }\n\n    @Test\n    public void testIllegalCharacters() {\n        assertEquals(\"invalid_filename_.txt\", sanitizeFilename(\"invalid<filename>.txt\"));\n        assertEquals(\"file_name_with_illegal_chars_.txt\", sanitizeFilename(\"file/name:with*illegal|chars?.txt\"));\n    }\n\n    @Test\n    public void testLongFilename() {\n        String longFilename = \"a\".repeat(300) + \".txt\";\n        String sanitizedFilename = sanitizeFilename(longFilename);\n        assertEquals(255, sanitizedFilename.length());\n        assertEquals(\"a\".repeat(255), sanitizedFilename);\n    }\n\n    @Test\n    public void testEmptyFilename() {\n        assertEquals(\"\", sanitizeFilename(\"\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Removes illegal characters from a Windows file path string.\n *\n * @param filename The original filename string to be sanitized.\n * @return A sanitized string that is safe to use as a Windows filename.\n */\npublic static String sanitizeFilename(String filename) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 81, "code_type": "method", "original_language": "python", "file_path": "Programming\\065b625d489dc21248569f9af98e4c7f8502df7e\\AP-Comp-Codes\\04242023 Data Science\\Lesson 3\\crash.py", "question_type": "Algorithm and data structure", "summary": "Takes a list of numbers as input and finds the element in it that is closest to a specified target number.", "language_version_list": {"python": {"code_signature": "from typing import List, Union\n\n\ndef find_closest_element(target: Union[int, float], elements: List[Union[int, float]]) -> Union[int, float]:\n    \"\"\"\n    Finds and returns the element from the given list that is closest to the specified target value.\n\n    Args:\n        target (Union[int, float]): The target number to which we want to find the closest element.\n        elements (List[Union[int, float]]): A list of numerical elements from which the closest element is to be found.\n\n    Returns:\n        Union[int, float]: The element from the list that is closest to the target value.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFindClosestElement(unittest.TestCase):\n\n    def test_basic_functionality(self):\n        self.assertEqual(find_closest_element(5, [1, 3, 7, 8, 9]), 3,\n                         \"Should return 3 as it is the first closest element to 5\")\n\n    def test_exact_match(self):\n        self.assertEqual(find_closest_element(7, [1, 3, 7, 8, 9]), 7,\n                         \"Should return 7 as it exactly matches the target\")\n\n    def test_multiple_closest_values(self):\n        self.assertEqual(find_closest_element(5, [4, 6, 8, 9]), 4,\n                         \"Should return 4 as it is the first closest element to 5\")\n\n    def test_float_values(self):\n        self.assertEqual(find_closest_element(5.5, [1.1, 3.3, 7.7, 8.8]), 3.3,\n                         \"Should return 3.3 as it is the first closest element to 5.5\")\n", "prompt": "please write a python function , the function signature as below from typing import List, Union\n\n\ndef find_closest_element(target: Union[int, float], elements: List[Union[int, float]]) -> Union[int, float]:\n    \"\"\"\n    Finds and returns the element from the given list that is closest to the specified target value.\n\n    Args:\n        target (Union[int, float]): The target number to which we want to find the closest element.\n        elements (List[Union[int, float]]): A list of numerical elements from which the closest element is to be found.\n\n    Returns:\n        Union[int, float]: The element from the list that is closest to the target value.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds and returns the element from the given list that is closest to the specified target value.\n *\n * @param target The target number to which we want to find the closest element.\n * @param elements A list of numerical elements from which the closest element is to be found.\n * @return The element from the list that is closest to the target value.\n */\ndouble find_closest_element(double target, const std::vector<double>& elements) {}", "test_code": "TEST_CASE(\"TestFindClosestElement\", \"[find_closest_element]\") {\n    SECTION(\"test_basic_functionality\") {\n        REQUIRE(find_closest_element(5, {1, 3, 7, 8, 9}) == Approx(3));\n        CHECK(\"Should return 3 as it is the first closest element to 5\");\n    }\n\n    SECTION(\"test_exact_match\") {\n        REQUIRE(find_closest_element(7, {1, 3, 7, 8, 9}) == Approx(7));\n        CHECK(\"Should return 7 as it exactly matches the target\");\n    }\n\n    SECTION(\"test_multiple_closest_values\") {\n        REQUIRE(find_closest_element(5, {4, 6, 8, 9}) == Approx(4));\n        CHECK(\"Should return 4 as it is the first closest element to 5\");\n    }\n\n    SECTION(\"test_float_values\") {\n        REQUIRE(find_closest_element(5.5, {1.1, 3.3, 7.7, 8.8}) == Approx(3.3));\n        CHECK(\"Should return 3.3 as it is the first closest element to 5.5\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds and returns the element from the given list that is closest to the specified target value.\n *\n * @param target The target number to which we want to find the closest element.\n * @param elements A list of numerical elements from which the closest element is to be found.\n * @return The element from the list that is closest to the target value.\n */\ndouble find_closest_element(double target, const std::vector<double>& elements) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds and returns the element from the given list that is closest to the specified target value.\n *\n * @param target   The target number to which we want to find the closest element.\n * @param elements A list of numerical elements from which the closest element is to be found.\n * @return The element from the list that is closest to the target value.\n */\npublic static Number findClosestElement(Number target, List<Number> elements) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.List;\n\nimport static junit.framework.TestCase.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    /**\n     * Tests basic functionality of the findClosestElement method.\n     */\n    @Test\n    public void testBasicFunctionality() {\n        assertEquals(\"Should return 3 as it is the first closest element to 5\",\n                3, findClosestElement(5, List.of(1, 3, 7, 8, 9)).intValue());\n    }\n\n    /**\n     * Tests the exact match scenario for the findClosestElement method.\n     */\n    @Test\n    public void testExactMatch() {\n        assertEquals(\"Should return 7 as it exactly matches the target\",\n                7, findClosestElement(7, List.of(1, 3, 7, 8, 9)).intValue());\n    }\n\n    /**\n     * Tests multiple closest values scenario for the findClosestElement method.\n     */\n    @Test\n    public void testMultipleClosestValues() {\n        assertEquals(\"Should return 4 as it is the first closest element to 5\",\n                4, findClosestElement(5, List.of(4, 6, 8, 9)).intValue());\n    }\n\n    /**\n     * Tests float values scenario for the findClosestElement method.\n     */\n    @Test\n    public void testFloatValues() {\n        assertEquals(\"Should return 3.3 as it is the first closest element to 5.5\",\n                3.3, findClosestElement(5.5, List.of(1.1, 3.3, 7.7, 8.8)).doubleValue(), 0.001);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Finds and returns the element from the given list that is closest to the specified target value.\n *\n * @param target   The target number to which we want to find the closest element.\n * @param elements A list of numerical elements from which the closest element is to be found.\n * @return The element from the list that is closest to the target value.\n */\npublic static Number findClosestElement(Number target, List<Number> elements) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 82, "code_type": "method", "original_language": "python", "file_path": "pypatchy\\16897095606bb2884765cc207c550655e5a65b30\\pypatchy\\design\\design_yield.py", "question_type": "Algorithm and data structure", "summary": "find the unique cycles from the graph, classify them according to cycle size, and return a dictionary, the key of which is the cycle size, and the value is a list of cycles of corresponding size. The function also provides an option to filter out loops that visit the same node multiple times and ensure that each loop contains at least three nodes\n", "language_version_list": {"python": {"code_signature": "from typing import List, Dict, Any\n\nimport networkx as nx\n\n\nclass Graph:\n    def __init__(self, edges):\n        self.graph = nx.DiGraph(edges)\n\n    def cycles_by_size(self, filter_repeat_nodes=True) -> Dict[Any, List]:\n        \"\"\"\n        Finds all unique cycles in the graph that are larger than size 2, optionally filtering out cycles with repeated nodes.\n\n        Args:\n            filter_repeat_nodes (bool): If True, filters out cycles where any node appears more than once.\n\n        Returns:\n            Dict[int, List[nx.Graph]]: A dictionary mapping each cycle size to a list of subgraph objects representing\n                each unique cycle of that size.\n        \"\"\"\n", "test_code": "import unittest\nfrom collections import defaultdict\n\n\nclass TestGraphCycles(unittest.TestCase):\n    def test_empty_graph(self):\n        g = Graph([])\n        self.assertEqual(g.cycles_by_size(), defaultdict(list),\n                         \"Failed: Expected an empty defaultdict for an empty graph.\")\n\n    def test_graph_no_cycles(self):\n        g = Graph([(1, 2), (2, 3)])\n        self.assertEqual(g.cycles_by_size(), defaultdict(list),\n                         \"Failed: Expected an empty defaultdict for a graph with no cycles.\")\n\n    def test_simple_cycles(self):\n        g = Graph([(1, 2), (2, 3), (3, 1)])\n        results = g.cycles_by_size()\n        self.assertEqual(len(results[3]), 1, \"Failed: Expected one cycle of length 3.\")\n        self.assertIn(list(results[3][0].nodes()), [[1, 2, 3]], \"Failed: Expected cycle nodes to match.\")\n\n    def test_multiple_cycles(self):\n        g = Graph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1)])\n        results = g.cycles_by_size()\n        self.assertEqual(len(results[3]), 1, \"Failed: Expected one cycle of length 3.\")\n        self.assertEqual(len(results[4]), 1, \"Failed: Expected one cycle of length 4.\")\n", "prompt": "please write a python function , the function signature as below from typing import List, Dict, Any\n\nimport networkx as nx\n\n\nclass Graph:\n    def __init__(self, edges):\n        self.graph = nx.DiGraph(edges)\n\n    def cycles_by_size(self, filter_repeat_nodes=True) -> Dict[Any, List]:\n        \"\"\"\n        Finds all unique cycles in the graph that are larger than size 2, optionally filtering out cycles with repeated nodes.\n\n        Args:\n            filter_repeat_nodes (bool): If True, filters out cycles where any node appears more than once.\n\n        Returns:\n            Dict[int, List[nx.Graph]]: A dictionary mapping each cycle size to a list of subgraph objects representing\n                each unique cycle of that size.\n        \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 83, "code_type": "method", "original_language": "python", "file_path": "Fragmented\\84aa0d8cfc9af1623cb9edb3d541eac39ec47d10\\renpy-8.1.3-sdk\\Fragmented\\game\\test_combat_281.py", "question_type": "Algorithm and data structure", "summary": "Shift the list elements right one position in a loop: move the first element of the list to the end, and move the remaining elements forward one position in turn.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef rotate_list_elements(elements: List[int]) -> List[int]:\n    \"\"\"\n    Rotate the elements of the list to the left by one position. The first element\n    is moved to the end of the list, and all other elements are shifted one position to the left.\n\n    Args:\n        elements (List[int]): A list of integers to be rotated.\n\n    Returns:\n        List[int]: The rotated list with elements shifted to the left by one position.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestRotateListElements(unittest.TestCase):\n\n    def test_basic_rotation(self):\n        self.assertEqual(rotate_list_elements([1, 2, 3, 4]), [2, 3, 4, 1], \"Should rotate the list elements correctly\")\n\n    def test_single_element_list(self):\n        self.assertEqual(rotate_list_elements([10]), [10], \"Single element list should remain unchanged\")\n\n    def test_empty_list(self):\n        self.assertEqual(rotate_list_elements([]), [], \"Empty list should remain unchanged\")\n\n    def test_two_element_list(self):\n        self.assertEqual(rotate_list_elements([5, 9]), [9, 5], \"Should correctly rotate a two-element list\")\n\n    def test_large_list(self):\n        large_list = list(range(1, 1001))\n        rotated_list = rotate_list_elements(large_list)\n        self.assertEqual(rotated_list, list(range(2, 1001)) + [1], \"Should correctly rotate a large list\")\n\n\n\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef rotate_list_elements(elements: List[int]) -> List[int]:\n    \"\"\"\n    Rotate the elements of the list to the left by one position. The first element\n    is moved to the end of the list, and all other elements are shifted one position to the left.\n\n    Args:\n        elements (List[int]): A list of integers to be rotated.\n\n    Returns:\n        List[int]: The rotated list with elements shifted to the left by one position.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Rotates the elements of a vector to the left by one position.\n *\n * This function takes a vector of integers and shifts all elements one position \n * to the left. The first element is moved to the end of the vector.\n *\n * @param elements A vector of integers to be rotated.\n * @return A new vector with elements rotated to the left by one position.\n */\nstd::vector<int> rotate_vector_elements(const std::vector<int>& elements) {}", "test_code": "TEST_CASE(\"Test Rotate Vector Elements\", \"[rotate_vector_elements]\") {\n    SECTION(\"Basic Rotation\") {\n        REQUIRE(rotate_vector_elements({1, 2, 3, 4}) == std::vector<int>({2, 3, 4, 1}));\n    }\n\n    SECTION(\"Single Element List\") {\n        REQUIRE(rotate_vector_elements({10}) == std::vector<int>({10}));\n    }\n\n    SECTION(\"Empty List\") {\n        REQUIRE(rotate_vector_elements({}) == std::vector<int>({}));\n    }\n\n    SECTION(\"Two Element List\") {\n        REQUIRE(rotate_vector_elements({5, 9}) == std::vector<int>({9, 5}));\n    }\n\n    SECTION(\"Large List\") {\n        std::vector<int> large_list;\n        for (int i = 1; i <= 1000; ++i) {\n            large_list.push_back(i);\n        }\n        std::vector<int> rotated_list = rotate_vector_elements(large_list);\n        std::vector<int> expected_list(large_list.begin() + 1, large_list.end());\n        expected_list.push_back(large_list.front());\n\n        REQUIRE(rotated_list == expected_list);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Rotates the elements of a vector to the left by one position.\n *\n * This function takes a vector of integers and shifts all elements one position \n * to the left. The first element is moved to the end of the vector.\n *\n * @param elements A vector of integers to be rotated.\n * @return A new vector with elements rotated to the left by one position.\n */\nstd::vector<int> rotate_vector_elements(const std::vector<int>& elements) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Rotate the elements of the list to the left by one position. The first element\n * is moved to the end of the list, and all other elements are shifted one position to the left.\n *\n * @param elements A list of integers to be rotated.\n * @return The rotated list with elements shifted to the left by one position.\n */\npublic static List<Integer> rotateListElements(List<Integer> elements) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static junit.framework.TestCase.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testBasicRotation() {\n        List<Integer> originalList = new ArrayList<>(Arrays.asList(1, 2, 3, 4));\n        List<Integer> expectedList = new ArrayList<>(Arrays.asList(2, 3, 4, 1));\n        assertEquals(\"Should rotate the list elements correctly\", expectedList, rotateListElements(originalList));\n    }\n\n    @Test\n    public void testSingleElementList() {\n        List<Integer> originalList = new ArrayList<>(Arrays.asList(10));\n        List<Integer> expectedList = new ArrayList<>(Arrays.asList(10));\n        assertEquals(\"Single element list should remain unchanged\", expectedList, rotateListElements(originalList));\n    }\n\n    @Test\n    public void testEmptyList() {\n        List<Integer> originalList = new ArrayList<>();\n        List<Integer> expectedList = new ArrayList<>();\n        assertEquals(\"Empty list should remain unchanged\", expectedList, rotateListElements(originalList));\n    }\n\n    @Test\n    public void testTwoElementList() {\n        List<Integer> originalList = new ArrayList<>(Arrays.asList(5, 9));\n        List<Integer> expectedList = new ArrayList<>(Arrays.asList(9, 5));\n        assertEquals(\"Should correctly rotate a two-element list\", expectedList, rotateListElements(originalList));\n    }\n\n    @Test\n    public void testLargeList() {\n        List<Integer> largeList = new ArrayList<>();\n        for (int i = 1; i <= 1000; i++) {\n            largeList.add(i);\n        }\n        List<Integer> expectedList = new ArrayList<>(largeList.subList(1, largeList.size()));\n        expectedList.add(largeList.get(0));\n        assertEquals(\"Should correctly rotate a large list\", expectedList, rotateListElements(largeList));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Rotate the elements of the list to the left by one position. The first element\n * is moved to the end of the list, and all other elements are shifted one position to the left.\n *\n * @param elements A list of integers to be rotated.\n * @return The rotated list with elements shifted to the left by one position.\n */\npublic static List<Integer> rotateListElements(List<Integer> elements) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 84, "code_type": "method", "original_language": "python", "file_path": "NeetCode\\822d5781a0d703330ae1940fa2a9c8cbc3b3717a\\sliding_window\\minimum_window_substring.py", "question_type": "Algorithm and data structure", "summary": "Write a function that takes two strings, s and t, and returns the smallest substring in s that contains all the characters in t. If there are multiple such substrings, return any one of them. If no such substring exists, return an empty string.", "language_version_list": {"python": {"code_signature": "from collections import Counter\nfrom typing import Optional\n\n\ndef find_min_window_substring(source: str, target: str) -> Optional[str]:\n    \"\"\"\n    Finds the smallest window in the source string that contains all characters of the target string.\n\n    Args:\n        source (str): The source string in which to search for the window.\n        target (str): The target string containing the characters to be matched.\n\n    Returns:\n        Optional[str]: The smallest window in the source string that contains all characters of the target string.\n                       Returns an empty string if no such window exists.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFindMinWindowSubstring(unittest.TestCase):\n\n    def test_empty_source_string(self):\n        # Test with an empty source string\n        self.assertEqual(find_min_window_substring(\"\", \"abc\"), \"\", \"Should return an empty string when source is empty\")\n\n    def test_empty_target_string(self):\n        # Test with an empty target string\n        self.assertEqual(find_min_window_substring(\"abc\", \"\"), \"\", \"Should return an empty string when target is empty\")\n\n    def test_no_valid_window(self):\n        # Test when there is no valid window\n        self.assertEqual(find_min_window_substring(\"abcdef\", \"xyz\"), \"\",\n                         \"Should return an empty string when no valid window exists\")\n\n    def test_exact_match_window(self):\n        # Test when the entire source string is the exact match\n        self.assertEqual(find_min_window_substring(\"abcd\", \"abcd\"), \"abcd\",\n                         \"Should return the entire string when it is an exact match\")\n\n    def test_minimal_valid_window(self):\n        # Test with a minimal valid window case\n        self.assertEqual(find_min_window_substring(\"ADOBECODEBANC\", \"ABC\"), \"BANC\",\n                         \"Should return 'BANC' as the smallest window containing all characters of 'ABC'\")\n\n\n", "prompt": "please write a python function , the function signature as below from collections import Counter\nfrom typing import Optional\n\n\ndef find_min_window_substring(source: str, target: str) -> Optional[str]:\n    \"\"\"\n    Finds the smallest window in the source string that contains all characters of the target string.\n\n    Args:\n        source (str): The source string in which to search for the window.\n        target (str): The target string containing the characters to be matched.\n\n    Returns:\n        Optional[str]: The smallest window in the source string that contains all characters of the target string.\n                       Returns an empty string if no such window exists.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds the smallest window in the source string that contains all characters of the target string.\n *\n * This function searches for the smallest substring in the source string that includes \n * all characters present in the target string.\n *\n * @param source The source string in which to search for the window.\n * @param target The target string containing the characters to be matched.\n * @return The smallest window in the source string that contains all characters of the target string.\n *         Returns an empty string if no such window exists.\n */\nstd::string find_min_window_substring(const std::string& source, const std::string& target) {}\n", "test_code": "TEST_CASE(\"Test find_min_window_substring\") {\n    SECTION(\"Empty source string\") {\n        REQUIRE(find_min_window_substring(\"\", \"abc\") == \"\");\n        // Should return an empty string when source is empty\n    }\n\n    SECTION(\"Empty target string\") {\n        REQUIRE(find_min_window_substring(\"abc\", \"\") == \"\");\n        // Should return an empty string when target is empty\n    }\n\n    SECTION(\"No valid window\") {\n        REQUIRE(find_min_window_substring(\"abcdef\", \"xyz\") == \"\");\n        // Should return an empty string when no valid window exists\n    }\n\n    SECTION(\"Exact match window\") {\n        REQUIRE(find_min_window_substring(\"abcd\", \"abcd\") == \"abcd\");\n        // Should return the entire string when it is an exact match\n    }\n\n    SECTION(\"Minimal valid window\") {\n        REQUIRE(find_min_window_substring(\"ADOBECODEBANC\", \"ABC\") == \"BANC\");\n        // Should return 'BANC' as the smallest window containing all characters of 'ABC'\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds the smallest window in the source string that contains all characters of the target string.\n *\n * This function searches for the smallest substring in the source string that includes \n * all characters present in the target string.\n *\n * @param source The source string in which to search for the window.\n * @param target The target string containing the characters to be matched.\n * @return The smallest window in the source string that contains all characters of the target string.\n *         Returns an empty string if no such window exists.\n */\nstd::string find_min_window_substring(const std::string& source, const std::string& target) {}\n", "addition_info": ""}, "java": {"code_signature": "    /**\n * Finds the smallest window in the source string that contains all characters of the target string.\n *\n * @param source The source string in which to search for the window.\n * @param target The target string containing the characters to be matched.\n * @return The smallest window in the source string that contains all characters of the target string.\n *         Returns an empty string if no such window exists.\n */\n public static String findMinWindowSubstring(String source, String target) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    /**\n     * Tests the method findMinWindowSubstring with an empty source string.\n     */\n    @Test\n    public void testEmptySourceString() {\n        // Test with an empty source string\n        assertEquals(\"Should return an empty string when source is empty\",\n                \"\",\n                findMinWindowSubstring(\"\", \"abc\"));\n    }\n\n    /**\n     * Tests the method findMinWindowSubstring with an empty target string.\n     */\n    @Test\n    public void testEmptyTargetString() {\n        // Test with an empty target string\n        assertEquals(\"Should return an empty string when target is empty\",\n                \"\",\n                findMinWindowSubstring(\"abc\", \"\"));\n    }\n\n    /**\n     * Tests the method findMinWindowSubstring when there is no valid window.\n     */\n    @Test\n    public void testNoValidWindow() {\n        // Test when there is no valid window\n        assertEquals(\"Should return an empty string when no valid window exists\",\n                \"\",\n                findMinWindowSubstring(\"abcdef\", \"xyz\"));\n    }\n\n    /**\n     * Tests the method findMinWindowSubstring when the entire source string is the exact match.\n     */\n    @Test\n    public void testExactMatchWindow() {\n        // Test when the entire source string is the exact match\n        assertEquals(\"Should return the entire string when it is an exact match\",\n                \"abcd\",\n                findMinWindowSubstring(\"abcd\", \"abcd\"));\n    }\n\n    /**\n     * Tests the method findMinWindowSubstring with a minimal valid window case.\n     */\n    @Test\n    public void testMinimalValidWindow() {\n        // Test with a minimal valid window case\n        assertEquals(\"Should return 'BANC' as the smallest window containing all characters of 'ABC'\",\n                \"BANC\",\n                findMinWindowSubstring(\"ADOBECODEBANC\", \"ABC\"));\n    }\n}", "prompt": "please write a java function , the function signature as below     /**\n * Finds the smallest window in the source string that contains all characters of the target string.\n *\n * @param source The source string in which to search for the window.\n * @param target The target string containing the characters to be matched.\n * @return The smallest window in the source string that contains all characters of the target string.\n *         Returns an empty string if no such window exists.\n */\n public static String findMinWindowSubstring(String source, String target) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 85, "code_type": "method", "original_language": "python", "file_path": "dive-map\\a857ae4735b9e1616258de48faa9b8a8d5142109\\mapper.py", "question_type": "Data processing and transformation", "summary": "Uses the first valid value in the specified column to fill the pandas dataframe with the missing value for that column", "language_version_list": {"python": {"code_signature": "import pandas\nimport pandas as pd\n\n\ndef fill_missing_with_first_valid(df: pandas.DataFrame, column_name: str) -> pd.DataFrame:\n    \"\"\"\n    Fills missing values in the specified column of the DataFrame with the first valid value in that column.\n    Args:\n        df (pandas.DataFrame): The pandas DataFrame.\n        column_name (str): The name of the column to fill missing values.\n\n    Returns:\n        pd.DataFrame: The DataFrame with missing values filled.\n    \"\"\"\n", "test_code": "import unittest\n\nimport pandas as pd\n\n\nclass TestFillMissingWithFirstValid(unittest.TestCase):\n\n    def test_basic_filling(self):\n        df = pd.DataFrame({'A': [1, None, 3, None], 'B': ['foo', 'bar', None, 'baz']})\n        result = fill_missing_with_first_valid(df, 'B')\n        expected = pd.DataFrame({'A': [1, None, 3, None], 'B': ['foo', 'bar', 'foo', 'baz']})\n        pd.testing.assert_frame_equal(result, expected)\n\n    def test_no_missing_values(self):\n        df = pd.DataFrame({'A': [1, 2, 3], 'B': ['foo', 'bar', 'baz']})\n        result = fill_missing_with_first_valid(df, 'B')\n        expected = pd.DataFrame({'A': [1, 2, 3], 'B': ['foo', 'bar', 'baz']})\n        pd.testing.assert_frame_equal(result, expected)\n\n\n    def test_single_valid_value(self):\n        df = pd.DataFrame({'A': [1, None, None, 4], 'B': [None, 'bar', None, None]})\n        result = fill_missing_with_first_valid(df, 'B')\n        expected = pd.DataFrame({'A': [1, None, None, 4], 'B': ['bar', 'bar', 'bar', 'bar']})\n        pd.testing.assert_frame_equal(result, expected)\n\n    def test_multiple_valid_values(self):\n        df = pd.DataFrame({'A': [1, None, 3, 4], 'B': [None, 'bar', 'foo', None]})\n        result = fill_missing_with_first_valid(df, 'B')\n        expected = pd.DataFrame({'A': [1, None, 3, 4], 'B': ['bar', 'bar', 'foo', 'bar']})\n        pd.testing.assert_frame_equal(result, expected)\n", "prompt": "please write a python function , the function signature as below import pandas\nimport pandas as pd\n\n\ndef fill_missing_with_first_valid(df: pandas.DataFrame, column_name: str) -> pd.DataFrame:\n    \"\"\"\n    Fills missing values in the specified column of the DataFrame with the first valid value in that column.\n    Args:\n        df (pandas.DataFrame): The pandas DataFrame.\n        column_name (str): The name of the column to fill missing values.\n\n    Returns:\n        pd.DataFrame: The DataFrame with missing values filled.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 86, "code_type": "method", "original_language": "python", "file_path": "HandwrittenLaTeXRecognition\\7fbbeacae63d438ed81e3f97ebb0fefadc6e4a70\\data_formatting.py", "question_type": "Data processing and transformation", "summary": "using bresenham, calculate the coordinates of all integer points on the line from point A to point B\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef bresenham_line(x1: int, y1: int, x2: int, y2: int) -> List[tuple]:\n    \"\"\"\n    Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n\n    Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n    It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n    determine which points should be rasterized to represent the line.\n\n    Args:\n        x1 (int): The x-coordinate of the starting point of the line.\n        y1 (int): The y-coordinate of the starting point of the line.\n        x2 (int): The x-coordinate of the ending point of the line.\n        y2 (int): The y-coordinate of the ending point of the line.\n\n    Returns:\n        list of tuples: A list where each tuple contains the x and y coordinates of a point on the line.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestBresenhamLineAlgorithm(unittest.TestCase):\n    def test_horizontal_line(self):\n        self.assertEqual(bresenham_line(1, 5, 5, 5), [(1, 5), (2, 5), (3, 5), (4, 5), (5, 5)])\n\n    def test_vertical_line(self):\n        self.assertEqual(bresenham_line(3, 2, 3, 6), [(3, 2), (3, 3), (3, 4), (3, 5), (3, 6)])\n\n    def test_diagonal_line(self):\n        self.assertEqual(bresenham_line(2, 2, 6, 6), [(2, 2), (3, 3), (4, 4), (5, 5), (6, 6)])\n\n    def test_steep_slope(self):\n        self.assertEqual(bresenham_line(1, 1, 4, 6), [(1, 1), (2, 2), (2, 3), (3, 4), (3, 5), (4, 6)])\n\n    def test_negative_slope(self):\n        self.assertEqual(bresenham_line(5, 1, 1, 5), [(5, 1), (4, 2), (3, 3), (2, 4), (1, 5)])\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef bresenham_line(x1: int, y1: int, x2: int, y2: int) -> List[tuple]:\n    \"\"\"\n    Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n\n    Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n    It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n    determine which points should be rasterized to represent the line.\n\n    Args:\n        x1 (int): The x-coordinate of the starting point of the line.\n        y1 (int): The y-coordinate of the starting point of the line.\n        x2 (int): The x-coordinate of the ending point of the line.\n        y2 (int): The y-coordinate of the ending point of the line.\n\n    Returns:\n        list of tuples: A list where each tuple contains the x and y coordinates of a point on the line.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param x1 The x-coordinate of the starting point of the line.\n * @param y1 The y-coordinate of the starting point of the line.\n * @param x2 The x-coordinate of the ending point of the line.\n * @param y2 The y-coordinate of the ending point of the line.\n * @return A vector where each pair contains the x and y coordinates of a point on the line.\n */\nstd::vector<std::pair<int, int>> bresenham_line(int x1, int y1, int x2, int y2) {}", "test_code": "TEST_CASE(\"Test Bresenham Line Algorithm\", \"[Bresenham]\") {\n    SECTION(\"Horizontal Line\") {\n        std::vector<std::pair<int, int>> expected = {{1, 5}, {2, 5}, {3, 5}, {4, 5}, {5, 5}};\n        REQUIRE(bresenham_line(1, 5, 5, 5) == expected);\n    }\n\n    SECTION(\"Vertical Line\") {\n        std::vector<std::pair<int, int>> expected = {{3, 2}, {3, 3}, {3, 4}, {3, 5}, {3, 6}};\n        REQUIRE(bresenham_line(3, 2, 3, 6) == expected);\n    }\n\n    SECTION(\"Diagonal Line\") {\n        std::vector<std::pair<int, int>> expected = {{2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}};\n        REQUIRE(bresenham_line(2, 2, 6, 6) == expected);\n    }\n\n    SECTION(\"Steep Slope\") {\n        std::vector<std::pair<int, int>> expected = {{1, 1}, {2, 2}, {2, 3}, {3, 4}, {3, 5}, {4, 6}};\n        REQUIRE(bresenham_line(1, 1, 4, 6) == expected);\n    }\n\n    SECTION(\"Negative Slope\") {\n        std::vector<std::pair<int, int>> expected = {{5, 1}, {4, 2}, {3, 3}, {2, 4}, {1, 5}};\n        REQUIRE(bresenham_line(5, 1, 1, 5) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param x1 The x-coordinate of the starting point of the line.\n * @param y1 The y-coordinate of the starting point of the line.\n * @param x2 The x-coordinate of the ending point of the line.\n * @param y2 The y-coordinate of the ending point of the line.\n * @return A vector where each pair contains the x and y coordinates of a point on the line.\n */\nstd::vector<std::pair<int, int>> bresenham_line(int x1, int y1, int x2, int y2) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param x1 The x-coordinate of the starting point of the line.\n * @param y1 The y-coordinate of the starting point of the line.\n * @param x2 The x-coordinate of the ending point of the line.\n * @param y2 The y-coordinate of the ending point of the line.\n * @return A list of integer arrays, where each array contains the x and y coordinates of a point on the line.\n */\npublic static List<int[]> bresenhamLine(int x1, int y1, int x2, int y2) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testHorizontalLine() {\n        List<int[]> expected = Arrays.asList(\n                new int[]{1, 5},\n                new int[]{2, 5},\n                new int[]{3, 5},\n                new int[]{4, 5},\n                new int[]{5, 5}\n        );\n        List<int[]> actual = bresenhamLine(1, 5, 5, 5);\n        // Check if the sizes of the lists are equal\n        assertEquals(expected.size(), actual.size());\n\n        // Compare each int array in the lists\n        for (int i = 0; i < expected.size(); i++) {\n            assertArrayEquals(expected.get(i), actual.get(i));\n        }\n    }\n\n    @Test\n    public void testVerticalLine() {\n        List<int[]> expected = Arrays.asList(\n                new int[]{3, 2},\n                new int[]{3, 3},\n                new int[]{3, 4},\n                new int[]{3, 5},\n                new int[]{3, 6}\n        );\n        List<int[]> actual = bresenhamLine(3, 2, 3, 6);\n        // Check if the sizes of the lists are equal\n        assertEquals(expected.size(), actual.size());\n\n        // Compare each int array in the lists\n        for (int i = 0; i < expected.size(); i++) {\n            assertArrayEquals(expected.get(i), actual.get(i));\n        }\n    }\n\n    @Test\n    public void testDiagonalLine() {\n        List<int[]> expected = Arrays.asList(\n                new int[]{2, 2},\n                new int[]{3, 3},\n                new int[]{4, 4},\n                new int[]{5, 5},\n                new int[]{6, 6}\n        );\n        List<int[]> actual = bresenhamLine(2, 2, 6, 6);\n        // Check if the sizes of the lists are equal\n        assertEquals(expected.size(), actual.size());\n\n        // Compare each int array in the lists\n        for (int i = 0; i < expected.size(); i++) {\n            assertArrayEquals(expected.get(i), actual.get(i));\n        }\n    }\n\n    @Test\n    public void testSteepSlope() {\n        List<int[]> expected = Arrays.asList(\n                new int[]{1, 1},\n                new int[]{2, 2},\n                new int[]{2, 3},\n                new int[]{3, 4},\n                new int[]{3, 5},\n                new int[]{4, 6}\n        );\n        List<int[]> actual = bresenhamLine(1, 1, 4, 6);\n        // Check if the sizes of the lists are equal\n        assertEquals(expected.size(), actual.size());\n\n        // Compare each int array in the lists\n        for (int i = 0; i < expected.size(); i++) {\n            assertArrayEquals(expected.get(i), actual.get(i));\n        }\n    }\n\n    @Test\n    public void testNegativeSlope() {\n        List<int[]> expected = Arrays.asList(\n                new int[]{5, 1},\n                new int[]{4, 2},\n                new int[]{3, 3},\n                new int[]{2, 4},\n                new int[]{1, 5}\n        );\n        List<int[]> actual = bresenhamLine(5, 1, 1, 5);\n        // Check if the sizes of the lists are equal\n        assertEquals(expected.size(), actual.size());\n\n        // Compare each int array in the lists\n        for (int i = 0; i < expected.size(); i++) {\n            assertArrayEquals(expected.get(i), actual.get(i));\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param x1 The x-coordinate of the starting point of the line.\n * @param y1 The y-coordinate of the starting point of the line.\n * @param x2 The x-coordinate of the ending point of the line.\n * @param y2 The y-coordinate of the ending point of the line.\n * @return A list of integer arrays, where each array contains the x and y coordinates of a point on the line.\n */\npublic static List<int[]> bresenhamLine(int x1, int y1, int x2, int y2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 213, "code_type": "method", "original_language": "python", "file_path": "MJ-Bench\\79f4e9ef3cd1b9f97a1f862327ccff728d3001b6\\trl_modified\\examples\\research_projects\\tools\\calculator.py", "question_type": "Algorithm and data structure", "summary": "Apply the im2col operation to an input image.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\ndef im2col(image, filter_height, filter_width, stride=1, padding=0):\n    \"\"\"\n    Apply the im2col operation to an input image.\n\n    Parameters:\n    - image (numpy array): The input image of shape (C, H, W) where:\n        C: Number of channels\n        H: Height of the image\n        W: Width of the image\n    - filter_height (int): Height of the filter\n    - filter_width (int): Width of the filter\n    - stride (int): Stride of the filter\n    - padding (int): Number of pixels to pad the input image\n\n    Returns:\n    - col (numpy array): A 2D array where each column is a flattened filter region\n    \"\"\"", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestIm2Col(unittest.TestCase):\n\n    def test_single_channel_no_padding_stride_1(self):\n        image = np.array([\n            [[1, 2, 3, 4],\n             [5, 6, 7, 8],\n             [9, 10, 11, 12],\n             [13, 14, 15, 16]]\n        ])  # Shape (1, 4, 4)\n        filter_height = 2\n        filter_width = 2\n        stride = 1\n        padding = 0\n\n        expected_output = np.array([\n            [1, 2, 3, 5, 6, 7, 9, 10, 11],\n            [2, 3, 4, 6, 7, 8, 10, 11, 12],\n            [5, 6, 7, 9, 10, 11, 13, 14, 15],\n            [6, 7, 8, 10, 11, 12, 14, 15, 16]\n        ])\n        output = im2col(image, filter_height, filter_width, stride, padding)\n        np.testing.assert_array_equal(output, expected_output)\n\n    def test_single_channel_no_padding_stride_2(self):\n        image = np.array([\n            [[1, 2, 3, 4],\n             [5, 6, 7, 8],\n             [9, 10, 11, 12],\n             [13, 14, 15, 16]]\n        ])  # Shape (1, 4, 4)\n        filter_height = 2\n        filter_width = 2\n        stride = 2\n        padding = 0\n\n        expected_output = np.array([\n            [1, 3, 9, 11],\n            [2, 4, 10, 12],\n            [5, 7, 13, 15],\n            [6, 8, 14, 16]\n        ])\n        output = im2col(image, filter_height, filter_width, stride, padding)\n        np.testing.assert_array_equal(output, expected_output)\n\n    def test_multi_channel_no_padding_stride_1(self):\n        image = np.array([\n            [[1, 2, 3],\n             [4, 5, 6],\n             [7, 8, 9]],\n            [[9, 8, 7],\n             [6, 5, 4],\n             [3, 2, 1]]\n        ])  # Shape (2, 3, 3), 2 channels\n        filter_height = 2\n        filter_width = 2\n        stride = 1\n        padding = 0\n\n        expected_output = np.array([\n            [1, 2, 4, 5],\n            [2, 3, 5, 6],\n            [4, 5, 7, 8],\n            [5, 6, 8, 9],\n            [9, 8, 6, 5],\n            [8, 7, 5, 4],\n            [6, 5, 3, 2],\n            [5, 4, 2, 1]\n        ])\n        output = im2col(image, filter_height, filter_width, stride, padding)\n        np.testing.assert_array_equal(output, expected_output)\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\ndef im2col(image, filter_height, filter_width, stride=1, padding=0):\n    \"\"\"\n    Apply the im2col operation to an input image.\n\n    Parameters:\n    - image (numpy array): The input image of shape (C, H, W) where:\n        C: Number of channels\n        H: Height of the image\n        W: Width of the image\n    - filter_height (int): Height of the filter\n    - filter_width (int): Width of the filter\n    - stride (int): Stride of the filter\n    - padding (int): Number of pixels to pad the input image\n\n    Returns:\n    - col (numpy array): A 2D array where each column is a flattened filter region\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 214, "code_type": "method", "original_language": "python", "file_path": "study-tracker-proj\\0ea9f7d5d3582353f546ed98190dd56fa2fc122c\\generate_db.py", "question_type": "Data processing and transformation", "summary": "Reads data from the given mapping file and returns a list where each element is a tuple containing the compiled regular expression and replacement strings\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef read_mapping_file(mapping_file_path: str) -> List:\n    \"\"\"\n    Reads question from the given mapping file and returns a list where each element is a tuple containing the compiled regular expression and replacement strings\n    Args:\n        mapping_file_path (str): Path to the file containing regex mappings.\n\n    Returns:\n        list of tuples: Each tuple contains a compiled regex object and a corresponding replacement string.\n    \"\"\"\n", "test_code": "import re\nimport unittest\nfrom unittest.mock import patch, mock_open\n\n\nclass TestReadMappingFile(unittest.TestCase):\n\n    def test_valid_mapping_file(self):\n        # Test with a valid mapping file content\n        mock_file_content = \"'old_pattern1','new_word1'\\n'old_pattern2','new_word2'\\n\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_file_content)):\n            result = read_mapping_file(\"dummy_path.txt\")\n            expected = [\n                (re.compile(\"old_pattern1\"), \"new_word1\"),\n                (re.compile(\"old_pattern2\"), \"new_word2\"),\n            ]\n            self.assertEqual(result, expected)\n\n    def test_missing_file(self):\n        # Test with a missing file\n        with self.assertRaises(FileNotFoundError):\n            read_mapping_file(\"non_existent_file.txt\")\n\n    def test_malformed_line_no_comma(self):\n        # Test with a line that does not contain a comma\n        mock_file_content = \"'old_pattern1' 'new_word1'\\n\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_file_content)):\n            with self.assertRaises(ValueError) as context:\n                read_mapping_file(\"dummy_path.txt\")\n            self.assertEqual(str(context.exception), \"Each line must contain exactly one comma separating the pattern and the replacement.\")\n\n    def test_valid_patterns_with_special_characters(self):\n        # Test with valid patterns that contain special regex characters\n        mock_file_content = \"'\\\\d+', 'number'\\n'\\\\w+', 'word'\\n\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_file_content)):\n            result = read_mapping_file(\"dummy_path.txt\")\n            expected = [\n                (re.compile(r\"\\d+\"), \"number\"),\n                (re.compile(r\"\\w+\"), \"word\"),\n            ]\n            self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef read_mapping_file(mapping_file_path: str) -> List:\n    \"\"\"\n    Reads question from the given mapping file and returns a list where each element is a tuple containing the compiled regular expression and replacement strings\n    Args:\n        mapping_file_path (str): Path to the file containing regex mappings.\n\n    Returns:\n        list of tuples: Each tuple contains a compiled regex object and a corresponding replacement string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads question mappings from the specified file and returns a list of tuples \n *        containing compiled regular expressions and their corresponding replacement strings.\n *\n * This function processes a mapping file to extract regex patterns and their replacement \n * strings, compiling the patterns for later use.\n *\n * @param mapping_file_path The path to the file containing regex mappings.\n * @return A vector of Mapping structs, each containing a compiled regex object and \n *         its corresponding replacement string.\n */\nstd::vector<Mapping> read_mapping_file(const std::string& mapping_file_path) {}", "test_code": "TEST_CASE(\"Test read_mapping_file function\", \"[read_mapping_file]\") {\n    SECTION(\"Test with a valid mapping file content\") {\n        // Test with a valid mapping file content\n        const std::string mock_file_content = \"'old_pattern1','new_word1'\\n'old_pattern2','new_word2'\\n\";\n        std::istringstream mock_stream(mock_file_content);\n\n        // Redirect std::ifstream to use the mock stream\n        std::istringstream* original_ifstream_open = std::ifstream::open;\n        std::ifstream::open = [&mock_stream](const std::string&, std::ios_base::openmode) {\n            return &mock_stream;\n        };\n\n        std::vector<Mapping> result = read_mapping_file(\"dummy_path.txt\");\n        std::vector<Mapping> expected = {\n            {std::regex(\"old_pattern1\"), \"new_word1\"},\n            {std::regex(\"old_pattern2\"), \"new_word2\"}\n        };\n\n        REQUIRE(result.size() == expected.size());\n        for (size_t i = 0; i < result.size(); ++i) {\n            REQUIRE(result[i].pattern.mark_count() == expected[i].pattern.mark_count());\n            REQUIRE(result[i].replacement == expected[i].replacement);\n        }\n\n        // Restore the original ifstream::open\n        std::ifstream::open = original_ifstream_open;\n    }\n\n    SECTION(\"Test with a missing file\") {\n        // Test with a missing file\n        REQUIRE_THROWS_AS(read_mapping_file(\"non_existent_file.txt\"), std::runtime_error);\n    }\n\n    SECTION(\"Test with a line that does not contain a comma\") {\n        // Test with a line that does not contain a comma\n        const std::string mock_file_content = \"'old_pattern1' 'new_word1'\\n\";\n        std::istringstream mock_stream(mock_file_content);\n\n        // Redirect std::ifstream to use the mock stream\n        std::istringstream* original_ifstream_open = std::ifstream::open;\n        std::ifstream::open = [&mock_stream](const std::string&, std::ios_base::openmode) {\n            return &mock_stream;\n        };\n\n        REQUIRE_THROWS_AS(read_mapping_file(\"dummy_path.txt\"), std::runtime_error);\n\n        // Restore the original ifstream::open\n        std::ifstream::open = original_ifstream_open;\n    }\n\n    SECTION(\"Test with valid patterns that contain special regex characters\") {\n        // Test with valid patterns that contain special regex characters\n        const std::string mock_file_content = \"'\\\\d+', 'number'\\n'\\\\w+', 'word'\\n\";\n        std::istringstream mock_stream(mock_file_content);\n\n        // Redirect std::ifstream to use the mock stream\n        std::istringstream* original_ifstream_open = std::ifstream::open;\n        std::ifstream::open = [&mock_stream](const std::string&, std::ios_base::openmode) {\n            return &mock_stream;\n        };\n\n        std::vector<Mapping> result = read_mapping_file(\"dummy_path.txt\");\n        std::vector<Mapping> expected = {\n            {std::regex(\"\\\\d+\"), \"number\"},\n            {std::regex(\"\\\\w+\"), \"word\"}\n        };\n\n        REQUIRE(result.size() == expected.size());\n        for (size_t i = 0; i < result.size(); ++i) {\n            REQUIRE(result[i].pattern.mark_count() == expected[i].pattern.mark_count());\n            REQUIRE(result[i].replacement == expected[i].replacement);\n        }\n\n        // Restore the original ifstream::open\n        std::ifstream::open = original_ifstream_open;\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads question mappings from the specified file and returns a list of tuples \n *        containing compiled regular expressions and their corresponding replacement strings.\n *\n * This function processes a mapping file to extract regex patterns and their replacement \n * strings, compiling the patterns for later use.\n *\n * @param mapping_file_path The path to the file containing regex mappings.\n * @return A vector of Mapping structs, each containing a compiled regex object and \n *         its corresponding replacement string.\n */\nstd::vector<Mapping> read_mapping_file(const std::string& mapping_file_path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads a mapping file and returns a list of tuples with compiled regex and replacement strings.\n *\n * @param mappingFilePath Path to the file containing regex mappings.\n * @return A list of tuples, where each tuple contains a compiled regex object and a corresponding replacement string.\n * @throws IOException If the mapping file does not exist or cannot be read.\n */\npublic static class Tuple<T1, T2> {\n    private T1 first;\n    private T2 second;\n\n    public Tuple(T1 first, T2 second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public T1 getFirst() {\n        return first;\n    }\n\n    public T2 getSecond() {\n        return second;\n    }\n}\npublic static List<Tuple<Pattern, String>> readMappingFile(String mappingFilePath) throws IOException {}", "test_code": "public class Tester {\n\n    @Test\n    void testValidMappingFile() throws IOException {\n        // Test with a valid mapping file content\n        String mockFileContent = \"'old_pattern1','new_word1'\\n'old_pattern2','new_word2'\\n\";\n        File tempFile = File.createTempFile(\"dummy\", \".txt\");\n        try (FileWriter writer = new FileWriter(tempFile)) {\n            writer.write(mockFileContent);\n        }\n\n        List<Tuple<Pattern, String>> result = readMappingFile(tempFile.getAbsolutePath());\n        List<Tuple<Pattern, String>> expected = List.of(\n            new Tuple<>(Pattern.compile(\"old_pattern1\"), \"new_word1\"),\n            new Tuple<>(Pattern.compile(\"old_pattern2\"), \"new_word2\")\n        );\n\n        assertEquals(expected, result);\n    }\n\n    @Test\n    void testMissingFile() {\n        // Test with a missing file\n        assertThrows(IOException.class, () -> readMappingFile(\"non_existent_file.txt\"));\n    }\n\n    @Test\n    void testMalformedLineNoComma() throws IOException {\n        // Test with a line that does not contain a comma\n        String mockFileContent = \"'old_pattern1' 'new_word1'\\n\";\n        File tempFile = File.createTempFile(\"dummy\", \".txt\");\n        try (FileWriter writer = new FileWriter(tempFile)) {\n            writer.write(mockFileContent);\n        }\n\n        assertThrows(IllegalArgumentException.class, () -> readMappingFile(tempFile.getAbsolutePath()));\n    }\n\n    @Test\n    void testValidPatternsWithSpecialCharacters() throws IOException {\n        // Test with valid patterns that contain special regex characters\n        String mockFileContent = \"'\\\\d+', 'number'\\n'\\\\w+', 'word'\\n\";\n        File tempFile = File.createTempFile(\"dummy\", \".txt\");\n        try (FileWriter writer = new FileWriter(tempFile)) {\n            writer.write(mockFileContent);\n        }\n\n        List<Tuple<Pattern, String>> result = readMappingFile(tempFile.getAbsolutePath());\n        List<Tuple<Pattern, String>> expected = List.of(\n            new Tuple<>(Pattern.compile(\"\\\\d+\"), \"number\"),\n            new Tuple<>(Pattern.compile(\"\\\\w+\"), \"word\")\n        );\n\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Reads a mapping file and returns a list of tuples with compiled regex and replacement strings.\n *\n * @param mappingFilePath Path to the file containing regex mappings.\n * @return A list of tuples, where each tuple contains a compiled regex object and a corresponding replacement string.\n * @throws IOException If the mapping file does not exist or cannot be read.\n */\npublic static class Tuple<T1, T2> {\n    private T1 first;\n    private T2 second;\n\n    public Tuple(T1 first, T2 second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public T1 getFirst() {\n        return first;\n    }\n\n    public T2 getSecond() {\n        return second;\n    }\n}\npublic static List<Tuple<Pattern, String>> readMappingFile(String mappingFilePath) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 215, "code_type": "method", "original_language": "python", "file_path": "study-tracker-proj\\0ea9f7d5d3582353f546ed98190dd56fa2fc122c\\generate_db.py", "question_type": "Data processing and transformation", "summary": "Read a text file according to the file path, replace the word according to the dictionary map, and return the replaced text", "language_version_list": {"python": {"code_signature": "def replace_words_in_file(file_path: str, replacement_dict: dict) -> str:\n    \"\"\"\n    Read a text file, replace words according to a dictionary map, and return the modified text.\n\n    Parameters:\n    - file_path (str): The path to the text file.\n    - replacement_dict (dict): A dictionary where the keys are words to be replaced, and the values are the replacement words.\n\n    Returns:\n    - str: The text with the words replaced.\n    \"\"\"\n", "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestReplaceWordsInFile(unittest.TestCase):\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"hello world\")\n    def test_replace_single_word(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"hello\": \"hi\"}\n        expected_output = \"hi world\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"hello world\")\n    def test_replace_multiple_words(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"hello\": \"hi\", \"world\": \"earth\"}\n        expected_output = \"hi earth\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"hello world\")\n    def test_no_replacement(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"goodbye\": \"bye\"}\n        expected_output = \"hello world\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"\")\n    def test_empty_file(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"hello\": \"hi\"}\n        expected_output = \"\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n", "prompt": "please write a python function , the function signature as below def replace_words_in_file(file_path: str, replacement_dict: dict) -> str:\n    \"\"\"\n    Read a text file, replace words according to a dictionary map, and return the modified text.\n\n    Parameters:\n    - file_path (str): The path to the text file.\n    - replacement_dict (dict): A dictionary where the keys are words to be replaced, and the values are the replacement words.\n\n    Returns:\n    - str: The text with the words replaced.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads a text file, replaces words according to a dictionary map, and returns the modified text.\n *\n * @param file_path The path to the text file to be processed.\n * @param replacement_dict A dictionary where the keys are words to be replaced, \n *        and the values are the corresponding replacement words.\n * @return A string containing the text with the words replaced according to the dictionary.\n */\nstd::string replace_words_in_file(const std::string& file_path, const std::unordered_map<std::string, std::string>& replacement_dict) {}", "test_code": "TEST_CASE(\"Test replace_words_in_file\") {\n    SECTION(\"test_replace_single_word\") {\n        const std::string file_path = \"dummy_path.txt\";\n        const std::unordered_map<std::string, std::string> replacement_dict = {{\"hello\", \"hi\"}};\n        const std::string expected_output = \"hi world\";\n\n        // Mock file content\n        std::istringstream mock_file_content(\"hello world\");\n\n        // Redirect file stream to mock file content\n        std::istringstream original_cin(std::cin.rdbuf());\n        std::cin.rdbuf(mock_file_content.rdbuf());\n\n        std::string result = replace_words_in_file(file_path, replacement_dict);\n\n        // Restore original file stream\n        std::cin.rdbuf(original_cin.rdbuf());\n\n        REQUIRE(result == expected_output);\n    }\n\n    SECTION(\"test_replace_multiple_words\") {\n        const std::string file_path = \"dummy_path.txt\";\n        const std::unordered_map<std::string, std::string> replacement_dict = {{\"hello\", \"hi\"}, {\"world\", \"earth\"}};\n        const std::string expected_output = \"hi earth\";\n\n        // Mock file content\n        std::istringstream mock_file_content(\"hello world\");\n\n        // Redirect file stream to mock file content\n        std::istringstream original_cin(std::cin.rdbuf());\n        std::cin.rdbuf(mock_file_content.rdbuf());\n\n        std::string result = replace_words_in_file(file_path, replacement_dict);\n\n        // Restore original file stream\n        std::cin.rdbuf(original_cin.rdbuf());\n\n        REQUIRE(result == expected_output);\n    }\n\n    SECTION(\"test_no_replacement\") {\n        const std::string file_path = \"dummy_path.txt\";\n        const std::unordered_map<std::string, std::string> replacement_dict = {{\"goodbye\", \"bye\"}};\n        const std::string expected_output = \"hello world\";\n\n        // Mock file content\n        std::istringstream mock_file_content(\"hello world\");\n\n        // Redirect file stream to mock file content\n        std::istringstream original_cin(std::cin.rdbuf());\n        std::cin.rdbuf(mock_file_content.rdbuf());\n\n        std::string result = replace_words_in_file(file_path, replacement_dict);\n\n        // Restore original file stream\n        std::cin.rdbuf(original_cin.rdbuf());\n\n        REQUIRE(result == expected_output);\n    }\n\n    SECTION(\"test_empty_file\") {\n        const std::string file_path = \"dummy_path.txt\";\n        const std::unordered_map<std::string, std::string> replacement_dict = {{\"hello\", \"hi\"}};\n        const std::string expected_output = \"\";\n\n        // Mock file content\n        std::istringstream mock_file_content(\"\");\n\n        // Redirect file stream to mock file content\n        std::istringstream original_cin(std::cin.rdbuf());\n        std::cin.rdbuf(mock_file_content.rdbuf());\n\n        std::string result = replace_words_in_file(file_path, replacement_dict);\n\n        // Restore original file stream\n        std::cin.rdbuf(original_cin.rdbuf());\n\n        REQUIRE(result == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads a text file, replaces words according to a dictionary map, and returns the modified text.\n *\n * @param file_path The path to the text file to be processed.\n * @param replacement_dict A dictionary where the keys are words to be replaced, \n *        and the values are the corresponding replacement words.\n * @return A string containing the text with the words replaced according to the dictionary.\n */\nstd::string replace_words_in_file(const std::string& file_path, const std::unordered_map<std::string, std::string>& replacement_dict) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads a text file, replaces words according to a dictionary map, and returns the modified text.\n *\n * @param filePath The path to the text file.\n * @param replacementMap A map where the keys are words to be replaced, and the values are the replacement words.\n * @return The text with the words replaced or an error message if an exception occurs.\n */\npublic static String replaceWordsInFile(String filePath, Map<String, String> replacementMap) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\nimport org.mockito.stubbing.Answer;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.util.Map;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.when;\nimport static org.real.temp.Answer.*;\n@RunWith(MockitoJUnitRunner.class)\npublic class Tester {\n\n    @InjectMocks\n    private Answer answer; // This seems to be incorrectly used; please verify your intended use\n\n    @Mock\n    private BufferedReader mockReader;\n\n    @Test\n    public void testReplaceSingleWord() throws IOException {\n        String fileContent = \"hello world\";\n        String file_path = \"dummy_path.txt\";\n        Map<String, String> replacementDict = Map.of(\"hello\", \"hi\");\n        String expectedOutput = \"hi world\";\n\n        when(mockReader.readLine()).thenReturn(fileContent, null);\n\n        String result = replaceWordsInFile(file_path, replacementDict);\n        assertEquals(expectedOutput, result);\n    }\n\n    @Test\n    public void testReplaceMultipleWords() throws IOException {\n        String fileContent = \"hello world\";\n        String file_path = \"dummy_path.txt\";\n        Map<String, String> replacementDict = Map.of(\"hello\", \"hi\", \"world\", \"earth\");\n        String expectedOutput = \"hi earth\";\n\n        when(mockReader.readLine()).thenReturn(fileContent, null);\n\n        String result = replaceWordsInFile(file_path, replacementDict);\n        assertEquals(expectedOutput, result);\n    }\n\n    @Test\n    public void testNoReplacement() throws IOException {\n        String fileContent = \"hello world\";\n        String file_path = \"dummy_path.txt\";\n        Map<String, String> replacementDict = Map.of(\"goodbye\", \"bye\");\n        String expectedOutput = \"hello world\";\n\n        when(mockReader.readLine()).thenReturn(fileContent, null);\n\n        String result = replaceWordsInFile(file_path, replacementDict);\n        assertEquals(expectedOutput, result);\n    }\n\n    @Test\n    public void testEmptyFile() throws IOException {\n        String fileContent = \"\";\n        String file_path = \"dummy_path.txt\";\n        Map<String, String> replacementDict = Map.of(\"hello\", \"hi\");\n        String expectedOutput = \"\";\n\n        when(mockReader.readLine()).thenReturn(fileContent, null);\n\n        String result = replaceWordsInFile(file_path, replacementDict);\n        assertEquals(expectedOutput, result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Reads a text file, replaces words according to a dictionary map, and returns the modified text.\n *\n * @param filePath The path to the text file.\n * @param replacementMap A map where the keys are words to be replaced, and the values are the replacement words.\n * @return The text with the words replaced or an error message if an exception occurs.\n */\npublic static String replaceWordsInFile(String filePath, Map<String, String> replacementMap) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 216, "code_type": "method", "original_language": "python", "file_path": "CHATGPT\\16c1ed04ea01e23251f1c2114c7b39ce5eafeb50\\bot\\bot.py", "question_type": "Network requests and API call", "summary": "gets the IPv4 address of the local computer on a specific network interface, such as wlan0, which is usually a wireless network interface\n", "language_version_list": {"python": {"code_signature": "import re\nimport subprocess\n\n\ndef get_local_ip(interface: str = 'wlan0') -> str:\n    \"\"\"\n    gets the IPv4 address of the local computer on a specific network interface, such as wlan0, which is usually a wireless network interface\n    Args:\n        interface (str): The network interface to query. Default is 'wlan0'.\n\n    Returns:\n        str: The local IP address, or a message indicating no IP was found.\n    \"\"\"", "test_code": "import unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass TestGetLocalIp(unittest.TestCase):\n    def setUp(self):\n        # Sample IP command output for a wlan0 interface\n        self.sample_output = \"3: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\\n\" \\\n                             \"    inet 192.168.1.100/24 brd 192.168.1.255 scope global dynamic wlan0\\n\" \\\n                             \"       valid_lft 86394sec preferred_lft 86394sec\\n\"\n\n    @patch('subprocess.run')\n    def test_successful_ip_retrieval(self, mock_run):\n        # Configure the mock to return a successful output\n        mock_run.return_value = MagicMock(stdout=self.sample_output, check=True)\n        # Test function with wlan0 interface\n        ip = get_local_ip('wlan0')\n        self.assertEqual(ip, '192.168.1.100')\n\n    @patch('subprocess.run')\n    def test_command_failure(self, mock_run):\n        # Simulate a subprocess failure\n        mock_run.side_effect = subprocess.CalledProcessError(1, ['ip', 'addr', 'show', 'wlan0'])\n        self.assertRaises(Exception)\n    @patch('subprocess.run')\n    def test_different_interface(self, mock_run):\n        # Configure the mock for a different interface\n        mock_run.return_value = MagicMock(\n            stdout=\"3: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500\\n    inet 10.0.0.1/24\", check=True)\n        ip = get_local_ip('eth0')\n        self.assertEqual(ip, '10.0.0.1')", "prompt": "please write a python function , the function signature as below import re\nimport subprocess\n\n\ndef get_local_ip(interface: str = 'wlan0') -> str:\n    \"\"\"\n    gets the IPv4 address of the local computer on a specific network interface, such as wlan0, which is usually a wireless network interface\n    Args:\n        interface (str): The network interface to query. Default is 'wlan0'.\n\n    Returns:\n        str: The local IP address, or a message indicating no IP was found.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 219, "code_type": "method", "original_language": "python", "file_path": "DeepLearningModel-ForImageSegmentation\\50bcf97bc45127a4b1e2da8af6c3deb843e6fb12\\implementation\\use_creator.py", "question_type": "Algorithm and data structure", "summary": "Check the incoming list of records(eg ('AAPL', '2023-09-01', 0.22),) such as this for the presence of ticker symbols with the same ex-dividend date, but for amounts of different dividend amounts", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef check_dividend_variances(records: List) -> List:\n    \"\"\"\n    Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n    Args:\n        records (List): Each tuple contains (ticker, ex_dividend_date, dividend_amount).\n\n    Returns:\n        List: Each tuple contains (ticker, ex_dividend_date) that have different dividend amounts.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCheckDividendVariances(unittest.TestCase):\n\n    def test_no_inconsistencies(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22),\n            ('AAPL', '2023-09-01', 0.22),\n            ('MSFT', '2023-09-01', 0.56),\n            ('GOOG', '2023-09-02', 0.00)\n        ]\n        expected_output = []\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_one_inconsistency(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22),\n            ('AAPL', '2023-09-01', 0.23),  # Different amount\n            ('MSFT', '2023-09-01', 0.56),\n            ('GOOG', '2023-09-02', 0.00)\n        ]\n        expected_output = [('AAPL', '2023-09-01')]\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_multiple_inconsistencies(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22),\n            ('AAPL', '2023-09-01', 0.23),  # Different amount\n            ('MSFT', '2023-09-01', 0.56),\n            ('MSFT', '2023-09-01', 0.60),  # Different amount\n            ('GOOG', '2023-09-02', 0.00),\n            ('TSLA', '2023-09-03', 0.10),\n            ('TSLA', '2023-09-03', 0.10),  # Same amount, no inconsistency\n            ('TSLA', '2023-09-03', 0.15)  # Different amount\n        ]\n        expected_output = [('AAPL', '2023-09-01'), ('MSFT', '2023-09-01'), ('TSLA', '2023-09-03')]\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_single_record(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22)\n        ]\n        expected_output = []\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_empty_list(self):\n        records = []\n        expected_output = []\n        self.assertEqual(check_dividend_variances(records), expected_output)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef check_dividend_variances(records: List) -> List:\n    \"\"\"\n    Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n    Args:\n        records (List): Each tuple contains (ticker, ex_dividend_date, dividend_amount).\n\n    Returns:\n        List: Each tuple contains (ticker, ex_dividend_date) that have different dividend amounts.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n *\n * @param records A vector of tuples, where each tuple contains (ticker, ex_dividend_date, dividend_amount).\n * @return A vector of pairs, where each pair contains (ticker, ex_dividend_date) that have different dividend amounts.\n */\nstd::vector<std::pair<std::string, std::string>> checkDividendVariances(const std::vector<std::tuple<std::string, std::string, int>>& records) {}", "test_code": "TEST_CASE(\"Test checkDividendVariances function\", \"[checkDividendVariances]\") {\n    SECTION(\"No inconsistencies\") {\n        std::vector<std::tuple<std::string, std::string, int>> records = {\n            {\"AAPL\", \"2023-09-01\", 22},\n            {\"AAPL\", \"2023-09-01\", 22},\n            {\"MSFT\", \"2023-09-01\", 56},\n            {\"GOOG\", \"2023-09-02\", 0}\n        };\n        std::vector<std::pair<std::string, std::string>> expected_output = {};\n        REQUIRE(checkDividendVariances(records) == expected_output);\n    }\n\n    SECTION(\"One inconsistency\") {\n        std::vector<std::tuple<std::string, std::string, int>> records = {\n            {\"AAPL\", \"2023-09-01\", 22},\n            {\"AAPL\", \"2023-09-01\", 23},  // Different amount\n            {\"MSFT\", \"2023-09-01\", 56},\n            {\"GOOG\", \"2023-09-02\", 0}\n        };\n        std::vector<std::pair<std::string, std::string>> expected_output = {{\"AAPL\", \"2023-09-01\"}};\n        REQUIRE(checkDividendVariances(records) == expected_output);\n    }\n\n    SECTION(\"Multiple inconsistencies\") {\n        std::vector<std::tuple<std::string, std::string, int>> records = {\n            {\"AAPL\", \"2023-09-01\", 22},\n            {\"AAPL\", \"2023-09-01\", 23},  // Different amount\n            {\"MSFT\", \"2023-09-01\", 56},\n            {\"MSFT\", \"2023-09-01\", 60},  // Different amount\n            {\"GOOG\", \"2023-09-02\", 0},\n            {\"TSLA\", \"2023-09-03\", 10},\n            {\"TSLA\", \"2023-09-03\", 10},  // Same amount, no inconsistency\n            {\"TSLA\", \"2023-09-03\", 15}  // Different amount\n        };\n        std::vector<std::pair<std::string, std::string>> expected_output = {\n            {\"AAPL\", \"2023-09-01\"},\n            {\"MSFT\", \"2023-09-01\"},\n            {\"TSLA\", \"2023-09-03\"}\n        };\n        REQUIRE(checkDividendVariances(records) == expected_output);\n    }\n\n    SECTION(\"Single record\") {\n        std::vector<std::tuple<std::string, std::string, int>> records = {\n            {\"AAPL\", \"2023-09-01\", 22}\n        };\n        std::vector<std::pair<std::string, std::string>> expected_output = {};\n        REQUIRE(checkDividendVariances(records) == expected_output);\n    }\n\n    SECTION(\"Empty list\") {\n        std::vector<std::tuple<std::string, std::string, int>> records = {};\n        std::vector<std::pair<std::string, std::string>> expected_output = {};\n        REQUIRE(checkDividendVariances(records) == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n *\n * @param records A vector of tuples, where each tuple contains (ticker, ex_dividend_date, dividend_amount).\n * @return A vector of pairs, where each pair contains (ticker, ex_dividend_date) that have different dividend amounts.\n */\nstd::vector<std::pair<std::string, std::string>> checkDividendVariances(const std::vector<std::tuple<std::string, std::string, int>>& records) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n * \n * @param records A list of tuples where each tuple contains (ticker, exDividendDate, dividendAmount).\n * @return A list of tuples where each tuple contains (ticker, exDividendDate) that have different dividend amounts.\n */\npublic static class Tuple<T1, T2> {\n    private T1 first;\n    private T2 second;\n\n    public Tuple(T1 first, T2 second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public T1 getFirst() {\n        return first;\n    }\n\n    public T2 getSecond() {\n        return second;\n    }\n}\npublic static List<Tuple<String, String>> checkDividendVariances(List<Tuple<String, String, Integer>> records) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Tester {\n\n    /**\n     * Test case for no inconsistencies in the records.\n     */\n    @Test\n    public void testNoInconsistencies() {\n        List<Tuple<String, String, Double>> records = new ArrayList<>();\n        records.add(new Tuple<>(\"AAPL\", \"2023-09-01\", 0.22));\n        records.add(new Tuple<>(\"AAPL\", \"2023-09-01\", 0.22));\n        records.add(new Tuple<>(\"MSFT\", \"2023-09-01\", 0.56));\n        records.add(new Tuple<>(\"GOOG\", \"2023-09-02\", 0.00));\n\n        List<Tuple<String, String>> expectedOutput = new ArrayList<>();\n        List<Tuple<String, String>> actualOutput = checkDividendVariances(records);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    /**\n     * Test case for one inconsistency in the records.\n     */\n    @Test\n    public void testOneInconsistency() {\n        List<Tuple<String, String, Double>> records = new ArrayList<>();\n        records.add(new Tuple<>(\"AAPL\", \"2023-09-01\", 0.22));\n        records.add(new Tuple<>(\"AAPL\", \"2023-09-01\", 0.23));  // Different amount\n        records.add(new Tuple<>(\"MSFT\", \"2023-09-01\", 0.56));\n        records.add(new Tuple<>(\"GOOG\", \"2023-09-02\", 0.00));\n\n        List<Tuple<String, String>> expectedOutput = new ArrayList<>();\n        expectedOutput.add(new Tuple<>(\"AAPL\", \"2023-09-01\"));\n        List<Tuple<String, String>> actualOutput = checkDividendVariances(records);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    /**\n     * Test case for multiple inconsistencies in the records.\n     */\n    @Test\n    public void testMultipleInconsistencies() {\n        List<Tuple<String, String, Double>> records = new ArrayList<>();\n        records.add(new Tuple<>(\"AAPL\", \"2023-09-01\", 0.22));\n        records.add(new Tuple<>(\"AAPL\", \"2023-09-01\", 0.23));  // Different amount\n        records.add(new Tuple<>(\"MSFT\", \"2023-09-01\", 0.56));\n        records.add(new Tuple<>(\"MSFT\", \"2023-09-01\", 0.60));  // Different amount\n        records.add(new Tuple<>(\"GOOG\", \"2023-09-02\", 0.00));\n        records.add(new Tuple<>(\"TSLA\", \"2023-09-03\", 0.10));\n        records.add(new Tuple<>(\"TSLA\", \"2023-09-03\", 0.10));  // Same amount, no inconsistency\n        records.add(new Tuple<>(\"TSLA\", \"2023-09-03\", 0.15));  // Different amount\n\n        List<Tuple<String, String>> expectedOutput = new ArrayList<>();\n        expectedOutput.add(new Tuple<>(\"AAPL\", \"2023-09-01\"));\n        expectedOutput.add(new Tuple<>(\"MSFT\", \"2023-09-01\"));\n        expectedOutput.add(new Tuple<>(\"TSLA\", \"2023-09-03\"));\n        List<Tuple<String, String>> actualOutput = checkDividendVariances(records);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    /**\n     * Test case for a single record.\n     */\n    @Test\n    public void testSingleRecord() {\n        List<Tuple<String, String, Double>> records = new ArrayList<>();\n        records.add(new Tuple<>(\"AAPL\", \"2023-09-01\", 0.22));\n\n        List<Tuple<String, String>> expectedOutput = new ArrayList<>();\n        List<Tuple<String, String>> actualOutput = checkDividendVariances(records);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    /**\n     * Test case for an empty list of records.\n     */\n    @Test\n    public void testEmptyList() {\n        List<Tuple<String, String, Double>> records = new ArrayList<>();\n\n        List<Tuple<String, String>> expectedOutput = new ArrayList<>();\n        List<Tuple<String, String>> actualOutput = checkDividendVariances(records);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    // Helper class to represent a tuple\n    public static class Tuple<T1, T2, T3> {\n        private T1 first;\n        private T2 second;\n        private T3 third;\n\n        public Tuple(T1 first, T2 second, T3 third) {\n            this.first = first;\n            this.second = second;\n            this.third = third;\n        }\n\n        public T1 getFirst() {\n            return first;\n        }\n\n        public T2 getSecond() {\n            return second;\n        }\n\n        public T3 getThird() {\n            return third;\n        }\n    }\n\n    // Helper class to represent a tuple with two elements\n    public static class Tuple<T1, T2> {\n        private T1 first;\n        private T2 second;\n\n        public Tuple(T1 first, T2 second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public T1 getFirst() {\n            return first;\n        }\n\n        public T2 getSecond() {\n            return second;\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n * \n * @param records A list of tuples where each tuple contains (ticker, exDividendDate, dividendAmount).\n * @return A list of tuples where each tuple contains (ticker, exDividendDate) that have different dividend amounts.\n */\npublic static class Tuple<T1, T2> {\n    private T1 first;\n    private T2 second;\n\n    public Tuple(T1 first, T2 second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public T1 getFirst() {\n        return first;\n    }\n\n    public T2 getSecond() {\n        return second;\n    }\n}\npublic static List<Tuple<String, String>> checkDividendVariances(List<Tuple<String, String, Integer>> records) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 220, "code_type": "class", "original_language": "python", "file_path": "panorama\\9134aec85e06562fcb3095c22353ac560d8e4258\\Deep-EIoU\\Deep-EIoU\\tools\\sport_interpolation.py", "question_type": "Algorithm and data structure", "summary": "Using double-ended queues and collections to implement a data structure without duplicate data, add, delete and query operations", "language_version_list": {"python": {"code_signature": "from collections import deque\n\n\nclass UniqueDeque:\n\n    def add(self, item):\n        \"\"\"\n        Add an item to the deque if it is not already present.\n\n        Parameters:\n        - item: The item to add.\n\n        Returns:\n        - bool: True if the item was added, False if it was already present.\n        \"\"\"\n        pass\n\n    def delete(self, item):\n        \"\"\"\n        Remove an item from the deque if it exists.\n\n        Parameters:\n        - item: The item to remove.\n\n        Returns:\n        - bool: True if the item was removed, False if it was not found.\n        \"\"\"\n        pass\n\n    def contains(self, item):\n        \"\"\"\n        Check if an item is present in the deque.\n\n        Parameters:\n        - item: The item to check.\n\n        Returns:\n        - bool: True if the item is present, False otherwise.\n        \"\"\"\n        pass\n\n    def __len__(self):\n        \"\"\"\n        Get the number of elements in the deque.\n\n        Returns:\n        - int: The number of unique elements in the deque.\n        \"\"\"\n\n    def __iter__(self):\n        \"\"\"\n        Create an iterator for the deque.\n\n        Returns:\n        - iterator: An iterator over the elements in the deque.\n        \"\"\"\n", "test_code": "import unittest\nfrom collections import deque\n\nclass TestUniqueDeque(unittest.TestCase):\n\n    def test_add_unique_elements(self):\n        ud = UniqueDeque()\n        self.assertTrue(ud.add(1))\n        self.assertTrue(ud.add(2))\n        self.assertTrue(ud.add(3))\n        self.assertEqual(len(ud), 3)\n        self.assertEqual(list(ud), [1, 2, 3])\n\n    def test_add_duplicate_elements(self):\n        ud = UniqueDeque()\n        self.assertTrue(ud.add(1))\n        self.assertFalse(ud.add(1))  # Duplicate add should return False\n        self.assertEqual(len(ud), 1)\n        self.assertEqual(list(ud), [1])\n\n    def test_delete_elements(self):\n        ud = UniqueDeque()\n        ud.add(1)\n        ud.add(2)\n        ud.add(3)\n        self.assertTrue(ud.delete(2))\n        self.assertFalse(ud.delete(2))  # Deleting non-existing element should return False\n        self.assertEqual(len(ud), 2)\n        self.assertEqual(list(ud), [1, 3])\n\n    def test_contains(self):\n        ud = UniqueDeque()\n        ud.add(1)\n        self.assertTrue(ud.contains(1))\n        self.assertFalse(ud.contains(2))\n        ud.delete(1)\n        self.assertFalse(ud.contains(1))\n\n    def test_iter_and_len(self):\n        ud = UniqueDeque()\n        ud.add(1)\n        ud.add(2)\n        self.assertEqual(len(ud), 2)\n        items = list(iter(ud))\n        self.assertEqual(items, [1, 2])\n        ud.delete(1)\n        self.assertEqual(len(ud), 1)\n        self.assertEqual(list(ud), [2])", "prompt": "please write a python class , the class signature as below from collections import deque\n\n\nclass UniqueDeque:\n\n    def add(self, item):\n        \"\"\"\n        Add an item to the deque if it is not already present.\n\n        Parameters:\n        - item: The item to add.\n\n        Returns:\n        - bool: True if the item was added, False if it was already present.\n        \"\"\"\n        pass\n\n    def delete(self, item):\n        \"\"\"\n        Remove an item from the deque if it exists.\n\n        Parameters:\n        - item: The item to remove.\n\n        Returns:\n        - bool: True if the item was removed, False if it was not found.\n        \"\"\"\n        pass\n\n    def contains(self, item):\n        \"\"\"\n        Check if an item is present in the deque.\n\n        Parameters:\n        - item: The item to check.\n\n        Returns:\n        - bool: True if the item is present, False otherwise.\n        \"\"\"\n        pass\n\n    def __len__(self):\n        \"\"\"\n        Get the number of elements in the deque.\n\n        Returns:\n        - int: The number of unique elements in the deque.\n        \"\"\"\n\n    def __iter__(self):\n        \"\"\"\n        Create an iterator for the deque.\n\n        Returns:\n        - iterator: An iterator over the elements in the deque.\n        \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "class UniqueDeque {\npublic:\n    // Constructor initializes the deque and set.\n    UniqueDeque() : _deque(), _set() {}\n\n    // Add an item to the deque if it is not already present.\n    // Parameters:\n    // - item: The item to add.\n    // Returns:\n    // - bool: True if the item was added, False if it was already present.\n    bool add(const std::string& item) {\n    }\n\n    // Remove an item from the deque if it exists.\n    // Parameters:\n    // - item: The item to remove.\n    // Returns:\n    // - bool: True if the item was removed, False if it was not found.\n    bool deleteItem(const std::.string& item) {\n    }\n\n    // Check if an item is present in the deque.\n    // Parameters:\n    // - item: The item to check.\n    // Returns:\n    // - bool: True if the item is present, False otherwise.\n    bool contains(const std::string& item) const {\n        return _set.find(item) != _set.end();\n    }\n\n    // Get the number of elements in the deque.\n    // Returns:\n    // - int: The number of unique elements in the deque.\n    size_t size() const {\n        return _deque.size();\n    }\n\n    // Create an iterator for the deque.\n    // Returns:\n    // - iterator: An iterator over the elements in the deque.\n    std::deque<std::string>::iterator begin() {\n        return _deque.begin();\n    }\n\n    std::deque<std::string>::const_iterator begin() const {\n        return _deque.begin();\n    }\n\n    std::deque<std::string>::iterator end() {\n        return _deque.end();\n    }\n\n    std::deque<std::string>::const_iterator end() const {\n        return _deque.end();\n    }\n\nprivate:\n    std::deque<std::string> _deque; // Stores elements in order.\n    std::unordered_set<std::string> _set; // Ensures uniqueness.\n};", "test_code": "TEST_CASE(\"TestUniqueDeque\") {\n    SECTION(\"test_add_unique_elements\") {\n        UniqueDeque ud;\n        REQUIRE(ud.add(1));\n        REQUIRE(ud.add(2));\n        REQUIRE(ud.add(3));\n        REQUIRE(ud.size() == 3);\n        std::vector<int> expected = {1, 2, 3};\n        std::vector<int> actual(begin(ud), end(ud));\n        REQUIRE(actual == expected);\n    }\n\n    SECTION(\"test_add_duplicate_elements\") {\n        UniqueDeque ud;\n        REQUIRE(ud.add(1));\n        REQUIRE_FALSE(ud.add(1));  // Duplicate add should return false\n        REQUIRE(ud.size() == 1);\n        std::vector<int> expected = {1};\n        std::vector<int> actual(begin(ud), end(ud));\n        REQUIRE(actual == expected);\n    }\n\n    SECTION(\"test_delete_elements\") {\n        UniqueDeque ud;\n        ud.add(1);\n        ud.add(2);\n        ud.add(3);\n        REQUIRE(ud.deleteItem(2));\n        REQUIRE_FALSE(ud.deleteItem(2));  // Deleting non-existing element should return false\n        REQUIRE(ud.size() == 2);\n        std::vector<int> expected = {1, 3};\n        std::vector<int> actual(begin(ud), end(ud));\n        REQUIRE(actual == expected);\n    }\n\n    SECTION(\"test_contains\") {\n        UniqueDeque ud;\n        ud.add(1);\n        REQUIRE(ud.contains(1));\n        REQUIRE_FALSE(ud.contains(2));\n        ud.deleteItem(1);\n        REQUIRE_FALSE(ud.contains(1));\n    }\n\n    SECTION(\"test_iter_and_len\") {\n        UniqueDeque ud;\n        ud.add(1);\n        ud.add(2);\n        REQUIRE(ud.size() == 2);\n        std::vector<int> expected = {1, 2};\n        std::vector<int> actual(begin(ud), end(ud));\n        REQUIRE(actual == expected);\n        ud.deleteItem(1);\n        REQUIRE(ud.size() == 1);\n        expected = {2};\n        actual = std::vector<int>(begin(ud), end(ud));\n        REQUIRE(actual == expected);\n    }\n}", "prompt": "please write a cpp class , the class signature as below class UniqueDeque {\npublic:\n    // Constructor initializes the deque and set.\n    UniqueDeque() : _deque(), _set() {}\n\n    // Add an item to the deque if it is not already present.\n    // Parameters:\n    // - item: The item to add.\n    // Returns:\n    // - bool: True if the item was added, False if it was already present.\n    bool add(const std::string& item) {\n    }\n\n    // Remove an item from the deque if it exists.\n    // Parameters:\n    // - item: The item to remove.\n    // Returns:\n    // - bool: True if the item was removed, False if it was not found.\n    bool deleteItem(const std::.string& item) {\n    }\n\n    // Check if an item is present in the deque.\n    // Parameters:\n    // - item: The item to check.\n    // Returns:\n    // - bool: True if the item is present, False otherwise.\n    bool contains(const std::string& item) const {\n        return _set.find(item) != _set.end();\n    }\n\n    // Get the number of elements in the deque.\n    // Returns:\n    // - int: The number of unique elements in the deque.\n    size_t size() const {\n        return _deque.size();\n    }\n\n    // Create an iterator for the deque.\n    // Returns:\n    // - iterator: An iterator over the elements in the deque.\n    std::deque<std::string>::iterator begin() {\n        return _deque.begin();\n    }\n\n    std::deque<std::string>::const_iterator begin() const {\n        return _deque.begin();\n    }\n\n    std::deque<std::string>::iterator end() {\n        return _deque.end();\n    }\n\n    std::deque<std::string>::const_iterator end() const {\n        return _deque.end();\n    }\n\nprivate:\n    std::deque<std::string> _deque; // Stores elements in order.\n    std::unordered_set<std::string> _set; // Ensures uniqueness.\n};", "addition_info": ""}, "java": {"code_signature": "public class Answer {\n    static class UniqueDeque{\n        private LinkedList<Integer> deque;\n        private Set<Integer> set;\n\n        public UniqueDeque() {\n\n        }\n\n        public boolean add(int item) {\n\n        }\n\n        public boolean delete(int item) {\n\n        }\n\n        public boolean contains(int item) {\n\n        }\n\n        public int size() {\n\n        }\n\n        public Iterator<Integer> iterator() {\n\n        }\n\n        @Override\n        public String toString() {}\n    }\n}", "test_code": "package org.real.temp;\nimport org.junit.Test;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testAddUniqueElements() {\n        UniqueDeque ud = new UniqueDeque();\n        assertTrue(ud.add(1));\n        assertTrue(ud.add(2));\n        assertTrue(ud.add(3));\n        assertEquals(3, ud.size());\n        Iterator<Integer> iterator = ud.iterator();\n        List<Integer> list = new LinkedList<>();\n        while (iterator.hasNext()) {\n            list.add(iterator.next());\n        }\n        assertEquals(\"[1, 2, 3]\", list.toString());\n    }\n\n    @Test\n    public void testAddDuplicateElements() {\n        UniqueDeque ud = new UniqueDeque();\n        assertTrue(ud.add(1));\n        assertFalse(ud.add(1));  // Duplicate add should return false\n        assertEquals(1, ud.size());\n        Iterator<Integer> iterator = ud.iterator();\n        List<Integer> list = new LinkedList<>();\n        while (iterator.hasNext()) {\n            list.add(iterator.next());\n        }\n        assertEquals(\"[1]\", list.toString());\n    }\n\n    @Test\n    public void testDeleteElements() {\n        UniqueDeque ud = new UniqueDeque();\n        ud.add(1);\n        ud.add(2);\n        ud.add(3);\n        assertTrue(ud.delete(2));\n        assertFalse(ud.delete(2));  // Deleting non-existing element should return false\n        assertEquals(2, ud.size());\n        Iterator<Integer> iterator = ud.iterator();\n        List<Integer> list = new LinkedList<>();\n        while (iterator.hasNext()) {\n            list.add(iterator.next());\n        }\n        assertEquals(\"[1, 3]\", list.toString());\n    }\n\n    @Test\n    public void testContains() {\n        UniqueDeque ud = new UniqueDeque();\n        ud.add(1);\n        assertTrue(ud.contains(1));\n        assertFalse(ud.contains(2));\n        ud.delete(1);\n        assertFalse(ud.contains(1));\n    }\n\n    @Test\n    public void testIterAndLen() {\n        UniqueDeque ud = new UniqueDeque();\n        ud.add(1);\n        ud.add(2);\n        assertEquals(2, ud.size());\n        Iterator<Integer> iterator = ud.iterator();\n        List<Integer> list = new LinkedList<>();\n        while (iterator.hasNext()) {\n            list.add(iterator.next());\n        }\n        assertEquals(\"[1, 2]\", list.toString());\n        ud.delete(1);\n        assertEquals(1, ud.size());\n        iterator = ud.iterator();\n        list.clear();\n        while (iterator.hasNext()) {\n            list.add(iterator.next());\n        }\n        assertEquals(\"[2]\", list.toString());\n    }\n}", "prompt": "please write a java class , the function signature as below public class Answer {\n    static class UniqueDeque{\n        private LinkedList<Integer> deque;\n        private Set<Integer> set;\n\n        public UniqueDeque() {\n\n        }\n\n        public boolean add(int item) {\n\n        }\n\n        public boolean delete(int item) {\n\n        }\n\n        public boolean contains(int item) {\n\n        }\n\n        public int size() {\n\n        }\n\n        public Iterator<Integer> iterator() {\n\n        }\n\n        @Override\n        public String toString() {}\n    }\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 221, "code_type": "method", "original_language": "python", "file_path": "guarantees-based-mechanistic-interpretability-with-data\\bc999acd93d093d66fd1b9b1c840a01f71179dd3\\gbmi\\utils\\__init__.py", "question_type": "File operations and I/O operation", "summary": "extract and parse strings containing Python dictionary syntax from a given file\n", "language_version_list": {"python": {"code_signature": "from typing import Dict, List\n\n\ndef extract_parse_dicts(file_path: str) -> List[Dict]:\n    \"\"\"\n    extract and parse strings containing Python dictionary syntax from a given file\n    Args:\n        file_path (str): The path to the file from which to extract dictionary strings.\n\n    Returns:\n        list: A list of dictionaries extracted and parsed from the file.\n    \"\"\"\n", "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestExtractParseDicts(unittest.TestCase):\n    def test_extract_single_valid_dictionary(self):\n        mock_content = '{\"name\": \"John\", \"age\": 30}'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [{\"name\": \"John\", \"age\": 30}])\n\n    def test_extract_multiple_dictionaries(self):\n        mock_content = '{\"name\": \"John\", \"age\": 30}\\n{\"city\": \"New York\", \"country\": \"USA\"}'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [{\"name\": \"John\", \"age\": 30}, {\"city\": \"New York\", \"country\": \"USA\"}])\n\n    def test_invalid_dictionary_format(self):\n        mock_content = '{\"name\": \"John\", \"age\": \"thirty\"}'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [{'name': 'John', 'age': 'thirty'}])\n\n    def test_empty_file(self):\n        with patch('builtins.open', mock_open(read_data='')):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [])\n\n", "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef extract_parse_dicts(file_path: str) -> List[Dict]:\n    \"\"\"\n    extract and parse strings containing Python dictionary syntax from a given file\n    Args:\n        file_path (str): The path to the file from which to extract dictionary strings.\n\n    Returns:\n        list: A list of dictionaries extracted and parsed from the file.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 224, "code_type": "method", "original_language": "python", "file_path": "GenAI_RAG\\ae365a3cc4dcc1bae65dea488e5a857e488c135d\\Create_Embeddings.py", "question_type": "File operations and I/O operation", "summary": "Empty all files and subdirectories in the specified directory\n", "language_version_list": {"python": {"code_signature": "def empty_directory(directory_path:str):\n    \"\"\"\n    empty all files and subdirectories in the specified directory\n    Args:\n        directory_path (str): Path to the directory whose contents are to be emptied.\n\n    Returns:\n        None or ValueError: If the specified path does not exist or is not a directory.\n    \"\"\"\n", "test_code": "import os\nimport shutil\nimport tempfile\nimport unittest\n\n\nclass TestEmptyDirectory(unittest.TestCase):\n    def setUp(self):\n        # Set up a temporary directory with some files and directories\n        self.test_dir = tempfile.mkdtemp()\n        # Create some files and directories\n        os.mkdir(os.path.join(self.test_dir, 'subdir'))\n        with open(os.path.join(self.test_dir, 'file1.txt'), 'w') as f:\n            f.write(\"Hello\")\n        with open(os.path.join(self.test_dir, 'subdir', 'file2.txt'), 'w') as f:\n            f.write(\"World\")\n\n    def tearDown(self):\n        # Remove the temporary directory after each test.js\n        shutil.rmtree(self.test_dir)\n\n    def test_empty_directory_success(self):\n        \"\"\" Test that the directory is emptied successfully \"\"\"\n        empty_directory(self.test_dir)\n        self.assertEqual(os.listdir(self.test_dir), [])  # Directory should be empty\n\n\n\n    def test_empty_directory_with_subdirectories(self):\n        \"\"\" Test emptying a directory that includes subdirectories \"\"\"\n        empty_directory(self.test_dir)\n        self.assertFalse(os.listdir(self.test_dir))  # Directory and subdirectory should be empty\n\n    def test_empty_already_empty_directory(self):\n        \"\"\" Test emptying a directory that is already empty \"\"\"\n        empty_directory(self.test_dir)  # First emptying\n        empty_directory(self.test_dir)  # Empty again\n        self.assertEqual(os.listdir(self.test_dir), [])  # Still should be empty\n", "prompt": "please write a python function , the function signature as below def empty_directory(directory_path:str):\n    \"\"\"\n    empty all files and subdirectories in the specified directory\n    Args:\n        directory_path (str): Path to the directory whose contents are to be emptied.\n\n    Returns:\n        None or ValueError: If the specified path does not exist or is not a directory.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Empties all files and subdirectories in the specified directory.\n *\n * @param directoryPath The path to the directory whose contents are to be emptied.\n * @return void or std::invalid_argument: If the specified path does not exist or is not a directory.\n */\nvoid empty_directory(const std::string& directoryPath);", "test_code": "TEST_CASE(\"Empty Directory\", \"[empty_directory]\") {\n    // Test cases go here\n\n    SECTION(\"Non-existent directory\") {\n        REQUIRE_THROWS_AS(empty_directory(\"/path/to/nonexistent/directory\"), std::invalid_argument);\n    }\n\n    SECTION(\"Non-directory path\") {\n        REQUIRE_THROWS_AS(empty_directory(\"/path/to/file.txt\"), std::invalid_argument);\n    }\n\n    SECTION(\"Empty directory\") {\n        fs::create_directories(\"/tmp/test_dir\");\n        empty_directory(\"/tmp/test_dir\");\n        REQUIRE(fs::directory_iterator(\"/tmp/test_dir\").begin() == fs::directory_iterator(\"/tmp/test_dir\").end());\n        fs::remove_all(\"/tmp/test_dir\");\n    }\n\n    SECTION(\"Directory with files\") {\n        fs::create_directories(\"/tmp/test_dir\");\n        fs::create_file(\"/tmp/test_dir/file1.txt\");\n        fs::create_file(\"/tmp/test_dir/file2.txt\");\n        empty_directory(\"/tmp/test_dir\");\n        REQUIRE(fs::directory_iterator(\"/tmp/test_dir\").begin() == fs::directory_iterator(\"/tmp/test_dir\").end());\n        fs::remove_all(\"/tmp/test_dir\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Empties all files and subdirectories in the specified directory.\n *\n * @param directoryPath The path to the directory whose contents are to be emptied.\n * @return void or std::invalid_argument: If the specified path does not exist or is not a directory.\n */\nvoid empty_directory(const std::string& directoryPath);", "addition_info": ""}, "java": {"code_signature": "/**\n * Empties all files and subdirectories in the specified directory.\n *\n * @param directoryPath The path to the directory whose contents are to be emptied.\n * @throws IllegalArgumentException if the specified path does not exist or is not a directory.\n */\npublic static void emptyDirectory(String directoryPath) {}", "test_code": "import org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.File;\n\npublic class Tester {\n\n    private File testDirectory;\n\n    @Before\n    public void setUp() {\n        // Create a temporary directory for testing\n        testDirectory = new File(\"tempTestDir\");\n        if (!testDirectory.exists()) {\n            testDirectory.mkdirs();\n        }\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testEmptyNonExistentDirectory() {\n        // Test with a non-existent directory\n        empty_directory(\"non_existent_dir\");\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testEmptyFileInsteadOfDirectory() {\n        // Test with a file instead of a directory\n        File tempFile = new File(testDirectory, \"testFile.txt\");\n        try {\n            tempFile.createNewFile();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        empty_directory(tempFile.getAbsolutePath());\n    }\n\n    @Test\n    public void testEmptyExistingDirectory() {\n        // Test with an existing directory\n        File subDirectory = new File(testDirectory, \"subDir\");\n        subDirectory.mkdir();\n\n        File testFile = new File(subDirectory, \"testFile.txt\");\n        try {\n            testFile.createNewFile();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        empty_directory(testDirectory.getAbsolutePath());\n\n        // Verify that the directory is empty\n        assert !subDirectory.exists() : \"Subdirectory should have been deleted\";\n        assert !testFile.exists() : \"Test file should have been deleted\";\n    }\n\n    /**\n     * Method to empty all files and subdirectories in the specified directory.\n     *\n     * @param directoryPath Path to the directory whose contents are to be emptied.\n     * @throws IllegalArgumentException If the specified path does not exist or is not a directory.\n     */\n    public static void empty_directory(String directoryPath) throws IllegalArgumentException {\n        File directory = new File(directoryPath);\n        if (!directory.exists() || !directory.isDirectory()) {\n            throw new IllegalArgumentException(\"The specified path does not exist or is not a directory.\");\n        }\n\n        File[] files = directory.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                if (file.isDirectory()) {\n                    empty_directory(file.getAbsolutePath()); // Recursively delete subdirectories\n                }\n                file.delete(); // Delete files\n            }\n        }\n        directory.delete(); // Delete the main directory\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Empties all files and subdirectories in the specified directory.\n *\n * @param directoryPath The path to the directory whose contents are to be emptied.\n * @throws IllegalArgumentException if the specified path does not exist or is not a directory.\n */\npublic static void emptyDirectory(String directoryPath) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 226, "code_type": "method", "original_language": "python", "file_path": "Final_NLP\\1bc3ddcfc74a5661898ea201ef7d7b6a1f42b9e0\\contrast_sets\\tsv_to_jsonl.py", "question_type": "Data processing and transformation", "summary": "convert tsv file to jsonl file\n", "language_version_list": {"python": {"code_signature": "import pandas as pd\n\n\ndef tsv_to_jsonl(tsv_file: str, jsonl_file: str):\n    \"\"\"\n    Convert tsv file to jsonl file\n\n    Args:\n        tsv_file: tsf file path\n        jsonl_file: jsonl file path\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import os\nimport tempfile\nimport unittest\n\n\nclass TestTSVtoJSONL(unittest.TestCase):\n\n    def setUp(self):\n        # Create a temporary directory for testing\n        self.test_dir = tempfile.TemporaryDirectory()\n\n    def tearDown(self):\n        # Clean up the temporary directory\n        self.test_dir.cleanup()\n\n    def test_standard_tsv(self):\n        tsv_content = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\nBob\\t25\\tCanada\\n\"\n        tsv_file = os.path.join(self.test_dir.name, 'test_standard.tsv')\n        jsonl_file = os.path.join(self.test_dir.name, 'test_standard.jsonl')\n\n        with open(tsv_file, 'w', encoding='utf-8') as f:\n            f.write(tsv_content)\n\n        tsv_to_jsonl(tsv_file, jsonl_file)\n\n        with open(jsonl_file, 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n\n        expected_lines = [\n            '{\"Name\":\"Alice\",\"Age\":30,\"Country\":\"USA\"}\\n',\n            '{\"Name\":\"Bob\",\"Age\":25,\"Country\":\"Canada\"}\\n'\n        ]\n        self.assertEqual(lines, expected_lines)\n\n\n    def test_single_row_tsv(self):\n        tsv_content = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\n\"\n        tsv_file = os.path.join(self.test_dir.name, 'test_single_row.tsv')\n        jsonl_file = os.path.join(self.test_dir.name, 'test_single_row.jsonl')\n\n        with open(tsv_file, 'w', encoding='utf-8') as f:\n            f.write(tsv_content)\n\n        tsv_to_jsonl(tsv_file, jsonl_file)\n\n        with open(jsonl_file, 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n\n        expected_lines = [\n            '{\"Name\":\"Alice\",\"Age\":30,\"Country\":\"USA\"}\\n'\n        ]\n        self.assertEqual(lines, expected_lines)\n\n    def test_numeric_and_boolean_values(self):\n        tsv_content = \"Name\\tAge\\tIs_Student\\nAlice\\t30\\tTrue\\nBob\\t25\\tFalse\\n\"\n        tsv_file = os.path.join(self.test_dir.name, 'test_numeric_boolean.tsv')\n        jsonl_file = os.path.join(self.test_dir.name, 'test_numeric_boolean.jsonl')\n\n        with open(tsv_file, 'w', encoding='utf-8') as f:\n            f.write(tsv_content)\n\n        tsv_to_jsonl(tsv_file, jsonl_file)\n\n        with open(jsonl_file, 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n\n        expected_lines = [\n            '{\"Name\":\"Alice\",\"Age\":30,\"Is_Student\":true}\\n',\n            '{\"Name\":\"Bob\",\"Age\":25,\"Is_Student\":false}\\n'\n        ]\n        self.assertEqual(lines, expected_lines)\n", "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef tsv_to_jsonl(tsv_file: str, jsonl_file: str):\n    \"\"\"\n    Convert tsv file to jsonl file\n\n    Args:\n        tsv_file: tsf file path\n        jsonl_file: jsonl file path\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert tsv file to jsonl file\n *\n * @param tsv_file: Path to the tsv file\n * @param jsonl_file: Path to the jsonl file\n */\nvoid tsv_to_jsonl(const std::string& tsv_file, const std::string& jsonl_file);", "test_code": "TEST_CASE(\"Test TSV to JSONL conversion\", \"[tsv_to_jsonl]\") {\n    // Create a temporary directory for testing\n    fs::path temp_dir = fs::temp_directory_path() / \"test_tsv_to_jsonl\";\n    fs::create_directory(temp_dir);\n\n    SECTION(\"Standard TSV\") {\n        std::string tsv_content = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\nBob\\t25\\tCanada\\n\";\n        std::string tsv_file = (temp_dir / \"test_standard.tsv\").string();\n        std::string jsonl_file = (temp_dir / \"test_standard.jsonl\").string();\n\n        std::ofstream tsv(tsv_file);\n        tsv << tsv_content;\n        tsv.close();\n\n        tsv_to_jsonl(tsv_file, jsonl_file);\n\n        std::ifstream jsonl(jsonl_file);\n        std::vector<std::string> lines;\n        std::string line;\n        while (std::getline(jsonl, line)) {\n            lines.push_back(line + \"\\n\");\n        }\n        jsonl.close();\n\n        std::vector<std::string> expected_lines = {\n            \"{\\\"Name\\\":\\\"Alice\\\",\\\"Age\\\":30,\\\"Country\\\":\\\"USA\\\"}\\n\",\n            \"{\\\"Name\\\":\\\"Bob\\\",\\\"Age\\\":25,\\\"Country\\\":\\\"Canada\\\"}\\n\"\n        };\n\n        REQUIRE(lines == expected_lines);\n    }\n\n    SECTION(\"Single Row TSV\") {\n        std::string tsv_content = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\n\";\n        std::string tsv_file = (temp_dir / \"test_single_row.tsv\").string();\n        std::string jsonl_file = (temp_dir / \"test_single_row.jsonl\").string();\n\n        std::ofstream tsv(tsv_file);\n        tsv << tsv_content;\n        tsv.close();\n\n        tsv_to_jsonl(tsv_file, jsonl_file);\n\n        std::ifstream jsonl(jsonl_file);\n        std::vector<std::string> lines;\n        std::string line;\n        while (std::getline(jsonl, line)) {\n            lines.push_back(line + \"\\n\");\n        }\n        jsonl.close();\n\n        std::vector<std::string> expected_lines = {\n            \"{\\\"Name\\\":\\\"Alice\\\",\\\"Age\\\":30,\\\"Country\\\":\\\"USA\\\"}\\n\"\n        };\n\n        REQUIRE(lines == expected_lines);\n    }\n\n    SECTION(\"Numeric and Boolean Values\") {\n        std::string tsv_content = \"Name\\tAge\\tIs_Student\\nAlice\\t30\\tTrue\\nBob\\t25\\tFalse\\n\";\n        std::string tsv_file = (temp_dir / \"test_numeric_boolean.tsv\").string();\n        std::string jsonl_file = (temp_dir / \"test_numeric_boolean.jsonl\").string();\n\n        std::ofstream tsv(tsv_file);\n        tsv << tsv_content;\n        tsv.close();\n\n        tsv_to_jsonl(tsv_file, jsonl_file);\n\n        std::ifstream jsonl(jsonl_file);\n        std::vector<std::string> lines;\n        std::string line;\n        while (std::getline(jsonl, line)) {\n            lines.push_back(line + \"\\n\");\n        }\n        jsonl.close();\n\n        std::vector<std::string> expected_lines = {\n            \"{\\\"Name\\\":\\\"Alice\\\",\\\"Age\\\":30,\\\"Is_Student\\\":true}\\n\",\n            \"{\\\"Name\\\":\\\"Bob\\\",\\\"Age\\\":25,\\\"Is_Student\\\":false}\\n\"\n        };\n\n        REQUIRE(lines == expected_lines);\n    }\n\n    // Clean up the temporary directory\n    fs::remove_all(temp_dir);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert tsv file to jsonl file\n *\n * @param tsv_file: Path to the tsv file\n * @param jsonl_file: Path to the jsonl file\n */\nvoid tsv_to_jsonl(const std::string& tsv_file, const std::string& jsonl_file);", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts TSV (Tab-Separated Values) file to JSONL (JSON Lines) file.\n *\n * @param tsvFile  The path to the TSV file.\n * @param jsonlFile The path to the JSONL file.\n */\npublic void tsvToJsonL(String tsvFile, String jsonlFile) throws IOException {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\nimport static org.real.temp.Answer.*;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Tests for the TSV to JSONL conversion.\n */\npublic class Tester {\n\n    private Path tempDir;\n\n    /**\n     * Sets up a temporary directory for testing.\n     */\n    @Before\n    public void setUp() throws IOException {\n        // Create a temporary directory\n        tempDir = Files.createTempDirectory(\"testDir\");\n    }\n\n    /**\n     * Cleans up the temporary directory after each test.\n     */\n    @After\n    public void tearDown() throws IOException {\n        // Delete the temporary directory and its contents\n        Files.walk(tempDir)\n                .sorted((path1, path2) -> path2.compareTo(path1)) // Delete files before directories\n                .forEach(path -> {\n                    try {\n                        Files.delete(path);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                });\n    }\n\n    /**\n     * Tests the conversion of a standard TSV file to JSONL.\n     */\n    @Test\n    public void testStandardTSV() throws IOException {\n        String tsvContent = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\nBob\\t25\\tCanada\\n\";\n        Path tsvFile = tempDir.resolve(\"test_standard.tsv\");\n        Path jsonlFile = tempDir.resolve(\"test_standard.jsonl\");\n\n        try (Writer writer = new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(tsvFile), \"UTF-8\"))) {\n            writer.write(tsvContent);\n        }\n\n        tsvToJSONL(tsvFile.toString(), jsonlFile.toString());\n\n        List<String> lines = Files.readAllLines(jsonlFile);\n\n        List<String> expectedLines = List.of(\n                \"{\\\"Name\\\":\\\"Alice\\\",\\\"Age\\\":30,\\\"Country\\\":\\\"USA\\\"}\\n\",\n                \"{\\\"Name\\\":\\\"Bob\\\",\\\"Age\\\":25,\\\"Country\\\":\\\"Canada\\\"}\\n\"\n        );\n\n        assertEquals(expectedLines, lines);\n    }\n\n    /**\n     * Tests the conversion of a single-row TSV file to JSONL.\n     */\n    @Test\n    public void testSingleRowTSV() throws IOException {\n        String tsvContent = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\n\";\n        Path tsvFile = tempDir.resolve(\"test_single_row.tsv\");\n        Path jsonlFile = tempDir.resolve(\"test_single_row.jsonl\");\n\n        try (Writer writer = new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(tsvFile), \"UTF-8\"))) {\n            writer.write(tsvContent);\n        }\n\n        tsvToJSONL(tsvFile.toString(), jsonlFile.toString());\n\n        List<String> lines = Files.readAllLines(jsonlFile);\n\n        List<String> expectedLines = List.of(\n                \"{\\\"Name\\\":\\\"Alice\\\",\\\"Age\\\":30,\\\"Country\\\":\\\"USA\\\"}\\n\"\n        );\n\n        assertEquals(expectedLines, lines);\n    }\n\n    /**\n     * Tests the conversion of a TSV file with numeric and boolean values to JSONL.\n     */\n    @Test\n    public void testNumericAndBooleanValues() throws IOException {\n        String tsvContent = \"Name\\tAge\\tIs_Student\\nAlice\\t30\\tTrue\\nBob\\t25\\tFalse\\n\";\n        Path tsvFile = tempDir.resolve(\"test_numeric_boolean.tsv\");\n        Path jsonlFile = tempDir.resolve(\"test_numeric_boolean.jsonl\");\n\n        try (Writer writer = new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(tsvFile), \"UTF-8\"))) {\n            writer.write(tsvContent);\n        }\n\n        tsvToJSONL(tsvFile.toString(), jsonlFile.toString());\n\n        List<String> lines = Files.readAllLines(jsonlFile);\n\n        List<String> expectedLines = List.of(\n                \"{\\\"Name\\\":\\\"Alice\\\",\\\"Age\\\":30,\\\"Is_Student\\\":true}\\n\",\n                \"{\\\"Name\\\":\\\"Bob\\\",\\\"Age\\\":25,\\\"Is_Student\\\":false}\\n\"\n        );\n\n        assertEquals(expectedLines, lines);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts TSV (Tab-Separated Values) file to JSONL (JSON Lines) file.\n *\n * @param tsvFile  The path to the TSV file.\n * @param jsonlFile The path to the JSONL file.\n */\npublic void tsvToJsonL(String tsvFile, String jsonlFile) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 227, "code_type": "method", "original_language": "python", "file_path": "image_color_distribution\\e4011b1cb8e9c3966bb5eeb675f608a62707ada6\\color_distribution.py", "question_type": "Data processing and transformation", "summary": "Count how many colors appear in the picture", "language_version_list": {"python": {"code_signature": "def count_unique_colors(image_path: str) -> int:\n    \"\"\"\n    Count the number of unique colors in an image.\n\n    Args:\n        image_path (str): Path to the image file.\n\n    Returns:\n        int: The number of unique colors in the image.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestCountUniqueColor(unittest.TestCase):\n\n    def test_case1(self):\n        picture_path = r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase01.png\"\n        expected_color_num = 1\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n\n    def test_case2(self):\n        picture_path = r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase02.png\"\n        expected_color_num = 2\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n\n    def test_case3(self):\n        picture_path =r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase03.png\"\n        expected_color_num = 3\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n    def test_case4(self):\n        picture_path =r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase04.png\"\n        expected_color_num = 466\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)", "prompt": "please write a python function , the function signature as below def count_unique_colors(image_path: str) -> int:\n    \"\"\"\n    Count the number of unique colors in an image.\n\n    Args:\n        image_path (str): Path to the image file.\n\n    Returns:\n        int: The number of unique colors in the image.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Count the number of unique colors in an image.\n *\n * @param image_path The path to the image file.\n * @return The number of unique colors in the image.\n */\nint count_unique_colors(const std::string& image_path);", "test_code": "TEST_CASE(\"Test count_unique_colors function\", \"[count_unique_colors]\") {\n    SECTION(\"Test case 1\") {\n        std::string picture_path = R\"(E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase01.png)\";\n        int expected_color_num = 1;\n        int output = count_unique_colors(picture_path);\n        REQUIRE(output == expected_color_num);\n    }\n\n    SECTION(\"Test case 2\") {\n        std::string picture_path = R\"(E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase02.png)\";\n        int expected_color_num = 2;\n        int output = count_unique_colors(picture_path);\n        REQUIRE(output == expected_color_num);\n    }\n\n    SECTION(\"Test case 3\") {\n        std::string picture_path = R\"(E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase03.png)\";\n        int expected_color_num = 3;\n        int output = count_unique_colors(picture_path);\n        REQUIRE(output == expected_color_num);\n    }\n\n    SECTION(\"Test case 4\") {\n        std::string picture_path = R\"(E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase04.png)\";\n        int expected_color_num = 466;\n        int output = count_unique_colors(picture_path);\n        REQUIRE(output == expected_color_num);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Count the number of unique colors in an image.\n *\n * @param image_path The path to the image file.\n * @return The number of unique colors in the image.\n */\nint count_unique_colors(const std::string& image_path);", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 229, "code_type": "method", "original_language": "python", "file_path": "computer-vision-american-sign-language\\f93eebaa293856d64f977f1caf1bc76a12e74f39\\custom_functions\\fileinfo.py", "question_type": "File operations and I/O operation", "summary": "Convert the file size from byte units to a more readable format (e.g. KB, MB, GB) such as 2120B, convert the bits to 2KB, keeping only the integer parts\n", "language_version_list": {"python": {"code_signature": "def convert_file_size(size_bytes: int) -> str:\n    \"\"\"\n    Converts a file size in bytes to a human-readable format.\n    For example:\n        input: 2120\n        output: 2KB\n    Args:\n        size_bytes (int): The size in bytes to be converted.\n\n    Returns:\n        str: The converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n    \"\"\"\n", "test_code": "# Unit test class\nimport unittest\n\n\nclass TestFileSizeConverter(unittest.TestCase):\n\n\n    def test_zero_bytes(self):\n        self.assertEqual(convert_file_size(0), \"0B\")\n\n    def test_bytes_less_than_1KB(self):\n        self.assertEqual(convert_file_size(512), \"512B\")\n\n    def test_exactly_1KB(self):\n        self.assertEqual(convert_file_size(1024), \"1KB\")\n\n    def test_2KB(self):\n        self.assertEqual(convert_file_size(2048), \"2KB\")\n\n    def test_exactly_1MB(self):\n        self.assertEqual(convert_file_size(1048576), \"1MB\")\n\n    def test_5MB(self):\n        self.assertEqual(convert_file_size(5242880), \"5MB\")\n\n    def test_exactly_1GB(self):\n        self.assertEqual(convert_file_size(1073741824), \"1GB\")", "prompt": "please write a python function , the function signature as below def convert_file_size(size_bytes: int) -> str:\n    \"\"\"\n    Converts a file size in bytes to a human-readable format.\n    For example:\n        input: 2120\n        output: 2KB\n    Args:\n        size_bytes (int): The size in bytes to be converted.\n\n    Returns:\n        str: The converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts a file size in bytes to a human-readable format.\n * For example:\n *     input: 2120\n *     output: 2KB\n *\n * @param size_bytes The size in bytes to be converted.\n * @return A string representing the converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n */\nstd::string convertFileSize(int64_t sizeBytes);", "test_code": "TEST_CASE(\"Convert file size to human-readable format\", \"[convert_file_size]\") {\n    REQUIRE(convert_file_size(2120) == \"2KB\");\n    REQUIRE(convert_file_size(1048576) == \"1MB\");\n    REQUIRE(convert_file_size(1073741824) == \"1GB\");\n    // Add more test cases as needed\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts a file size in bytes to a human-readable format.\n * For example:\n *     input: 2120\n *     output: 2KB\n *\n * @param size_bytes The size in bytes to be converted.\n * @return A string representing the converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n */\nstd::string convertFileSize(int64_t sizeBytes);", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a file size in bytes to a human-readable format.\n * For example:\n *     input: 2120\n *     output: 2KB\n *\n * @param sizeBytes The size in bytes to be converted.\n * @return The converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n */\npublic static String convertFileSize(long sizeBytes) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n/**\n * Test class for the file size converter.\n */\npublic class Tester {\n\n    /**\n     * Tests the conversion of zero bytes.\n     */\n    @Test\n    public void testZeroBytes() {\n        assertEquals(\"0B\", convertFileSize(0));\n    }\n\n    /**\n     * Tests the conversion of bytes less than 1KB.\n     */\n    @Test\n    public void testBytesLessThan1KB() {\n        assertEquals(\"512B\", convertFileSize(512));\n    }\n\n    /**\n     * Tests the conversion of exactly 1KB.\n     */\n    @Test\n    public void testExactly1KB() {\n        assertEquals(\"1KB\", convertFileSize(1024));\n    }\n\n    /**\n     * Tests the conversion of 2KB.\n     */\n    @Test\n    public void test2KB() {\n        assertEquals(\"2KB\", convertFileSize(2048));\n    }\n\n    /**\n     * Tests the conversion of exactly 1MB.\n     */\n    @Test\n    public void testExactly1MB() {\n        assertEquals(\"1MB\", convertFileSize(1048576));\n    }\n\n    /**\n     * Tests the conversion of 5MB.\n     */\n    @Test\n    public void test5MB() {\n        assertEquals(\"5MB\", convertFileSize(5242880));\n    }\n\n    /**\n     * Tests the conversion of exactly 1GB.\n     */\n    @Test\n    public void testExactly1GB() {\n        assertEquals(\"1GB\", convertFileSize(1073741824L));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a file size in bytes to a human-readable format.\n * For example:\n *     input: 2120\n *     output: 2KB\n *\n * @param sizeBytes The size in bytes to be converted.\n * @return The converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n */\npublic static String convertFileSize(long sizeBytes) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 230, "code_type": "method", "original_language": "python", "file_path": "heavenfire\\c76110867c82e6d45f233cea4b5760822da72aac\\python\\utils.py", "question_type": "Data processing and transformation", "summary": "move the emoj expression in the string to the end of the text\n", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef move_emojis_to_end(text: str):\n    \"\"\"\n    Move the emoj expression in the string to the end of the text\n\n    Args:\n        text (str): The input string containing text and possibly emojis.\n\n    Returns:\n        str: The modified string with all emojis moved to the end.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestMoveEmojisToEnd(unittest.TestCase):\n\n    def test_no_emojis(self):\n        # Case: String with no emojis\n        input_text = \"This is a test.\"\n        expected_output = \"This is a test.\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_all_emojis(self):\n        # Case: String with only emojis\n        input_text = \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\"\n        expected_output = \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_emojis_at_start(self):\n        # Case: Emojis at the start of the text\n        input_text = \"\ud83d\ude00\ud83d\ude03Hello world!\"\n        expected_output = \"Hello world!\ud83d\ude00\ud83d\ude03\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_emojis_at_end(self):\n        # Case: Emojis already at the end of the text\n        input_text = \"Hello world!\ud83d\ude00\ud83d\ude03\"\n        expected_output = \"Hello world!\ud83d\ude00\ud83d\ude03\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_emojis_in_middle(self):\n        # Case: Emojis in the middle of the text\n        input_text = \"Hello \ud83d\ude00world\ud83d\ude03!\"\n        expected_output = \"Hello world!\ud83d\ude00\ud83d\ude03\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_mixed_characters(self):\n        # Case: Text with mixed characters and emojis\n        input_text = \"Hi! \ud83d\ude00 How are you? \ud83d\ude03\"\n        expected_output = \"Hi!  How are you? \ud83d\ude00\ud83d\ude03\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef move_emojis_to_end(text: str):\n    \"\"\"\n    Move the emoj expression in the string to the end of the text\n\n    Args:\n        text (str): The input string containing text and possibly emojis.\n\n    Returns:\n        str: The modified string with all emojis moved to the end.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "std::string moveEmojisToEnd(const std::string& text) {\n    /*\n    Move the emoj expression in the string to the end of the text\n\n    Args:\n        text (const std::string&): The input string containing text and possibly emojis.\n\n    Returns:\n        std::string: The modified string with all emojis moved to the end.\n    */\n\n    // Regex pattern to match any emoji character\n    std::regex emojiPattern(R\"([\\x{1F600}-\\x{1F64F}\\x{1F300}-\\x{1F5FF}\\x{1F680}-\\x{1F6FF}\\x{2600}-\\x{26FF}\\x{2700}-\\x{27BF}])\", std::regex_constants::icase);\n    return result;\n}", "test_code": "TEST_CASE(\"Move Emojis to End\", \"[move_emojis_to_end]\") {\n    REQUIRE(move_emojis_to_end(\"\") == \"\");\n    REQUIRE(move_emojis_to_end(\"Hello World!\") == \"Hello World!\");\n    REQUIRE(move_emojis_to_end(\"Hello \ud83c\udf0d!\") == \"Hello !\ud83c\udf0d\");\n    REQUIRE(move_emojis_to_end(\"\ud83d\udc4b Hello \ud83c\udf0d!\") == \"Hello !\ud83d\udc4b\ud83c\udf0d\");\n    REQUIRE(move_emojis_to_end(\"Hello \ud83c\udf0d\ud83d\udc4b!\") == \"Hello !\ud83d\udc4b\ud83c\udf0d\");\n}", "prompt": "please write a cpp function , the function signature as below std::string moveEmojisToEnd(const std::string& text) {\n    /*\n    Move the emoj expression in the string to the end of the text\n\n    Args:\n        text (const std::string&): The input string containing text and possibly emojis.\n\n    Returns:\n        std::string: The modified string with all emojis moved to the end.\n    */\n\n    // Regex pattern to match any emoji character\n    std::regex emojiPattern(R\"([\\x{1F600}-\\x{1F64F}\\x{1F300}-\\x{1F5FF}\\x{1F680}-\\x{1F6FF}\\x{2600}-\\x{26FF}\\x{2700}-\\x{27BF}])\", std::regex_constants::icase);\n    return result;\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Moves the emoji expressions in the string to the end of the text.\n *\n * @param text The input string containing text and possibly emojis.\n * @return The modified string with all emojis moved to the end.\n */\npublic static String moveEmojisToEnd(String text) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.real.temp.Answer.*;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for the moveEmojisToEnd function.\n */\npublic class Tester {\n\n    /**\n     * Tests the case where the input string contains no emojis.\n     */\n    @Test\n    public void testNoEmojis() {\n        String inputText = \"This is a test.\";\n        String expectedOutput = \"This is a test.\";\n        assertEquals(expectedOutput, moveEmojisToEnd(inputText));\n    }\n\n    /**\n     * Tests the case where the input string contains only emojis.\n     */\n    @Test\n    public void testAllEmojis() {\n        String inputText = \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\";\n        String expectedOutput = \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\";\n        assertEquals(expectedOutput, moveEmojisToEnd(inputText));\n    }\n\n    /**\n     * Tests the case where emojis are at the start of the text.\n     */\n    @Test\n    public void testEmojisAtStart() {\n        String inputText = \"\ud83d\ude00\ud83d\ude03Hello world!\";\n        String expectedOutput = \"Hello world!\ud83d\ude00\ud83d\ude03\";\n        assertEquals(expectedOutput, moveEmojisToEnd(inputText));\n    }\n\n    /**\n     * Tests the case where emojis are already at the end of the text.\n     */\n    @Test\n    public void testEmojisAtEnd() {\n        String inputText = \"Hello world!\ud83d\ude00\ud83d\ude03\";\n        String expectedOutput = \"Hello world!\ud83d\ude00\ud83d\ude03\";\n        assertEquals(expectedOutput, moveEmojisToEnd(inputText));\n    }\n\n    /**\n     * Tests the case where emojis are in the middle of the text.\n     */\n    @Test\n    public void testEmojisInMiddle() {\n        String inputText = \"Hello \ud83d\ude00world\ud83d\ude03!\";\n        String expectedOutput = \"Hello world!\ud83d\ude00\ud83d\ude03\";\n        assertEquals(expectedOutput, moveEmojisToEnd(inputText));\n    }\n\n    /**\n     * Tests the case where the input string contains mixed characters and emojis.\n     */\n    @Test\n    public void testMixedCharacters() {\n        String inputText = \"Hi! \ud83d\ude00 How are you? \ud83d\ude03\";\n        String expectedOutput = \"Hi!  How are you? \ud83d\ude00\ud83d\ude03\";\n        assertEquals(expectedOutput, moveEmojisToEnd(inputText));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Moves the emoji expressions in the string to the end of the text.\n *\n * @param text The input string containing text and possibly emojis.\n * @return The modified string with all emojis moved to the end.\n */\npublic static String moveEmojisToEnd(String text) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 231, "code_type": "method", "original_language": "python", "file_path": "BN-ViT\\b16754870cbe4d4d2701a0a35f28473e0c513f96\\img\\plot.py", "question_type": "Data processing and transformation", "summary": "Reads a log file where each line is a JSON object containing 'test_acc1' and 'train_loss' values.Parses these lines and collects the values into two lists, one for each metric. ", "language_version_list": {"python": {"code_signature": "def read_log(log_file_path):\n    \"\"\"\n    Reads a log file containing JSON entries and extracts training loss and test accuracy.\n    Json entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}\n    Args:\n        log_file_path (str): The path to the log file to be read.\n\n    Returns:\n        tuple: A tuple containing two lists:\n            - train_loss_list (list): A list of training loss values extracted from the log.\n            - test_acc1_list (list): A list of test accuracy values extracted from the log.\n    \"\"\"\n", "test_code": "import json\nimport unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestReadLog(unittest.TestCase):\n\n    def test_read_correct_data(self):\n        \"\"\" Test reading correctly formatted JSON lines \"\"\"\n        mock_file_content = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}\\n' \\\n                            '{\"test_acc1\": 89.0, \"train_loss\": 0.70}'\n        with patch('builtins.open', mock_open(read_data=mock_file_content)):\n            train_loss, test_acc1 = read_log(\"dummy_path.json\")\n            self.assertEqual(train_loss, [0.75, 0.70])\n            self.assertEqual(test_acc1, [88.5, 89.0])\n\n    def test_read_correct_data_single(self):\n        \"\"\" Test reading correctly formatted JSON lines \"\"\"\n        mock_file_content = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}'\n        with patch('builtins.open', mock_open(read_data=mock_file_content)):\n            train_loss, test_acc1 = read_log(\"dummy_path.json\")\n            self.assertEqual(train_loss, [0.75])\n            self.assertEqual(test_acc1, [88.5])\n    def test_empty_file(self):\n        \"\"\" Test reading an empty file \"\"\"\n        with patch('builtins.open', mock_open(read_data=\"\")):\n            train_loss, test_acc1 = read_log(\"empty_file.json\")\n            self.assertEqual(train_loss, [])\n            self.assertEqual(test_acc1, [])\n\n    def test_partial_data_entries(self):\n        \"\"\" Test file with missing fields in some entries \"\"\"\n        mock_file_content = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}\\n' \\\n                            '{\"test_acc1\": 90.0,\"train_loss\": 0.75,\"f1\":0.91}'  # Missing train_loss\n        with patch('builtins.open', mock_open(read_data=mock_file_content)):\n            train_loss, test_acc1 = read_log(\"partial_data_file.json\")\n            self.assertEqual(train_loss, [0.75, 0.75])  # Only one complete entry\n            self.assertEqual(test_acc1, [88.5, 90.0])\n", "prompt": "please write a python function , the function signature as below def read_log(log_file_path):\n    \"\"\"\n    Reads a log file containing JSON entries and extracts training loss and test accuracy.\n    Json entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}\n    Args:\n        log_file_path (str): The path to the log file to be read.\n\n    Returns:\n        tuple: A tuple containing two lists:\n            - train_loss_list (list): A list of training loss values extracted from the log.\n            - test_acc1_list (list): A list of test accuracy values extracted from the log.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads a log file containing JSON entries and extracts training loss and test accuracy.\n * Json entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}\n *\n * @param log_file_path The path to the log file to be read.\n * @return A pair of vectors containing two lists:\n *         - train_loss_list: A vector of training loss values extracted from the log.\n *         - test_acc1_list: A vector of test accuracy values extracted from the log.\n */\nstd::pair<std::vector<double>, std::vector<double>> read_log(const std::string& log_file_path){}\n", "test_code": "TEST_CASE(\"readLog function tests\") {\n    \n    // Create a temporary file for testing\n    std::string testFilePath = \"dummy_path.json\";\n\n    SECTION(\"reads correctly formatted JSON lines\") {\n        std::ofstream outFile(testFilePath);\n        outFile << \"{\\\"test_acc1\\\": 88.5, \\\"train_loss\\\": 0.75}\\n\"\n                << \"{\\\"test_acc1\\\": 89.0, \\\"train_loss\\\": 0.70}\";\n        outFile.close();\n\n        auto [trainLossList, testAcc1List] = readLog(testFilePath);\n        REQUIRE(trainLossList == std::vector<double>{0.75, 0.70});\n        REQUIRE(testAcc1List == std::vector<double>{88.5, 89.0});\n    }\n\n    SECTION(\"reads correctly formatted JSON lines - single entry\") {\n        std::ofstream outFile(testFilePath);\n        outFile << \"{\\\"test_acc1\\\": 88.5, \\\"train_loss\\\": 0.75}\";\n        outFile.close();\n\n        auto [trainLossList, testAcc1List] = readLog(testFilePath);\n        REQUIRE(trainLossList == std::vector<double>{0.75});\n        REQUIRE(testAcc1List == std::vector<double>{88.5});\n    }\n\n    SECTION(\"reads an empty file\") {\n        std::ofstream outFile(testFilePath);\n        outFile.close(); // Create an empty file\n\n        auto [trainLossList, testAcc1List] = readLog(testFilePath);\n        REQUIRE(trainLossList.empty());\n        REQUIRE(testAcc1List.empty());\n    }\n\n    SECTION(\"handles partial data entries\") {\n        std::ofstream outFile(testFilePath);\n        outFile << \"{\\\"test_acc1\\\": 88.5, \\\"train_loss\\\": 0.75}\\n\"\n                << \"{\\\"test_acc1\\\": 90.0, \\\"train_loss\\\": 0.75, \\\"f1\\\": 0.91}\"; // Missing train_loss\n        outFile.close();\n\n        auto [trainLossList, testAcc1List] = readLog(testFilePath);\n        REQUIRE(trainLossList == std::vector<double>{0.75, 0.75}); // Only one complete entry\n        REQUIRE(testAcc1List == std::vector<double>{88.5, 90.0});\n    }\n    \n    // Clean up the test file after tests\n    remove(testFilePath.c_str());\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads a log file containing JSON entries and extracts training loss and test accuracy.\n * Json entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}\n *\n * @param log_file_path The path to the log file to be read.\n * @return A pair of vectors containing two lists:\n *         - train_loss_list: A vector of training loss values extracted from the log.\n *         - test_acc1_list: A vector of test accuracy values extracted from the log.\n */\nstd::pair<std::vector<double>, std::vector<double>> read_log(const std::string& log_file_path){}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads a log file containing JSON entries and extracts training loss and test accuracy.\n * Json entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}\n *\n * @param logFilePath The path to the log file to be read.\n * @return A tuple containing two lists:\n *         - trainLossList: A list of training loss values extracted from the log.\n *         - testAcc1List: A list of test accuracy values extracted from the log.\n */\npublic static class Tuple<T1, T2> {\n    private final T1 first;\n    private final T2 second;\n\n    public Tuple(T1 first, T2 second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public T1 getFirst() {\n        return first;\n    }\n\n    public T2 getSecond() {\n        return second;\n    }\n}\npublic static Tuple<List<Double>, List<Double>> readLog(String logFilePath) throws IOException {}\n", "test_code": "import org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.Mockito;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.when;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class Tester {\n\n    @Mock\n    private BufferedReader mockReader;\n\n    @InjectMocks\n    private Answer answer;\n\n    @Before\n    public void setUp() {\n        // Setup any common mocks or initializations here\n    }\n\n    @Test\n    public void testReadCorrectData() throws IOException {\n        // Mock the BufferedReader to simulate reading correct data\n        String mockFileContent = \"{\\\"test_acc1\\\": 88.5, \\\"train_loss\\\": 0.75}\\n\" +\n                                 \"{\\\"test_acc1\\\": 89.0, \\\"train_loss\\\": 0.70}\";\n\n        String[] lines = mockFileContent.split(\"\\n\");\n        Mockito.when(mockReader.readLine()).thenAnswer(invocation -> {\n            if (lines.length > 0) {\n                String line = lines[0];\n                lines = removeFirstElement(lines); // Remove the first element\n                return line;\n            }\n            return null;\n        });\n\n        List<Double> trainLossList = new ArrayList<>();\n        List<Double> testAcc1List = new ArrayList<>();\n\n        try {\n            answer.readLog(\"dummy_path.json\", trainLossList, testAcc1List);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        assertEquals(List.of(0.75, 0.70), trainLossList);\n        assertEquals(List.of(88.5, 89.0), testAcc1List);\n    }\n\n    @Test\n    public void testReadCorrectDataSingle() throws IOException {\n        // Mock the BufferedReader to simulate reading a single correct data line\n        String mockFileContent = \"{\\\"test_acc1\\\": 88.5, \\\"train_loss\\\": 0.75}\";\n        when(mockReader.readLine()).thenReturn(mockFileContent, (String) null);\n\n        List<Double> trainLossList = new ArrayList<>();\n        List<Double> testAcc1List = new ArrayList<>();\n\n        try {\n            answer.readLog(\"dummy_path.json\", trainLossList, testAcc1List);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        assertEquals(List.of(0.75), trainLossList);\n        assertEquals(List.of(88.5), testAcc1List);\n    }\n\n    @Test\n    public void testEmptyFile() throws IOException {\n        // Mock the BufferedReader to simulate reading an empty file\n        when(mockReader.readLine()).thenReturn((String) null);\n\n        List<Double> trainLossList = new ArrayList<>();\n        List<Double> testAcc1List = new ArrayList<>();\n\n        try {\n            answer.readLog(\"empty_file.json\", trainLossList, testAcc1List);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        assertEquals(List.of(), trainLossList);\n        assertEquals(List.of(), testAcc1List);\n    }\n\n    @Test\n    public void testPartialDataEntries() throws IOException {\n        // Mock the BufferedReader to simulate reading partial data entries\n        String mockFileContent = \"{\\\"test_acc1\\\": 88.5, \\\"train_loss\\\": 0.75}\\n\" +\n                                 \"{\\\"test_acc1\\\": 90.0,\\\"train_loss\\\": 0.75,\\\"f1\\\":0.91}\";\n\n        String[] lines = mockFileContent.split(\"\\n\");\n        Mockito.when(mockReader.readLine()).thenAnswer(invocation -> {\n            if (lines.length > 0) {\n                String line = lines[0];\n                lines = removeFirstElement(lines); // Remove the first element\n                return line;\n            }\n            return null;\n        });\n\n        List<Double> trainLossList = new ArrayList<>();\n        List<Double> testAcc1List = new ArrayList<>();\n\n        try {\n            answer.readLog(\"partial_data_file.json\", trainLossList, testAcc1List);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        assertEquals(List.of(0.75, 0.75), trainLossList);\n        assertEquals(List.of(88.5, 90.0), testAcc1List);\n    }\n\n    // Helper method to remove the first element from an array\n    private String[] removeFirstElement(String[] array) {\n        if (array == null || array.length == 0) {\n            return new String[0];\n        }\n        String[] newArray = new String[array.length - 1];\n        System.arraycopy(array, 1, newArray, 0, newArray.length);\n        return newArray;\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Reads a log file containing JSON entries and extracts training loss and test accuracy.\n * Json entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}\n *\n * @param logFilePath The path to the log file to be read.\n * @return A tuple containing two lists:\n *         - trainLossList: A list of training loss values extracted from the log.\n *         - testAcc1List: A list of test accuracy values extracted from the log.\n */\npublic static class Tuple<T1, T2> {\n    private final T1 first;\n    private final T2 second;\n\n    public Tuple(T1 first, T2 second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public T1 getFirst() {\n        return first;\n    }\n\n    public T2 getSecond() {\n        return second;\n    }\n}\npublic static Tuple<List<Double>, List<Double>> readLog(String logFilePath) throws IOException {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 232, "code_type": "method", "original_language": "python", "file_path": "heavenfire\\3e3e4ddf0ae625de172dd2c37bf71d987dbe5464\\python\\remind_me.py", "question_type": "Data processing and transformation", "summary": "convert a string containing hours, minutes, and seconds to milliseconds, for example, convert the string \"1h20 min30s\" to milliseconds\n", "language_version_list": {"python": {"code_signature": "from typing import Optional\n\n\ndef convert_hms_to_milliseconds(time_str: str) -> Optional[int]:\n    \"\"\"\n    Convert a time duration string in the format 'XhYminZs' to milliseconds.\n\n    This function takes a string representing a time duration, where hours, minutes, and seconds\n    are optionally provided, and converts this duration into the equivalent number of milliseconds.\n\n    Args:\n        time_str (str): A string representing the time duration, e.g., '1h20min30s'.\n\n    Returns:\n        Optional[int]: The equivalent duration in milliseconds, or None if the input is invalid.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestConvertHmsToMilliseconds(unittest.TestCase):\n\n    def test_basic_conversion(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"1h20min30s\"), 4830000, \"Should convert 1h20min30s to 4830000 milliseconds\")\n\n    def test_no_hours_or_minutes(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"30s\"), 30000, \"Should convert 30s to 30000 milliseconds\")\n\n    def test_invalid_format(self):\n        self.assertIsNone(convert_hms_to_milliseconds(\"1hour20minutes\"), \"Should return None for invalid time format\")\n\n    def test_edge_case_max_one_day(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"23h59min59s\"), 86399000, \"Should convert 23h59min59s to 86399000 milliseconds\")\n\n    def test_exceeding_one_day(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"24h1min\"), 86460000,\n                         \"Should correctly convert 24h1min to 86460000 milliseconds\")", "prompt": "please write a python function , the function signature as below from typing import Optional\n\n\ndef convert_hms_to_milliseconds(time_str: str) -> Optional[int]:\n    \"\"\"\n    Convert a time duration string in the format 'XhYminZs' to milliseconds.\n\n    This function takes a string representing a time duration, where hours, minutes, and seconds\n    are optionally provided, and converts this duration into the equivalent number of milliseconds.\n\n    Args:\n        time_str (str): A string representing the time duration, e.g., '1h20min30s'.\n\n    Returns:\n        Optional[int]: The equivalent duration in milliseconds, or None if the input is invalid.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert a time duration string in the format 'XhYminZs' to milliseconds.\n *\n * This function takes a string representing a time duration, where hours, minutes, and seconds\n * are optionally provided, and converts this duration into the equivalent number of milliseconds.\n *\n * @param time_str A string representing the time duration, e.g., '1h20min30s'.\n * @return std::optional<int> The equivalent duration in milliseconds, or std::nullopt if the input is invalid.\n */\nstd::optional<int> convert_hms_to_milliseconds(const std::string& timeStr){}", "test_code": "TEST_CASE(\"convert_hms_to_milliseconds tests\") {\n    \n    SECTION(\"Basic conversion\") {\n        REQUIRE(convert_hms_to_milliseconds(\"1h20min30s\") == 4830000);\n    }\n\n    SECTION(\"No hours or minutes\") {\n        REQUIRE(convert_hms_to_milliseconds(\"30s\") == 30000);\n    }\n\n    SECTION(\"Invalid format\") {\n        REQUIRE(convert_hms_to_milliseconds(\"1hour20minutes\") == std::nullopt);\n    }\n\n    SECTION(\"Edge case max one day\") {\n        REQUIRE(convert_hms_to_milliseconds(\"23h59min59s\") == 86399000);\n    }\n\n    SECTION(\"Exceeding one day\") {\n        REQUIRE(convert_hms_to_milliseconds(\"24h1min\") == 86460000);\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert a time duration string in the format 'XhYminZs' to milliseconds.\n *\n * This function takes a string representing a time duration, where hours, minutes, and seconds\n * are optionally provided, and converts this duration into the equivalent number of milliseconds.\n *\n * @param time_str A string representing the time duration, e.g., '1h20min30s'.\n * @return std::optional<int> The equivalent duration in milliseconds, or std::nullopt if the input is invalid.\n */\nstd::optional<int> convert_hms_to_milliseconds(const std::string& timeStr){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a time duration string in the format 'XhYminZs' to milliseconds.\n *\n * This function takes a string representing a time duration, where hours, minutes, and seconds\n * are optionally provided, and converts this duration into the equivalent number of milliseconds.\n *\n * @param timeStr The string representing the time duration, e.g., '1h20min30s'.\n * @return The equivalent duration in milliseconds, or null if the input is invalid.\n */\npublic static Optional<Integer> convertHmsToMilliseconds(String timeStr) {\n", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testConvertHmsToMilliseconds() {\n        // Test cases for the convertHmsToMilliseconds method\n\n        // Case 1: Valid input with all parts\n        assertEquals(5070000, convertHmsToMilliseconds(\"1h20min30s\"));\n\n        // Case 2: Valid input with only hours\n        assertEquals(3600000, convertHmsToMilliseconds(\"1h\"));\n\n        // Case 3: Valid input with only minutes\n        assertEquals(1200000, convertHmsToMilliseconds(\"20min\"));\n\n        // Case 4: Valid input with only seconds\n        assertEquals(30000, convertHmsToMilliseconds(\"30s\"));\n\n        // Case 5: Invalid input with non-numeric characters\n        assertNull(convertHmsToMilliseconds(\"1h20min30m\"));\n\n        // Case 6: Invalid input with negative values\n        assertNull(convertHmsToMilliseconds(\"-1h20min30s\"));\n\n        // Case 7: Empty string\n        assertNull(convertHmsToMilliseconds(\"\"));\n\n        // Add more test cases as needed\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a time duration string in the format 'XhYminZs' to milliseconds.\n *\n * This function takes a string representing a time duration, where hours, minutes, and seconds\n * are optionally provided, and converts this duration into the equivalent number of milliseconds.\n *\n * @param timeStr The string representing the time duration, e.g., '1h20min30s'.\n * @return The equivalent duration in milliseconds, or null if the input is invalid.\n */\npublic static Optional<Integer> convertHmsToMilliseconds(String timeStr) {\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 233, "code_type": "method", "original_language": "python", "file_path": "quizly\\a340f345bc55daecbb4e5dcaa252155f2858f481\\puzzle_extractor.py", "question_type": "Data processing and transformation", "summary": "from the given string, delete the comment section that starts with the pound sign (#) and ends the line\n", "language_version_list": {"python": {"code_signature": "def remove_comments(string: str) -> str:\n    \"\"\"\n    Removes comments from the provided string. Comments start with a '#' and end at the newline.\n    For example:\n        input: Hello, world! # This is a comment\n        output:  Hello, world!\n    Args:\n        string (str): The input string containing potential comments.\n\n    Returns:\n        str: The string with all comments removed.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestRemoveComments(unittest.TestCase):\n\n    def test_single_line_comment(self):\n        \"\"\" Test string with a comment on a single line \"\"\"\n        input_string = \"Hello, world!# This is a comment\"\n        expected_output = \"Hello, world!\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n\n    def test_no_comments(self):\n        \"\"\" Test string with no comments \"\"\"\n        input_string = \"Hello, world!\\nPython is fun!\"\n        expected_output = \"Hello, world!\\nPython is fun!\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n    def test_empty_string(self):\n        \"\"\" Test an empty string \"\"\"\n        input_string = \"\"\n        expected_output = \"\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n    def test_comments_only(self):\n        \"\"\" Test string where all lines are comments \"\"\"\n        input_string = \"# comment only line\\n#another comment line\"\n        expected_output = \"\\n\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n", "prompt": "please write a python function , the function signature as below def remove_comments(string: str) -> str:\n    \"\"\"\n    Removes comments from the provided string. Comments start with a '#' and end at the newline.\n    For example:\n        input: Hello, world! # This is a comment\n        output:  Hello, world!\n    Args:\n        string (str): The input string containing potential comments.\n\n    Returns:\n        str: The string with all comments removed.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Removes comments from the provided string. Comments start with a '#' and end at the newline.\n * For example:\n *     input: Hello, world! # This is a comment\n *     output:  Hello, world!\n *\n * @param string The input string containing potential comments.\n * @return The string with all comments removed.\n */\nstd::string remove_comments(const std::string& string){}", "test_code": "TEST_CASE(\"Remove comments from a string\", \"[remove_comments]\") {\n    REQUIRE(remove_comments(\"Hello, world! # This is a comment\") == \"Hello, world!\");\n    REQUIRE(remove_comments(\"# This is a comment\\nHello, world!\") == \"\\nHello, world!\");\n    REQUIRE(remove_comments(\"No comments here!\") == \"No comments here!\");\n    REQUIRE(remove_comments(\"Multiple #comments\\n#on multiple lines\") == \"\\n\");\n    REQUIRE(remove_comments(\"Comments before newline #should stay\") == \"Comments before newline \");\n    REQUIRE(remove_comments(\"Comments after newline\\n#should be removed\") == \"Comments after newline\\n\");\n}\n\nTEST_CASE(\"Edge cases\", \"[remove_comments]\") {\n    REQUIRE(remove_comments(\"\") == \"\");\n    REQUIRE(remove_comments(\"\\n\") == \"\\n\");\n    REQUIRE(remove_comments(\"#\") == \"\");\n    REQUIRE(remove_comments(\"##\") == \"#\");\n    REQUIRE(remove_comments(\"a#b#c\") == \"ab#c\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Removes comments from the provided string. Comments start with a '#' and end at the newline.\n * For example:\n *     input: Hello, world! # This is a comment\n *     output:  Hello, world!\n *\n * @param string The input string containing potential comments.\n * @return The string with all comments removed.\n */\nstd::string remove_comments(const std::string& string){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Removes comments from the provided string. Comments start with a '#' and end at the newline.\n * \n * Example:\n *     Input: \"Hello, world! # This is a comment\"\n *     Output: \"Hello, world!\"\n * \n * @param input The input string containing potential comments.\n * @return The string with all comments removed.\n */\npublic static String removeComments(String input) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class Tester {\n    @Test\n    public void testSingleLineComment() {\n        String inputString = \"Hello, world!# This is a comment\";\n        String expectedOutput = \"Hello, world!\";\n        assertEquals(expectedOutput, removeComments(inputString));\n    }\n\n    @Test\n    public void testNoComments() {\n        String inputString = \"Hello, world!\\nPython is fun!\";\n        String expectedOutput = \"Hello, world!\\nPython is fun!\";\n        assertEquals(expectedOutput, removeComments(inputString));\n    }\n\n    @Test\n    public void testEmptyString() {\n        String inputString = \"\";\n        String expectedOutput = \"\";\n        assertEquals(expectedOutput, removeComments(inputString));\n    }\n\n    @Test\n    public void testCommentsOnly() {\n        String inputString = \"# comment only line\\n#another comment line\";\n        String expectedOutput = \"\\n\"; // Result should include a newline since lines are comments only\n        assertEquals(expectedOutput, removeComments(inputString));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Removes comments from the provided string. Comments start with a '#' and end at the newline.\n * \n * Example:\n *     Input: \"Hello, world! # This is a comment\"\n *     Output: \"Hello, world!\"\n * \n * @param input The input string containing potential comments.\n * @return The string with all comments removed.\n */\npublic static String removeComments(String input) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 234, "code_type": "method", "original_language": "python", "file_path": "ngrok-stable-linux-arm\\c2986b7785ebdb030904e4e3af1ff6691c0b0fb4\\compareADIF.py", "question_type": "Data processing and transformation", "summary": "Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.", "language_version_list": {"python": {"code_signature": "def append_or_skip_row(file_handler, reader, row_candidate):\n    \"\"\"\n    Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n\n    Args:\n        file_handler: File handler of the CSV file opened in read-plus mode ('r+').\n        reader: CSV reader object for reading existing rows.\n        row_candidate: List containing the new row to be appended.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import csv\nimport io\nimport unittest\n\n\nclass TestAppendOrSkipRow(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up a mock CSV file using StringIO.\"\"\"\n        self.mock_file = io.StringIO()\n        self.mock_file.write(\"Alice,30,USA\\nBob,25,UK\\nCharlie,35,Canada\\n\")\n        self.mock_file.seek(0)  # Reset pointer to the start of the mock file\n        self.reader = csv.reader(self.mock_file)\n\n    def test_append_new_row(self):\n        \"\"\"Test appending a new row when there are no matching values.\"\"\"\n        new_row = ['David', '28', 'Australia']\n        append_or_skip_row(self.mock_file, self.reader, new_row)\n\n        self.mock_file.seek(0)  # Reset pointer to read from the start\n        result = list(csv.reader(self.mock_file))\n        self.assertIn(new_row, result)\n\n    def test_skip_different_values(self):\n        \"\"\"Test appending a new row with different values.\"\"\"\n        new_row = ['Alice', '31', 'USA']  # Same name, different age\n        append_or_skip_row(self.mock_file, self.reader, new_row)\n\n        self.mock_file.seek(0)  # Reset pointer to read from the start\n        result = list(csv.reader(self.mock_file))\n        self.assertIn(new_row, result)\n\n    def test_append_row_with_different_columns(self):\n        \"\"\"Test appending a row with different values in the first three columns.\"\"\"\n        new_row = ['Eve', '40', 'Australia', 'Engineer']\n        append_or_skip_row(self.mock_file, self.reader, new_row)\n\n        self.mock_file.seek(0)  # Reset pointer to read from the start\n        result = list(csv.reader(self.mock_file))\n        self.assertIn(new_row, result)\n\n    def test_multiple_appends(self):\n        \"\"\"Test appending multiple new rows correctly.\"\"\"\n        new_rows = [\n            ['Frank', '29', 'Germany'],\n            ['Grace', '22', 'France']\n        ]\n\n        for row in new_rows:\n            append_or_skip_row(self.mock_file, self.reader, row)\n            self.mock_file.seek(0)  # Reset pointer for the next read\n            self.reader = csv.reader(self.mock_file)  # Recreate the reader after each append\n\n        self.mock_file.seek(0)  # Reset pointer to read from the start\n        result = list(csv.reader(self.mock_file))\n        for row in new_rows:\n            self.assertIn(row, result)", "prompt": "please write a python function , the function signature as below def append_or_skip_row(file_handler, reader, row_candidate):\n    \"\"\"\n    Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n\n    Args:\n        file_handler: File handler of the CSV file opened in read-plus mode ('r+').\n        reader: CSV reader object for reading existing rows.\n        row_candidate: List containing the new row to be appended.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n *\n * @param fileHandler File stream of the CSV file opened in read-plus mode ('r+').\n * @param reader CSV reader object for reading existing rows.\n * @param rowCandidate Vector containing the new row to be appended.\n */\nvoid appendOrSkipRow(std::fstream& fileHandler, std::istream& reader, const std::vector<std::string>& rowCandidate){\n\n}", "test_code": "TEST_CASE(\"append_or_skip_row\", \"[csv]\") {\n    // Create a temporary CSV file with some initial data\n    std::ofstream tempFile(\"temp.csv\");\n    tempFile << \"col1,col2,col3,col4\\n\";\n    tempFile << \"value1,value2,value3,value4\\n\";\n    tempFile.close();\n\n    // Open the file in read-plus mode\n    std::fstream fileHandler(\"temp.csv\", std::ios::in | std::ios::out);\n    REQUIRE(fileHandler.is_open());\n\n    // Read the existing rows into a vector\n    std::vector<std::string> rows;\n    std::string line;\n    while (std::getline(reader, line)) {\n        rows.push_back(line);\n    }\n\n    // Define the candidate row to append\n    std::vector<std::string> rowCandidate = {\"value5\", \"value6\", \"value7\", \"value8\"};\n\n    // Call the function under test\n    append_or_skip_row(fileHandler, reader, rowCandidate);\n\n    // Seek back to the beginning of the file to read the updated content\n    fileHandler.seekg(0, std::ios::beg);\n    std::stringstream ss;\n    ss << fileHandler.rdbuf();\n    std::string updatedContent = ss.str();\n\n    // Check that the candidate row was appended\n    REQUIRE(updatedContent.find(\"value5,value6,value7,value8\") != std::string::npos);\n\n    // Clean up\n    fileHandler.close();\n    std::remove(\"temp.csv\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n *\n * @param fileHandler File stream of the CSV file opened in read-plus mode ('r+').\n * @param reader CSV reader object for reading existing rows.\n * @param rowCandidate Vector containing the new row to be appended.\n */\nvoid appendOrSkipRow(std::fstream& fileHandler, std::istream& reader, const std::vector<std::string>& rowCandidate){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n *\n * @param fileHandler The file handler of the CSV file opened in read-plus mode ('r+').\n * @param reader The CSV reader object for reading existing rows.\n * @param rowCandidate The list containing the new row to be appended.\n */\npublic static void appendOrSkipRow(PrintWriter fileHandler, List<String> reader, List<String> rowCandidate) {}", "test_code": "package org.real.temp;\n\nimport org.apache.commons.csv.CSVFormat;\nimport org.apache.commons.csv.CSVParser;\nimport org.apache.commons.csv.CSVRecord;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class Tester {\n\n    private StringWriter mockFile;\n    private List<String[]> records;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        // Set up a mock CSV file using StringWriter\n        mockFile = new StringWriter();\n        mockFile.write(\"Alice,30,USA\\nBob,25,UK\\nCharlie,35,Canada\\n\");\n        records = new ArrayList<>();\n        loadRecords();\n    }\n\n    private void loadRecords() throws IOException {\n        // Load records from the mock file\n        CSVParser parser = new CSVParser(new StringReader(mockFile.toString()), CSVFormat.DEFAULT);\n        for (CSVRecord record : parser) {\n            String[] row = new String[record.size()];\n            for (int i = 0; i < record.size(); i++) {\n                row[i] = record.get(i);\n            }\n            records.add(row);\n        }\n    }\n\n    private void appendOrSkipRow(String[] newRow) throws IOException {\n        boolean exists = false;\n        for (String[] row : records) {\n            // Check if the name matches (assuming first column is the name)\n            if (row[0].equals(newRow[0])) {\n                exists = true;\n                break;\n            }\n        }\n        // Append row only if it doesn't exist\n        if (!exists) {\n            records.add(newRow);\n        }\n        saveRecords();\n    }\n\n    private void saveRecords() {\n        mockFile.getBuffer().setLength(0); // Clear the StringWriter\n        for (String[] row : records) {\n            mockFile.write(String.join(\",\", row) + \"\\n\");\n        }\n    }\n\n    @Test\n    public void testAppendNewRow() throws IOException {\n        // Test appending a new row when there are no matching values\n        String[] newRow = {\"David\", \"28\", \"Australia\"};\n        appendOrSkipRow(newRow);\n        loadRecords(); // Reload records after appending\n\n        boolean found = false;\n        for (String[] row : records) {\n            if (row[0].equals(newRow[0])) {\n                found = true;\n                break;\n            }\n        }\n        assertTrue(found);\n    }\n\n    @Test\n    public void testSkipDifferentValues() throws IOException {\n        // Test appending a new row with different values\n        String[] newRow = {\"Alice\", \"31\", \"USA\"}; // Same name, different age\n        appendOrSkipRow(newRow);\n        loadRecords(); // Reload records after appending\n\n        boolean found = false;\n        for (String[] row : records) {\n            if (row[0].equals(newRow[0]) && !row[1].equals(newRow[1])) {\n                found = true;\n                break;\n            }\n        }\n        assertTrue(found);\n    }\n\n    @Test\n    public void testAppendRowWithDifferentColumns() throws IOException {\n        // Test appending a row with different values in the first three columns\n        String[] newRow = {\"Eve\", \"40\", \"Australia\", \"Engineer\"};\n        appendOrSkipRow(newRow);\n        loadRecords(); // Reload records after appending\n\n        boolean found = false;\n        for (String[] row : records) {\n            if (row[0].equals(newRow[0])) {\n                found = true;\n                break;\n            }\n        }\n        assertTrue(found);\n    }\n\n    @Test\n    public void testMultipleAppends() throws IOException {\n        // Test appending multiple new rows correctly\n        String[][] newRows = {\n            {\"Frank\", \"29\", \"Germany\"},\n            {\"Grace\", \"22\", \"France\"}\n        };\n\n        for (String[] row : newRows) {\n            appendOrSkipRow(row);\n            loadRecords(); // Reload records after each append\n        }\n\n        for (String[] row : newRows) {\n            boolean found = false;\n            for (String[] existingRow : records) {\n                if (existingRow[0].equals(row[0])) {\n                    found = true;\n                    break;\n                }\n            }\n            assertTrue(found);\n        }\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n *\n * @param fileHandler The file handler of the CSV file opened in read-plus mode ('r+').\n * @param reader The CSV reader object for reading existing rows.\n * @param rowCandidate The list containing the new row to be appended.\n */\npublic static void appendOrSkipRow(PrintWriter fileHandler, List<String> reader, List<String> rowCandidate) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 235, "code_type": "method", "original_language": "python", "file_path": "trdosl\\5ed74bb15f726589cddeb39e950774bf74c4875f\\_scripts\\calculate_bearing.py", "question_type": "Algorithm and data structure", "summary": "calculate the azimuth between two points on the earth. This function accepts the latitude and longitude of the two points as a parameter and returns the azimuth from the first point to the second point in degrees\n", "language_version_list": {"python": {"code_signature": "def calculate_bearing(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the azimuth between two points on the earth. This function accepts the latitude and longitude of the two points as a parameter and returns the azimuth from the first point to the second point in degrees\n    Args:\n        lat1 (float): Latitude of the starting point in decimal degrees.\n        lon1 (float): Longitude of the starting point in decimal degrees.\n        lat2 (float): Latitude of the ending point in decimal degrees.\n        lon2 (float): Longitude of the ending point in decimal degrees.\n\n    Returns:\n        float: Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestCalculateBearing(unittest.TestCase):\n    def test_north_bearing(self):\n        # From equator directly north\n        self.assertAlmostEqual(calculate_bearing(0, 0, 10, 0), 0)\n\n    def test_east_bearing(self):\n        # From prime meridian directly east\n        self.assertAlmostEqual(calculate_bearing(0, 0, 0, 10), 90)\n\n    def test_south_bearing(self):\n        # From a point directly south\n        self.assertAlmostEqual(calculate_bearing(10, 0, 0, 0), 180)\n\n    def test_west_bearing(self):\n        # From a point directly west\n        self.assertAlmostEqual(calculate_bearing(0, 10, 0, 0), 270)\n\n    def test_across_prime_meridian(self):\n        # From a point west of the prime meridian to a point east\n        self.assertAlmostEqual(calculate_bearing(0, -1, 0, 1), 90)", "prompt": "please write a python function , the function signature as below def calculate_bearing(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the azimuth between two points on the earth. This function accepts the latitude and longitude of the two points as a parameter and returns the azimuth from the first point to the second point in degrees\n    Args:\n        lat1 (float): Latitude of the starting point in decimal degrees.\n        lon1 (float): Longitude of the starting point in decimal degrees.\n        lat2 (float): Latitude of the ending point in decimal degrees.\n        lon2 (float): Longitude of the ending point in decimal degrees.\n\n    Returns:\n        float: Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculates the azimuth between two points on the Earth.\n *\n * @param lat1 The latitude of the starting point in decimal degrees.\n * @param lon1 The longitude of the starting point in decimal degrees.\n * @param lat2 The latitude of the ending point in decimal degrees.\n * @param lon2 The longitude of the ending point in decimal degrees.\n *\n * @return The bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n */\ndouble calculate_bearing(double lat1, double lon1, double lat2, double lon2);\n", "test_code": "// Helper function to compare floating point values with a tolerance\nbool approximately_equal(double a, double b, double epsilon = 1e-9) {\n    return std::abs(a - b) < epsilon;\n}\n\nTEST_CASE(\"Calculate Bearing Tests\", \"[calculate_bearing]\") {\n    SECTION(\"North Bearing\") {\n        // From equator directly north\n        REQUIRE(approximately_equal(calculate_bearing(0, 0, 10, 0), 0));\n    }\n\n    SECTION(\"East Bearing\") {\n        // From prime meridian directly east\n        REQUIRE(approximately_equal(calculate_bearing(0, 0, 0, 10), 90));\n    }\n\n    SECTION(\"South Bearing\") {\n        // From a point directly south\n        REQUIRE(approximately_equal(calculate_bearing(10, 0, 0, 0), 180));\n    }\n\n    SECTION(\"West Bearing\") {\n        // From a point directly west\n        REQUIRE(approximately_equal(calculate_bearing(0, 10, 0, 0), 270));\n    }\n\n    SECTION(\"Across Prime Meridian\") {\n        // From a point west of the prime meridian to a point east\n        REQUIRE(approximately_equal(calculate_bearing(0, -1, 0, 1), 90));\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculates the azimuth between two points on the Earth.\n *\n * @param lat1 The latitude of the starting point in decimal degrees.\n * @param lon1 The longitude of the starting point in decimal degrees.\n * @param lat2 The latitude of the ending point in decimal degrees.\n * @param lon2 The longitude of the ending point in decimal degrees.\n *\n * @return The bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n */\ndouble calculate_bearing(double lat1, double lon1, double lat2, double lon2);\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the bearing from one latitude and longitude to another.\n * \n * This function accepts the latitude and longitude of the two points as parameters and returns the bearing from the first point to the second point in degrees.\n * \n * @param lat1 Latitude of the starting point in decimal degrees.\n * @param lon1 Longitude of the starting point in decimal degrees.\n * @param lat2 Latitude of the ending point in decimal degrees.\n * @param lon2 Longitude of the ending point in decimal degrees.\n * @return Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n */\npublic static double calculateBearing(double lat1, double lon1, double lat2, double lon2) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    // Helper method for comparing floating-point numbers with a tolerance\n    private boolean approximatelyEqual(double a, double b, double epsilon) {\n        return Math.abs(a - b) < epsilon;\n    }\n\n    @Test\n    public void testNorthBearing() {\n        // From equator directly north\n        assertEquals(0, calculateBearing(0, 0, 10, 0), 1e-9);\n    }\n\n    @Test\n    public void testEastBearing() {\n        // From prime meridian directly east\n        assertEquals(90, calculateBearing(0, 0, 0, 10), 1e-9);\n    }\n\n    @Test\n    public void testSouthBearing() {\n        // From a point directly south\n        assertEquals(180, calculateBearing(10, 0, 0, 0), 1e-9);\n    }\n\n    @Test\n    public void testWestBearing() {\n        // From a point directly west\n        assertEquals(270, calculateBearing(0, 10, 0, 0), 1e-9);\n    }\n\n    @Test\n    public void testAcrossPrimeMeridian() {\n        // From a point west of the prime meridian to a point east\n        assertEquals(90, calculateBearing(0, -1, 0, 1), 1e-9);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Calculates the bearing from one latitude and longitude to another.\n * \n * This function accepts the latitude and longitude of the two points as parameters and returns the bearing from the first point to the second point in degrees.\n * \n * @param lat1 Latitude of the starting point in decimal degrees.\n * @param lon1 Longitude of the starting point in decimal degrees.\n * @param lat2 Latitude of the ending point in decimal degrees.\n * @param lon2 Longitude of the ending point in decimal degrees.\n * @return Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n */\npublic static double calculateBearing(double lat1, double lon1, double lat2, double lon2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 240, "code_type": "method", "original_language": "python", "file_path": "heavenfire\\da7903f58b6c05a96a9c210d4900dc92f78e9100\\python\\luna_discord_bot.py", "question_type": "Data processing and transformation", "summary": "    Converts a time duration string into a timedelta object.\n    The input string can include days (d), hours (h), minutes (m), seconds (s), and milliseconds (ms).\n    Each unit should be specified by an integer followed by its corresponding unit letter.", "language_version_list": {"python": {"code_signature": "from datetime import timedelta\nimport re\n\n\ndef gen_timeout_timedelta(time_string: str) -> timedelta:\n    \"\"\"\n    Converts a time duration string into a timedelta object.\n    The input string can include days (d), hours (h), minutes (m), seconds (s), and milliseconds (ms).\n    eg. \"1d 2h 3m 4s 500ms\"\n    Each unit should be specified by an integer followed by its corresponding unit letter.\n\n    Args:\n        time_string (str): A string representing the time duration.\n\n    Returns:\n        timedelta: A timedelta object representing the input duration.\n    \"\"\"", "test_code": "import unittest\nfrom datetime import timedelta\n\n\nclass TestGenTimeoutTimedelta(unittest.TestCase):\n    def test_single_unit_days(self):\n        self.assertEqual(gen_timeout_timedelta(\"5d\"), timedelta(days=5))\n\n\n    def test_single_unit_hours(self):\n        self.assertEqual(gen_timeout_timedelta(\"8h\"), timedelta(hours=8))\n\n    def test_single_unit_minutes(self):\n        self.assertEqual(gen_timeout_timedelta(\"45m\"), timedelta(minutes=45))\n\n    def test_single_unit_seconds(self):\n        self.assertEqual(gen_timeout_timedelta(\"30s\"), timedelta(seconds=30))\n\n    def test_complex_mix(self):\n        self.assertEqual(gen_timeout_timedelta(\"2d 20h 30m\"), timedelta(days=2, hours=20, minutes=30))\n\n    def test_no_units(self):\n        self.assertEqual(gen_timeout_timedelta(\"\"), timedelta(0))", "prompt": "please write a python function , the function signature as below from datetime import timedelta\nimport re\n\n\ndef gen_timeout_timedelta(time_string: str) -> timedelta:\n    \"\"\"\n    Converts a time duration string into a timedelta object.\n    The input string can include days (d), hours (h), minutes (m), seconds (s), and milliseconds (ms).\n    eg. \"1d 2h 3m 4s 500ms\"\n    Each unit should be specified by an integer followed by its corresponding unit letter.\n\n    Args:\n        time_string (str): A string representing the time duration.\n\n    Returns:\n        timedelta: A timedelta object representing the input duration.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 241, "code_type": "method", "original_language": "python", "file_path": "Daybyday\\f522008ddf9af17287b47845f5753ccbf5c30a5d\\16.06\\Python\\worms\\worms-chatgpt.py", "question_type": "Algorithm and data structure", "summary": "finds the minimum distance between two words in a text file, considering each line as a separate sequence \uff0creturns the line number and shortest distance at which the distance occurs\n", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef get_min_seq_num_and_distance(file_path: str, word1: str, word2: str) -> Tuple[int, int]:\n    \"\"\"\n    Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n    Args:\n        file_path (str): The path to the file to read.\n        word1 (str): The first word to search for.\n        word2 (str): The second word to search for.\n\n    Returns:\n        tuple: A tuple containing the line number with the minimum distance and the minimum distance itself.\n          Returns (None, float('inf')) if one or both words are not found in any line.\n    \"\"\"\n", "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestGetMinDistance(unittest.TestCase):\n\n    def test_basic_functionality(self):\n        \"\"\" Test basic functionality with expected input \"\"\"\n        mock_content = \"hello world\\napple banana apple\\norange apple banana\"\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (2, 1))\n\n\n    def test_words_not_present(self):\n        \"\"\" Test case where one or both words are not present \"\"\"\n        mock_content = \"apple orange pear\\norange pear apple\"\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (None, float('inf')))\n\n    def test_empty_file(self):\n        \"\"\" Test an empty file \"\"\"\n        with patch('builtins.open', mock_open(read_data='')):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (None, float('inf')))\n\n    def test_multiple_lines_with_varying_distances(self):\n        \"\"\" Test multiple lines with varying distances between words \"\"\"\n        mock_content = \"apple banana\\napple orange orange banana\\napple orange orange orange banana\"\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (1, 1))", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef get_min_seq_num_and_distance(file_path: str, word1: str, word2: str) -> Tuple[int, int]:\n    \"\"\"\n    Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n    Args:\n        file_path (str): The path to the file to read.\n        word1 (str): The first word to search for.\n        word2 (str): The second word to search for.\n\n    Returns:\n        tuple: A tuple containing the line number with the minimum distance and the minimum distance itself.\n          Returns (None, float('inf')) if one or both words are not found in any line.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n *\n * @param file_path The path to the file to read.\n * @param word1 The first word to search for.\n * @param word2 The second word to search for.\n *\n * @return A tuple containing the line number with the minimum distance and the minimum distance itself.\n *         Returns (std::nullopt, std::numeric_limits<int>::max()) if one or both words are not found in any line.\n */\nstd::tuple<std::optional<int>, int> get_min_seq_num_and_distance(const std::string& file_path, const std::string& word1, const std::string& word2){\n\n}", "test_code": "TEST_CASE_METHOD(TestGetMinDistance, \"Test basic functionality with expected input\") {\n    content = \"hello world\\napple banana apple\\norange apple banana\";\n    setup_temp_file();\n\n    auto [line_number, distance] = get_min_seq_num_and_distance(temp_file_path, \"apple\", \"banana\");\n    REQUIRE((line_number, distance) == std::make_pair(2, 1));\n\n    teardown_temp_file();\n}\n\nTEST_CASE_METHOD(TestGetMinDistance, \"Test case where one or both words are not present\") {\n    content = \"apple orange pear\\norange pear apple\";\n    setup_temp_file();\n\n    auto [line_number, distance] = get_min_seq_num_and_distance(temp_file_path, \"apple\", \"banana\");\n    REQUIRE((line_number, distance) == std::make_pair(-1, std::numeric_limits<int>::max()));\n\n    teardown_temp_file();\n}\n\nTEST_CASE_METHOD(TestGetMinDistance, \"Test an empty file\") {\n    content = \"\";\n    setup_temp_file();\n\n    auto [line_number, distance] = get_min_seq_num_and_distance(temp_file_path, \"apple\", \"banana\");\n    REQUIRE((line_number, distance) == std::make_pair(-1, std::numeric_limits<int>::max()));\n\n    teardown_temp_file();\n}\n\nTEST_CASE_METHOD(TestGetMinDistance, \"Test multiple lines with varying distances between words\") {\n    content = \"apple banana\\napple orange orange banana\\napple orange orange orange banana\";\n    setup_temp_file();\n\n    auto [line_number, distance] = get_min_seq_num_and_distance(temp_file_path, \"apple\", \"banana\");\n    REQUIRE((line_number, distance) == std::make_pair(1, 1));\n\n    teardown_temp_file();\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n *\n * @param file_path The path to the file to read.\n * @param word1 The first word to search for.\n * @param word2 The second word to search for.\n *\n * @return A tuple containing the line number with the minimum distance and the minimum distance itself.\n *         Returns (std::nullopt, std::numeric_limits<int>::max()) if one or both words are not found in any line.\n */\nstd::tuple<std::optional<int>, int> get_min_seq_num_and_distance(const std::string& file_path, const std::string& word1, const std::string& word2){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n *\n * @param filePath The path to the file to read.\n * @param word1    The first word to search for.\n * @param word2    The second word to search for.\n * @return A tuple containing the line number with the minimum distance and the minimum distance itself.\n *         Returns (null, Integer.MAX_VALUE) if one or both words are not found in any line.\n */\npublic static Tuple getMinSeqNumAndDistance(String filePath, String word1, String word2) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    private TextFileProcessor processor;\n\n    @BeforeEach\n    public void setUp() {\n        processor = new TextFileProcessor();\n    }\n\n    @Test\n    public void testGetMinSeqNumAndDistance() {\n        String filePath = \"path/to/your/file.txt\";\n        String word1 = \"word1\";\n        String word2 = \"word2\";\n\n        // Assuming the method returns a Pair<Integer, Integer>\n        Pair<Integer, Integer> result = processor.getMinSeqNumAndDistance(filePath, word1, word2);\n\n        assertNotNull(result);\n        assertTrue(result.getFirst() != null && result.getSecond() != null);\n        System.out.println(\"Line Number: \" + result.getFirst());\n        System.out.println(\"Minimum Distance: \" + result.getSecond());\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n *\n * @param filePath The path to the file to read.\n * @param word1    The first word to search for.\n * @param word2    The second word to search for.\n * @return A tuple containing the line number with the minimum distance and the minimum distance itself.\n *         Returns (null, Integer.MAX_VALUE) if one or both words are not found in any line.\n */\npublic static Tuple getMinSeqNumAndDistance(String filePath, String word1, String word2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 242, "code_type": "method", "original_language": "python", "file_path": "python-3-fundamentals\\1d2e3e04a3ef7b83e4e1a673c78f56a0d51c8bf8\\organize.py", "question_type": "File operations and I/O operation", "summary": "Classify an array of file names according to its file extension, and return the final class result in the form of a dictionary\n", "language_version_list": {"python": {"code_signature": "from typing import List, Dict\n\n\ndef classify_files_by_extension(file_names: List[str]) -> Dict:\n    \"\"\"\n    Classify an array of file names according to their file extensions.\n\n    Args:\n        file_names: List of file names (strings).\n\n    Returns:\n        Dict: Dictionary with file extensions as keys and lists of file names as values.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestClassifyFilesByExtension(unittest.TestCase):\n\n    def test_multiple_file_types(self):\n        \"\"\"Test with multiple file types.\"\"\"\n        files = [\n            \"document.docx\",\n            \"photo.jpeg\",\n            \"report.pdf\",\n            \"image.png\",\n            \"archive.zip\"\n        ]\n        expected_result = {\n            'docx': ['document.docx'],\n            'jpeg': ['photo.jpeg'],\n            'pdf': ['report.pdf'],\n            'png': ['image.png'],\n            'zip': ['archive.zip']\n        }\n        self.assertEqual(classify_files_by_extension(files), expected_result)\n\n    def test_empty_list(self):\n        \"\"\"Test with an empty list of file names.\"\"\"\n        files = []\n        expected_result = {}\n        self.assertEqual(classify_files_by_extension(files), expected_result)\n\n    def test_files_with_same_extension(self):\n        \"\"\"Test with multiple files having the same extension.\"\"\"\n        files = [\n            \"file1.txt\",\n            \"file2.txt\",\n            \"file3.txt\",\n        ]\n        expected_result = {\n            'txt': [\n                \"file1.txt\",\n                \"file2.txt\",\n                \"file3.txt\",\n            ]\n        }\n        self.assertEqual(classify_files_by_extension(files), expected_result)\n\n    def test_files_with_multiple_dots(self):\n        \"\"\"Test files that have multiple dots in their names.\"\"\"\n        files = [\n            \"my.document.docx\",\n            \"report.final.pdf\",\n            \"photo.album.jpeg\",\n            \"archive.backup.zip\"\n        ]\n        expected_result = {\n            'docx': ['my.document.docx'],\n            'pdf': ['report.final.pdf'],\n            'jpeg': ['photo.album.jpeg'],\n            'zip': ['archive.backup.zip']\n        }\n        self.assertEqual(classify_files_by_extension(files), expected_result)", "prompt": "please write a python function , the function signature as below from typing import List, Dict\n\n\ndef classify_files_by_extension(file_names: List[str]) -> Dict:\n    \"\"\"\n    Classify an array of file names according to their file extensions.\n\n    Args:\n        file_names: List of file names (strings).\n\n    Returns:\n        Dict: Dictionary with file extensions as keys and lists of file names as values.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Classify an array of file names according to their file extensions.\n *\n * @param fileNames A vector of strings representing file names.\n * @return An unordered_map where keys are file extensions and values are vectors of file names.\n */\nstd::unordered_map<std::string, std::vector<std::string>> classify_files_by_extension(const std::vector<std::string>& fileNames){\n\n}", "test_code": "TEST_CASE(\"Test classifyFilesByExtension\") {\n    SECTION(\"Test with multiple file types\") {\n        std::vector<std::string> files = {\n            \"document.docx\",\n            \"photo.jpeg\",\n            \"report.pdf\",\n            \"image.png\",\n            \"archive.zip\"\n        };\n        std::unordered_map<std::string, std::vector<std::string>> expected_result = {\n            {\"docx\", {\"document.docx\"}},\n            {\"jpeg\", {\"photo.jpeg\"}},\n            {\"pdf\", {\"report.pdf\"}},\n            {\"png\", {\"image.png\"}},\n            {\"zip\", {\"archive.zip\"}}\n        };\n\n        REQUIRE(classify_files_by_extension(files) == expected_result);\n    }\n\n    SECTION(\"Test with an empty list of file names\") {\n        std::vector<std::string> files = {};\n        std::unordered_map<std::string, std::vector<std::string>> expected_result = {};\n\n        REQUIRE(classify_files_by_extension(files) == expected_result);\n    }\n\n    SECTION(\"Test with multiple files having the same extension\") {\n        std::vector<std::string> files = {\n            \"file1.txt\",\n            \"file2.txt\",\n            \"file3.txt\"\n        };\n        std::unordered_map<std::string, std::vector<std::string>> expected_result = {\n            {\"txt\", {\"file1.txt\", \"file2.txt\", \"file3.txt\"}}\n        };\n\n        REQUIRE(classify_files_by_extension(files) == expected_result);\n    }\n\n    SECTION(\"Test files that have multiple dots in their names\") {\n        std::vector<std::string> files = {\n            \"my.document.docx\",\n            \"report.final.pdf\",\n            \"photo.album.jpeg\",\n            \"archive.backup.zip\"\n        };\n        std::unordered_map<std::string, std::vector<std::string>> expected_result = {\n            {\"docx\", {\"my.document.docx\"}},\n            {\"pdf\", {\"report.final.pdf\"}},\n            {\"jpeg\", {\"photo.album.jpeg\"}},\n            {\"zip\", {\"archive.backup.zip\"}}\n        };\n\n        REQUIRE(classify_files_by_extension(files) == expected_result);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Classify an array of file names according to their file extensions.\n *\n * @param fileNames A vector of strings representing file names.\n * @return An unordered_map where keys are file extensions and values are vectors of file names.\n */\nstd::unordered_map<std::string, std::vector<std::string>> classify_files_by_extension(const std::vector<std::string>& fileNames){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Classify an array of file names according to their file extensions.\n *\n * @param fileNames List of file names (strings).\n * @return A map with file extensions as keys and lists of file names as values.\n */\npublic static Map<String, List<String>> classifyFilesByExtension(String[] fileNames) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testClassifyFilesByExtension() {\n        List<String> fileNames = Arrays.asList(\"file1.txt\", \"file2.jpg\", \"file3.txt\", \"image.png\");\n        Map<String, List<String>> expectedOutput = new HashMap<>();\n        expectedOutput.put(\"txt\", Arrays.asList(\"file1.txt\", \"file3.txt\"));\n        expectedOutput.put(\"jpg\", Arrays.asList(\"file2.jpg\"));\n        expectedOutput.put(\"png\", Arrays.asList(\"image.png\"));\n\n        Map<String, List<String>> actualOutput = FileClassifier.classifyFilesByExtension(fileNames);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Classify an array of file names according to their file extensions.\n *\n * @param fileNames List of file names (strings).\n * @return A map with file extensions as keys and lists of file names as values.\n */\npublic static Map<String, List<String>> classifyFilesByExtension(String[] fileNames) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 244, "code_type": "method", "original_language": "python", "file_path": "ad_modelling_fyp\\d65e93d4dc1f99465e5aa8bfa3115cc79725e56a\\whole_brain_models\\whobpyt\\functions\\arg_type_check.py", "question_type": "Data processing and transformation", "summary": "Write a function to check whether the parameters passed to a given method object (for example, a class of methods) comply with their\nExpected data type, based on method signature, if there is a difference, a ValueError will be raised", "language_version_list": {"python": {"code_signature": "from typing import Callable\n\n\nimport inspect\n\n\ndef method_arg_type_check(method_obj, *args, **kwargs):\n    \"\"\"\n    Checks that the arguments passed to a given method object (e.g., method of a class) comply with their\n    expected question types, based on the method's signature.js.py.py.py.py.js.js.js. If there's a discrepancy, it raises a ValueError.\n\n    Args:\n        method_obj (Callable): The method for which arguments are checked.\n        *args (): Positional arguments passed to the method.\n        **kwargs (): Keyword arguments passed to the method.\n\n\n    Optional argument:\n        exclude (list of str): Names of parameters to exclude from the type check.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\nfrom typing import Callable\n\n\nclass MyClass:\n    def my_method(self, arg1: int, arg2: str, optional_arg: float = 3.14):\n        pass\n\n\nclass TestMethodArgTypeCheck(unittest.TestCase):\n    def test_correct_types(self):\n        \"\"\" Test with correct argument types. \"\"\"\n        try:\n            method_arg_type_check(MyClass.my_method, MyClass(), 10, \"hello\", optional_arg=3.14)\n        except ValueError:\n            self.fail(\"method_arg_type_check() raised ValueError unexpectedly!\")\n\n    def test_missing_argument(self):\n        \"\"\" Test with missing required argument. \"\"\"\n        with self.assertRaises(TypeError):\n            method_arg_type_check(MyClass.my_method, MyClass(), 10)  # Missing arg2\n", "prompt": "please write a python function , the function signature as below from typing import Callable\n\n\nimport inspect\n\n\ndef method_arg_type_check(method_obj, *args, **kwargs):\n    \"\"\"\n    Checks that the arguments passed to a given method object (e.g., method of a class) comply with their\n    expected question types, based on the method's signature.js.py.py.py.py.js.js.js. If there's a discrepancy, it raises a ValueError.\n\n    Args:\n        method_obj (Callable): The method for which arguments are checked.\n        *args (): Positional arguments passed to the method.\n        **kwargs (): Keyword arguments passed to the method.\n\n\n    Optional argument:\n        exclude (list of str): Names of parameters to exclude from the type check.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks that the arguments passed to a given method object (e.g., method of a class)\n * comply with their expected argument types, based on the method's signature. If there's a discrepancy,\n * it throws an IllegalArgumentException.\n *\n * @param methodObj The method for which arguments are checked.\n * @param args      Positional arguments passed to the method.\n * @param kwargs    Keyword arguments passed to the method.\n *\n * @throws IllegalArgumentException if any of the arguments do not match their expected types.\n */\npublic static void methodArgTypeCheck(Method methodObj, Object[] args, Object[] kwargs) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @BeforeEach\n    public void setUp() {\n        // Setup code here if needed\n    }\n\n    @Test\n    public void testMethodArgTypeCheck() throws Exception {\n        // Create an instance of the class where method_arg_type_check is defined\n        Class<?> clazz = Class.forName(\"YourClassName\");\n        Object obj = clazz.getDeclaredConstructor().newInstance();\n\n        // Get the method you want to test\n        Method method = clazz.getDeclaredMethod(\"method_arg_type_check\", Callable.class, Object[].class, Map.class);\n\n        // Test with correct arguments\n        try {\n            method.invoke(obj, someCallable, new Object[]{}, Collections.emptyMap());\n        } catch (Exception e) {\n            fail(\"Expected no exception but got: \" + e);\n        }\n\n        // Test with incorrect arguments\n        assertThrows(ValueError.class, () -> {\n            method.invoke(obj, someCallable, new Object[]{incorrectArgument}, Collections.emptyMap());\n        });\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks that the arguments passed to a given method object (e.g., method of a class)\n * comply with their expected argument types, based on the method's signature. If there's a discrepancy,\n * it throws an IllegalArgumentException.\n *\n * @param methodObj The method for which arguments are checked.\n * @param args      Positional arguments passed to the method.\n * @param kwargs    Keyword arguments passed to the method.\n *\n * @throws IllegalArgumentException if any of the arguments do not match their expected types.\n */\npublic static void methodArgTypeCheck(Method methodObj, Object[] args, Object[] kwargs) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 248, "code_type": "method", "original_language": "python", "file_path": "website-2024\\252065dd22d32491fb30866fac26c7125f433d3c\\static\\python-scripts\\sanitize_hotcrp_json.py", "question_type": "Data processing and transformation", "summary": "remove the corresponding sensitive data in the given dictionary based on the given key_to_remove list\n", "language_version_list": {"python": {"code_signature": "from typing import Dict, List\n\n\ndef sanitize_data(data: Dict, key_to_remove: List = None) -> Dict:\n    \"\"\"\n    remove the corresponding sensitive question in the given dictionary based on the given key_to_remove list\n\n    Args:\n        data (Dict): original question dict\n        key_to_remove (List): key_to_remove list\n\n    Returns:\n        Dict: removed dict\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSanitizeData(unittest.TestCase):\n    def test_empty_dict(self):\n        \"\"\" Test with an empty dictionary. \"\"\"\n        data = {}\n        key_to_remove = [\"email\", \"metadata\"]\n\n        expected = {}\n        self.assertEqual(sanitize_data(data, key_to_remove), expected)\n\n    def test_remove_default_keys(self):\n        \"\"\" Test removing default keys from a nested structure. \"\"\"\n        data = {\n            \"name\": \"John Doe\",\n            \"email\": \"johndoe@example.com\",\n            \"metadata\": {\"submitted_at\": \"2021-07-10\", \"status\": \"pending\"},\n            \"comments\": [\"Good\", \"Needs review\"]\n        }\n        key_to_remove = [\"email\", \"metadata\"]\n        expected = {\n            \"name\": \"John Doe\",\n            \"comments\": [\"Good\", \"Needs review\"]\n        }\n        self.assertEqual(sanitize_data(data, key_to_remove), expected)\n\n    def test_specified_key_to_remove(self):\n        \"\"\" Test removing a specified key from the dictionary. \"\"\"\n        data = {\n            \"name\": \"John Doe\",\n            \"location\": \"Earth\",\n            \"email\": \"johndoe@example.com\"\n        }\n        expected = {\n            \"name\": \"John Doe\",\n            \"location\": \"Earth\"\n        }\n        self.assertEqual(sanitize_data(data, key_to_remove=[\"email\"]), expected)", "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef sanitize_data(data: Dict, key_to_remove: List = None) -> Dict:\n    \"\"\"\n    remove the corresponding sensitive question in the given dictionary based on the given key_to_remove list\n\n    Args:\n        data (Dict): original question dict\n        key_to_remove (List): key_to_remove list\n\n    Returns:\n        Dict: removed dict\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Remove the corresponding sensitive questions in the given dictionary based on the given key_to_remove list.\n *\n * @param data The original question dictionary.\n * @param key_to_remove The list of keys to remove.\n * @return std::unordered_map<std::string, std::string> The removed dictionary.\n */\nstd::unordered_map<std::string, std::string> sanitize_data(const std::unordered_map<std::string, std::string>& data, const std::vector<std::string>& keyToRemove) {\n\n}", "test_code": "TEST_CASE(\"TestSanitizeData\", \"[SanitizeData]\") {\n    SECTION(\"test_empty_dict\") {\n        // Test with an empty dictionary.\n        std::unordered_map<std::string, std::string> data = {};\n        std::vector<std::string> key_to_remove = {\"email\", \"metadata\"};\n\n        std::unordered_map<std::string, std::string> expected = {};\n        REQUIRE(sanitize_data(data, &key_to_remove) == expected);\n    }\n\n    SECTION(\"test_remove_default_keys\") {\n        // Test removing default keys from a nested structure.\n        std::unordered_map<std::string, std::string> data = {\n            {\"name\", \"John Doe\"},\n            {\"email\", \"johndoe@example.com\"},\n            {\"metadata\", \"version: 1, timestamp: 2021-07-10, status: pending\"},\n            {\"comments\", \"Good, Needs review\"}\n        };\n        std::vector<std::string> key_to_remove = {\"email\", \"metadata\"};\n        std::unordered_map<std::string, std::string> expected = {\n            {\"name\", \"John Doe\"},\n            {\"comments\", \"Good, Needs review\"}\n        };\n        REQUIRE(sanitize_data(data, &key_to_remove) == expected);\n    }\n\n    SECTION(\"test_specified_key_to_remove\") {\n        // Test removing a specified key from the dictionary.\n        std::unordered_map<std::string, std::string> data = {\n            {\"name\", \"John Doe\"},\n            {\"location\", \"Earth\"},\n            {\"email\", \"johndoe@example.com\"}\n        };\n        std::unordered_map<std::string, std::string> expected = {\n            {\"name\", \"John Doe\"},\n            {\"location\", \"Earth\"}\n        };\n        REQUIRE(sanitize_data(data, &std::vector<std::string>{\"email\"}) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Remove the corresponding sensitive questions in the given dictionary based on the given key_to_remove list.\n *\n * @param data The original question dictionary.\n * @param key_to_remove The list of keys to remove.\n * @return std::unordered_map<std::string, std::string> The removed dictionary.\n */\nstd::unordered_map<std::string, std::string> sanitize_data(const std::unordered_map<std::string, std::string>& data, const std::vector<std::string>& keyToRemove) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Removes the corresponding sensitive questions in the given dictionary based on the given list of keys to remove.\n *\n * @param data          the original question dictionary\n * @param keyToBeRemoved the list of keys to remove; if null, uses default keys\n * @return the sanitized dictionary\n */\npublic static Map<String, Object> sanitizeData(Map<String, Object> data, List<String> keyToBeRemoved) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class Tester {\n\n    private SanitizeData sanitizer;\n\n    @Before\n    public void setUp() {\n        sanitizer = new SanitizeData();\n    }\n\n    @Test\n    public void testSanitizeDataWithKeys() {\n        // Arrange\n        Data data = new Data(\"John\", 30, \"secret\");\n        String[] keysToRemove = {\"password\"};\n        Data expectedResult = new Data(\"John\", 30);\n\n        // Act\n        Data result = sanitizer.sanitizeData(data, keysToRemove);\n\n        // Assert\n        assertEquals(expectedResult, result);\n    }\n\n    @Test\n    public void testSanitizeDataNoKeys() {\n        // Arrange\n        Data data = new Data(\"John\", 30, \"secret\");\n        String[] keysToRemove = {};\n        Data expectedResult = new Data(\"John\", 30, \"secret\");\n\n        // Act\n        Data result = sanitizer.sanitizeData(data, keysToRemove);\n\n        // Assert\n        assertEquals(expectedResult, result);\n    }\n\n    // Helper classes for testing\n    public static class Data {\n        private String name;\n        private int age;\n        private String password;\n\n        public Data(String name, int age, String password) {\n            this.name = name;\n            this.age = age;\n            this.password = password;\n        }\n\n        public Data(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        // Getters and setters (omitted for brevity)\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Data data = (Data) o;\n            return age == data.age && Objects.equals(name, data.name) && Objects.equals(password, data.password);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(name, age, password);\n        }\n\n        @Override\n        public String toString() {\n            return \"Data{\" +\n                    \"name='\" + name + '\\'' +\n                    \", age=\" + age +\n                    \", password='\" + password + '\\'' +\n                    '}';\n        }\n    }\n\n    public static class SanitizeData {\n        public Data sanitizeData(Data data, String[] keysToRemove) {\n            Data sanitizedData = new Data(data.getName(), data.getAge());\n            for (String key : keysToRemove) {\n                if (\"password\".equals(key)) {\n                    sanitizedData.setPassword(null);\n                }\n            }\n            return sanitizedData;\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Removes the corresponding sensitive questions in the given dictionary based on the given list of keys to remove.\n *\n * @param data          the original question dictionary\n * @param keyToBeRemoved the list of keys to remove; if null, uses default keys\n * @return the sanitized dictionary\n */\npublic static Map<String, Object> sanitizeData(Map<String, Object> data, List<String> keyToBeRemoved) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 249, "code_type": "method", "original_language": "python", "file_path": "Spectrum\\928b58b455406a6f08b05c1d752bf0eef79e04f0\\Assets\\Other\\ofl_to_spectrum.py", "question_type": "File operations and I/O operation", "summary": "Extract text from a given pdf file", "language_version_list": {"python": {"code_signature": "def extract_text_from_pdf(file_path: str) -> str:\n    \"\"\"\n    Extracts text from a given PDF file.\n\n    Args:\n    file_path (str): The path to the PDF file from which to extract text.\n\n    Returns:\n    str: The extracted text from the PDF.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestExtractTextFromPDF(unittest.TestCase):\n    def test_empty_file(self):\n        pdf_path = r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t249\\testcase01.pdf\"\n        expected = \" \\n\"\n        output = extract_text_from_pdf(pdf_path)\n        self.assertEqual(output, expected)\n\n    def test_normal_file(self):\n        pdf_path = r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t249\\testcase02.pdf\"\n        expected = \"11111  \\n\"\n        output = extract_text_from_pdf(pdf_path)\n        self.assertEqual(output, expected)\n\n    def test_more_text_file(self):\n        pdf_path = r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t249\\testcase03.pdf\"\n        expected = \"11111  \\n22222  \\n33333  \\n44444  \\n\"\n        output = extract_text_from_pdf(pdf_path)\n        self.assertEqual(output, expected)\n", "prompt": "please write a python function , the function signature as below def extract_text_from_pdf(file_path: str) -> str:\n    \"\"\"\n    Extracts text from a given PDF file.\n\n    Args:\n    file_path (str): The path to the PDF file from which to extract text.\n\n    Returns:\n    str: The extracted text from the PDF.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 250, "code_type": "method", "original_language": "python", "file_path": "RegRank\\ba03f17603783d94961ba936113d3b44423468aa\\regrank\\draw\\utils.py", "question_type": "Data processing and transformation", "summary": "Invert the keys and values in the dictionary, change the values of the original dictionary to the keys of the new dictionary, and the keys of the original dictionary become the values of the new dictionary. If the values in the original dictionary are duplicate (that is, multiple keys share the same value), the keys of the new dictionary will be mapped to a list containing all corresponding original keys\n", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef invert_dictionary(original_dict: Dict) -> Dict:\n    \"\"\"\n    Invert the keys and values in a dictionary. If multiple keys have the same value,\n    the new dictionary's values will be a list of these keys.\n    Args:\n        original_dict (dict): The dictionary to invert.\n\n    Returns:\n        A new dictionary with values and keys inverted.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestInvertDictionary(unittest.TestCase):\n\n    def test_normal_dictionary(self):\n        \"\"\"Test inversion of a dictionary without duplicate values.\"\"\"\n        original_dict = {'a': 1, 'b': 2, 'c': 3}\n        expected = {1: 'a', 2: 'b', 3: 'c'}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_dictionary_with_duplicates(self):\n        \"\"\"Test inversion of a dictionary with duplicate values.\"\"\"\n        original_dict = {'a': 1, 'b': 1, 'c': 2}\n        expected = {1: ['a', 'b'], 2: 'c'}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_empty_dictionary(self):\n        \"\"\"Test inversion of an empty dictionary.\"\"\"\n        original_dict = {}\n        expected = {}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_non_string_keys(self):\n        \"\"\"Test inversion of a dictionary with non-string keys.\"\"\"\n        original_dict = {1: 'apple', 2: 'banana', 3: 'apple'}\n        expected = {'apple': [1, 3], 'banana': 2}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_mixed_types(self):\n        \"\"\"Test inversion of a dictionary with mixed key and value types.\"\"\"\n        original_dict = {'a': 1, 2: 'two', 'three': 3}\n        expected = {1: 'a', 'two': 2, 3: 'three'}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef invert_dictionary(original_dict: Dict) -> Dict:\n    \"\"\"\n    Invert the keys and values in a dictionary. If multiple keys have the same value,\n    the new dictionary's values will be a list of these keys.\n    Args:\n        original_dict (dict): The dictionary to invert.\n\n    Returns:\n        A new dictionary with values and keys inverted.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Invert the keys and values in a dictionary. If multiple keys have the same value,\n * the new dictionary's values will be a list of these keys.\n *\n * @param original_dict The dictionary to invert.\n * @return A new dictionary with values and keys inverted.\n */\nstd::unordered_map<std::string, std::vector<std::string>> invert_dictionary(const std::unordered_map<std::string, std::string>& originalDict){\n\n}", "test_code": "TEST_CASE(\"Test inversion of a dictionary without duplicate values\") {\n    std::unordered_map<std::string, std::string> originalDict = {{\"a\", \"1\"}, {\"b\", \"2\"}, {\"c\", \"3\"}};\n    std::unordered_map<std::string, std::string> expected = {{\"1\", \"a\"}, {\"2\", \"b\"}, {\"3\", \"c\"}};\n    auto result = invert_dictionary(originalDict);\n\n    REQUIRE(result == expected);\n}\n\nTEST_CASE(\"Test inversion of a dictionary with duplicate values\") {\n    std::unordered_map<std::string, std::string> originalDict = {{\"a\", \"1\"}, {\"b\", \"1\"}, {\"c\", \"2\"}};\n    std::unordered_map<std::string, std::vector<std::string>> expected = {{\"1\", {\"a\", \"b\"}}, {\"2\", {\"c\"}}};\n    auto result = invert_dictionary(originalDict);\n\n    REQUIRE(result == expected);\n}\n\nTEST_CASE(\"Test inversion of an empty dictionary\") {\n    std::unordered_map<std::string, std::string> originalDict = {};\n    std::unordered_map<std::string, std::vector<std::string>> expected = {};\n    auto result = invert_dictionary(originalDict);\n\n    REQUIRE(result == expected);\n}\n\nTEST_CASE(\"Test inversion of a dictionary with non-string keys\") {\n    // Note: In C++, all keys and values are strings for simplicity.\n    std::unordered_map<std::string, std::string> originalDict = {{\"1\", \"apple\"}, {\"2\", \"banana\"}, {\"3\", \"apple\"}};\n    std::unordered_map<std::string, std::vector<std::string>> expected = {{\"apple\", {\"1\", \"3\"}}, {\"banana\", {\"2\"}}};\n    auto result = invert_dictionary(originalDict);\n\n    REQUIRE(result == expected);\n}\n\nTEST_CASE(\"Test inversion of a dictionary with mixed key and value types\") {\n    // Note: In C++, all keys and values are strings for simplicity.\n    std::unordered_map<std::string, std::string> originalDict = {{\"a\", \"1\"}, {\"2\", \"two\"}, {\"three\", \"3\"}};\n    std::unordered_map<std::string, std::vector<std::string>> expected = {{\"1\", {\"a\"}}, {\"two\", {\"2\"}}, {\"3\", {\"three\"}}};\n    auto result = invert_dictionary(originalDict);\n\n    REQUIRE(result == expected);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Invert the keys and values in a dictionary. If multiple keys have the same value,\n * the new dictionary's values will be a list of these keys.\n *\n * @param original_dict The dictionary to invert.\n * @return A new dictionary with values and keys inverted.\n */\nstd::unordered_map<std::string, std::vector<std::string>> invert_dictionary(const std::unordered_map<std::string, std::string>& originalDict){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Invert the keys and values in a dictionary. If multiple keys have the same value,\n * the new dictionary's values will be a list of these keys.\n *\n * @param originalDict The dictionary to invert.\n * @return A new dictionary with values and keys inverted.\n */\npublic static Map<Object, Object> invertDictionary(Map<Object, Object> originalDict) {\n    // Your implementation goes here\n}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Tester {\n\n    @Test\n    public void testInvertDictionary() {\n        // Test case 1\n        Map<String, Integer> input1 = new HashMap<>();\n        input1.put(\"a\", 1);\n        input1.put(\"b\", 2);\n        input1.put(\"c\", 3);\n\n        Map<Integer, List<String>> expectedOutput1 = new HashMap<>();\n        expectedOutput1.put(1, Arrays.asList(\"a\"));\n        expectedOutput1.put(2, Arrays.asList(\"b\"));\n        expectedOutput1.put(3, Arrays.asList(\"c\"));\n\n        assertEquals(expectedOutput1, DictionaryUtils.invertDictionary(input1));\n\n        // Test case 2\n        Map<String, String> input2 = new HashMap<>();\n        input2.put(\"apple\", \"fruit\");\n        input2.put(\"banana\", \"fruit\");\n        input2.put(\"carrot\", \"vegetable\");\n\n        Map<String, List<String>> expectedOutput2 = new HashMap<>();\n        expectedOutput2.put(\"fruit\", Arrays.asList(\"apple\", \"banana\"));\n        expectedOutput2.put(\"vegetable\", Arrays.asList(\"carrot\"));\n\n        assertEquals(expectedOutput2, DictionaryUtils.invertDictionary(input2));\n    }\n\n    @Test\n    public void testInvertDictionaryWithDuplicateValues() {\n        // Test case with duplicate values\n        Map<String, String> input3 = new HashMap<>();\n        input3.put(\"one\", \"1\");\n        input3.put(\"two\", \"2\");\n        input3.put(\"three\", \"1\");\n\n        Map<String, List<String>> expectedOutput3 = new HashMap<>();\n        expectedOutput3.put(\"1\", Arrays.asList(\"one\", \"three\"));\n        expectedOutput3.put(\"2\", Arrays.asList(\"two\"));\n\n        assertEquals(expectedOutput3, DictionaryUtils.invertDictionary(input3));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Invert the keys and values in a dictionary. If multiple keys have the same value,\n * the new dictionary's values will be a list of these keys.\n *\n * @param originalDict The dictionary to invert.\n * @return A new dictionary with values and keys inverted.\n */\npublic static Map<Object, Object> invertDictionary(Map<Object, Object> originalDict) {\n    // Your implementation goes here\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 252, "code_type": "method", "original_language": "python", "file_path": "EL9115_interactive_config\\6c573aa30877c32cf6324b5f0f3e7d9175d69b4b\\src\\spi_utilities.py", "question_type": "Algorithm and data structure", "summary": "Write a JSON decoding class that inherits from json.JSONEncoder. When encoding data into json format, the main functional bits of this class specifically handle keys identified as bits, and convert them to binary form if their value is an integer\n", "language_version_list": {"python": {"code_signature": "import json\n\n\nclass BitSequenceEncoder(json.JSONEncoder):\n    \"\"\"\n    Write a JSON decoding class that inherits from json.JSONEncoder. When encoding question into json format, the main functional bits of this class specifically handle keys identified as bits, and convert them to binary form if their value is an integer\n    For example 'bits': 255 after encoder \"bits\": \"11111111\"\n\n    \"\"\"\n\n    def encode(self, obj):\n        pass\n", "test_code": "import unittest\nimport json\n\nclass TestBitSequenceEncoder(unittest.TestCase):\n    def test_basic_encoding(self):\n        \"\"\" Test encoding with simple dictionary containing 'bits'. \"\"\"\n        data = {'name': 'Processor', 'bits': 255}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"name\": \"Processor\", \"bits\": \"11111111\"}')\n\n    def test_nested_encoding(self):\n        \"\"\" Test encoding with nested dictionary containing 'bits'. \"\"\"\n        data = {'component': {'name': 'ALU', 'bits': 128}, 'bits': 1}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"component\": {\"name\": \"ALU\", \"bits\": \"10000000\"}, \"bits\": \"00000001\"}')\n\n    def test_non_bits_key(self):\n        \"\"\" Test encoding with dictionary not containing 'bits' key. \"\"\"\n        data = {'name': 'Processor', 'value': 123}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"name\": \"Processor\", \"value\": 123}')\n\n    def test_no_bits_conversion_needed(self):\n        \"\"\" Test encoding with dictionary where 'bits' key needs no conversion. \"\"\"\n        data = {'name': 'Unit', 'bits': 'Already binary'}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"name\": \"Unit\", \"bits\": \"Already binary\"}')\n\n    def test_complex_structure_with_bits(self):\n        \"\"\" Test encoding a complex dictionary structure containing multiple 'bits' keys. \"\"\"\n        data = {\n            'processor': {'bits': 3, 'type': 'A'},\n            'memory': {'bits': 255, 'size': 16},\n            'ports': {'count': 2, 'bits': 128}\n        }\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"processor\": {\"bits\": \"00000011\", \"type\": \"A\"}, \"memory\": {\"bits\": \"11111111\", \"size\": 16}, \"ports\": {\"count\": 2, \"bits\": \"10000000\"}}')\n", "prompt": "please write a python function , the function signature as below import json\n\n\nclass BitSequenceEncoder(json.JSONEncoder):\n    \"\"\"\n    Write a JSON decoding class that inherits from json.JSONEncoder. When encoding question into json format, the main functional bits of this class specifically handle keys identified as bits, and convert them to binary form if their value is an integer\n    For example 'bits': 255 after encoder \"bits\": \"11111111\"\n\n    \"\"\"\n\n    def encode(self, obj):\n        pass\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 253, "code_type": "method", "original_language": "python", "file_path": "lego-spike-prime\\c7804b0df3da4ea368405f6b379be287dace2dec\\GyroMoveAndRotate.py", "question_type": "File operations and I/O operation", "summary": "Write a function to process different types of log entries. This function can process strings, numbers, dictionaries and lists, and can serialize dictionaries and lists into JSON format for output. If the input data type is not supported, an error will be thrown.\n", "language_version_list": {"python": {"code_signature": "def log(item: any) -> any:\n    \"\"\"\n    Logs an item by printing it. Handles strings, numbers, lists, and dictionaries by printing\n    them directly or as a JSON-formatted string. Other types are reported as errors.\n    Args:\n        item (any): The item to be logged. Can be of any type.\n\n    Returns:\n        item: The item to be logged. Can be of any type.\n    \"\"\"\n", "test_code": "import unittest\nfrom unittest.mock import patch\n\n\nclass TestLogFunction(unittest.TestCase):\n    @patch('builtins.print')\n    def test_log_string(self, mock_print):\n        \"\"\" Test logging a simple string \"\"\"\n        log(\"Hello, world!\")\n        mock_print.assert_called_once_with(\"Hello, world!\")\n\n    @patch('builtins.print')\n    def test_log_number(self, mock_print):\n        \"\"\" Test logging a number \"\"\"\n        log(123.456)\n        mock_print.assert_called_once_with(123.456)\n\n    @patch('builtins.print')\n    def test_log_dictionary(self, mock_print):\n        \"\"\" Test logging a dictionary as JSON \"\"\"\n        log({\"key\": \"value\", \"number\": 42})\n        expected_json_output = '{\\n    \"key\": \"value\",\\n    \"number\": 42\\n}'\n        mock_print.assert_called_once_with(expected_json_output)\n\n    @patch('builtins.print')\n    def test_log_list(self, mock_print):\n        \"\"\" Test logging a list as JSON \"\"\"\n        log([1, 2, 3, 4, 5])\n        expected_json_output = '[\\n    1,\\n    2,\\n    3,\\n    4,\\n    5\\n]'\n        mock_print.assert_called_once_with(expected_json_output)", "prompt": "please write a python function , the function signature as below def log(item: any) -> any:\n    \"\"\"\n    Logs an item by printing it. Handles strings, numbers, lists, and dictionaries by printing\n    them directly or as a JSON-formatted string. Other types are reported as errors.\n    Args:\n        item (any): The item to be logged. Can be of any type.\n\n    Returns:\n        item: The item to be logged. Can be of any type.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 255, "code_type": "method", "original_language": "python", "file_path": "avenet42\\28a087a9b35de7f7b5c7999b9d5b1e72c2e878c4\\tools\\helper_convertfont.py", "question_type": "File operations and I/O operation", "summary": "Convert a picture to an array of binary bits. Convert it to black and white mode (only 0s and 1s, corresponding to black and white), convert the white pixel (value 255) to 1, convert the black pixel to 0, and finally store these bits in an array and return\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef convert_image_to_bits(image_path: str) -> List:\n    \"\"\"\n    Convert a picture to an array of binary bits. Convert it to black and white mode (only 0s and 1s, corresponding to black and white), convert the white pixel (value 255) to 1, convert the black pixel to 0, and finally store these bits in an array and return\n\n\n    Args:\n        image_path (str): The path to the image file.\n\n    Returns:\n        list: A list of bits (0 or 1) representing the image.\n    \"\"\"\n", "test_code": "import unittest\nfrom io import BytesIO\nfrom PIL import Image\n\n\n\nclass TestConvertImageToBits(unittest.TestCase):\n\n    def create_image(self, mode, size, color):\n        \"\"\"\n        Helper method to create an in-memory image.\n\n        Args:\n            mode (str): The color mode of the image (e.g., '1' for binary, 'L' for grayscale).\n            size (tuple): A tuple of the image size (width, height).\n            color (int or tuple): The color to fill the image. 255 for white, 0 for black in '1' mode.\n\n        Returns:\n            Image: A PIL Image object.\n        \"\"\"\n        image = Image.new(mode, size, color)\n        return image\n\n    def test_all_white_image(self):\n        image = self.create_image('1', (4, 4), 255)\n        expected_bits = [1] * 16\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_all_black_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        expected_bits = [0] * 16\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_checkerboard_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        pixels = image.load()\n        for y in range(4):\n            for x in range(4):\n                if (x + y) % 2 == 0:\n                    pixels[x, y] = 255\n        expected_bits = [1, 0, 1, 0,\n                         0, 1, 0, 1,\n                         1, 0, 1, 0,\n                         0, 1, 0, 1]\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_horizontal_stripes_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        pixels = image.load()\n        for y in range(4):\n            for x in range(4):\n                if y % 2 == 0:\n                    pixels[x, y] = 255\n        expected_bits = [1, 1, 1, 1,\n                         0, 0, 0, 0,\n                         1, 1, 1, 1,\n                         0, 0, 0, 0]\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_vertical_stripes_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        pixels = image.load()\n        for y in range(4):\n            for x in range(4):\n                if x % 2 == 0:\n                    pixels[x, y] = 255\n        expected_bits = [1, 0, 1, 0,\n                         1, 0, 1, 0,\n                         1, 0, 1, 0,\n                         1, 0, 1, 0]\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef convert_image_to_bits(image_path: str) -> List:\n    \"\"\"\n    Convert a picture to an array of binary bits. Convert it to black and white mode (only 0s and 1s, corresponding to black and white), convert the white pixel (value 255) to 1, convert the black pixel to 0, and finally store these bits in an array and return\n\n\n    Args:\n        image_path (str): The path to the image file.\n\n    Returns:\n        list: A list of bits (0 or 1) representing the image.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert a picture to an array of binary bits. Convert it to black and white mode (only 0s and 1s,\n * corresponding to black and white), convert the white pixel (value 255) to 1, convert the black pixel to 0,\n * and finally store these bits in an array and return.\n *\n * @param image_path The path to the image file.\n * @return std::vector<int> A vector of bits (0 or 1) representing the image.\n */\nstd::vector<int> convert_image_to_bits(const std::string& image_path){\n\n}", "test_code": "TEST_CASE(\"TestConvertImageToBits\", \"[image]\") {\n    SECTION(\"All White Image\") {\n        const char* filename = \"all_white.png\";\n        create_and_save_image(\"1\", {4, 4}, 255, filename);\n        std::vector<int> expected_bits = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n        std::vector<int> result = convert_image_to_bits(filename);\n        REQUIRE(result == expected_bits);\n    }\n\n    SECTION(\"All Black Image\") {\n        const char* filename = \"all_black.png\";\n        create_and_save_image(\"1\", {4, 4}, 0, filename);\n        std::vector<int> expected_bits = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n        std::vector<int> result = convert_image_to_bits(filename);\n        REQUIRE(result == expected_bits);\n    }\n\n    SECTION(\"Checkerboard Image\") {\n        const char* filename = \"checkerboard.png\";\n        create_and_save_image(\"1\", {4, 4}, 0, filename);\n\n        // Load the image and modify pixels\n        int width, height, channels;\n        unsigned char* data = stbi_load(filename, &width, &height, &channels, 1);\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x) {\n                if ((x + y) % 2 == 0) {\n                    data[y * width + x] = 255;\n                }\n            }\n        }\n        stbi_write_png(filename, width, height, 1, data, width);\n        stbi_image_free(data);\n\n        std::vector<int> expected_bits = {1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1};\n        std::vector<int> result = convert_image_to_bits(filename);\n        REQUIRE(result == expected_bits);\n    }\n\n    SECTION(\"Horizontal Stripes Image\") {\n        const char* filename = \"horizontal_stripes.png\";\n        create_and_save_image(\"1\", {4, 4}, 0, filename);\n\n        // Load the image and modify pixels\n        int width, height, channels;\n        unsigned char* data = stbi_load(filename, &width, &height, &channels, 1);\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x) {\n                if (y % 2 == 0) {\n                    data[y * width + x] = 255;\n                }\n            }\n        }\n        stbi_write_png(filename, width, height, 1, data, width);\n        stbi_image_free(data);\n\n        std::vector<int> expected_bits = {1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0};\n        std::vector<int> result = convert_image_to_bits(filename);\n        REQUIRE(result == expected_bits);\n    }\n\n    SECTION(\"Vertical Stripes Image\") {\n        const char* filename = \"vertical_stripes.png\";\n        create_and_save_image(\"1\", {4, 4}, 0, filename);\n\n        // Load the image and modify pixels\n        int width, height, channels;\n        unsigned char* data = stbi_load(filename, &width, &height, &channels, 1);\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x) {\n                if (x % 2 == 0) {\n                    data[y * width + x] = 255;\n                }\n            }\n        }\n        stbi_write_png(filename, width, height, 1, data, width);\n        stbi_image_free(data);\n\n        std::vector<int> expected_bits = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n        std::vector<int> result = convert_image_to_bits(filename);\n        REQUIRE(result == expected_bits);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert a picture to an array of binary bits. Convert it to black and white mode (only 0s and 1s,\n * corresponding to black and white), convert the white pixel (value 255) to 1, convert the black pixel to 0,\n * and finally store these bits in an array and return.\n *\n * @param image_path The path to the image file.\n * @return std::vector<int> A vector of bits (0 or 1) representing the image.\n */\nstd::vector<int> convert_image_to_bits(const std::string& image_path){\n\n}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 256, "code_type": "method", "original_language": "python", "file_path": "avenet42\\28a087a9b35de7f7b5c7999b9d5b1e72c2e878c4\\tools\\helper_convertfont.py", "question_type": "Data processing and transformation", "summary": "convert an array of binary bits to an array of bytes. Traversing through each bit, composing these bits into bytes, forming a byte every 8 bits, and then storing these bytes in an array and returning it. If the length of the bit array is not a multiple of 8, the last incomplete byte will be discarded.\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef bits_to_bytes(bits: List[int]) -> bytearray:\n    \"\"\"\n    convert an array of binary bits to an array of bytes. Traversing through each bit, composing these bits into bytes, forming a byte every 8 bits, and then storing these bytes in an array and returning it. If the length of the bit array is not a multiple of 8, the last incomplete byte will be discarded.\n\n    Args:\n        bits (List[int]): The input array of bits (each element should be 0 or 1).\n\n    Returns:\n        An array of bytes constructed from the bits.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestBitsToBytes(unittest.TestCase):\n\n    def test_exact_multiple_of_eight(self):\n        \"\"\"Test bit arrays that are exact multiples of 8 bits.\"\"\"\n        bits = [1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1]\n        expected = bytearray([0b10110010, 0b01001111])  # Corrected to match actual byte values\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_incomplete_byte_discarded(self):\n        \"\"\"Test bit arrays where the last bits do not make up a full byte.\"\"\"\n        bits = [1, 0, 1, 1, 0, 0, 1, 0, 0, 1]  # Last two bits should be discarded\n        expected = bytearray([0b10110010])\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_empty_bit_array(self):\n        \"\"\"Test an empty bit array.\"\"\"\n        bits = []\n        expected = bytearray()\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_single_full_byte(self):\n        \"\"\"Test bit arrays that exactly make one byte.\"\"\"\n        bits = [1, 1, 1, 1, 1, 1, 1, 1]  # Represents the byte 0xFF\n        expected = bytearray([0xFF])\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_no_bits_discarded(self):\n        \"\"\"Test bit arrays with multiple of 8 bits and no extra bits.\"\"\"\n        bits = [1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1]\n        expected = bytearray([0xCC, 0x77])  # Corrected the second byte from 0xB7 to 0x77\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef bits_to_bytes(bits: List[int]) -> bytearray:\n    \"\"\"\n    convert an array of binary bits to an array of bytes. Traversing through each bit, composing these bits into bytes, forming a byte every 8 bits, and then storing these bytes in an array and returning it. If the length of the bit array is not a multiple of 8, the last incomplete byte will be discarded.\n\n    Args:\n        bits (List[int]): The input array of bits (each element should be 0 or 1).\n\n    Returns:\n        An array of bytes constructed from the bits.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert an array of binary bits to an array of bytes. Traverse through each bit,\n * composing these bits into bytes, forming a byte every 8 bits, and then store\n * these bytes in a vector and return it. If the length of the bit array is not a\n * multiple of 8, the last incomplete byte will be discarded.\n *\n * @param bits A vector of integers representing the input array of bits (each element should be 0 or 1).\n * @return A vector of bytes constructed from the bits.\n */\nstd::vector<uint8_t> bits_to_bytes(const std::vector<int>& bits){\n\n}", "test_code": "TEST_CASE(\"Test bits_to_bytes function\", \"[bits_to_bytes]\") {\n    SECTION(\"Test exact multiple of eight\") {\n        std::vector<int> bits = {1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1};\n        std::vector<unsigned char> expected = {0b10110010, 0b01001111};\n        auto result = bits_to_bytes(bits);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test incomplete byte discarded\") {\n        std::vector<int> bits = {1, 0, 1, 1, 0, 0, 1, 0, 0, 1};  // Last two bits should be discarded\n        std::vector<unsigned char> expected = {0b10110010};\n        auto result = bits_to_bytes(bits);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test empty bit array\") {\n        std::vector<int> bits = {};\n        std::vector<unsigned char> expected = {};\n        auto result = bits_to_bytes(bits);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test single full byte\") {\n        std::vector<int> bits = {1, 1, 1, 1, 1, 1, 1, 1};  // Represents the byte 0xFF\n        std::vector<unsigned char> expected = {0xFF};\n        auto result = bits_to_bytes(bits);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test no bits discarded\") {\n        std::vector<int> bits = {1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1};\n        std::vector<unsigned char> expected = {0xCC, 0x77};  // Corrected the second byte from 0xB7 to 0x77\n        auto result = bits_to_bytes(bits);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert an array of binary bits to an array of bytes. Traverse through each bit,\n * composing these bits into bytes, forming a byte every 8 bits, and then store\n * these bytes in a vector and return it. If the length of the bit array is not a\n * multiple of 8, the last incomplete byte will be discarded.\n *\n * @param bits A vector of integers representing the input array of bits (each element should be 0 or 1).\n * @return A vector of bytes constructed from the bits.\n */\nstd::vector<uint8_t> bits_to_bytes(const std::vector<int>& bits){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts an array of binary bits to an array of bytes. Traverses through each bit,\n * composing these bits into bytes, forming a byte every 8 bits, and then storing these\n * bytes in an array and returning it. If the length of the bit array is not a multiple\n * of 8, the last incomplete byte will be discarded.\n *\n * @param bits The input list of bits (each element should be 0 or 1).\n * @return A byte array constructed from the bits.\n */\npublic static byte[] bitsToBytes(List<Integer> bits) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\npublic class Tester {\n\n    @Test\n    public void testBitsToBytes() {\n        // Test data\n        int[] bits = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n        byte[] expectedOutput = {(byte) 0xAA};\n\n        // Call the method under test\n        byte[] actualOutput = bitsToBytes(bits);\n\n        // Verify the output\n        assertArrayEquals(expectedOutput, actualOutput);\n    }\n\n    /**\n     * Convert an array of binary bits to an array of bytes. Traversing through each bit,\n     * composing these bits into bytes, forming a byte every 8 bits, and then storing\n     * these bytes in an array and returning it. If the length of the bit array is not a\n     * multiple of 8, the last incomplete byte will be discarded.\n     *\n     * @param bits The input array of bits (each element should be 0 or 1).\n     * @return An array of bytes constructed from the bits.\n     */\n    public byte[] bitsToBytes(int[] bits) {\n        if (bits == null || bits.length % 8 != 0) {\n            return new byte[0];\n        }\n\n        int numBytes = bits.length / 8;\n        byte[] bytes = new byte[numBytes];\n\n        for (int i = 0; i < numBytes; i++) {\n            int byteValue = 0;\n            for (int j = 0; j < 8; j++) {\n                byteValue = (byteValue << 1) | bits[i * 8 + j];\n            }\n            bytes[i] = (byte) byteValue;\n        }\n\n        return bytes;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts an array of binary bits to an array of bytes. Traverses through each bit,\n * composing these bits into bytes, forming a byte every 8 bits, and then storing these\n * bytes in an array and returning it. If the length of the bit array is not a multiple\n * of 8, the last incomplete byte will be discarded.\n *\n * @param bits The input list of bits (each element should be 0 or 1).\n * @return A byte array constructed from the bits.\n */\npublic static byte[] bitsToBytes(List<Integer> bits) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 258, "code_type": "method", "original_language": "python", "file_path": "avenet42\\28a087a9b35de7f7b5c7999b9d5b1e72c2e878c4\\tools\\helper_convertfont.py", "question_type": "Data processing and transformation", "summary": "given a character set, extract the position of a specific character from a byte array. First, determine whether the desired character exists in the character set, and if so, calculate the character's position in the byte array, and extract the character's bits\n", "language_version_list": {"python": {"code_signature": "from typing import Tuple, List\n\n\ndef extract_character_bits(byte_array: bytes, char: str, charset='utf-8') -> Tuple[int, str]:\n    \"\"\"\n    Extracts the position and bits of a specific character from a byte array.\n\n    Args:\n        byte_array (bytes): The byte array to search within\n        char (str): The character to find in the byte array\n        charset (str): The character encoding of the byte array\n\n    Returns:\n        A tuple of (position, bits) if the character is found, otherwise None.\n    \"\"\"\n", "test_code": "import unittest\n\n# Assuming extract_character_bits is imported from your module\n# from your_module import extract_character_bits\n\nclass TestExtractCharacterBits(unittest.TestCase):\n\n    def test_case_1_valid_utf8(self):\n        byte_array = b'Hello, World!'\n        char = 'W'\n        result = extract_character_bits(byte_array, char, 'utf-8')\n        expected_result = (7, '01010111')  # 'W' is at position 7 with binary bits\n        self.assertEqual(result, expected_result)\n\n    def test_case_2_non_existent_character(self):\n        byte_array = b'This is a test.'\n        char = 'z'\n        result = extract_character_bits(byte_array, char, 'utf-8')\n        self.assertIsNone(result)  # Character 'z' is not in the byte array\n\n    def test_case_3_invalid_encoding(self):\n        byte_array = b'\\xff\\xfe'\n        char = 'A'\n        result = extract_character_bits(byte_array, char, 'ascii')  # Invalid bytes for ASCII\n        self.assertIsNone(result)  # Should handle UnicodeDecodeError and return None\n\n    def test_case_4_valid_utf16(self):\n        byte_array = 'Hello, World!'.encode('utf-16')\n        char = '!'\n        result = extract_character_bits(byte_array, char, 'utf-16')\n        expected_result = (12, '00100001 00000000')  # '!' at position 12 in UTF-16 encoding\n        self.assertEqual(result, expected_result)\n\n    def test_case_5_special_characters_utf8(self):\n        byte_array = 'Python \ud83d\udc0d is fun!'.encode('utf-8')\n        char = '\ud83d\udc0d'\n        result = extract_character_bits(byte_array, char, 'utf-8')\n        expected_result = (7, '11110000 10011111 10010000 10001101')  # Unicode character \ud83d\udc0d in UTF-8\n        self.assertEqual(result, expected_result)\n", "prompt": "please write a python function , the function signature as below from typing import Tuple, List\n\n\ndef extract_character_bits(byte_array: bytes, char: str, charset='utf-8') -> Tuple[int, str]:\n    \"\"\"\n    Extracts the position and bits of a specific character from a byte array.\n\n    Args:\n        byte_array (bytes): The byte array to search within\n        char (str): The character to find in the byte array\n        charset (str): The character encoding of the byte array\n\n    Returns:\n        A tuple of (position, bits) if the character is found, otherwise None.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 259, "code_type": "method", "original_language": "python", "file_path": "Course_Sys_Rec\\6cbc3bbf6d4592c8e79f1477433ae14434a9a3da\\backend\\search\\validators.py", "question_type": "Algorithm and data structure", "summary": "determine whether a number is a compliant four-digit number\n", "language_version_list": {"python": {"code_signature": "def is_compliant_four_digit(number: int) -> bool:\n    \"\"\"\n    determine whether a number is a compliant four-digit number\n    Args:\n        number (int): The number to check.\n\n    Returns:\n        True if the number is a compliant four-digit number, False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestIsCompliantFourDigit(unittest.TestCase):\n    def test_positive_four_digit_number(self):\n        # Tests a standard positive four-digit number\n        self.assertTrue(is_compliant_four_digit(1234))\n\n    def test_boundary_values(self):\n        # Tests the boundary values of the range\n        self.assertTrue(is_compliant_four_digit(1000))\n        self.assertTrue(is_compliant_four_digit(9999))\n\n    def test_negative_four_digit_number(self):\n        # Tests a negative four-digit number\n        self.assertFalse(is_compliant_four_digit(-1234))\n\n    def test_out_of_range_number(self):\n        # Tests numbers that are out of the four-digit range\n        self.assertFalse(is_compliant_four_digit(999))\n        self.assertFalse(is_compliant_four_digit(10000))", "prompt": "please write a python function , the function signature as below def is_compliant_four_digit(number: int) -> bool:\n    \"\"\"\n    determine whether a number is a compliant four-digit number\n    Args:\n        number (int): The number to check.\n\n    Returns:\n        True if the number is a compliant four-digit number, False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Determine whether a number is a compliant four-digit number.\n *\n * @param number The number to check.\n *\n * @return true if the number is a compliant four-digit number, false otherwise.\n */\nbool is_compliant_four_digit(int number){\n\n}", "test_code": "TEST_CASE(\"TestIsCompliantFourDigit\", \"[is_compliant_four_digit]\") {\n    SECTION(\"test_positive_four_digit_number\") {\n        // Tests a standard positive four-digit number\n        REQUIRE(is_compliant_four_digit(1234));\n    }\n\n    SECTION(\"test_boundary_values\") {\n        // Tests the boundary values of the range\n        REQUIRE(is_compliant_four_digit(1000));\n        REQUIRE(is_compliant_four_digit(9999));\n    }\n\n    SECTION(\"test_negative_four_digit_number\") {\n        // Tests a negative four-digit number\n        REQUIRE_FALSE(is_compliant_four_digit(-1234));\n    }\n\n    SECTION(\"test_out_of_range_number\") {\n        // Tests numbers that are out of the four-digit range\n        REQUIRE_FALSE(is_compliant_four_digit(999));\n        REQUIRE_FALSE(is_compliant_four_digit(10000));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Determine whether a number is a compliant four-digit number.\n *\n * @param number The number to check.\n *\n * @return true if the number is a compliant four-digit number, false otherwise.\n */\nbool is_compliant_four_digit(int number){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Determines whether the given number is a compliant four-digit number.\n *\n * @param number The number to check.\n * @return true if the number is a compliant four-digit number, false otherwise.\n */\npublic static boolean isCompliantFourDigit(int number) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testIsCompliantFourDigit() {\n        // Test cases to verify the functionality of isCompliantFourDigit method\n\n        // Case 1: Valid four-digit number\n        assertTrue(isCompliantFourDigit(1234));\n\n        // Case 2: Four-digit number with leading zero (should be false)\n        assertFalse(isCompliantFourDigit(0123));\n\n        // Case 3: Less than four digits\n        assertFalse(isCompliantFourDigit(123));\n\n        // Case 4: More than four digits\n        assertFalse(isCompliantFourDigit(12345));\n\n        // Case 5: Negative number\n        assertFalse(isCompliantFourDigit(-1234));\n    }\n\n    /**\n     * Determine whether a number is a compliant four-digit number\n     *\n     * @param number The number to check.\n     * @return True if the number is a compliant four-digit number, False otherwise.\n     */\n    public boolean isCompliantFourDigit(int number) {\n        String numStr = String.valueOf(Math.abs(number));\n        return numStr.length() == 4;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Determines whether the given number is a compliant four-digit number.\n *\n * @param number The number to check.\n * @return true if the number is a compliant four-digit number, false otherwise.\n */\npublic static boolean isCompliantFourDigit(int number) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 260, "code_type": "method", "original_language": "python", "file_path": "hci-2023-self-experiment\\e91c857a34c01e7586b98e435930d9d763020da8\\remove_empty_csv_lines.py", "question_type": "File operations and I/O operation", "summary": "Process the csv file and delete rows with two empty columns\n", "language_version_list": {"python": {"code_signature": "import pandas as pd\n\n\ndef process_csv(file_path: str, output_path: str):\n    \"\"\"\n    Processes a CSV file and removes rows with two or more empty columns.If file is empty return empty str\n\n    Args:\n        file_path (str): The path to the input CSV file.\n        output_path (str): The path where the processed CSV file will be saved.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\nimport pandas as pd\nfrom io import StringIO\n\nimport os\n\n\n# Assuming process_csv function is imported from the module\n# from your_module import process_csv\n\nclass TestProcessCSV(unittest.TestCase):\n\n    def setUp(self):\n        self.input_data_1 = \"\"\"A,B,C\n1,2,3\n4,,6\n7,8,\n9,10,11\"\"\"\n\n\n        self.input_data_2 = \"\"\"A,B,C,D\n,,\n1,,3,4\n2,3,,5\n,,,\"\"\"\n\n\n        self.input_data_3 = \"\"\"A\n1\n2\n3\"\"\"\n\n\n    def process_data(self, input_data):\n        input_file = StringIO(input_data)\n        output_file = StringIO()\n        input_file_path = \"input.csv\"\n        output_file_path = \"output.csv\"\n\n        # Write input data to a temp CSV file\n        with open(input_file_path, 'w') as f:\n            f.write(input_data)\n\n        # Process the CSV\n        process_csv(input_file_path, output_file_path)\n\n        # Read the output\n        with open(output_file_path, 'r') as f:\n            output_data = f.read()\n\n        # Clean up temp files\n        os.remove(input_file_path)\n        os.remove(output_file_path)\n\n        return output_data\n\n    def test_case_1(self):\n        output = self.process_data(self.input_data_1)\n        expected_output = \"\"\"A,B,C\\n1,2.0,3.0\\n4,,6.0\\n7,8.0,\\n9,10.0,11.0\\n\"\"\"\n        self.assertEqual(output, expected_output)\n\n    def test_case_2(self):\n        output = self.process_data(self.input_data_2)\n        expected_output = \"\"\"A,B,C,D\\n1.0,,3.0,4.0\\n2.0,3.0,,5.0\\n\"\"\"\n        self.assertEqual(output, expected_output)\n\n    def test_case_3(self):\n        output = self.process_data(self.input_data_3)\n        expected_output = \"\"\"A\\n1\\n2\\n3\\n\"\"\"  # Single-column CSV should remain unchanged\n        self.assertEqual(output, expected_output)", "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef process_csv(file_path: str, output_path: str):\n    \"\"\"\n    Processes a CSV file and removes rows with two or more empty columns.If file is empty return empty str\n\n    Args:\n        file_path (str): The path to the input CSV file.\n        output_path (str): The path where the processed CSV file will be saved.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Processes a CSV file and removes rows with two or more empty columns. If the file is empty, returns an empty string.\n *\n * @param file_path The path to the input CSV file.\n * @param output_path The path where the processed CSV file will be saved.\n */\nvoid process_csv(const std::string& file_path, const std::string& output_path){}", "test_code": "TEST_CASE(\"TestProcessCSV\", \"[process_csv]\") {\n    SECTION(\"Test Case 1\") {\n        const std::string input_data_1 = R\"(\nA,B,C\n1,2,3\n4,,6\n7,8,\n9,10,11\n)\";\n\n        const std::string input_file_path = \"input.csv\";\n        const std::string output_file_path = \"output.csv\";\n\n        // Write input data to a temp CSV file\n        std::ofstream input_file(input_file_path);\n        input_file << input_data_1;\n        input_file.close();\n\n        // Process the CSV\n        process_csv(input_file_path, output_file_path);\n\n        // Read the output\n        std::ifstream output_file(output_file_path);\n        std::stringstream output_stream;\n        output_stream << output_file.rdbuf();\n        std::string output_data = output_stream.str();\n        output_file.close();\n\n        // Clean up temp files\n        fs::remove(input_file_path);\n        fs::remove(output_file_path);\n\n        const std::string expected_output = R\"(\nA,B,C\n1,2.0,3.0\n4,,6.0\n7,8.0,\n9,10.0,11.0\n)\";\n\n        REQUIRE(output_data == expected_output);\n    }\n\n    SECTION(\"Test Case 2\") {\n        const std::string input_data_2 = R\"(\nA,B,C,D\n,,\n1,,3,4\n2,3,,5\n,,,\n)\";\n\n        const std::string input_file_path = \"input.csv\";\n        const std::string output_file_path = \"output.csv\";\n\n        // Write input data to a temp CSV file\n        std::ofstream input_file(input_file_path);\n        input_file << input_data_2;\n        input_file.close();\n\n        // Process the CSV\n        process_csv(input_file_path, output_file_path);\n\n        // Read the output\n        std::ifstream output_file(output_file_path);\n        std::stringstream output_stream;\n        output_stream << output_file.rdbuf();\n        std::string output_data = output_stream.str();\n        output_file.close();\n\n        // Clean up temp files\n        fs::remove(input_file_path);\n        fs::remove(output_file_path);\n\n        const std::string expected_output = R\"(\nA,B,C,D\n1.0,,3.0,4.0\n2.0,3.0,,5.0\n)\";\n\n        REQUIRE(output_data == expected_output);\n    }\n\n    SECTION(\"Test Case 3\") {\n        const std::string input_data_3 = R\"(\nA\n1\n2\n3\n)\";\n\n        const std::string input_file_path = \"input.csv\";\n        const std::string output_file_path = \"output.csv\";\n\n        // Write input data to a temp CSV file\n        std::ofstream input_file(input_file_path);\n        input_file << input_data_3;\n        input_file.close();\n\n        // Process the CSV\n        process_csv(input_file_path, output_file_path);\n\n        // Read the output\n        std::ifstream output_file(output_file_path);\n        std::stringstream output_stream;\n        output_stream << output_file.rdbuf();\n        std::string output_data = output_stream.str();\n        output_file.close();\n\n        // Clean up temp files\n        fs::remove(input_file_path);\n        fs::remove(output_file_path);\n\n        const std::string expected_output = R\"(\nA\n1\n2\n3\n)\";\n\n        REQUIRE(output_data == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Processes a CSV file and removes rows with two or more empty columns. If the file is empty, returns an empty string.\n *\n * @param file_path The path to the input CSV file.\n * @param output_path The path where the processed CSV file will be saved.\n */\nvoid process_csv(const std::string& file_path, const std::string& output_path){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Processes a CSV file and removes rows with two or more empty columns.\n * If the file is empty, returns an empty string.\n *\n * @param filePath The path to the input CSV file.\n * @param outputPath The path where the processed CSV file will be saved.\n */\npublic static void processCsv(String filePath, String outputPath) {}", "test_code": "package org.real.temp;\n\nimport com.opencsv.CSVReader;\nimport com.opencsv.CSVWriter;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Tester {\n\n    private String inputFilePath;\n    private String outputFilePath;\n\n    @BeforeEach\n    public void setUp() {\n        inputFilePath = \"src/test/resources/input.csv\";\n        outputFilePath = \"src/test/resources/output.csv\";\n    }\n\n    @Test\n    public void testProcessCsv() throws IOException {\n        // Prepare input data\n        File inputFile = new File(inputFilePath);\n        try (CSVWriter writer = new CSVWriter(new FileWriter(inputFile))) {\n            writer.writeNext(new String[]{\"col1\", \"col2\", \"col3\"});\n            writer.writeNext(new String[]{\"value1\", \"\", \"\"});\n            writer.writeNext(new String[]{\"\", \"value2\", \"\"});\n            writer.writeNext(new String[]{\"value3\", \"value4\", \"\"});\n        }\n\n        // Call the method under test\n        ProcessCsv.processCsv(inputFilePath, outputFilePath);\n\n        // Verify the output\n        File outputFile = new File(outputFilePath);\n        assertTrue(outputFile.exists());\n        try (CSVReader reader = new CSVReader(new FileReader(outputFile))) {\n            String[] nextLine;\n            int rowCount = 0;\n            while ((nextLine = reader.readNext()) != null) {\n                rowCount++;\n                if (rowCount == 1) { // Header row\n                    assertEquals(3, nextLine.length);\n                } else { // Data rows\n                    assertNotEquals(\"\", nextLine[0]);\n                    assertNotEquals(\"\", nextLine[1]);\n                    assertNotEquals(\"\", nextLine[2]);\n                }\n            }\n            assertEquals(2, rowCount); // Only two rows should remain after processing\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Processes a CSV file and removes rows with two or more empty columns.\n * If the file is empty, returns an empty string.\n *\n * @param filePath The path to the input CSV file.\n * @param outputPath The path where the processed CSV file will be saved.\n */\npublic static void processCsv(String filePath, String outputPath) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 262, "code_type": "method", "original_language": "python", "file_path": "leetcode_problems\\6ffa50a7ebae1f0ab6092efa49d3839644859510\\avg_binary_tree\\avg_binary_tree.py", "question_type": "Algorithm and data structure", "summary": "Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. ", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef average_of_levels(root: TreeNode) -> List[float]:\n    \"\"\"\n    Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.\n\n    Args:\n        root (TreeNode): The root of the binary tree.\n\n    Returns:\n        List[float]: A list containing the average values of each level.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass TestAverageOfLevels(unittest.TestCase):\n\n    def test_empty_tree(self):\n        root = None\n        expected = []\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_single_node_tree(self):\n        root = TreeNode(5)\n        expected = [5.0]\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_balanced_tree_two_levels(self):\n        root = TreeNode(3)\n        root.left = TreeNode(9)\n        root.right = TreeNode(20)\n        expected = [3.0, 14.5]  # Level 0: 3; Level 1: (9+20)/2 = 14.5\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_unbalanced_tree(self):\n        root = TreeNode(1)\n        root.right = TreeNode(2)\n        root.right.right = TreeNode(3)\n        expected = [1.0, 2.0, 3.0]  # Level 0: 1; Level 1: 2; Level 2: 3\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_tree_multiple_levels(self):\n        root = TreeNode(1)\n        root.left = TreeNode(2)\n        root.right = TreeNode(3)\n        root.left.left = TreeNode(4)\n        root.left.right = TreeNode(5)\n        root.right.right = TreeNode(8)\n        expected = [1.0, 2.5, 5.67]  # Level 0: 1; Level 1: (2+3)/2 = 2.5; Level 2: (4+5+8)/3 \u2248 5.67\n        self.assertAlmostEqual(average_of_levels(root)[2], expected[2], places=2)\n        self.assertEqual(average_of_levels(root)[:2], expected[:2])", "prompt": "please write a python function , the function signature as below from typing import List\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef average_of_levels(root: TreeNode) -> List[float]:\n    \"\"\"\n    Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.\n\n    Args:\n        root (TreeNode): The root of the binary tree.\n\n    Returns:\n        List[float]: A list containing the average values of each level.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\n/**\n * Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.\n *\n * @param root Pointer to the root of the binary tree.\n * @return A vector containing the average values of each level.\n */\nstd::vector<double> average_of_levels(TreeNode* root) {\n\n}", "test_code": "TEST_CASE(\"Test average_of_levels\") {\n    SECTION(\"Empty Tree\") {\n        TreeNode* root = nullptr;\n        std::vector<double> expected = {};\n        REQUIRE(average_of_levels(root) == expected);\n    }\n\n    SECTION(\"Single Node Tree\") {\n        TreeNode* root = new TreeNode(5);\n        std::vector<double> expected = {5.0};\n        REQUIRE(average_of_levels(root) == expected);\n        delete root;\n    }\n\n    SECTION(\"Balanced Tree Two Levels\") {\n        TreeNode* root = new TreeNode(3);\n        root->left = new TreeNode(9);\n        root->right = new TreeNode(20);\n        std::vector<double> expected = {3.0, 14.5};\n        REQUIRE(average_of_levels(root) == expected);\n        delete root->left;\n        delete root->right;\n        delete root;\n    }\n\n    SECTION(\"Unbalanced Tree\") {\n        TreeNode* root = new TreeNode(1);\n        root->right = new TreeNode(2);\n        root->right->right = new TreeNode(3);\n        std::vector<double> expected = {1.0, 2.0, 3.0};\n        REQUIRE(average_of_levels(root) == expected);\n        delete root->right->right;\n        delete root->right;\n        delete root;\n    }\n\n    SECTION(\"Tree Multiple Levels\") {\n        TreeNode* root = new TreeNode(1);\n        root->left = new TreeNode(2);\n        root->right = new TreeNode(3);\n        root->left->left = new TreeNode(4);\n        root->left->right = new TreeNode(5);\n        root->right->right = new TreeNode(8);\n        std::vector<double> expected = {1.0, 2.5, 5.67};\n        auto result = average_of_levels(root);\n        REQUIRE(result.size() == expected.size());\n        REQUIRE_THAT(result[0], Catch::Matchers::WithinAbs(expected[0], 0.01));\n        REQUIRE_THAT(result[1], Catch::Matchers::WithinAbs(expected[1], 0.01));\n        REQUIRE_THAT(result[2], Catch::Matchers::WithinAbs(expected[2], 0.01));\n        delete root->left->left;\n        delete root->left->right;\n        delete root->right->right;\n        delete root->left;\n        delete root->right;\n        delete root;\n    }\n}", "prompt": "please write a cpp function , the function signature as below \nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\n/**\n * Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.\n *\n * @param root Pointer to the root of the binary tree.\n * @return A vector containing the average values of each level.\n */\nstd::vector<double> average_of_levels(TreeNode* root) {\n\n}", "addition_info": "\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n"}, "java": {"code_signature": "\n/**\n * Calculates the average value of nodes at each level in a binary tree.\n *\n * @param root The root of the binary tree.\n * @return A list containing the average values of each level.\n */\npublic static List<Double> averageOfLevels(TreeNode root) {\n\n}", "test_code": "import org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testAverageOfLevels() {\n        // Create a sample binary tree\n        TreeNode root = new TreeNode(3);\n        root.left = new TreeNode(9);\n        root.right = new TreeNode(20);\n        root.right.left = new TreeNode(15);\n        root.right.right = new TreeNode(7);\n\n        // Expected result\n        List<Double> expected = Arrays.asList(3.0, 14.5, 11.0);\n\n        // Actual result\n        List<Double> actual = BinaryTreeUtil.averageOfLevels(root);\n\n        // Assert the results\n        assertEquals(expected, actual);\n    }\n}", "prompt": "please write a java function , the function signature as below \n/**\n * Calculates the average value of nodes at each level in a binary tree.\n *\n * @param root The root of the binary tree.\n * @return A list containing the average values of each level.\n */\npublic static List<Double> averageOfLevels(TreeNode root) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 263, "code_type": "method", "original_language": "python", "file_path": "leetcode_problems\\2c1d6ebdef1030b7793d957291fcebb771480477\\spiral_matrix\\optimized_with_ai.py", "question_type": "Data processing and transformation", "summary": "Please write a function that traverses a two-dimensional matrix in spiral order and returns a list of the elements of the traversal result", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\nclass MatrixTraversal:\n    def spiral_traversal(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Traverse a given m x n matrix in a spiral order and return all elements as a list.\n\n        The function starts at the top-left corner of the matrix and traverses it in a\n        clockwise spiral order, moving right across the top row, down the right column,\n        left across the bottom row, and up the left column, repeating this process\n        until all elements are traversed.\n\n        Args:\n            matrix (List[List[int]]): A 2D list representing the matrix with m rows and n columns.\n\n        Returns:\n            List[int]: A list of integers representing the elements of the matrix\n            in the order they were traversed.\n        \"\"\"", "test_code": "import unittest\n\nclass TestMatrixTraversal(unittest.TestCase):\n    def setUp(self):\n        self.mt = MatrixTraversal()\n\n    def test_empty_matrix(self):\n        # \u5f02\u5e38\u503c\u6d4b\u8bd5\uff1a\u7a7a\u77e9\u9635\n        self.assertEqual(self.mt.spiral_traversal([]), [], \"Should return an empty list for an empty matrix\")\n\n    def test_single_element_matrix(self):\n        # \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u5355\u5143\u7d20\u77e9\u9635\n        matrix = [[42]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [42], \"Should return the single element in the matrix\")\n\n    def test_single_row_matrix(self):\n        # \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u884c\u77e9\u9635\n        matrix = [[1, 2, 3, 4, 5]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [1, 2, 3, 4, 5], \"Should return all elements in a single row\")\n\n    def test_single_column_matrix(self):\n        # \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u5217\u77e9\u9635\n        matrix = [[1], [2], [3], [4], [5]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [1, 2, 3, 4, 5], \"Should return all elements in a single column\")\n\n    def test_general_case(self):\n        # \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u591a\u884c\u591a\u5217\u77e9\u9635\n        matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [1, 2, 3, 6, 9, 8, 7, 4, 5], \"Should return elements in spiral order for a general case matrix\")\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\nclass MatrixTraversal:\n    def spiral_traversal(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Traverse a given m x n matrix in a spiral order and return all elements as a list.\n\n        The function starts at the top-left corner of the matrix and traverses it in a\n        clockwise spiral order, moving right across the top row, down the right column,\n        left across the bottom row, and up the left column, repeating this process\n        until all elements are traversed.\n\n        Args:\n            matrix (List[List[int]]): A 2D list representing the matrix with m rows and n columns.\n\n        Returns:\n            List[int]: A list of integers representing the elements of the matrix\n            in the order they were traversed.\n        \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Traverse a given m x n matrix in a spiral order and return all elements as a vector.\n *\n *\n * @param matrix A 2D vector representing the matrix with m rows and n columns.\n * @return A vector of integers representing the elements of the matrix\n *         in the order they were traversed.\n */\nvector<int> spiral_traverse(const vector<vector<int>>& matrix) {}", "test_code": "TEST_CASE(\"TestMatrixTraversal\", \"[MatrixTraversal]\") {\n    MatrixTraversal mt;\n\n    SECTION(\"Empty matrix\") {\n        // \u5f02\u5e38\u503c\u6d4b\u8bd5\uff1a\u7a7a\u77e9\u9635\n        REQUIRE(spiral_traversal({}) == std::vector<int>{});\n    }\n\n    SECTION(\"Single element matrix\") {\n        // \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u5355\u5143\u7d20\u77e9\u9635\n        std::vector<std::vector<int>> matrix = {{42}};\n        REQUIRE(spiral_traversal(matrix) == std::vector<int>{42});\n    }\n\n    SECTION(\"Single row matrix\") {\n        // \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u884c\u77e9\u9635\n        std::vector<std::vector<int>> matrix = {{1, 2, 3, 4, 5}};\n        REQUIRE(spiral_traversal(matrix) == std::vector<int>{1, 2, 3, 4, 5});\n    }\n\n    SECTION(\"Single column matrix\") {\n        // \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u5217\u77e9\u9635\n        std::vector<std::vector<int>> matrix = {{1}, {2}, {3}, {4}, {5}};\n        REQUIRE(spiral_traversal(matrix) == std::vector<int>{1, 2, 3, 4, 5});\n    }\n\n    SECTION(\"General case\") {\n        // \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u591a\u884c\u591a\u5217\u77e9\u9635\n        std::vector<std::vector<int>> matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        REQUIRE(spiral_traversal(matrix) == std::vector<int>{1, 2, 3, 6, 9, 8, 7, 4, 5});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Traverse a given m x n matrix in a spiral order and return all elements as a vector.\n *\n *\n * @param matrix A 2D vector representing the matrix with m rows and n columns.\n * @return A vector of integers representing the elements of the matrix\n *         in the order they were traversed.\n */\nvector<int> spiral_traverse(const vector<vector<int>>& matrix) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Traverses a given m x n matrix in a spiral order and returns all elements as a list.\n *\n * The method starts at the top-left corner of the matrix and traverses it in a\n * clockwise spiral order, moving right across the top row, down the right column,\n * left across the bottom row, and up the left column, repeating this process\n * until all elements are traversed.\n *\n * @param matrix A 2D array representing the matrix with m rows and n columns.\n * @return A list of integers representing the elements of the matrix\n *         in the order they were traversed.\n */\npublic List<Integer> spiralTraversal(int[][] matrix) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testSpiralTraversal() {\n        MatrixTraversal traversal = new MatrixTraversal();\n\n        int[][] matrix1 = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n        assertEquals(List.of(1, 2, 3, 6, 9, 8, 7, 4, 5), traversal.spiralTraversal(matrix1));\n\n        int[][] matrix2 = {\n            {1, 2, 3, 4},\n            {5, 6, 7, 8},\n            {9, 10, 11, 12}\n        };\n        assertEquals(List.of(1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7), traversal.spiralTraversal(matrix2));\n\n        int[][] matrix3 = {\n            {1}\n        };\n        assertEquals(List.of(1), traversal.spiralTraversal(matrix3));\n\n        int[][] matrix4 = {};\n        assertEquals(List.of(), traversal.spiralTraversal(matrix4));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Traverses a given m x n matrix in a spiral order and returns all elements as a list.\n *\n * The method starts at the top-left corner of the matrix and traverses it in a\n * clockwise spiral order, moving right across the top row, down the right column,\n * left across the bottom row, and up the left column, repeating this process\n * until all elements are traversed.\n *\n * @param matrix A 2D array representing the matrix with m rows and n columns.\n * @return A list of integers representing the elements of the matrix\n *         in the order they were traversed.\n */\npublic List<Integer> spiralTraversal(int[][] matrix) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 264, "code_type": "method", "original_language": "python", "file_path": "PythonCollection\\454a4924cd2db9a101283c1c21b2ae7631220ea2\\clearTypo3Log.py", "question_type": "File operations and I/O operation", "summary": "extract log entries at the WARNING, ERROR, CRITICAL, and ALERT levels from a log file and save the log entries at each level to a different file\n", "language_version_list": {"python": {"code_signature": "def extract_log_entries(log_file_path:str):\n    \"\"\"\n    Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n    and save each type of log entry to a different file.\n\n    Args:\n        log_file_path: Path to the log file.\n\n    Returns:\n\n    \"\"\"\n\n\n    \"\"\"\n    Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n    and save each type of log entry to a different file.\n\n    Args:\n    log_file_path (str): Path to the log file.\n    \"\"\"", "test_code": "import unittest\nimport os\n\n\nclass TestExtractLogEntries(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Setup a temporary log file with sample question for testing.\"\"\"\n        self.log_file_path = 'test_log.log'\n        self.log_contents = [\n            \"INFO: This is an informational message.\\n\",\n            \"WARNING: This is a warning message.\\n\",\n            \"ERROR: This is an error message.\\n\",\n            \"CRITICAL: This is a critical message.\\n\",\n            \"ALERT: This is an alert message.\\n\"\n        ]\n        with open(self.log_file_path, 'w') as log_file:\n            log_file.writelines(self.log_contents)\n\n\n\n    def test_no_logs_of_certain_levels(self):\n        \"\"\"Test the situation where there are no log entries for one or more levels.\"\"\"\n        with open(self.log_file_path, 'w') as log_file:\n            log_file.write(\"INFO: This is another informational message.\\n\")\n        extract_log_entries(self.log_file_path)\n        for level in ['WARNING', 'ERROR', 'CRITICAL', 'ALERT']:\n            with open(f\"{level.lower()}_logs.txt\", 'r') as file:\n                self.assertEqual('', file.read())\n\n    def test_file_not_found(self):\n        \"\"\"Test behavior when the log file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            extract_log_entries(\"nonexistent.log\")\n\n    def test_empty_log_file(self):\n        \"\"\"Test behavior with an empty log file.\"\"\"\n        with open(self.log_file_path, 'w') as log_file:\n            log_file.write(\"\")\n        extract_log_entries(self.log_file_path)\n        for level in ['WARNING', 'ERROR', 'CRITICAL', 'ALERT']:\n            with open(f\"{level.lower()}_logs.txt\", 'r') as file:\n                self.assertEqual('', file.read())\n\n    def test_mixed_content_log_file(self):\n        \"\"\"Test extracting logs from a file with mixed content.\"\"\"\n        with open(self.log_file_path, 'w') as log_file:\n            log_file.writelines([\n                \"INFO: Some info.\\n\",\n                \"WARNING: Watch out!\\n\",\n                \"DEBUG: Debugging.\\n\",\n                \"ERROR: Oops!\\n\",\n                \"CRITICAL: Failed badly.\\n\",\n                \"ALERT: High alert!\\n\",\n                \"INFO: More info.\\n\"\n            ])\n        extract_log_entries(self.log_file_path)\n        for level in ['WARNING', 'ERROR', 'CRITICAL', 'ALERT']:\n            with open(f\"{level.lower()}_logs.txt\", 'r') as file:\n                content = file.read().strip()\n                self.assertIn(level, content)\n", "prompt": "please write a python function , the function signature as below def extract_log_entries(log_file_path:str):\n    \"\"\"\n    Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n    and save each type of log entry to a different file.\n\n    Args:\n        log_file_path: Path to the log file.\n\n    Returns:\n\n    \"\"\"\n\n\n    \"\"\"\n    Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n    and save each type of log entry to a different file.\n\n    Args:\n    log_file_path (str): Path to the log file.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n * and save each type of log entry to a different file.\n *\n * @param logFilePath The path to the log file.\n */\nvoid extract_log_entries(const std::string& log_file_path) {}", "test_code": "TEST_CASE(\"TestExtractLogEntries\", \"[log]\") {\n    const std::string log_file_path = \"test_log.log\";\n\n    SECTION(\"setUp\") {\n        std::vector<std::string> log_contents = {\n            \"INFO: This is an informational message.\\n\",\n            \"WARNING: This is a warning message.\\n\",\n            \"ERROR: This is an error message.\\n\",\n            \"CRITICAL: This is a critical message.\\n\",\n            \"ALERT: This is an alert message.\\n\"\n        };\n        std::ofstream log_file(log_file_path);\n        if (!log_file.is_open()) {\n            FAIL(\"Failed to create the log file.\");\n        }\n        log_file << std::string(log_contents.begin(), log_contents.end());\n        log_file.close();\n    }\n\n    SECTION(\"test_no_logs_of_certain_levels\") {\n        std::ofstream log_file(log_file_path);\n        if (!log_file.is_open()) {\n            FAIL(\"Failed to create the log file.\");\n        }\n        log_file << \"INFO: This is another informational message.\\n\";\n        log_file.close();\n\n        extract_log_entries(log_file_path);\n\n        for (const auto& level : {\"WARNING\", \"ERROR\", \"CRITICAL\", \"ALERT\"}) {\n            std::ifstream outfile(level + \"_logs.txt\");\n            if (!outfile.is_open()) {\n                FAIL(\"Failed to open the output file: \" + level + \"_logs.txt\");\n            }\n            std::string content((std::istreambuf_iterator<char>(outfile)), std::istreambuf_iterator<char>());\n            REQUIRE(content.empty());\n        }\n    }\n\n    SECTION(\"test_file_not_found\") {\n        extract_log_entries(\"nonexistent.log\");\n        for (const auto& level : {\"WARNING\", \"ERROR\", \"CRITICAL\", \"ALERT\"}) {\n            std::ifstream outfile(level + \"_logs.txt\");\n            if (!outfile.is_open()) {\n                FAIL(\"Failed to open the output file: \" + level + \"_logs.txt\");\n            }\n            std::string content((std::istreambuf_iterator<char>(outfile)), std::istreambuf_iterator<char>());\n            REQUIRE(content.empty());\n        }\n    }\n\n    SECTION(\"test_empty_log_file\") {\n        std::ofstream log_file(log_file_path);\n        if (!log_file.is_open()) {\n            FAIL(\"Failed to create the log file.\");\n        }\n        log_file.close();\n\n        extract_log_entries(log_file_path);\n\n        for (const auto& level : {\"WARNING\", \"ERROR\", \"CRITICAL\", \"ALERT\"}) {\n            std::ifstream outfile(level + \"_logs.txt\");\n            if (!outfile.is_open()) {\n                FAIL(\"Failed to open the output file: \" + level + \"_logs.txt\");\n            }\n            std::string content((std::istreambuf_iterator<char>(outfile)), std::istreambuf_iterator<char>());\n            REQUIRE(content.empty());\n        }\n    }\n\n    SECTION(\"test_mixed_content_log_file\") {\n        std::ofstream log_file(log_file_path);\n        if (!log_file.is_open()) {\n            FAIL(\"Failed to create the log file.\");\n        }\n        log_file << \"INFO: Some info.\\n\"\n                 << \"WARNING: Watch out!\\n\"\n                 << \"DEBUG: Debugging.\\n\"\n                 << \"ERROR: Oops!\\n\"\n                 << \"CRITICAL: Failed badly.\\n\"\n                 << \"ALERT: High alert!\\n\"\n                 << \"INFO: More info.\\n\";\n        log_file.close();\n\n        extract_log_entries(log_file_path);\n\n        for (const auto& level : {\"WARNING\", \"ERROR\", \"CRITICAL\", \"ALERT\"}) {\n            std::ifstream outfile(level + \"_logs.txt\");\n            if (!outfile.is_open()) {\n                FAIL(\"Failed to open the output file: \" + level + \"_logs.txt\");\n            }\n            std::string content((std::istreambuf_iterator<char>(outfile)), std::istreambuf_iterator<char>());\n            REQUIRE(content.find(level) != std::string::npos);\n        }\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n * and save each type of log entry to a different file.\n *\n * @param logFilePath The path to the log file.\n */\nvoid extract_log_entries(const std::string& log_file_path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Extracts log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n * and saves each type of log entry to a different file.\n *\n * @param logFilePath The path to the log file.\n * @throws IOException If an I/O error occurs.\n */\npublic static void extractLogEntries(String logFilePath) throws IOException {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    private LogFileProcessor logFileProcessor;\n\n    @BeforeEach\n    public void setUp() {\n        // Initialize any necessary objects or resources here\n        logFileProcessor = new LogFileProcessor();\n    }\n\n    @Test\n    public void testExtractLogEntries_Warning() {\n        // Arrange\n        String logFilePath = \"path/to/your/logfile.log\";\n        String expectedWarningOutputPath = \"path/to/expected/warnings.txt\";\n\n        // Act\n        logFileProcessor.extractLogEntries(logFilePath);\n\n        // Assert\n        assertTrue(new File(expectedWarningOutputPath).exists());\n    }\n\n    @Test\n    public void testExtractLogEntries_Error() {\n        // Arrange\n        String logFilePath = \"path/to/your/logfile.log\";\n        String expectedErrorOutputPath = \"path/to/expected/errors.txt\";\n\n        // Act\n        logFileProcessor.extractLogEntries(logFilePath);\n\n        // Assert\n        assertTrue(new File(expectedErrorOutputPath).exists());\n    }\n\n    @Test\n    public void testExtractLogEntries_Critical() {\n        // Arrange\n        String logFilePath = \"path/to/your/logfile.log\";\n        String expectedCriticalOutputPath = \"path/to/expected/criticals.txt\";\n\n        // Act\n        logFileProcessor.extractLogEntries(logFilePath);\n\n        // Assert\n        assertTrue(new File(expectedCriticalOutputPath).exists());\n    }\n\n    @Test\n    public void testExtractLogEntries_Alert() {\n        // Arrange\n        String logFilePath = \"path/to/your/logfile.log\";\n        String expectedAlertOutputPath = \"path/to/expected/alerts.txt\";\n\n        // Act\n        logFileProcessor.extractLogEntries(logFilePath);\n\n        // Assert\n        assertTrue(new File(expectedAlertOutputPath).exists());\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n * and saves each type of log entry to a different file.\n *\n * @param logFilePath The path to the log file.\n * @throws IOException If an I/O error occurs.\n */\npublic static void extractLogEntries(String logFilePath) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 266, "code_type": "method", "original_language": "python", "file_path": "ot-harjoitustyo\\037f762749a5c7dfde328c37e42e1d9901177020\\src\\utils\\utils.py", "question_type": "Data processing and transformation", "summary": "Handle nested data structures (e.g., dictionaries, lists, and enumerations), decode bytes to UTF8-strings, and convert numbers to integers or floating point numbers", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef handle_nested_data(data: Dict) -> Dict:\n    \"\"\"\n    handle nested question structures (e.g., dictionaries, lists, and enumerations), decode bytes to UTF8-strings, and convert numbers to integers or floating point numbers\n    Args:\n        data (Dict): question object\n\n    Returns:\n        after converted question\n    \"\"\"\n", "test_code": "import unittest\nfrom enum import Enum\nfrom numbers import Number\n\n\nclass TestHandleNestedData(unittest.TestCase):\n    def test_simple_dictionary(self):\n        data = {\"name\": b\"Alice\", \"age\": \"30\"}\n        expected = {\"name\": \"Alice\", \"age\": 30}\n        self.assertEqual(handle_nested_data(data), expected)\n\n    def test_nested_dictionary(self):\n        data = {\"user\": {\"name\": b\"Bob\", \"details\": {\"age\": \"25\", \"height\": \"175.5\"}}}\n        expected = {\"user\": {\"name\": \"Bob\", \"details\": {\"age\": 25, \"height\": 175.5}}}\n        self.assertEqual(handle_nested_data(data), expected)\n\n    def test_list_of_mixed_data_types(self):\n        data = [\"100\", b\"200\", 300.0, \"400.5\"]\n        expected = [100, \"200\", 300.0, 400.5]\n        self.assertEqual(handle_nested_data(data), expected)\n\n    def test_incorrect_byte_decoding(self):\n        data = {\"invalid_bytes\": b\"\\xff\\xfe\\xfd\\xfc\"}\n        with self.assertRaises(UnicodeDecodeError):\n            handle_nested_data(data)\n\n    def test_complex_nested_structure(self):\n        data = {\n            \"team\": [\n                {\"name\": b\"Charlie\", \"scores\": [\"1000\", \"2000.2\"]},\n                {\"name\": b\"Daisy\", \"skills\": [b\"Coding\", \"Design\"], \"age\": \"22\"}\n            ]\n        }\n        expected = {\n            \"team\": [\n                {\"name\": \"Charlie\", \"scores\": [1000, 2000.2]},\n                {\"name\": \"Daisy\", \"skills\": [\"Coding\", \"Design\"], \"age\": 22}\n            ]\n        }\n        self.assertEqual(handle_nested_data(data), expected)", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef handle_nested_data(data: Dict) -> Dict:\n    \"\"\"\n    handle nested question structures (e.g., dictionaries, lists, and enumerations), decode bytes to UTF8-strings, and convert numbers to integers or floating point numbers\n    Args:\n        data (Dict): question object\n\n    Returns:\n        after converted question\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Handle nested question structures (e.g., maps, vectors, strings, ints, doubles), decode bytes to UTF8-strings, and convert numbers to integers or floating point numbers\n * \n * @param std::map<std::string, VarType> question object\n * @return: after converted question\n */\nstd::map<std::string, VarType> handle_nested_data(std::map<std::string, VarType> data) {}", "test_code": "TEST_CASE(\"Test handle_nested_data function\") {\n    SECTION(\"Simple dictionary\") {\n        std::map<std::string, VarType> data = {{\"name\", std::string(\"Alice\", 5)}, {\"age\", \"30\"}};\n        std::map<std::string, VarType> expected = {{\"name\", \"Alice\"}, {\"age\", 30}};\n        REQUIRE(handle_nested_data(data) == expected);\n    }\n\n    SECTION(\"Nested dictionary\") {\n        std::map<std::string, VarType> nestedData = {\n            {\"user\", std::map<std::string, VarType>{{\"name\", std::string(\"Bob\", 3)}, {\"details\", std::map<std::string, VarType>{{\"age\", \"25\"}, {\"height\", \"175.5\"}}}}}\n        };\n        std::map<std::string, VarType> expected = {\n            {\"user\", std::map<std::string, VarType>{{\"name\", \"Bob\"}, {\"details\", std::map<std::string, VarType>{{\"age\", 25}, {\"height\", 175.5}}}}}\n        };\n        REQUIRE(handle_nested_data(nestedData) == expected);\n    }\n\n    SECTION(\"List of mixed data types\") {\n        std::vector<VarType> data = {\"100\", std::string(\"200\", 3), 300.0, \"400.5\"};\n        std::vector<VarType> expected = {100, std::string(\"200\", 3), 300.0, 400.5};\n        REQUIRE(handle_nested_data(data) == expected);\n    }\n\n    SECTION(\"Incorrect byte decoding\") {\n        std::map<std::string, VarType> data = {{\"invalid_bytes\", std::string(\"\\xff\\xfe\\xfd\\xfc\", 4)}};\n        REQUIRE_THROWS_AS(handle_nested_data(data), std::invalid_argument);\n    }\n\n    SECTION(\"Complex nested structure\") {\n        std::map<std::string, VarType> data = {\n            {\"team\", std::vector<VarType>{\n                std::map<std::string, VarType>{{\"name\", std::string(\"Charlie\", 7)}, {\"scores\", std::vector<VarType>{\"1000\", \"2000.2\"}}},\n                std::map<std::string, VarType>{{\"name\", std::string(\"Daisy\", 5)}, {\"skills\", std::vector<VarType>{std::string(\"Coding\", 6), \"Design\"}}, {\"age\", \"22\"}}\n            }}\n        };\n        std::map<std::string, VarType> expected = {\n            {\"team\", std::vector<VarType>{\n                std::map<std::string, VarType>{{\"name\", \"Charlie\"}, {\"scores\", std::vector<VarType>{1000, 2000.2}}},\n                std::map<std::string, VarType>{{\"name\", \"Daisy\"}, {\"skills\", std::vector<VarType>{\"Coding\", \"Design\"}}, {\"age\", 22}}\n            }}\n        };\n        REQUIRE(handle_nested_data(data) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Handle nested question structures (e.g., maps, vectors, strings, ints, doubles), decode bytes to UTF8-strings, and convert numbers to integers or floating point numbers\n * \n * @param std::map<std::string, VarType> question object\n * @return: after converted question\n */\nstd::map<std::string, VarType> handle_nested_data(std::map<std::string, VarType> data) {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 267, "code_type": "method", "original_language": "python", "file_path": "ot-harjoitustyo\\037f762749a5c7dfde328c37e42e1d9901177020\\src\\utils\\utils.py", "question_type": "Algorithm and data structure", "summary": "extract the second-level and top-level domain names from the fully qualified domain name FQDN and return them\n", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef extract_sld_tld(fqdn: str) -> Tuple[str, str]:\n    \"\"\"\n    extract the second-level and top-level domain names from the fully qualified domain name FQDN and return them\n    Args:\n        fqdn (str): The fully qualified domain name.\n\n    Returns:\n        A tuple containing the second-level domain and top-level domain.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestExtractSldTld(unittest.TestCase):\n    def test_standard_fqdn(self):\n        # Test a typical FQDN\n        self.assertEqual(extract_sld_tld(\"www.example.com\"), (\"example\", \"com\"))\n\n    def test_standard_fqdn2(self):\n        # Test a typical FQDN\n        self.assertEqual(extract_sld_tld(\"www.example.xyz\"), (\"example\", \"xyz\"))\n\n    def test_fqdn_with_subdomains(self):\n        # Test an FQDN with multiple subdomains\n        self.assertEqual(extract_sld_tld(\"blog.subdomain.example.com\"), (\"example\", \"com\"))\n\n    def test_numeric_tld(self):\n        # Test a numeric TLD, which can occur in private networks\n        self.assertEqual(extract_sld_tld(\"server.example.123\"), (\"example\", \"123\"))\n", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef extract_sld_tld(fqdn: str) -> Tuple[str, str]:\n    \"\"\"\n    extract the second-level and top-level domain names from the fully qualified domain name FQDN and return them\n    Args:\n        fqdn (str): The fully qualified domain name.\n\n    Returns:\n        A tuple containing the second-level domain and top-level domain.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extracts the second-level and top-level domain names from the fully qualified domain name (FQDN).\n *\n * @param fqdn The fully qualified domain name.\n * @return A tuple containing the second-level domain and top-level domain.\n */\nstd::tuple<std::string, std::string> extract_sld_tld(const std::string& fqdn){\n\n}", "test_code": "TEST_CASE(\"Test extract_sld_tld function\") {\n    SECTION(\"Test a typical FQDN\") {\n        REQUIRE(extract_sld_tld(\"www.example.com\") == std::make_pair(\"example\", \"com\"));\n    }\n\n    SECTION(\"Test another typical FQDN\") {\n        REQUIRE(extract_sld_tld(\"www.example.xyz\") == std::make_pair(\"example\", \"xyz\"));\n    }\n\n    SECTION(\"Test an FQDN with multiple subdomains\") {\n        REQUIRE(extract_sld_tld(\"blog.subdomain.example.com\") == std::make_pair(\"example\", \"com\"));\n    }\n\n    SECTION(\"Test a numeric TLD\") {\n        REQUIRE(extract_sld_tld(\"server.example.123\") == std::make_pair(\"example\", \"123\"));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts the second-level and top-level domain names from the fully qualified domain name (FQDN).\n *\n * @param fqdn The fully qualified domain name.\n * @return A tuple containing the second-level domain and top-level domain.\n */\nstd::tuple<std::string, std::string> extract_sld_tld(const std::string& fqdn){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Extracts the second-level domain (SLD) and top-level domain (TLD) from a fully qualified domain name (FQDN).\n * \n * @param fqdn The fully qualified domain name.\n * @return A pair containing the second-level domain and top-level domain.\n * @throws IllegalArgumentException if the provided FQDN does not contain enough parts to extract SLD and TLD.\n */\npublic static SimpleEntry<String, String> extractSldTld(String fqdn) {}", "test_code": "package org.real.temp;\n\nimport junit.framework.TestCase;\n\npublic class Tester extends TestCase {\n\n    public void testExtractSldTld() {\n        String fqdn = \"example.com\";\n        String[] result = DomainNameExtractor.extractSldTld(fqdn);\n        assertEquals(\"example\", result[0]);\n        assertEquals(\"com\", result[1]);\n\n        fqdn = \"sub.example.co.uk\";\n        result = DomainNameExtractor.extractSldTld(fqdn);\n        assertEquals(\"example\", result[0]);\n        assertEquals(\"co.uk\", result[1]);\n    }\n\n    public void testInvalidFQDN() {\n        try {\n            DomainNameExtractor.extractSldTld(\"invalid\");\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // Expected exception\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts the second-level domain (SLD) and top-level domain (TLD) from a fully qualified domain name (FQDN).\n * \n * @param fqdn The fully qualified domain name.\n * @return A pair containing the second-level domain and top-level domain.\n * @throws IllegalArgumentException if the provided FQDN does not contain enough parts to extract SLD and TLD.\n */\npublic static SimpleEntry<String, String> extractSldTld(String fqdn) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 268, "code_type": "method", "original_language": "python", "file_path": "leetcode_problems\\fb16642c3e03da8209e860c644c6e7a3f165f34a\\gas_station\\gas_station.py\n", "question_type": "Algorithm and data structure", "summary": "There are n gas stations along a circular route,\nwhere the amount of gas at the ith station is gas[i].\n\nYou have a car with an unlimited gas tank and\nit costs cost[i] of gas to travel from the ith station to its next (i + 1)th station.\nYou begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays gas and cost,\nreturn the starting gas station's index \nif you can travel around the circuit once in the clockwise direction,\notherwise return -1. If there exists a solution, it is guaranteed to be unique ", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -> int:\n    \"\"\"\n    Determines if there exists a starting gas station's index where you can travel\n    around the circuit once in a clockwise direction.\n\n    Args:\n        gas (List[int]): List of integers representing the amount of gas at each station.\n        cost (List[int]): List of integers representing the cost of gas to travel from each station to the next.\n\n    Returns:\n        int: The starting gas station's index if the circuit can be completed, otherwise -1.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCanCompleteCircuit(unittest.TestCase):\n\n    def test_possible_single_station(self):\n        gas = [5]\n        cost = [4]\n        expected = 0\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_impossible_single_station(self):\n        gas = [4]\n        cost = [5]\n        expected = -1\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_two_stations_possible(self):\n        gas = [1, 2]\n        cost = [2, 1]\n        expected = 1\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_circular_route_possible(self):\n        gas = [1, 2, 3, 4, 5]\n        cost = [3, 4, 5, 1, 2]\n        expected = 3\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_circular_route_impossible(self):\n        gas = [2, 3, 4]\n        cost = [3, 4, 3]\n        expected = -1\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -> int:\n    \"\"\"\n    Determines if there exists a starting gas station's index where you can travel\n    around the circuit once in a clockwise direction.\n\n    Args:\n        gas (List[int]): List of integers representing the amount of gas at each station.\n        cost (List[int]): List of integers representing the cost of gas to travel from each station to the next.\n\n    Returns:\n        int: The starting gas station's index if the circuit can be completed, otherwise -1.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Determines if there exists a starting gas station's index where you can travel\n * around the circuit once in a clockwise direction.\n *\n * @param gas A vector of integers representing the amount of gas at each station.\n * @param cost A vector of integers representing the cost of gas to travel from each station to the next.\n * @return The starting gas station's index if the circuit can be completed, otherwise -1.\n */\nint canCompleteCircuit(const std::vector<int>& gas, const std::vector<int>& cost) {\n\n}", "test_code": "TEST_CASE(\"Test possible single station\", \"[canCompleteCircuit]\") {\n    std::vector<int> gas = {5};\n    std::vector<int> cost = {4};\n    int expected = 0;\n    REQUIRE(canCompleteCircuit(gas, cost) == expected);\n}\n\nTEST_CASE(\"Test impossible single station\", \"[canCompleteCircuit]\") {\n    std::vector<int> gas = {4};\n    std::vector<int> cost = {5};\n    int expected = -1;\n    REQUIRE(canCompleteCircuit(gas, cost) == expected);\n}\n\nTEST_CASE(\"Test two stations possible\", \"[canCompleteCircuit]\") {\n    std::vector<int> gas = {1, 2};\n    std::vector<int> cost = {2, 1};\n    int expected = 1;\n    REQUIRE(canCompleteCircuit(gas, cost) == expected);\n}\n\nTEST_CASE(\"Test circular route possible\", \"[canCompleteCircuit]\") {\n    std::vector<int> gas = {1, 2, 3, 4, 5};\n    std::vector<int> cost = {3, 4, 5, 1, 2};\n    int expected = 3;\n    REQUIRE(canCompleteCircuit(gas, cost) == expected);\n}\n\nTEST_CASE(\"Test circular route impossible\", \"[canCompleteCircuit]\") {\n    std::vector<int> gas = {2, 3, 4};\n    std::vector<int> cost = {3, 4, 3};\n    int expected = -1;\n    REQUIRE(canCompleteCircuit(gas, cost) == expected);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Determines if there exists a starting gas station's index where you can travel\n * around the circuit once in a clockwise direction.\n *\n * @param gas A vector of integers representing the amount of gas at each station.\n * @param cost A vector of integers representing the cost of gas to travel from each station to the next.\n * @return The starting gas station's index if the circuit can be completed, otherwise -1.\n */\nint canCompleteCircuit(const std::vector<int>& gas, const std::vector<int>& cost) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Determines if there exists a starting gas station's index where you can travel\n * around the circuit once in a clockwise direction.\n *\n * @param gas List of integers representing the amount of gas at each station.\n * @param cost List of integers representing the cost of gas to travel from each station to the next.\n * @return The starting gas station's index if the circuit can be completed, otherwise -1.\n */\npublic static int canCompleteCircuit(List<Integer> gas, List<Integer> cost) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testCanCompleteCircuit() {\n        // Test case 1\n        int[] gas1 = {1, 2, 3, 4, 5};\n        int[] cost1 = {3, 4, 5, 1, 2};\n        assertEquals(3, canCompleteCircuit(gas1, cost1));\n\n        // Test case 2\n        int[] gas2 = {2, 3, 4};\n        int[] cost2 = {3, 4, 3};\n        assertEquals(-1, canCompleteCircuit(gas2, cost2));\n    }\n\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int totalGas = 0;\n        int currentGas = 0;\n        int startStation = 0;\n\n        for (int i = 0; i < gas.length; i++) {\n            totalGas += gas[i] - cost[i];\n            currentGas += gas[i] - cost[i];\n\n            if (currentGas < 0) {\n                startStation = i + 1;\n                currentGas = 0;\n            }\n        }\n\n        return totalGas >= 0 ? startStation : -1;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Determines if there exists a starting gas station's index where you can travel\n * around the circuit once in a clockwise direction.\n *\n * @param gas List of integers representing the amount of gas at each station.\n * @param cost List of integers representing the cost of gas to travel from each station to the next.\n * @return The starting gas station's index if the circuit can be completed, otherwise -1.\n */\npublic static int canCompleteCircuit(List<Integer> gas, List<Integer> cost) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 269, "code_type": "method", "original_language": "python", "file_path": "CLICK_PLC_Tools\\8438dcba5d7b5885d52f4ec8a3a34694399e7fed\\clicksploit.py", "question_type": "Network requests and API call", "summary": "checks whether a string is compliant IP\n", "language_version_list": {"python": {"code_signature": "def is_compliant_ip(ip: str) -> bool:\n    \"\"\"\n    Check whether the IP address is a legal IP address.\n\n    Args:\n        ip (str): The IP address in string format.\n\n    Returns:\n        bool: True if the IP is compliant, False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestIsCompliantIP(unittest.TestCase):\n    def test_private_ip(self):\n        # Test that private IPs return True\n        self.assertTrue(is_compliant_ip('192.168.1.1'))\n\n    def test_public_ip(self):\n        # Test that public IPs return False\n        self.assertTrue(is_compliant_ip('8.8.8.8'))\n\n    def test_invalid_ip(self):\n        # Test that invalid IP strings return False\n        self.assertFalse(is_compliant_ip('999.999.999.999'))\n", "prompt": "please write a python function , the function signature as below def is_compliant_ip(ip: str) -> bool:\n    \"\"\"\n    Check whether the IP address is a legal IP address.\n\n    Args:\n        ip (str): The IP address in string format.\n\n    Returns:\n        bool: True if the IP is compliant, False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Check whether the IP address is a legal IP address.\n *\n * @param ip The IP address in string format.\n * @return True if the IP is compliant, False otherwise.\n */\nbool is_compliant_ip(const std::string& ip){\n\n}", "test_code": "TEST_CASE(\"Test IsCompliantIP\", \"[is_compliant_ip]\") {\n    SECTION(\"Private IP\") {\n        // Test that private IPs return True\n        REQUIRE(is_compliant_ip(\"192.168.1.1\"));\n    }\n\n    SECTION(\"Public IP\") {\n        // Test that public IPs return False\n        REQUIRE_FALSE(is_compliant_ip(\"8.8.8.8\"));\n    }\n\n    SECTION(\"Invalid IP\") {\n        // Test that invalid IP strings return False\n        REQUIRE_FALSE(is_compliant_ip(\"999.999.999.999\"));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Check whether the IP address is a legal IP address.\n *\n * @param ip The IP address in string format.\n * @return True if the IP is compliant, False otherwise.\n */\nbool is_compliant_ip(const std::string& ip){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks whether the given IP address is a legal IP address.\n *\n * @param ip The IP address in string format.\n * @return true if the IP is compliant, false otherwise.\n */\npublic static boolean isCompliantIP(String ip) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class TesterTest {\n\n    @Test\n    public void testIsCompliantIpValid() {\n        assertTrue(Tester.isCompliantIp(\"192.168.1.1\"));\n    }\n\n    @Test\n    public void testIsCompliantIpInvalid() {\n        assertFalse(Tester.isCompliantIp(\"256.256.256.256\"));\n    }\n\n    @Test\n    public void testIsCompliantIpEmptyString() {\n        assertFalse(Tester.isCompliantIp(\"\"));\n    }\n\n    @Test\n    public void testIsCompliantIpNull() {\n        assertThrows(NullPointerException.class, () -> Tester.isCompliantIp(null));\n    }\n\n    @Test\n    public void testIsCompliantIpIncorrectFormat() {\n        assertFalse(Tester.isCompliantIp(\"192.168.1\"));\n        assertFalse(Tester.isCompliantIp(\"192.168.1.a\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks whether the given IP address is a legal IP address.\n *\n * @param ip The IP address in string format.\n * @return true if the IP is compliant, false otherwise.\n */\npublic static boolean isCompliantIP(String ip) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 281, "code_type": "method", "original_language": "python", "file_path": "uozp-hw1\\b91e588821c3c344e33d48660821af1bc02be862\\hw0.py", "question_type": "Algorithm and data structure", "summary": "compute the squared Euclidean distance between two vectors\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef squared_euclidean_distance(vec1: List[int], vec2: List[int]) -> int:\n    \"\"\"\n    compute the squared Euclidean distance between two vectors.\n\n    Args:\n        vec1 (List[int]): First vector.\n        vec2 (List[int]): Second vector.\n\n    Returns:\n        int: Euclidean distance between vec1 and vec2.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSquaredEuclideanDistance(unittest.TestCase):\n    def test_standard_vectors(self):\n        \"\"\"Test squared distance calculation for typical vectors.\"\"\"\n        vec1 = [1, 2, 3]\n        vec2 = [4, 5, 6]\n        expected_result = 27  # (3^2 + 3^2 + 3^2)\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n\n    def test_vectors_with_zeros(self):\n        \"\"\"Test vectors that include zero values.\"\"\"\n        vec1 = [0, 0, 0]\n        vec2 = [0, 0, 0]\n        expected_result = 0\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n\n    def test_vectors_with_negative_values(self):\n        \"\"\"Test vectors that include negative values.\"\"\"\n        vec1 = [-1, -2, -3]\n        vec2 = [-4, -5, -6]\n        expected_result = 27  # (3^2 + 3^2 + 3^2)\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n\n    def test_single_element_vectors(self):\n        \"\"\"Test single element vectors.\"\"\"\n        vec1 = [5]\n        vec2 = [-5]\n        expected_result = 100  # (10^2)\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef squared_euclidean_distance(vec1: List[int], vec2: List[int]) -> int:\n    \"\"\"\n    compute the squared Euclidean distance between two vectors.\n\n    Args:\n        vec1 (List[int]): First vector.\n        vec2 (List[int]): Second vector.\n\n    Returns:\n        int: Euclidean distance between vec1 and vec2.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Compute the squared Euclidean distance between two vectors.\n *\n * @param vec1 The first vector.\n * @param vec2 The second vector.\n * @return The squared Euclidean distance between vec1 and vec2.\n */\nint squared_euclidean_distance(const std::vector<int>& vec1, const std::vector<int>& vec2) {\n\n}", "test_code": "TEST_CASE(\"Squared Euclidean Distance\", \"[squared_euclidean_distance]\") {\n    SECTION(\"Equal Vectors\") {\n        std::vector<int> vec1 = {1, 2, 3};\n        std::vector<int> vec2 = {1, 2, 3};\n        REQUIRE(squared_euclidean_distance(vec1, vec2) == 0);\n    }\n\n    SECTION(\"Different Vectors\") {\n        std::vector<int> vec1 = {1, 2, 3};\n        std::vector<int> vec2 = {4, 5, 6};\n        REQUIRE(squared_euclidean_distance(vec1, vec2) == 27);\n    }\n\n    SECTION(\"Empty Vectors\") {\n        std::vector<int> vec1 = {};\n        std::vector<int> vec2 = {};\n        REQUIRE(squared_euclidean_distance(vec1, vec2) == 0);\n    }\n\n    SECTION(\"Single Element Vectors\") {\n        std::vector<int> vec1 = {1};\n        std::vector<int> vec2 = {2};\n        REQUIRE(squared_euclidean_distance(vec1, vec2) == 1);\n    }\n\n    SECTION(\"Vectors with Negative Elements\") {\n        std::vector<int> vec1 = {-1, -2, -3};\n        std::vector<int> vec2 = {1, 2, 3};\n        REQUIRE(squared_euclidean_distance(vec1, vec2) == 36);\n    }\n\n    SECTION(\"Vectors of Different Sizes Should Throw Exception\") {\n        std::vector<int> vec1 = {1, 2, 3};\n        std::vector<int> vec2 = {1, 2};\n        REQUIRE_THROWS_WITH(squared_euclidean_distance(vec1, vec2), \"Vectors must be of the same size\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Compute the squared Euclidean distance between two vectors.\n *\n * @param vec1 The first vector.\n * @param vec2 The second vector.\n * @return The squared Euclidean distance between vec1 and vec2.\n */\nint squared_euclidean_distance(const std::vector<int>& vec1, const std::vector<int>& vec2) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Computes the squared Euclidean distance between two vectors.\n *\n * @param vec1 The first vector as a List of integers.\n * @param vec2 The second vector as a List of integers.\n * @return The squared Euclidean distance between vec1 and vec2 as an integer.\n * @throws IllegalArgumentException If the vectors are of different lengths.\n */\npublic static int squaredEuclideanDistance(List<Integer> vec1, List<Integer> vec2) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testSquaredEuclideanDistance() {\n        List<Integer> vec1 = Arrays.asList(1, 2, 3);\n        List<Integer> vec2 = Arrays.asList(4, 5, 6);\n\n        int expectedDistance = 27; // (1-4)^2 + (2-5)^2 + (3-6)^2 = 9 + 9 + 9 = 27\n        int actualDistance = VectorUtils.squaredEuclideanDistance(vec1, vec2);\n\n        assertEquals(expectedDistance, actualDistance, \"The squared Euclidean distance should be 27\");\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Computes the squared Euclidean distance between two vectors.\n *\n * @param vec1 The first vector as a List of integers.\n * @param vec2 The second vector as a List of integers.\n * @return The squared Euclidean distance between vec1 and vec2 as an integer.\n * @throws IllegalArgumentException If the vectors are of different lengths.\n */\npublic static int squaredEuclideanDistance(List<Integer> vec1, List<Integer> vec2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 282, "code_type": "method", "original_language": "python", "file_path": "uozp-hw1\\b91e588821c3c344e33d48660821af1bc02be862\\hw0.py", "question_type": "Data processing and transformation", "summary": "convert a multi-dimensional array into a one-dimensional array\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef flatten_array(multi_dim_array: List) -> List:\n    \"\"\"\n    convert a multi-dimensional array into a one-dimensional array\n    Args:\n        multi_dim_array (List): A multi-dimensional list (nested list).\n\n    Returns:\n        list: A one-dimensional list containing all elements of the input.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFlattenArray(unittest.TestCase):\n    def test_deeply_nested_array(self):\n        \"\"\"Test a deeply nested array.\"\"\"\n        nested_array = [1, [2, [3, [4, [5]]]]]\n        expected_result = [1, 2, 3, 4, 5]\n        self.assertEqual(flatten_array(nested_array), expected_result)\n\n    def test_mixed_types(self):\n        \"\"\"Test an array with mixed question types.\"\"\"\n        mixed_array = [\"a\", [\"b\", 2, [True, [3.14]]], False]\n        expected_result = [\"a\", \"b\", 2, True, 3.14, False]\n        self.assertEqual(flatten_array(mixed_array), expected_result)\n\n    def test_empty_array(self):\n        \"\"\"Test an empty array.\"\"\"\n        empty_array = []\n        expected_result = []\n        self.assertEqual(flatten_array(empty_array), expected_result)\n\n    def test_array_with_empty_subarrays(self):\n        \"\"\"Test an array that includes empty subarrays.\"\"\"\n        complex_array = [1, [], [2, [], 3], [4, [5, [], 6], 7], []]\n        expected_result = [1, 2, 3, 4, 5, 6, 7]\n        self.assertEqual(flatten_array(complex_array), expected_result)\n\n    def test_no_nested_array(self):\n        \"\"\"Test an array that has no nested structure.\"\"\"\n        flat_array = [1, 2, 3, 4, 5]\n        expected_result = [1, 2, 3, 4, 5]\n        self.assertEqual(flatten_array(flat_array), expected_result)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef flatten_array(multi_dim_array: List) -> List:\n    \"\"\"\n    convert a multi-dimensional array into a one-dimensional array\n    Args:\n        multi_dim_array (List): A multi-dimensional list (nested list).\n\n    Returns:\n        list: A one-dimensional list containing all elements of the input.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert a multi-dimensional array into a one-dimensional array.\n *\n * @param multiDimArray The multi-dimensional vector (nested vector).\n * @return A one-dimensional vector containing all elements of the input.\n */\nstd::vector<int> flatten_array(const std::vector<std::vector<int>>& multiDimArray){\n\n}", "test_code": "TEST_CASE(\"Flatten array tests\") {\n\n    // Test a deeply nested array\n    SECTION(\"deeply_nested_array\") {\n        std::vector<std::vector<int>> nested_array = {{1}, {2, {3, {4, {5}}}}};\n        std::vector<int> expected_result = {1, 2, 3, 4, 5};\n        REQUIRE(flatten_array(nested_array) == expected_result);\n    }\n\n    // Test an array with mixed types (simulated with integers for simplicity)\n    SECTION(\"mixed_types\") {\n        std::vector<std::vector<int>> mixed_array = {{1}, {2, {3, {4, {5}}}}, {6}};\n        std::vector<int> expected_result = {1, 2, 3, 4, 5, 6};\n        REQUIRE(flatten_array(mixed_array) == expected_result);\n    }\n\n    // Test an empty array\n    SECTION(\"empty_array\") {\n        std::vector<std::vector<int>> empty_array = {};\n        std::vector<int> expected_result = {};\n        REQUIRE(flatten_array(empty_array) == expected_result);\n    }\n\n    // Test an array that includes empty subarrays\n    SECTION(\"array_with_empty_subarrays\") {\n        std::vector<std::vector<int>> complex_array = {{1}, {}, {2, {}, 3}, {4, {5, {}, 6}, 7}, {}};\n        std::vector<int> expected_result = {1, 2, 3, 4, 5, 6, 7};\n        REQUIRE(flatten_array(complex_array) == expected_result);\n    }\n\n    // Test an array that has no nested structure\n    SECTION(\"no_nested_array\") {\n        std::vector<std::vector<int>> flat_array = {{1}, {2}, {3}, {4}, {5}};\n        std::vector<int> expected_result = {1, 2, 3, 4, 5};\n        REQUIRE(flatten_array(flat_array) == expected_result);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert a multi-dimensional array into a one-dimensional array.\n *\n * @param multiDimArray The multi-dimensional vector (nested vector).\n * @return A one-dimensional vector containing all elements of the input.\n */\nstd::vector<int> flatten_array(const std::vector<std::vector<int>>& multiDimArray){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a multi-dimensional array into a one-dimensional array.\n *\n * @param multiDimArray A multi-dimensional list (nested list).\n * @return A one-dimensional list containing all elements of the input.\n */\npublic static List<Object> flattenArray(List<?> multiDimArray) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class ArrayUtilsTest {\n\n    @Test\n    public void testFlattenArray() {\n        // Test case 1: Empty list\n        assertEquals(Arrays.asList(), ArrayUtils.flattenArray(Arrays.asList()));\n\n        // Test case 2: Single element list\n        assertEquals(Arrays.asList(1), ArrayUtils.flattenArray(Arrays.asList(1)));\n\n        // Test case 3: Two-level nested list\n        assertEquals(Arrays.asList(1, 2, 3, 4), ArrayUtils.flattenArray(Arrays.asList(\n                Arrays.asList(1, 2),\n                Arrays.asList(3, 4)\n        )));\n\n        // Test case 4: Multi-level nested list\n        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6), ArrayUtils.flattenArray(Arrays.asList(\n                Arrays.asList(1, 2),\n                Arrays.asList(3, Arrays.asList(4, 5)),\n                Arrays.asList(6)\n        )));\n\n        // Test case 5: Mixed types (should throw exception or handle appropriately)\n        try {\n            ArrayUtils.flattenArray(Arrays.asList(1, Arrays.asList(\"a\", 2)));\n        } catch (ClassCastException e) {\n            // Expected exception\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a multi-dimensional array into a one-dimensional array.\n *\n * @param multiDimArray A multi-dimensional list (nested list).\n * @return A one-dimensional list containing all elements of the input.\n */\npublic static List<Object> flattenArray(List<?> multiDimArray) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 286, "code_type": "method", "original_language": "python", "file_path": "partial-model-merging\\d919c66a8b5f50c6ab7f599a0605d6a18834bcb1\\src\\plot_scripts\\plot_correlation_histogram.py", "question_type": "Algorithm and data structure", "summary": "find the largest integer between a given number n and half of it that is divisible by 10 or 5", "language_version_list": {"python": {"code_signature": "from typing import Union\n\n\ndef find_largest_divisible(n: int) -> Union[int, None]:\n    \"\"\"\n    find the largest integer between a given number n and half of it that is divisible by 10 or 5\n    Args:\n        n (int): The upper bound of the range.\n\n    Returns:\n        The largest integer between n and half of n that is divisible by 5, or\n         None if no such number exists.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFindLargestDivisible(unittest.TestCase):\n    def test_typical_case(self):\n        \"\"\"Test with a typical input where the largest divisible number should be found.\"\"\"\n        self.assertEqual(find_largest_divisible(50), 50)\n        self.assertEqual(find_largest_divisible(47), 45)\n\n    def test_no_divisible_found(self):\n        \"\"\"Test a case where no divisible number is found within the range.\"\"\"\n        self.assertIsNone(find_largest_divisible(4))\n\n    def test_exact_half_divisible(self):\n        \"\"\"Test when the half of n is exactly divisible by 5.\"\"\"\n        self.assertEqual(find_largest_divisible(10), 10)\n\n    def test_large_number(self):\n        \"\"\"Test with a large number to ensure performance and correctness.\"\"\"\n        self.assertEqual(find_largest_divisible(1000), 1000)\n\n    def test_lower_bound(self):\n        \"\"\"Test the function with the lowest bound that should find a divisible number.\"\"\"\n        self.assertEqual(find_largest_divisible(5), 5)\n", "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef find_largest_divisible(n: int) -> Union[int, None]:\n    \"\"\"\n    find the largest integer between a given number n and half of it that is divisible by 10 or 5\n    Args:\n        n (int): The upper bound of the range.\n\n    Returns:\n        The largest integer between n and half of n that is divisible by 5, or\n         None if no such number exists.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Find the largest integer between a given number n and half of it that is divisible by 10 or 5\n *\n * @param n The upper bound of the range.\n * @return The largest integer between n and half of n that is divisible by 5,\n * or -1 if no such number exists.\n */\nint find_largest_divisible(int n) {\n\n}", "test_code": "TEST_CASE(\"TestFindLargestDivisible\", \"[find_largest_divisible]\") {\n    SECTION(\"test_typical_case\") {\n        // Test with a typical input where the largest divisible number should be found.\n        REQUIRE(find_largest_divisible(50) == 50);\n        REQUIRE(find_largest_divisible(47) == 45);\n    }\n\n    SECTION(\"test_no_divisible_found\") {\n        // Test a case where no divisible number is found within the range.\n        REQUIRE(!find_largest_divisible(4).has_value());\n    }\n\n    SECTION(\"test_exact_half_divisible\") {\n        // Test when the half of n is exactly divisible by 5.\n        REQUIRE(find_largest_divisible(10) == 10);\n    }\n\n    SECTION(\"test_large_number\") {\n        // Test with a large number to ensure performance and correctness.\n        REQUIRE(find_largest_divisible(1000) == 1000);\n    }\n\n    SECTION(\"test_lower_bound\") {\n        // Test the function with the lowest bound that should find a divisible number.\n        REQUIRE(find_largest_divisible(5) == 5);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Find the largest integer between a given number n and half of it that is divisible by 10 or 5\n *\n * @param n The upper bound of the range.\n * @return The largest integer between n and half of n that is divisible by 5,\n * or -1 if no such number exists.\n */\nint find_largest_divisible(int n) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds the largest integer between a given number n and half of it that is divisible by 10 or 5.\n *\n * @param n The upper bound of the range.\n * @return The largest integer between n and half of n that is divisible by 5, or\n *         Optional.empty() if no such number exists.\n */\npublic static Optional<Integer> findLargestDivisible(int n) {}", "test_code": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class TesterTest {\n\n    @Test\n    public void testFindLargestDivisible() {\n        assertEquals(Integer.valueOf(30), Tester.findLargestDivisible(30));\n        assertEquals(Integer.valueOf(25), Tester.findLargestDivisible(29));\n        assertEquals(Integer.valueOf(5), Tester.findLargestDivisible(7));\n        assertNull(Tester.findLargestDivisible(1));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds the largest integer between a given number n and half of it that is divisible by 10 or 5.\n *\n * @param n The upper bound of the range.\n * @return The largest integer between n and half of n that is divisible by 5, or\n *         Optional.empty() if no such number exists.\n */\npublic static Optional<Integer> findLargestDivisible(int n) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 290, "code_type": "method", "original_language": "python", "file_path": "integrity-datamodels\\f35cdaabb51a81f692c6dcce24ba10acc92e6cc1\\ontologies\\rdf_to_ngsi.py", "question_type": "Data processing and transformation", "summary": "Read the emission probability matrix and the mapping order of amino acids in a given HMM (Hidden Markov Model) file\n", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef rdf_jsonld_to_ngsild(rdf_jsonld: str) -> Dict:\n    \"\"\"\n    convert the question in RDF JSON-LD format to NGSI-LD format\n    Args:\n        rdf_jsonld (str): RDF JSON-LD formatted question as a string.\n\n    Returns:\n        Data formatted according to NGSI-LD specifications.\n    \"\"\"\n", "test_code": "import unittest\nimport json\n\n\nclass TestRDFJSONLDToNGSILDConversion(unittest.TestCase):\n    def test_basic_conversion(self):\n        \"\"\"Test a basic and correct conversion from JSON-LD to NGSI-LD.\"\"\"\n        rdf_jsonld = json.dumps({\n            \"@context\": \"http://schema.org/\",\n            \"@id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"@type\": \"Vehicle\",\n            \"speed\": {\"value\": 60, \"unitCode\": \"KMH\"}\n        })\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"type\": \"Vehicle\",\n            \"@context\": \"http://schema.org/\",\n            \"attributes\": [\n                {\"type\": \"Property\", \"name\": \"speed\", \"value\": {\"value\": 60, \"unitCode\": \"KMH\"}}\n            ]\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n\n    def test_missing_id_and_type(self):\n        \"\"\"Test conversion when @id and @type are missing.\"\"\"\n        rdf_jsonld = json.dumps({\n            \"@context\": \"http://schema.org/\",\n            \"speed\": {\"value\": 60, \"unitCode\": \"KMH\"}\n        })\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:unknown:id\",\n            \"type\": \"UnknownType\",\n            \"@context\": \"http://schema.org/\",\n            \"attributes\": [\n                {\"type\": \"Property\", \"name\": \"speed\", \"value\": {\"value\": 60, \"unitCode\": \"KMH\"}}\n            ]\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n\n    def test_with_nested_objects(self):\n        \"\"\"Test conversion with nested objects.\"\"\"\n        rdf_jsonld = json.dumps({\n            \"@context\": \"http://schema.org/\",\n            \"@id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"@type\": \"Vehicle\",\n            \"location\": {\"latitude\": 48.8566, \"longitude\": 2.3522}\n        })\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"type\": \"Vehicle\",\n            \"@context\": \"http://schema.org/\",\n            \"attributes\": [\n                {\"type\": \"Property\", \"name\": \"location\", \"value\": {\"latitude\": 48.8566, \"longitude\": 2.3522}}\n            ]\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n\n    def test_invalid_json_input(self):\n        \"\"\"Test the function's response to invalid JSON input.\"\"\"\n        rdf_jsonld = \"This is not a valid JSON\"\n        with self.assertRaises(json.JSONDecodeError):\n            rdf_jsonld_to_ngsild(rdf_jsonld)\n\n    def test_empty_jsonld(self):\n        \"\"\"Test the conversion of an empty JSON-LD document.\"\"\"\n        rdf_jsonld = json.dumps({})\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:unknown:id\",\n            \"type\": \"UnknownType\",\n            \"@context\": \"https://schema.lab.fiware.org/ld/context\",\n            \"attributes\": []\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef rdf_jsonld_to_ngsild(rdf_jsonld: str) -> Dict:\n    \"\"\"\n    convert the question in RDF JSON-LD format to NGSI-LD format\n    Args:\n        rdf_jsonld (str): RDF JSON-LD formatted question as a string.\n\n    Returns:\n        Data formatted according to NGSI-LD specifications.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert the question in RDF JSON-LD format to NGSI-LD format\n *\n * @param rdfJsonLd The RDF JSON-LD formatted question as a string.\n * @return A map containing data formatted according to NGSI-LD specifications.\n */\nstd::map<std::string, std::string> rdf_json_ld_to_ngsi_ld(const std::string& rdfJsonLd){\n\n}", "test_code": "TEST_CASE(\"Test RDF JSON-LD to NGSI-LD Conversion\") {\n    SECTION(\"Basic conversion\") {\n        // Test a basic and correct conversion from JSON-LD to NGSI-LD\n        std::string rdf_jsonld = R\"({\"@context\": \"http://schema.org/\", \"@id\": \"urn:ngsi-ld:Vehicle:A123\", \"@type\": \"Vehicle\", \"speed\": {\"value\": 60, \"unitCode\": \"KMH\"}})\";\n        json expected_ngsild = {\n            {\"id\", \"urn:ngsi-ld:Vehicle:A123\"},\n            {\"type\", \"Vehicle\"},\n            {\"@context\", \"http://schema.org/\"},\n            {\"attributes\", json::array({\n                {\"type\", \"Property\"},\n                {\"name\", \"speed\"},\n                {\"value\", json::object({{\"value\", 60}, {\"unitCode\", \"KMH\"}})}\n            })}\n        };\n        json result = rdf_json_ld_to_ngsi_ld(rdf_jsonld);\n        REQUIRE(result == expected_ngsild);\n    }\n\n    SECTION(\"Missing @id and @type\") {\n        // Test conversion when @id and @type are missing\n        std::string rdf_jsonld = R\"({\"@context\": \"http://schema.org/\", \"speed\": {\"value\": 60, \"unitCode\": \"KMH\"}})\";\n        json expected_ngsild = {\n            {\"id\", \"urn:ngsi-ld:unknown:id\"},\n            {\"type\", \"UnknownType\"},\n            {\"@context\", \"http://schema.org/\"},\n            {\"attributes\", json::array({\n                {\"type\", \"Property\"},\n                {\"name\", \"speed\"},\n                {\"value\", json::object({{\"value\", 60}, {\"unitCode\", \"KMH\"}})}\n            })}\n        };\n        json result = rdf_json_ld_to_ngsi_ld(rdf_jsonld);\n        REQUIRE(result == expected_ngsild);\n    }\n\n    SECTION(\"With nested objects\") {\n        // Test conversion with nested objects\n        std::string rdf_jsonld = R\"({\"@context\": \"http://schema.org/\", \"@id\": \"urn:ngsi-ld:Vehicle:A123\", \"@type\": \"Vehicle\", \"location\": {\"latitude\": 48.8566, \"longitude\": 2.3522}})\";\n        json expected_ngsild = {\n            {\"id\", \"urn:ngsi-ld:Vehicle:A123\"},\n            {\"type\", \"Vehicle\"},\n            {\"@context\", \"http://schema.org/\"},\n            {\"attributes\", json::array({\n                {\"type\", \"Property\"},\n                {\"name\", \"location\"},\n                {\"value\", json::object({{\"latitude\", 48.8566}, {\"longitude\", 2.3522}})}\n            })}\n        };\n        json result = rdf_json_ld_to_ngsi_ld(rdf_jsonld);\n        REQUIRE(result == expected_ngsild);\n    }\n\n    SECTION(\"Invalid JSON input\") {\n        // Test the function's response to invalid JSON input\n        std::string rdf_jsonld = \"This is not a valid JSON\";\n        REQUIRE_THROWS_AS(rdf_json_ld_to_ngsi_ld(rdf_jsonld), std::exception);\n    }\n\n    SECTION(\"Empty JSON-LD document\") {\n        // Test the conversion of an empty JSON-LD document\n        std::string rdf_jsonld = R\"({})\";\n        json expected_ngsild = {\n            {\"id\", \"urn:ngsi-ld:unknown:id\"},\n            {\"type\", \"UnknownType\"},\n            {\"@context\", \"https://schema.lab.fiware.org/ld/context\"},\n            {\"attributes\", json::array()}\n        };\n        json result = rdf_json_ld_to_ngsi_ld(rdf_jsonld);\n        REQUIRE(result == expected_ngsild);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert the question in RDF JSON-LD format to NGSI-LD format\n *\n * @param rdfJsonLd The RDF JSON-LD formatted question as a string.\n * @return A map containing data formatted according to NGSI-LD specifications.\n */\nstd::map<std::string, std::string> rdf_json_ld_to_ngsi_ld(const std::string& rdfJsonLd){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts the question in RDF JSON-LD format to NGSI-LD format.\n * \n * @param rdfJsonLd The RDF JSON-LD formatted question as a string.\n * @return A map containing data formatted according to NGSI-LD specifications.\n */\npublic Map<String, Object> rdfJsonldToNgSILD(String rdfJsonLd) {}", "test_code": "import static org.junit.Assert.assertEquals;\nimport org.json.JSONObject;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testRDFJSONLDToNGSILD() throws Exception {\n        // Arrange\n        String rdfJsonLd = \"{\\\"@context\\\": \\\"http://example.com\\\", \\\"name\\\": \\\"John\\\"}\";\n\n        // Act\n        JSONObject ngsiLdResult = rdfJsonLdToNgSILDRdfJsonLd(rdfJsonLd);\n\n        // Assert\n        assertEquals(\"John\", ngsiLdResult.getString(\"name\"));\n    }\n\n    private JSONObject rdfJsonLdToNgSILDRdfJsonLd(String rdfJsonLd) {\n        // Implement the conversion logic here and return a JSONObject\n        // This is just a placeholder for demonstration purposes\n        JSONObject jsonObject = new JSONObject();\n        jsonObject.put(\"name\", \"John\");\n        return jsonObject;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts the question in RDF JSON-LD format to NGSI-LD format.\n * \n * @param rdfJsonLd The RDF JSON-LD formatted question as a string.\n * @return A map containing data formatted according to NGSI-LD specifications.\n */\npublic Map<String, Object> rdfJsonldToNgSILD(String rdfJsonLd) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 291, "code_type": "method", "original_language": "python", "file_path": "aitechtalk20230712\\feb0696125ad08d951eb03357a2ef4c4421f22d3\\trainingdata\\prepareTrainingData.py", "question_type": "File operations and I/O operation", "summary": "appends the specified string to the beginning of each line of the file and then updates the entire file", "language_version_list": {"python": {"code_signature": "def prepend_to_each_line(file_path: str, prefix: str):\n    \"\"\"\n    Appends the specified string to the beginning of each line of the file.\n\n    Args:\n    file_path (str): Path to the file whose lines will be modified.\n    prefix (str): String to append to the beginning of each line.\n    \"\"\"\n", "test_code": "import unittest\nimport os\n\nclass TestPrependToEachLine(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Create a temporary file for testing.\"\"\"\n        self.test_file_path = \"test_file.txt\"\n        with open(self.test_file_path, 'w') as f:\n            f.write(\"Line 1\\nLine 2\\nLine 3\")\n\n    def tearDown(self):\n        \"\"\"Remove the temporary file after testing.\"\"\"\n        os.remove(self.test_file_path)\n\n    def test_prepend_string(self):\n        \"\"\"Test appending a simple string to the beginning of each line.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"Test: \")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"Test: Line 1\\n\", \"Test: Line 2\\n\", \"Test: Line 3\"])\n\n    def test_prepend_empty_string(self):\n        \"\"\"Test appending an empty string.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"\")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"Line 1\\n\", \"Line 2\\n\", \"Line 3\"])\n\n    def test_prepend_special_characters(self):\n        \"\"\"Test appending special characters to the beginning of each line.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"#$%^&* \")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"#$%^&* Line 1\\n\", \"#$%^&* Line 2\\n\", \"#$%^&* Line 3\"])\n\n    def test_prepend_numeric_string(self):\n        \"\"\"Test appending numeric string to the beginning of each line.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"123 \")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"123 Line 1\\n\", \"123 Line 2\\n\", \"123 Line 3\"])\n\n    def test_file_not_found(self):\n        \"\"\"Test the response when the file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            prepend_to_each_line(\"non_existent_file.txt\", \"Test: \")", "prompt": "please write a python function , the function signature as below def prepend_to_each_line(file_path: str, prefix: str):\n    \"\"\"\n    Appends the specified string to the beginning of each line of the file.\n\n    Args:\n    file_path (str): Path to the file whose lines will be modified.\n    prefix (str): String to append to the beginning of each line.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Appends the specified string to the beginning of each line of the file.\n *\n * @param file_path The path to the file whose lines will be modified.\n * @param prefix The string to append to the beginning of each line.\n */\nvoid prepend_to_each_line(const std::string& file_path, const std::string& prefix){\n\n}", "test_code": "TEST_CASE(\"TestPrependToEachLine\") {\n    std::string test_file_path = \"test_file.txt\";\n\n    SECTION(\"setUp\") {\n        // Create a temporary file for testing\n        std::ofstream f(test_file_path);\n        f << \"Line 1\\nLine 2\\nLine 3\";\n        f.close();\n    }\n\n    SECTION(\"tearDown\") {\n        // Remove the temporary file after testing\n        std::filesystem::remove(test_file_path);\n    }\n\n    SECTION(\"test_prepend_string\") {\n        // Test appending a simple string to the beginning of each line\n        prepend_to_each_line(test_file_path, \"Test: \");\n        std::ifstream f(test_file_path);\n        std::string line;\n        std::vector<std::string> lines;\n        while (std::getline(f, line)) {\n            lines.push_back(line + \"\\n\");\n        }\n        f.close();\n        REQUIRE(lines == std::vector<std::string>({\n            \"Test: Line 1\\n\",\n            \"Test: Line 2\\n\",\n            \"Test: Line 3\\n\"\n        }));\n    }\n\n    SECTION(\"test_prepend_empty_string\") {\n        // Test appending an empty string\n        prepend_to_each_line(test_file_path, \"\");\n        std::ifstream f(test_file_path);\n        std::string line;\n        std::vector<std::string> lines;\n        while (std::getline(f, line)) {\n            lines.push_back(line + \"\\n\");\n        }\n        f.close();\n        REQUIRE(lines == std::vector<std::string>({\n            \"Line 1\\n\",\n            \"Line 2\\n\",\n            \"Line 3\\n\"\n        }));\n    }\n\n    SECTION(\"test_prepend_special_characters\") {\n        // Test appending special characters to the beginning of each line\n        prepend_to_each_line(test_file_path, \"#$%^&* \");\n        std::ifstream f(test_file_path);\n        std::string line;\n        std::vector<std::string> lines;\n        while (std::getline(f, line)) {\n            lines.push_back(line + \"\\n\");\n        }\n        f.close();\n        REQUIRE(lines == std::vector<std::string>({\n            \"#$%^&* Line 1\\n\",\n            \"#$%^&* Line 2\\n\",\n            \"#$%^&* Line 3\\n\"\n        }));\n    }\n\n    SECTION(\"test_prepend_numeric_string\") {\n        // Test appending numeric string to the beginning of each line\n        prepend_to_each_line(test_file_path, \"123 \");\n        std::ifstream f(test_file_path);\n        std::string line;\n        std::vector<std::string> lines;\n        while (std::getline(f, line)) {\n            lines.push_back(line + \"\\n\");\n        }\n        f.close();\n        REQUIRE(lines == std::vector<std::string>({\n            \"123 Line 1\\n\",\n            \"123 Line 2\\n\",\n            \"123 Line 3\\n\"\n        }));\n    }\n\n    SECTION(\"test_file_not_found\") {\n        // Test the response when the file does not exist\n        REQUIRE_THROWS_AS(prepend_to_each_line(\"non_existent_file.txt\", \"Test: \"), std::runtime_error);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Appends the specified string to the beginning of each line of the file.\n *\n * @param file_path The path to the file whose lines will be modified.\n * @param prefix The string to append to the beginning of each line.\n */\nvoid prepend_to_each_line(const std::string& file_path, const std::string& prefix){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Appends the specified string to the beginning of each line of the file.\n *\n * @param filePath the path to the file whose lines will be modified\n * @param prefix   the string to append to the beginning of each line\n */\npublic static void prependToEachLine(String filePath, String prefix) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\nimport org.junit.Test;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class Tester extends junit.framework.TestCase {\n\n    @Test\n    public void testPrependToFile() throws IOException {\n        // Temporary file path\n        File tempFile = File.createTempFile(\"test\", \".txt\");\n\n        // Content to write to the file\n        String content = \"Hello\\nWorld\";\n\n        // Write initial content to the file\n        try (FileWriter writer = new FileWriter(tempFile)) {\n            writer.write(content);\n        }\n\n        // Prefix to prepend\n        String prefix = \"Prefix_\";\n\n        // Call the method under test\n        prependToEachLine(tempFile.getAbsolutePath(), prefix);\n\n        // Read the updated content from the file\n        String updatedContent = new String(Files.readAllBytes(Paths.get(tempFile.getAbsolutePath())));\n\n        // Expected result\n        String expectedResult = \"Prefix_Hello\\nPrefix_World\";\n\n        // Assert that the updated content matches the expected result\n        assertEquals(expectedResult, updatedContent);\n\n        // Clean up the temporary file\n        tempFile.delete();\n    }\n\n    private void prependToEachLine(String filePath, String prefix) {\n        try {\n            // Read all lines from the file\n            List<String> lines = Files.readAllLines(Paths.get(filePath));\n\n            // Prepend the prefix to each line\n            for (int i = 0; i < lines.size(); i++) {\n                lines.set(i, prefix + lines.get(i));\n            }\n\n            // Write the updated lines back to the file\n            Files.write(Paths.get(filePath), lines);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error while prepending to file: \" + filePath, e);\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Appends the specified string to the beginning of each line of the file.\n *\n * @param filePath the path to the file whose lines will be modified\n * @param prefix   the string to append to the beginning of each line\n */\npublic static void prependToEachLine(String filePath, String prefix) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 366, "code_type": "method", "original_language": "python", "file_path": "Spectrum\\928b58b455406a6f08b05c1d752bf0eef79e04f0\\Assets\\Other\\ofl_to_spectrum.py", "question_type": "File operations and I/O operation", "summary": "Extracts text content from a given word file", "language_version_list": {"python": {"code_signature": "from docx import Document\n\ndef extract_text_from_word(docx_file_path):\n    \"\"\"\n    Extracts text content from a given Word file (.docx).\n\n    Args:\n        docx_file_path (str): The path to the Word file.\n\n    Returns:\n        str: The extracted text content.\n    \"\"\"", "test_code": "import unittest\nimport os\nfrom docx import Document\n\n\nclass TestExtractTextFromWord(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up the testing environment.\"\"\"\n        # Create a temporary Word file for testing\n        self.test_docx_path = \"test_document.docx\"\n        self.create_sample_docx()\n\n    def tearDown(self):\n        \"\"\"Clean up the test environment.\"\"\"\n        # Remove created files after tests\n        if os.path.exists(self.test_docx_path):\n            os.remove(self.test_docx_path)\n\n    def create_sample_docx(self):\n        \"\"\"Helper method to create a sample Word document for testing.\"\"\"\n        doc = Document()\n        doc.add_paragraph(\"Hello World!\")\n        doc.add_paragraph(\"This is a test document.\")\n        doc.save(self.test_docx_path)\n\n    def test_extract_text_success(self):\n        \"\"\"Test extracting text from a normal Word document.\"\"\"\n        expected_text = \"Hello World!\\nThis is a test document.\"\n        extracted_text = extract_text_from_word(self.test_docx_path)\n        self.assertEqual(extracted_text.strip(), expected_text)\n\n    def test_extract_empty_document(self):\n        \"\"\"Test extracting text from an empty Word document.\"\"\"\n        empty_docx_path = \"empty_document.docx\"\n        Document().save(empty_docx_path)\n\n        extracted_text = extract_text_from_word(empty_docx_path)\n        self.assertEqual(extracted_text, \"\")  # Expecting an empty string\n\n        os.remove(empty_docx_path)  # Clean up\n\n\n    def test_extract_text_with_special_characters(self):\n        \"\"\"Test extracting text from a document containing special characters.\"\"\"\n        special_docx_path = \"special_characters.docx\"\n        doc = Document()\n        doc.add_paragraph(\"Hello, \u4e16\u754c! @#$%^&*()\")\n        doc.save(special_docx_path)\n\n        extracted_text = extract_text_from_word(special_docx_path)\n        expected_text = \"Hello, \u4e16\u754c! @#$%^&*()\"\n        self.assertEqual(extracted_text.strip(), expected_text)\n\n        os.remove(special_docx_path)  # Clean up\n\n    def test_extract_text_with_multiple_paragraphs(self):\n        \"\"\"Test extracting text from a document with multiple paragraphs.\"\"\"\n        multi_para_docx_path = \"multi_paragraphs.docx\"\n        doc = Document()\n        doc.add_paragraph(\"First paragraph.\")\n        doc.add_paragraph(\"Second paragraph.\")\n        doc.add_paragraph(\"Third paragraph.\")\n        doc.save(multi_para_docx_path)\n\n        extracted_text = extract_text_from_word(multi_para_docx_path)\n        expected_text = \"First paragraph.\\nSecond paragraph.\\nThird paragraph.\"\n        self.assertEqual(extracted_text.strip(), expected_text)\n\n        os.remove(multi_para_docx_path)  # Clean up\n", "prompt": "please write a python function , the function signature as below from docx import Document\n\ndef extract_text_from_word(docx_file_path):\n    \"\"\"\n    Extracts text content from a given Word file (.docx).\n\n    Args:\n        docx_file_path (str): The path to the Word file.\n\n    Returns:\n        str: The extracted text content.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 369, "code_type": "method", "original_language": "python", "file_path": "python\\9dac241780aa9e5292ae196b0612c953e5181065\\nqueens", "question_type": "Algorithm and data structure", "summary": "solve the Eight Queens problem, if a solution is found, it will print out the configuration of the chessboard. If all queens cannot be placed, print \"No solution\"", "language_version_list": {"python": {"code_signature": "def eight_queens():\n    \"\"\"\n    solve the Eight Queens problem, if a solution is found, it will print out the configuration of the chessboard. If all queens cannot be placed, print \"No solution\"\n    print example as below:\n    . . Q . . . . .\n    . . . . Q . . .\n    . Q . . . . . .\n    . . . . . . . Q\n    . . . . . Q . .\n    . . . Q . . . .\n    . . . . . . Q .\n    Q . . . . . . .\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\nfrom unittest.mock import patch\nfrom io import StringIO\n\n\nclass TestEightQueens(unittest.TestCase):\n    def setUp(self):\n        self.board = [['.' for _ in range(8)] for _ in range(8)]\n\n    def test_solution_exists(self):\n        with patch('sys.stdout', new_callable=StringIO) as fake_out:\n            eight_queens()\n            self.assertTrue(\"Q\" in fake_out.getvalue(), \"The board should contain at least one queen.\")\n\n    def test_correct_number_of_queens(self):\n        with patch('sys.stdout', new_callable=StringIO) as fake_out:\n            eight_queens()\n            output = fake_out.getvalue().strip().split('\\n\\n')  # Split the output into blocks for each board\n            for board in output:\n                # Count number of 'Q's in each board\n                num_queens = board.count('Q')\n                self.assertEqual(num_queens, 8, \"Each board should contain exactly 8 queens.\")\n\n    def test_no_solution_scenario(self):\n        # As the Eight Queens always has a solution for an 8x8 board,\n        # to test the 'No solution' output we need a scenario where no solution exists.\n        # We will manipulate the board to a smaller size where no solution is possible.\n        # Here we consider a 3x3 board for simplicity.\n        def no_solution_queens():\n            board = [['.' for _ in range(3)] for _ in range(3)]\n            if not solve_queens(board, 0):\n                print(\"No solution\")\n\n        with patch('sys.stdout', new_callable=StringIO) as fake_out:\n            no_solution_queens()\n            self.assertIn(\"No solution\", fake_out.getvalue(), \"Should print 'No solution' when no solution exists.\")\n", "prompt": "please write a python function , the function signature as below def eight_queens():\n    \"\"\"\n    solve the Eight Queens problem, if a solution is found, it will print out the configuration of the chessboard. If all queens cannot be placed, print \"No solution\"\n    print example as below:\n    . . Q . . . . .\n    . . . . Q . . .\n    . Q . . . . . .\n    . . . . . . . Q\n    . . . . . Q . .\n    . . . Q . . . .\n    . . . . . . Q .\n    Q . . . . . . .\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "/**\n * Solve the Eight Queens problem. If a solution is found, it will print out the configuration of the chessboard.\n * If all queens cannot be placed, it will print \"No solution\".\n *\n * Print example:\n * . . Q . . . . .\n * . . . . Q . . .\n * . Q . . . . . .\n * . . . . . . . Q\n * . . . . . Q . .\n * . . . Q . . . .\n * . . . . . . Q .\n * Q . . . . . . .\n */\npublic static void eightQueens() {\n    // Method implementation goes here\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Before\n    public void setUp() {\n        // Setup code (if needed)\n    }\n\n    @Test\n    public void testEightQueens() {\n        try {\n            // Call the method that solves the Eight Queens problem\n            eightQueens();\n        } catch (Exception e) {\n            fail(\"The eightQueens method threw an unexpected exception: \" + e.getMessage());\n        }\n    }\n\n    private void eightQueens() {\n        // Implementation of the Eight Queens problem solver\n        // This is just a placeholder. Replace with actual implementation.\n        System.out.println(\". . Q . . . . .\");\n        System.out.println(\". . . . Q . . .\");\n        System.out.println(\". Q . . . . . .\");\n        System.out.println(\". . . . . . . Q\");\n        System.out.println(\". . . . . Q . .\");\n        System.out.println(\". . . Q . . . .\");\n        System.out.println(\". . . . . . Q .\");\n        System.out.println(\"Q . . . . . . .\");\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Solve the Eight Queens problem. If a solution is found, it will print out the configuration of the chessboard.\n * If all queens cannot be placed, it will print \"No solution\".\n *\n * Print example:\n * . . Q . . . . .\n * . . . . Q . . .\n * . Q . . . . . .\n * . . . . . . . Q\n * . . . . . Q . .\n * . . . Q . . . .\n * . . . . . . Q .\n * Q . . . . . . .\n */\npublic static void eightQueens() {\n    // Method implementation goes here\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 370, "code_type": "method", "original_language": "python", "file_path": "stride\\b57d0323a671ba9aff267643ce11b791e38d5c7e\\playground.py", "question_type": "Data processing and transformation", "summary": "Convert the index of a one-dimensional array to the index of the corresponding multi-dimensional array\n", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef decompose(n: int, shape: Tuple) -> Tuple:\n    \"\"\"\n    Decompose a flat index `n` into a multidimensional index based on the given shape.\n\n    Args:\n        n: Flat index (non-negative integer).\n        shape: Tuple representing the dimensions of the multi-dimensional array.\n\n    Returns:\n        Tuple: Tuple representing the multidimensional index corresponding to `n`.\n    Raises:\n        ValueError: If `n` is out of bounds for the array defined by `shape`.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestDecomposeFunction(unittest.TestCase):\n\n    def test_edge_case_with_larger_shap(self):\n        self.assertEqual(decompose(60, (4, 4, 4)), (3, 3, 0))\n\n    def test_last_valid_index(self):\n        self.assertEqual(decompose(63, (4, 4, 4)), (3, 3, 3))\n\n    def test_single_dimension_case(self):\n        self.assertEqual(decompose(2, (5,)), (2,))\n\n    def test_invalid_cases(self):\n        # Test case 5: Out of bounds case (negative index)\n        with self.assertRaises(ValueError):\n            decompose(-1, (3, 4, 5))\n\n        # Test case 6: Out of bounds case (index too large)\n        with self.assertRaises(ValueError):\n            decompose(100, (3, 4, 5))\n", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef decompose(n: int, shape: Tuple) -> Tuple:\n    \"\"\"\n    Decompose a flat index `n` into a multidimensional index based on the given shape.\n\n    Args:\n        n: Flat index (non-negative integer).\n        shape: Tuple representing the dimensions of the multi-dimensional array.\n\n    Returns:\n        Tuple: Tuple representing the multidimensional index corresponding to `n`.\n    Raises:\n        ValueError: If `n` is out of bounds for the array defined by `shape`.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Decompose a flat index `n` into a multidimensional index based on the given shape.\n *\n * @param n Flat index (non-negative integer).\n * @param shape Tuple representing the dimensions of the multi-dimensional array.\n * @return std::tuple Decomposed multidimensional index corresponding to `n`.\n * @throw std::out_of_range If `n` is out of bounds for the array defined by `shape`.\n */\nstd::tuple<int, int> decompose(int n, const std::tuple<int, int>& shape){\n\n}", "test_code": "TEST_CASE(\"Test Decompose Function\", \"[decompose]\") {\n    SECTION(\"Edge case with larger shape\") {\n        REQUIRE(decompose(60, {4, 4, 4}) == std::make_tuple(3, 3, 0));\n    }\n\n    SECTION(\"Last valid index\") {\n        REQUIRE(decompose(63, {4, 4, 4}) == std::make_tuple(3, 3, 3));\n    }\n\n    SECTION(\"Single dimension case\") {\n        REQUIRE(decompose(2, {5}) == std::make_tuple(2));\n    }\n\n    SECTION(\"Invalid cases\") {\n        // Test case 5: Out of bounds case (negative index)\n        REQUIRE_THROWS_AS(decompose(-1, {3, 4, 5}), std::out_of_range);\n\n        // Test case 6: Out of bounds case (index too large)\n        REQUIRE_THROWS_AS(decompose(100, {3, 4, 5}), std::out_of_range);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Decompose a flat index `n` into a multidimensional index based on the given shape.\n *\n * @param n Flat index (non-negative integer).\n * @param shape Tuple representing the dimensions of the multi-dimensional array.\n * @return std::tuple Decomposed multidimensional index corresponding to `n`.\n * @throw std::out_of_range If `n` is out of bounds for the array defined by `shape`.\n */\nstd::tuple<int, int> decompose(int n, const std::tuple<int, int>& shape){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Decompose a flat index `n` into a multidimensional index based on the given shape.\n *\n * @param n     Flat index (non-negative integer).\n * @param shape Array representing the dimensions of the multi-dimensional array.\n * @return      Array representing the multidimensional index corresponding to `n`.\n * @throws      IllegalArgumentException if `n` is out of bounds for the array defined by `shape`.\n */\npublic static int[] decompose(int n, int[] shape) throws IllegalArgumentException {\n    // Method implementation goes here\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\nimport java.util.Arrays;\n\npublic class Tester {\n\n    @Test\n    public void testDecompose() {\n        // Test case 1\n        int[] result = decompose(3, new int[]{2, 2});\n        assertArrayEquals(new int[]{0, 1}, result);\n\n        // Test case 2\n        result = decompose(5, new int[]{2, 3});\n        assertArrayEquals(new int[]{1, 2}, result);\n\n        // Test case 3\n        result = decompose(8, new int[]{2, 2, 2});\n        assertArrayEquals(new int[]{1, 0, 0}, result);\n\n        // Test case 4: Out of bounds\n        try {\n            decompose(9, new int[]{2, 2, 2});\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            assertEquals(\"Index out of bounds\", e.getMessage());\n        }\n    }\n\n    private int[] decompose(int n, int[] shape) {\n        if (n < 0 || n >= Arrays.stream(shape).reduce(1, (a, b) -> a * b)) {\n            throw new IllegalArgumentException(\"Index out of bounds\");\n        }\n\n        int[] result = new int[shape.length];\n        int size = 1;\n        for (int i = shape.length - 1; i >= 0; i--) {\n            result[i] = n / size % shape[i];\n            size *= shape[i];\n        }\n        return result;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Decompose a flat index `n` into a multidimensional index based on the given shape.\n *\n * @param n     Flat index (non-negative integer).\n * @param shape Array representing the dimensions of the multi-dimensional array.\n * @return      Array representing the multidimensional index corresponding to `n`.\n * @throws      IllegalArgumentException if `n` is out of bounds for the array defined by `shape`.\n */\npublic static int[] decompose(int n, int[] shape) throws IllegalArgumentException {\n    // Method implementation goes here\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 380, "code_type": "method", "original_language": "python", "file_path": "scripts\\9406f19eae2cf146a6a4ca06015eb4ce364d58ec\\time-converter\\time2s.py", "question_type": "Data processing and transformation", "summary": "Calculate the total number of seconds based on combinations of different time units (days, hours, minutes, seconds)\n", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef calculate_total_seconds(time: Tuple[int]):\n    \"\"\"\n    Calculate the total number of seconds given a tuple or list of time periods in the order of\n    days, hours, minutes, and seconds.\n\n    :param time: tuple or list, where\n        time[0] - number of days (optional)\n        time[1] - number of hours (optional)\n        time[2] - number of minutes (optional)\n        time[3] - number of seconds (optional)\n    :return: int, total number of seconds\n\n    Examples:\n        calculate_total_seconds([1, 2, 3, 4]) returns 93784\n        calculate_total_seconds([0, 2, 3]) returns 7380\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestCalculateTotalSeconds(unittest.TestCase):\n\n    def test_complete_time(self):\n        # Test with full values provided for days, hours, minutes, and seconds\n        time = [1, 2, 3, 4]  # 1 day, 2 hours, 3 minutes, 4 seconds\n        expected = 93784\n        result = calculate_total_seconds(time)\n        self.assertEqual(result, expected)\n\n    def test_partial_time(self):\n        # Test with some values missing (assumed trailing zeros)\n        time = [0, 2, 3]  # 0 days, 2 hours, 3 minutes\n        expected = 7380\n        result = calculate_total_seconds(time)\n        self.assertEqual(result, expected)\n\n    def test_seconds_only(self):\n        # Test with only seconds provided\n        time = [7200]  # 7200 seconds\n        expected = 622080000\n        result = calculate_total_seconds(time)\n        self.assertEqual(result, expected)\n\n    def test_no_time(self):\n        # Test with no time values provided\n        time = []\n        expected = 0\n        result = calculate_total_seconds(time)\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef calculate_total_seconds(time: Tuple[int]):\n    \"\"\"\n    Calculate the total number of seconds given a tuple or list of time periods in the order of\n    days, hours, minutes, and seconds.\n\n    :param time: tuple or list, where\n        time[0] - number of days (optional)\n        time[1] - number of hours (optional)\n        time[2] - number of minutes (optional)\n        time[3] - number of seconds (optional)\n    :return: int, total number of seconds\n\n    Examples:\n        calculate_total_seconds([1, 2, 3, 4]) returns 93784\n        calculate_total_seconds([0, 2, 3]) returns 7380\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the total number of seconds given a vector of time periods in the order of\n * days, hours, minutes, and seconds.\n *\n * @param time A vector where\n *     time[0] - number of days (optional)\n *     time[1] - number of hours (optional)\n *     time[2] - number of minutes (optional)\n *     time[3] - number of seconds (optional)\n * @return The total number of seconds as an integer.\n *\n * Examples:\n *     calculateTotalSeconds({1, 2, 3, 4}) returns 93784\n *     calculateTotalSeconds({0, 2, 3}) returns 7380\n */\nint calculate_total_seconds(const std::vector<int>& time) {\n\n}", "test_code": "TEST_CASE(\"Test calculate_total_seconds\", \"[calculate_total_seconds]\") {\n    SECTION(\"Test with full values provided for days, hours, minutes, and seconds\") {\n        std::vector<int> time = {1, 2, 3, 4};  // 1 day, 2 hours, 3 minutes, 4 seconds\n        int expected = 93784;\n        REQUIRE(calculate_total_seconds(time) == expected);\n    }\n\n    SECTION(\"Test with some values missing (assumed trailing zeros)\") {\n        std::vector<int> time = {0, 2, 3};  // 0 days, 2 hours, 3 minutes\n        int expected = 7380;\n        REQUIRE(calculate_total_seconds(time) == expected);\n    }\n\n    SECTION(\"Test with only seconds provided\") {\n        std::vector<int> time = {7200};  // 7200 seconds\n        int expected = 7200;  // Corrected expected value\n        REQUIRE(calculate_total_seconds(time) == expected);\n    }\n\n    SECTION(\"Test with no time values provided\") {\n        std::vector<int> time = {};  // Empty vector\n        int expected = 0;\n        REQUIRE(calculate_total_seconds(time) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the total number of seconds given a vector of time periods in the order of\n * days, hours, minutes, and seconds.\n *\n * @param time A vector where\n *     time[0] - number of days (optional)\n *     time[1] - number of hours (optional)\n *     time[2] - number of minutes (optional)\n *     time[3] - number of seconds (optional)\n * @return The total number of seconds as an integer.\n *\n * Examples:\n *     calculateTotalSeconds({1, 2, 3, 4}) returns 93784\n *     calculateTotalSeconds({0, 2, 3}) returns 7380\n */\nint calculate_total_seconds(const std::vector<int>& time) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate the total number of seconds given an array of time periods in the order of\n * days, hours, minutes, and seconds.\n *\n * @param time An array of integers, where\n *             time[0] - number of days (optional)\n *             time[1] - number of hours (optional)\n *             time[2] - number of minutes (optional)\n *             time[3] - number of seconds (optional)\n * @return The total number of seconds\n *\n * Examples:\n *     calculateTotalSeconds(new int[]{1, 2, 3, 4}) returns 93784\n *     calculateTotalSeconds(new int[]{0, 2, 3}) returns 7380\n */\npublic static int calculateTotalSeconds(int[] time) {\n    // Method implementation goes here...\n}", "test_code": "/**\n * Calculate the total number of seconds given a tuple or list of time periods in the order of\n * days, hours, minutes, and seconds.\n *\n * @param time array, where\n *             time[0] - number of days (optional)\n *             time[1] - number of hours (optional)\n *             time[2] - number of minutes (optional)\n *             time[3] - number of seconds (optional)\n * @return int, total number of seconds\n */\npublic static int calculateTotalSeconds(int[] time) {\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculate the total number of seconds given an array of time periods in the order of\n * days, hours, minutes, and seconds.\n *\n * @param time An array of integers, where\n *             time[0] - number of days (optional)\n *             time[1] - number of hours (optional)\n *             time[2] - number of minutes (optional)\n *             time[3] - number of seconds (optional)\n * @return The total number of seconds\n *\n * Examples:\n *     calculateTotalSeconds(new int[]{1, 2, 3, 4}) returns 93784\n *     calculateTotalSeconds(new int[]{0, 2, 3}) returns 7380\n */\npublic static int calculateTotalSeconds(int[] time) {\n    // Method implementation goes here...\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 381, "code_type": "method", "original_language": "python", "file_path": "pycookbook\\8599d1f263e1d8ca350196a147ad65dd92f6f78c\\emailparser.py\n", "question_type": "Data processing and transformation", "summary": "Extract the user name and mailbox suffix from the mailbox string, for example, extract xxx and gmail.com from xxx@gmail.com", "language_version_list": {"python": {"code_signature": "def extract_email_details(email: str):\n    \"\"\"\n    Extracts the username and mailbox suffix from an email address.eg extract_email_details(\"xxx@gmail.com\") returns ('xxx', 'gmail.com')\n    Args:\n        email (str): the email address to extract details from\n\n    Returns:\n        tuple: (username, domain)\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestExtractEmailDetails(unittest.TestCase):\n\n    def test_valid_email(self):\n        # Test with a typical email address\n        email = \"user@example.com\"\n        expected = (\"user\", \"example.com\")\n        result = extract_email_details(email)\n        self.assertEqual(result, expected)\n\n    def test_valid_email_with_subdomain(self):\n        # Test with an email that includes a subdomain\n        email = \"user@mail.office.com\"\n        expected = (\"user\", \"mail.office.com\")\n        result = extract_email_details(email)\n        self.assertEqual(result, expected)\n\n\n    def test_email_without_at_symbol(self):\n        # Test with an email that lacks an '@' symbol\n        email = \"userexample.com\"\n        with self.assertRaises(ValueError):\n            extract_email_details(email)\n\n    def test_empty_email(self):\n        # Test with an empty string as an email\n        email = \"\"\n        with self.assertRaises(ValueError):\n            extract_email_details(email)", "prompt": "please write a python function , the function signature as below def extract_email_details(email: str):\n    \"\"\"\n    Extracts the username and mailbox suffix from an email address.eg extract_email_details(\"xxx@gmail.com\") returns ('xxx', 'gmail.com')\n    Args:\n        email (str): the email address to extract details from\n\n    Returns:\n        tuple: (username, domain)\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "please write a cpp function , the function signature as below ", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 386, "code_type": "method", "original_language": "python", "file_path": "SoraTranslator\\5cb5566d66aa2c0312046710f42cf77ec6281795\\backend\\Integrators\\utils\\encoding_fix.py\n", "question_type": "File operations and I/O operation", "summary": "Converts the object file to the specified encoding format", "language_version_list": {"python": {"code_signature": "import shutil\n\n\ndef convert_encoding(input_file_path: str, output_file_path: str, original_encoding=\"cp932\",\n                     target_encoding=\"utf_16\") -> bool:\n    \"\"\"\n    This function converts the encoding of a file from one encoding to another\n\n    Parameters:\n        input_file_path (str): The path to the input file.\n        output_file_path (str): The path to the output file where the converted content is saved.\n        original_encoding (str): The original encoding of the file (default is cp932).\n        target_encoding (str): The target encoding to convert to (default is utf_16).\n\n    Returns:\n        bool: True if the conversion was successful, or if no conversion was needed; False otherwise.\n    \"\"\"\n", "test_code": "import unittest\nimport os\nimport shutil\nfrom io import open\n\nclass TestFixEncoding(unittest.TestCase):\n    def setUp(self):\n        # Create a directory for test files if it doesn't exist\n        self.test_dir = 'test_files'\n        os.makedirs(self.test_dir, exist_ok=True)\n        self.input_file_path = os.path.join(self.test_dir, 'test_input.txt')\n        self.output_file_path = os.path.join(self.test_dir, 'test_output.txt')\n\n    def tearDown(self):\n        # Remove test directory and all created files after each test\n        shutil.rmtree(self.test_dir)\n\n    def write_to_file(self, file_path, text, encoding):\n        # Helper method to write text to a file with a specific encoding\n        with open(file_path, 'w', encoding=encoding) as f:\n            f.write(text)\n\n    def test_basic_conversion(self):\n        # Test basic conversion from cp932 to utf_16\n        self.write_to_file(self.input_file_path, '\u3053\u308c\u306f\u30c6\u30b9\u30c8\u3067\u3059', 'cp932')\n        result = convert_encoding(self.input_file_path, self.output_file_path)\n        self.assertTrue(result)\n        with open(self.output_file_path, 'r', encoding='utf_16') as f:\n            self.assertEqual(f.read(), '\u3053\u308c\u306f\u30c6\u30b9\u30c8\u3067\u3059')\n\n    def test_no_conversion_needed(self):\n        # Test when no conversion is needed because file is already in target encoding\n        self.write_to_file(self.input_file_path, 'No conversion needed', 'utf_16')\n        result = convert_encoding(self.input_file_path, self.output_file_path, 'utf_16')\n        self.assertTrue(result)\n\n    def test_output_already_converted(self):\n        # Test behavior when file is already in target encoding and copied directly\n        self.write_to_file(self.input_file_path, 'Already utf_16', 'utf_16')\n        result = convert_encoding(self.input_file_path, self.output_file_path, 'cp932', 'utf_16')\n        self.assertTrue(result)", "prompt": "please write a python function , the function signature as below import shutil\n\n\ndef convert_encoding(input_file_path: str, output_file_path: str, original_encoding=\"cp932\",\n                     target_encoding=\"utf_16\") -> bool:\n    \"\"\"\n    This function converts the encoding of a file from one encoding to another\n\n    Parameters:\n        input_file_path (str): The path to the input file.\n        output_file_path (str): The path to the output file where the converted content is saved.\n        original_encoding (str): The original encoding of the file (default is cp932).\n        target_encoding (str): The target encoding to convert to (default is utf_16).\n\n    Returns:\n        bool: True if the conversion was successful, or if no conversion was needed; False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "please write a cpp function , the function signature as below ", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 390, "code_type": "method", "original_language": "python", "file_path": "dash-chatgpt-challenge\\6b5e530ee1e4d21b8bf7e78c2df7ca15293d0636\\demo_sentiment\\demo.py\n", "question_type": "Data processing and transformation", "summary": "Split the input text string into sentences", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef split_into_sentences(text:str) -> List[str]:\n    \"\"\"\n    Split the input text string into sentences.\n\n    Args:\n        text (str): The input text to be split into sentences.\n\n    Returns:\n        list: A list of sentences extracted from the input text, cleaned and stripped of leading/trailing whitespace.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSplitIntoSentences(unittest.TestCase):\n\n    def test_basic_splitting(self):\n        # Test splitting a basic text with clear punctuation\n        text = \"Hello world! How are you? I am fine.\"\n        expected = [\"Hello world!\", \"How are you?\", \"I am fine.\"]\n        result = split_into_sentences(text)\n        self.assertEqual(result, expected)\n\n    def test_complex_punctuation(self):\n        # Test splitting text that includes quotes and commas\n        text = 'He said, This is amazing! Then he left.'\n        expected = ['He said, This is amazing!', \"Then he left.\"]\n        result = split_into_sentences(text)\n        self.assertEqual(result, expected)\n\n    def test_with_no_punctuation(self):\n        # Test text that has no punctuation marks\n        text = \"Hello world how are you\"\n        expected = [\"Hello world how are you\"]\n        result = split_into_sentences(text)\n        self.assertEqual(result, expected)\n\n    def test_empty_string(self):\n        # Test empty string input\n        text = \"\"\n        expected = []\n        result = split_into_sentences(text)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef split_into_sentences(text:str) -> List[str]:\n    \"\"\"\n    Split the input text string into sentences.\n\n    Args:\n        text (str): The input text to be split into sentences.\n\n    Returns:\n        list: A list of sentences extracted from the input text, cleaned and stripped of leading/trailing whitespace.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "please write a cpp function , the function signature as below ", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 392, "code_type": "method", "original_language": "python", "file_path": "AoC\\2161e6aef7c480f3fb013dd9224ee014073097d6\\2015\\Day_10\\number.py\n", "question_type": "Algorithm and data structure", "summary": "Generates the next sequence in the 'look-and-say' sequence by reading off the digits of the given number,grouping by consecutive digits.", "language_version_list": {"python": {"code_signature": "def look_and_say(number: str):\n    \"\"\"\n    Generates the next sequence in the 'look-and-say' sequence by reading off the digits of the given number,\n    grouping by consecutive digits.\n\n    Args:\n        number (str): The current sequence as a string.\n\n    Returns:\n        str: The next sequence in the 'look-and-say' series.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestLookAndSay(unittest.TestCase):\n\n    def test_single_digit(self):\n        # Test with a single digit to see if it replicates correctly\n        self.assertEqual(look_and_say('1'), '11')\n\n    def test_repetitive_digits(self):\n        # Test a sequence of the same digits\n        self.assertEqual(look_and_say('111'), '31')\n\n    def test_mixed_digits(self):\n        # Test a sequence with different digits\n        self.assertEqual(look_and_say('1211'), '111221')\n\n    def test_complex_sequence(self):\n        # Test a more complex sequence\n        self.assertEqual(look_and_say('312211'), '13112221')\n", "prompt": "please write a python function , the function signature as below def look_and_say(number: str):\n    \"\"\"\n    Generates the next sequence in the 'look-and-say' sequence by reading off the digits of the given number,\n    grouping by consecutive digits.\n\n    Args:\n        number (str): The current sequence as a string.\n\n    Returns:\n        str: The next sequence in the 'look-and-say' series.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "please write a cpp function , the function signature as below ", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 395, "code_type": "method", "original_language": "python", "file_path": "advent-of-code-2023\\52c3e66ec60e675ab7963c812fb62177ce210a02\\day-01\\chat-gpt-pt1.py\n", "question_type": "File operations and I/O operation", "summary": "    Sums up calibration values extracted from the document.\n    Each calibration value is formed by combining the first and last digits of numbers found in each line\n    into a two-digit number.\n", "language_version_list": {"python": {"code_signature": "def sum_calibration_values(calibration_document) -> int:\n    \"\"\"\n    Sums up calibration values extracted from the document.\n    Each calibration value is formed by combining the first and last digits of numbers found in each line\n    into a two-digit number.\n\n    Args:\n        calibration_document (iterable): An iterable of strings, each representing a line of text.\n\n    Returns:\n        int: The total sum of all calibration values.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestSumCalibrationValues(unittest.TestCase):\n\n    def test_basic_calculations(self):\n        # Test with a simple input where lines contain at least two digits\n        document = [\n            \"Reading 1234 calibration\",\n            \"Measure 5678 complete\",\n            \"End of data 91011\"\n        ]\n        self.assertEqual(sum_calibration_values(document), 163)\n\n    def test_no_digits(self):\n        # Test lines with no digits\n        document = [\n            \"No numbers here\",\n            \"Still no numbers\"\n        ]\n        self.assertEqual(sum_calibration_values(document), 0)\n\n    def test_empty_lines(self):\n        # Test with empty lines or lines with spaces\n        document = [\n            \"\",\n            \"   \"\n        ]\n        self.assertEqual(sum_calibration_values(document), 0)\n\n    def test_mixed_content(self):\n        # Test with a mixture of valid and invalid lines\n        document = [\n            \"Good line 1524 end\",\n            \"Bad line\",\n            \"Another good line 7681\"\n        ]\n        self.assertEqual(sum_calibration_values(document), 85)", "prompt": "please write a python function , the function signature as below def sum_calibration_values(calibration_document) -> int:\n    \"\"\"\n    Sums up calibration values extracted from the document.\n    Each calibration value is formed by combining the first and last digits of numbers found in each line\n    into a two-digit number.\n\n    Args:\n        calibration_document (iterable): An iterable of strings, each representing a line of text.\n\n    Returns:\n        int: The total sum of all calibration values.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Sums up calibration values extracted from the document.\n * Each calibration value is formed by combining the first and last digits of numbers found in each line\n * into a two-digit number.\n *\n * @param calibrationDocument A vector of strings, each representing a line of text.\n * @return The total sum of all calibration values.\n */\nint sum_calibration_values(const std::vector<std::string>& calibrationDocument);", "test_code": "TEST_CASE(\"Test sum_calibration_values\", \"[sum_calibration_values]\") {\n    SECTION(\"test_basic_calculations\") {\n        // Test with a simple input where lines contain at least two digits\n        std::vector<std::string> document = {\n            \"Reading 1234 calibration\",\n            \"Measure 5678 complete\",\n            \"End of data 91011\"\n        };\n        REQUIRE(sum_calibration_values(document) == 163);\n    }\n\n    SECTION(\"test_no_digits\") {\n        // Test lines with no digits\n        std::vector<std::string> document = {\n            \"No numbers here\",\n            \"Still no numbers\"\n        };\n        REQUIRE(sum_calibration_values(document) == 0);\n    }\n\n    SECTION(\"test_empty_lines\") {\n        // Test with empty lines or lines with spaces\n        std::vector<std::string> document = {\n            \"\",\n            \"   \"\n        };\n        REQUIRE(sum_calibration_values(document) == 0);\n    }\n\n    SECTION(\"test_mixed_content\") {\n        // Test with a mixture of valid and invalid lines\n        std::vector<std::string> document = {\n            \"Good line 1524 end\",\n            \"Bad line\",\n            \"Another good line 7681\"\n        };\n        REQUIRE(sum_calibration_values(document) == 85);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Sums up calibration values extracted from the document.\n * Each calibration value is formed by combining the first and last digits of numbers found in each line\n * into a two-digit number.\n *\n * @param calibrationDocument A vector of strings, each representing a line of text.\n * @return The total sum of all calibration values.\n */\nint sum_calibration_values(const std::vector<std::string>& calibrationDocument);", "addition_info": ""}, "java": {"code_signature": "/**\n * Sums up calibration values extracted from the document.\n * Each calibration value is formed by combining the first and last digits of numbers found in each line\n * into a two-digit number.\n *\n * @param calibrationDocument an iterable of strings, each representing a line of text.\n * @return the total sum of all calibration values.\n */\npublic static int sumCalibrationValues(Iterable<String> calibrationDocument) {}", "test_code": "import static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testSumCalibrationValues() {\n        // Test data\n        String[] calibrationDocument = {\"1abc2\", \"3def4ghi5\"};\n        \n        // Call the method under test\n        int result = sumCalibrationValues(calibrationDocument);\n        \n        // Assert the expected outcome\n        assertEquals(100, result);  // Assuming that 12 + 45 should give 57\n    }\n\n    /**\n     * Sums up calibration values extracted from the document.\n     * Each calibration value is formed by combining the first and last digits of numbers found in each line\n     * into a two-digit number.\n     *\n     * @param calibrationDocument An array of strings, each representing a line of text.\n     * @return The total sum of all calibration values.\n     */\n    private int sumCalibrationValues(String[] calibrationDocument) {\n        int sum = 0;\n        for (String line : calibrationDocument) {\n            int firstDigit = Character.getNumericValue(line.charAt(0));\n            int lastDigit = Character.getNumericValue(line.charAt(line.length() - 1));\n            sum += firstDigit * 10 + lastDigit;\n        }\n        return sum;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Sums up calibration values extracted from the document.\n * Each calibration value is formed by combining the first and last digits of numbers found in each line\n * into a two-digit number.\n *\n * @param calibrationDocument an iterable of strings, each representing a line of text.\n * @return the total sum of all calibration values.\n */\npublic static int sumCalibrationValues(Iterable<String> calibrationDocument) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 396, "code_type": "method", "original_language": "python", "file_path": "compprog\\be5d4a09aa5297c9afc2ef85baa61b3732149a5b\\abc\\abc354\\f\\chatgpt.py\n", "question_type": "Algorithm and data structure", "summary": "Given an array of integers nums, find the length of the longest strictly increasing subsequence in it", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef length_of_LIS(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the length of the longest strictly increasing subsequence in it\n\n    Args:\n        nums (List[int]): int array\n\n    Returns:\n        int: longest strictly increasing subsequence\n    \"\"\"", "test_code": "import unittest\nfrom typing import List\n\nclass TestLengthOfLIS(unittest.TestCase):\n\n    def test_empty_list(self):\n        # Test the function with an empty list\n        self.assertEqual(length_of_LIS([]), 0)\n\n    def test_single_element(self):\n        # Test with a list containing only one element\n        self.assertEqual(length_of_LIS([7]), 1)\n\n    def test_increasing_sequence(self):\n        # Test with a list where the elements are strictly increasing\n        self.assertEqual(length_of_LIS([1, 2, 3, 4, 5]), 5)\n\n    def test_decreasing_sequence(self):\n        # Test with a list where the elements are strictly decreasing\n        self.assertEqual(length_of_LIS([5, 4, 3, 2, 1]), 1)\n\n    def test_complex_sequence(self):\n        # Test with a complex sequence with mix of increasing and decreasing elements\n        self.assertEqual(length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]), 4)\n\n    def test_all_equal_elements(self):\n        # Test with all elements in the list being equal\n        self.assertEqual(length_of_LIS([2, 2, 2, 2]), 1)\n\n    def test_with_negative_numbers(self):\n        # Test with a mix of negative and positive numbers\n        self.assertEqual(length_of_LIS([-1, -2, -3, 0, 1, 2]), 4)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef length_of_LIS(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the length of the longest strictly increasing subsequence in it\n\n    Args:\n        nums (List[int]): int array\n\n    Returns:\n        int: longest strictly increasing subsequence\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds the length of the longest strictly increasing subsequence in a given array of integers.\n *\n * @param nums The input array of integers.\n * @return The length of the longest strictly increasing subsequence.\n */\nint length_of_lis(const std::vector<int>& nums);", "test_code": "TEST_CASE(\"Test Length of LIS\", \"[LIS]\") {\n    SECTION(\"Empty list\") {\n        REQUIRE(length_of_LIS({}) == 0);\n    }\n\n    SECTION(\"Single element\") {\n        REQUIRE(length_of_lis({7}) == 1);\n    }\n\n    SECTION(\"Strictly increasing sequence\") {\n        REQUIRE(length_of_lis({1, 2, 3, 4, 5}) == 5);\n    }\n\n    SECTION(\"Strictly decreasing sequence\") {\n        REQUIRE(length_of_lis({5, 4, 3, 2, 1}) == 1);\n    }\n\n    SECTION(\"Complex sequence\") {\n        REQUIRE(length_of_lis({10, 9, 2, 5, 3, 7, 101, 18}) == 4);\n    }\n\n    SECTION(\"All equal elements\") {\n        REQUIRE(length_of_lis({2, 2, 2, 2}) == 1);\n    }\n\n    SECTION(\"With negative numbers\") {\n        REQUIRE(length_of_lis({-1, -2, -3, 0, 1, 2}) == 4);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds the length of the longest strictly increasing subsequence in a given array of integers.\n *\n * @param nums The input array of integers.\n * @return The length of the longest strictly increasing subsequence.\n */\nint length_of_lis(const std::vector<int>& nums);", "addition_info": ""}, "java": {"code_signature": "/**\n * Given an array of integers nums, find the length of the longest strictly increasing subsequence in it.\n *\n * @param nums the input integer list\n * @return the length of the longest strictly increasing subsequence\n */\npublic int lengthOfLIS(List<Integer> nums) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testLengthOfLIS() {\n        // Test case 1\n        int[] nums1 = {10, 9, 2, 5, 3, 7, 101, 18};\n        assertEquals(4, lengthOfLIS(nums1), \"Test case 1 failed\");\n\n        // Test case 2\n        int[] nums2 = {0, 1, 0, 3, 2, 3};\n        assertEquals(4, lengthOfLIS(nums2), \"Test case 2 failed\");\n\n        // Test case 3\n        int[] nums3 = {7, 7, 7, 7, 7, 7, 7};\n        assertEquals(1, lengthOfLIS(nums3), \"Test case 3 failed\");\n\n        // Test case 4\n        int[] nums4 = {};\n        assertEquals(0, lengthOfLIS(nums4), \"Test case 4 failed\");\n\n        // Test case 5\n        int[] nums5 = {1};\n        assertEquals(1, lengthOfLIS(nums5), \"Test case 5 failed\");\n    }\n\n    private int lengthOfLIS(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        \n        int n = nums.length;\n        int[] dp = new int[n];\n        int maxLength = 1;\n\n        for (int i = 0; i < n; i++) {\n            dp[i] = 1;\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n            maxLength = Math.max(maxLength, dp[i]);\n        }\n\n        return maxLength;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Given an array of integers nums, find the length of the longest strictly increasing subsequence in it.\n *\n * @param nums the input integer list\n * @return the length of the longest strictly increasing subsequence\n */\npublic int lengthOfLIS(List<Integer> nums) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 398, "code_type": "method", "original_language": "python", "file_path": "python-sample\\2b6587f7a16471244cc9e8cca58ac4f2d2a92d51\\3.Extract files not in the csv.py\n", "question_type": "Data processing and transformation", "summary": "Copy files from folderA to folderB excluding those listed in the specified CSV file ", "language_version_list": {"python": {"code_signature": "import os\nimport csv\nimport shutil\n\n\ndef extract_files_excluding_csv(folderA: str, csv_file: str, folderB: str):\n    \"\"\"\n    Copy files from folderA to folderB excluding those listed in the specified CSV file.\n\n    Args:\n        folderA: Path to the source folder containing all files (str).\n        csv_file: Path to the CSV file containing filenames to exclude (str).\n        folderB: Path to the destination folder (str).\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import os\nimport shutil\nimport unittest\n\n\nclass TestExtractFiles(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up test directories and files before each test case.\"\"\"\n        self.folderA = \"test_folderA\"\n        self.folderB = \"test_folderB\"\n        os.makedirs(self.folderA, exist_ok=True)\n        os.makedirs(self.folderB, exist_ok=True)\n\n    def tearDown(self):\n        \"\"\"Clean up the test directories after each test case.\"\"\"\n        shutil.rmtree(self.folderA)\n        shutil.rmtree(self.folderB)\n\n    def create_csv(self, filename_list):\n        \"\"\"Helper method to create a CSV file for testing.\"\"\"\n        csv_file = \"test_exclude.csv\"\n        with open(csv_file, \"w\", newline='') as file:\n            writer = csv.writer(file)\n            writer.writerow([\"filename\"])  # Write header\n            for name in filename_list:\n                writer.writerow([name])\n        return csv_file\n\n    def test_basic_functionality(self):\n        \"\"\"Test basic functionality with some files excluded.\"\"\"\n        with open(os.path.join(self.folderA, \"file1.txt\"), \"w\") as f:\n            f.write(\"Content of file 1\")\n        with open(os.path.join(self.folderA, \"file2.txt\"), \"w\") as f:\n            f.write(\"Content of file 2\")\n        with open(os.path.join(self.folderA, \"file3.txt\"), \"w\") as f:\n            f.write(\"Content of file 3\")\n\n        csv_file = self.create_csv([\"file2.txt\"])  # Exclude file2.txt\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"file1.txt\")))\n        self.assertFalse(os.path.exists(os.path.join(self.folderB, \"file2.txt\")))\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"file3.txt\")))\n\n    def test_empty_folderA(self):\n        \"\"\"Test when folderA is empty.\"\"\"\n        csv_file = self.create_csv([\"file1.txt\"])  # Exclude file1.txt\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        self.assertEqual(len(os.listdir(self.folderB)), 0)\n\n    def test_all_files_excluded(self):\n        \"\"\"Test when all files are excluded.\"\"\"\n        with open(os.path.join(self.folderA, \"file1.txt\"), \"w\") as f:\n            f.write(\"Content of file 1\")\n        with open(os.path.join(self.folderA, \"file2.txt\"), \"w\") as f:\n            f.write(\"Content of file 2\")\n\n        csv_file = self.create_csv([\"file1.txt\", \"file2.txt\"])  # Exclude all files\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        self.assertEqual(len(os.listdir(self.folderB)), 0)\n\n    def test_destination_folder_already_has_files(self):\n        \"\"\"Test when folderB already contains files.\"\"\"\n        with open(os.path.join(self.folderB, \"existing_file.txt\"), \"w\") as f:\n            f.write(\"This is an existing file.\")\n\n        with open(os.path.join(self.folderA, \"file1.txt\"), \"w\") as f:\n            f.write(\"Content of file 1\")\n\n        csv_file = self.create_csv([])  # Do not exclude any files\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        # Check if both existing and new files are present\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"existing_file.txt\")))\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"file1.txt\")))\n\n    def test_empty_csv_file(self):\n        \"\"\"Test with an empty CSV file.\"\"\"\n        with open(os.path.join(self.folderA, \"file1.txt\"), \"w\") as f:\n            f.write(\"Content of file 1\")\n\n        csv_file = self.create_csv([])  # Empty CSV, do not exclude any files\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"file1.txt\")))", "prompt": "please write a python function , the function signature as below import os\nimport csv\nimport shutil\n\n\ndef extract_files_excluding_csv(folderA: str, csv_file: str, folderB: str):\n    \"\"\"\n    Copy files from folderA to folderB excluding those listed in the specified CSV file.\n\n    Args:\n        folderA: Path to the source folder containing all files (str).\n        csv_file: Path to the CSV file containing filenames to exclude (str).\n        folderB: Path to the destination folder (str).\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 401, "code_type": "method", "original_language": "python", "file_path": "bitbox-wallet-app\\e6706873ef4ea1ad9332009fd01b82c076e71416\\scripts\\check-locize-placeholders.py\n", "question_type": "Data processing and transformation", "summary": "Find a placeholder in the format {{ placeholder }}} from the string and return a list of all matching placeholders\n", "language_version_list": {"python": {"code_signature": "import re\n\ndef find_placeholders(text):\n    \"\"\"\n    Find and return a list of all placeholders in the format {{ placeholder }} from the input text.\n\n    Args:\n        text (str): The input string containing potential placeholders.\n\n    Returns:\n        list: A list of matching placeholders.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFindPlaceholders(unittest.TestCase):\n\n    def test_multiple_placeholders(self):\n        \"\"\"Test string with multiple placeholders.\"\"\"\n        input_text = \"Here are some placeholders: {{ placeholder1 }}, {{ placeholder2 }}, and {{ placeholder3 }}.\"\n        expected_output = ['placeholder1', 'placeholder2', 'placeholder3']\n        self.assertEqual(find_placeholders(input_text), expected_output)\n\n    def test_no_placeholders(self):\n        \"\"\"Test string with no placeholders.\"\"\"\n        input_text = \"This string has no placeholders.\"\n        expected_output = []\n        self.assertEqual(find_placeholders(input_text), expected_output)\n\n    def test_single_placeholder(self):\n        \"\"\"Test string with a single placeholder.\"\"\"\n        input_text = \"The only placeholder is {{ singlePlaceholder }}.\"\n        expected_output = ['singlePlaceholder']\n        self.assertEqual(find_placeholders(input_text), expected_output)\n\n    def test_placeholder_with_spaces(self):\n        \"\"\"Test string with placeholders that have extra spaces.\"\"\"\n        input_text = \"Placeholders with spaces: {{  placeholder_with_spaces  }} and {{ placeholder2 }}.\"\n        expected_output = ['placeholder_with_spaces', 'placeholder2']\n        self.assertEqual(find_placeholders(input_text), expected_output)\n", "prompt": "please write a python function , the function signature as below import re\n\ndef find_placeholders(text):\n    \"\"\"\n    Find and return a list of all placeholders in the format {{ placeholder }} from the input text.\n\n    Args:\n        text (str): The input string containing potential placeholders.\n\n    Returns:\n        list: A list of matching placeholders.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Find and return a list of all placeholders in the format {{ placeholder }} from the input text.\n *\n * @param text The input string containing potential placeholders.\n * @return std::vector<std::string> A vector of matching placeholders.\n */\nstd::vector<std::string> find_placeholders(const std::string& text) {}", "test_code": "TEST_CASE(\"Test find_placeholders function\", \"[find_placeholders]\") {\n    SECTION(\"Test string with multiple placeholders\") {\n        std::string input_text = \"Here are some placeholders: {{ placeholder1 }}, {{ placeholder2 }}, and {{ placeholder3 }}.\";\n        std::vector<std::string> expected_output = {\"placeholder1\", \"placeholder2\", \"placeholder3\"};\n        REQUIRE(find_placeholders(input_text) == expected_output);\n    }\n\n    SECTION(\"Test string with no placeholders\") {\n        std::string input_text = \"This string has no placeholders.\";\n        std::vector<std::string> expected_output = {};\n        REQUIRE(find_placeholders(input_text) == expected_output);\n    }\n\n    SECTION(\"Test string with a single placeholder\") {\n        std::string input_text = \"The only placeholder is {{ singlePlaceholder }}.\";\n        std::vector<std::string> expected_output = {\"singlePlaceholder\"};\n        REQUIRE(find_placeholders(input_text) == expected_output);\n    }\n\n    SECTION(\"Test string with placeholders that have extra spaces\") {\n        std::string input_text = \"Placeholders with spaces: {{  placeholder_with_spaces  }} and {{ placeholder2 }}.\";\n        std::vector<std::string> expected_output = {\"placeholder_with_spaces\", \"placeholder2\"};\n        REQUIRE(find_placeholders(input_text) == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Find and return a list of all placeholders in the format {{ placeholder }} from the input text.\n *\n * @param text The input string containing potential placeholders.\n * @return std::vector<std::string> A vector of matching placeholders.\n */\nstd::vector<std::string> find_placeholders(const std::string& text) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds and returns a list of all placeholders in the format {{ placeholder }} from the input text.\n *\n * @param text the input string containing potential placeholders\n * @return a list of matching placeholders\n */\npublic List<String> findPlaceholders(String text) {}", "test_code": "package org.real.temp;\n\nimport junit.framework.TestCase;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Tester extends TestCase {\n\n    // Assuming you have a method that needs testing, for example, findPlaceholders\n    public void testFindPlaceholders() {\n        String inputText = \"This is a sample text with placeholders like {{ name }}, {{ age }}, and {{ address }}.\";\n        List<String> expectedPlaceholders = new ArrayList<>();\n        expectedPlaceholders.add(\"{{ name }}\");\n        expectedPlaceholders.add(\"{{ age }}\");\n        expectedPlaceholders.add(\"{{ address }}\");\n\n        List<String> actualPlaceholders = findPlaceholders(inputText);\n\n        assertEquals(expectedPlaceholders.size(), actualPlaceholders.size());\n        for (String expected : expectedPlaceholders) {\n            assertTrue(actualPlaceholders.contains(expected));\n        }\n    }\n\n    private List<String> findPlaceholders(String text) {\n        Pattern pattern = Pattern.compile(\"\\\\{\\\\{\\\\s*([a-zA-Z0-9_]+)\\\\s*\\\\}\\\\}\");\n        Matcher matcher = pattern.matcher(text);\n        List<String> placeholders = new ArrayList<>();\n\n        while (matcher.find()) {\n            placeholders.add(matcher.group(1));\n        }\n\n        return placeholders;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds and returns a list of all placeholders in the format {{ placeholder }} from the input text.\n *\n * @param text the input string containing potential placeholders\n * @return a list of matching placeholders\n */\npublic List<String> findPlaceholders(String text) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 404, "code_type": "method", "original_language": "python", "file_path": "dengjunhui-data-structure\\f54a9a850704302a6eb3d0eb2660149563346007\\src\\fibonacci\\matrix_exponentiation.py\n", "question_type": "Data processing and transformation", "summary": "Computes the n-th power of a matrix using the fast exponentiation method.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef power(matrix: List[List[int]], n: int) -> List[List[int]]:\n    \"\"\"\n    Computes the n-th power of a matrix using the fast exponentiation method.\n\n    Args:\n        matrix (List[List[int]]): A square matrix to be exponentiated.\n        n (int): The exponent to raise the matrix to. Must be a non-negative integer.\n\n    Returns:\n        List[List[int]]: The matrix raised to the power of n.\n\n    Raises:\n        ValueError: If n is negative.\n        TypeError: If matrix is not a list of lists or n is not an integer.\n    \"\"\"", "test_code": "import unittest\n\nclass TestMatrixPower(unittest.TestCase):\n\n    def test_identity_matrix(self):\n        # Testing the power function with an identity matrix\n        matrix = [[1, 0], [0, 1]]\n        expected = [[1, 0], [0, 1]]\n        result = power(matrix, 1)\n        self.assertEqual(result, expected)\n\n    def test_zero_power(self):\n        # Testing matrix to the power of zero (should return identity)\n        matrix = [[2, 3], [1, 4]]\n        expected = [[1, 0], [0, 1]]\n        result = power(matrix, 0)\n        self.assertEqual(result, expected)\n\n    def test_positive_power(self):\n        # Testing matrix to a positive power\n        matrix = [[2, 1], [1, 3]]\n        expected = [[5, 5], [5, 10]]  # This is the result of matrix^2\n        result = power(matrix, 2)\n        self.assertEqual(result, expected)\n\n    def test_negative_power(self):\n        # Testing matrix to a negative power (should raise ValueError)\n        matrix = [[2, 1], [1, 3]]\n        with self.assertRaises(ValueError):\n            power(matrix, -1)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef power(matrix: List[List[int]], n: int) -> List[List[int]]:\n    \"\"\"\n    Computes the n-th power of a matrix using the fast exponentiation method.\n\n    Args:\n        matrix (List[List[int]]): A square matrix to be exponentiated.\n        n (int): The exponent to raise the matrix to. Must be a non-negative integer.\n\n    Returns:\n        List[List[int]]: The matrix raised to the power of n.\n\n    Raises:\n        ValueError: If n is negative.\n        TypeError: If matrix is not a list of lists or n is not an integer.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Computes the n-th power of a matrix using the fast exponentiation method.\n *\n * @param matrix A square matrix to be exponentiated.\n * @param n The exponent to raise the matrix to. Must be a non-negative integer.\n * @return The matrix raised to the power of n.\n * @throw std::invalid_argument if n is negative.\n * @throw std::invalid_argument if matrix is not a square matrix.\n */\nstd::vector<std::vector<int>> power(const std::vector<std::vector<int>>& matrix, int n);", "test_code": "TEST_CASE(\"Test Matrix Power\", \"[matrix_power]\") {\n    SECTION(\"Identity Matrix\") {\n        // Testing the power function with an identity matrix\n        std::vector<std::vector<int>> matrix = {{1, 0}, {0, 1}};\n        std::vector<std::vector<int>> expected = {{1, 0}, {0, 1}};\n        auto result = power(matrix, 1);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Zero Power\") {\n        // Testing matrix to the power of zero (should return identity)\n        std::vector<std::vector<int>> matrix = {{2, 3}, {1, 4}};\n        std::vector<std::vector<int>> expected = {{1, 0}, {0, 1}};\n        auto result = power(matrix, 0);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Positive Power\") {\n        // Testing matrix to a positive power\n        std::vector<std::vector<int>> matrix = {{2, 1}, {1, 3}};\n        std::vector<std::vector<int>> expected = {{5, 5}, {5, 10}};  // This is the result of matrix^2\n        auto result = power(matrix, 2);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Negative Power\") {\n        // Testing matrix to a negative power (should throw std::invalid_argument)\n        std::vector<std::vector<int>> matrix = {{2, 1}, {1, 3}};\n        REQUIRE_THROWS_AS(power(matrix, -1), std::invalid_argument);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Computes the n-th power of a matrix using the fast exponentiation method.\n *\n * @param matrix A square matrix to be exponentiated.\n * @param n The exponent to raise the matrix to. Must be a non-negative integer.\n * @return The matrix raised to the power of n.\n * @throw std::invalid_argument if n is negative.\n * @throw std::invalid_argument if matrix is not a square matrix.\n */\nstd::vector<std::vector<int>> power(const std::vector<std::vector<int>>& matrix, int n);", "addition_info": ""}, "java": {"code_signature": "/**\n * Computes the n-th power of a matrix using the fast exponentiation method.\n *\n * @param matrix A square matrix to be exponentiated.\n * @param n      The exponent to raise the matrix to. Must be a non-negative integer.\n * @return The matrix raised to the power of n.\n * @throws IllegalArgumentException if n is negative.\n * @throws ClassCastException     if matrix is not a list of lists or n is not an integer.\n */\npublic static List<List<Integer>> power(List<List<Integer>> matrix, int n) {}", "test_code": "import static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testNegativeExponent() {\n        int[][] matrix = {{1, 2}, {3, 4}};\n        MatrixPower.power(matrix, -1);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testNonIntegerExponent() {\n        int[][] matrix = {{1, 2}, {3, 4}};\n        MatrixPower.power(matrix, 1.5);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testNonMatrixInput() {\n        Object[] input = {\"not\", \"a\", \"matrix\"};\n        MatrixPower.power(input, 2);\n    }\n    \n    // Add more tests for other scenarios...\n}", "prompt": "please write a java function , the function signature as below /**\n * Computes the n-th power of a matrix using the fast exponentiation method.\n *\n * @param matrix A square matrix to be exponentiated.\n * @param n      The exponent to raise the matrix to. Must be a non-negative integer.\n * @return The matrix raised to the power of n.\n * @throws IllegalArgumentException if n is negative.\n * @throws ClassCastException     if matrix is not a list of lists or n is not an integer.\n */\npublic static List<List<Integer>> power(List<List<Integer>> matrix, int n) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 405, "code_type": "method", "original_language": "python", "file_path": "redditSidebarUpdater\\8faf879dbfb8dcd51bc536ff4c1f66128e22b03b\\src\\redditSidebarUpdater_Playoffs.py\n", "question_type": "Data processing and transformation", "summary": "Remove the part before the first upper case letter and the first lower case letter from the string", "language_version_list": {"python": {"code_signature": "def remove_parts_of_string(*strings):\n    \"\"\"\n    Remove the part before the first upper case letter and the first lower case letter from the string\n\n    For example:\n        input: 1234AbCde5678\n        output: AbCde5678\n    Args:\n        *strings: Accepts one or more strings as variable arguments\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestRemovePartsOfString(unittest.TestCase):\n\n    def test_case_3(self):\n        # Test with a string that has no uppercase letters\n        result = remove_parts_of_string(\"abcdefg\")\n        self.assertEqual(result, [\"abcdefg\"])\n\n    def test_case_4(self):\n        # Test with a string that has no lowercase letters\n        result = remove_parts_of_string(\"ABCDEFG\")\n        self.assertEqual(result, [\"ABCDEFG\"])\n\n    def test_case_5(self):\n        # Test with a string that has mixed cases\n        result = remove_parts_of_string(\"1234AbCde5678\")\n        self.assertEqual(result, [\"AbCde5678\"])\n\n    def test_case_6(self):\n        # Test with an empty string\n        result = remove_parts_of_string(\"\")\n        self.assertEqual(result, [\"\"])\n\n    def test_case_7(self):\n        # Test with a string that has only one uppercase letter\n        result = remove_parts_of_string(\"X\")\n        self.assertEqual(result, [\"X\"])\n\n    def test_case_8(self):\n        # Test with a string that has only one lowercase letter\n        result = remove_parts_of_string(\"y\")\n        self.assertEqual(result, [\"y\"])\n", "prompt": "please write a python function , the function signature as below def remove_parts_of_string(*strings):\n    \"\"\"\n    Remove the part before the first upper case letter and the first lower case letter from the string\n\n    For example:\n        input: 1234AbCde5678\n        output: AbCde5678\n    Args:\n        *strings: Accepts one or more strings as variable arguments\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Removes the part before the first uppercase letter and the first lowercase letter from each string.\n *\n * Example:\n *     Input: \"1234AbCde5678\"\n *     Output: \"AbCde5678\"\n *\n * @param strings A vector of strings to be processed.\n * @return A vector of strings after processing.\n */\nstd::vector<std::string> remove_parts_of_string(const std::vector<std::string>& strings);", "test_code": "TEST_CASE(\"Test remove_parts_of_string function\") {\n    SECTION(\"Test with a string that has no uppercase letters\") {\n        std::vector<std::string> input = {\"abcdefg\"};\n        std::vector<std::string> expected = {\"abcdefg\"};\n        REQUIRE(remove_parts_of_string(input) == expected);\n    }\n\n    SECTION(\"Test with a string that has no lowercase letters\") {\n        std::vector<std::string> input = {\"ABCDEFG\"};\n        std::vector<std::string> expected = {\"ABCDEFG\"};\n        REQUIRE(remove_parts_of_string(input) == expected);\n    }\n\n    SECTION(\"Test with a string that has mixed cases\") {\n        std::vector<std::string> input = {\"1234AbCde5678\"};\n        std::vector<std::string> expected = {\"AbCde5678\"};\n        REQUIRE(remove_parts_of_string(input) == expected);\n    }\n\n    SECTION(\"Test with an empty string\") {\n        std::vector<std::string> input = {\"\"};\n        std::vector<std::string> expected = {\"\"};\n        REQUIRE(remove_parts_of_string(input) == expected);\n    }\n\n    SECTION(\"Test with a string that has only one uppercase letter\") {\n        std::vector<std::string> input = {\"X\"};\n        std::vector<std::string> expected = {\"X\"};\n        REQUIRE(remove_parts_of_string(input) == expected);\n    }\n\n    SECTION(\"Test with a string that has only one lowercase letter\") {\n        std::vector<std::string> input = {\"y\"};\n        std::vector<std::string> expected = {\"y\"};\n        REQUIRE(remove_parts_of_string(input) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Removes the part before the first uppercase letter and the first lowercase letter from each string.\n *\n * Example:\n *     Input: \"1234AbCde5678\"\n *     Output: \"AbCde5678\"\n *\n * @param strings A vector of strings to be processed.\n * @return A vector of strings after processing.\n */\nstd::vector<std::string> remove_parts_of_string(const std::vector<std::string>& strings);", "addition_info": ""}, "java": {"code_signature": "/**\n * Removes the part before the first uppercase letter and the first lowercase letter from the string.\n *\n * For example:\n *     Input: 1234AbCde5678\n *     Output: AbCde5678\n *\n * @param strings Accepts one or more strings as variable arguments.\n */\npublic class StringManipulator {\n\n    public static void main(String[] args) {\n        // Example usage\n        System.out.println(removePartsOfString(\"1234AbCde5678\")); // Output: AbCde5678\n    }\n\n    /**\n     * Removes the part before the first uppercase letter and the first lowercase letter from the string.\n     *\n     * @param strings Variable number of strings to process.\n     * @return The modified string.\n     */\n    public static String removePartsOfString(String... strings) {}\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testRemovePartsOfString() {\n        // Test case 1\n        assertEquals(\"AbCde5678\", removePartsOfStrings(\"1234AbCde5678\"));\n\n        // Test case 2\n        assertEquals(\"HelloWorld\", removePartsOfStrings(\"HelloWorld\"));\n\n        // Test case 3\n        assertEquals(\"JavaIsFun\", removePartsOfStrings(\"JavaIsFun\"));\n\n        // Test case 4\n        assertEquals(\"\", removePartsOfStrings(\"1234567890\"));\n\n        // Test case 5\n        assertEquals(\"\", removePartsOfStrings(\"!@#$%^&*()_+\"));\n\n        // Test case 6\n        assertEquals(\"ABCD\", removePartsOfStrings(\"ABCD\"));\n    }\n\n    private String removePartsOfStrings(String... strings) {\n        if (strings == null || strings.length == 0) {\n            return \"\";\n        }\n\n        String input = strings[0];\n        int startIndex = -1;\n        int endIndex = -1;\n\n        for (int i = 0; i < input.length(); i++) {\n            char c = input.charAt(i);\n            if (Character.isUpperCase(c)) {\n                startIndex = i;\n            } else if (Character.isLowerCase(c)) {\n                endIndex = i;\n                break;\n            }\n        }\n\n        if (startIndex == -1 || endIndex == -1) {\n            return input;\n        }\n\n        return input.substring(startIndex, endIndex + 1);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Removes the part before the first uppercase letter and the first lowercase letter from the string.\n *\n * For example:\n *     Input: 1234AbCde5678\n *     Output: AbCde5678\n *\n * @param strings Accepts one or more strings as variable arguments.\n */\npublic class StringManipulator {\n\n    public static void main(String[] args) {\n        // Example usage\n        System.out.println(removePartsOfString(\"1234AbCde5678\")); // Output: AbCde5678\n    }\n\n    /**\n     * Removes the part before the first uppercase letter and the first lowercase letter from the string.\n     *\n     * @param strings Variable number of strings to process.\n     * @return The modified string.\n     */\n    public static String removePartsOfString(String... strings) {}\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 406, "code_type": "class", "original_language": "python", "file_path": "autogit\\ba45731233991817239e8116a024edb962dc602e\\autogit\\utils.py\n", "question_type": "Data processing and transformation", "summary": "Implement a colors class that prints strings in color", "language_version_list": {"python": {"code_signature": "class Colors:\n\n    @staticmethod\n    def red(text: str) -> str:\n        \"\"\"text in red color\"\"\"\n        pass\n\n    @staticmethod\n    def green(text: str) -> str:\n        \"\"\"text in green color\"\"\"\n\n    @staticmethod\n    def blue(text: str) -> str:\n        \"\"\"text in blue color\"\"\"\n\n    @staticmethod\n    def yellow(text: str) -> str:\n        \"\"\"text in yellow color\"\"\"\n\n    @staticmethod\n    def magenta(text: str) -> str:\n        \"\"\"text in magenta color\"\"\"\n\n    @staticmethod\n    def cyan(text: str) -> str:\n        \"\"\"text in cyan color\"\"\"\n", "test_code": "import unittest\n\nclass TestColors(unittest.TestCase):\n\n    def test_red(self):\n        \"\"\"Test the red color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[91mHello\\033[0m\"\n        self.assertEqual(Colors.red(input_text), expected_output)\n\n    def test_green(self):\n        \"\"\"Test the green color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[92mHello\\033[0m\"\n        self.assertEqual(Colors.green(input_text), expected_output)\n\n    def test_blue(self):\n        \"\"\"Test the blue color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[94mHello\\033[0m\"\n        self.assertEqual(Colors.blue(input_text), expected_output)\n\n    def test_yellow(self):\n        \"\"\"Test the yellow color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[93mHello\\033[0m\"\n        self.assertEqual(Colors.yellow(input_text), expected_output)\n\n    def test_magenta(self):\n        \"\"\"Test the magenta color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[95mHello\\033[0m\"\n        self.assertEqual(Colors.magenta(input_text), expected_output)\n\n    def test_cyan(self):\n        \"\"\"Test the cyan color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[96mHello\\033[0m\"\n        self.assertEqual(Colors.cyan(input_text), expected_output)\n\n    def test_combined_colors(self):\n        \"\"\"Test combining different color methods\"\"\"\n        input_text_red = Colors.red(\"Red\")\n        input_text_blue = Colors.blue(\"Blue\")\n        input_text_combined = f\"{input_text_red} and {input_text_blue}\"\n        expected_output = \"\\033[91mRed\\033[0m and \\033[94mBlue\\033[0m\"\n        self.assertEqual(input_text_combined, expected_output)\n", "prompt": "please write a python class , the class signature as below class Colors:\n\n    @staticmethod\n    def red(text: str) -> str:\n        \"\"\"text in red color\"\"\"\n        pass\n\n    @staticmethod\n    def green(text: str) -> str:\n        \"\"\"text in green color\"\"\"\n\n    @staticmethod\n    def blue(text: str) -> str:\n        \"\"\"text in blue color\"\"\"\n\n    @staticmethod\n    def yellow(text: str) -> str:\n        \"\"\"text in yellow color\"\"\"\n\n    @staticmethod\n    def magenta(text: str) -> str:\n        \"\"\"text in magenta color\"\"\"\n\n    @staticmethod\n    def cyan(text: str) -> str:\n        \"\"\"text in cyan color\"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "class Colors {\npublic:\n    // Function to return text in red color\n    static std::string red(const std::string& text);\n\n    // Function to return text in green color\n    static std::string green(const std::string& text);\n\n    // Function to return text in blue color\n    static std::string blue(const std::string& text);\n\n    // Function to return text in yellow color\n    static std::string yellow(const std::string& text);\n\n    // Function to return text in magenta color\n    static std::string magenta(const std::string& text);\n\n    // Function to return text in cyan color\n    static std::string cyan(const std::string& text);\n};\n\n// Implementation of each function (you can add actual implementation here)\nstd::string Colors::red(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[31m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::green(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[32m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::blue(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[34m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::yellow(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[33m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::magenta(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[35m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::cyan(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[36m\" + text + \"\\033[0m\";\n}", "test_code": "TEST_CASE(\"Test Colors\", \"[Colors]\") {\n    SECTION(\"Test the red color method\") {\n        const std::string input_text = \"Hello\";\n        const std::string expected_output = \"\\033[91mHello\\033[0m\";\n        REQUIRE(Colors::red(input_text) == expected_output);\n    }\n\n    SECTION(\"Test the green color method\") {\n        const std::string input_text = \"Hello\";\n        const std::string expected_output = \"\\033[92mHello\\033[0m\";\n        REQUIRE(Colors::green(input_text) == expected_output);\n    }\n\n    SECTION(\"Test the blue color method\") {\n        const std::string input_text = \"Hello\";\n        const std::string expected_output = \"\\033[94mHello\\033[0m\";\n        REQUIRE(Colors::blue(input_text) == expected_output);\n    }\n\n    SECTION(\"Test the yellow color method\") {\n        const std::string input_text = \"Hello\";\n        const std::string expected_output = \"\\033[93mHello\\033[0m\";\n        REQUIRE(Colors::yellow(input_text) == expected_output);\n    }\n\n    SECTION(\"Test the magenta color method\") {\n        const std::string input_text = \"Hello\";\n        const std::string expected_output = \"\\033[95mHello\\033[0m\";\n        REQUIRE(Colors::magenta(input_text) == expected_output);\n    }\n\n    SECTION(\"Test the cyan color method\") {\n        const std::string input_text = \"Hello\";\n        const std::string expected_output = \"\\033[96mHello\\033[0m\";\n        REQUIRE(Colors::cyan(input_text) == expected_output);\n    }\n\n    SECTION(\"Test combining different color methods\") {\n        const std::string input_text_red = Colors::red(\"Red\");\n        const std::string input_text_blue = Colors::blue(\"Blue\");\n        const std::string input_text_combined = input_text_red + \" and \" + input_text_blue;\n        const std::string expected_output = \"\\033[91mRed\\033[0m and \\033[94mBlue\\033[0m\";\n        REQUIRE(input_text_combined == expected_output);\n    }\n}", "prompt": "please write a cpp class , the class signature as below class Colors {\npublic:\n    // Function to return text in red color\n    static std::string red(const std::string& text);\n\n    // Function to return text in green color\n    static std::string green(const std::string& text);\n\n    // Function to return text in blue color\n    static std::string blue(const std::string& text);\n\n    // Function to return text in yellow color\n    static std::string yellow(const std::string& text);\n\n    // Function to return text in magenta color\n    static std::string magenta(const std::string& text);\n\n    // Function to return text in cyan color\n    static std::string cyan(const std::string& text);\n};\n\n// Implementation of each function (you can add actual implementation here)\nstd::string Colors::red(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[31m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::green(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[32m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::blue(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[34m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::yellow(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[33m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::magenta(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[35m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::cyan(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[36m\" + text + \"\\033[0m\";\n}", "addition_info": ""}, "java": {"code_signature": "public final class Colors {\n\n    // Private constructor to prevent instantiation of utility class\n    private Colors() {\n        throw new UnsupportedOperationException(\"Utility class\");\n    }\n\n    /**\n     * Returns the text in red color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for red color.\n     */\n    public static String red(String text) {\n        return \"\\u001B[31m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in green color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for green color.\n     */\n    public static String green(String text) {\n        return \"\\u001B[32m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in blue color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for blue color.\n     */\n    public static String blue(String text) {\n        return \"\\u001B[34m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in yellow color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for yellow color.\n     */\n    public static String yellow(String text) {\n        return \"\\u001B[33m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in magenta color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for magenta color.\n     */\n    public static String magenta(String text) {\n        return \"\\u001B[35m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in cyan color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for cyan color.\n     */\n    public static String cyan(String text) {\n        return \"\\u001B[36m\" + text + \"\\u001B[0m\";\n    }\n}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Tester {\n\n    // Assuming these methods will be implemented with some functionality\n    public String red(String text) {\n        return \"\\033[31m\" + text + \"\\033[0m\";\n    }\n\n    public String green(String text) {\n        return \"\\033[32m\" + text + \"\\033[0m\";\n    }\n\n    public String blue(String text) {\n        return \"\\033[34m\" + text + \"\\033[0m\";\n    }\n\n    public String yellow(String text) {\n        return \"\\033[33m\" + text + \"\\033[0m\";\n    }\n\n    public String magenta(String text) {\n        return \"\\033[35m\" + text + \"\\033[0m\";\n    }\n\n    public String cyan(String text) {\n        return \"\\033[36m\" + text + \"\\033[0m\";\n    }\n\n    @Test\n    public void testRed() {\n        assertEquals(\"\\033[31mHello\\033[0m\", red(\"Hello\"));\n    }\n\n    @Test\n    public void testGreen() {\n        assertEquals(\"\\033[32mHello\\033[0m\", green(\"Hello\"));\n    }\n\n    @Test\n    public void testBlue() {\n        assertEquals(\"\\033[34mHello\\033[0m\", blue(\"Hello\"));\n    }\n\n    @Test\n    public void testYellow() {\n        assertEquals(\"\\033[33mHello\\033[0m\", yellow(\"Hello\"));\n    }\n\n    @Test\n    public void testMagenta() {\n        assertEquals(\"\\033[35mHello\\033[0m\", magenta(\"Hello\"));\n    }\n\n    @Test\n    public void testCyan() {\n        assertEquals(\"\\033[36mHello\\033[0m\", cyan(\"Hello\"));\n    }\n}", "prompt": "please write a java class , the function signature as below public final class Colors {\n\n    // Private constructor to prevent instantiation of utility class\n    private Colors() {\n        throw new UnsupportedOperationException(\"Utility class\");\n    }\n\n    /**\n     * Returns the text in red color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for red color.\n     */\n    public static String red(String text) {\n        return \"\\u001B[31m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in green color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for green color.\n     */\n    public static String green(String text) {\n        return \"\\u001B[32m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in blue color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for blue color.\n     */\n    public static String blue(String text) {\n        return \"\\u001B[34m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in yellow color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for yellow color.\n     */\n    public static String yellow(String text) {\n        return \"\\u001B[33m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in magenta color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for magenta color.\n     */\n    public static String magenta(String text) {\n        return \"\\u001B[35m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in cyan color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for cyan color.\n     */\n    public static String cyan(String text) {\n        return \"\\u001B[36m\" + text + \"\\u001B[0m\";\n    }\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 410, "code_type": "method", "original_language": "python", "file_path": "digital-forensics-lab\\d7a59b5c116a003994d0b9e9258c32aa228dab09\\Illegal_Possession_Images\\lab_files\\wlan_decrypt\\crackWEP40_GPU_Improved_v1.py\n", "question_type": "Algorithm and data structure", "summary": "Checks the XOR sums of specific columns in a given combination array.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef check_xor_sum(combination: np.ndarray):\n    \"\"\"\n    Checks the XOR sums of specific columns in a given combination array.\n\n    Args:\n        combination (np.ndarray): A 2D numpy array where each column corresponds\n                                  to a specific value.\n\n    Returns:\n        bool: True if the XOR sums of the specified columns match the required\n              values; otherwise, False.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestCheckXorSum(unittest.TestCase):\n\n    def test_correct_xor_sums(self):\n        \"\"\" Test with combination values that produce the expected XOR sums. \"\"\"\n        combination = np.array([\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n        ])\n        self.assertFalse(check_xor_sum(combination))\n\n    def test_incorrect_xor_sums(self):\n        \"\"\" Test with combination values that do not meet the expected XOR sums. \"\"\"\n        combination = np.array([\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00]\n        ])\n        self.assertFalse(check_xor_sum(combination))\n\n    def test_edge_case_with_zero(self):\n        \"\"\" Test with a combination where all values are zero. \"\"\"\n        combination = np.zeros((1, 8), dtype=int)  # 1 row of zeros\n        self.assertFalse(check_xor_sum(combination))\n\n    def test_large_numbers(self):\n        \"\"\" Test with large numbers in the combination. \"\"\"\n        combination = np.array([\n            [0x6b000000, 0x00000000, 0x00000012, 0x00000000, 0x76000000, 0x00000000, 0x00000000, 0x00000000],\n            [0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]\n        ])\n        self.assertFalse(check_xor_sum(combination))\n\n    def test_multiple_rows(self):\n        \"\"\" Test with a combination that contains multiple rows. \"\"\"\n        combination = np.array([\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00]\n        ])\n        self.assertTrue(check_xor_sum(combination))", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef check_xor_sum(combination: np.ndarray):\n    \"\"\"\n    Checks the XOR sums of specific columns in a given combination array.\n\n    Args:\n        combination (np.ndarray): A 2D numpy array where each column corresponds\n                                  to a specific value.\n\n    Returns:\n        bool: True if the XOR sums of the specified columns match the required\n              values; otherwise, False.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Checks the XOR sums of specific columns in a given combination array.\n *\n * @param combination A 2D vector where each column corresponds to a specific value.\n * @return True if the XOR sums of the specified columns match the required values; otherwise, False.\n */\nbool check_xor_sum(const std::vector<std::vector<int>>& combination);", "test_code": "TEST_CASE(\"TestCheckXorSum\", \"[check_xor_sum]\") {\n    SECTION(\"test_correct_xor_sums\") {\n        // Test with combination values that produce the expected XOR sums.\n        Eigen::ArrayXi combination(2, 8);\n        combination << 0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00,\n                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00;\n        REQUIRE_FALSE(check_xor_sum(combination));\n    }\n\n    SECTION(\"test_incorrect_xor_sums\") {\n        // Test with combination values that do not meet the expected XOR sums.\n        Eigen::ArrayXi combination(2, 8);\n        combination << 0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00,\n                       0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00;\n        REQUIRE_FALSE(check_xor_sum(combination));\n    }\n\n    SECTION(\"test_edge_case_with_zero\") {\n        // Test with a combination where all values are zero.\n        Eigen::ArrayXi combination(1, 8);\n        combination.setZero();\n        REQUIRE_FALSE(check_xor_sum(combination));\n    }\n\n    SECTION(\"test_large_numbers\") {\n        // Test with large numbers in the combination.\n        Eigen::ArrayXi combination(2, 8);\n        combination << 0x6b000000, 0x00000000, 0x00000012, 0x00000000, 0x76000000, 0x00000000, 0x00000000, 0x00000000,\n                       0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000;\n        REQUIRE_FALSE(check_xor_sum(combination));\n    }\n\n    SECTION(\"test_multiple_rows\") {\n        // Test with a combination that contains multiple rows.\n        Eigen::ArrayXi combination(3, 8);\n        combination << 0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00,\n                       0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00,\n                       0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00;\n        REQUIRE(check_xor_sum(combination));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Checks the XOR sums of specific columns in a given combination array.\n *\n * @param combination A 2D vector where each column corresponds to a specific value.\n * @return True if the XOR sums of the specified columns match the required values; otherwise, False.\n */\nbool check_xor_sum(const std::vector<std::vector<int>>& combination);", "addition_info": ""}, "java": {"code_signature": "public class Main {\n\n    /**\n     * Checks the XOR sums of specific columns in a given combination array.\n     *\n     * @param combination A 2D int array where each column corresponds to a specific value.\n     * @return True if the XOR sums of the specified columns match the required values; otherwise, false.\n     */\n    public static boolean checkXorSum(int[][] combination) {\n        // Your implementation here\n    }\n\n}", "test_code": "import static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testCheckXorSum() {\n        // Assuming check_xor_sum is implemented and available here\n        // For demonstration purposes, let's create a mock implementation\n        boolean result = check_xor_sum(new int[][]{\n            {1, 0, 1},\n            {0, 1, 0},\n            {1, 1, 1}\n        });\n\n        assertTrue(result); // Adjust the assertion based on expected behavior\n    }\n\n    private boolean check_xor_sum(int[][] combination) {\n        // Implement the logic for checking XOR sums here\n        // This is a placeholder for the actual implementation\n        return true; // Placeholder return value\n    }\n}", "prompt": "please write a java function , the function signature as below public class Main {\n\n    /**\n     * Checks the XOR sums of specific columns in a given combination array.\n     *\n     * @param combination A 2D int array where each column corresponds to a specific value.\n     * @return True if the XOR sums of the specified columns match the required values; otherwise, false.\n     */\n    public static boolean checkXorSum(int[][] combination) {\n        // Your implementation here\n    }\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 412, "code_type": "method", "original_language": "python", "file_path": "ecdo\\40700402154c8b71029f908b758a9afa10847c32\\5-TOOLS-DATA-DEV\\scripts\\remove-newlines.py\n", "question_type": "File operations and I/O operation", "summary": "Read content from a text file, remove the line breaks at the end of each line, make sure there is a space at the end of each line (unless it already exists), and finally merge these processed lines into a single string that is written to an output file\n", "language_version_list": {"python": {"code_signature": "", "test_code": "import os\nimport tempfile\nimport unittest\n\n\nclass TestFormatText(unittest.TestCase):\n\n    def test_basic_text(self):\n        # Test with basic text\n        input_text = \"This is line one.\\nThis is line two.\\nThis is line three.\"\n        expected_output = \"This is line one. This is line two. This is line three.\"\n\n        with tempfile.NamedTemporaryFile(delete=False, mode='w+t') as input_file:\n            input_file.write(input_text)\n            input_file.seek(0)  # Go back to the start of the file\n            output_file_path = tempfile.mktemp(suffix='.txt')  # Create a temporary output file\n\n            format_text(input_file.name, output_file_path)\n\n            with open(output_file_path, 'r') as output_file:\n                output_text = output_file.read().strip()\n\n            self.assertEqual(expected_output, output_text)\n\n        os.remove(input_file.name)\n        os.remove(output_file_path)\n\n    def test_single_line(self):\n        # Test with a single line\n        input_text = \"This is a single line.\"\n        expected_output = \"This is a single line.\"\n\n        with tempfile.NamedTemporaryFile(delete=False, mode='w+t') as input_file:\n            input_file.write(input_text)\n            input_file.seek(0)\n            output_file_path = tempfile.mktemp(suffix='.txt')\n\n            format_text(input_file.name, output_file_path)\n\n            with open(output_file_path, 'r') as output_file:\n                output_text = output_file.read().strip()\n\n            self.assertEqual(expected_output, output_text)\n\n        os.remove(input_file.name)\n        os.remove(output_file_path)\n\n    def test_empty_file(self):\n        # Test with an empty file\n        input_text = \"\"\n        expected_output = \"\"\n\n        with tempfile.NamedTemporaryFile(delete=False, mode='w+t') as input_file:\n            input_file.write(input_text)\n            input_file.seek(0)\n            output_file_path = tempfile.mktemp(suffix='.txt')\n\n            format_text(input_file.name, output_file_path)\n\n            with open(output_file_path, 'r') as output_file:\n                output_text = output_file.read().strip()\n\n            self.assertEqual(expected_output, output_text)\n\n        os.remove(input_file.name)\n        os.remove(output_file_path)\n\n    def test_file_with_no_newlines(self):\n        # Test with text that has no newlines\n        input_text = \"This is a continuous line without breaks.\"\n        expected_output = \"This is a continuous line without breaks.\"\n\n        with tempfile.NamedTemporaryFile(delete=False, mode='w+t') as input_file:\n            input_file.write(input_text)\n            input_file.seek(0)\n            output_file_path = tempfile.mktemp(suffix='.txt')\n\n            format_text(input_file.name, output_file_path)\n\n            with open(output_file_path, 'r') as output_file:\n                output_text = output_file.read().strip()\n\n            self.assertEqual(expected_output, output_text)\n\n        os.remove(input_file.name)\n        os.remove(output_file_path)\n", "prompt": "please write a python function , the function signature as below ", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Formats the text by removing newline characters and adding spaces between lines.\n *\n * @param input_file The path to the input file.\n * @param output_file The path to the output file.\n */\nvoid format_text(const std::string& input_file = \"input.txt\", const std::string& output_file = \"output.txt\") {}", "test_code": "TEST_CASE(\"Testformat_text\", \"[format_text]\") {\n    SECTION(\"test_basic_text\") {\n        // Test with basic text\n        std::string input_text = \"This is line one.\\nThis is line two.\\nThis is line three.\";\n        std::string expected_output = \"This is line one. This is line two. This is line three.\";\n\n        // Create a temporary directory\n        std::filesystem::path temp_dir = std::filesystem::temp_directory_path();\n        std::string input_file_path = (temp_dir / \"input.txt\").string();\n        std::string output_file_path = (temp_dir / \"output.txt\").string();\n\n        // Write input text to the temporary input file\n        std::ofstream input_file(input_file_path);\n        input_file << input_text;\n        input_file.close();\n\n        // Call the format_text function\n        format_text(input_file_path, output_file_path);\n\n        // Read the output file\n        std::ifstream output_file(output_file_path);\n        std::string output_text((std::istreambuf_iterator<char>(output_file)), std::istreambuf_iterator<char>());\n        output_file.close();\n\n        // Check the output\n        REQUIRE(expected_output == output_text);\n\n        // Clean up\n        std::remove(input_file_path.c_str());\n        std::remove(output_file_path.c_str());\n    }\n\n    SECTION(\"test_single_line\") {\n        // Test with a single line\n        std::string input_text = \"This is a single line.\";\n        std::string expected_output = \"This is a single line.\";\n\n        // Create a temporary directory\n        std::filesystem::path temp_dir = std::filesystem::temp_directory_path();\n        std::string input_file_path = (temp_dir / \"input.txt\").string();\n        std::string output_file_path = (temp_dir / \"output.txt\").string();\n\n        // Write input text to the temporary input file\n        std::ofstream input_file(input_file_path);\n        input_file << input_text;\n        input_file.close();\n\n        // Call the format_text function\n        format_text(input_file_path, output_file_path);\n\n        // Read the output file\n        std::ifstream output_file(output_file_path);\n        std::string output_text((std::istreambuf_iterator<char>(output_file)), std::istreambuf_iterator<char>());\n        output_file.close();\n\n        // Check the output\n        REQUIRE(expected_output == output_text);\n\n        // Clean up\n        std::remove(input_file_path.c_str());\n        std::remove(output_file_path.c_str());\n    }\n\n    SECTION(\"test_empty_file\") {\n        // Test with an empty file\n        std::string input_text = \"\";\n        std::string expected_output = \"\";\n\n        // Create a temporary directory\n        std::filesystem::path temp_dir = std::filesystem::temp_directory_path();\n        std::string input_file_path = (temp_dir / \"input.txt\").string();\n        std::string output_file_path = (temp_dir / \"output.txt\").string();\n\n        // Write input text to the temporary input file\n        std::ofstream input_file(input_file_path);\n        input_file << input_text;\n        input_file.close();\n\n        // Call the format_text function\n        format_text(input_file_path, output_file_path);\n\n        // Read the output file\n        std::ifstream output_file(output_file_path);\n        std::string output_text((std::istreambuf_iterator<char>(output_file)), std::istreambuf_iterator<char>());\n        output_file.close();\n\n        // Check the output\n        REQUIRE(expected_output == output_text);\n\n        // Clean up\n        std::remove(input_file_path.c_str());\n        std::remove(output_file_path.c_str());\n    }\n\n    SECTION(\"test_file_with_no_newlines\") {\n        // Test with text that has no newlines\n        std::string input_text = \"This is a continuous line without breaks.\";\n        std::string expected_output = \"This is a continuous line without breaks.\";\n\n        // Create a temporary directory\n        std::filesystem::path temp_dir = std::filesystem::temp_directory_path();\n        std::string input_file_path = (temp_dir / \"input.txt\").string();\n        std::string output_file_path = (temp_dir / \"output.txt\").string();\n\n        // Write input text to the temporary input file\n        std::ofstream input_file(input_file_path);\n        input_file << input_text;\n        input_file.close();\n\n        // Call the format_text function\n        format_text(input_file_path, output_file_path);\n\n        // Read the output file\n        std::ifstream output_file(output_file_path);\n        std::string output_text((std::istreambuf_iterator<char>(output_file)), std::istreambuf_iterator<char>());\n        output_file.close();\n\n        // Check the output\n        REQUIRE(expected_output == output_text);\n\n        // Clean up\n        std::remove(input_file_path.c_str());\n        std::remove(output_file_path.c_str());\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Formats the text by removing newline characters and adding spaces between lines.\n *\n * @param input_file The path to the input file.\n * @param output_file The path to the output file.\n */\nvoid format_text(const std::string& input_file = \"input.txt\", const std::string& output_file = \"output.txt\") {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 413, "code_type": "method", "original_language": "python", "file_path": "AtCoder\\19300ad200cbf5fa8ba9c6f0616c60a7c3168f19\\ABC\\ABC363\\D.py\n", "question_type": "Algorithm and data structure", "summary": "Filter out the number of palindrome within any number n. Palindrome numbers are numbers with the same correction and reverse readings, such as 121, 1331\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef get_palindrome_list(n: int) ->  List[int]:\n    \"\"\"\n    Filter out the number of palindrome within any number n. Palindrome numbers are numbers with the same correction and reverse readings, such as 121, 1331\n\n    Args:\n        n (int): range number\n\n    Returns:\n        List[int]: Palindrome numbers\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestNthPalindrome(unittest.TestCase):\n    def test_single_digit(self):\n        \"\"\"Test case for the first palindrome\"\"\"\n        self.assertEqual(get_palindrome_list(1), [0], \"The first palindrome should be 0\")\n\n    def test_edge_of_single_and_double_digits(self):\n        \"\"\"Test case for the tenth palindrome, transitioning to double digits\"\"\"\n        self.assertEqual(get_palindrome_list(10), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n                         \"The tenth palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\")\n\n    def test_edge_of_double_and_triple_digits(self):\n        \"\"\"Test case for the 100th palindrome, transitioning to triple digits\"\"\"\n        self.assertEqual(get_palindrome_list(100), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99],\n                         \"The 100th palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99]\")\n\n    def test_large_number(self):\n        \"\"\"Test case for a larger number, e.g., the 1000th palindrome\"\"\"\n        self.assertEqual(get_palindrome_list(1000),\n                         [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141,\n                          151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333,\n                          343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525,\n                          535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717,\n                          727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909,\n                          919, 929, 939, 949, 959, 969, 979, 989, 999]\n                         ,\n                         \"The 1000th palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999]\")\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef get_palindrome_list(n: int) ->  List[int]:\n    \"\"\"\n    Filter out the number of palindrome within any number n. Palindrome numbers are numbers with the same correction and reverse readings, such as 121, 1331\n\n    Args:\n        n (int): range number\n\n    Returns:\n        List[int]: Palindrome numbers\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <vector>\n#include <string>\n\n/**\n * @brief Filters out the number of palindromes within any number n.\n * Palindrome numbers are numbers with the same correction and reverse readings, such as 121, 1331.\n *\n * @param n The range number\n * @return std::vector<int> A vector containing palindrome numbers\n */\nstd::vector<int> get_palindrome_list(int n);", "test_code": "TEST_CASE(\"Test cases for get_palindrome_list\", \"[palindrome]\") {\n    SECTION(\"Test case for the first palindrome\") {\n        REQUIRE(get_palindrome_list(1) == std::vector<int>({0}));\n    }\n\n    SECTION(\"Test case for the tenth palindrome, transitioning to double digits\") {\n        REQUIRE(get_palindrome_list(10) == std::vector<int>({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}));\n    }\n\n    SECTION(\"Test case for the 100th palindrome, transitioning to triple digits\") {\n        REQUIRE(get_palindrome_list(100) == std::vector<int>({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99}));\n    }\n\n    SECTION(\"Test case for a larger number, e.g., the 1000th palindrome\") {\n        REQUIRE(get_palindrome_list(1000) == std::vector<int>({\n            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191,\n            202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434,\n            444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676,\n            686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919,\n            929, 939, 949, 959, 969, 979, 989, 999\n        }));\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <vector>\n#include <string>\n\n/**\n * @brief Filters out the number of palindromes within any number n.\n * Palindrome numbers are numbers with the same correction and reverse readings, such as 121, 1331.\n *\n * @param n The range number\n * @return std::vector<int> A vector containing palindrome numbers\n */\nstd::vector<int> get_palindrome_list(int n);", "addition_info": ""}, "java": {"code_signature": "/**\n * Filter out the number of palindrome within any number n. Palindrome numbers are numbers with the same correction and reverse readings, such as 121, 1331\n *\n * @param n the range number\n * @return a list of palindrome numbers\n */\npublic class PalindromeFilter {}", "test_code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class NumberUtils {\n\n    public static List<Integer> getPalindromeList(int n) {\n        List<Integer> palindromes = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            if (isPalindrome(i)) {\n                palindromes.add(i);\n            }\n        }\n        return palindromes;\n    }\n\n    private static boolean isPalindrome(int number) {\n        String str = Integer.toString(number);\n        int left = 0;\n        int right = str.length() - 1;\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Filter out the number of palindrome within any number n. Palindrome numbers are numbers with the same correction and reverse readings, such as 121, 1331\n *\n * @param n the range number\n * @return a list of palindrome numbers\n */\npublic class PalindromeFilter {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 414, "code_type": "method", "original_language": "python", "file_path": "alexwan0.github.io\\ab9cb15f26f86dfdce94be3a1c6d5986fa42bdae\\bibtex_to_html.py\n", "question_type": "File operations and I/O operation", "summary": "Extract the title, author and year of the article from the bib file.", "language_version_list": {"python": {"code_signature": "def extract_bib_info(bib_file: str):\n    \"\"\"\n    Extracts the title, author, and year from a BibTeX file.bib file content such as @article{sample2024,\\n  author = {John Doe and Jane Smith},\\n  title = {A Comprehensive Study on AI},\\n  year = {2024}\\n}\n\n    Args:\n        bib_file (str): The path to the BibTeX file.\n\n    Returns:\n        list of dict: A list containing dictionaries with title, author, and year for each article.\n    \"\"\"\n", "test_code": "import re\nimport unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestExtractBibInfo(unittest.TestCase):\n\n    def test_valid_entry(self):\n        \"\"\"Test extraction from a valid BibTeX entry.\"\"\"\n        mock_bib = \"@article{sample2024,\\n  author = {John Doe and Jane Smith},\\n  title = {A Comprehensive Study on AI},\\n  year = {2024}\\n}\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = [{'title': 'A Comprehensive Study on AI', 'author': 'John Doe and Jane Smith', 'year': '2024'}]\n            self.assertEqual(result, expected)\n\n    def test_multiple_entries(self):\n        \"\"\"Test extraction from multiple BibTeX entries.\"\"\"\n        mock_bib = (\n            \"@article{sample2024,\\n\"\n            \"  author = {John Doe},\\n\"\n            \"  title = {A Comprehensive Study on AI},\\n\"\n            \"  year = {2024}\\n}\\n\"\n            \"@article{sample2023,\\n\"\n            \"  author = {Jane Smith},\\n\"\n            \"  title = {Deep Learning Techniques},\\n\"\n            \"  year = {2023}\\n}\"\n        )\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = [\n                {'title': 'A Comprehensive Study on AI', 'author': 'John Doe', 'year': '2024'},\n                {'title': 'Deep Learning Techniques', 'author': 'Jane Smith', 'year': '2023'}\n            ]\n            self.assertEqual(result, expected)\n\n    def test_missing_fields(self):\n        \"\"\"Test extraction when some fields are missing.\"\"\"\n        mock_bib = \"@article{sample2024,\\n  author = {John Doe},\\n  title = {Title Missing Year}\\n}\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = [{'title': 'Title Missing Year', 'author': 'John Doe', 'year': None}]\n            self.assertEqual(result, expected)\n\n    def test_empty_file(self):\n        \"\"\"Test extraction from an empty BibTeX file.\"\"\"\n        mock_bib = \"\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = []\n            self.assertEqual(result, expected)\n\n    def test_incorrect_format(self):\n        \"\"\"Test extraction from a badly formatted BibTeX entry.\"\"\"\n        mock_bib = \"@article{sample2024,\\n  author = John Doe,\\n  title = {Title Without Braces},\\n  year = 2024\\n}\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = [{'title': 'Title Without Braces', 'author': None, 'year': None}]\n            self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def extract_bib_info(bib_file: str):\n    \"\"\"\n    Extracts the title, author, and year from a BibTeX file.bib file content such as @article{sample2024,\\n  author = {John Doe and Jane Smith},\\n  title = {A Comprehensive Study on AI},\\n  year = {2024}\\n}\n\n    Args:\n        bib_file (str): The path to the BibTeX file.\n\n    Returns:\n        list of dict: A list containing dictionaries with title, author, and year for each article.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 420, "code_type": "class", "original_language": "python", "file_path": "computer-sciences\\c5d11d4b8387f01bb804788db030bf035ace10ad\\Python\\exams\\worms\\worms-chatgpt.py\n", "question_type": "Data processing and transformation", "summary": "Find the minimum distance between two specified words (word1 and word2) from the file and return in which line the distance occurred\n", "language_version_list": {"python": {"code_signature": "def get_min_distance(file_path, word1, word2):\n    \"\"\"\n    Find the minimum distance between two specified words (word1 and word2) from the file and return in which line the distance occurred\n\n    Args:\n        file_path (str):\n        word1 (str):\n        word2 (str):\n\n    Returns:\n\n    \"\"\"", "test_code": "import unittest\nfrom unittest.mock import patch\n\n\nclass TestGetMinDistance(unittest.TestCase):\n    @patch('builtins.open')\n    def test_simple_case(self, mock_open):\n        # Mock the file read operation\n        mock_open.return_value.__enter__.return_value = iter([\n            \"hello world\",\n            \"hello hello world\",\n            \"world hello\"\n        ])\n        self.assertEqual(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\"), (0, 1))\n\n\n    @patch('builtins.open')\n    def test_multiple_lines(self, mock_open):\n        mock_open.return_value.__enter__.return_value = iter([\n            \"hello planet\",\n            \"world hello planet\",\n            \"hello world planet\"\n        ])\n        self.assertEqual(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\"), (1, 1))\n\n    @patch('builtins.open')\n    def test_large_distance(self, mock_open):\n        mock_open.return_value.__enter__.return_value = iter([\n            \"hello a b c d e f g h i j k l m n o p q r s t u v w x y z world\"\n        ])\n        self.assertEqual(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\"), (0, 27))\n\n    @patch('builtins.open')\n    def test_adjacent_words(self, mock_open):\n        mock_open.return_value.__enter__.return_value = iter([\n            \"hello world\",\n            \"hello hello world world\",\n            \"world hello\"\n        ])\n        self.assertEqual(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\"), (0, 1))\n", "prompt": "please write a python class , the class signature as below def get_min_distance(file_path, word1, word2):\n    \"\"\"\n    Find the minimum distance between two specified words (word1 and word2) from the file and return in which line the distance occurred\n\n    Args:\n        file_path (str):\n        word1 (str):\n        word2 (str):\n\n    Returns:\n\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Find the minimum distance between two specified words (word1 and word2) from the file and return in which line the distance occurred.\n *\n * @param file_path The path to the file.\n * @param word1 The first word to search for.\n * @param word2 The second word to search for.\n * @return A pair of integers representing the line number and the minimum distance.\n */\nstd::pair<int, int> get_min_distance(const std::string& file_path, const std::string& word1, const std::string& word2);", "test_code": "TEST_CASE(\"Test Get Min Distance\") {\n    SECTION(\"Simple case\") {\n        std::vector<std::string> lines = {\n            \"hello world\",\n            \"hello hello world\",\n            \"world hello\"\n        };\n        REQUIRE(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\") == std::make_pair(0, 1));\n    }\n\n    SECTION(\"Multiple lines\") {\n        std::vector<std::string> lines = {\n            \"hello planet\",\n            \"world hello planet\",\n            \"hello world planet\"\n        };\n        REQUIRE(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\") == std::make_pair(1, 1));\n    }\n\n    SECTION(\"Large distance\") {\n        std::vector<std::string> lines = {\n            \"hello a b c d e f g h i j k l m n o p q r s t u v w x y z world\"\n        };\n        REQUIRE(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\") == std::make_pair(0, 27));\n    }\n\n    SECTION(\"Adjacent words\") {\n        std::vector<std::string> lines = {\n            \"hello world\",\n            \"hello hello world world\",\n            \"world hello\"\n        };\n        REQUIRE(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\") == std::make_pair(0, 1));\n    }\n}", "prompt": "please write a cpp class , the class signature as below /**\n * Find the minimum distance between two specified words (word1 and word2) from the file and return in which line the distance occurred.\n *\n * @param file_path The path to the file.\n * @param word1 The first word to search for.\n * @param word2 The second word to search for.\n * @return A pair of integers representing the line number and the minimum distance.\n */\nstd::pair<int, int> get_min_distance(const std::string& file_path, const std::string& word1, const std::string& word2);", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java class , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 423, "code_type": "method", "original_language": "python", "file_path": "TestGen-Thesis\\245b7d14338b7495bd5c6b6eb7ff66f49c3bbdad\\scripts\\helpers.py\n", "question_type": "File operations and I/O operation", "summary": "Writes a line to a text file, checks whether a line with the same content already exists before writing, and does not write if it does", "language_version_list": {"python": {"code_signature": "def write_unique_line_to_file(filename: str, line_content: str):\n    \"\"\"\n    Writes a line to a text file only if the line with the same content does not already exist.\n\n    Args:\n        filename (str): The name of the file to write to.\n        line_content (str): The content of the line to write.\n\n    Returns:\n        None\n    \"\"\"", "test_code": "import unittest\nimport os\n\n\nclass TestWriteUniqueLineToFile(unittest.TestCase):\n    def setUp(self):\n        # Setup: create a temporary file for testing.\n        self.filename = 'test_file.txt'\n        with open(self.filename, 'w') as file:\n            file.write('')\n\n    def test_write_new_line(self):\n        # Test case 1: Writing a new line to an empty file.\n        line_content = \"First unique line.\"\n        write_unique_line_to_file(self.filename, line_content)\n        with open(self.filename, 'r') as file:\n            self.assertIn(line_content, file.read())\n\n    def test_write_duplicate_line(self):\n        # Test case 2: Attempting to write a duplicate line.\n        line_content = \"First unique line.\"\n        # Write the line once.\n        write_unique_line_to_file(self.filename, line_content)\n        # Attempt to write it again.\n        write_unique_line_to_file(self.filename, line_content)\n        # Check if the line was written only once.\n        with open(self.filename, 'r') as file:\n            self.assertEqual(file.read().strip().count(line_content), 1)\n\n    def test_write_multiple_unique_lines(self):\n        # Test case 3: Writing multiple unique lines.\n        lines = [\"First unique line.\", \"Second unique line.\", \"Third unique line.\"]\n        for line in lines:\n            write_unique_line_to_file(self.filename, line)\n        with open(self.filename, 'r') as file:\n            file_content = file.read()\n            for line in lines:\n                self.assertIn(line, file_content)\n\n    def test_write_empty_line(self):\n        # Test case 5: Writing an empty line, should not write.\n        line_content = \"\"\n        write_unique_line_to_file(self.filename, line_content)\n        with open(self.filename, 'r') as file:\n            self.assertEqual(file.read(), \"\")\n", "prompt": "please write a python function , the function signature as below def write_unique_line_to_file(filename: str, line_content: str):\n    \"\"\"\n    Writes a line to a text file only if the line with the same content does not already exist.\n\n    Args:\n        filename (str): The name of the file to write to.\n        line_content (str): The content of the line to write.\n\n    Returns:\n        None\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Writes a line to a text file only if the line with the same content does not already exist.\n *\n * @param filename The name of the file to write to.\n * @param lineContent The content of the line to write.\n */\nvoid write_unique_line_to_file(const std::string& filename, const std::string& lineContent) {}", "test_code": "TEST_CASE(\"Testwrite_unique_line_to_file\", \"[write_unique_line_to_file]\") {\n    const std::string filename = \"test_file.txt\";\n\n    SECTION(\"Setup: Create a temporary file for testing\") {\n        std::ofstream file(filename);\n        REQUIRE(file.is_open());\n        file.close();\n    }\n\n    SECTION(\"Test case 1: Writing a new line to an empty file\") {\n        const std::string lineContent = \"First unique line.\";\n        write_unique_line_to_file(filename, lineContent);\n\n        std::ifstream file(filename);\n        REQUIRE(file.is_open());\n\n        std::string fileContent((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        REQUIRE(fileContent.find(lineContent) != std::string::npos);\n    }\n\n    SECTION(\"Test case 2: Attempting to write a duplicate line\") {\n        const std::string lineContent = \"First unique line.\";\n        write_unique_line_to_file(filename, lineContent);\n        write_unique_line_to_file(filename, lineContent);\n\n        std::ifstream file(filename);\n        REQUIRE(file.is_open());\n\n        std::string fileContent((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        REQUIRE(std::count(fileContent.begin(), fileContent.end(), '\\n') == 1);\n        REQUIRE(fileContent.find(lineContent) != std::string::npos);\n    }\n\n    SECTION(\"Test case 3: Writing multiple unique lines\") {\n        const std::vector<std::string> lines = {\"First unique line.\", \"Second unique line.\", \"Third unique line.\"};\n        for (const auto& line : lines) {\n            write_unique_line_to_file(filename, line);\n        }\n\n        std::ifstream file(filename);\n        REQUIRE(file.is_open());\n\n        std::string fileContent((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        for (const auto& line : lines) {\n            REQUIRE(fileContent.find(line) != std::string::npos);\n        }\n    }\n\n    SECTION(\"Test case 4: Writing an empty line, should not write\") {\n        const std::string lineContent = \"\";\n        write_unique_line_to_file(filename, lineContent);\n\n        std::ifstream file(filename);\n        REQUIRE(file.is_open());\n\n        std::string fileContent((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        REQUIRE(fileContent.empty());\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Writes a line to a text file only if the line with the same content does not already exist.\n *\n * @param filename The name of the file to write to.\n * @param lineContent The content of the line to write.\n */\nvoid write_unique_line_to_file(const std::string& filename, const std::string& lineContent) {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 424, "code_type": "method", "original_language": "python", "file_path": "adventofcode\\60cdeebfe2448f8ae516c0e4dd34adf7e63503c5\\2019\\day15\\floyd_warshall.py\n", "question_type": "Algorithm and data structure", "summary": "Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.", "language_version_list": {"python": {"code_signature": "import heapq\nfrom typing import Dict\n\n\ndef dijkstra(graph: Dict, start: str) -> Dict:\n    \"\"\"\n    Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.\n    Args:\n        graph(Dict): A dictionary representing the adjacency list of the graph. Each key is a node, and the value is a list of tuples (neighbor, weight).\n        start(str): The starting node for the shortest path search.\n\n    Returns:\n        Dict: A dictionary with the shortest distance from the start node to each node.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestDijkstraAlgorithm(unittest.TestCase):\n\n    def setUp(self):\n        # Sample graphs for testing\n        self.graph1 = {\n            'A': [('B', 1), ('C', 4)],\n            'B': [('A', 1), ('C', 2), ('D', 5)],\n            'C': [('A', 4), ('B', 2), ('D', 1)],\n            'D': [('B', 5), ('C', 1)],\n        }\n\n        self.graph2 = {\n            'A': [('B', 2)],\n            'B': [('A', 2), ('C', 3)],\n            'C': [('B', 3), ('D', 1)],\n            'D': [('C', 1)],\n        }\n\n        self.graph_with_isolated_node = {\n            'A': [('B', 1)],\n            'B': [('A', 1)],\n            'C': [],  # Isolated node\n        }\n\n        self.graph_with_negative_weight = {\n            'A': [('B', 2), ('C', 1)],\n            'B': [('D', 3)],\n            'C': [('B', -1), ('D', 4)],\n            'D': [],\n        }\n\n    def test_shortest_paths_graph1(self):\n        \"\"\"Test shortest paths in a normal graph.\"\"\"\n        expected = {'A': 0, 'B': 1, 'C': 3, 'D': 4}\n        result = dijkstra(self.graph1, 'A')\n        self.assertEqual(result, expected)\n\n    def test_shortest_paths_graph2(self):\n        \"\"\"Test shortest paths in a different normal graph.\"\"\"\n        expected = {'A': 0, 'B': 2, 'C': 5, 'D': 6}\n        result = dijkstra(self.graph2, 'A')\n        self.assertEqual(result, expected)\n\n    def test_shortest_paths_with_isolated_node(self):\n        \"\"\"Test shortest paths with an isolated node.\"\"\"\n        expected = {'A': 0, 'B': 1, 'C': float('inf')}\n        result = dijkstra(self.graph_with_isolated_node, 'A')\n        self.assertEqual(result, expected)\n\n\n    def test_starting_at_isolated_node(self):\n        \"\"\"Test when starting at an isolated node.\"\"\"\n        expected = {'C': 0, 'A': float('inf'), 'B': float('inf')}\n        result = dijkstra(self.graph_with_isolated_node, 'C')\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below import heapq\nfrom typing import Dict\n\n\ndef dijkstra(graph: Dict, start: str) -> Dict:\n    \"\"\"\n    Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.\n    Args:\n        graph(Dict): A dictionary representing the adjacency list of the graph. Each key is a node, and the value is a list of tuples (neighbor, weight).\n        start(str): The starting node for the shortest path search.\n\n    Returns:\n        Dict: A dictionary with the shortest distance from the start node to each node.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.\n * \n * @param graph An unordered_map representing the adjacency list of the graph. Each key is a node, and the value is a vector of pairs (neighbor, weight).\n * @param start The starting node for the shortest path search.\n * \n * @return An unordered_map with the shortest distance from the start node to each node.\n */\nunordered_map<char, int> dijkstra(const unordered_map<char, vector<pair<char, int>>> &graph, char start) {}", "test_code": "TEST_CASE(\"Test Dijkstra Algorithm\") {\n    // Sample graphs for testing\n    unordered_map<char, vector<pair<char, int>>> graph1 = {\n        {'A', {{'B', 1}, {'C', 4}}},\n        {'B', {{'A', 1}, {'C', 2}, {'D', 5}}},\n        {'C', {{'A', 4}, {'B', 2}, {'D', 1}}},\n        {'D', {{'B', 5}, {'C', 1}}}\n    };\n\n    unordered_map<char, vector<pair<char, int>>> graph2 = {\n        {'A', {{'B', 2}}},\n        {'B', {{'A', 2}, {'C', 3}}},\n        {'C', {{'B', 3}, {'D', 1}}},\n        {'D', {{'C', 1}}}\n    };\n\n    unordered_map<char, vector<pair<char, int>>> graph_with_isolated_node = {\n        {'A', {{'B', 1}}},\n        {'B', {{'A', 1}}},\n        {'C', {}}  // Isolated node\n    };\n\n    unordered_map<char, vector<pair<char, int>>> graph_with_negative_weight = {\n        {'A', {{'B', 2}, {'C', 1}}},\n        {'B', {{'D', 3}}},\n        {'C', {{'B', -1}, {'D', 4}}},\n        {'D', {}}\n    };\n\n    SECTION(\"Test shortest paths in a normal graph\") {\n        unordered_map<char, int> expected = {{'A', 0}, {'B', 1}, {'C', 3}, {'D', 4}};\n        unordered_map<char, int> result = dijkstra(graph1, 'A');\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test shortest paths in a different normal graph\") {\n        unordered_map<char, int> expected = {{'A', 0}, {'B', 2}, {'C', 5}, {'D', 6}};\n        unordered_map<char, int> result = dijkstra(graph2, 'A');\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test shortest paths with an isolated node\") {\n        unordered_map<char, int> expected = {{'A', 0}, {'B', 1}, {'C', INT_MAX}};\n        unordered_map<char, int> result = dijkstra(graph_with_isolated_node, 'A');\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test when starting at an isolated node\") {\n        unordered_map<char, int> expected = {{'C', 0}, {'A', INT_MAX}, {'B', INT_MAX}};\n        unordered_map<char, int> result = dijkstra(graph_with_isolated_node, 'C');\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.\n * \n * @param graph An unordered_map representing the adjacency list of the graph. Each key is a node, and the value is a vector of pairs (neighbor, weight).\n * @param start The starting node for the shortest path search.\n * \n * @return An unordered_map with the shortest distance from the start node to each node.\n */\nunordered_map<char, int> dijkstra(const unordered_map<char, vector<pair<char, int>>> &graph, char start) {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 427, "code_type": "method", "original_language": "python", "file_path": "computer-sciences\\40f5a3ec7464e27b79fe1e0d9cd0e797f3ee05ef\\Python\\exams\\munodi\\munodi-chatbox_gpt.py\n", "question_type": "Data processing and transformation", "summary": "Read multiple sequences from the file and determine if each sequence is a \"Munodi sequence\". The definition of the Munodi sequence is based on a specific recursive relationship, that is, for even numbers, the next term is half of it, for odd numbers, the next term is 3*n + 1, and the sequence terminates when it encounters 1", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef check_sequences(filename:str) -> Dict:\n    \"\"\"\n    Read multiple sequences from the file and determine if each sequence is a \"Munodi sequence\". The definition of the Munodi sequence is based on a specific recursive relationship, that is, for even numbers, the next term is half of it, for odd numbers, the next term is 3*n + 1, and the sequence terminates when it encounters 1.\n    For example: (2, 4, 6, 8) is Mundi sequence\n\n    Args:\n        filename(str): file path\n\n    Returns:\n        Dict: sequences weather is Munodi sequence\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCheckSequences(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up the test cases with sequences.\"\"\"\n        # Create a temporary file with test cases\n        self.test_file = 'test_sequences.dat'\n        with open(self.test_file, 'w') as f:\n            f.write(\"2,4,6,8\\n\")    # Munodi sequence (d = 2)\n            f.write(\"1,3,5,7\\n\")    # Munodi sequence (d = 2)\n            f.write(\"10,20,30\\n\")   # Munodi sequence (d = 10)\n            f.write(\"1,2,4,8\\n\")    # Not a Munodi sequence (d changes)\n            f.write(\"5,10,15,20\\n\") # Munodi sequence (d = 5)\n\n    def test_sequences(self):\n        \"\"\"Test the sequences for Munodi property.\"\"\"\n        expected_results = {\n            (2, 4, 6, 8): True,\n            (1, 3, 5, 7): True,\n            (10, 20, 30): True,\n            (1, 2, 4, 8): False,\n            (5, 10, 15, 20): True,\n        }\n        results = check_sequences(self.test_file)\n        for seq in expected_results:\n            self.assertEqual(results[seq], expected_results[seq])\n\n    def tearDown(self):\n        \"\"\"Clean up the test file after tests.\"\"\"\n        import os\n        os.remove(self.test_file)", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef check_sequences(filename:str) -> Dict:\n    \"\"\"\n    Read multiple sequences from the file and determine if each sequence is a \"Munodi sequence\". The definition of the Munodi sequence is based on a specific recursive relationship, that is, for even numbers, the next term is half of it, for odd numbers, the next term is 3*n + 1, and the sequence terminates when it encounters 1.\n    For example: (2, 4, 6, 8) is Mundi sequence\n\n    Args:\n        filename(str): file path\n\n    Returns:\n        Dict: sequences weather is Munodi sequence\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads sequences from a file and determines if each sequence is a \"Munodi sequence\".\n * \n * The Munodi sequence is defined by the following recursive relationship:\n * - For even numbers, the next term is half of the current number.\n * - For odd numbers, the next term is 3*n + 1.\n * - The sequence terminates when it reaches 1.\n * \n * For example, the sequence (2, 4, 6, 8) is a Munodi sequence.\n * \n * @param filename The path to the file containing sequences.\n * \n * @return A map where the keys are the sequences (as vectors of integers) and the values are booleans indicating whether the sequence is a valid Munodi sequence.\n */\nstd::map<std::vector<int>, bool> check_sequences(const std::string& filename) {", "test_code": "TEST_CASE(\"TestCheckSequences\", \"[check_sequences]\") {\n    // Set up the test cases with sequences.\n    std::string test_file = \"test_sequences.dat\";\n\n    // Write test sequences to the file\n    std::ofstream f(test_file);\n    f << \"2,4,6,8\\n\";    // Munodi sequence (d = 2)\n    f << \"1,3,5,7\\n\";    // Munodi sequence (d = 2)\n    f << \"10,20,30\\n\";   // Munodi sequence (d = 10)\n    f << \"1,2,4,8\\n\";    // Not a Munodi sequence (d changes)\n    f << \"5,10,15,20\\n\"; // Munodi sequence (d = 5)\n    f.close();\n\n    // Expected results\n    std::map<std::vector<int>, bool> expected_results = {\n        {{2, 4, 6, 8}, true},\n        {{1, 3, 5, 7}, true},\n        {{10, 20, 30}, true},\n        {{1, 2, 4, 8}, false},\n        {{5, 10, 15, 20}, true}\n    };\n\n    // Check the sequences\n    auto results = check_sequences(test_file);\n    for (const auto& [seq, expected] : expected_results) {\n        REQUIRE(results.find(seq) != results.end());\n        CHECK(results.at(seq) == expected);\n    }\n\n    // Clean up the test file after tests\n    std::filesystem::remove(test_file);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads sequences from a file and determines if each sequence is a \"Munodi sequence\".\n * \n * The Munodi sequence is defined by the following recursive relationship:\n * - For even numbers, the next term is half of the current number.\n * - For odd numbers, the next term is 3*n + 1.\n * - The sequence terminates when it reaches 1.\n * \n * For example, the sequence (2, 4, 6, 8) is a Munodi sequence.\n * \n * @param filename The path to the file containing sequences.\n * \n * @return A map where the keys are the sequences (as vectors of integers) and the values are booleans indicating whether the sequence is a valid Munodi sequence.\n */\nstd::map<std::vector<int>, bool> check_sequences(const std::string& filename) {", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 428, "code_type": "method", "original_language": "python", "file_path": "omnipy\\b1b9e610257c1ba11f73472fcf8452fd6fe8d90e\\src\\omnipy\\util\\mako_helpers.py\n", "question_type": "Data processing and transformation", "summary": "Parses a Python type hint string and returns the individual types as a list of strings.", "language_version_list": {"python": {"code_signature": "import ast\nfrom typing import List\n\n\ndef parse_type_hint(type_hint_string:str) -> List:\n    \"\"\"\n    Parses a Python type hint string and returns the individual types as a list of strings.\n\n    Args:\n        type_hint_string (str): The type hint string to parse.\n\n    Returns:\n        list: The individual types parsed from the type hint string.\n\n    Example:\n        type_hint = \"Union[typing.List[str], typing.Dict[str, int], Tuple[int, str], Optional[int]]\"\n        parsed_types = parse_type_hint(type_hint)\n        print(parsed_types)\n        # Output: ['Union', 'typing.List', 'str', 'typing.Dict', 'str', 'int', 'Tuple', 'int',\n                   'str', 'Optional', 'int']\n    \"\"\"\n", "test_code": "import unittest\n\n\n# Assuming the parse_type_hint function is defined above or imported here\n\nclass TestParseTypeHint(unittest.TestCase):\n\n    def test_basic_types(self):\n        type_hint = 'int'\n        expected = ['int']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n\n    def test_list_type(self):\n        type_hint = 'List[int]'\n        expected = ['List', 'int']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n\n    def test_union_type(self):\n        type_hint = 'Union[str, float]'\n        expected = ['Union', 'str', 'float']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n\n    def test_tuple_type(self):\n        type_hint = 'Tuple[str, int, float]'\n        expected = ['Tuple', 'str', 'int', 'float']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n\n    def test_complex_type(self):\n        type_hint = 'List[Union[int, float], Tuple[str, int]]'\n        expected = ['List', 'Union', 'int', 'float', 'Tuple', 'str', 'int']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n", "prompt": "please write a python function , the function signature as below import ast\nfrom typing import List\n\n\ndef parse_type_hint(type_hint_string:str) -> List:\n    \"\"\"\n    Parses a Python type hint string and returns the individual types as a list of strings.\n\n    Args:\n        type_hint_string (str): The type hint string to parse.\n\n    Returns:\n        list: The individual types parsed from the type hint string.\n\n    Example:\n        type_hint = \"Union[typing.List[str], typing.Dict[str, int], Tuple[int, str], Optional[int]]\"\n        parsed_types = parse_type_hint(type_hint)\n        print(parsed_types)\n        # Output: ['Union', 'typing.List', 'str', 'typing.Dict', 'str', 'int', 'Tuple', 'int',\n                   'str', 'Optional', 'int']\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 430, "code_type": "method", "original_language": "python", "file_path": "scratch\\b004193d0799617bd21194a35a69bf20c37f1230\\misc\\paths_between_rects.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "Check whether two rectangles intersect in the vertical direction", "language_version_list": {"python": {"code_signature": "def intersect_vertically(rect1, rect2):\n    \"\"\"\n    Check whether two rectangles intersect in the vertical direction\n\n    Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n    - (x1, y1) are the coordinates of the bottom-left corner.\n    - (x2, y2) are the coordinates of the top-right corner.\n\n    Args:\n        rect1 (tuple): The first rectangle defined by (x1, y1, x2, y2).\n        rect2 (tuple): The second rectangle defined by (x1, y1, x2, y2).\n\n    Returns:\n        bool: True if the rectangles intersect vertically, False otherwise.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIntersectVertically(unittest.TestCase):\n\n    def test_case1(self):\n        \"\"\"Test with overlapping rectangles.\"\"\"\n        rect1 = (0, 0, 2, 2)\n        rect2 = (1, 1, 3, 3)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n\n    def test_case2(self):\n        \"\"\"Test with overlapping rectangles.\"\"\"\n        rect1 = (-1, -1, 1, 1)\n        rect2 = (0, 0, 2, 2)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n\n    def test_case3(self):\n        # Test case where rectangles partially overlap vertically\n        rect1 = (0, 1, 2, 4)\n        rect2 = (1, 0, 3, 2)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n\n    def test_case4(self):\n        # Test case where rectangles are identical\n        rect1 = (0, 0, 2, 2)\n        rect2 = (0, 0, 2, 2)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n\n    def test_case5(self):\n        # Test case where one rectangle is completely inside the other\n        rect1 = (0, 0, 4, 4)\n        rect2 = (1, 1, 2, 2)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n", "prompt": "please write a python function , the function signature as below def intersect_vertically(rect1, rect2):\n    \"\"\"\n    Check whether two rectangles intersect in the vertical direction\n\n    Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n    - (x1, y1) are the coordinates of the bottom-left corner.\n    - (x2, y2) are the coordinates of the top-right corner.\n\n    Args:\n        rect1 (tuple): The first rectangle defined by (x1, y1, x2, y2).\n        rect2 (tuple): The second rectangle defined by (x1, y1, x2, y2).\n\n    Returns:\n        bool: True if the rectangles intersect vertically, False otherwise.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Checks whether two rectangles intersect in the vertical direction.\n * \n * Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n * - (x1, y1) are the coordinates of the bottom-left corner.\n * - (x2, y2) are the coordinates of the top-right corner.\n * \n * @param rect1 A tuple representing the first rectangle defined by (x1, y1, x2, y2).\n * @param rect2 A tuple representing the second rectangle defined by (x1, y1, x2, y2).\n * \n * @return True if the rectangles intersect vertically, False otherwise.\n */\nbool intersect_vertically(const std::tuple<int, int, int, int>& rect1, const std::tuple<int, int, int, int>& rect2) {\n", "test_code": "TEST_CASE(\"Test Intersect Vertically\", \"[intersect_vertically]\") {\n    SECTION(\"Test with overlapping rectangles\") {\n        auto rect1 = std::make_tuple(0, 0, 2, 2);\n        auto rect2 = std::make_tuple(1, 1, 3, 3);\n        REQUIRE(intersect_vertically(rect1, rect2));\n    }\n\n    SECTION(\"Test with overlapping rectangles\") {\n        auto rect1 = std::make_tuple(-1, -1, 1, 1);\n        auto rect2 = std::make_tuple(0, 0, 2, 2);\n        REQUIRE(intersect_vertically(rect1, rect2));\n    }\n\n    SECTION(\"Test case where rectangles partially overlap vertically\") {\n        auto rect1 = std::make_tuple(0, 1, 2, 4);\n        auto rect2 = std::make_tuple(1, 0, 3, 2);\n        REQUIRE(intersect_vertically(rect1, rect2));\n    }\n\n    SECTION(\"Test case where rectangles are identical\") {\n        auto rect1 = std::make_tuple(0, 0, 2, 2);\n        auto rect2 = std::make_tuple(0, 0, 2, 2);\n        REQUIRE(intersect_vertically(rect1, rect2));\n    }\n\n    SECTION(\"Test case where one rectangle is completely inside the other\") {\n        auto rect1 = std::make_tuple(0, 0, 4, 4);\n        auto rect2 = std::make_tuple(1, 1, 2, 2);\n        REQUIRE(intersect_vertically(rect1, rect2));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Checks whether two rectangles intersect in the vertical direction.\n * \n * Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n * - (x1, y1) are the coordinates of the bottom-left corner.\n * - (x2, y2) are the coordinates of the top-right corner.\n * \n * @param rect1 A tuple representing the first rectangle defined by (x1, y1, x2, y2).\n * @param rect2 A tuple representing the second rectangle defined by (x1, y1, x2, y2).\n * \n * @return True if the rectangles intersect vertically, False otherwise.\n */\nbool intersect_vertically(const std::tuple<int, int, int, int>& rect1, const std::tuple<int, int, int, int>& rect2) {\n", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 431, "code_type": "method", "original_language": "python", "file_path": "scratch\\b004193d0799617bd21194a35a69bf20c37f1230\\misc\\paths_between_rects.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "Check whether two rectangles intersect in the horizontal direction", "language_version_list": {"python": {"code_signature": "def intersect_horizontally(rect1, rect2):\n    \"\"\"\n    Determine if two rectangles intersect horizontally.\n\n    Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n    - (x1, y1) are the coordinates of the bottom-left corner.\n    - (x2, y2) are the coordinates of the top-right corner.\n\n    Args:\n        rect1 (tuple): The first rectangle defined by (x1, y1, x2, y2).\n        rect2 (tuple): The second rectangle defined by (x1, y1, x2, y2).\n\n    Returns:\n        bool: True if the rectangles intersect horizontally, False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestIntersectHorizontally(unittest.TestCase):\n\n    def test_case1(self):\n        \"\"\"Test with overlapping rectangles.\"\"\"\n        rect1 = (0, 0, 2, 2)\n        rect2 = (1, 1, 3, 3)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n\n    def test_case2(self):\n        \"\"\"Test with rectangles touching at a point (not overlapping).\"\"\"\n        rect1 = (0, 0, 1, 1)\n        rect2 = (1, 1, 2, 2)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n\n    def test_case3(self):\n        \"\"\"Test with adjacent rectangles (no overlap).\"\"\"\n        rect1 = (0, 0, 2, 2)\n        rect2 = (2, 0, 3, 3)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n\n    def test_case4(self):\n        \"\"\"Test with one rectangle fully inside another.\"\"\"\n        rect1 = (1, 1, 4, 4)\n        rect2 = (2, 2, 3, 3)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n\n    def test_case5(self):\n        \"\"\"Test with overlapping rectangles.\"\"\"\n        rect1 = (-1, -1, 1, 1)\n        rect2 = (0, 0, 2, 2)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n", "prompt": "please write a python function , the function signature as below def intersect_horizontally(rect1, rect2):\n    \"\"\"\n    Determine if two rectangles intersect horizontally.\n\n    Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n    - (x1, y1) are the coordinates of the bottom-left corner.\n    - (x2, y2) are the coordinates of the top-right corner.\n\n    Args:\n        rect1 (tuple): The first rectangle defined by (x1, y1, x2, y2).\n        rect2 (tuple): The second rectangle defined by (x1, y1, x2, y2).\n\n    Returns:\n        bool: True if the rectangles intersect horizontally, False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Determine if two rectangles intersect horizontally.\n *\n * Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n * - (x1, y1) are the coordinates of the bottom-left corner.\n * - (x2, y2) are the coordinates of the top-right corner.\n *\n * @param rect1 The first rectangle defined by (x1, y1, x2, y2).\n * @param rect2 The second rectangle defined by (x1, y1, x2, y2).\n * @return True if the rectangles intersect horizontally, False otherwise.\n */\nbool intersect_horizontally(const std::tuple<int, int, int, int>& rect1, const std::tuple<int, int, int, int>& rect2) {", "test_code": "TEST_CASE(\"Test intersect_horizontally\", \"[intersect_horizontally]\") {\n    SECTION(\"Test with overlapping rectangles\") {\n        auto rect1 = std::make_tuple(0, 0, 2, 2);\n        auto rect2 = std::make_tuple(1, 1, 3, 3);\n        REQUIRE(intersect_horizontally(rect1, rect2));\n    }\n\n    SECTION(\"Test with rectangles touching at a point (not overlapping)\") {\n        auto rect1 = std::make_tuple(0, 0, 1, 1);\n        auto rect2 = std::make_tuple(1, 1, 2, 2);\n        REQUIRE(intersect_horizontally(rect1, rect2));\n    }\n\n    SECTION(\"Test with adjacent rectangles (no overlap)\") {\n        auto rect1 = std::make_tuple(0, 0, 2, 2);\n        auto rect2 = std::make_tuple(2, 0, 3, 3);\n        REQUIRE(intersect_horizontally(rect1, rect2));\n    }\n\n    SECTION(\"Test with one rectangle fully inside another\") {\n        auto rect1 = std::make_tuple(1, 1, 4, 4);\n        auto rect2 = std::make_tuple(2, 2, 3, 3);\n        REQUIRE(intersect_horizontally(rect1, rect2));\n    }\n\n    SECTION(\"Test with overlapping rectangles\") {\n        auto rect1 = std::make_tuple(-1, -1, 1, 1);\n        auto rect2 = std::make_tuple(0, 0, 2, 2);\n        REQUIRE(intersect_horizontally(rect1, rect2));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Determine if two rectangles intersect horizontally.\n *\n * Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n * - (x1, y1) are the coordinates of the bottom-left corner.\n * - (x2, y2) are the coordinates of the top-right corner.\n *\n * @param rect1 The first rectangle defined by (x1, y1, x2, y2).\n * @param rect2 The second rectangle defined by (x1, y1, x2, y2).\n * @return True if the rectangles intersect horizontally, False otherwise.\n */\nbool intersect_horizontally(const std::tuple<int, int, int, int>& rect1, const std::tuple<int, int, int, int>& rect2) {", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 433, "code_type": "method", "original_language": "python", "file_path": "simd-bot\\9e5fa6904dc8e0d459ac3cc3679b62fdc336f660\\tools\\txt2pdf.py\n", "question_type": "Data processing and transformation", "summary": "Extracts paragraph (separated by two newlines) lines (separated by one newline) in text\n", "language_version_list": {"python": {"code_signature": "def extract_paragraphs_and_lines(text: str):\n    \"\"\"\n    Extracts paragraphs and lines from the given text.The paragraphs end with \\n\\n The line end with \\n\n    For example:\n        input: First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\n        output:\n\n    Args:\n        text (str): The input text from which paragraphs and lines will be extracted.\n\n    Returns:\n        dict: A dictionary containing:\n            - 'paragraphs': A list of paragraphs extracted from the text.\n            - 'lines': A list of lines extracted from the text.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestExtractParagraphsAndLines(unittest.TestCase):\n\n    def test_single_paragraph(self):\n        input_text = \"This is a single paragraph.\"\n        expected_output = {\n            'paragraphs': [\"This is a single paragraph.\"],\n            'lines': [\"This is a single paragraph.\"]\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n\n    def test_multiple_paragraphs(self):\n        input_text = \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\"\n        expected_output = {\n            'paragraphs': [\n                \"First paragraph.\\nThis is the second line.\",\n                \"Second paragraph.\\nAnother line.\"\n            ],\n            'lines': [\n                \"First paragraph.\",\n                \"This is the second line.\",\n                \"Second paragraph.\",\n                \"Another line.\"\n            ]\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n\n    def test_leading_and_trailing_whitespace(self):\n        input_text = \"   This paragraph has leading whitespace.\\nAnd a line after.\\n\\n   This one has trailing whitespace.   \"\n        expected_output = {\n            'paragraphs': [\n                \"This paragraph has leading whitespace.\\nAnd a line after.\",\n                \"This one has trailing whitespace.\"\n            ],\n            'lines': [\n                \"This paragraph has leading whitespace.\",\n                \"And a line after.\",\n                \"This one has trailing whitespace.\"\n            ]\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n\n    def test_empty_string(self):\n        input_text = \"\"\n        expected_output = {\n            'paragraphs': [],\n            'lines': []\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n\n    def test_multiple_empty_paragraphs(self):\n        input_text = \"\\n\\n\\n\"\n        expected_output = {\n            'paragraphs': [],\n            'lines': []\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n", "prompt": "please write a python function , the function signature as below def extract_paragraphs_and_lines(text: str):\n    \"\"\"\n    Extracts paragraphs and lines from the given text.The paragraphs end with \\n\\n The line end with \\n\n    For example:\n        input: First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\n        output:\n\n    Args:\n        text (str): The input text from which paragraphs and lines will be extracted.\n\n    Returns:\n        dict: A dictionary containing:\n            - 'paragraphs': A list of paragraphs extracted from the text.\n            - 'lines': A list of lines extracted from the text.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extracts paragraphs and lines from the given text.\n * \n * Paragraphs are defined as segments of text that end with \"\\n\\n\", \n * and lines end with a single \"\\n\".\n * \n * @note Example:\n *     Input: \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\"\n *     Output: (See function behavior for exact output structure)\n * \n * @param text The input text from which paragraphs and lines will be extracted.\n * \n * @return A map containing:\n *         - 'paragraphs': A vector of strings representing paragraphs extracted from the text.\n *         - 'lines': A vector of strings representing lines extracted from the text.\n */\nstd::map<std::string, std::vector<std::string>> extract_paragraphs_and_lines(const std::string& text);\n", "test_code": "TEST_CASE(\"Test extract_paragraphs_and_lines\") {\n    SECTION(\"Single paragraph\") {\n        std::string input_text = \"This is a single paragraph.\";\n        std::map<std::string, std::vector<std::string>> expected_output = {\n            {\"paragraphs\", {\"This is a single paragraph.\"}},\n            {\"lines\", {\"This is a single paragraph.\"}}\n        };\n\n        auto result = extract_paragraphs_and_lines(input_text);\n        REQUIRE(result[\"paragraphs\"] == expected_output[\"paragraphs\"]);\n        REQUIRE(result[\"lines\"] == expected_output[\"lines\"]);\n    }\n\n    SECTION(\"Multiple paragraphs\") {\n        std::string input_text = \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\";\n        std::map<std::string, std::vector<std::string>> expected_output = {\n            {\"paragraphs\", {\"First paragraph.\\nThis is the second line.\", \"Second paragraph.\\nAnother line.\"}},\n            {\"lines\", {\"First paragraph.\", \"This is the second line.\", \"Second paragraph.\", \"Another line.\"}}\n        };\n\n        auto result = extract_paragraphs_and_lines(input_text);\n        REQUIRE(result[\"paragraphs\"] == expected_output[\"paragraphs\"]);\n        REQUIRE(result[\"lines\"] == expected_output[\"lines\"]);\n    }\n\n    SECTION(\"Leading and trailing whitespace\") {\n        std::string input_text = \"   This paragraph has leading whitespace.\\nAnd a line after.\\n\\n   This one has trailing whitespace.   \";\n        std::map<std::string, std::vector<std::string>> expected_output = {\n            {\"paragraphs\", {\"This paragraph has leading whitespace.\\nAnd a line after.\", \"This one has trailing whitespace.\"}},\n            {\"lines\", {\"This paragraph has leading whitespace.\", \"And a line after.\", \"This one has trailing whitespace.\"}}\n        };\n\n        auto result = extract_paragraphs_and_lines(input_text);\n        REQUIRE(result[\"paragraphs\"] == expected_output[\"paragraphs\"]);\n        REQUIRE(result[\"lines\"] == expected_output[\"lines\"]);\n    }\n\n    SECTION(\"Empty string\") {\n        std::string input_text = \"\";\n        std::map<std::string, std::vector<std::string>> expected_output = {\n            {\"paragraphs\", {}},\n            {\"lines\", {}}\n        };\n\n        auto result = extract_paragraphs_and_lines(input_text);\n        REQUIRE(result[\"paragraphs\"] == expected_output[\"paragraphs\"]);\n        REQUIRE(result[\"lines\"] == expected_output[\"lines\"]);\n    }\n\n    SECTION(\"Multiple empty paragraphs\") {\n        std::string input_text = \"\\n\\n\\n\";\n        std::map<std::string, std::vector<std::string>> expected_output = {\n            {\"paragraphs\", {}},\n            {\"lines\", {}}\n        };\n\n        auto result = extract_paragraphs_and_lines(input_text);\n        REQUIRE(result[\"paragraphs\"] == expected_output[\"paragraphs\"]);\n        REQUIRE(result[\"lines\"] == expected_output[\"lines\"]);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts paragraphs and lines from the given text.\n * \n * Paragraphs are defined as segments of text that end with \"\\n\\n\", \n * and lines end with a single \"\\n\".\n * \n * @note Example:\n *     Input: \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\"\n *     Output: (See function behavior for exact output structure)\n * \n * @param text The input text from which paragraphs and lines will be extracted.\n * \n * @return A map containing:\n *         - 'paragraphs': A vector of strings representing paragraphs extracted from the text.\n *         - 'lines': A vector of strings representing lines extracted from the text.\n */\nstd::map<std::string, std::vector<std::string>> extract_paragraphs_and_lines(const std::string& text);\n", "addition_info": ""}, "java": {"code_signature": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class TextProcessor {\n\n    /**\n     * Extracts paragraphs and lines from the given text. Paragraphs end with \\n\\n and lines end with \\n.\n     *\n     * Example usage:\n     * Input: \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\"\n     * Output: A Map where:\n     *         - Key 'paragraphs' maps to a List of paragraphs extracted from the text.\n     *         - Key 'lines' maps to a List of lines extracted from the text.\n     *\n     * @param text The input text from which paragraphs and lines will be extracted.\n     * @return A Map containing:\n     *         - 'paragraphs': A List of paragraphs extracted from the text.\n     *         - 'lines': A List of lines extracted from the text.\n     */\n    public static Map<String, List<String>> extractParagraphsAndLines(String text) {\n        // Method implementation goes here\n        return new HashMap<>();\n    }\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport static org.junit.Assert.assertEquals;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\n@RunWith(JUnit4.class)\npublic class Tester {\n\n    private static Map<String, List<String>> extract_paragraphs_and_lines(String text) {\n        String[] paragraphs = text.split(\"\\n\\n\");\n        String[] lines = text.split(\"\\n\");\n\n        List<String> paragraphsList = Arrays.asList(paragraphs);\n        List<String> linesList = Arrays.asList(lines);\n\n        return Map.of(\n            \"paragraphs\", paragraphsList,\n            \"lines\", linesList\n        );\n    }\n\n    @Test\n    public void testExtractParagraphsAndLines() {\n        // Test data\n        String text = \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\";\n\n        // Expected result\n        Map<String, List<String>> expectedResult = Map.of(\n            \"paragraphs\", Arrays.asList(\"First paragraph.\\nThis is the second line.\", \"Second paragraph.\\nAnother line.\"),\n            \"lines\", Arrays.asList(\"First paragraph.\", \"This is the second line.\", \"Second paragraph.\", \"Another line.\")\n        );\n\n        // Actual result\n        Map<String, List<String>> actualResult = extract_paragraphs_and_lines(text);\n\n        // Assertion\n        assertEquals(expectedResult, actualResult);\n    }\n}", "prompt": "please write a java function , the function signature as below import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class TextProcessor {\n\n    /**\n     * Extracts paragraphs and lines from the given text. Paragraphs end with \\n\\n and lines end with \\n.\n     *\n     * Example usage:\n     * Input: \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\"\n     * Output: A Map where:\n     *         - Key 'paragraphs' maps to a List of paragraphs extracted from the text.\n     *         - Key 'lines' maps to a List of lines extracted from the text.\n     *\n     * @param text The input text from which paragraphs and lines will be extracted.\n     * @return A Map containing:\n     *         - 'paragraphs': A List of paragraphs extracted from the text.\n     *         - 'lines': A List of lines extracted from the text.\n     */\n    public static Map<String, List<String>> extractParagraphsAndLines(String text) {\n        // Method implementation goes here\n        return new HashMap<>();\n    }\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 438, "code_type": "method", "original_language": "python", "file_path": "CS_TA_work_week5\\6c19b5ecf46fd81927499bee5e42f58cebacebcf\\src\\starter_code\\chatgpt_solution_1.py\n", "question_type": "Data processing and transformation", "summary": "conver csv file to dataframe", "language_version_list": {"python": {"code_signature": "import pandas as pd\n\n\ndef read_csv_to_dataframe(file_path: str) -> pd.DataFrame:\n    \"\"\"\n    Reads a CSV file and converts it to a pandas DataFrame.\n\n    Args:\n        file_path (str): The path to the CSV file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the data from the CSV file.\n    \"\"\"\n", "test_code": "import unittest\nimport pandas as pd\nimport os\n\n\nclass TestReadCsvToDataFrame(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up temporary CSV files for testing.\"\"\"\n        # Create a valid CSV file\n        self.valid_csv_path = 'valid.csv'\n        pd.DataFrame({'col1': [1, 2], 'col2': [3, 4]}).to_csv(self.valid_csv_path, index=False)\n\n        # Create an empty CSV file\n        self.empty_csv_path = 'empty.csv'\n        open(self.empty_csv_path, 'w').close()\n\n        # Create an invalid format CSV file\n        self.invalid_csv_path = 'invalid.csv'\n        with open(self.invalid_csv_path, 'w') as f:\n            f.write(\"col1, col2\\n1, 2\\n3, 4\\ninvalid_line\")\n\n    def tearDown(self):\n        \"\"\"Clean up temporary files after tests.\"\"\"\n        if os.path.exists(self.valid_csv_path):\n            os.remove(self.valid_csv_path)\n        if os.path.exists(self.empty_csv_path):\n            os.remove(self.empty_csv_path)\n        if os.path.exists(self.invalid_csv_path):\n            os.remove(self.invalid_csv_path)\n\n    def test_valid_csv(self):\n        \"\"\"Test reading a valid CSV file.\"\"\"\n        df = read_csv_to_dataframe(self.valid_csv_path)\n        self.assertIsInstance(df, pd.DataFrame)\n        self.assertEqual(df.shape, (2, 2))\n        self.assertListEqual(list(df.columns), ['col1', 'col2'])\n\n\n\n    def test_correct_data(self):\n        \"\"\"Test if the correct data is read from the CSV file.\"\"\"\n        df = read_csv_to_dataframe(self.valid_csv_path)\n        expected_data = {'col1': [1, 2], 'col2': [3, 4]}\n        pd.testing.assert_frame_equal(df, pd.DataFrame(expected_data))\n\n    def test_read_csv_with_missing_values(self):\n        \"\"\"Test reading a CSV file with missing values.\"\"\"\n        missing_values_csv_path = 'missing_values.csv'\n        pd.DataFrame({'col1': [1, None], 'col2': [None, 4]}).to_csv(missing_values_csv_path, index=False)\n        df = read_csv_to_dataframe(missing_values_csv_path)\n        self.assertTrue(df.isnull().values.any())\n        os.remove(missing_values_csv_path)\n\n    def test_large_csv_file(self):\n        \"\"\"Test reading a large CSV file.\"\"\"\n        large_csv_path = 'large.csv'\n        large_df = pd.DataFrame({'col1': range(1000), 'col2': range(1000, 2000)})\n        large_df.to_csv(large_csv_path, index=False)\n        df = read_csv_to_dataframe(large_csv_path)\n        self.assertEqual(df.shape, (1000, 2))\n        os.remove(large_csv_path)", "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef read_csv_to_dataframe(file_path: str) -> pd.DataFrame:\n    \"\"\"\n    Reads a CSV file and converts it to a pandas DataFrame.\n\n    Args:\n        file_path (str): The path to the CSV file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the data from the CSV file.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 442, "code_type": "method", "original_language": "python", "file_path": "fiware-orion\\cca7d63318dee393d4e8874ada0f7790b63b28c9\\scripts\\oriondb_consistency\\oriondb_co", "question_type": "Data processing and transformation", "summary": "Convert strings in nested structures (e.g. dictionaries, arrays) to numbers (integers or floating point numbers) as much as possible\n", "language_version_list": {"python": {"code_signature": "from typing import List, Dict, Union\n\n\ndef convert_strings_to_numbers(data: Union[Dict, List]) -> Union[Dict, List]:\n    \"\"\"\n    Convert strings in nested structures (e.g. dictionaries, arrays) to numbers (integers or floating point numbers) as much as possible\n\n    Args:\n        data (Union[Dict,List]): before convert data\n\n    Returns:\n        Union[Dict,List]: after convert data\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestConvertStringsToNumbers(unittest.TestCase):\n\n    def test_flat_dict(self):\n        data = {'a': '1', 'b': '2.5', 'c': 'not a number'}\n        expected = {'a': 1, 'b': 2.5, 'c': 'not a number'}\n        self.assertEqual(convert_strings_to_numbers(data), expected)\n\n    def test_nested_dict(self):\n        data = {'x': {'y': '10', 'z': '3.14'}, 'w': '20.0'}\n        expected = {'x': {'y': 10, 'z': 3.14}, 'w': 20.0}\n        self.assertEqual(convert_strings_to_numbers(data), expected)\n\n    def test_list_of_strings(self):\n        data = ['1', '2.5', '3', 'invalid']\n        expected = [1, 2.5, 3, 'invalid']\n        self.assertEqual(convert_strings_to_numbers(data), expected)\n\n    def test_mixed_structure(self):\n        data = {'numbers': ['1', '2.0', 3], 'more_numbers': [{'num': '4'}, '5']}\n        expected = {'numbers': [1, 2.0, 3], 'more_numbers': [{'num': 4}, 5]}\n        self.assertEqual(convert_strings_to_numbers(data), expected)\n\n    def test_empty_structure(self):\n        data = {}\n        expected = {}\n        self.assertEqual(convert_strings_to_numbers(data), expected)", "prompt": "please write a python function , the function signature as below from typing import List, Dict, Union\n\n\ndef convert_strings_to_numbers(data: Union[Dict, List]) -> Union[Dict, List]:\n    \"\"\"\n    Convert strings in nested structures (e.g. dictionaries, arrays) to numbers (integers or floating point numbers) as much as possible\n\n    Args:\n        data (Union[Dict,List]): before convert data\n\n    Returns:\n        Union[Dict,List]: after convert data\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 443, "code_type": "method", "original_language": "python", "file_path": "GQLSpection\\19536007e2c2721b74b780daf4d15f6e31f78927\\src\\gqlspection\\utils.py\n", "question_type": "Data processing and transformation", "summary": "Process a string by compressing multiple consecutive whitespace characters into a single space\n", "language_version_list": {"python": {"code_signature": "def compress_whitespace(input_string: str):\n    \"\"\"\n    Compress multiple consecutive whitespace characters in a string into a single space.\n\n    Args:\n        input_string(str): The string to be processed.\n\n    Returns:\n        str: The processed string with compressed whitespace.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCompressWhitespace(unittest.TestCase):\n\n    def test_single_spaces(self):\n        \"\"\"Test with a string containing single spaces\"\"\"\n        self.assertEqual(compress_whitespace(\"This is a test string.\"), \"This is a test string.\")\n\n    def test_multiple_spaces(self):\n        \"\"\"Test with a string containing multiple spaces\"\"\"\n        self.assertEqual(compress_whitespace(\"This    is  a   test   string.\"), \"This is a test string.\")\n\n    def test_leading_trailing_spaces(self):\n        \"\"\"Test with leading and trailing spaces\"\"\"\n        self.assertEqual(compress_whitespace(\"   Leading and trailing spaces   \"), \"Leading and trailing spaces\")\n\n    def test_only_spaces(self):\n        \"\"\"Test with a string containing only spaces\"\"\"\n        self.assertEqual(compress_whitespace(\"       \"), \"\")\n\n    def test_empty_string(self):\n        \"\"\"Test with an empty string\"\"\"\n        self.assertEqual(compress_whitespace(\"\"), \"\")", "prompt": "please write a python function , the function signature as below def compress_whitespace(input_string: str):\n    \"\"\"\n    Compress multiple consecutive whitespace characters in a string into a single space.\n\n    Args:\n        input_string(str): The string to be processed.\n\n    Returns:\n        str: The processed string with compressed whitespace.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <string>\n\n/**\n * @brief Compress multiple consecutive whitespace characters in a string into a single space.\n *\n * @param input_string The string to be processed.\n * @return The processed string with compressed whitespace.\n */\nstd::string compress_whitespace(const std::string& input_string) {}\n", "test_code": "TEST_CASE(\"Test compress_whitespace function\", \"[compress_whitespace]\") {\n    SECTION(\"Test with a string containing single spaces\") {\n        std::string input = \"This is a test string.\";\n        std::string expected = \"This is a test string.\";\n        REQUIRE(compress_whitespace(input) == expected);\n    }\n\n    SECTION(\"Test with a string containing multiple spaces\") {\n        std::string input = \"This    is  a   test   string.\";\n        std::string expected = \"This is a test string.\";\n        REQUIRE(compress_whitespace(input) == expected);\n    }\n\n    SECTION(\"Test with leading and trailing spaces\") {\n        std::string input = \"   Leading and trailing spaces   \";\n        std::string expected = \"Leading and trailing spaces\";\n        REQUIRE(compress_whitespace(input) == expected);\n    }\n\n    SECTION(\"Test with a string containing only spaces\") {\n        std::string input = \"       \";\n        std::string expected = \"\";\n        REQUIRE(compress_whitespace(input) == expected);\n    }\n\n    SECTION(\"Test with an empty string\") {\n        std::string input = \"\";\n        std::string expected = \"\";\n        REQUIRE(compress_whitespace(input) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <string>\n\n/**\n * @brief Compress multiple consecutive whitespace characters in a string into a single space.\n *\n * @param input_string The string to be processed.\n * @return The processed string with compressed whitespace.\n */\nstd::string compress_whitespace(const std::string& input_string) {}\n", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 444, "code_type": "method", "original_language": "python", "file_path": "GQLSpection\\19536007e2c2721b74b780daf4d15f6e31f78927\\src\\gqlspection\\utils.py\n", "question_type": "Data processing and transformation", "summary": "Formats a string into a commented block with specified maximum line length.", "language_version_list": {"python": {"code_signature": "def format_comment(string, max_length=60):\n    \"\"\"\n    Formats a string into a commented block with specified maximum line length.\n\n    Args:\n        string (str): The input string to format.\n        max_length (int): Maximum length of each line in the output.\n\n    Returns:\n        str: A formatted string with each line prefixed by '# ' and not exceeding the specified max_length.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFormatComment(unittest.TestCase):\n\n    def test_short_string(self):\n        \"\"\"Test with a short string that fits within max_length\"\"\"\n        input_string = \"This is a test.\"\n        expected_output = \"# This is a test.\"\n        self.assertEqual(format_comment(input_string), expected_output)\n\n    def test_long_string(self):\n        \"\"\"Test with a longer string that exceeds max_length\"\"\"\n        input_string = \"This is a test of the format_comment function which should wrap long lines correctly.\"\n        expected_output = (\n            \"# This is a test of the format_comment function which should\\n\"\n            \"# wrap long lines correctly.\"\n        )\n        self.assertEqual(format_comment(input_string, max_length=60), expected_output)\n\n    def test_multiple_lines(self):\n        \"\"\"Test with multiple lines of input\"\"\"\n        input_string = \"First line.\\nSecond line that is quite long and needs to be wrapped.\"\n        expected_output = (\n            \"# First line.\\n\"\n            \"# Second line that is quite long and needs to be wrapped.\"\n        )\n        self.assertEqual(format_comment(input_string, max_length=60), expected_output)\n\n    def test_exact_max_length(self):\n        \"\"\"Test with a line that is exactly max_length characters long\"\"\"\n        input_string = \"A\" * 60  # 60 characters long\n        expected_output = \"# \" + \"A\" * 60\n        self.assertEqual(format_comment(input_string, max_length=60), expected_output)\n\n    def test_empty_string(self):\n        \"\"\"Test with an empty string\"\"\"\n        input_string = \"\"\n        expected_output = \"# \"\n        self.assertEqual(format_comment(input_string), expected_output)\n", "prompt": "please write a python function , the function signature as below def format_comment(string, max_length=60):\n    \"\"\"\n    Formats a string into a commented block with specified maximum line length.\n\n    Args:\n        string (str): The input string to format.\n        max_length (int): Maximum length of each line in the output.\n\n    Returns:\n        str: A formatted string with each line prefixed by '# ' and not exceeding the specified max_length.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <string>\n\n/**\n * @brief Formats a string into a commented block with a specified maximum line length.\n *\n * This function takes an input string and formats it into lines that are\n * each prefixed by '// '. The lines will not exceed the specified maximum\n * length, ensuring that the output is neatly formatted.\n *\n * @param string The input string to format.\n * @param max_length Maximum length of each line in the output.\n * @return A formatted string with each line prefixed by '// ' and not exceeding \n *         the specified max_length.\n */\nstd::string format_comment(const std::string& string, int max_length = 60) {}\n", "test_code": "TEST_CASE(\"Test format_comment function\", \"[format_comment]\") {\n    SECTION(\"Test with a short string that fits within max_length\") {\n        std::string input_string = \"This is a test.\";\n        std::string expected_output = \"# This is a test.\";\n        REQUIRE(format_comment(input_string) == expected_output);\n    }\n\n    SECTION(\"Test with a longer string that exceeds max_length\") {\n        std::string input_string = \"This is a test of the format_comment function which should wrap long lines correctly.\";\n        std::string expected_output =\n            \"# This is a test of the format_comment function which should\\n\"\n            \"# wrap long lines correctly.\";\n        REQUIRE(format_comment(input_string, 60) == expected_output);\n    }\n\n    SECTION(\"Test with multiple lines of input\") {\n        std::string input_string = \"First line.\\nSecond line that is quite long and needs to be wrapped.\";\n        std::string expected_output =\n            \"# First line.\\n\"\n            \"# Second line that is quite long and needs to be wrapped.\";\n        REQUIRE(format_comment(input_string, 60) == expected_output);\n    }\n\n    SECTION(\"Test with a line that is exactly max_length characters long\") {\n        std::string input_string(60, 'A');  // 60 characters long\n        std::string expected_output = \"# \" + std::string(60, 'A');\n        REQUIRE(format_comment(input_string, 60) == expected_output);\n    }\n\n    SECTION(\"Test with an empty string\") {\n        std::string input_string = \"\";\n        std::string expected_output = \"# \";\n        REQUIRE(format_comment(input_string) == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <string>\n\n/**\n * @brief Formats a string into a commented block with a specified maximum line length.\n *\n * This function takes an input string and formats it into lines that are\n * each prefixed by '// '. The lines will not exceed the specified maximum\n * length, ensuring that the output is neatly formatted.\n *\n * @param string The input string to format.\n * @param max_length Maximum length of each line in the output.\n * @return A formatted string with each line prefixed by '// ' and not exceeding \n *         the specified max_length.\n */\nstd::string format_comment(const std::string& string, int max_length = 60) {}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Formats a string into a commented block with specified maximum line length.\n *\n * @param string     the input string to format\n * @param maxLength  the maximum length of each line in the output\n * @return           a formatted string with each line prefixed by '# ' and not exceeding the specified maxLength\n */\npublic String formatComment(String string, int maxLength) {", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testFormatComment() {\n        String input = \"This is a long string that needs to be formatted into multiple lines.\";\n        int maxLength = 60;\n        String expectedOutput = \"# This is a long string that\\n# needs to be formatted into\\n# multiple lines.\";\n\n        String actualOutput = formatComment(input, maxLength);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    private String formatComment(String string, int maxLength) {\n        StringBuilder result = new StringBuilder();\n        String[] words = string.split(\" \");\n        StringBuilder currentLine = new StringBuilder(\"# \");\n\n        for (String word : words) {\n            if ((currentLine.length() + word.length()) > maxLength) {\n                result.append(currentLine).append(\"\\n\");\n                currentLine = new StringBuilder(\"# \").append(word);\n            } else {\n                currentLine.append(word).append(\" \");\n            }\n        }\n\n        result.append(currentLine);\n        return result.toString().trim();\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Formats a string into a commented block with specified maximum line length.\n *\n * @param string     the input string to format\n * @param maxLength  the maximum length of each line in the output\n * @return           a formatted string with each line prefixed by '# ' and not exceeding the specified maxLength\n */\npublic String formatComment(String string, int maxLength) {,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 445, "code_type": "method", "original_language": "python", "file_path": "arena-py\\0bd135904574bb26425a253ed4e67a7c92fa2697\\tools\\calibrate-vr\\calibrate.py\n", "question_type": "Data processing and transformation", "summary": "Create a pose matrix representing a rotation about a given axis", "language_version_list": {"python": {"code_signature": "import numpy\nimport numpy as np\n\n\ndef create_rot_matrix(angle_deg: float, axis: str) -> numpy.ndarray:\n    \"\"\"\n    Create a pose matrix representing a rotation about a given axis.\n\n    Args:\n        angle_deg (float): Rotation angle in degrees.\n        axis (str): Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n\n    Returns:\n        numpy.ndarray: 4x4 pose matrix representing the rotation.\n    \"\"\"\n", "test_code": "import unittest\nimport numpy as np\nfrom numpy.testing import assert_array_almost_equal\n\n\n\nclass TestCreateRotMatrix(unittest.TestCase):\n    def test_rotation_x_90_degrees(self):\n        \"\"\" Test rotation around X-axis for 90 degrees \"\"\"\n        expected_matrix = np.array([\n            [1, 0, 0, 0],\n            [0, 0, -1, 0],\n            [0, 1, 0, 0],\n            [0, 0, 0, 1]\n        ])\n        result_matrix = create_rot_matrix(90, 'x')\n        assert_array_almost_equal(result_matrix, expected_matrix)\n\n    def test_rotation_y_180_degrees(self):\n        \"\"\" Test rotation around Y-axis for 180 degrees \"\"\"\n        expected_matrix = np.array([\n            [-1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, -1, 0],\n            [0, 0, 0, 1]\n        ])\n        result_matrix = create_rot_matrix(180, 'y')\n        assert_array_almost_equal(result_matrix, expected_matrix)\n\n    def test_rotation_z_270_degrees(self):\n        \"\"\" Test rotation around Z-axis for 270 degrees (or -90 degrees) \"\"\"\n        expected_matrix = np.array([\n            [0, 1, 0, 0],\n            [-1, 0, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]\n        ])\n        result_matrix = create_rot_matrix(270, 'z')\n        assert_array_almost_equal(result_matrix, expected_matrix)\n\n    def test_invalid_axis(self):\n        \"\"\" Test behavior with invalid axis input \"\"\"\n        with self.assertRaises(ValueError):\n            create_rot_matrix(90, 'a')\n\n    def test_zero_rotation(self):\n        \"\"\" Test zero degree rotation which should lead to identity matrix \"\"\"\n        expected_matrix = np.eye(4)\n        result_matrix = create_rot_matrix(0, 'x')\n        assert_array_almost_equal(result_matrix, expected_matrix)", "prompt": "please write a python function , the function signature as below import numpy\nimport numpy as np\n\n\ndef create_rot_matrix(angle_deg: float, axis: str) -> numpy.ndarray:\n    \"\"\"\n    Create a pose matrix representing a rotation about a given axis.\n\n    Args:\n        angle_deg (float): Rotation angle in degrees.\n        axis (str): Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n\n    Returns:\n        numpy.ndarray: 4x4 pose matrix representing the rotation.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <Eigen/Dense>\n#include <string>\n\n/**\n * @brief Create a pose matrix representing a rotation about a given axis.\n *\n * @param angle_deg Rotation angle in degrees.\n * @param axis Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n * @return Eigen::Matrix4d 4x4 pose matrix representing the rotation.\n */\nEigen::Matrix4d create_rot_matrix(double angle_deg, const std::string& axis);", "test_code": "TEST_CASE(\"Create Rotation Matrix\", \"[rotation]\") {\n    // Test for X-axis rotation\n    auto xRotation = create_rot_matrix(90.0, 'X');\n    REQUIRE(xRotation(1, 1) == Approx(cos(M_PI / 2)).margin(1e-6));\n    REQUIRE(xRotation(1, 2) == Approx(-sin(M_PI / 2)).margin(1e-6));\n    REQUIRE(xRotation(2, 1) == Approx(sin(M_PI / 2)).margin(1e-6));\n    REQUIRE(xRotation(2, 2) == Approx(cos(M_PI / 2)).margin(1e-6));\n\n    // Test for Y-axis rotation\n    auto yRotation = create_rot_matrix(90.0, 'Y');\n    REQUIRE(yRotation(0, 0) == Approx(cos(M_PI / 2)).margin(1e-6));\n    REQUIRE(yRotation(0, 2) == Approx(sin(M_PI / 2)).margin(1e-6));\n    REQUIRE(yRotation(2, 0) == Approx(-sin(M_PI / 2)).margin(1e-6));\n    REQUIRE(yRotation(2, 2) == Approx(cos(M_PI / 2)).margin(1e-6));\n\n    // Test for Z-axis rotation\n    auto zRotation = create_rot_matrix(90.0, 'Z');\n    REQUIRE(zRotation(0, 0) == Approx(cos(M_PI / 2)).margin(1e-6));\n    REQUIRE(zRotation(0, 1) == Approx(-sin(M_PI / 2)).margin(1e-6));\n    REQUIRE(zRotation(1, 0) == Approx(sin(M_PI / 2)).margin(1e-6));\n    REQUIRE(zRotation(1, 1) == Approx(cos(M_PI / 2)).margin(1e-6));\n}\n", "prompt": "please write a cpp function , the function signature as below #include <Eigen/Dense>\n#include <string>\n\n/**\n * @brief Create a pose matrix representing a rotation about a given axis.\n *\n * @param angle_deg Rotation angle in degrees.\n * @param axis Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n * @return Eigen::Matrix4d 4x4 pose matrix representing the rotation.\n */\nEigen::Matrix4d create_rot_matrix(double angle_deg, const std::string& axis);", "addition_info": ""}, "java": {"code_signature": "import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\nimport org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * Create a pose matrix representing a rotation about a given axis.\n *\n * @param angleDeg Rotation angle in degrees.\n * @param axis     Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n * @return A 4x4 pose matrix representing the rotation.\n */\npublic class PoseMatrixCreator {\n\n    public static RealMatrix createRotMatrix(double angleDeg, String axis) {\n        // Implementation goes here\n    }\n}\n", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    private double[][] identityMatrix = {\n            {1, 0, 0, 0},\n            {0, 1, 0, 0},\n            {0, 0, 1, 0},\n            {0, 0, 0, 1}\n    };\n\n    @BeforeEach\n    public void setUp() {\n        // Setup code if needed\n    }\n\n    @Test\n    public void testCreateRotMatrix_XAxis_90Degrees() {\n        double[][] expected = {\n                {1, 0, 0, 0},\n                {0, 0, -1, 0},\n                {0, 1, 0, 0},\n                {0, 0, 0, 1}\n        };\n        double[][] result = createRotMatrix(90, \"X\");\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testCreateRotMatrix_YAxis_90Degrees() {\n        double[][] expected = {\n                {0, 0, 1, 0},\n                {0, 1, 0, 0},\n                {-1, 0, 0, 0},\n                {0, 0, 0, 1}\n        };\n        double[][] result = createRotMatrix(90, \"Y\");\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testCreateRotMatrix_ZAxis_90Degrees() {\n        double[][] expected = {\n                {0, -1, 0, 0},\n                {1, 0, 0, 0},\n                {0, 0, 1, 0},\n                {0, 0, 0, 1}\n        };\n        double[][] result = createRotMatrix(90, \"Z\");\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testCreateRotMatrix_InvalidAxis() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> {\n            createRotMatrix(90, \"W\");\n        });\n        assertEquals(\"Invalid axis provided\", exception.getMessage());\n    }\n\n    private double[][] createRotMatrix(double angleDeg, String axis) {\n        // Implement the logic for creating the rotation matrix here\n        // For simplicity, let's assume it returns an identity matrix\n        return identityMatrix;\n    }\n}\n", "prompt": "please write a java function , the function signature as below import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\nimport org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * Create a pose matrix representing a rotation about a given axis.\n *\n * @param angleDeg Rotation angle in degrees.\n * @param axis     Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n * @return A 4x4 pose matrix representing the rotation.\n */\npublic class PoseMatrixCreator {\n\n    public static RealMatrix createRotMatrix(double angleDeg, String axis) {\n        // Implementation goes here\n    }\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 451, "code_type": "method", "original_language": "python", "file_path": "avenet42\\28a087a9b35de7f7b5c7999b9d5b1e72c2e878c4\\tools\\helper_convertfont.py\n", "question_type": "File operations and I/O operation", "summary": "Converts an image to a binary representation.Convert the image to black and white mode, that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black pixel value of 0", "language_version_list": {"python": {"code_signature": "def convert_image_to_bits(image_path: str):\n    \"\"\"\n    Converts an image to a binary representation.Convert the image to black and white mode, that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black pixel value of 0\n\n    Args:\n        image_path (str): The file path of the image to convert.\n\n    Returns:\n        list: A list of bits representing the image, where 1 is for white pixels\n              and 0 is for black pixels.\n    \"\"\"\n", "test_code": "import os\nimport unittest\n\nfrom PIL import Image\n\n\nclass TestConvertImageToBits(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create test images before each test.\"\"\"\n        # Create a white image (all pixels white)\n        self.white_image_path = 'white_image.bmp'\n        white_image = Image.new('1', (2, 2), color=1)  # 1 is for white\n        white_image.save(self.white_image_path)\n\n        # Create a black image (all pixels black)\n        self.black_image_path = 'black_image.bmp'\n        black_image = Image.new('1', (2, 2), color=0)  # 0 is for black\n        black_image.save(self.black_image_path)\n\n        # Create a mixed image (half white, half black)\n        self.mixed_image_path = 'mixed_image.bmp'\n        mixed_image = Image.new('1', (2, 2))\n        mixed_image.putpixel((0, 0), 1)  # White\n        mixed_image.putpixel((0, 1), 0)  # Black\n        mixed_image.putpixel((1, 0), 0)  # Black\n        mixed_image.putpixel((1, 1), 1)  # White\n        mixed_image.save(self.mixed_image_path)\n\n    def tearDown(self):\n        \"\"\"Remove the test images after each test.\"\"\"\n        os.remove(self.white_image_path)\n        os.remove(self.black_image_path)\n        os.remove(self.mixed_image_path)\n\n    def test_white_image(self):\n        \"\"\"Test converting a white image.\"\"\"\n        expected_output = [1, 1, 1, 1]  # All pixels should be 1 (white)\n        result = convert_image_to_bits(self.white_image_path)\n        self.assertEqual(result, expected_output)\n\n    def test_black_image(self):\n        \"\"\"Test converting a black image.\"\"\"\n        expected_output = [0, 0, 0, 0]  # All pixels should be 0 (black)\n        result = convert_image_to_bits(self.black_image_path)\n        self.assertEqual(result, expected_output)\n\n    def test_mixed_image(self):\n        \"\"\"Test converting a mixed image.\"\"\"\n        expected_output = [1, 0, 0, 1]  # 1 white, 3 black\n        result = convert_image_to_bits(self.mixed_image_path)\n        self.assertEqual(result, expected_output)\n\n    def test_invalid_image_path(self):\n        \"\"\"Test converting an invalid image path.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            convert_image_to_bits('invalid_image_path.bmp')\n\n    def test_large_image(self):\n        \"\"\"Test converting a larger image.\"\"\"\n        # Create a larger image (3x3)\n        large_image_path = 'large_image.bmp'\n        large_image = Image.new('1', (3, 3))\n        large_image.putpixel((0, 0), 1)\n        large_image.putpixel((1, 1), 1)\n        large_image.putpixel((2, 2), 1)\n        large_image.save(large_image_path)\n\n        expected_output = [\n            1, 0, 0,\n            0, 1, 0,\n            0, 0, 1\n        ]\n        result = convert_image_to_bits(large_image_path)\n        self.assertEqual(result, expected_output)\n\n        # Clean up\n        os.remove(large_image_path)\n", "prompt": "please write a python function , the function signature as below def convert_image_to_bits(image_path: str):\n    \"\"\"\n    Converts an image to a binary representation.Convert the image to black and white mode, that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black pixel value of 0\n\n    Args:\n        image_path (str): The file path of the image to convert.\n\n    Returns:\n        list: A list of bits representing the image, where 1 is for white pixels\n              and 0 is for black pixels.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts an image to a binary representation. Convert the image to black and white mode,\n * that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black pixel value of 0.\n *\n * @param image_path The file path of the image to convert.\n * @return A vector of integers representing the image, where 1 is for white pixels and 0 is for black pixels.\n */\nstd::vector<int> convertImageToBits(const std::string& image_path);\n", "test_code": "#include <catch2/catch.hpp>\n#include <vector>\n#include <memory>\n#include \"image_converter.h\" // Assuming this is where your convertImageToBits function is defined\n\n// Mock implementation of convertImageToBits for testing purposes\nstd::vector<int> convertImageToBits(const std::string& image_path) {\n    // This is just a placeholder. Replace it with actual logic if needed.\n    return {1, 1, 1, 1};\n}\n\nTEST_CASE(\"Convert image to bits\", \"[image_conversion]\") {\n    // Create a simple white image\n    auto img = std::make_unique<Image>(2, 2); // Assuming Image is a class that represents an image\n    img->fill(255);\n\n    // Convert the image to a byte array\n    std::vector<unsigned char> img_byte_arr;\n    img->save(img_byte_arr);\n\n    // Call the function under test\n    std::vector<int> result = convertImageToBits(\"dummy_path\"); // Use a dummy path for simplicity\n\n    // Define the expected result\n    std::vector<int> expected_result = {1, 1, 1, 1};\n\n    // Check if the result matches the expected result\n    REQUIRE(result == expected_result);\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * Converts an image to a binary representation. Convert the image to black and white mode,\n * that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black pixel value of 0.\n *\n * @param image_path The file path of the image to convert.\n * @return A vector of integers representing the image, where 1 is for white pixels and 0 is for black pixels.\n */\nstd::vector<int> convertImageToBits(const std::string& image_path);\n", "addition_info": ""}, "java": {"code_signature": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\n/**\n * Converts an image to a binary representation. Convert the image to black and white mode,\n * that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black\n * pixel value of 0.\n *\n * @param imagePath The file path of the image to convert.\n * @return A list of bits representing the image, where 1 is for white pixels and 0 is for black pixels.\n */\npublic List<Integer> convertImageToBits(String imagePath) {\n    // Function implementation will go here.\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testConvertImageToBits() {\n        // Assuming convertImageToBits is implemented in ImageConverter class\n        ImageConverter converter = new ImageConverter();\n\n        // Example image path (replace with actual image path)\n        String imagePath = \"path/to/your/image.jpg\";\n\n        // Call the method to be tested\n        List<Integer> result = converter.convertImageToBits(imagePath);\n\n        // Expected result (replace with actual expected result)\n        List<Integer> expectedResult = Arrays.asList(0, 1, 0, 1, 1, 0, 0, 1);\n\n        // Assert the result\n        assertEquals(expectedResult, result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below import java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\n/**\n * Converts an image to a binary representation. Convert the image to black and white mode,\n * that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black\n * pixel value of 0.\n *\n * @param imagePath The file path of the image to convert.\n * @return A list of bits representing the image, where 1 is for white pixels and 0 is for black pixels.\n */\npublic List<Integer> convertImageToBits(String imagePath) {\n    // Function implementation will go here.\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 460, "code_type": "method", "original_language": "python", "file_path": "MATH-HPC\\1c0fc9efc66d356f7d25bb7851bb311e31c38006\\Session1\\build\\solution\\exercise1.py\n", "question_type": "Algorithm and data structure", "summary": "Multiplies a matrix by a vector and returns the resulting vector.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef matrix_vector_multiplication(matrix: List[List[float]], vector: List[float]) -> List[float]:\n    \"\"\"\n    Multiplies a matrix by a vector and returns the resulting vector.\n\n    Args:\n        matrix (List[List[float]]): A 2D list representing the matrix.\n        vector (List[float]): A 1D list representing the vector.\n\n    Returns:\n        List[float]: The resulting vector after multiplication.\n\n    Raises:\n        ValueError: If the dimensions of the matrix and vector are not compatible for multiplication.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestMatrixVectorMultiplication(unittest.TestCase):\n\n    def test_non_square_matrix(self):\n        \"\"\"Test case for a non-square matrix and a compatible vector.\"\"\"\n        matrix = [[1, 2], [3, 4], [5, 6]]\n        vector = [2, 3]\n        expected_result = [8.0, 18.0, 28.0]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_zero_vector(self):\n        \"\"\"Test case for a matrix and a zero vector.\"\"\"\n        matrix = [[1, 2, 3], [4, 5, 6]]\n        vector = [0, 0, 0]\n        expected_result = [0.0, 0.0]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_single_element(self):\n        \"\"\"Test case for a single element matrix and vector.\"\"\"\n        matrix = [[5]]\n        vector = [3]\n        expected_result = [15.0]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_single_element_matrix_and_vector(self):\n        # Test case with a single element in the matrix and vector\n        matrix = [[3]]\n        vector = [4]\n        expected = [12]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected)\n\n    def test_compatible_sizes(self):\n        # Test case with compatible sizes but different dimensions\n        matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        vector = [1, 1, 1]\n        expected = [6, 15, 24]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef matrix_vector_multiplication(matrix: List[List[float]], vector: List[float]) -> List[float]:\n    \"\"\"\n    Multiplies a matrix by a vector and returns the resulting vector.\n\n    Args:\n        matrix (List[List[float]]): A 2D list representing the matrix.\n        vector (List[float]): A 1D list representing the vector.\n\n    Returns:\n        List[float]: The resulting vector after multiplication.\n\n    Raises:\n        ValueError: If the dimensions of the matrix and vector are not compatible for multiplication.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <vector>\n#include <stdexcept>\n\n/**\n * @brief Multiplies a matrix by a vector and returns the resulting vector.\n *\n * @param matrix A 2D vector representing the matrix.\n * @param vector A 1D vector representing the vector.\n * @return The resulting vector after multiplication.\n * @throw std::invalid_argument If the dimensions of the matrix and vector are not compatible for multiplication.\n */\nstd::vector<double> matrix_vector_multiplication(const std::vector<std::vector<double>>& matrix, const std::vector<double>& vector) {\n}\n", "test_code": "TEST_CASE(\"TestMatrixVectorMultiplication\", \"[matrix_vector_multiplication]\") {\n    SECTION(\"test_non_square_matrix\") {\n        std::vector<std::vector<float>> matrix = {{1, 2}, {3, 4}, {5, 6}};\n        std::vector<float> vector = {2, 3};\n        std::vector<float> expected_result = {8.0f, 18.0f, 28.0f};\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected_result);\n    }\n\n    SECTION(\"test_zero_vector\") {\n        std::vector<std::vector<float>> matrix = {{1, 2, 3}, {4, 5, 6}};\n        std::vector<float> vector = {0, 0, 0};\n        std::vector<float> expected_result = {0.0f, 0.0f};\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected_result);\n    }\n\n    SECTION(\"test_single_element\") {\n        std::vector<std::vector<float>> matrix = {{5}};\n        std::vector<float> vector = {3};\n        std::vector<float> expected_result = {15.0f};\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected_result);\n    }\n\n    SECTION(\"test_single_element_matrix_and_vector\") {\n        std::vector<std::vector<float>> matrix = {{3}};\n        std::vector<float> vector = {4};\n        std::vector<float> expected = {12.0f};\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected);\n    }\n\n    SECTION(\"test_compatible_sizes\") {\n        std::vector<std::vector<float>> matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        std::vector<float> vector = {1, 1, 1};\n        std::vector<float> expected = {6.0f, 15.0f, 24.0f};\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <vector>\n#include <stdexcept>\n\n/**\n * @brief Multiplies a matrix by a vector and returns the resulting vector.\n *\n * @param matrix A 2D vector representing the matrix.\n * @param vector A 1D vector representing the vector.\n * @return The resulting vector after multiplication.\n * @throw std::invalid_argument If the dimensions of the matrix and vector are not compatible for multiplication.\n */\nstd::vector<double> matrix_vector_multiplication(const std::vector<std::vector<double>>& matrix, const std::vector<double>& vector) {\n}\n", "addition_info": ""}, "java": {"code_signature": "import java.util.List;\n\n/**\n * Multiplies a matrix by a vector and returns the resulting vector.\n *\n * @param matrix A 2D array representing the matrix.\n * @param vector A 1D array representing the vector.\n * @return The resulting vector after multiplication.\n * @throws IllegalArgumentException If the dimensions of the matrix and vector are not compatible for multiplication.\n */\npublic static double[] matrixVectorMultiplication(double[][] matrix, double[] vector) {\n", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    public List<Double> matrixVectorMultiplication(List<List<Double>> matrix, List<Double> vector) {\n        if (matrix.get(0).size() != vector.size()) {\n            throw new IllegalArgumentException(\"Matrix and vector dimensions are not compatible for multiplication.\");\n        }\n\n        List<Double> result = new ArrayList<>();\n        for (List<Double> row : matrix) {\n            double sum = 0;\n            for (int i = 0; i < row.size(); i++) {\n                sum += row.get(i) * vector.get(i);\n            }\n            result.add(sum);\n        }\n        return result;\n    }\n\n    @Test\n    public void testValidMatrixVectorMultiplication() {\n        List<List<Double>> matrix = Arrays.asList(\n            Arrays.asList(1.0, 2.0),\n            Arrays.asList(3.0, 4.0)\n        );\n        List<Double> vector = Arrays.asList(5.0, 6.0);\n        List<Double> expectedResult = Arrays.asList(17.0, 39.0);\n        assertEquals(expectedResult, matrixVectorMultiplication(matrix, vector));\n    }\n\n    @Test\n    public void testInvalidMatrixVectorMultiplication() {\n        List<List<Double>> matrix = Arrays.asList(\n            Arrays.asList(1.0, 2.0),\n            Arrays.asList(3.0, 4.0)\n        );\n        List<Double> vector = Arrays.asList(5.0);\n        assertThrows(IllegalArgumentException.class, () -> matrixVectorMultiplication(matrix, vector));\n    }\n}", "prompt": "please write a java function , the function signature as below import java.util.List;\n\n/**\n * Multiplies a matrix by a vector and returns the resulting vector.\n *\n * @param matrix A 2D array representing the matrix.\n * @param vector A 1D array representing the vector.\n * @return The resulting vector after multiplication.\n * @throws IllegalArgumentException If the dimensions of the matrix and vector are not compatible for multiplication.\n */\npublic static double[] matrixVectorMultiplication(double[][] matrix, double[] vector) {\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 461, "code_type": "method", "original_language": "python", "file_path": "leetcode_problems\\6ffa50a7ebae1f0ab6092efa49d3839644859510\\avg_binary_tree\\avg_binary_tree.py\n", "question_type": "Algorithm and data structure", "summary": "Calculate the average value of nodes at each level of a binary tree.", "language_version_list": {"python": {"code_signature": "from typing import List, Optional\nfrom collections import deque\n\n\nclass TreeNode:\n    \"\"\"Definition for a binary tree node.\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef average_of_levels(root: Optional[TreeNode]) -> List[float]:\n    \"\"\"\n    Calculate the average value of nodes at each level of a binary tree.\n\n    Args:\n        root (Optional[TreeNode]): The root of the binary tree.\n\n    Returns:\n        List[float]: A list of averages for each level of the binary tree.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TreeNode:\n    \"\"\"Definition for a binary tree node.\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass TestAverageOfLevels(unittest.TestCase):\n    def test_empty_tree(self):\n        \"\"\"Test case for an empty tree.\"\"\"\n        self.assertEqual(average_of_levels(None), [])\n\n    def test_single_node(self):\n        \"\"\"Test case for a tree with a single node.\"\"\"\n        root = TreeNode(5)\n        self.assertEqual(average_of_levels(root), [5.0])\n\n    def test_three_levels(self):\n        \"\"\"Test case for a tree with three levels.\"\"\"\n        root = TreeNode(1)\n        root.left = TreeNode(2)\n        root.right = TreeNode(3)\n        root.left.left = TreeNode(4)\n        root.left.right = TreeNode(5)\n        root.right.right = TreeNode(6)\n        self.assertEqual(average_of_levels(root), [1.0, 2.5, 5.0])  # (1), (2, 3) -> [1.0, (2+3)/2], (4, 5, 6) -> [5.0]\n", "prompt": "please write a python function , the function signature as below from typing import List, Optional\nfrom collections import deque\n\n\nclass TreeNode:\n    \"\"\"Definition for a binary tree node.\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef average_of_levels(root: Optional[TreeNode]) -> List[float]:\n    \"\"\"\n    Calculate the average value of nodes at each level of a binary tree.\n\n    Args:\n        root (Optional[TreeNode]): The root of the binary tree.\n\n    Returns:\n        List[float]: A list of averages for each level of the binary tree.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 462, "code_type": "method", "original_language": "python", "file_path": "leetcode_problems\\2c1d6ebdef1030b7793d957291fcebb771480477\\spiral_matrix\\optimized_with_ai.py\n", "question_type": "Algorithm and data structure", "summary": "Given a 2D matrix, return all elements of the matrix in spiral order", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef spiral_order(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a 2D matrix, return all elements of the matrix in spiral order.\n\n    Args:\n        matrix (List[List[int]]): A 2D list of integers.\n\n    Returns:\n        List[int]: A list of integers representing the matrix elements in spiral order.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestSpiralOrder(unittest.TestCase):\n    def test_empty_matrix(self):\n        self.assertEqual(spiral_order([]), [])\n\n    def test_single_row_matrix(self):\n        self.assertEqual(spiral_order([[1, 2, 3]]), [1, 2, 3])\n\n    def test_single_column_matrix(self):\n        self.assertEqual(spiral_order([[1], [2], [3]]), [1, 2, 3])\n\n    def test_square_matrix(self):\n        self.assertEqual(spiral_order([\n            [1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]\n        ]), [1, 2, 3, 6, 9, 8, 7, 4, 5])\n\n    def test_rectangle_matrix(self):\n        self.assertEqual(spiral_order([\n            [1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]\n        ]), [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7])", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef spiral_order(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a 2D matrix, return all elements of the matrix in spiral order.\n\n    Args:\n        matrix (List[List[int]]): A 2D list of integers.\n\n    Returns:\n        List[int]: A list of integers representing the matrix elements in spiral order.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <vector>\n#include <iostream>\n\n/**\n * @brief Given a 2D matrix, return all elements of the matrix in spiral order.\n *\n * @param matrix A 2D vector of integers.\n * @return std::vector<int> A vector of integers representing the matrix elements in spiral order.\n */\nstd::vector<int> spiralOrder(const std::vector<std::vector<int>>& matrix);", "test_code": "TEST_CASE(\"Test Spiral Order\", \"[spiralOrder]\") {\n    SECTION(\"Empty Matrix\") {\n        REQUIRE(spiralOrder({}) == std::vector<int>{});\n    }\n\n    SECTION(\"Single Row Matrix\") {\n        REQUIRE(spiralOrder({{1, 2, 3}}) == std::vector<int>({1, 2, 3}));\n    }\n\n    SECTION(\"Single Column Matrix\") {\n        REQUIRE(spiralOrder({{1}, {2}, {3}}) == std::vector<int>({1, 2, 3}));\n    }\n\n    SECTION(\"Square Matrix\") {\n        REQUIRE(spiralOrder({\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        }) == std::vector<int>({1, 2, 3, 6, 9, 8, 7, 4, 5}));\n    }\n\n    SECTION(\"Rectangle Matrix\") {\n        REQUIRE(spiralOrder({\n            {1, 2, 3, 4},\n            {5, 6, 7, 8},\n            {9, 10, 11, 12}\n        }) == std::vector<int>({1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7}));\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <vector>\n#include <iostream>\n\n/**\n * @brief Given a 2D matrix, return all elements of the matrix in spiral order.\n *\n * @param matrix A 2D vector of integers.\n * @return std::vector<int> A vector of integers representing the matrix elements in spiral order.\n */\nstd::vector<int> spiralOrder(const std::vector<std::vector<int>>& matrix);", "addition_info": ""}, "java": {"code_signature": "import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Given a 2D matrix, return all elements of the matrix in spiral order.\n *\n * @param matrix The 2D list of integers.\n * @return A list of integers representing the matrix elements in spiral order.\n */\npublic class SpiralMatrix {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> result = new ArrayList<>();\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return result;\n        }\n\n        int top = 0;\n        int bottom = matrix.length - 1;\n        int left = 0;\n        int right = matrix[0].length - 1;\n\n        while (true) {\n            // Traverse from left to right along the top row\n            for (int i = left; i <= right; i++) {\n                result.add(matrix[top][i]);\n            }\n            top++;\n            if (top > bottom) break;\n\n            // Traverse downwards along the right column\n            for (int i = top; i <= bottom; i++) {\n                result.add(matrix[i][right]);\n            }\n            right--;\n            if (left > right) break;\n\n            // Traverse from right to left along the bottom row\n            for (int i = right; i >= left; i--) {\n                result.add(matrix[bottom][i]);\n            }\n            bottom--;\n            if (top > bottom) break;\n\n            // Traverse upwards along the left column\n            for (int i = bottom; i >= top; i--) {\n                result.add(matrix[i][left]);\n            }\n            left++;\n            if (left > right) break;\n        }\n\n        return result;\n    }\n}\n", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\nimport org.junit.Test;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testSpiralOrder() {\n        MatrixSpiral matrixSpiral = new MatrixSpiral();\n\n        // Test case 1\n        int[][] matrix1 = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n        List<Integer> expected1 = Arrays.asList(1, 2, 3, 6, 9, 8, 7, 4, 5);\n        assertEquals(expected1, matrixSpiral.spiralOrder(matrix1));\n\n        // Test case 2\n        int[][] matrix2 = {\n            {1, 2, 3, 4},\n            {5, 6, 7, 8},\n            {9, 10, 11, 12}\n        };\n        List<Integer> expected2 = Arrays.asList(1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7);\n        assertEquals(expected2, matrixSpiral.spiralOrder(matrix2));\n\n        // Test case 3\n        int[][] matrix3 = {};\n        List<Integer> expected3 = Arrays.asList();\n        assertEquals(expected3, matrixSpiral.spiralOrder(matrix3));\n\n        // Test case 4\n        int[][] matrix4 = {{1}};\n        List<Integer> expected4 = Arrays.asList(1);\n        assertEquals(expected4, matrixSpiral.spiralOrder(matrix4));\n\n        // Test case 5\n        int[][] matrix5 = {\n            {1, 2},\n            {3, 4},\n            {5, 6}\n        };\n        List<Integer> expected5 = Arrays.asList(1, 2, 4, 6, 5, 3);\n        assertEquals(expected5, matrixSpiral.spiralOrder(matrix5));\n    }\n}\n\nclass MatrixSpiral {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> result = new ArrayList<>();\n        if (matrix == null || matrix.length == 0) {\n            return result;\n        }\n\n        int top = 0, bottom = matrix.length - 1;\n        int left = 0, right = matrix[0].length - 1;\n\n        while (top <= bottom && left <= right) {\n            // Traverse from left to right along the top row\n            for (int i = left; i <= right; i++) {\n                result.add(matrix[top][i]);\n            }\n            top++;\n\n            // Traverse downwards along the right column\n            for (int i = top; i <= bottom; i++) {\n                result.add(matrix[i][right]);\n            }\n            right--;\n\n            // Traverse from right to left along the bottom row, if still within bounds\n            if (top <= bottom) {\n                for (int i = right; i >= left; i--) {\n                    result.add(matrix[bottom][i]);\n                }\n                bottom--;\n            }\n\n            // Traverse upwards along the left column, if still within bounds\n            if (left <= right) {\n                for (int i = bottom; i >= top; i--) {\n                    result.add(matrix[i][left]);\n                }\n                left++;\n            }\n        }\n\n        return result;\n    }\n}\n", "prompt": "please write a java function , the function signature as below import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Given a 2D matrix, return all elements of the matrix in spiral order.\n *\n * @param matrix The 2D list of integers.\n * @return A list of integers representing the matrix elements in spiral order.\n */\npublic class SpiralMatrix {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> result = new ArrayList<>();\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return result;\n        }\n\n        int top = 0;\n        int bottom = matrix.length - 1;\n        int left = 0;\n        int right = matrix[0].length - 1;\n\n        while (true) {\n            // Traverse from left to right along the top row\n            for (int i = left; i <= right; i++) {\n                result.add(matrix[top][i]);\n            }\n            top++;\n            if (top > bottom) break;\n\n            // Traverse downwards along the right column\n            for (int i = top; i <= bottom; i++) {\n                result.add(matrix[i][right]);\n            }\n            right--;\n            if (left > right) break;\n\n            // Traverse from right to left along the bottom row\n            for (int i = right; i >= left; i--) {\n                result.add(matrix[bottom][i]);\n            }\n            bottom--;\n            if (top > bottom) break;\n\n            // Traverse upwards along the left column\n            for (int i = bottom; i >= top; i--) {\n                result.add(matrix[i][left]);\n            }\n            left++;\n            if (left > right) break;\n        }\n\n        return result;\n    }\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 463, "code_type": "method", "original_language": "python", "file_path": "PythonCollection\\454a4924cd2db9a101283c1c21b2ae7631220ea2\\clearTypo3Log.py\n", "question_type": "Data processing and transformation", "summary": "Obtain logs of [WARNING], [ERROR], [CRITICAL], and [ALERT] levels from the log file", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef extract_log_levels(log_file_path:str, output_file_path:str):\n    \"\"\"\n    Obtain logs of [WARNING], [ERROR], [CRITICAL], and [ALERT] levels from the log file\n    log content such as:\n        [INFO] Information message\n        [WARNING] Warning message\n        [DEBUG] Debug message\n\n    Args:\n        log_file_path: log file path\n        output_file_path: output log file path\n\n    Returns:\n\n    \"\"\"", "test_code": "import unittest\nimport tempfile\nimport os\n\n\n# Assuming the extract_log_levels function is defined here or imported\n\nclass TestLogExtraction(unittest.TestCase):\n    def create_temp_log_file(self, content):\n        # Create a temporary log file\n        temp_file = tempfile.NamedTemporaryFile(delete=False, mode='w+')\n        temp_file.write(content)\n        temp_file.close()\n        return temp_file.name\n\n    def read_output_file(self, file_path):\n        # Read content from a file\n        with open(file_path, 'r') as file:\n            return file.read()\n\n    def test_warning_level(self):\n        logs = \"\"\"[INFO] Information message\n[WARNING] Warning message\n[DEBUG] Debug message\"\"\"\n        expected_output = \"[WARNING] Warning message\\n\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n\n    def test_error_level(self):\n        logs = \"\"\"[ERROR] Error occurred\n[INFO] Just an info\"\"\"\n        expected_output = \"[ERROR] Error occurred\\n\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n\n    def test_critical_and_alert_levels(self):\n        logs = \"\"\"[ALERT] Security breach\n[CRITICAL] System failure\n[NOTICE] Something to notice\"\"\"\n        expected_output = \"[ALERT] Security breach\\n[CRITICAL] System failure\\n\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n\n    def test_no_relevant_logs(self):\n        logs = \"[INFO] No issues here\\n[DEBUG] All systems go\"\n        expected_output = \"\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n\n    def test_mixed_logs(self):\n        logs = \"\"\"[WARNING] Low disk space\n[INFO] Update completed\n[ERROR] Failed to load module\n[CRITICAL] Memory leak detected\n[DEBUG] This is a debug message\"\"\"\n        expected_output = \"[WARNING] Low disk space\\n[ERROR] Failed to load module\\n[CRITICAL] Memory leak detected\\n\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef extract_log_levels(log_file_path:str, output_file_path:str):\n    \"\"\"\n    Obtain logs of [WARNING], [ERROR], [CRITICAL], and [ALERT] levels from the log file\n    log content such as:\n        [INFO] Information message\n        [WARNING] Warning message\n        [DEBUG] Debug message\n\n    Args:\n        log_file_path: log file path\n        output_file_path: output log file path\n\n    Returns:\n\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 465, "code_type": "method", "original_language": "python", "file_path": "MATH-HPC\\1c0fc9efc66d356f7d25bb7851bb311e31c38006\\Session2\\build\\solution\\exercise3_2.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "Implement matrix and vector multiplication", "language_version_list": {"python": {"code_signature": "import numpy\nimport numpy as np\n\n\ndef matrix_vector_multiplication(matrix: np.array, vector: np.array) -> numpy.ndarray:\n    \"\"\"\n    Multiplies a given matrix by a vector using NumPy's dot product.\n\n    Parameters:\n    matrix (numpy.ndarray): A 2D array (matrix) of shape (m, n) where m is the number of rows\n                            and n is the number of columns.\n    vector (numpy.ndarray): A 1D array (vector) of shape (n,) that represents a vector\n                            compatible for multiplication with the given matrix.\n\n    Returns:\n    numpy.ndarray: A 1D array (resulting vector) of shape (m,) representing the product of\n                   the matrix and the vector.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestMatrixVectorMultiplication(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test with a simple 2x2 matrix and a 2-element vector\n        matrix = np.array([[1, 2], [3, 4]])\n        vector = np.array([5, 6])\n        expected_result = np.array([17, 39])  # [1*5 + 2*6, 3*5 + 4*6]\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_case_2(self):\n        # Test with a 3x3 matrix and a 3-element vector\n        matrix = np.array([[1, 0, 2], [0, 1, 2], [1, 1, 0]])\n        vector = np.array([3, 4, 5])\n        expected_result = np.array([13, 14, 7])  # [1*3 + 0*4 + 2*5, 0*3 + 1*4 + 2*5, 1*3 + 1*4 + 0*5]\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_case_3(self):\n        # Test with a zero matrix and a vector\n        matrix = np.array([[0, 0], [0, 0]])\n        vector = np.array([1, 1])\n        expected_result = np.array([0, 0])  # Zero matrix multiplied by any vector yields zero\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_case_4(self):\n        # Test with a matrix having negative values\n        matrix = np.array([[-1, -2], [-3, -4]])\n        vector = np.array([1, 1])\n        expected_result = np.array([-3, -7])  # [-1*1 + -2*1, -3*1 + -4*1]\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_case_5(self):\n        # Test with non-square matrix (2x3) and a compatible vector (3-element)\n        matrix = np.array([[1, 2, 3], [4, 5, 6]])\n        vector = np.array([1, 0, 1])\n        expected_result = np.array([4, 10])  # [1*1 + 2*0 + 3*1, 4*1 + 5*0 + 6*1]\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)", "prompt": "please write a python function , the function signature as below import numpy\nimport numpy as np\n\n\ndef matrix_vector_multiplication(matrix: np.array, vector: np.array) -> numpy.ndarray:\n    \"\"\"\n    Multiplies a given matrix by a vector using NumPy's dot product.\n\n    Parameters:\n    matrix (numpy.ndarray): A 2D array (matrix) of shape (m, n) where m is the number of rows\n                            and n is the number of columns.\n    vector (numpy.ndarray): A 1D array (vector) of shape (n,) that represents a vector\n                            compatible for multiplication with the given matrix.\n\n    Returns:\n    numpy.ndarray: A 1D array (resulting vector) of shape (m,) representing the product of\n                   the matrix and the vector.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "\n/**\n * @brief Multiplies a given matrix by a vector.\n *\n * @param matrix The input matrix represented as a vector of vectors.\n * @param vector The input vector represented as a vector.\n * @return The resulting vector after multiplying the matrix and the vector.\n */\nstd::vector<double> matrix_vector_multiplication(const std::vector<std::vector<double>>& matrix, const std::vector<double>& vector) {}", "test_code": "TEST_CASE(\"Test Matrix-Vector Multiplication\", \"[matrix-vector-multiplication]\") {\n    SECTION(\"Test with a simple 2x2 matrix and a 2-element vector\") {\n        std::vector<std::vector<double>> matrix = {{1, 2}, {3, 4}};\n        std::vector<double> vector = {5, 6};\n        std::vector<double> expected_result = {17, 39};  // [1*5 + 2*6, 3*5 + 4*6]\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected_result);\n    }\n\n    SECTION(\"Test with a 3x3 matrix and a 3-element vector\") {\n        std::vector<std::vector<double>> matrix = {{1, 0, 2}, {0, 1, 2}, {1, 1, 0}};\n        std::vector<double> vector = {3, 4, 5};\n        std::vector<double> expected_result = {13, 14, 7};  // [1*3 + 0*4 + 2*5, 0*3 + 1*4 + 2*5, 1*3 + 1*4 + 0*5]\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected_result);\n    }\n\n    SECTION(\"Test with a zero matrix and a vector\") {\n        std::vector<std::vector<double>> matrix = {{0, 0}, {0, 0}};\n        std::vector<double> vector = {1, 1};\n        std::vector<double> expected_result = {0, 0};  // Zero matrix multiplied by any vector yields zero\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected_result);\n    }\n\n    SECTION(\"Test with a matrix having negative values\") {\n        std::vector<std::vector<double>> matrix = {{-1, -2}, {-3, -4}};\n        std::vector<double> vector = {1, 1};\n        std::vector<double> expected_result = {-3, -7};  // [-1*1 + -2*1, -3*1 + -4*1]\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected_result);\n    }\n\n    SECTION(\"Test with non-square matrix (2x3) and a compatible vector (3-element)\") {\n        std::vector<std::vector<double>> matrix = {{1, 2, 3}, {4, 5, 6}};\n        std::vector<double> vector = {1, 0, 1};\n        std::vector<double> expected_result = {4, 10};  // [1*1 + 2*0 + 3*1, 4*1 + 5*0 + 6*1]\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected_result);\n    }\n}", "prompt": "please write a cpp function , the function signature as below \n/**\n * @brief Multiplies a given matrix by a vector.\n *\n * @param matrix The input matrix represented as a vector of vectors.\n * @param vector The input vector represented as a vector.\n * @return The resulting vector after multiplying the matrix and the vector.\n */\nstd::vector<double> matrix_vector_multiplication(const std::vector<std::vector<double>>& matrix, const std::vector<double>& vector) {}", "addition_info": ""}, "java": {"code_signature": "import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealVector;\n\npublic class MatrixVectorMultiplication {\n\n    /**\n     * Multiplies a given matrix by a vector using Apache Commons Math's RealMatrix and RealVector classes.\n\n     * @param matrix The 2D array (matrix) of shape (m, n) where m is the number of rows\n                    and n is the number of columns.\n     * @param vector The 1D array (vector) of shape (n,) that represents a vector\n                    compatible for multiplication with the given matrix.\n     * @return A 1D array (resulting vector) of shape (m,) representing the product of\n                the matrix and the vector.\n     */\n    public static RealVector matrixVectorMultiplication(double[][] matrix, double[] vector) {\n        // Create a new Array2DRowRealMatrix object from the provided matrix.\n        Array2DRowRealMatrix matrixObj = new Array2DRowRealMatrix(matrix);\n\n        // Create a new RealVector object from the provided vector.\n        RealVector vectorObj = new ArrayRealVector(vector);\n\n        // Multiply the matrix by the vector using the multiply method.\n        RealVector result = matrixObj.operate(vectorObj);\n\n        // Return the resulting vector from the multiplication.\n        return result;\n    }\n}\n", "test_code": "import static org.junit.Assert.assertArrayEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testMatrixVectorMultiplication() {\n        double[][] matrix = {{1, 2}, {3, 4}};\n        double[] vector = {5, 6};\n\n        // Call the method under test\n        double[] result = matrixVectorMultiplication(matrix, vector);\n\n        // Define expected output\n        double[] expectedOutput = {17, 39};\n\n        // Assert if the actual output matches the expected output\n        assertArrayEquals(expectedOutput, result, 0.0001);\n    }\n\n    private double[] matrixVectorMultiplication(double[][] matrix, double[] vector) {\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        double[] result = new double[rows];\n\n        for(int i=0; i<rows; i++) {\n            for(int j=0; j<cols; j++) {\n                result[i] += matrix[i][j] * vector[j];\n            }\n        }\n\n        return result;\n    }\n}", "prompt": "please write a java function , the function signature as below import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealVector;\n\npublic class MatrixVectorMultiplication {\n\n    /**\n     * Multiplies a given matrix by a vector using Apache Commons Math's RealMatrix and RealVector classes.\n\n     * @param matrix The 2D array (matrix) of shape (m, n) where m is the number of rows\n                    and n is the number of columns.\n     * @param vector The 1D array (vector) of shape (n,) that represents a vector\n                    compatible for multiplication with the given matrix.\n     * @return A 1D array (resulting vector) of shape (m,) representing the product of\n                the matrix and the vector.\n     */\n    public static RealVector matrixVectorMultiplication(double[][] matrix, double[] vector) {\n        // Create a new Array2DRowRealMatrix object from the provided matrix.\n        Array2DRowRealMatrix matrixObj = new Array2DRowRealMatrix(matrix);\n\n        // Create a new RealVector object from the provided vector.\n        RealVector vectorObj = new ArrayRealVector(vector);\n\n        // Multiply the matrix by the vector using the multiply method.\n        RealVector result = matrixObj.operate(vectorObj);\n\n        // Return the resulting vector from the multiplication.\n        return result;\n    }\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 468, "code_type": "method", "original_language": "python", "file_path": "raimad\\fc52183dfaa99c0d2546bf70a6bfe64caf7a5d3b\\src\\raimad\\affine.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "Given a 3x3 matrix, return the corresponding translation vector", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef get_translation(matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given a 3x3 matrix, return the corresponding translation vector.\n\n    Args:\n        matrix (np.ndarray): A 3x3 affine transformation matrix.\n\n    Returns:\n        np.ndarray: A 2-element array containing the translation components (translation_x, translation_y).\n    \"\"\"", "test_code": "import numpy as np\nimport unittest\n\n\n# Assume the get_translation function is defined as provided\n\nclass TestGetTranslationFunction(unittest.TestCase):\n\n    def test_identity_matrix(self):\n        \"\"\" Test for the identity matrix (no translation) \"\"\"\n        matrix = np.array([[1, 0, 0],\n                           [0, 1, 0],\n                           [0, 0, 1]])\n        expected_translation = np.array([0.0, 0.0])\n        np.testing.assert_array_equal(get_translation(matrix), expected_translation)\n\n    def test_translation_matrix(self):\n        \"\"\" Test for a translation matrix (5 in x, 10 in y) \"\"\"\n        matrix = np.array([[1, 0, 5],\n                           [0, 1, 10],\n                           [0, 0, 1]])\n        expected_translation = np.array([5.0, 10.0])\n        np.testing.assert_array_equal(get_translation(matrix), expected_translation)\n\n    def test_negative_translation(self):\n        \"\"\" Test for a translation matrix with negative values \"\"\"\n        matrix = np.array([[1, 0, -3],\n                           [0, 1, -6],\n                           [0, 0, 1]])\n        expected_translation = np.array([-3.0, -6.0])\n        np.testing.assert_array_equal(get_translation(matrix), expected_translation)", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef get_translation(matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given a 3x3 matrix, return the corresponding translation vector.\n\n    Args:\n        matrix (np.ndarray): A 3x3 affine transformation matrix.\n\n    Returns:\n        np.ndarray: A 2-element array containing the translation components (translation_x, translation_y).\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <Eigen/Dense>\n#include <vector>\n\n/**\n * @brief Given a 3x3 matrix, return the corresponding translation vector.\n *\n * @param matrix A 3x3 affine transformation matrix.\n * @return std::vector<double> A 2-element vector containing the translation components (translation_x, translation_y).\n */\nstd::vector<double> get_translation(const Eigen::Matrix3d& matrix);\n", "test_code": "TEST_CASE(\"Test GetTranslationFunction\", \"[get_translation]\") {\n    SECTION(\"Identity Matrix\") {\n        Eigen::Matrix3d matrix;\n        matrix << 1, 0, 0,\n                  0, 1, 0,\n                  0, 0, 1;\n\n        Eigen::Matrix<double, 2, 1> expected_translation = Eigen::Matrix<double, 2, 1>::Zero();\n        REQUIRE(get_translation(matrix) == expected_translation);\n    }\n\n    SECTION(\"Translation Matrix\") {\n        Eigen::Matrix3d matrix;\n        matrix << 1, 0, 5,\n                  0, 1, 10,\n                  0, 0, 1;\n\n        Eigen::Matrix<double, 2, 1> expected_translation;\n        expected_translation << 5.0, 10.0;\n        REQUIRE(get_translation(matrix) == expected_translation);\n    }\n\n    SECTION(\"Negative Translation\") {\n        Eigen::Matrix3d matrix;\n        matrix << 1, 0, -3,\n                  0, 1, -6,\n                  0, 0, 1;\n\n        Eigen::Matrix<double, 2, 1> expected_translation;\n        expected_translation << -3.0, -6.0;\n        REQUIRE(get_translation(matrix) == expected_translation);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <Eigen/Dense>\n#include <vector>\n\n/**\n * @brief Given a 3x3 matrix, return the corresponding translation vector.\n *\n * @param matrix A 3x3 affine transformation matrix.\n * @return std::vector<double> A 2-element vector containing the translation components (translation_x, translation_y).\n */\nstd::vector<double> get_translation(const Eigen::Matrix3d& matrix);\n", "addition_info": ""}, "java": {"code_signature": "import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * Given a 3x3 matrix, return the corresponding translation vector.\n *\n * @param matrix The 3x3 affine transformation matrix.\n * @return A 2-element array containing the translation components (translation_x, translation_y).\n */\npublic double[] getTranslation(RealMatrix matrix) {\n    // Ensure the input matrix is a 3x3 matrix\n    if (matrix.getRowDimension() != 3 || matrix.getColumnDimension() != 3) {\n        throw new IllegalArgumentException(\"Input matrix must be a 3x3 matrix.\");\n    }\n\n    // Extract the translation vector from the last column of the matrix\n    double translationX = matrix.getEntry(0, 2);\n    double translationY = matrix.getEntry(1, 2);\n\n    // Return the translation vector as a 2-element array\n    return new double[]{translationX, translationY};\n}\n", "test_code": "import static org.junit.Assert.assertArrayEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testGetTranslation() {\n        // Define a sample input matrix\n        double[][] matrix = {\n            {1.0, 0.0, 5.0},\n            {0.0, 1.0, 3.0},\n            {0.0, 0.0, 1.0}\n        };\n\n        // Call the getTranslation method from MatrixUtils\n        double[] result = MatrixUtils.getTranslation(matrix);\n\n        // Expected translation vector\n        double[] expected = {5.0, 3.0};\n\n        // Assert that the result matches the expected output\n        assertArrayEquals(expected, result, 0.001);\n    }\n}\n\n// Assuming there's a utility class with the getTranslation method\nclass MatrixUtils {\n    public static double[] getTranslation(double[][] matrix) {\n        if (matrix.length != 3 || matrix[0].length != 3 || matrix[1].length != 3 || matrix[2].length != 3) {\n            throw new IllegalArgumentException(\"Input matrix must be 3x3\");\n        }\n\n        return new double[]{matrix[0][2], matrix[1][2]};\n    }\n}", "prompt": "please write a java function , the function signature as below import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * Given a 3x3 matrix, return the corresponding translation vector.\n *\n * @param matrix The 3x3 affine transformation matrix.\n * @return A 2-element array containing the translation components (translation_x, translation_y).\n */\npublic double[] getTranslation(RealMatrix matrix) {\n    // Ensure the input matrix is a 3x3 matrix\n    if (matrix.getRowDimension() != 3 || matrix.getColumnDimension() != 3) {\n        throw new IllegalArgumentException(\"Input matrix must be a 3x3 matrix.\");\n    }\n\n    // Extract the translation vector from the last column of the matrix\n    double translationX = matrix.getEntry(0, 2);\n    double translationY = matrix.getEntry(1, 2);\n\n    // Return the translation vector as a 2-element array\n    return new double[]{translationX, translationY};\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 469, "code_type": "method", "original_language": "python", "file_path": "raimad\\fc52183dfaa99c0d2546bf70a6bfe64caf7a5d3b\\src\\raimad\\affine.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "    Given a 3x3 affine transformation matrix, return the corresponding scaling factors\n    along the x and y axes", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\nimport numpy as np\n\n\ndef get_scale(matrix: np.ndarray) -> Tuple[np.float64, np.float64]:\n    \"\"\"\n    Given a 3x3 affine transformation matrix, return the corresponding scaling factors\n    along the x and y axes.\n\n    Args:\n        matrix (np.ndarray): A 3x3 affine transformation matrix.\n\n    Returns:\n        Tuple[np.float64, np.float64]: A tuple containing the scale factors (scale_x, scale_y).\n    \"\"\"\n", "test_code": "import numpy as np\nimport unittest\n\n\n# Assume the get_scale function is defined as provided\n\nclass TestGetScaleFunction(unittest.TestCase):\n\n    def test_identity_matrix(self):\n        \"\"\" Test for the identity matrix (no scaling) \"\"\"\n        matrix = np.array([[1, 0, 0],\n                           [0, 1, 0],\n                           [0, 0, 1]])\n        expected_scale = (1.0, 1.0)\n        self.assertEqual(get_scale(matrix), expected_scale)\n\n    def test_scaling_matrix(self):\n        \"\"\" Test for a scaling matrix (2x in x and 3x in y) \"\"\"\n        matrix = np.array([[2, 0, 0],\n                           [0, 3, 0],\n                           [0, 0, 1]])\n        expected_scale = (2.0, 3.0)\n        self.assertEqual(get_scale(matrix), expected_scale)\n\n\n    def test_uniform_scaling(self):\n        # Test case with uniform scaling\n        matrix = np.array([[2, 0, 0],\n                           [0, 2, 0],\n                           [0, 0, 1]])\n        expected = (2.0, 2.0)\n        self.assertEqual(get_scale(matrix), expected)\n\n    def test_non_uniform_scaling(self):\n        # Test case with non-uniform scaling\n        matrix = np.array([[3, 0, 0],\n                           [0, 5, 0],\n                           [0, 0, 1]])\n        expected = (3.0, 5.0)\n        self.assertEqual(get_scale(matrix), expected)\n\n    def test_reflection_matrix(self):\n        # Test case with reflection matrix\n        matrix = np.array([[-1, 0, 0],\n                           [0, 1, 0],\n                           [0, 0, 1]])\n        expected = (1.0, 1.0)\n        self.assertEqual(get_scale(matrix), expected)", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\nimport numpy as np\n\n\ndef get_scale(matrix: np.ndarray) -> Tuple[np.float64, np.float64]:\n    \"\"\"\n    Given a 3x3 affine transformation matrix, return the corresponding scaling factors\n    along the x and y axes.\n\n    Args:\n        matrix (np.ndarray): A 3x3 affine transformation matrix.\n\n    Returns:\n        Tuple[np.float64, np.float64]: A tuple containing the scale factors (scale_x, scale_y).\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <array>\n#include <cmath>\n\n/**\n * @brief Get the scaling factors for a 2D affine transformation.\n *\n * @param matrix The 3x3 affine transformation matrix.\n * @return std::pair<double, double> A pair containing the scale factors (scaleX, scaleY).\n */\nstd::pair<double, double> get_scale(const std::array<std::array<double, 3>, 3>& matrix){}\n", "test_code": "TEST_CASE(\"Test Get Scale Function\", \"[get_scale]\") {\n    SECTION(\"Identity Matrix\") {\n        // Test for the identity matrix (no scaling)\n        Eigen::MatrixXd matrix(3, 3);\n        matrix << 1, 0, 0,\n                  0, 1, 0,\n                  0, 0, 1;\n        auto expected_scale = std::make_pair(1.0, 1.0);\n        REQUIRE(get_scale(matrix) == expected_scale);\n    }\n\n    SECTION(\"Scaling Matrix\") {\n        // Test for a scaling matrix (2x in x and 3x in y)\n        Eigen::MatrixXd matrix(3, 3);\n        matrix << 2, 0, 0,\n                  0, 3, 0,\n                  0, 0, 1;\n        auto expected_scale = std::make_pair(2.0, 3.0);\n        REQUIRE(get_scale(matrix) == expected_scale);\n    }\n\n    SECTION(\"Uniform Scaling\") {\n        // Test case with uniform scaling\n        Eigen::MatrixXd matrix(3, 3);\n        matrix << 2, 0, 0,\n                  0, 2, 0,\n                  0, 0, 1;\n        auto expected_scale = std::make_pair(2.0, 2.0);\n        REQUIRE(get_scale(matrix) == expected_scale);\n    }\n\n    SECTION(\"Non-Uniform Scaling\") {\n        // Test case with non-uniform scaling\n        Eigen::MatrixXd matrix(3, 3);\n        matrix << 3, 0, 0,\n                  0, 5, 0,\n                  0, 0, 1;\n        auto expected_scale = std::make_pair(3.0, 5.0);\n        REQUIRE(get_scale(matrix) == expected_scale);\n    }\n\n    SECTION(\"Reflection Matrix\") {\n        // Test case with reflection matrix\n        Eigen::MatrixXd matrix(3, 3);\n        matrix << -1, 0, 0,\n                  0, 1, 0,\n                  0, 0, 1;\n        auto expected_scale = std::make_pair(1.0, 1.0);\n        REQUIRE(get_scale(matrix) == expected_scale);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <array>\n#include <cmath>\n\n/**\n * @brief Get the scaling factors for a 2D affine transformation.\n *\n * @param matrix The 3x3 affine transformation matrix.\n * @return std::pair<double, double> A pair containing the scale factors (scaleX, scaleY).\n */\nstd::pair<double, double> get_scale(const std::array<std::array<double, 3>, 3>& matrix){}\n", "addition_info": ""}, "java": {"code_signature": "import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\npublic class Main {\n    /**\n     * Given a 3x3 affine transformation matrix, return the corresponding scaling factors\n     * along the x and y axes.\n     *\n     * @param matrix A 3x3 affine transformation matrix.\n     * @return A double array containing the scale factors [scaleX, scaleY].\n     */\n    public static double[] getScale(RealMatrix matrix) {\n        // Your implementation here\n    }\n}\n", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Point2D;\n\npublic class Tester {\n\n    @Test\n    public void testGetScale() {\n        // Define a sample 3x3 affine transformation matrix\n        double[][] matrix = {\n            {2.0, 0.0, 0.0},\n            {0.0, 3.0, 0.0},\n            {0.0, 0.0, 1.0}\n        };\n\n        // Convert the matrix to an AffineTransform object\n        AffineTransform transform = new AffineTransform();\n        transform.setTransform(\n            matrix[0][0], matrix[0][1], matrix[0][2],\n            matrix[1][0], matrix[1][1], matrix[1][2]\n        );\n\n        // Get the scale factors\n        Point2D.Double scale = new Point2D.Double();\n        transform.getScale(scale);\n\n        // Check if the scale factors are correct\n        assertEquals(2.0, scale.x, \"Scale factor along X-axis should be 2.0\");\n        assertEquals(3.0, scale.y, \"Scale factor along Y-axis should be 3.0\");\n    }\n}\n", "prompt": "please write a java function , the function signature as below import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\npublic class Main {\n    /**\n     * Given a 3x3 affine transformation matrix, return the corresponding scaling factors\n     * along the x and y axes.\n     *\n     * @param matrix A 3x3 affine transformation matrix.\n     * @return A double array containing the scale factors [scaleX, scaleY].\n     */\n    public static double[] getScale(RealMatrix matrix) {\n        // Your implementation here\n    }\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 470, "code_type": "method", "original_language": "python", "file_path": "raimad\\fc52183dfaa99c0d2546bf70a6bfe64caf7a5d3b\\src\\raimad\\affine.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "Applies a shear transformation to a 2D matrix along the x-axis.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef apply_shear_x(matrix: np.array, shear_factor: float):\n    \"\"\"\n    Applies a shear transformation to a 2D matrix along the x-axis.\n\n    Args:\n    matrix (np.ndarray): A 2D numpy array representing the original matrix.\n    shear_factor (float): The factor by which the matrix is sheared along the x-axis.\n\n    Returns:\n    np.ndarray: The sheared matrix.\n    \"\"\"\n", "test_code": "import numpy as np\nimport unittest\n\nclass TestShearTransformation(unittest.TestCase):\n    def test_identity_shear(self):\n        \"\"\" Test with zero shear factor which should return the original matrix unchanged. \"\"\"\n        matrix = np.array([[1, 2], [3, 4]])\n        shear_factor = 0\n        expected_output = np.array([[1, 2], [3, 4]])\n        result = apply_shear_x(matrix, shear_factor)\n        np.testing.assert_array_equal(result, expected_output, \"The matrix should remain unchanged with zero shear factor.\")\n\n    def test_positive_shear(self):\n        \"\"\" Test with a positive shear factor. \"\"\"\n        matrix = np.array([[1, 2], [3, 4]])\n        shear_factor = 1\n        expected_output = np.array([[1, 3], [3, 7]])\n        result = apply_shear_x(matrix, shear_factor)\n        np.testing.assert_array_equal(result, expected_output, \"The matrix should be correctly sheared.\")\n\n    def test_negative_shear(self):\n        \"\"\" Test with a negative shear factor. \"\"\"\n        matrix = np.array([[1, 2], [3, 4]])\n        shear_factor = -1\n        expected_output = np.array([[1, 1], [3, 1]])\n        result = apply_shear_x(matrix, shear_factor)\n        np.testing.assert_array_equal(result, expected_output, \"The matrix should be correctly sheared negatively.\")\n\n\n    def test_high_shear_factor(self):\n        \"\"\" Test with a high shear factor to see how the matrix adapts to extreme transformations. \"\"\"\n        matrix = np.array([[1, 1], [1, 1]])\n        shear_factor = 10\n        expected_output = np.array([[1, 11], [1, 11]])\n        result = apply_shear_x(matrix, shear_factor)\n        np.testing.assert_array_equal(result, expected_output, \"The matrix should be correctly sheared with a high shear factor.\")", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef apply_shear_x(matrix: np.array, shear_factor: float):\n    \"\"\"\n    Applies a shear transformation to a 2D matrix along the x-axis.\n\n    Args:\n    matrix (np.ndarray): A 2D numpy array representing the original matrix.\n    shear_factor (float): The factor by which the matrix is sheared along the x-axis.\n\n    Returns:\n    np.ndarray: The sheared matrix.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <Eigen/Dense>\n\n/**\n * @brief Applies a shear transformation to a 2D matrix along the x-axis.\n *\n * @param matrix A 2D Eigen::MatrixXd object representing the original matrix.\n * @param shear_factor The factor by which the matrix is sheared along the x-axis.\n * @return Eigen::MatrixXd The sheared matrix.\n */\nEigen::MatrixXd apply_shear_x(const Eigen::MatrixXd& matrix, double shearFactor) {}\n", "test_code": "TEST_CASE(\"TestShearTransformation\", \"[shear]\") {\n    SECTION(\"test_identity_shear\") {\n        // Test with zero shear factor which should return the original matrix unchanged.\n        Eigen::MatrixXd matrix = Eigen::MatrixXd::Zero(2, 2);\n        matrix << 1, 2,\n                  3, 4;\n        double shear_factor = 0;\n        Eigen::MatrixXd expected_output = Eigen::MatrixXd::Zero(2, 2);\n        expected_output << 1, 2,\n                           3, 4;\n        Eigen::MatrixXd result = apply_shear_x(matrix, shear_factor);\n        REQUIRE(result.isApprox(expected_output));\n    }\n\n    SECTION(\"test_positive_shear\") {\n        // Test with a positive shear factor.\n        Eigen::MatrixXd matrix = Eigen::MatrixXd::Zero(2, 2);\n        matrix << 1, 2,\n                  3, 4;\n        double shear_factor = 1;\n        Eigen::MatrixXd expected_output = Eigen::MatrixXd::Zero(2, 2);\n        expected_output << 1, 3,\n                           3, 7;\n        Eigen::MatrixXd result = apply_shear_x(matrix, shear_factor);\n        REQUIRE(result.isApprox(expected_output));\n    }\n\n    SECTION(\"test_negative_shear\") {\n        // Test with a negative shear factor.\n        Eigen::MatrixXd matrix = Eigen::MatrixXd::Zero(2, 2);\n        matrix << 1, 2,\n                  3, 4;\n        double shear_factor = -1;\n        Eigen::MatrixXd expected_output = Eigen::MatrixXd::Zero(2, 2);\n        expected_output << 1, 1,\n                           3, 1;\n        Eigen::MatrixXd result = apply_shear_x(matrix, shear_factor);\n        REQUIRE(result.isApprox(expected_output));\n    }\n\n    SECTION(\"test_high_shear_factor\") {\n        // Test with a high shear factor to see how the matrix adapts to extreme transformations.\n        Eigen::MatrixXd matrix = Eigen::MatrixXd::Zero(2, 2);\n        matrix << 1, 1,\n                  1, 1;\n        double shear_factor = 10;\n        Eigen::MatrixXd expected_output = Eigen::MatrixXd::Zero(2, 2);\n        expected_output << 1, 11,\n                           1, 11;\n        Eigen::MatrixXd result = apply_shear_x(matrix, shear_factor);\n        REQUIRE(result.isApprox(expected_output));\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <Eigen/Dense>\n\n/**\n * @brief Applies a shear transformation to a 2D matrix along the x-axis.\n *\n * @param matrix A 2D Eigen::MatrixXd object representing the original matrix.\n * @param shear_factor The factor by which the matrix is sheared along the x-axis.\n * @return Eigen::MatrixXd The sheared matrix.\n */\nEigen::MatrixXd apply_shear_x(const Eigen::MatrixXd& matrix, double shearFactor) {}\n", "addition_info": ""}, "java": {"code_signature": "import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * Applies a shear transformation to a 2D matrix along the x-axis.\n *\n * @param matrix       the 2D real matrix representing the original matrix.\n * @param shearFactor  the factor by which the matrix is sheared along the x-axis.\n * @return             the sheared matrix.\n */\npublic RealMatrix applyShearX(RealMatrix matrix, double shearFactor) {\n    // Method implementation will go here.\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testApplyShearX() {\n        // Define the input matrix and expected output matrix\n        double[][] inputMatrix = {{1, 2}, {3, 4}};\n        double shearFactor = 0.5; // Example shear factor\n        double[][] expectedOutputMatrix = {{1 + 0.5 * 2, 2}, {3 + 0.5 * 4, 4}};\n\n        // Call the method under test\n        double[][] resultMatrix = applyShearX(inputMatrix, shearFactor);\n\n        // Assert that the result matches the expected output\n        assertArrayEquals(expectedOutputMatrix, resultMatrix);\n    }\n\n    // Dummy implementation of applyShearX for demonstration purposes\n    private double[][] applyShearX(double[][] matrix, double shearFactor) {\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        double[][] result = new double[rows][cols];\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                result[i][j] = matrix[i][j] + shearFactor * matrix[i][j];\n            }\n        }\n\n        return result;\n    }\n}\n", "prompt": "please write a java function , the function signature as below import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * Applies a shear transformation to a 2D matrix along the x-axis.\n *\n * @param matrix       the 2D real matrix representing the original matrix.\n * @param shearFactor  the factor by which the matrix is sheared along the x-axis.\n * @return             the sheared matrix.\n */\npublic RealMatrix applyShearX(RealMatrix matrix, double shearFactor) {\n    // Method implementation will go here.\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 471, "code_type": "method", "original_language": "python", "file_path": "raimad\\fc52183dfaa99c0d2546bf70a6bfe64caf7a5d3b\\src\\raimad\\affine.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "Given an affine transformation matrix, return the corresponding rotation angle in radians.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\ndef get_rotation(matrix:np.array) -> float:\n    \"\"\"\n    Given an affine transformation matrix, return the corresponding rotation angle in radians.\n\n    Args:\n        matrix (np.array): A 2D affine transformation matrix.\n\n    Returns:\n        float: The rotation angle in radians, extracted from the affine matrix.\n    \"\"\"", "test_code": "import numpy as np\nimport unittest\n\n\nclass TestGetRotationFunction(unittest.TestCase):\n\n    def test_rotation_0_degrees(self):\n        \"\"\" Test for a rotation of 0 degrees (identity matrix) \"\"\"\n        matrix = np.array([[1, 0, 0],\n                           [0, 1, 0],\n                           [0, 0, 1]])\n        expected_rotation = 0.0\n        self.assertAlmostEqual(get_rotation(matrix), expected_rotation, places=6)\n\n    def test_rotation_90_degrees(self):\n        \"\"\" Test for a rotation of 90 degrees \"\"\"\n        matrix = np.array([[0, -1, 0],\n                           [1, 0, 0],\n                           [0, 0, 1]])\n        expected_rotation = np.pi / 2  # 90 degrees in radians\n        self.assertAlmostEqual(get_rotation(matrix), expected_rotation, places=6)\n\n    def test_rotation_180_degrees(self):\n        \"\"\" Test for a rotation of 180 degrees \"\"\"\n        matrix = np.array([[-1, 0, 0],\n                           [0, -1, 0],\n                           [0, 0, 1]])\n        expected_rotation = np.pi  # 180 degrees in radians\n        self.assertAlmostEqual(get_rotation(matrix), expected_rotation, places=6)\n\n    def test_rotation_negative_90_degrees(self):\n        \"\"\" Test for a rotation of -90 degrees \"\"\"\n        matrix = np.array([[0, 1, 0],\n                           [-1, 0, 0],\n                           [0, 0, 1]])\n        expected_rotation = -np.pi / 2  # -90 degrees in radians\n        self.assertAlmostEqual(get_rotation(matrix), expected_rotation, places=6)\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\ndef get_rotation(matrix:np.array) -> float:\n    \"\"\"\n    Given an affine transformation matrix, return the corresponding rotation angle in radians.\n\n    Args:\n        matrix (np.array): A 2D affine transformation matrix.\n\n    Returns:\n        float: The rotation angle in radians, extracted from the affine matrix.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <Eigen/Dense>\n\n/**\n * @brief Extracts the rotation angle from a 2D affine transformation matrix.\n *\n * @param matrix A 2x3 Eigen::Matrix representing a 2D affine transformation matrix.\n * @return double The rotation angle in radians, extracted from the affine matrix.\n */\ndouble get_rotation(const Eigen::Matrix2d& matrix);\n", "test_code": "TEST_CASE(\"TestGetRotationFunction\", \"[rotation]\") {\n    SECTION(\"test_rotation_0_degrees\") {\n        // Test for a rotation of 0 degrees (identity matrix)\n        Eigen::Matrix3d matrix;\n        matrix << 1, 0, 0,\n                  0, 1, 0,\n                  0, 0, 1;\n        double expected_rotation = 0.0;\n        REQUIRE(std::abs(get_rotation(matrix) - expected_rotation) < 1e-6);\n    }\n\n    SECTION(\"test_rotation_90_degrees\") {\n        // Test for a rotation of 90 degrees\n        Eigen::Matrix3d matrix;\n        matrix << 0, -1, 0,\n                  1, 0, 0,\n                  0, 0, 1;\n        double expected_rotation = M_PI / 2;  // 90 degrees in radians\n        REQUIRE(std::abs(get_rotation(matrix) - expected_rotation) < 1e-6);\n    }\n\n    SECTION(\"test_rotation_180_degrees\") {\n        // Test for a rotation of 180 degrees\n        Eigen::Matrix3d matrix;\n        matrix << -1, 0, 0,\n                  0, -1, 0,\n                  0, 0, 1;\n        double expected_rotation = M_PI;  // 180 degrees in radians\n        REQUIRE(std::abs(get_rotation(matrix) - expected_rotation) < 1e-6);\n    }\n\n    SECTION(\"test_rotation_negative_90_degrees\") {\n        // Test for a rotation of -90 degrees\n        Eigen::Matrix3d matrix;\n        matrix << 0, 1, 0,\n                  -1, 0, 0,\n                  0, 0, 1;\n        double expected_rotation = -M_PI / 2;  // -90 degrees in radians\n        REQUIRE(std::abs(get_rotation(matrix) - expected_rotation) < 1e-6);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <Eigen/Dense>\n\n/**\n * @brief Extracts the rotation angle from a 2D affine transformation matrix.\n *\n * @param matrix A 2x3 Eigen::Matrix representing a 2D affine transformation matrix.\n * @return double The rotation angle in radians, extracted from the affine matrix.\n */\ndouble get_rotation(const Eigen::Matrix2d& matrix);\n", "addition_info": ""}, "java": {"code_signature": "import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * Given an affine transformation matrix, return the corresponding rotation angle in radians.\n *\n * @param matrix The 2D affine transformation matrix.\n * @return The rotation angle in radians, extracted from the affine matrix.\n */\npublic static double getRotation(RealMatrix matrix) {\n    // Method implementation goes here\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testGetRotation() {\n        // Assuming we have a way to create a rotation matrix and expected result\n        double[][] matrix = { {Math.cos(Math.PI / 4), -Math.sin(Math.PI / 4), 0},\n                              {Math.sin(Math.PI / 4), Math.cos(Math.PI / 4), 0},\n                              {0, 0, 1} };\n        double expectedResult = Math.PI / 4;\n\n        double actualResult = getRotation(np.array(matrix));\n\n        assertEquals(expectedResult, actualResult, 0.0001);\n    }\n\n    private double getRotation(double[][] matrix) {\n        /*\n         * Implement the logic to extract the rotation angle from the given matrix.\n         * This is just a placeholder implementation.\n         */\n        double cosTheta = matrix[0][0];\n        double sinTheta = matrix[1][0];\n        return Math.atan2(sinTheta, cosTheta);\n    }\n}\n", "prompt": "please write a java function , the function signature as below import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * Given an affine transformation matrix, return the corresponding rotation angle in radians.\n *\n * @param matrix The 2D affine transformation matrix.\n * @return The rotation angle in radians, extracted from the affine matrix.\n */\npublic static double getRotation(RealMatrix matrix) {\n    // Method implementation goes here\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 474, "code_type": "method", "original_language": "python", "file_path": "CSU-CS_DS-Assignments\\7859969e199472c9fdf2462ebfeac7aeb6754dbf\\2-Sophomore-Year\\Python-Programming\\nothing\\py_grammer_selfstudy\\993.py\n", "question_type": "Algorithm and data structure", "summary": "Given a binary tree array, determine whether the given two values are sibling nodes", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef are_siblings(tree:List[int], val1:int, val2:int):\n    \"\"\"\n    Determines if two values are siblings in a binary tree represented as an array.\n\n    Args:\n        tree(List[int]): the binary tree level-order representation\n        val1(int):\n        val2(int):\n\n    Returns:\n\n    \"\"\"\n\n    \"\"\"\n    Determines if two values are siblings in a binary tree represented as an array.\n\n    :param tree: List[int], the binary tree level-order representation\n    :param val1: int, first value to check for sibling relationship\n    :param val2: int, second value to check for sibling relationship\n    :return: bool, True if val1 and val2 are siblings, False otherwise\n    \"\"\"", "test_code": "import unittest\n\nclass TestAreSiblings(unittest.TestCase):\n    def setUp(self):\n        # Setting up a binary tree used for all the test cases\n        self.tree = [1, 2, 3, 4, 5, 6, 7]\n\n    def test_basic_case(self):\n        # Test with nodes 4 and 5, which are siblings\n        result = are_siblings(self.tree, 4, 5)\n        self.assertTrue(result)\n\n    def test_non_sibling_case(self):\n        # Test with nodes 4 and 6, which are not siblings\n        result = are_siblings(self.tree, 4, 6)\n        self.assertFalse(result)\n\n    def test_root_node_case(self):\n        # Test with node 1 (root) and any other node, should return False\n        result = are_siblings(self.tree, 1, 2)\n        self.assertFalse(result)\n\n    def test_non_existent_values(self):\n        # Test with non-existent values\n        result = are_siblings(self.tree, 8, 9)\n        self.assertFalse(result)\n\n    def test_same_node_case(self):\n        # Test with the same node for both values\n        result = are_siblings(self.tree, 4, 4)\n        self.assertFalse(result)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef are_siblings(tree:List[int], val1:int, val2:int):\n    \"\"\"\n    Determines if two values are siblings in a binary tree represented as an array.\n\n    Args:\n        tree(List[int]): the binary tree level-order representation\n        val1(int):\n        val2(int):\n\n    Returns:\n\n    \"\"\"\n\n    \"\"\"\n    Determines if two values are siblings in a binary tree represented as an array.\n\n    :param tree: List[int], the binary tree level-order representation\n    :param val1: int, first value to check for sibling relationship\n    :param val2: int, second value to check for sibling relationship\n    :return: bool, True if val1 and val2 are siblings, False otherwise\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <vector>\n\n/**\n * @brief Determines if two values are siblings in a binary tree represented as an array.\n *\n * @param tree std::vector<int>, the binary tree level-order representation\n * @param val1 int, first value to check for sibling relationship\n * @param val2 int, second value to check for sibling relationship\n * @return bool, true if val1 and val2 are siblings, false otherwise\n */\nbool are_siblings(const std::vector<int>& tree, int val1, int val2);\n", "test_code": "TEST_CASE(\"TestAreSiblings\", \"[are_siblings]\") {\n    const std::vector<int> tree = {1, 2, 3, 4, 5, 6, 7};\n\n    SECTION(\"test_basic_case\") {\n        // Test with nodes 4 and 5, which are siblings\n        bool result = are_siblings(tree, 4, 5);\n        REQUIRE(result);\n    }\n\n    SECTION(\"test_non_sibling_case\") {\n        // Test with nodes 4 and 6, which are not siblings\n        bool result = are_siblings(tree, 4, 6);\n        REQUIRE_FALSE(result);\n    }\n\n    SECTION(\"test_root_node_case\") {\n        // Test with node 1 (root) and any other node, should return False\n        bool result = are_siblings(tree, 1, 2);\n        REQUIRE_FALSE(result);\n    }\n\n    SECTION(\"test_non_existent_values\") {\n        // Test with non-existent values\n        bool result = are_siblings(tree, 8, 9);\n        REQUIRE_FALSE(result);\n    }\n\n    SECTION(\"test_same_node_case\") {\n        // Test with the same node for both values\n        bool result = are_siblings(tree, 4, 4);\n        REQUIRE_FALSE(result);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <vector>\n\n/**\n * @brief Determines if two values are siblings in a binary tree represented as an array.\n *\n * @param tree std::vector<int>, the binary tree level-order representation\n * @param val1 int, first value to check for sibling relationship\n * @param val2 int, second value to check for sibling relationship\n * @return bool, true if val1 and val2 are siblings, false otherwise\n */\nbool are_siblings(const std::vector<int>& tree, int val1, int val2);\n", "addition_info": ""}, "java": {"code_signature": "import java.util.List;\n\npublic class BinaryTree {\n\n    /**\n     * Determines if two values are siblings in a binary tree represented as an array.\n     *\n     * @param tree the binary tree level-order representation\n     * @param val1 the first value to check for sibling relationship\n     * @param val2 the second value to check for sibling relationship\n     * @return true if val1 and val2 are siblings, false otherwise\n     */\n    public static boolean areSiblings(List<Integer> tree, int val1, int val2) {\n        // Method implementation will go here\n        return false; // Placeholder return statement\n    }\n}\n", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testAreSiblings() {\n        // Test data for a binary tree represented as an array\n        int[] tree = {1, 2, 3, 4, 5, 6, 7};\n\n        // Test cases\n        assertTrue(areSiblings(tree, 4, 5)); // 4 and 5 are siblings\n        assertFalse(areSiblings(tree, 2, 3)); // 2 and 3 are not siblings\n        assertFalse(areSiblings(tree, 4, 7)); // 4 and 7 are not siblings\n        assertFalse(areSiblings(tree, 8, 9)); // 8 and 9 do not exist in the tree\n    }\n\n    private boolean areSiblings(int[] tree, int val1, int val2) {\n        int n = tree.length;\n\n        // Find parent of val1\n        int i = 0;\n        while (i < n && tree[i] != val1) {\n            i++;\n        }\n        int parentVal1 = -1;\n        if (i < n) {\n            parentVal1 = tree[(i - 1) / 2];\n        }\n\n        // Find parent of val2\n        i = 0;\n        while (i < n && tree[i] != val2) {\n            i++;\n        }\n        int parentVal2 = -1;\n        if (i < n) {\n            parentVal2 = tree[(i - 1) / 2];\n        }\n\n        // Check if both nodes have the same parent\n        return parentVal1 == parentVal2 && parentVal1 != -1;\n    }\n}\n", "prompt": "please write a java function , the function signature as below import java.util.List;\n\npublic class BinaryTree {\n\n    /**\n     * Determines if two values are siblings in a binary tree represented as an array.\n     *\n     * @param tree the binary tree level-order representation\n     * @param val1 the first value to check for sibling relationship\n     * @param val2 the second value to check for sibling relationship\n     * @return true if val1 and val2 are siblings, false otherwise\n     */\n    public static boolean areSiblings(List<Integer> tree, int val1, int val2) {\n        // Method implementation will go here\n        return false; // Placeholder return statement\n    }\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 475, "code_type": "method", "original_language": "python", "file_path": "midjourney-batch-prompt\\4ced4f82f6fba6dbccafcf2b8f2943b8bce52612\\aiprompt.py\n", "question_type": "Data processing and transformation", "summary": "    Safely formats a template string by replacing placeholders with corresponding values\n    from the provided keyword arguments. If a placeholder does not have a corresponding\n    value in kwargs, it remains unchanged.", "language_version_list": {"python": {"code_signature": "def safe_format(template, **kwargs):\n    \"\"\"\n    Safely formats a template string by replacing placeholders with corresponding values\n    from the provided keyword arguments. If a placeholder does not have a corresponding\n    value in kwargs, it remains unchanged.\n\n    Args:\n        template (str): The string template containing placeholders in the form {key}.\n        **kwargs: Keyword arguments that map keys to their replacement values.\n\n    Returns:\n        str: The formatted string with placeholders replaced by values.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestSafeFormat(unittest.TestCase):\n\n    def test_full_replacement(self):\n        \"\"\"Test with all placeholders having corresponding values.\"\"\"\n        template = \"Hello, {name}! Welcome to {place}.\"\n        result = safe_format(template, name=\"Alice\", place=\"Wonderland\")\n        expected = \"Hello, Alice! Welcome to Wonderland.\"\n        self.assertEqual(result, expected)\n\n    def test_partial_replacement(self):\n        \"\"\"Test with some placeholders missing corresponding values.\"\"\"\n        template = \"Hello, {name}! Welcome to {place}.\"\n        result = safe_format(template, name=\"Alice\")\n        expected = \"Hello, Alice! Welcome to {place}.\"\n        self.assertEqual(result, expected)\n\n    def test_no_replacement(self):\n        \"\"\"Test when no placeholders are provided.\"\"\"\n        template = \"Hello, world!\"\n        result = safe_format(template)\n        expected = \"Hello, world!\"\n        self.assertEqual(result, expected)\n\n    def test_missing_placeholder(self):\n        \"\"\"Test with a placeholder that has no corresponding value.\"\"\"\n        template = \"My name is {name}, and I live in {city}.\"\n        result = safe_format(template, name=\"Alice\")\n        expected = \"My name is Alice, and I live in {city}.\"\n        self.assertEqual(result, expected)\n\n    def test_numeric_values(self):\n        \"\"\"Test with numeric values as replacements.\"\"\"\n        template = \"Your score is {score} out of {total}.\"\n        result = safe_format(template, score=85, total=100)\n        expected = \"Your score is 85 out of 100.\"\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def safe_format(template, **kwargs):\n    \"\"\"\n    Safely formats a template string by replacing placeholders with corresponding values\n    from the provided keyword arguments. If a placeholder does not have a corresponding\n    value in kwargs, it remains unchanged.\n\n    Args:\n        template (str): The string template containing placeholders in the form {key}.\n        **kwargs: Keyword arguments that map keys to their replacement values.\n\n    Returns:\n        str: The formatted string with placeholders replaced by values.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Safely formats a template string by replacing placeholders with corresponding values\n * from the provided keyword arguments. If a placeholder does not have a corresponding\n * value in kwargs, it remains unchanged.\n *\n * @param template_str The string template containing placeholders in the form {key}.\n * @param kwargs A map of keys to their replacement values.\n * @return std::string The formatted string with placeholders replaced by values.\n */\nstd::string safe_format(const std::string& template_str, const std::unordered_map<std::string, std::string>& kwargs);\n", "test_code": "TEST_CASE(\"TestSafeFormat\", \"[safe_format]\") {\n    SECTION(\"test_full_replacement\") {\n        // Test with all placeholders having corresponding values.\n        std::string template_str = \"Hello, {name}! Welcome to {place}.\";\n        std::unordered_map<std::string, std::string> kwargs = {\n            {\"name\", \"Alice\"},\n            {\"place\", \"Wonderland\"}\n        };\n        std::string result = safe_format(template_str, kwargs);\n        std::string expected = \"Hello, Alice! Welcome to Wonderland.\";\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_partial_replacement\") {\n        // Test with some placeholders missing corresponding values.\n        std::string template_str = \"Hello, {name}! Welcome to {place}.\";\n        std::unordered_map<std::string, std::string> kwargs = {\n            {\"name\", \"Alice\"}\n        };\n        std::string result = safe_format(template_str, kwargs);\n        std::string expected = \"Hello, Alice! Welcome to {place}.\";\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_no_replacement\") {\n        // Test when no placeholders are provided.\n        std::string template_str = \"Hello, world!\";\n        std::unordered_map<std::string, std::string> kwargs;\n        std::string result = safe_format(template_str, kwargs);\n        std::string expected = \"Hello, world!\";\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_missing_placeholder\") {\n        // Test with a placeholder that has no corresponding value.\n        std::string template_str = \"My name is {name}, and I live in {city}.\";\n        std::unordered_map<std::string, std::string> kwargs = {\n            {\"name\", \"Alice\"}\n        };\n        std::string result = safe_format(template_str, kwargs);\n        std::string expected = \"My name is Alice, and I live in {city}.\";\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_numeric_values\") {\n        // Test with numeric values as replacements.\n        std::string template_str = \"Your score is {score} out of {total}.\";\n        std::unordered_map<std::string, std::string> kwargs = {\n            {\"score\", \"85\"},\n            {\"total\", \"100\"}\n        };\n        std::string result = safe_format(template_str, kwargs);\n        std::string expected = \"Your score is 85 out of 100.\";\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Safely formats a template string by replacing placeholders with corresponding values\n * from the provided keyword arguments. If a placeholder does not have a corresponding\n * value in kwargs, it remains unchanged.\n *\n * @param template_str The string template containing placeholders in the form {key}.\n * @param kwargs A map of keys to their replacement values.\n * @return std::string The formatted string with placeholders replaced by values.\n */\nstd::string safe_format(const std::string& template_str, const std::unordered_map<std::string, std::string>& kwargs);\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Safely formats a template string by replacing placeholders with corresponding values\n * from the provided keyword arguments. If a placeholder does not have a corresponding\n * value in kwargs, it remains unchanged.\n *\n * @param template The string template containing placeholders in the form {key}.\n * @param kwargs   Keyword arguments that map keys to their replacement values.\n * @return The formatted string with placeholders replaced by values.\n */\npublic static String safeFormat(String template, Map<String, Object> kwargs) {\n", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    /**\n     * Safely formats a template string by replacing placeholders with corresponding values\n     * from the provided keyword arguments. If a placeholder does not have a corresponding\n     * value in kwargs, it remains unchanged.\n     *\n     * @param template The string template containing placeholders in the form {key}.\n     * @param args Keyword arguments that map keys to their replacement values.\n     * @return The formatted string with placeholders replaced by values.\n     */\n    public String safeFormat(String template, Object... args) {\n        for (Object arg : args) {\n            if (arg instanceof String && ((String) arg).startsWith(\"{\") && ((String) arg).endsWith(\"}\")) {\n                String key = ((String) arg).substring(1, ((String) arg).length() - 1);\n                int index = template.indexOf(arg);\n                while (index != -1) {\n                    if (index + arg.length() < template.length() && Character.isLetterOrDigit(template.charAt(index + arg.length()))) {\n                        // Skip if the next character is a letter or digit to avoid partial matches\n                        index = template.indexOf(arg, index + arg.length());\n                    } else {\n                        template = template.substring(0, index) + args[index / 2] + template.substring(index + arg.length());\n                        index += args[index / 2].toString().length();\n                    }\n                }\n            }\n        }\n        return template;\n    }\n\n    @Test\n    public void testSafeFormat() {\n        assertEquals(\"Hello, John!\", safeFormat(\"Hello, {name}!\", \"John\"));\n        assertEquals(\"The answer is {answer}.\", safeFormat(\"The answer is {answer}.\", \"42\"));\n        assertEquals(\"No replacements here.\", safeFormat(\"No replacements here.\"));\n        assertEquals(\"Keep {unchanged} unchanged.\", safeFormat(\"Keep {unchanged} unchanged.\"));\n        assertEquals(\"Replace {first}, keep {second}.\", safeFormat(\"Replace {first}, keep {second}.\", \"first\"));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Safely formats a template string by replacing placeholders with corresponding values\n * from the provided keyword arguments. If a placeholder does not have a corresponding\n * value in kwargs, it remains unchanged.\n *\n * @param template The string template containing placeholders in the form {key}.\n * @param kwargs   Keyword arguments that map keys to their replacement values.\n * @return The formatted string with placeholders replaced by values.\n */\npublic static String safeFormat(String template, Map<String, Object> kwargs) {\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 476, "code_type": "method", "original_language": "python", "file_path": "tensorneat\\5fdf7b29bca1ff3a13733732fa234459de53a3d8\\src\\tensorneat\\common\\graph.py\n", "question_type": "Algorithm and data structure", "summary": "achieve topological sorting, based on depth priority search", "language_version_list": {"python": {"code_signature": "from typing import List, Tuple\n\n\ndef topological_sort_dfs(vertices: List[int], edges: List[Tuple]) -> List:\n    \"\"\"\n    achieve topological sorting, based on depth priority search\n\n    Args:\n        vertices (List[int]): A list of vertices in the graph. Each vertex should be a unique integer.\n        edges (List[Tuple[int, int]]): A list of tuples where each tuple represents a directed edge\n                                       in the graph and is formed as (start_vertex, end_vertex).\n\n    Returns:\n        List[int]: A list of vertices in topological order. If the graph contains a cycle,\n                   and thus cannot have a valid topological ordering, an empty list is returned.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestTopologicalSortDFS(unittest.TestCase):\n    def test_simple_chain(self):\n        vertices = [1, 2, 3]\n        edges = [(1, 2), (2, 3)]\n        self.assertEqual(topological_sort_dfs(vertices, edges), [1, 2, 3])\n\n\n    def test_disconnected_graph(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2)]\n        # There are multiple correct answers possible\n        result = topological_sort_dfs(vertices, edges)\n        self.assertTrue(result.index(1) < result.index(2))\n        self.assertTrue(3 in result and 4 in result)\n\n    def test_complex_graph(self):\n        vertices = [1, 2, 3, 4, 5, 6]\n        edges = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (6, 1)]\n        result = topological_sort_dfs(vertices, edges)\n        self.assertTrue(result.index(1) < result.index(2))\n        self.assertTrue(result.index(1) < result.index(3))\n        self.assertTrue(result.index(2) < result.index(4))\n        self.assertTrue(result.index(3) < result.index(4))\n        self.assertTrue(result.index(4) < result.index(5))\n        self.assertTrue(result.index(6) < result.index(1))\n\n    def test_single_vertex(self):\n        vertices = [1]\n        edges = []\n        self.assertEqual(topological_sort_dfs(vertices, edges), [1])", "prompt": "please write a python function , the function signature as below from typing import List, Tuple\n\n\ndef topological_sort_dfs(vertices: List[int], edges: List[Tuple]) -> List:\n    \"\"\"\n    achieve topological sorting, based on depth priority search\n\n    Args:\n        vertices (List[int]): A list of vertices in the graph. Each vertex should be a unique integer.\n        edges (List[Tuple[int, int]]): A list of tuples where each tuple represents a directed edge\n                                       in the graph and is formed as (start_vertex, end_vertex).\n\n    Returns:\n        List[int]: A list of vertices in topological order. If the graph contains a cycle,\n                   and thus cannot have a valid topological ordering, an empty list is returned.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <vector>\n#include <list>\n\n/**\n * @brief Achieve topological sorting, based on depth priority search\n *\n * @param vertices A vector of integers representing the vertices in the graph.\n *                 Each vertex should be a unique integer.\n * @param edges A vector of pairs of integers where each pair represents a directed\n *              edge in the graph and is formed as (start_vertex, end_vertex).\n *\n * @return A vector of integers representing the vertices in topological order.\n *         If the graph contains a cycle, and thus cannot have a valid topological\n *         ordering, an empty vector is returned.\n */\nstd::vector<int> topological_sort_dfs(const std::vector<int>& vertices, const std::vector<std::pair<int, int>>& edges);", "test_code": "TEST_CASE(\"Test topological_sort_dfs\", \"[topological_sort_dfs]\") {\n    SECTION(\"test_simple_chain\") {\n        std::vector<int> vertices = {1, 2, 3};\n        std::vector<std::pair<int, int>> edges = {{1, 2}, {2, 3}};\n        REQUIRE(topological_sort_dfs(vertices, edges) == std::vector<int>({1, 2, 3}));\n    }\n\n    SECTION(\"test_disconnected_graph\") {\n        std::vector<int> vertices = {1, 2, 3, 4};\n        std::vector<std::pair<int, int>> edges = {{1, 2}};\n        auto result = topological_sort_dfs(vertices, edges);\n        REQUIRE(std::find(result.begin(), result.end(), 1) < std::find(result.begin(), result.end(), 2));\n        REQUIRE(std::find(result.begin(), result.end(), 3) != result.end());\n        REQUIRE(std::find(result.begin(), result.end(), 4) != result.end());\n    }\n\n    SECTION(\"test_complex_graph\") {\n        std::vector<int> vertices = {1, 2, 3, 4, 5, 6};\n        std::vector<std::pair<int, int>> edges = {{1, 2}, {1, 3}, {2, 4}, {3, 4}, {4, 5}, {6, 1}};\n        auto result = topological_sort_dfs(vertices, edges);\n        REQUIRE(std::find(result.begin(), result.end(), 1) < std::find(result.begin(), result.end(), 2));\n        REQUIRE(std::find(result.begin(), result.end(), 1) < std::find(result.begin(), result.end(), 3));\n        REQUIRE(std::find(result.begin(), result.end(), 2) < std::find(result.begin(), result.end(), 4));\n        REQUIRE(std::find(result.begin(), result.end(), 3) < std::find(result.begin(), result.end(), 4));\n        REQUIRE(std::find(result.begin(), result.end(), 4) < std::find(result.begin(), result.end(), 5));\n        REQUIRE(std::find(result.begin(), result.end(), 6) < std::find(result.begin(), result.end(), 1));\n    }\n\n    SECTION(\"test_single_vertex\") {\n        std::vector<int> vertices = {1};\n        std::vector<std::pair<int, int>> edges = {};\n        REQUIRE(topological_sort_dfs(vertices, edges) == std::vector<int>({1}));\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <vector>\n#include <list>\n\n/**\n * @brief Achieve topological sorting, based on depth priority search\n *\n * @param vertices A vector of integers representing the vertices in the graph.\n *                 Each vertex should be a unique integer.\n * @param edges A vector of pairs of integers where each pair represents a directed\n *              edge in the graph and is formed as (start_vertex, end_vertex).\n *\n * @return A vector of integers representing the vertices in topological order.\n *         If the graph contains a cycle, and thus cannot have a valid topological\n *         ordering, an empty vector is returned.\n */\nstd::vector<int> topological_sort_dfs(const std::vector<int>& vertices, const std::vector<std::pair<int, int>>& edges);", "addition_info": ""}, "java": {"code_signature": "import java.util.*;\n\npublic class TopologicalSort {\n\n    /**\n     * Achieve topological sorting, based on depth priority search\n     *\n     * @param vertices A list of vertices in the graph. Each vertex should be a unique integer.\n     * @param edges    A list of tuples where each tuple represents a directed edge\n     *                 in the graph and is formed as (startVertex, endVertex).\n     * @return A list of vertices in topological order. If the graph contains a cycle,\n     *         and thus cannot have a valid topological ordering, an empty list is returned.\n     */\n    public static List<Integer> topologicalSortDFS(List<Integer> vertices, List<List<Integer>> edges) {\n        // Method implementation goes here...\n    }\n}\n", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class Tester {\n\n    private TopologicalSort topologicalSort;\n\n    @Before\n    public void setUp() {\n        topologicalSort = new TopologicalSort();\n    }\n\n    @Test\n    public void testTopologicalSortDfs() {\n        List<Integer> vertices = new ArrayList<>();\n        vertices.add(1);\n        vertices.add(2);\n        vertices.add(3);\n        vertices.add(4);\n\n        List<List<Integer>> edges = new ArrayList<>();\n        edges.add(List.of(1, 2));\n        edges.add(List.of(1, 3));\n        edges.add(List.of(2, 4));\n        edges.add(List.of(3, 4));\n\n        List<Integer> result = topologicalSort.topologicalSortDfs(vertices, edges);\n\n        assertTrue(result.size() == vertices.size());\n        assertEquals(List.of(1, 2, 3, 4), result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below import java.util.*;\n\npublic class TopologicalSort {\n\n    /**\n     * Achieve topological sorting, based on depth priority search\n     *\n     * @param vertices A list of vertices in the graph. Each vertex should be a unique integer.\n     * @param edges    A list of tuples where each tuple represents a directed edge\n     *                 in the graph and is formed as (startVertex, endVertex).\n     * @return A list of vertices in topological order. If the graph contains a cycle,\n     *         and thus cannot have a valid topological ordering, an empty list is returned.\n     */\n    public static List<Integer> topologicalSortDFS(List<Integer> vertices, List<List<Integer>> edges) {\n        // Method implementation goes here...\n    }\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 477, "code_type": "method", "original_language": "python", "file_path": "markpickle\\f29202998c0d5ae3ebc2bd22de57bc1c2c6bacbb\\markpickle\\simplify_types.py\n", "question_type": "Data processing and transformation", "summary": "Check if the given object can be treated as a dictionary.", "language_version_list": {"python": {"code_signature": "from typing import Any\n\ndef can_class_to_dict(obj: Any) -> bool:\n    \"\"\"\n    Check if the given object can be treated as a dictionary.\n\n    Args:\n        obj (Any): any type\n\n    Returns:\n        bool: can obj to dict\n    \"\"\"", "test_code": "import unittest\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n\nclass Car:\n    def __init__(self, make: str, model: str):\n        self.make = make\n        self.model = model\n\nclass Dog:\n    def __init__(self, name: str, breed: str):\n        self.name = name\n        self.breed = breed\n        self._age = 5  # Private attribute\n\nclass EmptyClass:\n    pass\n\nclass Student:\n    school_name = \"Example School\"\n\n    def __init__(self, name: str):\n        self.name = name\n        self.grade = \"A\"\n\nclass TestCanClassToDict(unittest.TestCase):\n\n    def test_dataclass(self):\n        person = Person(name=\"Alice\", age=30)\n        self.assertTrue(can_class_to_dict(person))\n\n    def test_regular_class(self):\n        car = Car(make=\"Toyota\", model=\"Corolla\")\n        self.assertTrue(can_class_to_dict(car))\n\n    def test_regular_class_with_private_attribute(self):\n        dog = Dog(name=\"Buddy\", breed=\"Golden Retriever\")\n        self.assertTrue(can_class_to_dict(dog))\n\n    def test_empty_class(self):\n        empty = EmptyClass()\n        self.assertTrue(can_class_to_dict(empty))\n\n    def test_class_with_class_variable(self):\n        student = Student(name=\"John\")\n        self.assertTrue(can_class_to_dict(student))\n\n    def test_non_class_object(self):\n        number = 42\n        self.assertFalse(can_class_to_dict(number))\n", "prompt": "please write a python function , the function signature as below from typing import Any\n\ndef can_class_to_dict(obj: Any) -> bool:\n    \"\"\"\n    Check if the given object can be treated as a dictionary.\n\n    Args:\n        obj (Any): any type\n\n    Returns:\n        bool: can obj to dict\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 478, "code_type": "method", "original_language": "python", "file_path": "markpickle\\f29202998c0d5ae3ebc2bd22de57bc1c2c6bacbb\\markpickle\\simplify_types.py\n", "question_type": "Data processing and transformation", "summary": "Converts a dataclass or class instance to a dictionary.", "language_version_list": {"python": {"code_signature": "from dataclasses import is_dataclass\nfrom typing import Any, Dict\n\n\ndef class_to_dict(obj: Any) -> Dict[str, Any]:\n    \"\"\"\n    Converts a dataclass or class instance to a dictionary.\n\n    Args:\n        obj: An instance of a dataclass or a class.\n\n    Returns:\n        A dictionary representation of the class or dataclass.\n    \"\"\"\n", "test_code": "import unittest\nfrom dataclasses import dataclass\n\n\n# The class_to_dict function should already be defined above.\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n\n\nclass Car:\n    def __init__(self, make: str, model: str):\n        self.make = make\n        self.model = model\n        self.year = 2020\n\n\nclass Dog:\n    def __init__(self, name: str, breed: str):\n        self.name = name\n        self.breed = breed\n        self._age = 5  # Private attribute\n\n\nclass EmptyClass:\n    pass\n\n\nclass Student:\n    school_name = \"Example School\"\n\n    def __init__(self, name: str):\n        self.name = name\n        self.grade = \"A\"\n\n\nclass TestClassToDict(unittest.TestCase):\n\n    def test_dataclass(self):\n        person = Person(name=\"Alice\", age=30)\n        self.assertEqual(class_to_dict(person), {'name': 'Alice', 'age': 30})\n\n    def test_regular_class(self):\n        car = Car(make=\"Toyota\", model=\"Corolla\")\n        self.assertEqual(class_to_dict(car), {'make': 'Toyota', 'model': 'Corolla', 'year': 2020})\n\n    def test_empty_class(self):\n        empty = EmptyClass()\n        self.assertEqual(class_to_dict(empty), {})\n\n    def test_class_with_class_variable(self):\n        student = Student(name=\"John\")\n        self.assertEqual(class_to_dict(student), {'name': 'John', 'grade': 'A'})\n", "prompt": "please write a python function , the function signature as below from dataclasses import is_dataclass\nfrom typing import Any, Dict\n\n\ndef class_to_dict(obj: Any) -> Dict[str, Any]:\n    \"\"\"\n    Converts a dataclass or class instance to a dictionary.\n\n    Args:\n        obj: An instance of a dataclass or a class.\n\n    Returns:\n        A dictionary representation of the class or dataclass.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 482, "code_type": "method", "original_language": "python", "file_path": "TestGen-Thesis\\91b00426653cbcadd6d779fd3f0a07e695edad63\\scripts\\csvToGraph.py\n", "question_type": "Data processing and transformation", "summary": "Extract the contents of the outermost bracket\n", "language_version_list": {"python": {"code_signature": "def extract_outermost_brackets(s: str) -> str:\n    \"\"\"\n    Extracts the contents of the outermost brackets from the input string.\n    For example:\n        input: Text [with [nested] brackets] and more text\n        output: with [nested] brackets\n    Args:\n        s (str): The input string containing brackets.\n\n    Returns:\n        str: The contents within the outermost brackets, or an empty string if no brackets are found.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestExtractOutermostBrackets(unittest.TestCase):\n    \n    def test_single_parentheses(self):\n        self.assertEqual(extract_outermost_brackets(\"Text (example) more text\"), \"example\")\n\n    def test_nested_brackets(self):\n        self.assertEqual(extract_outermost_brackets(\"Text {with some {nested} brackets}\"), \"with some {nested} brackets\")\n\n    def test_square_brackets(self):\n        self.assertEqual(extract_outermost_brackets(\"Text [with [nested] brackets] and more text\"), \"with [nested] brackets\")\n\n    def test_mixed_bracket_types(self):\n        self.assertEqual(extract_outermost_brackets(\"Mixed (types {of brackets [in use]})\"), \"types {of brackets [in use]}\")\n\n    def test_no_brackets(self):\n        self.assertEqual(extract_outermost_brackets(\"No brackets here\"), \"\")", "prompt": "please write a python function , the function signature as below def extract_outermost_brackets(s: str) -> str:\n    \"\"\"\n    Extracts the contents of the outermost brackets from the input string.\n    For example:\n        input: Text [with [nested] brackets] and more text\n        output: with [nested] brackets\n    Args:\n        s (str): The input string containing brackets.\n\n    Returns:\n        str: The contents within the outermost brackets, or an empty string if no brackets are found.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extracts the contents of the outermost brackets from the input string.\n *\n * This function scans the input string for the outermost brackets and extracts \n * the contents within them. For example, given the input string:\n * \"Text [with [nested] brackets] and more text\", the function will return:\n * \"with [nested] brackets\".\n *\n * @param s The input string containing brackets.\n * @type s std::string\n *\n * @return The contents within the outermost brackets, or an empty string if no \n * brackets are found.\n * @rtype std::string\n */\nstd::string extract_outermost_brackets(const std::string& s) {}", "test_code": "TEST_CASE(\"Test extract_outermost_brackets\") {\n    SECTION(\"test_single_parentheses\") {\n        CHECK(extract_outermost_brackets(\"Text (example) more text\") == \"example\");\n    }\n\n    SECTION(\"test_nested_brackets\") {\n        CHECK(extract_outermost_brackets(\"Text {with some {nested} brackets}\") == \"with some {nested} brackets\");\n    }\n\n    SECTION(\"test_square_brackets\") {\n        CHECK(extract_outermost_brackets(\"Text [with [nested] brackets] and more text\") == \"with [nested] brackets\");\n    }\n\n    SECTION(\"test_mixed_bracket_types\") {\n        CHECK(extract_outermost_brackets(\"Mixed (types {of brackets [in use]})\") == \"types {of brackets [in use]}\");\n    }\n\n    SECTION(\"test_no_brackets\") {\n        CHECK(extract_outermost_brackets(\"No brackets here\") == \"\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts the contents of the outermost brackets from the input string.\n *\n * This function scans the input string for the outermost brackets and extracts \n * the contents within them. For example, given the input string:\n * \"Text [with [nested] brackets] and more text\", the function will return:\n * \"with [nested] brackets\".\n *\n * @param s The input string containing brackets.\n * @type s std::string\n *\n * @return The contents within the outermost brackets, or an empty string if no \n * brackets are found.\n * @rtype std::string\n */\nstd::string extract_outermost_brackets(const std::string& s) {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 483, "code_type": "method", "original_language": "python", "file_path": "Pictionary\\a23c12e1b60494ac96ac2554371d583d0d76e8f1\\app\\routes.py", "question_type": "Data processing and transformation", "summary": "Verify that the mailbox string is a qualified mailbox\n", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Verifies if the provided string is a valid email address.\n\n    Args:\n        email (str):The email address to validate.\n\n    Returns:\n        bool: True if the email address is valid, False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestEmailValidation(unittest.TestCase):\n\n    def test_valid_email(self):\n        self.assertTrue(is_valid_email(\"test@example.com\"))\n\n    def test_valid_email_with_subdomain(self):\n        self.assertTrue(is_valid_email(\"user@subdomain.example.com\"))\n\n    def test_valid_email_with_plus_tag(self):\n        self.assertTrue(is_valid_email(\"user.name+tag+sorting@example.com\"))\n\n    def test_invalid_email_missing_username(self):\n        self.assertFalse(is_valid_email(\"@missingusername.com\"))\n\n    def test_invalid_email_missing_at_symbol(self):\n        self.assertFalse(is_valid_email(\"missingatsign.com\"))\n\n\n    def test_invalid_email_tld_too_short(self):\n        self.assertFalse(is_valid_email(\"user@domain.c\"))\n\n    def test_invalid_email_with_special_characters(self):\n        self.assertFalse(is_valid_email(\"user@domain.com!\"))\n\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Verifies if the provided string is a valid email address.\n\n    Args:\n        email (str):The email address to validate.\n\n    Returns:\n        bool: True if the email address is valid, False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Verifies if the provided string is a valid email address.\n *\n * @param email The email address to validate.\n * @type email std::string\n *\n * @return True if the email address is valid, False otherwise.\n * @rtype bool\n */\nbool isValidEmail(const std::string &email);", "test_code": "TEST_CASE(\"Test Email Validation\", \"[email]\") {\n    SECTION(\"Valid email\") {\n        REQUIRE(is_valid_email(\"test@example.com\"));\n    }\n\n    SECTION(\"Valid email with subdomain\") {\n        REQUIRE(is_valid_email(\"user@subdomain.example.com\"));\n    }\n\n    SECTION(\"Valid email with plus tag\") {\n        REQUIRE(is_valid_email(\"user.name+tag+sorting@example.com\"));\n    }\n\n    SECTION(\"Invalid email missing username\") {\n        REQUIRE_FALSE(is_valid_email(\"@missingusername.com\"));\n    }\n\n    SECTION(\"Invalid email missing at symbol\") {\n        REQUIRE_FALSE(is_valid_email(\"missingatsign.com\"));\n    }\n\n    SECTION(\"Invalid email TLD too short\") {\n        REQUIRE_FALSE(is_valid_email(\"user@domain.c\"));\n    }\n\n    SECTION(\"Invalid email with special characters\") {\n        REQUIRE_FALSE(is_valid_email(\"user@domain.com!\"));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Verifies if the provided string is a valid email address.\n *\n * @param email The email address to validate.\n * @type email std::string\n *\n * @return True if the email address is valid, False otherwise.\n * @rtype bool\n */\nbool isValidEmail(const std::string &email);", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 485, "code_type": "method", "original_language": "python", "file_path": "fastgql\\47ddbf9f5bd444d51ebc210f9158dbf2bc165a7b\\fastgql\\query_builders\\sql\\query_builder.py\n", "question_type": "Data processing and transformation", "summary": "This function modifies a SQL query string containing named parameters\n    (like $name, $age) into a format compatible with libraries that require\n    positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n    a tuple containing the modified SQL string and a list of parameter values\n    ordered according to their new positions in the query.", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef prepare_query(sql: str, params: dict) -> tuple:\n    \"\"\"\n    This function modifies a SQL query string containing named parameters\n    (like $name, $age) into a format compatible with libraries that require\n    positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n    a tuple containing the modified SQL string and a list of parameter values\n    ordered according to their new positions in the query.\n    For example:\n        input:\n            sql: SELECT * FROM users WHERE id = $user_id AND status = $status\n            params: {'user_id': 42,'status': 'active'}\n        output:\n            SELECT * FROM users WHERE id = $1 AND status = $2,[42, 'active']\n\n    Args:\n        sql (str): The original SQL query string with named parameters.\n        params (dict): A dictionary mapping parameter names to their values.\n\n    Returns:\n        tuple: A tuple where the first element is the modified SQL query string with positional parameters, and the second element is a list of parameter values sorted according to the order of the positional parameters.\n    \"\"\"", "test_code": "import unittest\n\n\n# Assuming the prepare_query function is defined above or imported\n\nclass TestPrepareQuery(unittest.TestCase):\n\n    def test_valid_named_parameters(self):\n        sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $status\"\n        parameters = {\n            'user_id': 42,\n            'status': 'active'\n        }\n        expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $2\"\n        expected_values = [42, 'active']\n\n        new_sql, value_list = prepare_query(sql_query, parameters)\n        self.assertEqual(new_sql, expected_sql)\n        self.assertEqual(value_list, expected_values)\n\n    def test_missing_parameters(self):\n        sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $status\"\n        parameters = {\n            'user_id': 42  # 'status' is missing\n        }\n        expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $2\"\n        expected_values = [42]  # 'status' is not included\n\n        new_sql, value_list = prepare_query(sql_query, parameters)\n        self.assertEqual(new_sql, expected_sql)\n        self.assertEqual(value_list, expected_values)\n\n    def test_no_parameters(self):\n        sql_query = \"SELECT * FROM users\"\n        parameters = {}  # No parameters provided\n        expected_sql = \"SELECT * FROM users\"\n        expected_values = []\n\n        new_sql, value_list = prepare_query(sql_query, parameters)\n        self.assertEqual(new_sql, expected_sql)\n        self.assertEqual(value_list, expected_values)\n\n    def test_multiple_same_parameters(self):\n        sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $user_id\"\n        parameters = {\n            'user_id': 42\n        }\n        expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $1\"\n        expected_values = [42]  # Only one value for 'user_id'\n\n        new_sql, value_list = prepare_query(sql_query, parameters)\n        self.assertEqual(new_sql, expected_sql)\n        self.assertEqual(value_list, expected_values)\n\n    def test_special_characters_in_parameters(self):\n        sql_query = \"INSERT INTO users (name, email) VALUES ($name, $email)\"\n        parameters = {\n            'name': \"John Doe\",\n            'email': \"john.doe@example.com\"\n        }\n        expected_sql = \"INSERT INTO users (name, email) VALUES ($1, $2)\"\n        expected_values = [\"John Doe\", \"john.doe@example.com\"]\n\n        new_sql, value_list = prepare_query(sql_query, parameters)\n        self.assertEqual(new_sql, expected_sql)\n        self.assertEqual(value_list, expected_values)", "prompt": "please write a python function , the function signature as below import re\n\n\ndef prepare_query(sql: str, params: dict) -> tuple:\n    \"\"\"\n    This function modifies a SQL query string containing named parameters\n    (like $name, $age) into a format compatible with libraries that require\n    positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n    a tuple containing the modified SQL string and a list of parameter values\n    ordered according to their new positions in the query.\n    For example:\n        input:\n            sql: SELECT * FROM users WHERE id = $user_id AND status = $status\n            params: {'user_id': 42,'status': 'active'}\n        output:\n            SELECT * FROM users WHERE id = $1 AND status = $2,[42, 'active']\n\n    Args:\n        sql (str): The original SQL query string with named parameters.\n        params (dict): A dictionary mapping parameter names to their values.\n\n    Returns:\n        tuple: A tuple where the first element is the modified SQL query string with positional parameters, and the second element is a list of parameter values sorted according to the order of the positional parameters.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief This function modifies a SQL query string containing named parameters\n * (like $name, $age) into a format compatible with libraries that require\n * positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n * a pair containing the modified SQL string and a vector of parameter values\n * ordered according to their new positions in the query.\n * \n * Example:\n *     Input:\n *         sql: SELECT * FROM users WHERE id = $user_id AND status = $status\n *         params: {{\"user_id\", \"42\"}, {\"status\", \"active\"}}\n *     Output:\n *         Modified SQL: SELECT * FROM users WHERE id = $1 AND status = $2\n *         Values: [\"42\", \"active\"]\n * \n * @param sql The original SQL query string with named parameters.\n * @param params A map mapping parameter names to their values.\n * @return A pair where the first element is the modified SQL query string with positional parameters,\n *         and the second element is a vector of parameter values sorted according to the order of the positional parameters.\n */\nstd::pair<std::string, std::vector<std::string>> prepare_query(const std::string& sql, const std::map<std::string, std::string>& params) {}", "test_code": "TEST_CASE(\"Test prepare_query function\") {\n    SECTION(\"Valid named parameters\") {\n        std::string sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $status\";\n        std::map<std::string, std::string> parameters = {\n            {\"user_id\", \"42\"},\n            {\"status\", \"active\"}\n        };\n        std::string expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $2\";\n        std::vector<std::string> expected_values = {\"42\", \"active\"};\n\n        auto [new_sql, value_list] = prepare_query(sql_query, parameters);\n        REQUIRE(new_sql == expected_sql);\n        REQUIRE(value_list == expected_values);\n    }\n\n    SECTION(\"Missing parameters\") {\n        std::string sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $status\";\n        std::map<std::string, std::string> parameters = {\n            {\"user_id\", \"42\"}\n        };\n        std::string expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $2\";\n        std::vector<std::string> expected_values = {\"42\"};\n\n        auto [new_sql, value_list] = prepare_query(sql_query, parameters);\n        REQUIRE(new_sql == expected_sql);\n        REQUIRE(value_list == expected_values);\n    }\n\n    SECTION(\"No parameters\") {\n        std::string sql_query = \"SELECT * FROM users\";\n        std::map<std::string, std::string> parameters = {};\n        std::string expected_sql = \"SELECT * FROM users\";\n        std::vector<std::string> expected_values = {};\n\n        auto [new_sql, value_list] = prepare_query(sql_query, parameters);\n        REQUIRE(new_sql == expected_sql);\n        REQUIRE(value_list == expected_values);\n    }\n\n    SECTION(\"Multiple same parameters\") {\n        std::string sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $user_id\";\n        std::map<std::string, std::string> parameters = {\n            {\"user_id\", \"42\"}\n        };\n        std::string expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $1\";\n        std::vector<std::string> expected_values = {\"42\"};\n\n        auto [new_sql, value_list] = prepare_query(sql_query, parameters);\n        REQUIRE(new_sql == expected_sql);\n        REQUIRE(value_list == expected_values);\n    }\n\n    SECTION(\"Special characters in parameters\") {\n        std::string sql_query = \"INSERT INTO users (name, email) VALUES ($name, $email)\";\n        std::map<std::string, std::string> parameters = {\n            {\"name\", \"John Doe\"},\n            {\"email\", \"john.doe@example.com\"}\n        };\n        std::string expected_sql = \"INSERT INTO users (name, email) VALUES ($1, $2)\";\n        std::vector<std::string> expected_values = {\"John Doe\", \"john.doe@example.com\"};\n\n        auto [new_sql, value_list] = prepare_query(sql_query, parameters);\n        REQUIRE(new_sql == expected_sql);\n        REQUIRE(value_list == expected_values);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief This function modifies a SQL query string containing named parameters\n * (like $name, $age) into a format compatible with libraries that require\n * positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n * a pair containing the modified SQL string and a vector of parameter values\n * ordered according to their new positions in the query.\n * \n * Example:\n *     Input:\n *         sql: SELECT * FROM users WHERE id = $user_id AND status = $status\n *         params: {{\"user_id\", \"42\"}, {\"status\", \"active\"}}\n *     Output:\n *         Modified SQL: SELECT * FROM users WHERE id = $1 AND status = $2\n *         Values: [\"42\", \"active\"]\n * \n * @param sql The original SQL query string with named parameters.\n * @param params A map mapping parameter names to their values.\n * @return A pair where the first element is the modified SQL query string with positional parameters,\n *         and the second element is a vector of parameter values sorted according to the order of the positional parameters.\n */\nstd::pair<std::string, std::vector<std::string>> prepare_query(const std::string& sql, const std::map<std::string, std::string>& params) {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 486, "code_type": "method", "original_language": "python", "file_path": "calculator\\252881ee22af936f9ca4a8e5a1b2bc19bfba8db7\\calc.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "a class implements add, subtract, multiply, and divide\n", "language_version_list": {"python": {"code_signature": "class Calculator:\n    def add(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the sum of a and b.\n        \"\"\"\n        pass\n\n    def subtract(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the difference of a and b.\n        \"\"\"\n        pass\n\n    def multiply(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the product of a and b.\n        \"\"\"\n        pass\n\n    def divide(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the quotient of a and b.\n        Raises ValueError if b is zero.\n        \"\"\"\n        pass\n", "test_code": "import unittest\n\n\nclass TestCalculator(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create an instance of Calculator before each test.\"\"\"\n        self.calculator = Calculator()\n\n    def test_add(self):\n        \"\"\"Test the addition method.\"\"\"\n        result = self.calculator.add(10, 5)\n        self.assertEqual(result, 15)\n\n    def test_subtract(self):\n        \"\"\"Test the subtraction method.\"\"\"\n        result = self.calculator.subtract(10, 5)\n        self.assertEqual(result, 5)\n\n    def test_multiply(self):\n        \"\"\"Test the multiplication method.\"\"\"\n        result = self.calculator.multiply(10, 5)\n        self.assertEqual(result, 50)\n\n    def test_divide(self):\n        \"\"\"Test the division method.\"\"\"\n        result = self.calculator.divide(10, 5)\n        self.assertEqual(result, 2.0)\n\n    def test_divide_by_zero(self):\n        \"\"\"Test division by zero raises ValueError.\"\"\"\n        self.assertRaises(Exception)", "prompt": "please write a python function , the function signature as below class Calculator:\n    def add(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the sum of a and b.\n        \"\"\"\n        pass\n\n    def subtract(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the difference of a and b.\n        \"\"\"\n        pass\n\n    def multiply(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the product of a and b.\n        \"\"\"\n        pass\n\n    def divide(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the quotient of a and b.\n        Raises ValueError if b is zero.\n        \"\"\"\n        pass\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "class Calculator {\npublic:\n    // Returns the sum of a and b.\n    float add(float a, float b) {\n    }\n\n    // Returns the difference of a and b.\n    float subtract(float a, float b) {\n    }\n\n    // Returns the product of a and b.\n    float multiply(float a, float b) {\n    }\n\n    // Returns the quotient of a and b.\n    // Throws std::invalid_argument if b is zero.\n    float divide(float a, float b) {\n    }\n};", "test_code": "TEST_CASE(\"Calculator operations\", \"[Calculator]\") {\n    Calculator calculator;\n\n    // Test the addition method.\n    SECTION(\"Addition\") {\n        float result = calculator.add(10, 5);\n        REQUIRE(result == 15);\n    }\n\n    // Test the subtraction method.\n    SECTION(\"Subtraction\") {\n        float result = calculator.subtract(10, 5);\n        REQUIRE(result == 5);\n    }\n\n    // Test the multiplication method.\n    SECTION(\"Multiplication\") {\n        float result = calculator.multiply(10, 5);\n        REQUIRE(result == 50);\n    }\n\n    // Test the division method.\n    SECTION(\"Division\") {\n        float result = calculator.divide(10, 5);\n        REQUIRE(result == 2.0f);\n    }\n\n    // Test division by zero raises std::invalid_argument.\n    SECTION(\"Division by zero\") {\n        REQUIRE_THROWS_AS(calculator.divide(10, 0), std::invalid_argument);\n    }\n}", "prompt": "please write a cpp function , the function signature as below class Calculator {\npublic:\n    // Returns the sum of a and b.\n    float add(float a, float b) {\n    }\n\n    // Returns the difference of a and b.\n    float subtract(float a, float b) {\n    }\n\n    // Returns the product of a and b.\n    float multiply(float a, float b) {\n    }\n\n    // Returns the quotient of a and b.\n    // Throws std::invalid_argument if b is zero.\n    float divide(float a, float b) {\n    }\n};", "addition_info": ""}, "java": {"code_signature": "package org.real.temp;\n\n/**\n * A simple calculator class that provides basic arithmetic operations.\n */\npublic class Answer {\n\n    /**\n     * A class that performs basic arithmetic operations.\n     */\n    public static class Calculator {\n\n        /**\n         * Returns the sum of two floating-point numbers.\n         *\n         * @param a the first number\n         * @param b the second number\n         * @return the sum of a and b\n         */\n        public double add(double a, double b) {\n        }\n\n        /**\n         * Returns the difference between two floating-point numbers.\n         *\n         * @param a the first number\n         * @param b the second number\n         * @return the difference of a and b\n         */\n        public double subtract(double a, double b) {\n        }\n\n        /**\n         * Returns the product of two floating-point numbers.\n         *\n         * @param a the first number\n         * @param b the second number\n         * @return the product of a and b\n         */\n        public double multiply(double a, double b) {\n        }\n\n        /**\n         * Returns the quotient of two floating-point numbers.\n         *\n         * @param a the numerator\n         * @param b the denominator\n         * @return the quotient of a and b\n         * @throws IllegalArgumentException if b is zero\n         */\n        public double divide(double a, double b) {\n        }\n    }\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\n/**\n * Test class for the Calculator.\n */\npublic class Tester {\n\n    private Calculator calculator;\n\n    @Before\n    public void setUp() {\n        // Create an instance of Calculator before each test.\n        calculator = new Calculator();\n    }\n\n    @Test\n    public void testAdd() {\n        // Test the addition method.\n        double result = calculator.add(10, 5);\n        assertEquals(15.0, result, 0.0);\n    }\n\n    @Test\n    public void testSubtract() {\n        // Test the subtraction method.\n        double result = calculator.subtract(10, 5);\n        assertEquals(5.0, result, 0.0);\n    }\n\n    @Test\n    public void testMultiply() {\n        // Test the multiplication method.\n        double result = calculator.multiply(10, 5);\n        assertEquals(50.0, result, 0.0);\n    }\n\n    @Test\n    public void testDivide() {\n        // Test the division method.\n        double result = calculator.divide(10, 5);\n        assertEquals(2.0, result, 0.0);\n    }\n\n    @Test\n    public void testDivideByZero() {\n        // Test division by zero raises IllegalArgumentException.\n        assertThrows(IllegalArgumentException.class, () -> calculator.divide(10, 0));\n    }\n}", "prompt": "please write a java function , the function signature as below package org.real.temp;\n\n/**\n * A simple calculator class that provides basic arithmetic operations.\n */\npublic class Answer {\n\n    /**\n     * A class that performs basic arithmetic operations.\n     */\n    public static class Calculator {\n\n        /**\n         * Returns the sum of two floating-point numbers.\n         *\n         * @param a the first number\n         * @param b the second number\n         * @return the sum of a and b\n         */\n        public double add(double a, double b) {\n        }\n\n        /**\n         * Returns the difference between two floating-point numbers.\n         *\n         * @param a the first number\n         * @param b the second number\n         * @return the difference of a and b\n         */\n        public double subtract(double a, double b) {\n        }\n\n        /**\n         * Returns the product of two floating-point numbers.\n         *\n         * @param a the first number\n         * @param b the second number\n         * @return the product of a and b\n         */\n        public double multiply(double a, double b) {\n        }\n\n        /**\n         * Returns the quotient of two floating-point numbers.\n         *\n         * @param a the numerator\n         * @param b the denominator\n         * @return the quotient of a and b\n         * @throws IllegalArgumentException if b is zero\n         */\n        public double divide(double a, double b) {\n        }\n    }\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 487, "code_type": "method", "original_language": "python", "file_path": "athina-sdk\\50646629f89f8e25d0a7b7a8edb69305605fcabb\\magik\\evaluators.py\n", "question_type": "Data processing and transformation", "summary": "Check if the string contains an email address\n", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef contains_email(text: str) -> bool:\n    \"\"\"\n    Check if the given text contains an email address.\n\n    Args:\n        text (str): The string to search for an email address.\n\n    Returns:\n        bool: True if an email address is found, False otherwise.\n    \"\"\"\n\n\n    \"\"\"\n    Check if the given text contains an email address.\n\n    Args:\n    text (str): The string to search for an email address.\n\n    Returns:\n    bool: True if an email address is found, False otherwise.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestContainsEmail(unittest.TestCase):\n\n    def test_contains_valid_email(self):\n        \"\"\"Test if a valid email is detected in the string.\"\"\"\n        test_string = \"You can reach me at example@example.com for more info.\"\n        self.assertTrue(contains_email(test_string))\n\n    def test_contains_email_with_special_characters(self):\n        \"\"\"Test if an email with special characters is detected.\"\"\"\n        test_string = \"My email address is john.doe123+test@gmail.com!\"\n        self.assertTrue(contains_email(test_string))\n\n    def test_does_not_contain_email(self):\n        \"\"\"Test a string that does not contain any email address.\"\"\"\n        test_string = \"This string does not have an email.\"\n        self.assertFalse(contains_email(test_string))\n\n    def test_contains_multiple_emails(self):\n        \"\"\"Test a string containing multiple email addresses.\"\"\"\n        test_string = \"You can contact me at example1@example.com or example2@example.com.\"\n        self.assertTrue(contains_email(test_string))\n\n    def test_contains_invalid_email_format(self):\n        \"\"\"Test a string with an invalid email format.\"\"\"\n        test_string = \"Please contact me at example@.com or test@domain.\"\n        self.assertFalse(contains_email(test_string))", "prompt": "please write a python function , the function signature as below import re\n\n\ndef contains_email(text: str) -> bool:\n    \"\"\"\n    Check if the given text contains an email address.\n\n    Args:\n        text (str): The string to search for an email address.\n\n    Returns:\n        bool: True if an email address is found, False otherwise.\n    \"\"\"\n\n\n    \"\"\"\n    Check if the given text contains an email address.\n\n    Args:\n    text (str): The string to search for an email address.\n\n    Returns:\n    bool: True if an email address is found, False otherwise.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Checks if the given text contains an email address.\n *\n * @param text The string to search for an email address.\n * @type text const std::string&\n *\n * @return True if an email address is found, False otherwise.\n * @rtype bool\n */\nbool containsEmailAddress(const std::string &text){}\n", "test_code": "TEST_CASE(\"TestContainsEmail\", \"[email]\") {\n    SECTION(\"test_contains_valid_email\") {\n        // Test if a valid email is detected in the string\n        std::string test_string = \"You can reach me at example@example.com for more info.\";\n        REQUIRE(contains_email(test_string));\n    }\n\n    SECTION(\"test_contains_email_with_special_characters\") {\n        // Test if an email with special characters is detected\n        std::string test_string = \"My email address is john.doe123+test@gmail.com!\";\n        REQUIRE(contains_email(test_string));\n    }\n\n    SECTION(\"test_does_not_contain_email\") {\n        // Test a string that does not contain any email address\n        std::string test_string = \"This string does not have an email.\";\n        REQUIRE_FALSE(contains_email(test_string));\n    }\n\n    SECTION(\"test_contains_multiple_emails\") {\n        // Test a string containing multiple email addresses\n        std::string test_string = \"You can contact me at example1@example.com or example2@example.com.\";\n        REQUIRE(contains_email(test_string));\n    }\n\n    SECTION(\"test_contains_invalid_email_format\") {\n        // Test a string with an invalid email format\n        std::string test_string = \"Please contact me at example@.com or test@domain.\";\n        REQUIRE_FALSE(contains_email(test_string));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Checks if the given text contains an email address.\n *\n * @param text The string to search for an email address.\n * @type text const std::string&\n *\n * @return True if an email address is found, False otherwise.\n * @rtype bool\n */\nbool containsEmailAddress(const std::string &text){}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks if the given text contains an email address.\n *\n * @param text The string to search for an email address.\n * @return true if an email address is found, false otherwise.\n */\npublic static boolean containsEmail(String text) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Test class for checking if a string contains an email address.\n */\npublic class Tester {\n\n    /**\n     * Test if a valid email is detected in the string.\n     */\n    @Test\n    public void testContainsValidEmail() {\n        String testString = \"You can reach me at example@example.com for more info.\";\n        assertTrue(containsEmail(testString));\n    }\n\n    /**\n     * Test if an email with special characters is detected.\n     */\n    @Test\n    public void testContainsEmailWithSpecialCharacters() {\n        String testString = \"My email address is john.doe123+test@gmail.com!\";\n        assertTrue(containsEmail(testString));\n    }\n\n    /**\n     * Test a string that does not contain any email address.\n     */\n    @Test\n    public void testDoesNotContainEmail() {\n        String testString = \"This string does not have an email.\";\n        assertFalse(containsEmail(testString));\n    }\n\n    /**\n     * Test a string containing multiple email addresses.\n     */\n    @Test\n    public void testContainsMultipleEmails() {\n        String testString = \"You can contact me at example1@example.com or example2@example.com.\";\n        assertTrue(containsEmail(testString));\n    }\n\n    /**\n     * Test a string with an invalid email format.\n     */\n    @Test\n    public void testContainsInvalidEmailFormat() {\n        String testString = \"Please contact me at example@.com or test@domain.\";\n        assertFalse(containsEmail(testString));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks if the given text contains an email address.\n *\n * @param text The string to search for an email address.\n * @return true if an email address is found, false otherwise.\n */\npublic static boolean containsEmail(String text) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 488, "code_type": "method", "original_language": "python", "file_path": "MobileComputingAssignments\\83fc9405bb9ed970ef84f9d292de3e3e49837cc7\\Assignment 4\\utils.py\n", "question_type": "Network requests and API call", "summary": "Retrieve the local IP address of the specified network interface on Windows.", "language_version_list": {"python": {"code_signature": "import subprocess\nimport re\nfrom typing import Optional\n\n\ndef get_local_ip(interface: str = 'Wi-Fi') -> Optional[str]:\n    \"\"\"\n    Retrieve the local IP address of the specified network interface on Windows.\n\n    Args:\n        interface (str): The name of the network interface to check (default is 'Wi-Fi').\n\n    Returns:\n        Optional[str]: The local IP address if found, otherwise None.\n    \"\"\"\n", "test_code": "import subprocess\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass TestGetLocalIP(unittest.TestCase):\n\n    @patch('subprocess.run')\n    def test_local_ip_found(self, mock_run):\n        # Mock the output of ipconfig for a case where a local IP is found\n        mock_run.return_value = MagicMock(stdout='192.168.1.10\\n')\n        result = get_local_ip()\n        self.assertEqual(result, '192.168.1.10')\n\n    @patch('subprocess.run')\n    def test_no_local_ip_found(self, mock_run):\n        # Mock the output of ipconfig for a case where no local IP is found\n        mock_run.return_value = MagicMock(stdout='10.0.0.5\\n')\n        result = get_local_ip()\n        self.assertIsNone(result)\n\n    @patch('subprocess.run')\n    def test_multiple_ips_found(self, mock_run):\n        # Mock the output with multiple local IPs\n        mock_run.return_value = MagicMock(stdout='10.0.0.5\\n'\n                                                  '192.168.1.10\\n')\n        result = get_local_ip()\n        self.assertEqual(result, '192.168.1.10')\n\n    @patch('subprocess.run')\n    def test_invalid_command(self, mock_run):\n        # Simulate a case where subprocess.run raises a CalledProcessError\n        mock_run.side_effect = subprocess.CalledProcessError(1, 'ipconfig')\n        result = get_local_ip()\n        self.assertIsNone(result)\n\n    @patch('subprocess.run')\n    def test_unexpected_error(self, mock_run):\n        # Simulate an unexpected error\n        mock_run.side_effect = Exception(\"Unexpected error\")\n        result = get_local_ip()\n        self.assertIsNone(result)", "prompt": "please write a python function , the function signature as below import subprocess\nimport re\nfrom typing import Optional\n\n\ndef get_local_ip(interface: str = 'Wi-Fi') -> Optional[str]:\n    \"\"\"\n    Retrieve the local IP address of the specified network interface on Windows.\n\n    Args:\n        interface (str): The name of the network interface to check (default is 'Wi-Fi').\n\n    Returns:\n        Optional[str]: The local IP address if found, otherwise None.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Retrieve the local IP address of the specified network interface on Windows.\n *\n * @param interface The name of the network interface to check (default is \"Wi-Fi\").\n * @return The local IP address if found, otherwise std::nullopt.\n */\nusing OptionalString = std::optional<std::string>;\nOptionalString get_local_ip(const std::string& interface = \"Wi-Fi\") {}", "test_code": "TEST_CASE(\"Test Get Local IP\", \"[get_local_ip]\") {\n    SECTION(\"Local IP Found\") {\n        // Mock the output of ipconfig for a case where a local IP is found\n        std::istringstream mock_output(\"192.168.1.10\\n\");\n        std::streambuf* old_cout = std::cout.rdbuf(mock_output.rdbuf());\n\n        OptionalString result = get_local_ip();\n        REQUIRE(result.has_value());\n        REQUIRE(*result == \"192.168.1.10\");\n\n        std::cout.rdbuf(old_cout); // Restore the original stream buffer\n    }\n\n    SECTION(\"No Local IP Found\") {\n        // Mock the output of ipconfig for a case where no local IP is found\n        std::istringstream mock_output(\"10.0.0.5\\n\");\n        std::streambuf* old_cout = std::cout.rdbuf(mock_output.rdbuf());\n\n        OptionalString result = get_local_ip();\n        REQUIRE(!result.has_value());\n\n        std::cout.rdbuf(old_cout); // Restore the original stream buffer\n    }\n\n    SECTION(\"Multiple IPs Found\") {\n        // Mock the output with multiple local IPs\n        std::istringstream mock_output(\"10.0.0.5\\n192.168.1.10\\n\");\n        std::streambuf* old_cout = std::cout.rdbuf(mock_output.rdbuf());\n\n        OptionalString result = get_local_ip();\n        REQUIRE(result.has_value());\n        REQUIRE(*result == \"192.168.1.10\");\n\n        std::cout.rdbuf(old_cout); // Restore the original stream buffer\n    }\n\n    SECTION(\"Invalid Command\") {\n        // Simulate a case where CreateProcessA fails\n        std::istringstream mock_output(\"\");\n        std::streambuf* old_cout = std::cout.rdbuf(mock_output.rdbuf());\n\n        OptionalString result = get_local_ip();\n        REQUIRE(!result.has_value());\n\n        std::cout.rdbuf(old_cout); // Restore the original stream buffer\n    }\n\n    SECTION(\"Unexpected Error\") {\n        // Simulate an unexpected error\n        std::istringstream mock_output(\"\");\n        std::streambuf* old_cout = std::cout.rdbuf(mock_output.rdbuf());\n\n        OptionalString result = get_local_ip();\n        REQUIRE(!result.has_value());\n\n        std::cout.rdbuf(old_cout); // Restore the original stream buffer\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Retrieve the local IP address of the specified network interface on Windows.\n *\n * @param interface The name of the network interface to check (default is \"Wi-Fi\").\n * @return The local IP address if found, otherwise std::nullopt.\n */\nusing OptionalString = std::optional<std::string>;\nOptionalString get_local_ip(const std::string& interface = \"Wi-Fi\") {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Retrieve the local IP address of the specified network interface on Windows.\n *\n * @param interfaceName The name of the network interface to check (default is \"Wi-Fi\").\n * @return The local IP address if found, otherwise null.\n */\npublic static String getLocalIp(String interfaceName) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.mockito.Mockito.when;\nimport static org.mockito.Mockito.doThrow;\n\npublic class Tester {\n\n    @Mock\n    private Process processMock;\n\n    private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();\n\n    @BeforeEach\n    public void setUp() {\n        MockitoAnnotations.openMocks(this);\n        System.setOut(new PrintStream(outContent));\n    }\n\n    @Test\n    public void testLocalIpFound() throws IOException {\n        // Mock the output of ipconfig for a case where a local IP is found\n        when(Runtime.getRuntime().exec(\"ipconfig\")).thenReturn(processMock);\n        when(processMock.getInputStream()).thenReturn(new ByteArrayInputStream(\"192.168.1.10\\n\".getBytes()));\n\n        String result = getLocalIp();\n        assertEquals(\"192.168.1.10\", result);\n    }\n\n    @Test\n    public void testNoLocalIpFound() throws IOException {\n        // Mock the output of ipconfig for a case where no local IP is found\n        when(Runtime.getRuntime().exec(\"ipconfig\")).thenReturn(processMock);\n        when(processMock.getInputStream()).thenReturn(new ByteArrayInputStream(\"10.0.0.5\\n\".getBytes()));\n\n        String result = getLocalIp();\n        assertNull(result);\n    }\n\n    @Test\n    public void testMultipleIpsFound() throws IOException {\n        // Mock the output with multiple local IPs\n        when(Runtime.getRuntime().exec(\"ipconfig\")).thenReturn(processMock);\n        when(processMock.getInputStream()).thenReturn(new ByteArrayInputStream(\"10.0.0.5\\n192.168.1.10\\n\".getBytes()));\n\n        String result = getLocalIp();\n        assertEquals(\"192.168.1.10\", result);\n    }\n\n    @Test\n    public void testInvalidCommand() {\n        // Simulate a case where subprocess.run raises a CalledProcessError\n        doThrow(new IOException(\"CalledProcessError\")).when(Runtime.getRuntime()).exec(\"ipconfig\");\n\n        String result = getLocalIp();\n        assertNull(result);\n    }\n\n    @Test\n    public void testUnexpectedError() {\n        // Simulate an unexpected error\n        doThrow(new RuntimeException(\"Unexpected error\")).when(Runtime.getRuntime()).exec(\"ipconfig\");\n\n        String result = getLocalIp();\n        assertNull(result);\n    }\n\n    // Utility method to simulate the getLocalIp method\n    private String getLocalIp() {\n        try {\n            // Execute the 'ipconfig' command to get addresses for the specified interface\n            Process process = Runtime.getRuntime().exec(\"ipconfig\");\n            StringBuilder output = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n\n            // Regular expression to match IPv4 addresses\n            Pattern ipPattern = Pattern.compile(\"(\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+)\");\n\n            // Search for IP addresses in the command output\n            Matcher matcher = ipPattern.matcher(output.toString());\n            while (matcher.find()) {\n                String ip = matcher.group(1);\n                if (ip.startsWith(\"192.168.\")) {\n                    return ip; // Return the first local IP found\n                }\n            }\n\n            return null; // Return null if no suitable IP is found\n\n        } catch (IOException e) {\n            System.out.println(\"Error executing command: \" + e.getMessage());\n            return null;\n        } catch (Exception e) {\n            System.out.println(\"An unexpected error occurred: \" + e.getMessage());\n            return null;\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Retrieve the local IP address of the specified network interface on Windows.\n *\n * @param interfaceName The name of the network interface to check (default is \"Wi-Fi\").\n * @return The local IP address if found, otherwise null.\n */\npublic static String getLocalIp(String interfaceName) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 490, "code_type": "method", "original_language": "python", "file_path": "yet-another-applied-llm-benchmark\\e50ca985fc38cd848471e3bf82d24525238862e5\\create_results_html.py", "question_type": "Data processing and transformation", "summary": "    Formats a string by prepending '> ' to each line and ensuring proper\n    formatting of code blocks.", "language_version_list": {"python": {"code_signature": "def format_str_2_markdown(x: str) -> str:\n    \"\"\"\n    Formats a string by prepending '> ' to each line and ensuring proper\n    formatting of code blocks.\n\n    Args:\n        x (str): The input string to be formatted. If the input is not a\n        string, it will be converted to one.\n\n    Returns:\n        str: The formatted string with each line prefixed by '> ' and\n        with balanced code block delimiters.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFormatStr(unittest.TestCase):\n\n    def test_simple_string(self):\n        \"\"\"Test a simple string input.\"\"\"\n        input_str = \"Hello, World!\"\n        expected_output = \"> Hello, World!\"\n        self.assertEqual(format_str_2_markdown(input_str), expected_output)\n\n    def test_multiline_string(self):\n        \"\"\"Test a multiline string input.\"\"\"\n        input_str = \"Line 1\\nLine 2\\nLine 3\"\n        expected_output = \"> Line 1\\n> Line 2\\n> Line 3\"\n        self.assertEqual(format_str_2_markdown(input_str), expected_output)\n\n    def test_code_block_delimiters_even(self):\n        \"\"\"Test a string with an even number of code block delimiters.\"\"\"\n        input_str = \"Some code:\\n```\\nprint('Hello')\\n```\"\n        expected_output = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\"\n        self.assertEqual(format_str_2_markdown(input_str), expected_output)\n\n    def test_code_block_delimiters_odd(self):\n        \"\"\"Test a string with an odd number of code block delimiters.\"\"\"\n        input_str = \"Some code:\\n```\\nprint('Hello')\"\n        expected_output = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\"\n        self.assertEqual(format_str_2_markdown(input_str), expected_output)\n\n    def test_non_string_input(self):\n        \"\"\"Test non-string input (e.g., integer) to ensure it's converted.\"\"\"\n        input_value = 123\n        expected_output = \"> 123\"\n        self.assertEqual(format_str_2_markdown(input_value), expected_output)", "prompt": "please write a python function , the function signature as below def format_str_2_markdown(x: str) -> str:\n    \"\"\"\n    Formats a string by prepending '> ' to each line and ensuring proper\n    formatting of code blocks.\n\n    Args:\n        x (str): The input string to be formatted. If the input is not a\n        string, it will be converted to one.\n\n    Returns:\n        str: The formatted string with each line prefixed by '> ' and\n        with balanced code block delimiters.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Formats a string by prepending '> ' to each line and ensuring proper\n * formatting of code blocks.\n *\n * @param x The input string to be formatted. If the input is not a\n *          string, it will be converted to one.\n * @return The formatted string with each line prefixed by '> ' and\n *         with balanced code block delimiters.\n */\nstd::string format_str(const std::string& x) {}", "test_code": "TEST_CASE(\"Test a simple string input\", \"[format_str]\") {\n    std::string input_str = \"Hello, World!\";\n    std::string expected_output = \"> Hello, World!\";\n    REQUIRE(format_str(input_str) == expected_output);\n}\n\nTEST_CASE(\"Test a multiline string input\", \"[format_str]\") {\n    std::string input_str = \"Line 1\\nLine 2\\nLine 3\";\n    std::string expected_output = \"> Line 1\\n> Line 2\\n> Line 3\";\n    REQUIRE(format_str(input_str) == expected_output);\n}\n\nTEST_CASE(\"Test a string with an even number of code block delimiters\", \"[format_str]\") {\n    std::string input_str = \"Some code:\\n```\\nprint('Hello')\\n```\";\n    std::string expected_output = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\";\n    REQUIRE(format_str(input_str) == expected_output);\n}\n\nTEST_CASE(\"Test a string with an odd number of code block delimiters\", \"[format_str]\") {\n    std::string input_str = \"Some code:\\n```\\nprint('Hello')\";\n    std::string expected_output = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\";\n    REQUIRE(format_str(input_str) == expected_output);\n}\n\nTEST_CASE(\"Test non-string input (e.g., integer) to ensure it's converted\", \"[format_str]\") {\n    int input_value = 123;\n    std::string expected_output = \"> 123\";\n    REQUIRE(format_str(std::to_string(input_value)) == expected_output);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Formats a string by prepending '> ' to each line and ensuring proper\n * formatting of code blocks.\n *\n * @param x The input string to be formatted. If the input is not a\n *          string, it will be converted to one.\n * @return The formatted string with each line prefixed by '> ' and\n *         with balanced code block delimiters.\n */\nstd::string format_str(const std::string& x) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Formats a string by prepending '> ' to each line and ensuring proper\n * formatting of code blocks.\n *\n * @param x The input string to be formatted. If the input is not a string,\n *          it will be converted to one.\n * @return The formatted string with each line prefixed by '> ' and\n *         with balanced code block delimiters.\n */\npublic static String formatStr(Object x) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for the formatStr method.\n */\npublic class Tester {\n\n    /**\n     * Tests a simple string input.\n     */\n    @Test\n    public void testSimpleString() {\n        String inputStr = \"Hello, World!\";\n        String expectedOutput = \"> Hello, World!\";\n        assertEquals(expectedOutput, formatStr(inputStr));\n    }\n\n    /**\n     * Tests a multiline string input.\n     */\n    @Test\n    public void testMultilineString() {\n        String inputStr = \"Line 1\\nLine 2\\nLine 3\";\n        String expectedOutput = \"> Line 1\\n> Line 2\\n> Line 3\";\n        assertEquals(expectedOutput, formatStr(inputStr));\n    }\n\n    /**\n     * Tests a string with an even number of code block delimiters.\n     */\n    @Test\n    public void testCodeBlockDelimitersEven() {\n        String inputStr = \"Some code:\\n```\\nprint('Hello')\\n```\";\n        String expectedOutput = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\";\n        assertEquals(expectedOutput, formatStr(inputStr));\n    }\n\n    /**\n     * Tests a string with an odd number of code block delimiters.\n     */\n    @Test\n    public void testCodeBlockDelimitersOdd() {\n        String inputStr = \"Some code:\\n```\\nprint('Hello')\";\n        String expectedOutput = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\";\n        assertEquals(expectedOutput, formatStr(inputStr));\n    }\n\n    /**\n     * Tests non-string input (e.g., integer) to ensure it's converted.\n     */\n    @Test\n    public void testNonStringInput() {\n        Object inputValue = 123;\n        String expectedOutput = \"> 123\";\n        assertEquals(expectedOutput, formatStr(inputValue));\n    }\n\n    // The formatStr method implementation\n    private String formatStr(Object x) {\n        // Convert x to string if it's not already a string.\n        String str = x.toString();\n\n        // Ensure there is a matching number of code block delimiters.\n        // If the count of delimiters is odd, append an additional one to balance.\n        int delimiterCount = str.length() - str.replace(\"```\", \"\").length();\n        if (delimiterCount % 2 == 1) {\n            str += \"\\n```\";\n        }\n\n        // Format each line by prepending '> ' and join them with newlines.\n        String[] lines = str.split(\"\\n\");\n        StringBuilder formattedLines = new StringBuilder();\n        for (String line : lines) {\n            formattedLines.append(\"> \").append(line).append(\"\\n\");\n        }\n\n        // Return the final formatted string.\n        return formattedLines.toString();\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Formats a string by prepending '> ' to each line and ensuring proper\n * formatting of code blocks.\n *\n * @param x The input string to be formatted. If the input is not a string,\n *          it will be converted to one.\n * @return The formatted string with each line prefixed by '> ' and\n *         with balanced code block delimiters.\n */\npublic static String formatStr(Object x) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 491, "code_type": "method", "original_language": "python", "file_path": "yet-another-applied-llm-benchmark\\e50ca985fc38cd848471e3bf82d24525238862e5\\create_results_html.py", "question_type": "Data processing and transformation", "summary": "    Convert a value in the range [0, 1] to an RGB color that transitions \n    from red to yellow and then from yellow to green.", "language_version_list": {"python": {"code_signature": "def convert_range_to_color_yellow_green_change(value: float) -> tuple:\n    \"\"\"\n    Convert a value in the range [0, 1] to an RGB color that transitions\n    from red to yellow and then from yellow to green.\n\n    Parameters:\n        value (float): A float value in the range [0, 1] representing the\n                       interpolation position.\n\n    Returns:\n        tuple: A tuple containing the RGB color values (red, green, blue).\n    \"\"\"\n\n    # Scale the input value from the range [0, 1] to [0, 255]\n", "test_code": "import unittest\nclass TestConvertToColorThroughYellow(unittest.TestCase):\n    \n    def test_red(self):\n        \"\"\"Test the output for value 0.0 (should be red)\"\"\"\n        self.assertEqual(convert_to_color_through_yellow(0.0), (255, 127.5, 127.5))\n\n    def test_yellow(self):\n        \"\"\"Test the output for value 0.5 (should be yellow)\"\"\"\n        self.assertEqual(convert_to_color_through_yellow(0.5), (255, 255, 127.5))\n\n    def test_green(self):\n        \"\"\"Test the output for value 1.0 (should be green)\"\"\"\n        self.assertEqual(convert_to_color_through_yellow(1.0), (0, 255, 127.5))\n\n    def test_mid_transition(self):\n        \"\"\"Test the output for value 0.25 (between red and yellow)\"\"\"\n        self.assertEqual(convert_to_color_through_yellow(0.25), (255, 191, 127.5))\n\n    def test_yellow_transition(self):\n        \"\"\"Test the output for value 0.75 (between yellow and green)\"\"\"\n        self.assertEqual(convert_to_color_through_yellow(0.75), (127, 255, 127.5))", "prompt": "please write a python function , the function signature as below def convert_range_to_color_yellow_green_change(value: float) -> tuple:\n    \"\"\"\n    Convert a value in the range [0, 1] to an RGB color that transitions\n    from red to yellow and then from yellow to green.\n\n    Parameters:\n        value (float): A float value in the range [0, 1] representing the\n                       interpolation position.\n\n    Returns:\n        tuple: A tuple containing the RGB color values (red, green, blue).\n    \"\"\"\n\n    # Scale the input value from the range [0, 1] to [0, 255]\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 492, "code_type": "method", "original_language": "python", "file_path": "experiments\\86f0146b22d18c19be3d7318ee367f5fef4eb366\\mlx\\lora\\lib\\prepare_training_data.py", "question_type": "Data processing and transformation", "summary": "    Saves the provided content to a specified file after cleaning up\n    redundant whitespace.", "language_version_list": {"python": {"code_signature": "def save_content_to_file(content: str, path: str) -> None:\n    \"\"\"\n    Saves the provided content to a specified file after cleaning up\n    redundant whitespace.\n\n    Args:\n        content (str): The text content to be saved to the file.\n        path (str): The file path where the content will be saved.\n\n    Returns:\n        None\n    \"\"\"", "test_code": "import os\nimport unittest\n\n\nclass TestSaveContentToFile(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up a temporary file path for testing.\"\"\"\n        self.test_file_path = 'test_output.txt'\n\n    def tearDown(self):\n        \"\"\"Clean up the test file after each test.\"\"\"\n        if os.path.exists(self.test_file_path):\n            os.remove(self.test_file_path)\n\n    def test_basic_content(self):\n        \"\"\"Test with basic content and check if it saves correctly.\"\"\"\n        content = \"Hello,  World!  \"\n        expected = \"Hello, World!\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)\n\n    def test_multiple_spaces_and_empty_lines(self):\n        \"\"\"Test handling of multiple spaces and empty lines.\"\"\"\n        content = \"\"\"\n\n        This is a    test.\n\n        Another line.      \n        \"\"\"\n        expected = \"This is a test. Another line.\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)\n\n    def test_only_whitespace(self):\n        \"\"\"Test if only whitespace is handled correctly.\"\"\"\n        content = \"    \\n  \\n   \"\n        expected = \"\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)\n\n    def test_empty_content(self):\n        \"\"\"Test if empty content is saved correctly.\"\"\"\n        content = \"\"\n        expected = \"\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def save_content_to_file(content: str, path: str) -> None:\n    \"\"\"\n    Saves the provided content to a specified file after cleaning up\n    redundant whitespace.\n\n    Args:\n        content (str): The text content to be saved to the file.\n        path (str): The file path where the content will be saved.\n\n    Returns:\n        None\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Saves the provided content to a specified file after cleaning up\n * redundant whitespace.\n *\n * @param content The text content to be saved to the file.\n * @param path The file path where the content will be saved.\n */\nvoid save_content_to_file(const std::string& content, const std::string& path) {}", "test_code": "TEST_CASE(\"TestSaveContentToFile\", \"[save_content_to_file]\") {\n    const std::string test_file_path = \"test_output.txt\";\n\n    SECTION(\"Basic content\") {\n        std::string content = \"Hello,  World!  \";\n        std::string expected = \"Hello, World!\";\n        save_content_to_file(content, test_file_path);\n\n        std::ifstream file(test_file_path);\n        REQUIRE(file.is_open());\n        std::string result((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        file.close();\n\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Multiple spaces and empty lines\") {\n        std::string content = R\"(\n        \n        This is a    test.\n\n        Another line.      \n        )\";\n        std::string expected = \"This is a test. Another line.\";\n        save_content_to_file(content, test_file_path);\n\n        std::ifstream file(test_file_path);\n        REQUIRE(file.is_open());\n        std::string result((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        file.close();\n\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Only whitespace\") {\n        std::string content = \"    \\n  \\n   \";\n        std::string expected = \"\";\n        save_content_to_file(content, test_file_path);\n\n        std::ifstream file(test_file_path);\n        REQUIRE(file.is_open());\n        std::string result((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        file.close();\n\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Empty content\") {\n        std::string content = \"\";\n        std::string expected = \"\";\n        save_content_to_file(content, test_file_path);\n\n        std::ifstream file(test_file_path);\n        REQUIRE(file.is_open());\n        std::string result((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        file.close();\n\n        REQUIRE(result == expected);\n    }\n\n    // Clean up the test file after all sections\n    if (fs::exists(test_file_path)) {\n        fs::remove(test_file_path);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Saves the provided content to a specified file after cleaning up\n * redundant whitespace.\n *\n * @param content The text content to be saved to the file.\n * @param path The file path where the content will be saved.\n */\nvoid save_content_to_file(const std::string& content, const std::string& path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Saves the provided content to a specified file after cleaning up redundant whitespace.\n *\n * @param content The text content to be saved to the file.\n * @param path    The file path where the content will be saved.\n */\npublic static void saveContentToFile(String content, String path) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Tester {\n\n    private static final String TEST_FILE_PATH = \"test_output.txt\";\n\n    @Before\n    public void setUp() {\n        // Set up a temporary file path for testing.\n    }\n\n    @After\n    public void tearDown() {\n        // Clean up the test file after each test.\n        File file = new File(TEST_FILE_PATH);\n        if (file.exists()) {\n            file.delete();\n        }\n    }\n\n    @Test\n    public void testBasicContent() throws IOException {\n        // Test with basic content and check if it saves correctly.\n        String content = \"Hello,  World!  \";\n        String expected = \"Hello, World!\";\n        saveContentToFile(content, TEST_FILE_PATH);\n\n        try (FileReader reader = new FileReader(TEST_FILE_PATH)) {\n            char[] buffer = new char[1024];\n            int length = reader.read(buffer);\n            String result = new String(buffer, 0, length).trim();\n            assertEquals(expected, result);\n        }\n    }\n\n    @Test\n    public void testMultipleSpacesAndEmptyLines() throws IOException {\n        // Test handling of multiple spaces and empty lines.\n        String content = \"\\n\\n\\nThis is a    test.\\n\\nAnother line.      \\n\";\n        String expected = \"This is a test. Another line.\";\n        saveContentToFile(content, TEST_FILE_PATH);\n\n        try (FileReader reader = new FileReader(TEST_FILE_PATH)) {\n            char[] buffer = new char[1024];\n            int length = reader.read(buffer);\n            String result = new String(buffer, 0, length).trim();\n            assertEquals(expected, result);\n        }\n    }\n\n    @Test\n    public void testOnlyWhitespace() throws IOException {\n        // Test if only whitespace is handled correctly.\n        String content = \"    \\n  \\n   \";\n        String expected = \"\";\n        saveContentToFile(content, TEST_FILE_PATH);\n\n        try (FileReader reader = new FileReader(TEST_FILE_PATH)) {\n            char[] buffer = new char[1024];\n            int length = reader.read(buffer);\n            String result = new String(buffer, 0, length).trim();\n            assertEquals(expected, result);\n        }\n    }\n\n    @Test\n    public void testEmptyContent() throws IOException {\n        // Test if empty content is saved correctly.\n        String content = \"\";\n        String expected = \"\";\n        saveContentToFile(content, TEST_FILE_PATH);\n\n        try (FileReader reader = new FileReader(TEST_FILE_PATH)) {\n            char[] buffer = new char[1024];\n            int length = reader.read(buffer);\n            String result = new String(buffer, 0, length).trim();\n            assertEquals(expected, result);\n        }\n    }\n\n    // Utility method to save content to a file\n    private void saveContentToFile(String content, String path) {\n        // Remove redundant whitespace from the content.\n        // Split the content into lines, strip leading/trailing whitespace,\n        // and filter out empty lines.\n        content = String.join(\"\\n\",\n            content.lines()\n                   .filter(line -> !line.trim().isEmpty())\n                   .map(String::trim)\n                   .toArray(String[]::new));\n\n        // Replace multiple spaces with a single space.\n        content = content.replaceAll(\"\\\\s+\", \" \").trim();\n\n        // Write the cleaned content to the specified file.\n        try (FileWriter writer = new FileWriter(path, false)) {\n            writer.write(content);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Saves the provided content to a specified file after cleaning up redundant whitespace.\n *\n * @param content The text content to be saved to the file.\n * @param path    The file path where the content will be saved.\n */\npublic static void saveContentToFile(String content, String path) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 493, "code_type": "method", "original_language": "python", "file_path": "experiments\\86f0146b22d18c19be3d7318ee367f5fef4eb366\\mlx\\lora\\lib\\prepare_training_data.py", "question_type": "Data processing and transformation", "summary": "Wrap the text content to the specified maximum width and generate these lines line by line\n", "language_version_list": {"python": {"code_signature": "import textwrap\n\n\ndef wrap_content_generator(content: str, width=80):\n    \"\"\"\n    Wrap the text content to the specified maximum width and generate these lines line by line\n\n    Args:\n        content (str): The content to be wrapped and yielded line by line.\n        width (str): The maximum width of the lines, default is 80 characters.\n\n    Yields:\n        str: Each line of the content wrapped to the specified width.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestWrapContentGenerator(unittest.TestCase):\n\n    def test_empty_content(self):\n        \"\"\"Test with empty content.\"\"\"\n        result = list(wrap_content_generator(\"\"))\n        self.assertEqual(result, [])\n\n    def test_single_line_content(self):\n        \"\"\"Test with a single line of content within default width.\"\"\"\n        result = list(wrap_content_generator(\"Hello, world!\"))\n        self.assertEqual(result, [\"Hello, world!\"])\n\n    def test_multi_line_content(self):\n        \"\"\"Test with multiple lines of content each fitting within default width.\"\"\"\n        content = \"Hello\\nWorld\\nPython\"\n        result = list(wrap_content_generator(content))\n        self.assertEqual(result, [\"Hello\", \"World\", \"Python\"])\n\n    def test_long_line(self):\n        \"\"\"Test with a single long line that exceeds the default width.\"\"\"\n        content = \"This is a very long line that should definitely be wrapped around the default width of 80 characters.\"\n        result = list(wrap_content_generator(content))\n        self.assertTrue(len(max(result, key=len)) <= 80)\n\n    def test_custom_width(self):\n        \"\"\"Test with a custom width.\"\"\"\n        content = \"This is a test for custom width setting.\"\n        result = list(wrap_content_generator(content, width=10))\n        self.assertTrue(all(len(line) <= 10 for line in result))\n\n    def test_only_whitespaces(self):\n        \"\"\"Test content that contains only whitespace characters.\"\"\"\n        result = list(wrap_content_generator(\"     \"))\n        self.assertEqual(result, [\"\\n\"])", "prompt": "please write a python function , the function signature as below import textwrap\n\n\ndef wrap_content_generator(content: str, width=80):\n    \"\"\"\n    Wrap the text content to the specified maximum width and generate these lines line by line\n\n    Args:\n        content (str): The content to be wrapped and yielded line by line.\n        width (str): The maximum width of the lines, default is 80 characters.\n\n    Yields:\n        str: Each line of the content wrapped to the specified width.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Wraps the text content to the specified maximum width and generates lines one by one.\n *\n * @param content The content to be wrapped and yielded line by line.\n * @param width The maximum width of the lines. The default is 80 characters.\n *\n * @return Each line of the content wrapped to the specified width.\n */\nstd::string wrapText(const std::string &content, int width = 80);\n", "test_code": "TEST_CASE(\"TestWrapContentGenerator\", \"[wrap_content_generator]\") {\n    SECTION(\"test_empty_content\") {\n        std::vector<std::string> result;\n        wrap_content_generator(\"\", 80, [&result](const std::string &line) {\n            result.push_back(line);\n        });\n        REQUIRE(result == std::vector<std::string>({\"\\n\"}));\n    }\n\n    SECTION(\"test_single_line_content\") {\n        std::vector<std::string> result;\n        wrap_content_generator(\"Hello, world!\", 80, [&result](const std::string &line) {\n            result.push_back(line);\n        });\n        REQUIRE(result == std::vector<std::string>({\"Hello, world!\"}));\n    }\n\n    SECTION(\"test_multi_line_content\") {\n        std::vector<std::string> result;\n        std::string content = \"Hello\\nWorld\\nPython\";\n        wrap_content_generator(content, 80, [&result](const std::string &line) {\n            result.push_back(line);\n        });\n        REQUIRE(result == std::vector<std::string>({\"Hello\", \"World\", \"Python\"}));\n    }\n\n    SECTION(\"test_long_line\") {\n        std::vector<std::string> result;\n        std::string content = \"This is a very long line that should definitely be wrapped around the default width of 80 characters.\";\n        wrap_content_generator(content, 80, [&result](const std::string &line) {\n            result.push_back(line);\n        });\n        REQUIRE(std::all_of(result.begin(), result.end(), [](const std::string &line) {\n            return line.length() <= 80;\n        }));\n    }\n\n    SECTION(\"test_custom_width\") {\n        std::vector<std::string> result;\n        std::string content = \"This is a test for custom width setting.\";\n        wrap_content_generator(content, 10, [&result](const std::string &line) {\n            result.push_back(line);\n        });\n        REQUIRE(std::all_of(result.begin(), result.end(), [](const std::string &line) {\n            return line.length() <= 10;\n        }));\n    }\n\n    SECTION(\"test_only_whitespaces\") {\n        std::vector<std::string> result;\n        wrap_content_generator(\"     \", 80, [&result](const std::string &line) {\n            result.push_back(line);\n        });\n        REQUIRE(result == std::vector<std::string>({\"\\n\"}));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Wraps the text content to the specified maximum width and generates lines one by one.\n *\n * @param content The content to be wrapped and yielded line by line.\n * @param width The maximum width of the lines. The default is 80 characters.\n *\n * @return Each line of the content wrapped to the specified width.\n */\nstd::string wrapText(const std::string &content, int width = 80);\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Wrap the text content to the specified maximum width and return a list of wrapped lines.\n *\n * @param content The content to be wrapped and returned line by line.\n * @param width The maximum width of the lines, default is 80 characters.\n * @return A List containing each line of the content wrapped to the specified width.\n */\npublic static List<String> wrapContentGenerator(String content, int width) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testEmptyContent() {\n        List<String> result = wrapContentGenerator(\"\", 80);\n        assertEquals(result, List.of());\n    }\n\n    @Test\n    public void testSingleLineContent() {\n        List<String> result = wrapContentGenerator(\"Hello, world!\", 80);\n        assertEquals(result, List.of(\"Hello, world!\"));\n    }\n\n    @Test\n    public void testMultiLineContent() {\n        String content = \"Hello\\nWorld\\nPython\";\n        List<String> result = wrapContentGenerator(content, 80);\n        assertEquals(result, List.of(\"Hello\", \"World\", \"Python\"));\n    }\n\n    @Test\n    public void testLongLine() {\n        String content = \"This is a very long line that should definitely be wrapped around the default width of 80 characters.\";\n        List<String> result = wrapContentGenerator(content, 80);\n        assertTrue(result.stream().allMatch(line -> line.length() <= 80));\n    }\n\n    @Test\n    public void testCustomWidth() {\n        String content = \"This is a test for custom width setting.\";\n        List<String> result = wrapContentGenerator(content, 10);\n        assertTrue(result.stream().allMatch(line -> line.length() <= 10));\n    }\n\n    @Test\n    public void testOnlyWhitespaces() {\n        List<String> result = wrapContentGenerator(\"     \", 80);\n        assertEquals(result, List.of(\"\\n\"));\n    }\n\n    // Utility method to simulate the Python function\n    private List<String> wrapContentGenerator(String content, int width) {\n        return Answer.wrapContentGenerator(content, width);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Wrap the text content to the specified maximum width and return a list of wrapped lines.\n *\n * @param content The content to be wrapped and returned line by line.\n * @param width The maximum width of the lines, default is 80 characters.\n * @return A List containing each line of the content wrapped to the specified width.\n */\npublic static List<String> wrapContentGenerator(String content, int width) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 494, "code_type": "method", "original_language": "python", "file_path": "experiments\\86f0146b22d18c19be3d7318ee367f5fef4eb366\\mlx\\lora\\lib\\prepare_training_data.py", "question_type": "Data processing and transformation", "summary": "Cleans the input dictionary by removing keys with invalid values.Valid values are non-NaN, non-None, and non-whitespace strings.", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef clean_dictionary(input_dict:Dict) -> Dict:\n    \"\"\"\n    Cleans the input dictionary by removing keys with invalid values.Valid values are non-NaN, non-None, and non-whitespace strings.\n\n    Args:\n        input_dict (Dict): A dictionary to be cleaned.\n\n    Returns:\n        Dict: A new dictionary containing only valid values.\n    \"\"\"", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestCleanDictionary(unittest.TestCase):\n\n    def test_valid_strings(self):\n        \"\"\" Test a dictionary with valid strings. \"\"\"\n        input_dict = {\n            'key1': 'valid string',\n            'key2': 'another valid string'\n        }\n        expected_output = {\n            'key1': 'valid string',\n            'key2': 'another valid string'\n        }\n        self.assertEqual(clean_dictionary(input_dict), expected_output)\n\n    def test_none_and(self):\n        \"\"\" Test a dictionary with None and NaN values. \"\"\"\n        input_dict = {\n            'key1': None,\n            'key3': 'valid string'\n        }\n        expected_output = {\n            'key3': 'valid string'\n        }\n        self.assertEqual(clean_dictionary(input_dict), expected_output)\n\n    def test_whitespace_strings(self):\n        \"\"\" Test a dictionary with whitespace strings. \"\"\"\n        input_dict = {\n            'key1': '   ',\n            'key2': '',\n            'key3': 'valid'\n        }\n        expected_output = {\n            'key3': 'valid'\n        }\n        self.assertEqual(clean_dictionary(input_dict), expected_output)\n\n    def test_empty_dictionary(self):\n        \"\"\" Test an empty dictionary. \"\"\"\n        input_dict = {}\n        expected_output = {}\n        self.assertEqual(clean_dictionary(input_dict), expected_output)\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef clean_dictionary(input_dict:Dict) -> Dict:\n    \"\"\"\n    Cleans the input dictionary by removing keys with invalid values.Valid values are non-NaN, non-None, and non-whitespace strings.\n\n    Args:\n        input_dict (Dict): A dictionary to be cleaned.\n\n    Returns:\n        Dict: A new dictionary containing only valid values.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Cleans the input dictionary by removing keys with invalid values.\n * Valid values are non-NaN, non-nullptr, and non-whitespace strings.\n *\n * @param input_dict A map to be cleaned.\n * @return A new map containing only valid values.\n */\nstd::map<std::string, std::string> clean_dictionary(const std::map<std::string, std::string>& input_dict) {\n\n}", "test_code": "#include <catch2/catch_test_macros.hpp>\n#include <map>\n#include <string>\n#include <cctype>\n\nTEST_CASE(\"Test clean_dictionary function\", \"[clean_dictionary]\") {\n    SECTION(\"Test a dictionary with valid strings\") {\n        std::map<std::string, std::string> input_dict = {\n            {\"key1\", \"valid string\"},\n            {\"key2\", \"another valid string\"}\n        };\n        std::map<std::string, std::string> expected_output = {\n            {\"key1\", \"valid string\"},\n            {\"key2\", \"another valid string\"}\n        };\n        REQUIRE(clean_dictionary(input_dict) == expected_output);\n    }\n\n    SECTION(\"Test a dictionary with None and NaN values\") {\n        std::map<std::string, std::string> input_dict = {\n            {\"key1\", \"\"},\n            {\"key3\", \"valid string\"}\n        };\n        std::map<std::string, std::string> expected_output = {\n            {\"key3\", \"valid string\"}\n        };\n        REQUIRE(clean_dictionary(input_dict) == expected_output);\n    }\n\n    SECTION(\"Test a dictionary with whitespace strings\") {\n        std::map<std::string, std::string> input_dict = {\n            {\"key1\", \"   \"},\n            {\"key2\", \"\"},\n            {\"key3\", \"valid\"}\n        };\n        std::map<std::string, std::string> expected_output = {\n            {\"key3\", \"valid\"}\n        };\n        REQUIRE(clean_dictionary(input_dict) == expected_output);\n    }\n\n    SECTION(\"Test an empty dictionary\") {\n        std::map<std::string, std::string> input_dict = {};\n        std::map<std::string, std::string> expected_output = {};\n        REQUIRE(clean_dictionary(input_dict) == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Cleans the input dictionary by removing keys with invalid values.\n * Valid values are non-NaN, non-nullptr, and non-whitespace strings.\n *\n * @param input_dict A map to be cleaned.\n * @return A new map containing only valid values.\n */\nstd::map<std::string, std::string> clean_dictionary(const std::map<std::string, std::string>& input_dict) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Cleans the input map by removing entries with invalid values.\n * Valid values are non-null, non-blank strings, and numbers that are not NaN.\n *\n * @param inputMap A map to be cleaned.\n * @return A new map containing only valid values.\n */\npublic static Map<String, Object> cleanDictionary(Map<String, Object> inputMap) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Tester {\n\n    @Test\n    public void testValidStrings() {\n        \"\"\" Test a dictionary with valid strings. \"\"\"\n        Map<String, Object> inputDict = new HashMap<>();\n        inputDict.put(\"key1\", \"valid string\");\n        inputDict.put(\"key2\", \"another valid string\");\n\n        Map<String, Object> expectedOutput = new HashMap<>();\n        expectedOutput.put(\"key1\", \"valid string\");\n        expectedOutput.put(\"key2\", \"another valid string\");\n\n        assertEquals(expectedOutput, cleanDictionary(inputDict));\n    }\n\n    @Test\n    public void testNoneAndNaNValues() {\n        \"\"\" Test a dictionary with None and NaN values. \"\"\"\n        Map<String, Object> inputDict = new HashMap<>();\n        inputDict.put(\"key1\", null);\n        inputDict.put(\"key3\", \"valid string\");\n\n        Map<String, Object> expectedOutput = new HashMap<>();\n        expectedOutput.put(\"key3\", \"valid string\");\n\n        assertEquals(expectedOutput, cleanDictionary(inputDict));\n    }\n\n    @Test\n    public void testWhitespaceStrings() {\n        \"\"\" Test a dictionary with whitespace strings. \"\"\"\n        Map<String, Object> inputDict = new HashMap<>();\n        inputDict.put(\"key1\", \"   \");\n        inputDict.put(\"key2\", \"\");\n        inputDict.put(\"key3\", \"valid\");\n\n        Map<String, Object> expectedOutput = new HashMap<>();\n        expectedOutput.put(\"key3\", \"valid\");\n\n        assertEquals(expectedOutput, cleanDictionary(inputDict));\n    }\n\n    @Test\n    public void testEmptyDictionary() {\n        \"\"\" Test an empty dictionary. \"\"\"\n        Map<String, Object> inputDict = new HashMap<>();\n        Map<String, Object> expectedOutput = new HashMap<>();\n\n        assertEquals(expectedOutput, cleanDictionary(inputDict));\n    }\n\n    // Utility method to simulate the cleanDictionary function\n    private Map<String, Object> cleanDictionary(Map<String, Object> inputDict) {\n        Map<String, Object> cleanedMap = new HashMap<>();\n\n        for (Map.Entry<String, Object> entry : inputDict.entrySet()) {\n            Object value = entry.getValue();\n\n            // Check if the value is not null and not a blank string\n            if (value instanceof String && !((String) value).trim().isEmpty()) {\n                // Check if value is a number (Integer or Double) and is not NaN\n                if (!(value instanceof Double && ((Double) value).isNaN())) {\n                    cleanedMap.put(entry.getKey(), value);\n                }\n            }\n        }\n\n        return cleanedMap;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Cleans the input map by removing entries with invalid values.\n * Valid values are non-null, non-blank strings, and numbers that are not NaN.\n *\n * @param inputMap A map to be cleaned.\n * @return A new map containing only valid values.\n */\npublic static Map<String, Object> cleanDictionary(Map<String, Object> inputMap) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 495, "code_type": "method", "original_language": "python", "file_path": "experiments\\86f0146b22d18c19be3d7318ee367f5fef4eb366\\mlx\\lora\\lib\\prepare_training_data.py", "question_type": "Data processing and transformation", "summary": "    Filters website content to include lines containing any of the specified keywords as whole words,\n    along with a specified number of lines before and after for context. This version uses regular expressions\n    to ensure exact, whole word matching and respects case sensitivity.", "language_version_list": {"python": {"code_signature": "import re\nfrom typing import List\n\n\ndef filter_content_with_context(\n        content: str,\n        keywords: List[str],\n        lines_before: int = 1,\n        lines_after: int = 1\n) -> str:\n    \"\"\"\n    Filters website content to include lines containing any of the specified keywords as whole words,\n    along with a specified number of lines before and after for context. This version uses regular expressions\n    to ensure exact, whole word matching and respects case sensitivity.\n\n    Args:\n        content (str): The full text content of the website.\n        keywords (List[str]): A list of strings to search for within the content.\n        lines_before (int): Number of lines to include before a matching line.\n        lines_after (int): Number of lines to include after a matching line.\n\n    Returns:\n        str: A string containing the filtered content with additional context.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFilterContentWithContext(unittest.TestCase):\n\n    def test_single_keyword_match(self):\n        \"\"\"Test a single keyword match with context lines.\"\"\"\n        content = \"\"\"Line one.\n        This line contains a keyword.\n        Line three.\"\"\"\n        keywords = [\"keyword\"]\n        expected_output = \"\"\"Line one.\n        This line contains a keyword.\n        Line three.\"\"\"\n        result = filter_content_with_context(content, keywords, lines_before=1, lines_after=1)\n        self.assertEqual(result.strip(), expected_output.strip(), \"Failed to filter content for a single keyword.\")\n\n\n    def test_no_keyword_match(self):\n        \"\"\"Test when no keywords match.\"\"\"\n        content = \"\"\"Line one.\n        Line two.\n        Line three.\"\"\"\n        keywords = [\"missing\"]\n        expected_output = \"\"\n        result = filter_content_with_context(content, keywords, lines_before=1, lines_after=1)\n        self.assertEqual(result.strip(), expected_output, \"Failed to return empty string for no matches.\")\n\n\n    def test_lines_before_and_after(self):\n        \"\"\"Test functionality with specified lines before and after.\"\"\"\n        content = \"\"\"Line one.\n        This line contains a keyword.\n        Line three.\n        Line four.\n        Line five.\"\"\"\n        keywords = [\"keyword\"]\n        expected_output = \"\"\"Line one.\n        This line contains a keyword.\n        Line three.\"\"\"\n        result = filter_content_with_context(content, keywords, lines_before=1, lines_after=1)\n        self.assertEqual(result.strip(), expected_output.strip(), \"Failed to correctly include context lines.\")\n", "prompt": "please write a python function , the function signature as below import re\nfrom typing import List\n\n\ndef filter_content_with_context(\n        content: str,\n        keywords: List[str],\n        lines_before: int = 1,\n        lines_after: int = 1\n) -> str:\n    \"\"\"\n    Filters website content to include lines containing any of the specified keywords as whole words,\n    along with a specified number of lines before and after for context. This version uses regular expressions\n    to ensure exact, whole word matching and respects case sensitivity.\n\n    Args:\n        content (str): The full text content of the website.\n        keywords (List[str]): A list of strings to search for within the content.\n        lines_before (int): Number of lines to include before a matching line.\n        lines_after (int): Number of lines to include after a matching line.\n\n    Returns:\n        str: A string containing the filtered content with additional context.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Filters website content to include lines containing any of the specified keywords as whole words,\n * along with a specified number of lines before and after for context. This version uses regular expressions\n * to ensure exact, whole word matching and respects case sensitivity.\n *\n * @param content The full text content of the website.\n * @param keywords A list of strings to search for within the content.\n * @param lines_before Number of lines to include before a matching line.\n * @param lines_after Number of lines to include after a matching line.\n *\n * @return A string containing the filtered content with additional context.\n */\nstd::string filter_content_with_context(\n    const std::string& content,\n    const std::vector<std::string>& keywords,\n    int lines_before = 1,\n    int lines_after = 1\n) {\n\n}", "test_code": "TEST_CASE(\"TestFilterContentWithContext\", \"[filter_content_with_context]\") {\n    SECTION(\"test_single_keyword_match\") {\n        std::string content = R\"(Line one.\n        This line contains a keyword.\n        Line three.)\";\n        std::vector<std::string> keywords = {\"keyword\"};\n        std::string expected_output = R\"(Line one.\n        This line contains a keyword.\n        Line three.)\";\n        std::string result = filter_content_with_context(content, keywords, 1, 1);\n        REQUIRE(result == expected_output);\n    }\n\n    SECTION(\"test_no_keyword_match\") {\n        std::string content = R\"(Line one.\n        Line two.\n        Line three.)\";\n        std::vector<std::string> keywords = {\"missing\"};\n        std::string expected_output = \"\";\n        std::string result = filter_content_with_context(content, keywords, 1, 1);\n        REQUIRE(result == expected_output);\n    }\n\n    SECTION(\"test_lines_before_and_after\") {\n        std::string content = R\"(Line one.\n        This line contains a keyword.\n        Line three.\n        Line four.\n        Line five.)\";\n        std::vector<std::string> keywords = {\"keyword\"};\n        std::string expected_output = R\"(Line one.\n        This line contains a keyword.\n        Line three.)\";\n        std::string result = filter_content_with_context(content, keywords, 1, 1);\n        REQUIRE(result == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Filters website content to include lines containing any of the specified keywords as whole words,\n * along with a specified number of lines before and after for context. This version uses regular expressions\n * to ensure exact, whole word matching and respects case sensitivity.\n *\n * @param content The full text content of the website.\n * @param keywords A list of strings to search for within the content.\n * @param lines_before Number of lines to include before a matching line.\n * @param lines_after Number of lines to include after a matching line.\n *\n * @return A string containing the filtered content with additional context.\n */\nstd::string filter_content_with_context(\n    const std::string& content,\n    const std::vector<std::string>& keywords,\n    int lines_before = 1,\n    int lines_after = 1\n) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Filters website content to include lines containing any of the specified keywords as whole words,\n * along with a specified number of lines before and after for context. This version uses regular expressions\n * to ensure exact, whole word matching and respects case sensitivity.\n *\n * @param content       The full text content of the website.\n * @param keywords      A list of strings to search for within the content.\n * @param linesBefore   Number of lines to include before a matching line.\n * @param linesAfter    Number of lines to include after a matching line.\n * @return              A string containing the filtered content with additional context.\n */\npublic static String filterContentWithContext(String content, List<String> keywords, int linesBefore, int linesAfter) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testSingleKeywordMatch() {\n        String content = \"Line one.\\n\" +\n                         \"This line contains a keyword.\\n\" +\n                         \"Line three.\";\n        List<String> keywords = Arrays.asList(\"keyword\");\n        String expectedOutput = \"Line one.\\n\" +\n                                \"This line contains a keyword.\\n\" +\n                                \"Line three.\";\n        String result = Answer.filterContentWithContext(content, keywords, 1, 1);\n        assertEquals(expectedOutput.strip(), result.strip(), \"Failed to filter content for a single keyword.\");\n    }\n\n    @Test\n    public void testNoKeywordMatch() {\n        String content = \"Line one.\\n\" +\n                         \"Line two.\\n\" +\n                         \"Line three.\";\n        List<String> keywords = Arrays.asList(\"missing\");\n        String expectedOutput = \"\";\n        String result = Answer.filterContentWithContext(content, keywords, 1, 1);\n        assertEquals(expectedOutput.strip(), result.strip(), \"Failed to return empty string for no matches.\");\n    }\n\n    @Test\n    public void testLinesBeforeAndAfter() {\n        String content = \"Line one.\\n\" +\n                         \"This line contains a keyword.\\n\" +\n                         \"Line three.\\n\" +\n                         \"Line four.\\n\" +\n                         \"Line five.\";\n        List<String> keywords = Arrays.asList(\"keyword\");\n        String expectedOutput = \"Line one.\\n\" +\n                                \"This line contains a keyword.\\n\" +\n                                \"Line three.\";\n        String result = Answer.filterContentWithContext(content, keywords, 1, 1);\n        assertEquals(expectedOutput.strip(), result.strip(), \"Failed to correctly include context lines.\");\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Filters website content to include lines containing any of the specified keywords as whole words,\n * along with a specified number of lines before and after for context. This version uses regular expressions\n * to ensure exact, whole word matching and respects case sensitivity.\n *\n * @param content       The full text content of the website.\n * @param keywords      A list of strings to search for within the content.\n * @param linesBefore   Number of lines to include before a matching line.\n * @param linesAfter    Number of lines to include after a matching line.\n * @return              A string containing the filtered content with additional context.\n */\npublic static String filterContentWithContext(String content, List<String> keywords, int linesBefore, int linesAfter) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 496, "code_type": "method", "original_language": "python", "file_path": "modeling-info-spread\\f138143cdc0057ca1a2ec2be8ef4d0babb4bf2f8\\src\\models\\channel.py\n", "question_type": "Algorithm and data structure", "summary": "Generates the ith row of Pascal's Triangle.", "language_version_list": {"python": {"code_signature": "import math\nfrom typing import List\n\n\ndef pascal_triangle_row(i: int) -> List:\n    \"\"\"\n    Generates the ith row of Pascal's Triangle.\n\n    Args:\n        i (int): Row index (0-indexed)\n\n    Returns:\n        List: A list representing the ith row of Pascal's Triangle\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestPascalTriangleRow(unittest.TestCase):\n\n    def test_row_0(self):\n        \"\"\" Test the 0th row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(0), [1])\n\n    def test_row_1(self):\n        \"\"\" Test the 1st row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(1), [1, 1])\n\n    def test_row_2(self):\n        \"\"\" Test the 2nd row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(2), [1, 2, 1])\n\n    def test_row_3(self):\n        \"\"\" Test the 3rd row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(3), [1, 3, 3, 1])\n\n    def test_row_4(self):\n        \"\"\" Test the 4th row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(4), [1, 4, 6, 4, 1])\n\n    def test_row_5(self):\n        \"\"\" Test the 5th row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(5), [1, 5, 10, 10, 5, 1])\n", "prompt": "please write a python function , the function signature as below import math\nfrom typing import List\n\n\ndef pascal_triangle_row(i: int) -> List:\n    \"\"\"\n    Generates the ith row of Pascal's Triangle.\n\n    Args:\n        i (int): Row index (0-indexed)\n\n    Returns:\n        List: A list representing the ith row of Pascal's Triangle\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Generates the ith row of Pascal's Triangle.\n *\n * @param i Row index (0-indexed)\n * @return A vector representing the ith row of Pascal's Triangle\n */\nstd::vector<long long> pascal_triangle_row(int i) {}", "test_code": "TEST_CASE(\"Test Pascal's Triangle Row\") {\n    SECTION(\"Test the 0th row of Pascal's Triangle\") {\n        REQUIRE(pascal_triangle_row(0) == std::vector<long long>({1}));\n    }\n\n    SECTION(\"Test the 1st row of Pascal's Triangle\") {\n        REQUIRE(pascal_triangle_row(1) == std::vector<long long>({1, 1}));\n    }\n\n    SECTION(\"Test the 2nd row of Pascal's Triangle\") {\n        REQUIRE(pascal_triangle_row(2) == std::vector<long long>({1, 2, 1}));\n    }\n\n    SECTION(\"Test the 3rd row of Pascal's Triangle\") {\n        REQUIRE(pascal_triangle_row(3) == std::vector<long long>({1, 3, 3, 1}));\n    }\n\n    SECTION(\"Test the 4th row of Pascal's Triangle\") {\n        REQUIRE(pascal_triangle_row(4) == std::vector<long long>({1, 4, 6, 4, 1}));\n    }\n\n    SECTION(\"Test the 5th row of Pascal's Triangle\") {\n        REQUIRE(pascal_triangle_row(5) == std::vector<long long>({1, 5, 10, 10, 5, 1}));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Generates the ith row of Pascal's Triangle.\n *\n * @param i Row index (0-indexed)\n * @return A vector representing the ith row of Pascal's Triangle\n */\nstd::vector<long long> pascal_triangle_row(int i) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Generates the ith row of Pascal's Triangle.\n *\n * @param i the row index (0-indexed)\n * @return a List representing the ith row of Pascal's Triangle\n */\npublic static List<Long> pascalTriangleRow(int i) {\n\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Test class for verifying the correctness of the Pascal's Triangle row generation.\n */\npublic class Tester {\n\n    /**\n     * Tests the 0th row of Pascal's Triangle.\n     */\n    @Test\n    public void testRow0() {\n        List<Long> expected = Arrays.asList(1L);\n        assertEquals(expected, pascalTriangleRow(0));\n    }\n\n    /**\n     * Tests the 1st row of Pascal's Triangle.\n     */\n    @Test\n    public void testRow1() {\n        List<Long> expected = Arrays.asList(1L, 1L);\n        assertEquals(expected, pascalTriangleRow(1));\n    }\n\n    /**\n     * Tests the 2nd row of Pascal's Triangle.\n     */\n    @Test\n    public void testRow2() {\n        List<Long> expected = Arrays.asList(1L, 2L, 1L);\n        assertEquals(expected, pascalTriangleRow(2));\n    }\n\n    /**\n     * Tests the 3rd row of Pascal's Triangle.\n     */\n    @Test\n    public void testRow3() {\n        List<Long> expected = Arrays.asList(1L, 3L, 3L, 1L);\n        assertEquals(expected, pascalTriangleRow(3));\n    }\n\n    /**\n     * Tests the 4th row of Pascal's Triangle.\n     */\n    @Test\n    public void testRow4() {\n        List<Long> expected = Arrays.asList(1L, 4L, 6L, 4L, 1L);\n        assertEquals(expected, pascalTriangleRow(4));\n    }\n\n    /**\n     * Tests the 5th row of Pascal's Triangle.\n     */\n    @Test\n    public void testRow5() {\n        List<Long> expected = Arrays.asList(1L, 5L, 10L, 10L, 5L, 1L);\n        assertEquals(expected, pascalTriangleRow(5));\n    }\n\n    /**\n     * Generates the ith row of Pascal's Triangle.\n     *\n     * @param i the row index (0-indexed)\n     * @return a List representing the ith row of Pascal's Triangle\n     */\n    private List<Long> pascalTriangleRow(int i) {\n        List<Long> row = new ArrayList<>();\n        for (int k = 0; k <= i; k++) {\n            row.add(combination(i, k));\n        }\n        return row;\n    }\n\n    /**\n     * Calculates the combination (n choose k).\n     *\n     * @param n the total number of items\n     * @param k the number of items to choose\n     * @return the combination value\n     */\n    private static long combination(int n, int k) {\n        long result = 1;\n        if (k > n - k) {\n            k = n - k;\n        }\n        for (int i = 0; i < k; ++i) {\n            result *= (n - i);\n            result /= (i + 1);\n        }\n        return result;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Generates the ith row of Pascal's Triangle.\n *\n * @param i the row index (0-indexed)\n * @return a List representing the ith row of Pascal's Triangle\n */\npublic static List<Long> pascalTriangleRow(int i) {\n\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 498, "code_type": "method", "original_language": "python", "file_path": "kaggle\\7365ae9fc3caf06b7220ceca94ab0efeb3a9d77f\\classify_leaves\\utils\\find_duplicates.py\n", "question_type": "Algorithm and data structure", "summary": "Computes and returns the MD5 hash of the string\n", "language_version_list": {"python": {"code_signature": "import hashlib\n\n\ndef compute_md5(input_string: str) -> str:\n    \"\"\"\n    Computes and returns the MD5 hash of the input string.\n\n    Args:\n        input_string (str): The string to be hashed\n\n    Returns:\n        str: he MD5 hash of the input string in hexadecimal format\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestComputeMD5(unittest.TestCase):\n\n    def test_empty_string(self):\n        \"\"\" Test the MD5 hash of an empty string. \"\"\"\n        self.assertEqual(compute_md5(''), 'd41d8cd98f00b204e9800998ecf8427e')\n\n    def test_simple_string(self):\n        \"\"\" Test the MD5 hash of a simple string. \"\"\"\n        self.assertEqual(compute_md5('Hello, World!'), '65a8e27d8879283831b664bd8b7f0ad4')\n\n    def test_numeric_string(self):\n        \"\"\" Test the MD5 hash of a numeric string. \"\"\"\n        self.assertEqual(compute_md5('123456'), 'e10adc3949ba59abbe56e057f20f883e')\n\n    def test_special_characters(self):\n        \"\"\" Test the MD5 hash of a string with special characters. \"\"\"\n        self.assertEqual(compute_md5('!@#$%^&*()'), '05b28d17a7b6e7024b6e5d8cc43a8bf7')\n\n    def test_long_string(self):\n        \"\"\" Test the MD5 hash of a long string. \"\"\"\n        long_string = 'a' * 1000  # A string of 1000 'a' characters\n        expected_hash = 'cabe45dcc9ae5b66ba86600cca6b8ba8'  # MD5 of 'aaaa....' (1000 'a's)\n        self.assertEqual(compute_md5(long_string), expected_hash)", "prompt": "please write a python function , the function signature as below import hashlib\n\n\ndef compute_md5(input_string: str) -> str:\n    \"\"\"\n    Computes and returns the MD5 hash of the input string.\n\n    Args:\n        input_string (str): The string to be hashed\n\n    Returns:\n        str: he MD5 hash of the input string in hexadecimal format\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Computes and returns the MD5 hash of the input string.\n *\n * @param input_string The string to be hashed\n * @return The MD5 hash of the input string in hexadecimal format\n */\nstd::string compute_md5(const std::string& input_string) {}", "test_code": "TEST_CASE(\"Test Compute MD5\") {\n    SECTION(\"Test the MD5 hash of an empty string\") {\n        REQUIRE(compute_md5(\"\") == \"d41d8cd98f00b204e9800998ecf8427e\");\n    }\n\n    SECTION(\"Test the MD5 hash of a simple string\") {\n        REQUIRE(compute_md5(\"Hello, World!\") == \"65a8e27d8879283831b664bd8b7f0ad4\");\n    }\n\n    SECTION(\"Test the MD5 hash of a numeric string\") {\n        REQUIRE(compute_md5(\"123456\") == \"e10adc3949ba59abbe56e057f20f883e\");\n    }\n\n    SECTION(\"Test the MD5 hash of a string with special characters\") {\n        REQUIRE(compute_md5(\"!@#$%^&*()\") == \"05b28d17a7b6e7024b6e5d8cc43a8bf7\");\n    }\n\n    SECTION(\"Test the MD5 hash of a long string\") {\n        std::string long_string(1000, 'a');\n        std::string expected_hash = \"cabe45dcc9ae5b66ba86600cca6b8ba8\";\n        REQUIRE(compute_md5(long_string) == expected_hash);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Computes and returns the MD5 hash of the input string.\n *\n * @param input_string The string to be hashed\n * @return The MD5 hash of the input string in hexadecimal format\n */\nstd::string compute_md5(const std::string& input_string) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Computes and returns the MD5 hash of the input string.\n *\n * @param inputString The string to be hashed\n * @return The MD5 hash of the input string in hexadecimal format\n */\npublic static String computeMD5(String inputString) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testEmptyString() {\n        // Test the MD5 hash of an empty string.\n        assertEquals(\"d41d8cd98f00b204e9800998ecf8427e\", computeMD5(\"\"));\n    }\n\n    @Test\n    public void testSimpleString() {\n        // Test the MD5 hash of a simple string.\n        assertEquals(\"65a8e27d8879283831b664bd8b7f0ad4\", computeMD5(\"Hello, World!\"));\n    }\n\n    @Test\n    public void testNumericString() {\n        // Test the MD5 hash of a numeric string.\n        assertEquals(\"e10adc3949ba59abbe56e057f20f883e\", computeMD5(\"123456\"));\n    }\n\n    @Test\n    public void testSpecialCharacters() {\n        // Test the MD5 hash of a string with special characters.\n        assertEquals(\"05b28d17a7b6e7024b6e5d8cc43a8bf7\", computeMD5(\"!@#$%^&*()\"));\n    }\n\n    @Test\n    public void testLongString() {\n        // Test the MD5 hash of a long string.\n        String longString = \"a\".repeat(1000);  // A string of 1000 'a' characters\n        String expectedHash = \"cabe45dcc9ae5b66ba86600cca6b8ba8\";  // MD5 of 'aaaa....' (1000 'a's)\n        assertEquals(expectedHash, computeMD5(longString));\n    }\n\n    // Method to compute the MD5 hash of a string\n    private String computeMD5(String inputString) {\n        try {\n            // Create an MD5 MessageDigest instance\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n\n            // Update the digest using the specified array of bytes\n            md.update(inputString.getBytes());\n\n            // Complete the hash computation\n            byte[] digest = md.digest();\n\n            // Convert the byte array to a hex string\n            StringBuilder hexString = new StringBuilder();\n            for (byte b : digest) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) hexString.append('0');\n                hexString.append(hex);\n            }\n\n            // Return the hexadecimal representation of the hash\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"MD5 algorithm not found\", e);\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Computes and returns the MD5 hash of the input string.\n *\n * @param inputString The string to be hashed\n * @return The MD5 hash of the input string in hexadecimal format\n */\npublic static String computeMD5(String inputString) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 499, "code_type": "method", "original_language": "python", "file_path": "NumbER\\fc0df31b5fadf058e48afa3ba5cedd7a50595ff0\\NumbER\\dataset_cleaning\\baby_products\\clean.py\n", "question_type": "Data processing and transformation", "summary": "Extracts a numeric value from the input string based on the given regex pattern.", "language_version_list": {"python": {"code_signature": "import re\nfrom typing import Union\n\n\ndef clean_pattern(x: str, pattern: str) -> Union[str,float]:\n    \"\"\"\n    Extracts a numeric value from the input string based on the given regex pattern.\n\n    Args:\n        x (str or any): The input from which to extract the value. It will be converted to a string.\n        pattern (str): The regular expression pattern to use for matching.\n\n    Returns:\n        Union[str,float]: The extracted weight value if a match is found, otherwise an empty string.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestCleanPattern(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Sets up a common regex pattern for testing.\"\"\"\n        self.pattern = r'(\\d+\\.?\\d*) kg'  # Regex pattern to match weight in kg\n\n    def test_valid_integer_weight(self):\n        \"\"\"Test case for valid integer weight.\"\"\"\n        input_string = \"The weight is 25 kg\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, 25.0)\n\n    def test_valid_float_weight(self):\n        \"\"\"Test case for valid float weight.\"\"\"\n        input_string = \"Weight measured at 15.75 kg\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, 15.75)\n\n    def test_no_weight_found(self):\n        \"\"\"Test case where no weight is present.\"\"\"\n        input_string = \"No weight provided.\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, '')\n\n    def test_invalid_float_conversion(self):\n        \"\"\"Test case for non-numeric weight.\"\"\"\n        input_string = \"The weight is thirty kg\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, '')\n\n    def test_weight_with_extra_text(self):\n        \"\"\"Test case for weight with additional text.\"\"\"\n        input_string = \"The total weight is 45.3 kg as per the last measurement.\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, 45.3)\n", "prompt": "please write a python function , the function signature as below import re\nfrom typing import Union\n\n\ndef clean_pattern(x: str, pattern: str) -> Union[str,float]:\n    \"\"\"\n    Extracts a numeric value from the input string based on the given regex pattern.\n\n    Args:\n        x (str or any): The input from which to extract the value. It will be converted to a string.\n        pattern (str): The regular expression pattern to use for matching.\n\n    Returns:\n        Union[str,float]: The extracted weight value if a match is found, otherwise an empty string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extracts a numeric value from the input string based on the given regex pattern.\n *\n * @param x The input from which to extract the value. It will be converted to a string.\n * @param pattern The regular expression pattern to use for matching.\n * @return The extracted weight value if a match is found, otherwise an empty string.\n */\nstd::string clean_pattern(const std::string& x, const std::string& pattern) {}", "test_code": "TEST_CASE(\"TestCleanPattern\", \"[clean_pattern]\") {\n    const std::string pattern = R\"((\\d+\\.?\\d*) kg)\";  // Regex pattern to match weight in kg\n\n    SECTION(\"test_valid_integer_weight\") {\n        std::string input_string = \"The weight is 25 kg\";\n        std::string result = clean_pattern(input_string, pattern);\n        REQUIRE(result == \"25.0\");\n    }\n\n    SECTION(\"test_valid_float_weight\") {\n        std::string input_string = \"Weight measured at 15.75 kg\";\n        std::string result = clean_pattern(input_string, pattern);\n        REQUIRE(result == \"15.75\");\n    }\n\n    SECTION(\"test_no_weight_found\") {\n        std::string input_string = \"No weight provided.\";\n        std::string result = clean_pattern(input_string, pattern);\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"test_invalid_float_conversion\") {\n        std::string input_string = \"The weight is thirty kg\";\n        std::string result = clean_pattern(input_string, pattern);\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"test_weight_with_extra_text\") {\n        std::string input_string = \"The total weight is 45.3 kg as per the last measurement.\";\n        std::string result = clean_pattern(input_string, pattern);\n        REQUIRE(result == \"45.3\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts a numeric value from the input string based on the given regex pattern.\n *\n * @param x The input from which to extract the value. It will be converted to a string.\n * @param pattern The regular expression pattern to use for matching.\n * @return The extracted weight value if a match is found, otherwise an empty string.\n */\nstd::string clean_pattern(const std::string& x, const std::string& pattern) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Extracts a numeric value from the input string based on the given regex pattern.\n *\n * @param x       The input from which to extract the value. It will be converted to a string.\n * @param pattern The regular expression pattern to use for matching.\n * @return The extracted weight value as a float if a match is found, otherwise an empty string.\n */\npublic static Object cleanPattern(Object x, String pattern) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for the cleanPattern method.\n */\npublic class Tester {\n\n    private String pattern;\n\n    @Before\n    public void setUp() {\n        // Set up a common regex pattern for testing\n        pattern = \"(\\\\d+\\\\.?\\\\d*) kg\";  // Regex pattern to match weight in kg\n    }\n\n    @Test\n    public void testValidIntegerWeight() {\n        // Test case for valid integer weight\n        String inputString = \"The weight is 25 kg\";\n        Object result = cleanPattern(inputString, pattern);\n        assertEquals(25.0f, result);\n    }\n\n    @Test\n    public void testValidFloatWeight() {\n        // Test case for valid float weight\n        String inputString = \"Weight measured at 15.75 kg\";\n        Object result = cleanPattern(inputString, pattern);\n        assertEquals(15.75f, result);\n    }\n\n    @Test\n    public void testNoWeightFound() {\n        // Test case where no weight is present\n        String inputString = \"No weight provided.\";\n        Object result = cleanPattern(inputString, pattern);\n        assertEquals(\"\", result);\n    }\n\n    @Test\n    public void testInvalidFloatConversion() {\n        // Test case for non-numeric weight\n        String inputString = \"The weight is thirty kg\";\n        Object result = cleanPattern(inputString, pattern);\n        assertEquals(\"\", result);\n    }\n\n    @Test\n    public void testWeightWithExtraText() {\n        // Test case for weight with additional text\n        String inputString = \"The total weight is 45.3 kg as per the last measurement.\";\n        Object result = cleanPattern(inputString, pattern);\n        assertEquals(45.3f, result);\n    }\n\n    // Method to be tested\n    private Object cleanPattern(Object x, String pattern) {\n        // Convert input to string\n        String input = x.toString();\n\n        // Compile the pattern\n        Pattern compiledPattern = Pattern.compile(pattern);\n        Matcher matcher = compiledPattern.matcher(input);\n\n        if (matcher.find()) {\n            // Extract the weight value from the first matching group\n            String weight = matcher.group(1);  // Can also use matcher.group(3) if needed\n\n            try {\n                // Convert the weight to a float and return it\n                float weightValue = Float.parseFloat(weight);\n                return weightValue;\n            } catch (NumberFormatException e) {\n                // Handle cases where conversion to float fails\n                System.out.println(\"Warning: Unable to convert '\" + weight + \"' to float.\");\n                return \"\";\n            }\n        } else {\n            return \"\";  // Return empty string if no match is found\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts a numeric value from the input string based on the given regex pattern.\n *\n * @param x       The input from which to extract the value. It will be converted to a string.\n * @param pattern The regular expression pattern to use for matching.\n * @return The extracted weight value as a float if a match is found, otherwise an empty string.\n */\npublic static Object cleanPattern(Object x, String pattern) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 500, "code_type": "method", "original_language": "python", "file_path": "NumbER\\fc0df31b5fadf058e48afa3ba5cedd7a50595ff0\\NumbER\\dataset_cleaning\\baby_products\\clean.py\n", "question_type": "Data processing and transformation", "summary": "Converts the string representation of a score to its decimal value\n", "language_version_list": {"python": {"code_signature": "def convert_score_to_decimal(score_str: str) -> float:\n    \"\"\"\n    Converts the string representation of a score to its decimal value.\n    For example:\n        input: 10/4\n        output: 2.5\n    Args:\n        score_str (str): The score as a string, can be a decimal or a fraction\n\n    Returns:\n        float: The decimal value of the score as a float, or None if the input is invalid\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestConvertScoreToDecimal(unittest.TestCase):\n\n    def test_decimal_score(self):\n        \"\"\" Test a simple decimal score. \"\"\"\n        self.assertEqual(convert_score_to_decimal(\"2.5\"), 2.5)\n\n    def test_fraction_score(self):\n        \"\"\" Test a fraction score. \"\"\"\n        self.assertEqual(convert_score_to_decimal(\"10/4\"), 2.5)\n\n    def test_integer_score(self):\n        \"\"\" Test an integer score represented as a string. \"\"\"\n        self.assertEqual(convert_score_to_decimal(\"5\"), 5.0)\n\n    def test_integer_divide_score(self):\n        self.assertEqual(convert_score_to_decimal(\"12/3\"), 4.0)", "prompt": "please write a python function , the function signature as below def convert_score_to_decimal(score_str: str) -> float:\n    \"\"\"\n    Converts the string representation of a score to its decimal value.\n    For example:\n        input: 10/4\n        output: 2.5\n    Args:\n        score_str (str): The score as a string, can be a decimal or a fraction\n\n    Returns:\n        float: The decimal value of the score as a float, or None if the input is invalid\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts the string representation of a score to its decimal value.\n * For example:\n *     input: 10/4\n *     output: 2.5\n *\n * @param score_str The score as a string, can be a decimal or a fraction\n * @return The decimal value of the score as a float, or std::nullopt if the input is invalid\n */\nstd::optional<float> convert_score_to_decimal(const std::string& score_str) {\n\n}", "test_code": "#include <catch2/catch_test_macros.hpp>\n#include <optional>\n#include <string>\n#include <sstream>\n#include <stdexcept>\n\n// Test cases using Catch2\nTEST_CASE(\"Test convert_score_to_decimal\") {\n    SECTION(\"Test a simple decimal score\") {\n        REQUIRE(convert_score_to_decimal(\"2.5\").value() == Approx(2.5f));\n    }\n\n    SECTION(\"Test a fraction score\") {\n        REQUIRE(convert_score_to_decimal(\"10/4\").value() == Approx(2.5f));\n    }\n\n    SECTION(\"Test an integer score represented as a string\") {\n        REQUIRE(convert_score_to_decimal(\"5\").value() == Approx(5.0f));\n    }\n\n    SECTION(\"Test an integer divide score\") {\n        REQUIRE(convert_score_to_decimal(\"12/3\").value() == Approx(4.0f));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts the string representation of a score to its decimal value.\n * For example:\n *     input: 10/4\n *     output: 2.5\n *\n * @param score_str The score as a string, can be a decimal or a fraction\n * @return The decimal value of the score as a float, or std::nullopt if the input is invalid\n */\nstd::optional<float> convert_score_to_decimal(const std::string& score_str) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts the string representation of a score to its decimal value.\n * For example:\n *     input: \"10/4\"\n *     output: 2.5\n *\n * @param scoreStr The score as a string, can be a decimal or a fraction\n * @return The decimal value of the score as a double, or null if the input is invalid\n */\npublic static Double convertScoreToDecimal(String scoreStr) {\n\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testDecimalScore() {\n        // Test a simple decimal score.\n        assertEquals(2.5, convertScoreToDecimal(\"2.5\"), 0.001);\n    }\n\n    @Test\n    public void testFractionScore() {\n        // Test a fraction score.\n        assertEquals(2.5, convertScoreToDecimal(\"10/4\"), 0.001);\n    }\n\n    @Test\n    public void testIntegerScore() {\n        // Test an integer score represented as a string.\n        assertEquals(5.0, convertScoreToDecimal(\"5\"), 0.001);\n    }\n\n    @Test\n    public void testIntegerDivideScore() {\n        // Test an integer division score.\n        assertEquals(4.0, convertScoreToDecimal(\"12/3\"), 0.001);\n    }\n\n    // Utility method to convert the score to decimal\n    private Double convertScoreToDecimal(String scoreStr) {\n        try {\n            // Check if the score is a fraction\n            if (scoreStr.contains(\"/\")) {\n                String[] parts = scoreStr.split(\"/\");\n                if (parts.length == 2) {\n                    double numerator = Double.parseDouble(parts[0]);\n                    double denominator = Double.parseDouble(parts[1]);\n                    return numerator / denominator;\n                } else {\n                    throw new IllegalArgumentException(\"Invalid fraction format\");\n                }\n            } else {\n                // Otherwise, treat it as a decimal\n                return Double.parseDouble(scoreStr);\n            }\n\n        } catch (NumberFormatException | ArithmeticException e) {\n            System.out.println(\"Error converting '\" + scoreStr + \"' to decimal: \" + e.getMessage());\n            return null;\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts the string representation of a score to its decimal value.\n * For example:\n *     input: \"10/4\"\n *     output: 2.5\n *\n * @param scoreStr The score as a string, can be a decimal or a fraction\n * @return The decimal value of the score as a double, or null if the input is invalid\n */\npublic static Double convertScoreToDecimal(String scoreStr) {\n\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 501, "code_type": "method", "original_language": "python", "file_path": "neurorient\\1d34765b7588e11c385433277e3b203df300b51c\\neurorient\\utils_config.py\n", "question_type": "Data processing and transformation", "summary": "Converts strings concatenated with _ to a short format. For example, converting the string f1_p1_g1_b1_c1 to \"fpgbc\"", "language_version_list": {"python": {"code_signature": "def convert_to_short_format(input_str) -> str:\n    \"\"\"\n    Converts a string concatenated with underscores to a short format.\n    For example:\n        input: f1_p1_g1_b1_c1\n        output: fpgbc\n    Args:\n        input_str (str): The input string with segments separated by underscores.\n\n    Returns:\n        str: A short format string derived from the first characters of each segment.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestConvertToShortFormat(unittest.TestCase):\n\n    def test_basic_case(self):\n        \"\"\" Test a standard input with mixed characters. \"\"\"\n        self.assertEqual(convert_to_short_format(\"f1_p1_g1_b1_c1\"), \"fpgbc\")\n\n    def test_multiple_segments(self):\n        \"\"\" Test input with multiple segments. \"\"\"\n        self.assertEqual(convert_to_short_format(\"a2_b3_c4\"), \"abc\")\n\n    def test_non_alpha_numeric(self):\n        \"\"\" Test input with non-alphanumeric characters. \"\"\"\n        self.assertEqual(convert_to_short_format(\"hello_world_test\"), \"hwt\")\n\n    def test_single_segment(self):\n        \"\"\" Test a single segment input. \"\"\"\n        self.assertEqual(convert_to_short_format(\"single\"), \"s\")\n", "prompt": "please write a python function , the function signature as below def convert_to_short_format(input_str) -> str:\n    \"\"\"\n    Converts a string concatenated with underscores to a short format.\n    For example:\n        input: f1_p1_g1_b1_c1\n        output: fpgbc\n    Args:\n        input_str (str): The input string with segments separated by underscores.\n\n    Returns:\n        str: A short format string derived from the first characters of each segment.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a string concatenated with underscores to a short format.\n * \n * For example:\n * - Input: `f1_p1_g1_b1_c1`\n * - Output: `fpgbc`\n *\n * @param input_str The input string with segments separated by underscores.\n *\n * @return A short format string derived from the first characters of each segment.\n */\nstd::string convert_to_short_format(const std::string &input_str){}\n", "test_code": "TEST_CASE(\"TestConvertToShortFormat\", \"[convert_to_short_format]\") {\n    SECTION(\"Test a standard input with mixed characters\") {\n        REQUIRE(convert_to_short_format(\"f1_p1_g1_b1_c1\") == \"fpgbc\");\n    }\n\n    SECTION(\"Test input with multiple segments\") {\n        REQUIRE(convert_to_short_format(\"a2_b3_c4\") == \"abc\");\n    }\n\n    SECTION(\"Test input with non-alphanumeric characters\") {\n        REQUIRE(convert_to_short_format(\"hello_world_test\") == \"hwt\");\n    }\n\n    SECTION(\"Test a single segment input\") {\n        REQUIRE(convert_to_short_format(\"single\") == \"s\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a string concatenated with underscores to a short format.\n * \n * For example:\n * - Input: `f1_p1_g1_b1_c1`\n * - Output: `fpgbc`\n *\n * @param input_str The input string with segments separated by underscores.\n *\n * @return A short format string derived from the first characters of each segment.\n */\nstd::string convert_to_short_format(const std::string &input_str){}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a string concatenated with underscores to a short format.\n * For example:\n * <pre>\n *     input: f1_p1_g1_b1_c1\n *     output: fpgbc\n * </pre>\n *\n * @param inputStr The input string with segments separated by underscores.\n * @return A short format string derived from the first characters of each segment.\n */\npublic static String convertToShortFormat(String inputStr) {\n\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for the convertToShortFormat method.\n */\npublic class Tester {\n\n    /**\n     * Tests a standard input with mixed characters.\n     */\n    @Test\n    public void testBasicCase() {\n        assertEquals(\"fpgbc\", convertToShortFormat(\"f1_p1_g1_b1_c1\"));\n    }\n\n    /**\n     * Tests input with multiple segments.\n     */\n    @Test\n    public void testMultipleSegments() {\n        assertEquals(\"abc\", convertToShortFormat(\"a2_b3_c4\"));\n    }\n\n    /**\n     * Tests input with non-alphanumeric characters.\n     */\n    @Test\n    public void testNonAlphaNumeric() {\n        assertEquals(\"hwt\", convertToShortFormat(\"hello_world_test\"));\n    }\n\n    /**\n     * Tests a single segment input.\n     */\n    @Test\n    public void testSingleSegment() {\n        assertEquals(\"s\", convertToShortFormat(\"single\"));\n    }\n\n    // Helper method to simulate the convertToShortFormat method\n    private String convertToShortFormat(String inputStr) {\n        // Split the input string by underscores\n        String[] segments = inputStr.split(\"_\");\n\n        // Extract the first character from each segment and join them\n        StringBuilder shortFormat = new StringBuilder();\n        for (String segment : segments) {\n            if (!segment.isEmpty()) {\n                shortFormat.append(segment.charAt(0));\n            }\n        }\n\n        return shortFormat.toString();\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a string concatenated with underscores to a short format.\n * For example:\n * <pre>\n *     input: f1_p1_g1_b1_c1\n *     output: fpgbc\n * </pre>\n *\n * @param inputStr The input string with segments separated by underscores.\n * @return A short format string derived from the first characters of each segment.\n */\npublic static String convertToShortFormat(String inputStr) {\n\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 505, "code_type": "method", "original_language": "python", "file_path": "backend\\2a8b52493d9195046114127f3f8387e95d1b5a06\\src\\utils.py\n", "question_type": "Data processing and transformation", "summary": "Convert a CamelCase string to snake_case.", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef camel_to_snake(camel_str: str) -> str:\n    \"\"\"\n    Convert a CamelCase string to snake_case.\n\n    Args:\n        camel_str (str): The CamelCase string to convert.\n\n    Returns:\n        str: The converted snake_case string.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestCamelToSnake(unittest.TestCase):\n    def test_basic_conversion(self):\n        \"\"\" Test basic CamelCase to snake_case conversion. \"\"\"\n        self.assertEqual(camel_to_snake(\"HelloWorld\"), \"hello_world\")\n\n    def test_multiple_words(self):\n        \"\"\" Test conversion of a CamelCase string with multiple words. \"\"\"\n        self.assertEqual(camel_to_snake(\"ThisIsATest\"), \"this_is_a_test\")\n\n    def test_with_numbers(self):\n        \"\"\" Test conversion with numbers in the string. \"\"\"\n        self.assertEqual(camel_to_snake(\"ConvertThis123String\"), \"convert_this123_string\")\n\n    def test_leading_uppercase(self):\n        \"\"\" Test conversion with leading uppercase letters. \"\"\"\n        self.assertEqual(camel_to_snake(\"PythonFunction\"), \"python_function\")\n\n    def test_empty_string(self):\n        \"\"\" Test conversion of an empty string. \"\"\"\n        self.assertEqual(camel_to_snake(\"\"), \"\")\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef camel_to_snake(camel_str: str) -> str:\n    \"\"\"\n    Convert a CamelCase string to snake_case.\n\n    Args:\n        camel_str (str): The CamelCase string to convert.\n\n    Returns:\n        str: The converted snake_case string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a CamelCase string to snake_case.\n *\n * @param camel_str The CamelCase string to convert.\n *\n * @return The converted snake_case string.\n */\nstd::string convert_camel_to_snake(const std::string &camel_str){}\n", "test_code": "TEST_CASE(\"Test CamelCase to snake_case conversion\", \"[convert_camel_to_snake]\") {\n    SECTION(\"Basic conversion\") {\n        REQUIRE(convert_camel_to_snake(\"HelloWorld\") == \"hello_world\");\n    }\n\n    SECTION(\"Multiple words\") {\n        REQUIRE(convert_camel_to_snake(\"ThisIsATest\") == \"this_is_a_test\");\n    }\n\n    SECTION(\"With numbers\") {\n        REQUIRE(convert_camel_to_snake(\"ConvertThis123String\") == \"convert_this123_string\");\n    }\n\n    SECTION(\"Leading uppercase\") {\n        REQUIRE(convert_camel_to_snake(\"PythonFunction\") == \"python_function\");\n    }\n\n    SECTION(\"Empty string\") {\n        REQUIRE(convert_camel_to_snake(\"\") == \"\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a CamelCase string to snake_case.\n *\n * @param camel_str The CamelCase string to convert.\n *\n * @return The converted snake_case string.\n */\nstd::string convert_camel_to_snake(const std::string &camel_str){}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a CamelCase string to snake_case.\n *\n * @param camelStr The CamelCase string to convert.\n * @return The converted snake_case string.\n */\npublic static String camelToSnake(String camelStr) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for verifying the correctness of the camelToSnake method.\n */\npublic class Tester {\n\n    /**\n     * Tests basic CamelCase to snake_case conversion.\n     */\n    @Test\n    public void testBasicConversion() {\n        assertEquals(\"hello_world\", camelToSnake(\"HelloWorld\"));\n    }\n\n    /**\n     * Tests conversion of a CamelCase string with multiple words.\n     */\n    @Test\n    public void testMultipleWords() {\n        assertEquals(\"this_is_a_test\", camelToSnake(\"ThisIsATest\"));\n    }\n\n    /**\n     * Tests conversion with numbers in the string.\n     */\n    @Test\n    public void testWithNumbers() {\n        assertEquals(\"convert_this123_string\", camelToSnake(\"ConvertThis123String\"));\n    }\n\n    /**\n     * Tests conversion with leading uppercase letters.\n     */\n    @Test\n    public void testLeadingUppercase() {\n        assertEquals(\"python_function\", camelToSnake(\"PythonFunction\"));\n    }\n\n    /**\n     * Tests conversion of an empty string.\n     */\n    @Test\n    public void testEmptyString() {\n        assertEquals(\"\", camelToSnake(\"\"));\n    }\n\n    // Method to be tested\n    private String camelToSnake(String camelStr) {\n        // Use regular expression to insert underscores before each uppercase letter,\n        // and then convert the whole string to lowercase\n        return camelStr.replaceAll(\"(?<!^)(?=[A-Z])\", \"_\").toLowerCase();\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a CamelCase string to snake_case.\n *\n * @param camelStr The CamelCase string to convert.\n * @return The converted snake_case string.\n */\npublic static String camelToSnake(String camelStr) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 506, "code_type": "method", "original_language": "python", "file_path": "backend\\2a8b52493d9195046114127f3f8387e95d1b5a06\\src\\utils.py\n", "question_type": "Data processing and transformation", "summary": "Convert a snake_case string to CamelCase", "language_version_list": {"python": {"code_signature": "def snake_to_camel(snake_str: str) -> str:\n    \"\"\"\n    Convert a snake_case string to CamelCase.\n\n    Args:\n        snake_str (str): The snake_case string to convert.\n\n    Returns:\n        str: The converted CamelCase string.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSnakeToCamel(unittest.TestCase):\n    def test_basic_conversion(self):\n        \"\"\" Test basic snake_case to CamelCase conversion. \"\"\"\n        self.assertEqual(snake_to_camel(\"hello_world\"), \"HelloWorld\")\n\n    def test_multiple_words(self):\n        \"\"\" Test conversion of a snake_case string with multiple words. \"\"\"\n        self.assertEqual(snake_to_camel(\"this_is_a_test\"), \"ThisIsATest\")\n\n    def test_with_numbers(self):\n        \"\"\" Test conversion with numbers in the string. \"\"\"\n        self.assertEqual(snake_to_camel(\"convert_this_123_string\"), \"ConvertThis123String\")\n\n    def test_leading_trailing_underscores(self):\n        \"\"\" Test conversion with leading and trailing underscores. \"\"\"\n        self.assertEqual(snake_to_camel(\"_leading_and_trailing_\"), \"LeadingAndTrailing\")\n        self.assertEqual(snake_to_camel(\"___multiple___underscores___\"), \"MultipleUnderscores\")\n\n    def test_empty_string(self):\n        \"\"\" Test conversion of an empty string. \"\"\"\n        self.assertEqual(snake_to_camel(\"\"), \"\")", "prompt": "please write a python function , the function signature as below def snake_to_camel(snake_str: str) -> str:\n    \"\"\"\n    Convert a snake_case string to CamelCase.\n\n    Args:\n        snake_str (str): The snake_case string to convert.\n\n    Returns:\n        str: The converted CamelCase string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a snake_case string to CamelCase.\n *\n * @param snake_str The snake_case string to convert.\n *\n * @return The converted CamelCase string.\n */\nstd::string snake_to_camel(const std::string& snake_str) {}", "test_code": "TEST_CASE(\"Test basic snake_case to CamelCase conversion\", \"[snake_to_camel]\") {\n    CHECK(snake_to_camel(\"hello_world\") == \"HelloWorld\");\n}\n\nTEST_CASE(\"Test conversion of a snake_case string with multiple words\", \"[snake_to_camel]\") {\n    CHECK(snake_to_camel(\"this_is_a_test\") == \"ThisIsATest\");\n}\n\nTEST_CASE(\"Test conversion with numbers in the string\", \"[snake_to_camel]\") {\n    CHECK(snake_to_camel(\"convert_this_123_string\") == \"ConvertThis123String\");\n}\n\nTEST_CASE(\"Test conversion with leading and trailing underscores\", \"[snake_to_camel]\") {\n    CHECK(snake_to_camel(\"_leading_and_trailing_\") == \"LeadingAndTrailing\");\n    CHECK(snake_to_camel(\"___multiple___underscores___\") == \"MultipleUnderscores\");\n}\n\nTEST_CASE(\"Test conversion of an empty string\", \"[snake_to_camel]\") {\n    CHECK(snake_to_camel(\"\") == \"\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a snake_case string to CamelCase.\n *\n * @param snake_str The snake_case string to convert.\n *\n * @return The converted CamelCase string.\n */\nstd::string snake_to_camel(const std::string& snake_str) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a snake_case string to CamelCase.\n *\n * @param snakeStr The snake_case string to convert.\n * @return The converted CamelCase string.\n */\npublic static String snakeToCamel(String snakeStr) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for converting snake_case strings to CamelCase.\n */\npublic class Tester {\n\n    /**\n     * Converts a snake_case string to CamelCase.\n     *\n     * @param snakeStr The snake_case string to convert.\n     * @return The converted CamelCase string.\n     */\n    public static String snakeToCamel(String snakeStr) {\n        // Split the snake_case string into words\n        String[] words = snakeStr.split(\"_\");\n\n        // Capitalize the first letter of each word and join them\n        StringBuilder camelCaseStr = new StringBuilder();\n        for (String word : words) {\n            if (!word.isEmpty()) {\n                camelCaseStr.append(Character.toUpperCase(word.charAt(0)));\n                camelCaseStr.append(word.substring(1));\n            }\n        }\n        return camelCaseStr.toString();\n    }\n\n    @Test\n    public void testBasicConversion() {\n        // Test basic snake_case to CamelCase conversion\n        assertEquals(\"HelloWorld\", snakeToCamel(\"hello_world\"));\n    }\n\n    @Test\n    public void testMultipleWords() {\n        // Test conversion of a snake_case string with multiple words\n        assertEquals(\"ThisIsATest\", snakeToCamel(\"this_is_a_test\"));\n    }\n\n    @Test\n    public void testWithNumbers() {\n        // Test conversion with numbers in the string\n        assertEquals(\"ConvertThis123String\", snakeToCamel(\"convert_this_123_string\"));\n    }\n\n    @Test\n    public void testLeadingTrailingUnderscores() {\n        // Test conversion with leading and trailing underscores\n        assertEquals(\"LeadingAndTrailing\", snakeToCamel(\"_leading_and_trailing_\"));\n        assertEquals(\"MultipleUnderscores\", snakeToCamel(\"___multiple___underscores___\"));\n    }\n\n    @Test\n    public void testEmptyString() {\n        // Test conversion of an empty string\n        assertEquals(\"\", snakeToCamel(\"\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a snake_case string to CamelCase.\n *\n * @param snakeStr The snake_case string to convert.\n * @return The converted CamelCase string.\n */\npublic static String snakeToCamel(String snakeStr) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 507, "code_type": "method", "original_language": "python", "file_path": "backend\\2a8b52493d9195046114127f3f8387e95d1b5a06\\src\\utils.py\n", "question_type": "Program input code", "summary": "Check that a password satisfies the criteria for a strong password, has at least one lowercase letter, at least one uppercase letter, at least one number, and is at least 8 bits long", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef is_strong_password(password: str) -> bool:\n    \"\"\"\n    Check if the provided password is strong.\n\n    A strong password must satisfy the following criteria:\n    - At least one lowercase letter\n    - At least one uppercase letter\n    - At least one number\n    - At least 8 characters long\n\n    Args:\n        password (str): The password to check.\n\n    Returns:\n        bool: True if the password is strong, False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestStrongPassword(unittest.TestCase):\n    def test_valid_password(self):\n        \"\"\" Test a strong password that meets all criteria. \"\"\"\n        self.assertTrue(is_strong_password(\"StrongPass1\"))\n\n    def test_missing_lowercase(self):\n        \"\"\" Test a password missing a lowercase letter. \"\"\"\n        self.assertFalse(is_strong_password(\"STRONGPASS1\"))\n\n    def test_missing_uppercase(self):\n        \"\"\" Test a password missing an uppercase letter. \"\"\"\n        self.assertFalse(is_strong_password(\"strongpass1\"))\n\n    def test_missing_number(self):\n        \"\"\" Test a password missing a number. \"\"\"\n        self.assertFalse(is_strong_password(\"StrongPassword\"))\n\n    def test_too_short(self):\n        \"\"\" Test a password that is too short. \"\"\"\n        self.assertFalse(is_strong_password(\"Short1\"))\n\n    def test_valid_with_special_characters(self):\n        \"\"\" Test a password that includes special characters but is still strong. \"\"\"\n        self.assertTrue(is_strong_password(\"Strong!Password1\"))", "prompt": "please write a python function , the function signature as below import re\n\n\ndef is_strong_password(password: str) -> bool:\n    \"\"\"\n    Check if the provided password is strong.\n\n    A strong password must satisfy the following criteria:\n    - At least one lowercase letter\n    - At least one uppercase letter\n    - At least one number\n    - At least 8 characters long\n\n    Args:\n        password (str): The password to check.\n\n    Returns:\n        bool: True if the password is strong, False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Checks if the provided password is strong.\n *\n * A strong password must satisfy the following criteria:\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one number\n * - At least 8 characters long\n *\n * @param password The password to check.\n *\n * @return True if the password is strong; false otherwise.\n */\nbool is_strong_password(const std::string& password) {}", "test_code": "TEST_CASE(\"Test a strong password that meets all criteria\", \"[valid_password]\") {\n    REQUIRE(is_strong_password(\"StrongPass1\"));\n}\n\nTEST_CASE(\"Test a password missing a lowercase letter\", \"[missing_lowercase]\") {\n    REQUIRE_FALSE(is_strong_password(\"STRONGPASS1\"));\n}\n\nTEST_CASE(\"Test a password missing an uppercase letter\", \"[missing_uppercase]\") {\n    REQUIRE_FALSE(is_strong_password(\"strongpass1\"));\n}\n\nTEST_CASE(\"Test a password missing a number\", \"[missing_number]\") {\n    REQUIRE_FALSE(is_strong_password(\"StrongPassword\"));\n}\n\nTEST_CASE(\"Test a password that is too short\", \"[too_short]\") {\n    REQUIRE_FALSE(is_strong_password(\"Short1\"));\n}\n\nTEST_CASE(\"Test a password that includes special characters but is still strong\", \"[valid_with_special_characters]\") {\n    REQUIRE(is_strong_password(\"Strong!Password1\"));\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Checks if the provided password is strong.\n *\n * A strong password must satisfy the following criteria:\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one number\n * - At least 8 characters long\n *\n * @param password The password to check.\n *\n * @return True if the password is strong; false otherwise.\n */\nbool is_strong_password(const std::string& password) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Check if the provided password is strong.\n *\n * A strong password must satisfy the following criteria:\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one number\n * - At least 8 characters long\n *\n * @param password The password to check.\n * @return true if the password is strong, false otherwise.\n */\npublic static boolean isStrongPassword(String password) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    /**\n     * Test a strong password that meets all criteria.\n     */\n    @Test\n    public void testValidPassword() {\n        assertTrue(isStrongPassword(\"StrongPass1\"));\n    }\n\n    /**\n     * Test a password missing a lowercase letter.\n     */\n    @Test\n    public void testMissingLowercase() {\n        assertFalse(isStrongPassword(\"STRONGPASS1\"));\n    }\n\n    /**\n     * Test a password missing an uppercase letter.\n     */\n    @Test\n    public void testMissingUppercase() {\n        assertFalse(isStrongPassword(\"strongpass1\"));\n    }\n\n    /**\n     * Test a password missing a number.\n     */\n    @Test\n    public void testMissingNumber() {\n        assertFalse(isStrongPassword(\"StrongPassword\"));\n    }\n\n    /**\n     * Test a password that is too short.\n     */\n    @Test\n    public void testTooShort() {\n        assertFalse(isStrongPassword(\"Short1\"));\n    }\n\n    /**\n     * Test a password that includes special characters but is still strong.\n     */\n    @Test\n    public void testValidWithSpecialCharacters() {\n        assertTrue(isStrongPassword(\"Strong!Password1\"));\n    }\n\n    // Utility method to check if a password is strong\n    private boolean isStrongPassword(String password) {\n        // Check password length\n        if (password.length() < 8) {\n            return false;\n        }\n\n        // Check for at least one lowercase letter\n        if (!password.matches(\".*[a-z].*\")) {\n            return false;\n        }\n\n        // Check for at least one uppercase letter\n        if (!password.matches(\".*[A-Z].*\")) {\n            return false;\n        }\n\n        // Check for at least one number\n        if (!password.matches(\".*\\\\d.*\")) {\n            return false;\n        }\n\n        // If all checks passed, return true\n        return true;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Check if the provided password is strong.\n *\n * A strong password must satisfy the following criteria:\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one number\n * - At least 8 characters long\n *\n * @param password The password to check.\n * @return true if the password is strong, false otherwise.\n */\npublic static boolean isStrongPassword(String password) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 509, "code_type": "method", "original_language": "python", "file_path": "Approx-Multipliers-SMC\\5a0d8d7c37a02c2ff6d2c79cba3e609ae21178f2\\auxiliary\\density\\in\\elgamal\\elgamal.py\n", "question_type": "Algorithm and data structure", "summary": "Perform modular exponentiation: (base^exponent) % modulus efficiently.", "language_version_list": {"python": {"code_signature": "def mod_exp(base:int, exponent:int, modulus:int) -> int:\n    \"\"\"\n    Perform modular exponentiation: (base^exponent) % modulus efficiently.\n\n    Args:\n        base (int): The base value.\n        exponent (int): The exponent value (should be non-negative).\n        modulus (int): The modulus value (should be positive).\n\n    Returns:\n        int: The result of (base^exponent) % modulus.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestModExp(unittest.TestCase):\n    def test_case_1(self):\n        \"\"\" Test with base = 2, exponent = 10, modulus = 1000 \"\"\"\n        self.assertEqual(mod_exp(2, 10, 1000), 24)\n\n    def test_case_2(self):\n        \"\"\" Test with base = 3, exponent = 7, modulus = 50 \"\"\"\n        self.assertEqual(mod_exp(3, 7, 50), 37)\n\n    def test_case_3(self):\n        \"\"\" Test with base = 5, exponent = 0, modulus = 13 (any number^0 = 1) \"\"\"\n        self.assertEqual(mod_exp(5, 0, 13), 1)\n\n    def test_case_4(self):\n        \"\"\" Test with base = 7, exponent = 5, modulus = 20 \"\"\"\n        self.assertEqual(mod_exp(7, 5, 20), 7)  # 7^5 = 16807, 16807 % 20 = 7\n\n    def test_case_5(self):\n        \"\"\" Test with base = 10, exponent = 5, modulus = 6 \"\"\"\n        self.assertEqual(mod_exp(10, 5, 6), 4)  # 10^5 = 100000, 100000 % 6 = 4", "prompt": "please write a python function , the function signature as below def mod_exp(base:int, exponent:int, modulus:int) -> int:\n    \"\"\"\n    Perform modular exponentiation: (base^exponent) % modulus efficiently.\n\n    Args:\n        base (int): The base value.\n        exponent (int): The exponent value (should be non-negative).\n        modulus (int): The modulus value (should be positive).\n\n    Returns:\n        int: The result of (base^exponent) % modulus.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Perform modular exponentiation: (base^exponent) % modulus efficiently.\n *\n * @param base The base value.\n * @param exponent The exponent value (should be non-negative).\n * @param modulus The modulus value (should be positive).\n * @return The result of (base^exponent) % modulus.\n * @throws std::invalid_argument If modulus is less than or equal to zero.\n */\nlong long mod_exp(long long base, long long exponent, long long modulus) {}", "test_code": "TEST_CASE(\"Test modular exponentiation\", \"[mod_exp]\") {\n    SECTION(\"Test with base = 2, exponent = 10, modulus = 1000\") {\n        REQUIRE(mod_exp(2, 10, 1000) == 24);\n    }\n\n    SECTION(\"Test with base = 3, exponent = 7, modulus = 50\") {\n        REQUIRE(mod_exp(3, 7, 50) == 37);\n    }\n\n    SECTION(\"Test with base = 5, exponent = 0, modulus = 13 (any number^0 = 1)\") {\n        REQUIRE(mod_exp(5, 0, 13) == 1);\n    }\n\n    SECTION(\"Test with base = 7, exponent = 5, modulus = 20\") {\n        REQUIRE(mod_exp(7, 5, 20) == 7);  // 7^5 = 16807, 16807 % 20 = 7\n    }\n\n    SECTION(\"Test with base = 10, exponent = 5, modulus = 6\") {\n        REQUIRE(mod_exp(10, 5, 6) == 4);  // 10^5 = 100000, 100000 % 6 = 4\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Perform modular exponentiation: (base^exponent) % modulus efficiently.\n *\n * @param base The base value.\n * @param exponent The exponent value (should be non-negative).\n * @param modulus The modulus value (should be positive).\n * @return The result of (base^exponent) % modulus.\n * @throws std::invalid_argument If modulus is less than or equal to zero.\n */\nlong long mod_exp(long long base, long long exponent, long long modulus) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Performs modular exponentiation: (base^exponent) % modulus efficiently.\n *\n * @param base     The base value.\n * @param exponent The exponent value (should be non-negative).\n * @param modulus  The modulus value (should be positive).\n * @return The result of (base^exponent) % modulus.\n * @throws IllegalArgumentException If modulus is less than or equal to zero.\n */\npublic static int modExp(int base, int exponent, int modulus) {\n\n}\n\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for modular exponentiation.\n */\npublic class Tester {\n\n    /**\n     * Test with base = 2, exponent = 10, modulus = 1000.\n     */\n    @Test\n    public void testCase1() {\n        assertEquals(\"Test with base = 2, exponent = 10, modulus = 1000\", 24, modExp(2, 10, 1000));\n    }\n\n    /**\n     * Test with base = 3, exponent = 7, modulus = 50.\n     */\n    @Test\n    public void testCase2() {\n        assertEquals(\"Test with base = 3, exponent = 7, modulus = 50\", 37, modExp(3, 7, 50));\n    }\n\n    /**\n     * Test with base = 5, exponent = 0, modulus = 13 (any number^0 = 1).\n     */\n    @Test\n    public void testCase3() {\n        assertEquals(\"Test with base = 5, exponent = 0, modulus = 13\", 1, modExp(5, 0, 13));\n    }\n\n    /**\n     * Test with base = 7, exponent = 5, modulus = 20.\n     */\n    @Test\n    public void testCase4() {\n        assertEquals(\"Test with base = 7, exponent = 5, modulus = 20\", 7, modExp(7, 5, 20));\n    }\n\n    /**\n     * Test with base = 10, exponent = 5, modulus = 6.\n     */\n    @Test\n    public void testCase5() {\n        assertEquals(\"Test with base = 10, exponent = 5, modulus = 6\", 4, modExp(10, 5, 6));\n    }\n\n    /**\n     * Performs modular exponentiation: (base^exponent) % modulus efficiently.\n     *\n     * @param base     The base value.\n     * @param exponent The exponent value (should be non-negative).\n     * @param modulus  The modulus value (should be positive).\n     * @return The result of (base^exponent) % modulus.\n     * @throws IllegalArgumentException If modulus is less than or equal to zero.\n     */\n    private static int modExp(int base, int exponent, int modulus) {\n        if (modulus <= 0) {\n            throw new IllegalArgumentException(\"Modulus must be a positive integer.\");\n        }\n\n        int result = 1;\n        base = base % modulus;  // Ensure base is within the modulus\n\n        while (exponent > 0) {\n            // If exponent is odd, multiply the base with the result\n            if (exponent % 2 == 1) {\n                result = (result * base) % modulus;\n            }\n\n            // Right shift the exponent by 1 (equivalent to exponent //= 2)\n            exponent >>= 1;\n            // Square the base\n            base = (base * base) % modulus;\n        }\n\n        return result;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Performs modular exponentiation: (base^exponent) % modulus efficiently.\n *\n * @param base     The base value.\n * @param exponent The exponent value (should be non-negative).\n * @param modulus  The modulus value (should be positive).\n * @return The result of (base^exponent) % modulus.\n * @throws IllegalArgumentException If modulus is less than or equal to zero.\n */\npublic static int modExp(int base, int exponent, int modulus) {\n\n}\n\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 510, "code_type": "method", "original_language": "python", "file_path": "AtCoder\\e7abdb335d403877150df2522f5cb1957ef0938b\\AtCoderBeginnerContest\\324\\b.py\n", "question_type": "Algorithm and data structure", "summary": "Find the powers of 2 and 3 that multiply to produce the given number.", "language_version_list": {"python": {"code_signature": "def find_powers(num: int) -> tuple:\n    \"\"\"\n    Find the powers of 2 and 3 that multiply to produce the given number.\n\n    Args:\n        num (int): A positive integer greater than zero.\n\n    Returns:\n        tuple: A tuple (n, m) where n is the power of 2 and m is the power of 3.\n           Returns None if the number is zero or if the number has prime factors other than 2 and 3.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFindPowers(unittest.TestCase):\n\n    def test_valid_cases(self):\n        \"\"\"Test valid numbers with only 2's and 3's as prime factors.\"\"\"\n        self.assertEqual(find_powers(18), (1, 2))  # 18 = 2^1 * 3^2\n        self.assertEqual(find_powers(8), (3, 0))   # 8 = 2^3 * 3^0\n        self.assertEqual(find_powers(27), (0, 3))  # 27 = 2^0 * 3^3\n        self.assertEqual(find_powers(12), (2, 1))  # 12 = 2^2 * 3^1\n        self.assertEqual(find_powers(1), (0, 0))    # 1 = 2^0 * 3^0\n\n    def test_invalid_cases(self):\n        \"\"\"Test numbers with prime factors other than 2 and 3.\"\"\"\n        self.assertIsNone(find_powers(7))    # 7 is a prime factor\n        self.assertIsNone(find_powers(14))   # 14 = 2^1 * 7^1 (contains 7)\n        self.assertIsNone(find_powers(10))   # 10 = 2^1 * 5^1 (contains 5)\n\n\n    def test_large_numbers(self):\n        \"\"\"Test large numbers that have only 2 and 3 as prime factors.\"\"\"\n        self.assertEqual(find_powers(864), (5, 3))  # 864 = 2^5 * 3^3\n        self.assertEqual(find_powers(729), (0, 6))  # 729 = 2^0 * 3^6\n\n    def test_edge_cases(self):\n        \"\"\"Test edge cases for minimal inputs.\"\"\"\n        self.assertEqual(find_powers(2), (1, 0))   # 2 = 2^1 * 3^0\n        self.assertEqual(find_powers(3), (0, 1))   # 3 = 2^0 * 3^1", "prompt": "please write a python function , the function signature as below def find_powers(num: int) -> tuple:\n    \"\"\"\n    Find the powers of 2 and 3 that multiply to produce the given number.\n\n    Args:\n        num (int): A positive integer greater than zero.\n\n    Returns:\n        tuple: A tuple (n, m) where n is the power of 2 and m is the power of 3.\n           Returns None if the number is zero or if the number has prime factors other than 2 and 3.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Find the powers of 2 and 3 that multiply to produce the given number.\n *\n * @param num A positive integer greater than zero.\n * @return A pair (n, m) where n is the power of 2 and m is the power of 3.\n *         Returns (-1, -1) if the number is zero or if the number has prime factors other than 2 and 3.\n */\nstd::pair<int, int> find_powers(int num) {}", "test_code": "TEST_CASE(\"Test valid cases\", \"[find_powers]\") {\n    SECTION(\"Valid numbers with only 2's and 3's as prime factors\") {\n        CHECK(find_powers(18) == std::make_pair(1, 2));  // 18 = 2^1 * 3^2\n        CHECK(find_powers(8) == std::make_pair(3, 0));   // 8 = 2^3 * 3^0\n        CHECK(find_powers(27) == std::make_pair(0, 3));  // 27 = 2^0 * 3^3\n        CHECK(find_powers(12) == std::make_pair(2, 1));  // 12 = 2^2 * 3^1\n        CHECK(find_powers(1) == std::make_pair(0, 0));   // 1 = 2^0 * 3^0\n    }\n}\n\nTEST_CASE(\"Test invalid cases\", \"[find_powers]\") {\n    SECTION(\"Numbers with prime factors other than 2 and 3\") {\n        CHECK(find_powers(7) == std::make_pair(-1, -1));  // 7 is a prime factor\n        CHECK(find_powers(14) == std::make_pair(-1, -1)); // 14 = 2^1 * 7^1 (contains 7)\n        CHECK(find_powers(10) == std::make_pair(-1, -1)); // 10 = 2^1 * 5^1 (contains 5)\n    }\n}\n\nTEST_CASE(\"Test large numbers\", \"[find_powers]\") {\n    SECTION(\"Large numbers that have only 2 and 3 as prime factors\") {\n        CHECK(find_powers(864) == std::make_pair(5, 3));  // 864 = 2^5 * 3^3\n        CHECK(find_powers(729) == std::make_pair(0, 6));  // 729 = 2^0 * 3^6\n    }\n}\n\nTEST_CASE(\"Test edge cases\", \"[find_powers]\") {\n    SECTION(\"Edge cases for minimal inputs\") {\n        CHECK(find_powers(2) == std::make_pair(1, 0));  // 2 = 2^1 * 3^0\n        CHECK(find_powers(3) == std::make_pair(0, 1));  // 3 = 2^0 * 3^1\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Find the powers of 2 and 3 that multiply to produce the given number.\n *\n * @param num A positive integer greater than zero.\n * @return A pair (n, m) where n is the power of 2 and m is the power of 3.\n *         Returns (-1, -1) if the number is zero or if the number has prime factors other than 2 and 3.\n */\nstd::pair<int, int> find_powers(int num) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds the powers of 2 and 3 that multiply to produce the given number.\n *\n * @param num A positive integer greater than zero.\n * @return An array (n, m) where n is the power of 2 and m is the power of 3.\n *         Returns null if the number is zero or if the number has prime factors other than 2 and 3.\n */\npublic static Integer[] findPowers(int num) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Test class for verifying the correctness of the findPowers method.\n */\npublic class Tester {\n\n    /**\n     * Tests valid numbers with only 2's and 3's as prime factors.\n     */\n    @Test\n    public void testValidCases() {\n        assertEquals(\"(1, 2)\", Arrays.toString(findPowers(18)));  // 18 = 2^1 * 3^2\n        assertEquals(\"(3, 0)\", Arrays.toString(findPowers(8)));   // 8 = 2^3 * 3^0\n        assertEquals(\"(0, 3)\", Arrays.toString(findPowers(27)));  // 27 = 2^0 * 3^3\n        assertEquals(\"(2, 1)\", Arrays.toString(findPowers(12)));  // 12 = 2^2 * 3^1\n        assertEquals(\"(0, 0)\", Arrays.toString(findPowers(1)));   // 1 = 2^0 * 3^0\n    }\n\n    /**\n     * Tests numbers with prime factors other than 2 and 3.\n     */\n    @Test\n    public void testInvalidCases() {\n        assertNull(findPowers(7));    // 7 is a prime factor\n        assertNull(findPowers(14));   // 14 = 2^1 * 7^1 (contains 7)\n        assertNull(findPowers(10));   // 10 = 2^1 * 5^1 (contains 5)\n    }\n\n    /**\n     * Tests large numbers that have only 2 and 3 as prime factors.\n     */\n    @Test\n    public void testLargeNumbers() {\n        assertEquals(\"(5, 3)\", Arrays.toString(findPowers(864)));  // 864 = 2^5 * 3^3\n        assertEquals(\"(0, 6)\", Arrays.toString(findPowers(729)));  // 729 = 2^0 * 3^6\n    }\n\n    /**\n     * Tests edge cases for minimal inputs.\n     */\n    @Test\n    public void testEdgeCases() {\n        assertEquals(\"(1, 0)\", Arrays.toString(findPowers(2)));   // 2 = 2^1 * 3^0\n        assertEquals(\"(0, 1)\", Arrays.toString(findPowers(3)));   // 3 = 2^0 * 3^1\n    }\n\n    // Utility method to simulate the findPowers method\n    private Integer[] findPowers(int num) {\n        // Input validation\n        if (num <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer greater than zero.\");\n        }\n\n        int n = 0; // Initialize counter for powers of 2\n        int m = 0; // Initialize counter for powers of 3\n\n        // Count the power of 2 in the factorization\n        while (num % 2 == 0) {\n            n++;\n            num /= 2;\n        }\n\n        // Count the power of 3 in the factorization\n        while (num % 3 == 0) {\n            m++;\n            num /= 3;\n        }\n\n        // If num is reduced to 1, only 2's and 3's were factors\n        if (num == 1) {\n            return new Integer[]{n, m};\n        } else {\n            return null; // Return null if there are other prime factors\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds the powers of 2 and 3 that multiply to produce the given number.\n *\n * @param num A positive integer greater than zero.\n * @return An array (n, m) where n is the power of 2 and m is the power of 3.\n *         Returns null if the number is zero or if the number has prime factors other than 2 and 3.\n */\npublic static Integer[] findPowers(int num) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 511, "code_type": "method", "original_language": "python", "file_path": "ObjectiveCli\\fbe60c455d846047b0fe9e2e4d3449f46a9a847f\\libs\\packaged\\Drawlib2\\generators.py\n", "question_type": "Data processing and transformation", "summary": "Convert a hexadecimal color code to an ANSI escape code", "language_version_list": {"python": {"code_signature": "def hex_to_ansi(hex_color: str) -> str:\n    \"\"\"\n    Convert a hexadecimal color code to an ANSI escape code.\n\n    Args:\n        hex_color (str): A string representing the hexadecimal color code, e.g., '#FF5733'.\n\n    Returns:\n        str: An ANSI escape code for the specified RGB color.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestHexToAnsi(unittest.TestCase):\n\n    def test_valid_colors(self):\n        \"\"\"Test valid hex color inputs.\"\"\"\n        self.assertEqual(hex_to_ansi(\"#FF5733\"), \"\\x1b[38;2;255;87;51m\")\n        self.assertEqual(hex_to_ansi(\"#00FF00\"), \"\\x1b[38;2;0;255;0m\")\n        self.assertEqual(hex_to_ansi(\"#0000FF\"), \"\\x1b[38;2;0;0;255m\")\n\n    def test_black_and_white(self):\n        \"\"\"Test edge cases with black and white colors.\"\"\"\n        self.assertEqual(hex_to_ansi(\"#000000\"), \"\\x1b[38;2;0;0;0m\")  # Black\n        self.assertEqual(hex_to_ansi(\"#FFFFFF\"), \"\\x1b[38;2;255;255;255m\")  # White\n", "prompt": "please write a python function , the function signature as below def hex_to_ansi(hex_color: str) -> str:\n    \"\"\"\n    Convert a hexadecimal color code to an ANSI escape code.\n\n    Args:\n        hex_color (str): A string representing the hexadecimal color code, e.g., '#FF5733'.\n\n    Returns:\n        str: An ANSI escape code for the specified RGB color.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a hexadecimal color code to an ANSI escape code.\n *\n * @param hex_color A string representing the hexadecimal color code, e.g., \"#FF5733\".\n *\n * @return An ANSI escape code for the specified RGB color.\n */\nstd::string hex_to_ansi(const std::string& hex_color) {}", "test_code": "TEST_CASE(\"Test valid hex color inputs\", \"[hex_to_ansi]\") {\n    SECTION(\"Valid colors\") {\n        CHECK(hex_to_ansi(\"#FF5733\") == \"\\x1b[38;2;255;87;51m\");\n        CHECK(hex_to_ansi(\"#00FF00\") == \"\\x1b[38;2;0;255;0m\");\n        CHECK(hex_to_ansi(\"#0000FF\") == \"\\x1b[38;2;0;0;255m\");\n    }\n}\n\nTEST_CASE(\"Test edge cases with black and white colors\", \"[hex_to_ansi]\") {\n    SECTION(\"Black and white colors\") {\n        CHECK(hex_to_ansi(\"#000000\") == \"\\x1b[38;2;0;0;0m\");  // Black\n        CHECK(hex_to_ansi(\"#FFFFFF\") == \"\\x1b[38;2;255;255;255m\");  // White\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a hexadecimal color code to an ANSI escape code.\n *\n * @param hex_color A string representing the hexadecimal color code, e.g., \"#FF5733\".\n *\n * @return An ANSI escape code for the specified RGB color.\n */\nstd::string hex_to_ansi(const std::string& hex_color) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a hexadecimal color code to an ANSI escape code.\n *\n * @param hexColor A string representing the hexadecimal color code, e.g., \"#FF5733\".\n * @return An ANSI escape code for the specified RGB color.\n * @throws IllegalArgumentException if the hex color format is invalid.\n */\npublic static String hexToAnsi(String hexColor) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for verifying the correctness of the hexToAnsi method.\n */\npublic class Tester {\n\n    /**\n     * Tests valid hex color inputs.\n     */\n    @Test\n    public void testValidColors() {\n        assertEquals(\"\\u001b[38;2;255;87;51m\", hexToAnsi(\"#FF5733\"));\n        assertEquals(\"\\u001b[38;2;0;255;0m\", hexToAnsi(\"#00FF00\"));\n        assertEquals(\"\\u001b[38;2;0;0;255m\", hexToAnsi(\"#0000FF\"));\n    }\n\n    /**\n     * Tests edge cases with black and white colors.\n     */\n    @Test\n    public void testBlackAndWhite() {\n        assertEquals(\"\\u001b[38;2;0;0;0m\", hexToAnsi(\"#000000\"));  // Black\n        assertEquals(\"\\u001b[38;2;255;255;255m\", hexToAnsi(\"#FFFFFF\"));  // White\n    }\n\n    /**\n     * Converts a hexadecimal color code to an ANSI escape code.\n     *\n     * @param hexColor A string representing the hexadecimal color code, e.g., \"#FF5733\".\n     * @return An ANSI escape code for the specified RGB color.\n     * @throws IllegalArgumentException if the hex color format is invalid.\n     */\n    private String hexToAnsi(String hexColor) {\n        // Check if the input is a valid hex color\n        if (hexColor == null || hexColor.length() != 7 || !hexColor.startsWith(\"#\")) {\n            throw new IllegalArgumentException(\"Invalid hex color format. Use '#RRGGBB'.\");\n        }\n\n        // Extract the red, green, and blue components from the hex string\n        int r = Integer.parseInt(hexColor.substring(1, 3), 16);\n        int g = Integer.parseInt(hexColor.substring(3, 5), 16);\n        int b = Integer.parseInt(hexColor.substring(5, 7), 16);\n\n        // Create the ANSI escape code\n        String ansiCode = \"\\u001b[38;2;\" + r + \";\" + g + \";\" + b + \"m\";\n\n        return ansiCode;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a hexadecimal color code to an ANSI escape code.\n *\n * @param hexColor A string representing the hexadecimal color code, e.g., \"#FF5733\".\n * @return An ANSI escape code for the specified RGB color.\n * @throws IllegalArgumentException if the hex color format is invalid.\n */\npublic static String hexToAnsi(String hexColor) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 512, "code_type": "method", "original_language": "python", "file_path": "digipick-solver\\1b3da607cb095cf439721a8f4a1d84ad5076fd9e\\orig\\digipick.py\n", "question_type": "Data processing and transformation", "summary": "Convert a list of hole positions to the ring format (list of 1s and 0s).", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef convert_to_ring_format(holes: List) -> List:\n    \"\"\"\n    Convert a list of hole positions to the ring format (list of 1s and 0s).\n\n    Args:\n        holes (list): A list of integers representing the positions of the holes (0-indexed).\n\n    Returns:\n        List: A list of length 32, where positions with holes are 0 and others are 1.\n\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestConvertToRingFormat(unittest.TestCase):\n\n    def test_no_holes(self):\n        \"\"\" Test with no holes provided. \"\"\"\n        holes = []\n        expected = [1] * 32  # All positions should be 1\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)\n\n    def test_single_hole(self):\n        \"\"\" Test with a single hole position. \"\"\"\n        holes = [5]\n        expected = [1] * 32\n        expected[5] = 0  # Only position 5 should be 0\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)\n\n    def test_multiple_holes(self):\n        \"\"\" Test with multiple hole positions. \"\"\"\n        holes = [0, 2, 4, 8, 16]\n        expected = [1] * 32\n        for hole in holes:\n            expected[hole] = 0  # Set specified positions to 0\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)\n\n    def test_hole_out_of_bounds(self):\n        \"\"\" Test with some hole positions out of bounds. \"\"\"\n        holes = [-1, 32, 5, 10]  # -1 and 32 are out of bounds\n        expected = [1] * 32\n        expected[5] = 0  # Only position 5 and 10 should be 0\n        expected[10] = 0\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)\n\n    def test_all_holes(self):\n        \"\"\" Test with all positions as holes. \"\"\"\n        holes = list(range(32))  # All positions from 0 to 31\n        expected = [0] * 32  # All positions should be 0\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef convert_to_ring_format(holes: List) -> List:\n    \"\"\"\n    Convert a list of hole positions to the ring format (list of 1s and 0s).\n\n    Args:\n        holes (list): A list of integers representing the positions of the holes (0-indexed).\n\n    Returns:\n        List: A list of length 32, where positions with holes are 0 and others are 1.\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert a list of hole positions to the ring format (list of 1s and 0s).\n *\n * @param holes A list of integers representing the positions of the holes (0-indexed).\n * @return A list of length 32, where positions with holes are 0 and others are 1.\n */\nstd::vector<int> convert_to_ring_format(const std::vector<int>& holes) {}", "test_code": "TEST_CASE(\"Test convert_to_ring_format\", \"[convert_to_ring_format]\") {\n    SECTION(\"Test with no holes provided\") {\n        std::vector<int> holes = {};\n        std::vector<int> expected(32, 1);  // All positions should be 1\n        auto result = convert_to_ring_format(holes);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test with a single hole position\") {\n        std::vector<int> holes = {5};\n        std::vector<int> expected(32, 1);\n        expected[5] = 0;  // Only position 5 should be 0\n        auto result = convert_to_ring_format(holes);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test with multiple hole positions\") {\n        std::vector<int> holes = {0, 2, 4, 8, 16};\n        std::vector<int> expected(32, 1);\n        for (int hole : holes) {\n            expected[hole] = 0;  // Set specified positions to 0\n        }\n        auto result = convert_to_ring_format(holes);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test with some hole positions out of bounds\") {\n        std::vector<int> holes = {-1, 32, 5, 10};  // -1 and 32 are out of bounds\n        std::vector<int> expected(32, 1);\n        expected[5] = 0;  // Only position 5 and 10 should be 0\n        expected[10] = 0;\n        auto result = convert_to_ring_format(holes);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test with all positions as holes\") {\n        std::vector<int> holes;\n        for (int i = 0; i < 32; ++i) {\n            holes.push_back(i);\n        }\n        std::vector<int> expected(32, 0);  // All positions should be 0\n        auto result = convert_to_ring_format(holes);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert a list of hole positions to the ring format (list of 1s and 0s).\n *\n * @param holes A list of integers representing the positions of the holes (0-indexed).\n * @return A list of length 32, where positions with holes are 0 and others are 1.\n */\nstd::vector<int> convert_to_ring_format(const std::vector<int>& holes) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Convert a list of hole positions to the ring format (list of 1s and 0s).\n *\n * @param holes A list of integers representing the positions of the holes (0-indexed).\n * @return A list of length 32, where positions with holes are 0 and others are 1.\n */\npublic static List<Integer> convertToRingFormat(List<Integer> holes) {\n\n}", "test_code": "import org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    // Method to be tested\n    private static List<Integer> convertToRingFormat(List<Integer> holes) {\n        // Initialize the ring with all positions set to 1\n        List<Integer> ring = new ArrayList<>();\n        for (int i = 0; i < 32; i++) {\n            ring.add(1);\n        }\n\n        // Mark the positions of holes as 0\n        for (Integer hole : holes) {\n            if (0 <= hole && hole < 32) {  // Ensure hole positions are within valid range\n                ring.set(hole, 0);\n            }\n        }\n\n        return ring;\n    }\n\n    @Test\n    public void testNoHoles() {\n        \"\"\" Test with no holes provided. \"\"\"\n        List<Integer> holes = new ArrayList<>();\n        List<Integer> expected = new ArrayList<>(Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1));\n        List<Integer> result = convertToRingFormat(holes);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testSingleHole() {\n        \"\"\" Test with a single hole position. \"\"\"\n        List<Integer> holes = new ArrayList<>(Arrays.asList(5));\n        List<Integer> expected = new ArrayList<>(Arrays.asList(1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1));\n        List<Integer> result = convertToRingFormat(holes);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testMultipleHoles() {\n        \"\"\" Test with multiple hole positions. \"\"\"\n        List<Integer> holes = new ArrayList<>(Arrays.asList(0, 2, 4, 8, 16));\n        List<Integer> expected = new ArrayList<>(Arrays.asList(0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1));\n        List<Integer> result = convertToRingFormat(holes);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testHoleOutOfBounds() {\n        \"\"\" Test with some hole positions out of bounds. \"\"\"\n        List<Integer> holes = new ArrayList<>(Arrays.asList(-1, 32, 5, 10));\n        List<Integer> expected = new ArrayList<>(Arrays.asList(1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1));\n        List<Integer> result = convertToRingFormat(holes);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testAllHoles() {\n        \"\"\" Test with all positions as holes. \"\"\"\n        List<Integer> holes = new ArrayList<>();\n        for (int i = 0; i < 32; i++) {\n            holes.add(i);\n        }\n        List<Integer> expected = new ArrayList<>(Arrays.asList(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0));\n        List<Integer> result = convertToRingFormat(holes);\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Convert a list of hole positions to the ring format (list of 1s and 0s).\n *\n * @param holes A list of integers representing the positions of the holes (0-indexed).\n * @return A list of length 32, where positions with holes are 0 and others are 1.\n */\npublic static List<Integer> convertToRingFormat(List<Integer> holes) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 513, "code_type": "method", "original_language": "python", "file_path": "Scrapers_Matei\\c3342a3e2348fff2edf8d4d612ba3e86c670374d\\sites\\__utils\\found_county.py\n", "question_type": "Data processing and transformation", "summary": "Check whether the phrase exists in the string, ignoring the case of the phrase\n", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef is_phrase_in_string_ignore_case(phrase: str, string: str) -> bool:\n    \"\"\"\n    Check if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n\n    Args:\n        phrase (str): The phrase to search for in the string.\n        string (str): The target string in which to search for the phrase.\n\n    Returns:\n        bool: True if the phrase is found as a whole word in the string, False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestIsPhraseInStringIgnoreCase(unittest.TestCase):\n\n    def test_exact_match_case_insensitive(self):\n        self.assertTrue(is_phrase_in_string_ignore_case(\"hello world\", \"Hello World\"))\n\n\n    def test_partial_word_match_case_insensitive(self):\n        self.assertTrue(is_phrase_in_string_ignore_case(\"Hello\", \"saying Hello there\"))\n\n    def test_different_cases(self):\n        self.assertTrue(is_phrase_in_string_ignore_case(\"HELLO\", \"hello there!\"))\n        self.assertTrue(is_phrase_in_string_ignore_case(\"world\", \"WORLD is great\"))\n\n    def test_non_existent_phrase(self):\n        self.assertFalse(is_phrase_in_string_ignore_case(\"goodbye\", \"Hello world\"))\n        self.assertFalse(is_phrase_in_string_ignore_case(\"hello\", \"goodbye world\"))\n\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef is_phrase_in_string_ignore_case(phrase: str, string: str) -> bool:\n    \"\"\"\n    Check if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n\n    Args:\n        phrase (str): The phrase to search for in the string.\n        string (str): The target string in which to search for the phrase.\n\n    Returns:\n        bool: True if the phrase is found as a whole word in the string, False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Check if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n *\n * @param phrase The phrase to search for in the string.\n * @param string The target string in which to search for the phrase.\n *\n * @return True if the phrase is found as a whole word in the string, False otherwise.\n */\nbool is_phrase_in_string_ignore_case(const std::string& phrase, const std::string& string) {\n\n}", "test_code": "TEST_CASE(\"Test is_phrase_in_string_ignore_case\", \"[is_phrase_in_string_ignore_case]\") {\n    SECTION(\"Exact match case insensitive\") {\n        REQUIRE(is_phrase_in_string_ignore_case(\"hello world\", \"Hello World\"));\n    }\n\n    SECTION(\"Partial word match case insensitive\") {\n        REQUIRE(is_phrase_in_string_ignore_case(\"Hello\", \"saying Hello there\"));\n    }\n\n    SECTION(\"Different cases\") {\n        REQUIRE(is_phrase_in_string_ignore_case(\"HELLO\", \"hello there!\"));\n        REQUIRE(is_phrase_in_string_ignore_case(\"world\", \"WORLD is great\"));\n    }\n\n    SECTION(\"Non-existent phrase\") {\n        REQUIRE_FALSE(is_phrase_in_string_ignore_case(\"goodbye\", \"Hello world\"));\n        REQUIRE_FALSE(is_phrase_in_string_ignore_case(\"hello\", \"goodbye world\"));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Check if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n *\n * @param phrase The phrase to search for in the string.\n * @param string The target string in which to search for the phrase.\n *\n * @return True if the phrase is found as a whole word in the string, False otherwise.\n */\nbool is_phrase_in_string_ignore_case(const std::string& phrase, const std::string& string) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n *\n * @param phrase The phrase to search for in the string.\n * @param string The target string in which to search for the phrase.\n * @return True if the phrase is found as a whole word in the string, False otherwise.\n */\npublic static boolean isPhraseInStringIgnoreCase(String phrase, String string) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Test class for verifying the functionality of the isPhraseInStringIgnoreCase method.\n */\npublic class Tester {\n\n    /**\n     * Tests that an exact match is found when ignoring case.\n     */\n    @Test\n    public void testExactMatchCaseInsensitive() {\n        assertTrue(isPhraseInStringIgnoreCase(\"hello world\", \"Hello World\"));\n    }\n\n    /**\n     * Tests that a partial word match is found when ignoring case.\n     */\n    @Test\n    public void testPartialWordMatchCaseInsensitive() {\n        assertTrue(isPhraseInStringIgnoreCase(\"Hello\", \"saying Hello there\"));\n    }\n\n    /**\n     * Tests different cases where the phrase is present but with varying capitalization.\n     */\n    @Test\n    public void testDifferentCases() {\n        assertTrue(isPhraseInStringIgnoreCase(\"HELLO\", \"hello there!\"));\n        assertTrue(isPhraseInStringIgnoreCase(\"world\", \"WORLD is great\"));\n    }\n\n    /**\n     * Tests cases where the phrase does not exist in the string.\n     */\n    @Test\n    public void testNonExistentPhrase() {\n        assertFalse(isPhraseInStringIgnoreCase(\"goodbye\", \"Hello world\"));\n        assertFalse(isPhraseInStringIgnoreCase(\"hello\", \"goodbye world\"));\n    }\n}\n\n// The isPhraseInStringIgnoreCase method remains the same as before\npublic class Answer {\n\n    /**\n     * Checks if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n     *\n     * @param phrase The phrase to search for in the string.\n     * @param string The target string in which to search for the phrase.\n     * @return True if the phrase is found as a whole word in the string, False otherwise.\n     */\n    public static boolean isPhraseInStringIgnoreCase(String phrase, String string) {\n        // Convert both phrase and string to lower case\n        phrase = phrase.toLowerCase();\n        string = string.toLowerCase();\n\n        // Escape special characters in the phrase\n        String escapedPhrase = Pattern.quote(phrase);\n\n        // Replace spaces in the phrase with \\s+ to allow for any whitespace variations\n        escapedPhrase = escapedPhrase.replace(\"\\\\ \", \"\\\\s+\");\n\n        // Construct the regex pattern with word boundaries\n        String pattern = \"\\\\b\" + escapedPhrase + \"\\\\b\";\n\n        // Compile the pattern and create a matcher for the target string\n        Pattern compiledPattern = Pattern.compile(pattern);\n        Matcher matcher = compiledPattern.matcher(string);\n\n        // Search for the pattern in the target string\n        return matcher.find();\n    }\n\n    // Example usage\n    public static void main(String[] args) {\n        System.out.println(isPhraseInStringIgnoreCase(\"hello world\", \"Hello   World\")); // true\n        System.out.println(isPhraseInStringIgnoreCase(\"hello\", \"Hello World\")); // false\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n *\n * @param phrase The phrase to search for in the string.\n * @param string The target string in which to search for the phrase.\n * @return True if the phrase is found as a whole word in the string, False otherwise.\n */\npublic static boolean isPhraseInStringIgnoreCase(String phrase, String string) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 514, "code_type": "method", "original_language": "python", "file_path": "kuda-assistant\\e7b8ef7b819bec85ddf4425660a03e88310f56b4\\utils\\processes.py\n", "question_type": "Data processing and transformation", "summary": "Extracts the date in the format YYYY-MM-DD from the given file name.", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef extract_date_from_filename(file_name: str):\n    \"\"\"\n    Extracts the date in the format YYYY-MM-DD from the given file name.\n\n    Args:\n        file_name (str): The name of the file which may contain a date.\n\n    Returns:\n        str or None: The extracted date string in YYYY-MM-DD format if found, else None.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestExtractDateFromFilename(unittest.TestCase):\n\n    def test_date_extraction_success(self):\n        \"\"\"Test case where the date is successfully extracted.\"\"\"\n        file_name = \"report-2023-09-28.txt\"\n        expected_date = \"2023-09-28\"\n        self.assertEqual(extract_date_from_filename(file_name), expected_date)\n\n    def test_no_date_in_filename(self):\n        \"\"\"Test case where no date is present in the filename.\"\"\"\n        file_name = \"report.txt\"\n        self.assertIsNone(extract_date_from_filename(file_name))\n\n    def test_multiple_dates_in_filename(self):\n        \"\"\"Test case where multiple dates are present, should return the first one.\"\"\"\n        file_name = \"report-2023-09-28-backup-2023-10-01.txt\"\n        expected_date = \"2023-09-28\"\n        self.assertEqual(extract_date_from_filename(file_name), expected_date)\n\n    def test_date_at_start_of_filename(self):\n        \"\"\"Test case where the date is at the start of the filename.\"\"\"\n        file_name = \"2023-09-28-report.txt\"\n        expected_date = \"2023-09-28\"\n        self.assertEqual(extract_date_from_filename(file_name), expected_date)\n\n    def test_incorrect_date_format(self):\n        \"\"\"Test case where the date format is incorrect.\"\"\"\n        file_name = \"report-2023-99-99.txt\"  # Invalid date\n        expected_date = \"2023-99-99\"\n        self.assertEqual(extract_date_from_filename(file_name), expected_date)\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef extract_date_from_filename(file_name: str):\n    \"\"\"\n    Extracts the date in the format YYYY-MM-DD from the given file name.\n\n    Args:\n        file_name (str): The name of the file which may contain a date.\n\n    Returns:\n        str or None: The extracted date string in YYYY-MM-DD format if found, else None.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extracts the date in the format YYYY-MM-DD from the given file name.\n *\n * @param file_name The name of the file which may contain a date.\n * @return A std::string containing the extracted date in YYYY-MM-DD format if found, else an empty string.\n */\nstd::string extract_date_from_filename(const std::string& file_name) {}", "test_code": "TEST_CASE(\"TestExtractDateFromFilename\", \"[extract_date_from_filename]\") {\n    SECTION(\"test_date_extraction_success\") {\n        // Test case where the date is successfully extracted.\n        const std::string file_name = \"report-2023-09-28.txt\";\n        const std::string expected_date = \"2023-09-28\";\n        REQUIRE(extract_date_from_filename(file_name) == expected_date);\n    }\n\n    SECTION(\"test_no_date_in_filename\") {\n        // Test case where no date is present in the filename.\n        const std::string file_name = \"report.txt\";\n        REQUIRE(extract_date_from_filename(file_name).empty());\n    }\n\n    SECTION(\"test_multiple_dates_in_filename\") {\n        // Test case where multiple dates are present, should return the first one.\n        const std::string file_name = \"report-2023-09-28-backup-2023-10-01.txt\";\n        const std::string expected_date = \"2023-09-28\";\n        REQUIRE(extract_date_from_filename(file_name) == expected_date);\n    }\n\n    SECTION(\"test_date_at_start_of_filename\") {\n        // Test case where the date is at the start of the filename.\n        const std::string file_name = \"2023-09-28-report.txt\";\n        const std::string expected_date = \"2023-09-28\";\n        REQUIRE(extract_date_from_filename(file_name) == expected_date);\n    }\n\n    SECTION(\"test_incorrect_date_format\") {\n        // Test case where the date format is incorrect.\n        const std::string file_name = \"report-2023-99-99.txt\";  // Invalid date\n        const std::string expected_date = \"\";  // Since the regex does not match, it should return an empty string\n        REQUIRE(extract_date_from_filename(file_name).empty());\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts the date in the format YYYY-MM-DD from the given file name.\n *\n * @param file_name The name of the file which may contain a date.\n * @return A std::string containing the extracted date in YYYY-MM-DD format if found, else an empty string.\n */\nstd::string extract_date_from_filename(const std::string& file_name) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Extracts the date in the format YYYY-MM-DD from the given file name.\n *\n * @param fileName The name of the file which may contain a date.\n * @return The extracted date string in YYYY-MM-DD format if found, else null.\n */\npublic static String extractDateFromFilename(String fileName) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Test cases for the extractDateFromFilename method.\n */\npublic class Tester {\n\n    /**\n     * Test case where the date is successfully extracted.\n     */\n    @Test\n    public void testDateExtractionSuccess() {\n        String fileName = \"report-2023-09-28.txt\";\n        String expectedDate = \"2023-09-28\";\n        assertEquals(expectedDate, extractDateFromFilename(fileName));\n    }\n\n    /**\n     * Test case where no date is present in the filename.\n     */\n    @Test\n    public void testNoDateInFilename() {\n        String fileName = \"report.txt\";\n        assertNull(extractDateFromFilename(fileName));\n    }\n\n    /**\n     * Test case where multiple dates are present, should return the first one.\n     */\n    @Test\n    public void testMultipleDatesInFilename() {\n        String fileName = \"report-2023-09-28-backup-2023-10-01.txt\";\n        String expectedDate = \"2023-09-28\";\n        assertEquals(expectedDate, extractDateFromFilename(fileName));\n    }\n\n    /**\n     * Test case where the date is at the start of the filename.\n     */\n    @Test\n    public void testDateAtStartOfFile() {\n        String fileName = \"2023-09-28-report.txt\";\n        String expectedDate = \"2023-09-28\";\n        assertEquals(expectedDate, extractDateFromFilename(fileName));\n    }\n\n    /**\n     * Test case where the date format is incorrect.\n     */\n    @Test\n    public void testIncorrectDateFormat() {\n        String fileName = \"report-2023-99-99.txt\";  // Invalid date\n        String expectedDate = \"2023-99-99\";\n        assertEquals(expectedDate, extractDateFromFilename(fileName));\n    }\n\n    // Utility method to extract the date from the filename\n    private String extractDateFromFilename(String fileName) {\n        // Define the regex pattern for matching a date in the format YYYY-MM-DD\n        Pattern datePattern = Pattern.compile(\"\\\\d{4}-\\\\d{2}-\\\\d{2}\");\n\n        // Search for the date pattern in the file name\n        Matcher matcher = datePattern.matcher(fileName);\n\n        // If a match is found, return the matched date; otherwise, return null\n        if (matcher.find()) {\n            return matcher.group(0);\n        } else {\n            return null;\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts the date in the format YYYY-MM-DD from the given file name.\n *\n * @param fileName The name of the file which may contain a date.\n * @return The extracted date string in YYYY-MM-DD format if found, else null.\n */\npublic static String extractDateFromFilename(String fileName) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 515, "code_type": "method", "original_language": "python", "file_path": "kuda-assistant\\e7b8ef7b819bec85ddf4425660a03e88310f56b4\\utils\\processes.py\n", "question_type": "Data processing and transformation", "summary": "    Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n    to the format '%Y-%m-%d_%H:%M:%S'.", "language_version_list": {"python": {"code_signature": "from datetime import datetime\n\ndef format_date_string(date_str:str):\n    \"\"\"\n    Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n    to the format '%Y-%m-%d_%H:%M:%S'.\n\n    Args:\n        date_str (str): The input date string.\n\n    Returns:\n        str: The formatted date string in the format '%Y-%m-%d_%H:%M:%S'.\n        None: If the input date string is invalid.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFormatDateString(unittest.TestCase):\n\n    def test_valid_date_conversion(self):\n        \"\"\"Test case for a valid date string.\"\"\"\n        date_str = \"Fri, 28 Sep 2023 14:45:00 +0000 (UTC)\"\n        expected_date = \"2023-09-28_14:45:00\"\n        self.assertEqual(format_date_string(date_str), expected_date)\n\n    def test_invalid_date_format(self):\n        \"\"\"Test case for an invalid date string format.\"\"\"\n        date_str = \"Invalid date format\"\n        self.assertIsNone(format_date_string(date_str))\n\n    def test_missing_components(self):\n        \"\"\"Test case for a date string missing components.\"\"\"\n        date_str = \"Fri, 28 Sep 2023 14:45:00 +0000\"\n        self.assertIsNone(format_date_string(date_str))\n\n    def test_edge_case_date(self):\n        \"\"\"Test case for an edge case date string (e.g., leap year).\"\"\"\n        date_str = \"Sun, 29 Feb 2024 14:45:00 +0000 (UTC)\"\n        expected_date = \"2024-02-29_14:45:00\"\n        self.assertEqual(format_date_string(date_str), expected_date)", "prompt": "please write a python function , the function signature as below from datetime import datetime\n\ndef format_date_string(date_str:str):\n    \"\"\"\n    Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n    to the format '%Y-%m-%d_%H:%M:%S'.\n\n    Args:\n        date_str (str): The input date string.\n\n    Returns:\n        str: The formatted date string in the format '%Y-%m-%d_%H:%M:%S'.\n        None: If the input date string is invalid.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a date string from one format to another.\n *\n * @param date_str The input date string to convert.\n *\n * @return The formatted date string in the format '%Y-%m-%d_%H:%M:%S'.\n *         Returns an empty string if the input date string is invalid.\n */\nstd::string format_date_string(const std::string& date_str) {\n\n}", "test_code": "TEST_CASE(\"TestFormatDateString\", \"[format_date_string]\") {\n    SECTION(\"test_valid_date_conversion\") {\n        const std::string date_str = \"Fri, 28 Sep 2023 14:45:00 +0000 (UTC)\";\n        const std::string expected_date = \"2023-09-28_14:45:00\";\n        REQUIRE(format_date_string(date_str) == expected_date);\n    }\n\n    SECTION(\"test_invalid_date_format\") {\n        const std::string date_str = \"Invalid date format\";\n        REQUIRE(format_date_string(date_str).empty());\n    }\n\n    SECTION(\"test_missing_components\") {\n        const std::string date_str = \"Fri, 28 Sep 2023 14:45:00 +0000\";\n        REQUIRE(format_date_string(date_str).empty());\n    }\n\n    SECTION(\"test_edge_case_date\") {\n        const std::string date_str = \"Sun, 29 Feb 2024 14:45:00 +0000 (UTC)\";\n        const std::string expected_date = \"2024-02-29_14:45:00\";\n        REQUIRE(format_date_string(date_str) == expected_date);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a date string from one format to another.\n *\n * @param date_str The input date string to convert.\n *\n * @return The formatted date string in the format '%Y-%m-%d_%H:%M:%S'.\n *         Returns an empty string if the input date string is invalid.\n */\nstd::string format_date_string(const std::string& date_str) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n * to the format '%Y-%m-%d_%H:%M:%S'.\n *\n * @param dateStr The input date string.\n * @return The formatted date string in the format '%Y-%m-%d_%H:%M:%S', or null if the input date string is invalid.\n */\npublic static String formatDateString(String dateStr) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * Test cases for the formatDateString method.\n */\npublic class Tester {\n\n    /**\n     * Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n     * to the format '%Y-%m-%d_%H:%M:%S'.\n     *\n     * @param dateStr The input date string.\n     * @return The formatted date string in the format '%Y-%m-%d_%H:%M:%S', or null if the input date string is invalid.\n     */\n    public static String formatDateString(String dateStr) {\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz (Z)\");\n        SimpleDateFormat outputFormat = new SimpleDateFormat(\"yyyy-MM-dd_HH:mm:ss\");\n\n        try {\n            // Parse the input date string to a Date object\n            Date dateObject = inputFormat.parse(dateStr);\n\n            // Format the Date object to the desired output format\n            String formattedDate = outputFormat.format(dateObject);\n\n            return formattedDate;\n        } catch (ParseException e) {\n            System.out.println(\"Error parsing date: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    @Test\n    public void testValidDateConversion() {\n        String dateStr = \"Fri, 28 Sep 2023 14:45:00 +0000 (UTC)\";\n        String expectedDate = \"2023-09-28_14:45:00\";\n        assertEquals(expectedDate, formatDateString(dateStr));\n    }\n\n    @Test\n    public void testInvalidDateFormat() {\n        String dateStr = \"Invalid date format\";\n        assertNull(formatDateString(dateStr));\n    }\n\n    @Test\n    public void testMissingComponents() {\n        String dateStr = \"Fri, 28 Sep 2023 14:45:00 +0000\";\n        assertNull(formatDateString(dateStr));\n    }\n\n    @Test\n    public void testEdgeCaseDate() {\n        String dateStr = \"Sun, 29 Feb 2024 14:45:00 +0000 (UTC)\";\n        String expectedDate = \"2024-02-29_14:45:00\";\n        assertEquals(expectedDate, formatDateString(dateStr));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n * to the format '%Y-%m-%d_%H:%M:%S'.\n *\n * @param dateStr The input date string.\n * @return The formatted date string in the format '%Y-%m-%d_%H:%M:%S', or null if the input date string is invalid.\n */\npublic static String formatDateString(String dateStr) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 516, "code_type": "method", "original_language": "python", "file_path": "prompt-optimizer\\ea72ca56973559ad5d37b38da96caa22cfb2310d\\evaluations\\utils.py\n", "question_type": "File operations and I/O operation", "summary": "Reads a YAML file and returns its content as a Python dictionary or list.", "language_version_list": {"python": {"code_signature": "import os\n\n\ndef read_yaml(file_path: str):\n    \"\"\"\n    Reads a YAML file and returns its content as a Python dictionary or list.\n\n    Args:\n        file_path (str): The path to the YAML file.\n\n    Returns:\n        dict or list: Parsed YAML content as a Python data structure.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        yaml.YAMLError: If there is an error parsing the YAML file.\n    \"\"\"", "test_code": "import os\nimport unittest\n\nimport yaml\n\n\nclass TestReadYaml(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create a temporary YAML file for testing.\"\"\"\n        self.valid_yaml_file = 'test_valid.yaml'\n        self.invalid_yaml_file = 'test_invalid.yaml'\n        self.non_existent_file = 'non_existent.yaml'\n\n        # Valid YAML content\n        with open(self.valid_yaml_file, 'w') as file:\n            file.write(\"name: Example\\nversion: 1.0\\ndependencies:\\n  - package1\\n  - package2\\n\")\n\n        # Invalid YAML content\n        with open(self.invalid_yaml_file, 'w') as file:\n            file.write(\"name: Example\\nversion: 1.0\\ndependencies:\\n  - package1\\n  - package2\\ninvalid_yaml: \\n - \")\n\n    def tearDown(self):\n        \"\"\"Remove the temporary YAML files after testing.\"\"\"\n        if os.path.isfile(self.valid_yaml_file):\n            os.remove(self.valid_yaml_file)\n        if os.path.isfile(self.invalid_yaml_file):\n            os.remove(self.invalid_yaml_file)\n\n    def test_read_valid_yaml(self):\n        \"\"\"Test reading a valid YAML file.\"\"\"\n        expected_data = {\n            'name': 'Example',\n            'version': 1.0,\n            'dependencies': ['package1', 'package2']\n        }\n        result = read_yaml(self.valid_yaml_file)\n        self.assertEqual(result, expected_data)\n\n    def test_file_not_found(self):\n        \"\"\"Test for FileNotFoundError when the file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            read_yaml(self.non_existent_file)\n\n\n    def test_empty_yaml_file(self):\n        \"\"\"Test reading an empty YAML file.\"\"\"\n        empty_yaml_file = 'test_empty.yaml'\n        with open(empty_yaml_file, 'w') as file:\n            file.write(\"\")  # Create an empty YAML file\n\n        result = read_yaml(empty_yaml_file)\n        self.assertIsNone(result)  # Expecting None for empty file\n\n        os.remove(empty_yaml_file)  # Cleanup after the test", "prompt": "please write a python function , the function signature as below import os\n\n\ndef read_yaml(file_path: str):\n    \"\"\"\n    Reads a YAML file and returns its content as a Python dictionary or list.\n\n    Args:\n        file_path (str): The path to the YAML file.\n\n    Returns:\n        dict or list: Parsed YAML content as a Python data structure.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        yaml.YAMLError: If there is an error parsing the YAML file.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads a YAML file and returns its content as a YAML node.\n *\n * @param file_path The path to the YAML file.\n * @return Parsed YAML content as a YAML node.\n * @throws std::runtime_error If the specified file does not exist or there is an error parsing the YAML file.\n */\nYAML::Node read_yaml(const std::string& file_path) {}", "test_code": "namespace fs = std::filesystem;\n\nTEST_CASE(\"TestReadYaml\", \"[YAML]\") {\n    const std::string valid_yaml_file = \"test_valid.yaml\";\n    const std::string invalid_yaml_file = \"test_invalid.yaml\";\n    const std::string non_existent_file = \"non_existent.yaml\";\n    const std::string empty_yaml_file = \"test_empty.yaml\";\n\n    SECTION(\"setUp\") {\n        // Valid YAML content\n        std::ofstream valid_file(valid_yaml_file);\n        valid_file << \"name: Example\\nversion: 1.0\\ndependencies:\\n  - package1\\n  - package2\\n\";\n        valid_file.close();\n\n        // Invalid YAML content\n        std::ofstream invalid_file(invalid_yaml_file);\n        invalid_file << \"name: Example\\nversion: 1.0\\ndependencies:\\n  - package1\\n  - package2\\ninvalid_yaml: \\n - \";\n        invalid_file.close();\n    }\n\n    SECTION(\"tearDown\") {\n        if (fs::exists(valid_yaml_file)) {\n            fs::remove(valid_yaml_file);\n        }\n        if (fs::exists(invalid_yaml_file)) {\n            fs::remove(invalid_yaml_file);\n        }\n        if (fs::exists(empty_yaml_file)) {\n            fs::remove(empty_yaml_file);\n        }\n    }\n\n    SECTION(\"test_read_valid_yaml\") {\n        // Test reading a valid YAML file\n        YAML::Node expected_data = YAML::Load(\n            \"name: Example\\n\"\n            \"version: 1.0\\n\"\n            \"dependencies:\\n\"\n            \"  - package1\\n\"\n            \"  - package2\\n\"\n        );\n\n        YAML::Node result = read_yaml(valid_yaml_file);\n        REQUIRE(result == expected_data);\n    }\n\n    SECTION(\"test_file_not_found\") {\n        // Test for FileNotFoundError when the file does not exist\n        REQUIRE_THROWS_AS(read_yaml(non_existent_file), std::runtime_error);\n    }\n\n    SECTION(\"test_empty_yaml_file\") {\n        // Test reading an empty YAML file\n        std::ofstream empty_file(empty_yaml_file);\n        empty_file << \"\";  // Create an empty YAML file\n        empty_file.close();\n\n        YAML::Node result = read_yaml(empty_yaml_file);\n        REQUIRE(result.IsNull());  // Expecting an empty node for an empty file\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads a YAML file and returns its content as a YAML node.\n *\n * @param file_path The path to the YAML file.\n * @return Parsed YAML content as a YAML node.\n * @throws std::runtime_error If the specified file does not exist or there is an error parsing the YAML file.\n */\nYAML::Node read_yaml(const std::string& file_path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads a YAML file and returns its content as a Java data structure (Map or List).\n *\n * @param filePath The path to the YAML file.\n * @return The parsed YAML content as a Java data structure.\n * @throws FileNotFoundException If the specified file does not exist.\n * @throws ReaderException If there is an error parsing the YAML file.\n */\npublic Object readYaml(String filePath) throws FileNotFoundException, ReaderException {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.yaml.snakeyaml.Yaml;\nimport org.yaml.snakeyaml.constructor.Constructor;\nimport org.yaml.snakeyaml.reader.ReaderException;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\n/**\n * Test class for reading YAML files.\n */\npublic class Tester {\n\n    private String validYamlFile = \"test_valid.yaml\";\n    private String invalidYamlFile = \"test_invalid.yaml\";\n    private String nonExistentFile = \"non_existent.yaml\";\n    private String emptyYamlFile = \"test_empty.yaml\";\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        // Valid YAML content\n        try (FileWriter writer = new FileWriter(validYamlFile)) {\n            writer.write(\"name: Example\\nversion: 1.0\\ndependencies:\\n  - package1\\n  - package2\\n\");\n        }\n\n        // Invalid YAML content\n        try (FileWriter writer = new FileWriter(invalidYamlFile)) {\n            writer.write(\"name: Example\\nversion: 1.0\\ndependencies:\\n  - package1\\n  - package2\\ninvalid_yaml: \\n - \");\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        // Remove the temporary YAML files after testing\n        new File(validYamlFile).delete();\n        new File(invalidYamlFile).delete();\n        new File(emptyYamlFile).delete();\n    }\n\n    @Test\n    public void testReadValidYaml() throws IOException {\n        // Test reading a valid YAML file\n        Map<String, Object> expectedData = Map.of(\n            \"name\", \"Example\",\n            \"version\", 1.0,\n            \"dependencies\", new String[]{\"package1\", \"package2\"}\n        );\n\n        Object result = readYaml(validYamlFile);\n        assertEquals(expectedData, result);\n    }\n\n    @Test\n    public void testFileNotFound() {\n        // Test for FileNotFoundError when the file does not exist\n        assertThrows(FileNotFoundException.class, () -> readYaml(nonExistentFile));\n    }\n\n    @Test\n    public void testEmptyYamlFile() throws IOException {\n        // Test reading an empty YAML file\n        try (FileWriter writer = new FileWriter(emptyYamlFile)) {\n            writer.write(\"\");  // Create an empty YAML file\n        }\n\n        Object result = readYaml(emptyYamlFile);\n        assertEquals(null, result);  // Expecting null for empty file\n    }\n\n    /**\n     * Reads a YAML file and returns its content as a Java data structure.\n     *\n     * @param filePath The path to the YAML file.\n     * @return The parsed YAML content as a Java data structure.\n     * @throws FileNotFoundException If the specified file does not exist.\n     * @throws ReaderException If there is an error parsing the YAML file.\n     */\n    private Object readYaml(String filePath) throws FileNotFoundException, ReaderException {\n        File file = new File(filePath);\n        if (!file.isFile()) {\n            throw new FileNotFoundException(\"The file '\" + filePath + \"' does not exist.\");\n        }\n\n        try (FileInputStream inputStream = new FileInputStream(file)) {\n            Yaml yaml = new Yaml(new Constructor(Object.class));\n            return yaml.load(inputStream);\n        } catch (ReaderException e) {\n            throw new ReaderException(\"Error parsing YAML file: \" + e.getMessage());\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Reads a YAML file and returns its content as a Java data structure (Map or List).\n *\n * @param filePath The path to the YAML file.\n * @return The parsed YAML content as a Java data structure.\n * @throws FileNotFoundException If the specified file does not exist.\n * @throws ReaderException If there is an error parsing the YAML file.\n */\npublic Object readYaml(String filePath) throws FileNotFoundException, ReaderException {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 517, "code_type": "method", "original_language": "python", "file_path": "prompt-optimizer\\ea72ca56973559ad5d37b38da96caa22cfb2310d\\evaluations\\utils.py\n", "question_type": "File operations and I/O operation", "summary": "Reads a JSON Lines file and returns its content as a list of dictionaries.", "language_version_list": {"python": {"code_signature": "import json\nimport os\nfrom typing import List, Dict, Any\n\ndef read_jsonl(file_path: str) -> List[Dict[str, Any]]:\n    \"\"\"\n    Reads a JSON Lines file and returns its content as a list of dictionaries.\n\n    Args:\n        file_path (str): The path to the JSON Lines file.\n\n    Returns:\n        List[Dict[str, Any]]: A list of JSON objects parsed from the file.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        json.JSONDecodeError: If there is an error parsing a line in the JSON Lines file.\n    \"\"\"", "test_code": "import json\nimport os\nimport unittest\n\n\nclass TestReadJsonl(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create temporary JSON Lines files for testing.\"\"\"\n        self.valid_jsonl_file = 'test_valid.jsonl'\n        self.invalid_jsonl_file = 'test_invalid.jsonl'\n        self.non_existent_file = 'non_existent.jsonl'\n\n        # Valid JSON Lines content\n        with open(self.valid_jsonl_file, 'w') as file:\n            file.write('{\"name\": \"Alice\", \"age\": 30}\\n')\n            file.write('{\"name\": \"Bob\", \"age\": 25}\\n')\n            file.write('{\"name\": \"Charlie\", \"age\": 35}\\n')\n\n        # Invalid JSON Lines content\n        with open(self.invalid_jsonl_file, 'w') as file:\n            file.write('{\"name\": \"Alice\", \"age\": 30}\\n')\n            file.write('{\"name\": \"Bob\", \"age\": \"twenty-five}\\n')  # Missing closing quote\n\n    def tearDown(self):\n        \"\"\"Remove the temporary JSON Lines files after testing.\"\"\"\n        if os.path.isfile(self.valid_jsonl_file):\n            os.remove(self.valid_jsonl_file)\n        if os.path.isfile(self.invalid_jsonl_file):\n            os.remove(self.invalid_jsonl_file)\n\n    def test_read_valid_jsonl(self):\n        \"\"\"Test reading a valid JSON Lines file.\"\"\"\n        expected_data = [\n            {\"name\": \"Alice\", \"age\": 30},\n            {\"name\": \"Bob\", \"age\": 25},\n            {\"name\": \"Charlie\", \"age\": 35}\n        ]\n        result = read_jsonl(self.valid_jsonl_file)\n        self.assertEqual(result, expected_data)\n\n    def test_file_not_found(self):\n        \"\"\"Test for FileNotFoundError when the file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            read_jsonl(self.non_existent_file)\n\n    def test_empty_jsonl_file(self):\n        \"\"\"Test reading an empty JSON Lines file.\"\"\"\n        empty_jsonl_file = 'test_empty.jsonl'\n        with open(empty_jsonl_file, 'w') as file:\n            file.write(\"\")  # Create an empty JSON Lines file\n\n        result = read_jsonl(empty_jsonl_file)\n        self.assertEqual(result, [])  # Expecting an empty list for empty file\n\n        os.remove(empty_jsonl_file)  # Cleanup after the test", "prompt": "please write a python function , the function signature as below import json\nimport os\nfrom typing import List, Dict, Any\n\ndef read_jsonl(file_path: str) -> List[Dict[str, Any]]:\n    \"\"\"\n    Reads a JSON Lines file and returns its content as a list of dictionaries.\n\n    Args:\n        file_path (str): The path to the JSON Lines file.\n\n    Returns:\n        List[Dict[str, Any]]: A list of JSON objects parsed from the file.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        json.JSONDecodeError: If there is an error parsing a line in the JSON Lines file.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads a JSON Lines file and returns its content as a list of dictionaries.\n *\n * @param file_path The path to the JSON Lines file.\n * @return A list of JSON objects parsed from the file.\n * @throws std::runtime_error If the specified file does not exist.\n * @throws std::runtime_error If there is an error parsing a line in the JSON Lines file.\n */\njson_list read_jsonl(const std::string& file_path) {}", "test_code": "TEST_CASE(\"Test reading JSON Lines files\", \"[jsonl]\") {\n    // Create temporary JSON Lines files for testing\n    const std::string valid_jsonl_file = \"test_valid.jsonl\";\n    const std::string invalid_jsonl_file = \"test_invalid.jsonl\";\n    const std::string non_existent_file = \"non_existent.jsonl\";\n    const std::string empty_jsonl_file = \"test_empty.jsonl\";\n\n    // Valid JSON Lines content\n    {\n        std::ofstream file(valid_jsonl_file);\n        file << R\"({\"name\": \"Alice\", \"age\": 30})\\n\";\n        file << R\"({\"name\": \"Bob\", \"age\": 25})\\n\";\n        file << R\"({\"name\": \"Charlie\", \"age\": 35})\\n\";\n    }\n\n    // Invalid JSON Lines content\n    {\n        std::ofstream file(invalid_jsonl_file);\n        file << R\"({\"name\": \"Alice\", \"age\": 30})\\n\";\n        file << R\"({\"name\": \"Bob\", \"age\": \"twenty-five}\\n\");  // Missing closing quote\n    }\n\n    // Empty JSON Lines file\n    {\n        std::ofstream file(empty_jsonl_file);\n        file << \"\";  // Create an empty JSON Lines file\n    }\n\n    SECTION(\"Test reading a valid JSON Lines file\") {\n        json_list expected_data = {\n            json{{\"name\", \"Alice\"}, {\"age\", 30}},\n            json{{\"name\", \"Bob\"}, {\"age\", 25}},\n            json{{\"name\", \"Charlie\"}, {\"age\", 35}}\n        };\n\n        json_list result = read_jsonl(valid_jsonl_file);\n        REQUIRE(result == expected_data);\n    }\n\n    SECTION(\"Test for FileNotFoundError when the file does not exist\") {\n        REQUIRE_THROWS_AS(read_jsonl(non_existent_file), std::runtime_error);\n    }\n\n    SECTION(\"Test reading an empty JSON Lines file\") {\n        json_list result = read_jsonl(empty_jsonl_file);\n        REQUIRE(result.empty());\n    }\n\n    // Remove the temporary JSON Lines files after testing\n    if (fs::exists(valid_jsonl_file)) {\n        fs::remove(valid_jsonl_file);\n    }\n    if (fs::exists(invalid_jsonl_file)) {\n        fs::remove(invalid_jsonl_file);\n    }\n    if (fs::exists(empty_jsonl_file)) {\n        fs::remove(empty_jsonl_file);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads a JSON Lines file and returns its content as a list of dictionaries.\n *\n * @param file_path The path to the JSON Lines file.\n * @return A list of JSON objects parsed from the file.\n * @throws std::runtime_error If the specified file does not exist.\n * @throws std::runtime_error If there is an error parsing a line in the JSON Lines file.\n */\njson_list read_jsonl(const std::string& file_path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads a JSON Lines file and returns its content as a list of dictionaries.\n *\n * @param filePath The path to the JSON Lines file.\n * @return A list of JSON objects parsed from the file.\n * @throws IOException If the specified file does not exist or there is an error reading the file.\n */\npublic static List<JSONObject> readJsonl(String filePath) throws IOException {\n\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.json.JSONObject;\n\npublic class Tester {\n\n    private static final String VALID_JSONL_FILE = \"test_valid.jsonl\";\n    private static final String INVALID_JSONL_FILE = \"test_invalid.jsonl\";\n    private static final String NON_EXISTENT_FILE = \"non_existent.jsonl\";\n    private static final String EMPTY_JSONL_FILE = \"test_empty.jsonl\";\n\n    @Before\n    public void setUp() throws IOException {\n        // Valid JSON Lines content\n        try (FileWriter writer = new FileWriter(VALID_JSONL_FILE)) {\n            writer.write(\"{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 30}\\n\");\n            writer.write(\"{\\\"name\\\": \\\"Bob\\\", \\\"age\\\": 25}\\n\");\n            writer.write(\"{\\\"name\\\": \\\"Charlie\\\", \\\"age\\\": 35}\\n\");\n        }\n\n        // Invalid JSON Lines content\n        try (FileWriter writer = new FileWriter(INVALID_JSONL_FILE)) {\n            writer.write(\"{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 30}\\n\");\n            writer.write(\"{\\\"name\\\": \\\"Bob\\\", \\\"age\\\": \\\"twenty-five}\\n\");  // Missing closing quote\n        }\n    }\n\n    @After\n    public void tearDown() {\n        // Remove the temporary JSON Lines files after testing\n        new File(VALID_JSONL_FILE).delete();\n        new File(INVALID_JSONL_FILE).delete();\n        new File(EMPTY_JSONL_FILE).delete();\n    }\n\n    @Test\n    public void testReadValidJsonl() throws IOException {\n        // Test reading a valid JSON Lines file\n        List<JSONObject> expectedData = new ArrayList<>();\n        expectedData.add(new JSONObject().put(\"name\", \"Alice\").put(\"age\", 30));\n        expectedData.add(new JSONObject().put(\"name\", \"Bob\").put(\"age\", 25));\n        expectedData.add(new JSONObject().put(\"name\", \"Charlie\").put(\"age\", 35));\n\n        List<JSONObject> result = readJsonl(VALID_JSONL_FILE);\n        assertEquals(expectedData, result);\n    }\n\n    @Test(expected = IOException.class)\n    public void testFileNotFound() throws IOException {\n        // Test for FileNotFoundException when the file does not exist\n        readJsonl(NON_EXISTENT_FILE);\n    }\n\n    @Test\n    public void testEmptyJsonlFile() throws IOException {\n        // Test reading an empty JSON Lines file\n        try (FileWriter writer = new FileWriter(EMPTY_JSONL_FILE)) {\n            writer.write(\"\");  // Create an empty JSON Lines file\n        }\n\n        List<JSONObject> result = readJsonl(EMPTY_JSONL_FILE);\n        assertEquals(new ArrayList<>(), result);\n\n        // Cleanup after the test\n        new File(EMPTY_JSONL_FILE).delete();\n    }\n\n    // Utility method to read JSON Lines file\n    private static List<JSONObject> readJsonl(String filePath) throws IOException {\n        // Check if the file exists\n        File file = new File(filePath);\n        if (!file.exists()) {\n            throw new IOException(\"The file '\" + filePath + \"' does not exist.\");\n        }\n\n        List<JSONObject> jsonList = new ArrayList<>();\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                try {\n                    JSONObject jsonObject = new JSONObject(new JSONTokener(line));\n                    jsonList.add(jsonObject);\n                } catch (Exception e) {\n                    throw new IOException(\"Error parsing line: \" + line.trim() + \" - \" + e.getMessage());\n                }\n            }\n        }\n\n        return jsonList;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Reads a JSON Lines file and returns its content as a list of dictionaries.\n *\n * @param filePath The path to the JSON Lines file.\n * @return A list of JSON objects parsed from the file.\n * @throws IOException If the specified file does not exist or there is an error reading the file.\n */\npublic static List<JSONObject> readJsonl(String filePath) throws IOException {\n\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 518, "code_type": "method", "original_language": "python", "file_path": "TRGB-BikeComputer\\2537af5d089f764d74269c04410485827529af7b\\Tools\\csv2influx.py\n", "question_type": "Data processing and transformation", "summary": "Convert numeric values in a CSV row from string format to a standardized format.", "language_version_list": {"python": {"code_signature": "from typing import Dict, Optional\n\ndef convert_csv_values(row: Dict[str, str]) -> Dict[str, Optional[str]]:\n    \"\"\"\n    Convert numeric values in a CSV row from string format to a standardized format.\n\n    Args:\n        row (Dict[str, str]): A dictionary representing a row of CSV data where\n                               keys are column names and values are strings.\n\n    Returns:\n        Dict[str, Optional[str]]: A new dictionary with values converted:\n                                   - Numeric strings have commas replaced with dots.\n                                   - Non-numeric strings are set to None.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestConvertCsvValues(unittest.TestCase):\n\n    def test_valid_numeric_strings(self):\n        \"\"\"Test with valid numeric strings including commas.\"\"\"\n        row = {'value1': '1,234', 'value2': '5,678', 'value3': '9,876'}\n        expected = {'value1': '1.234', 'value2': '5.678', 'value3': '9.876'}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n\n    def test_non_numeric_strings(self):\n        \"\"\"Test with non-numeric strings.\"\"\"\n        row = {'value1': 'not_a_number', 'value2': 'hello', 'value3': 'world'}\n        expected = {'value1': None, 'value2': None, 'value3': None}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n\n    def test_mixed_values(self):\n        \"\"\"Test with a mix of numeric and non-numeric strings.\"\"\"\n        row = {'value1': '1,234', 'value2': 'not_a_number', 'value3': '3,14159'}\n        expected = {'value1': '1.234', 'value2': None, 'value3': '3.14159'}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n\n    def test_no_values(self):\n        row = {'value1': 'aaaa', 'value2': 'not_a_number', 'value3': '3,14'}\n        expected = {'value1': None, 'value2': None, 'value3': '3.14'}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n\n    def test_edge_cases(self):\n        \"\"\"Test edge cases with empty strings and negative numbers.\"\"\"\n        row = {'value1': '', 'value2': '0.0', 'value3': '1,23'}\n        expected = {'value1': None, 'value2': '0.0', 'value3': '1.23'}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import Dict, Optional\n\ndef convert_csv_values(row: Dict[str, str]) -> Dict[str, Optional[str]]:\n    \"\"\"\n    Convert numeric values in a CSV row from string format to a standardized format.\n\n    Args:\n        row (Dict[str, str]): A dictionary representing a row of CSV data where\n                               keys are column names and values are strings.\n\n    Returns:\n        Dict[str, Optional[str]]: A new dictionary with values converted:\n                                   - Numeric strings have commas replaced with dots.\n                                   - Non-numeric strings are set to None.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert numeric values in a CSV row from string format to a standardized format.\n *\n * @param row A map representing a row of CSV data where keys are column names and values are strings.\n * @return A new map with values converted:\n *         - Numeric strings have commas replaced with dots.\n *         - Non-numeric strings are set to an empty string (to represent None).\n */\nstd::map<std::string, std::string> convert_csv_values(const std::map<std::string, std::string>& row) {}", "test_code": "#include <catch2/catch_test_macros.hpp>\n#include <map>\n#include <string>\n#include <cctype>\n\nTEST_CASE(\"TestConvertCsvValues\", \"[convert_csv_values]\") {\n    SECTION(\"test_valid_numeric_strings\") {\n        std::map<std::string, std::string> row = {\n            {\"value1\", \"1,234\"},\n            {\"value2\", \"5,678\"},\n            {\"value3\", \"9,876\"}\n        };\n        std::map<std::string, std::string> expected = {\n            {\"value1\", \"1.234\"},\n            {\"value2\", \"5.678\"},\n            {\"value3\", \"9.876\"}\n        };\n        auto result = convert_csv_values(row);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_non_numeric_strings\") {\n        std::map<std::string, std::string> row = {\n            {\"value1\", \"not_a_number\"},\n            {\"value2\", \"hello\"},\n            {\"value3\", \"world\"}\n        };\n        std::map<std::string, std::string> expected = {\n            {\"value1\", \"\"},\n            {\"value2\", \"\"},\n            {\"value3\", \"\"}\n        };\n        auto result = convert_csv_values(row);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_mixed_values\") {\n        std::map<std::string, std::string> row = {\n            {\"value1\", \"1,234\"},\n            {\"value2\", \"not_a_number\"},\n            {\"value3\", \"3,14159\"}\n        };\n        std::map<std::string, std::string> expected = {\n            {\"value1\", \"1.234\"},\n            {\"value2\", \"\"},\n            {\"value3\", \"3.14159\"}\n        };\n        auto result = convert_csv_values(row);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_no_values\") {\n        std::map<std::string, std::string> row = {\n            {\"value1\", \"aaaa\"},\n            {\"value2\", \"not_a_number\"},\n            {\"value3\", \"3,14\"}\n        };\n        std::map<std::string, std::string> expected = {\n            {\"value1\", \"\"},\n            {\"value2\", \"\"},\n            {\"value3\", \"3.14\"}\n        };\n        auto result = convert_csv_values(row);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_edge_cases\") {\n        std::map<std::string, std::string> row = {\n            {\"value1\", \"\"},\n            {\"value2\", \"0.0\"},\n            {\"value3\", \"1,23\"}\n        };\n        std::map<std::string, std::string> expected = {\n            {\"value1\", \"\"},\n            {\"value2\", \"0.0\"},\n            {\"value3\", \"1.23\"}\n        };\n        auto result = convert_csv_values(row);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert numeric values in a CSV row from string format to a standardized format.\n *\n * @param row A map representing a row of CSV data where keys are column names and values are strings.\n * @return A new map with values converted:\n *         - Numeric strings have commas replaced with dots.\n *         - Non-numeric strings are set to an empty string (to represent None).\n */\nstd::map<std::string, std::string> convert_csv_values(const std::map<std::string, std::string>& row) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Convert numeric values in a CSV row from string format to a standardized format.\n *\n * <p>\n * This method takes a map representing a row of CSV data, where keys are column names and values are strings.\n * It returns a new map with the following conversions:\n * - Numeric strings have commas replaced with dots.\n * - Non-numeric strings are set to null.\n * </p>\n *\n * @param row A map representing a row of CSV data where keys are column names and values are strings.\n * @return A new map with values converted as described above.\n */\npublic static Map<String, String> convertCsvValues(Map<String, String> row) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Tester {\n\n    @Test\n    public void testValidNumericStrings() {\n        Map<String, String> row = new HashMap<>();\n        row.put(\"value1\", \"1,234\");\n        row.put(\"value2\", \"5,678\");\n        row.put(\"value3\", \"9,876\");\n\n        Map<String, String> expected = new HashMap<>();\n        expected.put(\"value1\", \"1.234\");\n        expected.put(\"value2\", \"5.678\");\n        expected.put(\"value3\", \"9.876\");\n\n        Map<String, String> result = convertCsvValues(row);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testNonNumericStrings() {\n        Map<String, String> row = new HashMap<>();\n        row.put(\"value1\", \"not_a_number\");\n        row.put(\"value2\", \"hello\");\n        row.put(\"value3\", \"world\");\n\n        Map<String, String> expected = new HashMap<>();\n        expected.put(\"value1\", null);\n        expected.put(\"value2\", null);\n        expected.put(\"value3\", null);\n\n        Map<String, String> result = convertCsvValues(row);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testMixedValues() {\n        Map<String, String> row = new HashMap<>();\n        row.put(\"value1\", \"1,234\");\n        row.put(\"value2\", \"not_a_number\");\n        row.put(\"value3\", \"3,14159\");\n\n        Map<String, String> expected = new HashMap<>();\n        expected.put(\"value1\", \"1.234\");\n        expected.put(\"value2\", null);\n        expected.put(\"value3\", \"3.14159\");\n\n        Map<String, String> result = convertCsvValues(row);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testNoValues() {\n        Map<String, String> row = new HashMap<>();\n        row.put(\"value1\", \"aaaa\");\n        row.put(\"value2\", \"not_a_number\");\n        row.put(\"value3\", \"3,14\");\n\n        Map<String, String> expected = new HashMap<>();\n        expected.put(\"value1\", null);\n        expected.put(\"value2\", null);\n        expected.put(\"value3\", \"3.14\");\n\n        Map<String, String> result = convertCsvValues(row);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testEdgeCases() {\n        Map<String, String> row = new HashMap<>();\n        row.put(\"value1\", \"\");\n        row.put(\"value2\", \"0.0\");\n        row.put(\"value3\", \"1,23\");\n\n        Map<String, String> expected = new HashMap<>();\n        expected.put(\"value1\", null);\n        expected.put(\"value2\", \"0.0\");\n        expected.put(\"value3\", \"1.23\");\n\n        Map<String, String> result = convertCsvValues(row);\n        assertEquals(expected, result);\n    }\n\n    // Method to be tested\n    private Map<String, String> convertCsvValues(Map<String, String> row) {\n        Map<String, String> convertedRow = new HashMap<>();\n\n        for (Map.Entry<String, String> entry : row.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n\n            // Check if the value is numeric with possible comma and negative sign\n            boolean isNumeric = value.replace(\",\", \"\").replace(\"-\", \"\").matches(\"[0-9]+\");\n\n            if (isNumeric) {\n                // Replace comma with dot for numeric conversion\n                convertedRow.put(key, value.replace(',', '.'));\n            } else {\n                // Set to null if not a valid number\n                convertedRow.put(key, null);\n            }\n        }\n\n        return convertedRow;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Convert numeric values in a CSV row from string format to a standardized format.\n *\n * <p>\n * This method takes a map representing a row of CSV data, where keys are column names and values are strings.\n * It returns a new map with the following conversions:\n * - Numeric strings have commas replaced with dots.\n * - Non-numeric strings are set to null.\n * </p>\n *\n * @param row A map representing a row of CSV data where keys are column names and values are strings.\n * @return A new map with values converted as described above.\n */\npublic static Map<String, String> convertCsvValues(Map<String, String> row) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 519, "code_type": "method", "original_language": "python", "file_path": "gicog\\44da3e0ad3c6c46a8d4d218d69808a9163746038\\alphabetMatrix\\alphabetsToMatrix.py\n", "question_type": "Data processing and transformation", "summary": "Transpose a given matrix (2D array).", "language_version_list": {"python": {"code_signature": "from typing import List\n\ndef transpose_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transpose a given matrix (2D array).\n\n    Args:\n        matrix (List[List[int]]): The input 2D array to be transposed.\n\n    Returns:\n        List[List[int]]: The transposed 2D array.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestTransposeMatrix(unittest.TestCase):\n\n    def test_square_matrix(self):\n        \"\"\"Test transposing a square matrix.\"\"\"\n        matrix = [[1, 2], [3, 4]]\n        expected = [[1, 3], [2, 4]]\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)\n\n    def test_rectangular_matrix(self):\n        \"\"\"Test transposing a rectangular matrix.\"\"\"\n        matrix = [[1, 2, 3], [4, 5, 6]]\n        expected = [[1, 4], [2, 5], [3, 6]]\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)\n\n\n    def test_matrix_with_empty_rows(self):\n        \"\"\"Test transposing a matrix with an empty row.\"\"\"\n        matrix = [[], []]\n        expected = []\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)\n\n    def test_single_element_matrix(self):\n        \"\"\"Test transposing a matrix with a single element.\"\"\"\n        matrix = [[5]]\n        expected = [[5]]\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below from typing import List\n\ndef transpose_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transpose a given matrix (2D array).\n\n    Args:\n        matrix (List[List[int]]): The input 2D array to be transposed.\n\n    Returns:\n        List[List[int]]: The transposed 2D array.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Transpose a given matrix (2D array).\n *\n * @param matrix The input 2D array to be transposed.\n * @return The transposed 2D array.\n */\nstd::vector<std::vector<int>> transpose_matrix(const std::vector<std::vector<int>>& matrix) {}", "test_code": "TEST_CASE(\"Test transposing a square matrix\", \"[transpose_matrix]\") {\n    std::vector<std::vector<int>> matrix = {{1, 2}, {3, 4}};\n    std::vector<std::vector<int>> expected = {{1, 3}, {2, 4}};\n    auto result = transpose_matrix(matrix);\n    REQUIRE(result == expected);\n}\n\nTEST_CASE(\"Test transposing a rectangular matrix\", \"[transpose_matrix]\") {\n    std::vector<std::vector<int>> matrix = {{1, 2, 3}, {4, 5, 6}};\n    std::vector<std::vector<int>> expected = {{1, 4}, {2, 5}, {3, 6}};\n    auto result = transpose_matrix(matrix);\n    REQUIRE(result == expected);\n}\n\nTEST_CASE(\"Test transposing a matrix with an empty row\", \"[transpose_matrix]\") {\n    std::vector<std::vector<int>> matrix = {{}, {}};\n    std::vector<std::vector<int>> expected = {};\n    auto result = transpose_matrix(matrix);\n    REQUIRE(result == expected);\n}\n\nTEST_CASE(\"Test transposing a matrix with a single element\", \"[transpose_matrix]\") {\n    std::vector<std::vector<int>> matrix = {{5}};\n    std::vector<std::vector<int>> expected = {{5}};\n    auto result = transpose_matrix(matrix);\n    REQUIRE(result == expected);\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Transpose a given matrix (2D array).\n *\n * @param matrix The input 2D array to be transposed.\n * @return The transposed 2D array.\n */\nstd::vector<std::vector<int>> transpose_matrix(const std::vector<std::vector<int>>& matrix) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Transpose a given matrix (2D array).\n *\n * @param matrix The input 2D array to be transposed.\n * @return The transposed 2D array.\n */\npublic static List<List<Integer>> transposeMatrix(List<List<Integer>> matrix) {\n\n}", "test_code": "import org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class Tester {\n\n    private List<List<Integer>> transposeMatrix(List<List<Integer>> matrix) {\n        // Check if the matrix is empty\n        if (matrix == null || matrix.isEmpty() || matrix.get(0).isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        int numRows = matrix.size();\n        int numCols = matrix.get(0).size();\n\n        // Initialize the transposed matrix with the correct dimensions\n        List<List<Integer>> transposed = new ArrayList<>();\n        for (int col = 0; col < numCols; col++) {\n            List<Integer> newRow = new ArrayList<>(numRows);\n            for (int row = 0; row < numRows; row++) {\n                newRow.add(0);\n            }\n            transposed.add(newRow);\n        }\n\n        // Populate the transposed matrix\n        for (int i = 0; i < numRows; i++) {\n            for (int j = 0; j < numCols; j++) {\n                transposed.get(j).set(i, matrix.get(i).get(j));\n            }\n        }\n\n        return transposed;\n    }\n\n    @Test\n    public void testSquareMatrix() {\n        List<List<Integer>> matrix = new ArrayList<>();\n        matrix.add(List.of(1, 2));\n        matrix.add(List.of(3, 4));\n        List<List<Integer>> expected = new ArrayList<>();\n        expected.add(List.of(1, 3));\n        expected.add(List.of(2, 4));\n        List<List<Integer>> result = transposeMatrix(matrix);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testRectangularMatrix() {\n        List<List<Integer>> matrix = new ArrayList<>();\n        matrix.add(List.of(1, 2, 3));\n        matrix.add(List.of(4, 5, 6));\n        List<List<Integer>> expected = new ArrayList<>();\n        expected.add(List.of(1, 4));\n        expected.add(List.of(2, 5));\n        expected.add(List.of(3, 6));\n        List<List<Integer>> result = transposeMatrix(matrix);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testMatrixWithEmptyRows() {\n        List<List<Integer>> matrix = new ArrayList<>();\n        matrix.add(new ArrayList<>());\n        matrix.add(new ArrayList<>());\n        List<List<Integer>> expected = new ArrayList<>();\n        List<List<Integer>> result = transposeMatrix(matrix);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testSingleElementMatrix() {\n        List<List<Integer>> matrix = new ArrayList<>();\n        matrix.add(List.of(5));\n        List<List<Integer>> expected = new ArrayList<>();\n        expected.add(List.of(5));\n        List<List<Integer>> result = transposeMatrix(matrix);\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Transpose a given matrix (2D array).\n *\n * @param matrix The input 2D array to be transposed.\n * @return The transposed 2D array.\n */\npublic static List<List<Integer>> transposeMatrix(List<List<Integer>> matrix) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 520, "code_type": "method", "original_language": "python", "file_path": "geometric-algebra\\a5de1818b58da50d2cb7084c4d540238076358c7\\src\\Multivector.py\n", "question_type": "Algorithm and data structure", "summary": "    Computes the output index from two given indices in the MultiVector's representation\n    of the G_n orthonormal basis.", "language_version_list": {"python": {"code_signature": "def compute_output_index(idx_1: int, idx_2: int) -> int:\n    \"\"\"\n    Computes the output index from two given indices in the MultiVector's representation\n    of the G_n orthonormal basis.\n\n    This function interprets the integers as little-endian bitstrings, takes their XOR,\n    and interprets the result as an integer in little-endian.\n\n    Args:\n        idx_1 (int): Input index 1.\n        idx_2 (int): Input index 2.\n\n    Returns:\n        int: The computed output index.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestComputeOutputIndex(unittest.TestCase):\n\n    def test_standard_case(self):\n        \"\"\"Test with two standard positive integers.\"\"\"\n        idx_1 = 3  # binary: 11\n        idx_2 = 5  # binary: 101\n        expected = 6  # 3 XOR 5 = 6\n        result = compute_output_index(idx_1, idx_2)\n        self.assertEqual(result, expected)\n\n    def test_identical_indices(self):\n        \"\"\"Test with identical indices (should return 0).\"\"\"\n        idx_1 = 7  # binary: 111\n        idx_2 = 7  # binary: 111\n        expected = 0  # 7 XOR 7 = 0\n        result = compute_output_index(idx_1, idx_2)\n        self.assertEqual(result, expected)\n\n    def test_zero_index(self):\n        \"\"\"Test with one index as zero.\"\"\"\n        idx_1 = 0  # binary: 0\n        idx_2 = 5  # binary: 101\n        expected = 5  # 0 XOR 5 = 5\n        result = compute_output_index(idx_1, idx_2)\n        self.assertEqual(result, expected)\n\n    def test_large_numbers(self):\n        \"\"\"Test with large integer values.\"\"\"\n        idx_1 = 1024  # binary: 10000000000\n        idx_2 = 2048  # binary: 100000000000\n        expected = 3072  # 1024 XOR 2048 = 3072\n        result = compute_output_index(idx_1, idx_2)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def compute_output_index(idx_1: int, idx_2: int) -> int:\n    \"\"\"\n    Computes the output index from two given indices in the MultiVector's representation\n    of the G_n orthonormal basis.\n\n    This function interprets the integers as little-endian bitstrings, takes their XOR,\n    and interprets the result as an integer in little-endian.\n\n    Args:\n        idx_1 (int): Input index 1.\n        idx_2 (int): Input index 2.\n\n    Returns:\n        int: The computed output index.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/*\n *   Computes the output index from two given indices in the MultiVector's representation\n *   of the G_n orthonormal basis.\n *\n *   This function interprets the integers as little-endian bitstrings, takes their XOR,\n *   and interprets the result as an integer in little-endian.\n *\n *   Args:\n *       idx_1 (uint64_t): Input index 1.\n *       idx_2 (uint64_t): Input index 2.\n *\n *   Returns:\n *       uint64_t: The computed output index.\n */\nuint64_t compute_output_index(uint64_t idx_1, uint64_t idx_2) {\n\n}", "test_code": "#include <catch2/catch_test_macros.hpp>\n#include <cstdint>\n\nTEST_CASE(\"Test Compute Output Index\", \"[compute_output_index]\") {\n    SECTION(\"Test with two standard positive integers\") {\n        uint64_t idx_1 = 3;  // binary: 11\n        uint64_t idx_2 = 5;  // binary: 101\n        uint64_t expected = 6;  // 3 XOR 5 = 6\n        uint64_t result = compute_output_index(idx_1, idx_2);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test with identical indices (should return 0)\") {\n        uint64_t idx_1 = 7;  // binary: 111\n        uint64_t idx_2 = 7;  // binary: 111\n        uint64_t expected = 0;  // 7 XOR 7 = 0\n        uint64_t result = compute_output_index(idx_1, idx_2);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test with one index as zero\") {\n        uint64_t idx_1 = 0;  // binary: 0\n        uint64_t idx_2 = 5;  // binary: 101\n        uint64_t expected = 5;  // 0 XOR 5 = 5\n        uint64_t result = compute_output_index(idx_1, idx_2);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test with large integer values\") {\n        uint64_t idx_1 = 1024;  // binary: 10000000000\n        uint64_t idx_2 = 2048;  // binary: 100000000000\n        uint64_t expected = 3072;  // 1024 XOR 2048 = 3072\n        uint64_t result = compute_output_index(idx_1, idx_2);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /*\n *   Computes the output index from two given indices in the MultiVector's representation\n *   of the G_n orthonormal basis.\n *\n *   This function interprets the integers as little-endian bitstrings, takes their XOR,\n *   and interprets the result as an integer in little-endian.\n *\n *   Args:\n *       idx_1 (uint64_t): Input index 1.\n *       idx_2 (uint64_t): Input index 2.\n *\n *   Returns:\n *       uint64_t: The computed output index.\n */\nuint64_t compute_output_index(uint64_t idx_1, uint64_t idx_2) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Computes the output index from two given indices in the MultiVector's representation\n * of the G_n orthonormal basis.\n *\n * This function interprets the integers as little-endian bitstrings, takes their XOR,\n * and interprets the result as an integer in little-endian.\n *\n * @param idx1 Input index 1.\n * @param idx2 Input index 2.\n * @return The computed output index.\n */\npublic static int computeOutputIndex(int idx1, int idx2) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for the computeOutputIndex method.\n */\npublic class Tester {\n\n    /**\n     * Tests the computeOutputIndex method with two standard positive integers.\n     */\n    @Test\n    public void testStandardCase() {\n        int idx1 = 3;  // binary: 11\n        int idx2 = 5;  // binary: 101\n        int expected = 6;  // 3 XOR 5 = 6\n        int result = computeOutputIndex(idx1, idx2);\n        assertEquals(expected, result);\n    }\n\n    /**\n     * Tests the computeOutputIndex method with identical indices (should return 0).\n     */\n    @Test\n    public void testIdenticalIndices() {\n        int idx1 = 7;  // binary: 111\n        int idx2 = 7;  // binary: 111\n        int expected = 0;  // 7 XOR 7 = 0\n        int result = computeOutputIndex(idx1, idx2);\n        assertEquals(expected, result);\n    }\n\n    /**\n     * Tests the computeOutputIndex method with one index as zero.\n     */\n    @Test\n    public void testZeroIndex() {\n        int idx1 = 0;  // binary: 0\n        int idx2 = 5;  // binary: 101\n        int expected = 5;  // 0 XOR 5 = 5\n        int result = computeOutputIndex(idx1, idx2);\n        assertEquals(expected, result);\n    }\n\n    /**\n     * Tests the computeOutputIndex method with large integer values.\n     */\n    @Test\n    public void testLargeNumbers() {\n        int idx1 = 1024;  // binary: 10000000000\n        int idx2 = 2048;  // binary: 100000000000\n        int expected = 3072;  // 1024 XOR 2048 = 3072\n        int result = computeOutputIndex(idx1, idx2);\n        assertEquals(expected, result);\n    }\n\n    // Utility method to compute the output index\n    private int computeOutputIndex(int idx1, int idx2) {\n        // Perform bitwise XOR between the two indices\n        int result = idx1 ^ idx2;\n\n        // Convert result to little-endian byte representation\n        byte[] resultBytes = intToLittleEndianBytes(result);\n\n        // Convert little-endian bytes back to an integer\n        int resultInt = littleEndianBytesToInt(resultBytes);\n\n        return resultInt;\n    }\n\n    // Helper method to convert an integer to a little-endian byte array\n    private byte[] intToLittleEndianBytes(int value) {\n        byte[] bytes = new byte[4];\n        for (int i = 0; i < 4; i++) {\n            bytes[i] = (byte) (value & 0xFF);\n            value >>>= 8;\n        }\n        return bytes;\n    }\n\n    // Helper method to convert a little-endian byte array back to an integer\n    private int littleEndianBytesToInt(byte[] bytes) {\n        int result = 0;\n        for (int i = 0; i < bytes.length; i++) {\n            result |= (bytes[i] & 0xFF) << (i * 8);\n        }\n        return result;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Computes the output index from two given indices in the MultiVector's representation\n * of the G_n orthonormal basis.\n *\n * This function interprets the integers as little-endian bitstrings, takes their XOR,\n * and interprets the result as an integer in little-endian.\n *\n * @param idx1 Input index 1.\n * @param idx2 Input index 2.\n * @return The computed output index.\n */\npublic static int computeOutputIndex(int idx1, int idx2) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 521, "code_type": "method", "original_language": "python", "file_path": "WM9A4-Digital-Development-with-Python\\67907a0e7f78729083fa6055cf367dba6a0c8f04\\10 practice questions\\word_filter.py\n", "question_type": "Data processing and transformation", "summary": "Counts the occurrences of specified words in the given text.\n\n    This function filters the words from the text based on the provided list,\n    counts their occurrences, and returns a dictionary with the words in the\n    order they were provided.", "language_version_list": {"python": {"code_signature": "import re\nfrom collections import Counter\nfrom typing import List, Dict\n\n\ndef word_filter_counter(text: str, filter_words: List[str]) -> Dict[str, int]:\n    \"\"\"\n    Counts the occurrences of specified words in the given text.\n\n    This function filters the words from the text based on the provided list,\n    counts their occurrences, and returns a dictionary with the words in the\n    order they were provided.\n\n    Args:\n        text (str): The input text from which to count words.\n        filter_words (List[str]): A list of words to filter and count.\n\n    Returns:\n        Dict[str, int]: A dictionary with the count of each filter word in the text,\n                         maintaining the order from filter_words.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestWordFilterCounter(unittest.TestCase):\n\n    def test_case1(self):\n        text = \"go to the school.go to the park.\"\n        filter_words = [\"go\", \"to\", \"the\", \"school\", \"park\", \"play\"]\n        expected_output = {\n            \"go\": 2,\n            \"to\": 2,\n            \"the\": 2,\n            \"school\": 1,\n            \"park\": 1,\n            \"play\": 0\n        }\n        self.assertEqual(word_filter_counter(text, filter_words), expected_output)\n\n    def test_case2(self):\n        text = \"This is a completely different sentence.\"\n        filter_words = [\"I'll\", \"go\", \"to\", \"the\", \"school\", \"park\", \"play\"]\n        expected_output = {\n            \"I'll\": 0,\n            \"go\": 0,\n            \"to\": 0,\n            \"the\": 0,\n            \"school\": 0,\n            \"park\": 0,\n            \"play\": 0\n        }\n        self.assertEqual(word_filter_counter(text, filter_words), expected_output)\n\n    def test_case3(self):\n        text = \"I will not go to the school's park.\"\n        filter_words = [\"I\", \"will\", \"not\", \"go\", \"to\", \"the\", \"school's\", \"park\"]\n        expected_output = {\n            \"I\": 1,\n            \"will\": 1,\n            \"not\": 1,\n            \"go\": 1,\n            \"to\": 1,\n            \"the\": 1,\n            \"school's\": 1,\n            \"park\": 1,\n        }\n        self.assertEqual(word_filter_counter(text, filter_words), expected_output)\n", "prompt": "please write a python function , the function signature as below import re\nfrom collections import Counter\nfrom typing import List, Dict\n\n\ndef word_filter_counter(text: str, filter_words: List[str]) -> Dict[str, int]:\n    \"\"\"\n    Counts the occurrences of specified words in the given text.\n\n    This function filters the words from the text based on the provided list,\n    counts their occurrences, and returns a dictionary with the words in the\n    order they were provided.\n\n    Args:\n        text (str): The input text from which to count words.\n        filter_words (List[str]): A list of words to filter and count.\n\n    Returns:\n        Dict[str, int]: A dictionary with the count of each filter word in the text,\n                         maintaining the order from filter_words.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Counts the occurrences of specified words in the given text.\n *\n * @param text The input text from which to count words.\n * @param filter_words A list of words to filter and count.\n * @return A dictionary with the count of each filter word in the text,\n *         maintaining the order from filter_words.\n */\nstd::unordered_map<std::string, int> word_filter_counter(const std::string& text, const std::vector<std::string>& filter_words) {}", "test_code": "TEST_CASE(\"Test Word Filter Counter\") {\n    SECTION(\"Test Case 1\") {\n        std::string text = \"go to the school.go to the park.\";\n        std::vector<std::string> filter_words = {\"go\", \"to\", \"the\", \"school\", \"park\", \"play\"};\n        std::unordered_map<std::string, int> expected_output = {\n            {\"go\", 2},\n            {\"to\", 2},\n            {\"the\", 2},\n            {\"school\", 1},\n            {\"park\", 1},\n            {\"play\", 0}\n        };\n\n        REQUIRE(word_filter_counter(text, filter_words) == expected_output);\n    }\n\n    SECTION(\"Test Case 2\") {\n        std::string text = \"This is a completely different sentence.\";\n        std::vector<std::string> filter_words = {\"I'll\", \"go\", \"to\", \"the\", \"school\", \"park\", \"play\"};\n        std::unordered_map<std::string, int> expected_output = {\n            {\"I'll\", 0},\n            {\"go\", 0},\n            {\"to\", 0},\n            {\"the\", 0},\n            {\"school\", 0},\n            {\"park\", 0},\n            {\"play\", 0}\n        };\n\n        REQUIRE(word_filter_counter(text, filter_words) == expected_output);\n    }\n\n    SECTION(\"Test Case 3\") {\n        std::string text = \"I will not go to the school's park.\";\n        std::vector<std::string> filter_words = {\"I\", \"will\", \"not\", \"go\", \"to\", \"the\", \"school's\", \"park\"};\n        std::unordered_map<std::string, int> expected_output = {\n            {\"I\", 1},\n            {\"will\", 1},\n            {\"not\", 1},\n            {\"go\", 1},\n            {\"to\", 1},\n            {\"the\", 1},\n            {\"school's\", 1},\n            {\"park\", 1}\n        };\n\n        REQUIRE(word_filter_counter(text, filter_words) == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Counts the occurrences of specified words in the given text.\n *\n * @param text The input text from which to count words.\n * @param filter_words A list of words to filter and count.\n * @return A dictionary with the count of each filter word in the text,\n *         maintaining the order from filter_words.\n */\nstd::unordered_map<std::string, int> word_filter_counter(const std::string& text, const std::vector<std::string>& filter_words) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Counts the occurrences of specified words in the given text.\n *\n * This function filters the words from the text based on the provided list,\n * counts their occurrences, and returns a map with the words in the\n * order they were provided.\n *\n * @param text The input text from which to count words.\n * @param filterWords A list of words to filter and count.\n * @return A map with the count of each filter word in the text,\n *         maintaining the order from filterWords.\n */\npublic static Map<String, Integer> wordFilterCounter(String text, List<String> filterWords) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Test cases for the wordFilterCounter method.\n */\npublic class Tester {\n\n    /**\n     * Test case 1: Verifies the correct count of specified words in the given text.\n     */\n    @Test\n    public void testCase1() {\n        String text = \"go to the school.go to the park.\";\n        List<String> filterWords = Arrays.asList(\"go\", \"to\", \"the\", \"school\", \"park\", \"play\");\n        Map<String, Integer> expectedOutput = new HashMap<>();\n        expectedOutput.put(\"go\", 2);\n        expectedOutput.put(\"to\", 2);\n        expectedOutput.put(\"the\", 2);\n        expectedOutput.put(\"school\", 1);\n        expectedOutput.put(\"park\", 1);\n        expectedOutput.put(\"play\", 0);\n\n        Map<String, Integer> actualOutput = wordFilterCounter(text, filterWords);\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    /**\n     * Test case 2: Verifies the correct count of specified words in the given text.\n     */\n    @Test\n    public void testCase2() {\n        String text = \"This is a completely different sentence.\";\n        List<String> filterWords = Arrays.asList(\"I'll\", \"go\", \"to\", \"the\", \"school\", \"park\", \"play\");\n        Map<String, Integer> expectedOutput = new HashMap<>();\n        expectedOutput.put(\"I'll\", 0);\n        expectedOutput.put(\"go\", 0);\n        expectedOutput.put(\"to\", 0);\n        expectedOutput.put(\"the\", 0);\n        expectedOutput.put(\"school\", 0);\n        expectedOutput.put(\"park\", 0);\n        expectedOutput.put(\"play\", 0);\n\n        Map<String, Integer> actualOutput = wordFilterCounter(text, filterWords);\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    /**\n     * Test case 3: Verifies the correct count of specified words in the given text.\n     */\n    @Test\n    public void testCase3() {\n        String text = \"I will not go to the school's park.\";\n        List<String> filterWords = Arrays.asList(\"I\", \"will\", \"not\", \"go\", \"to\", \"the\", \"school's\", \"park\");\n        Map<String, Integer> expectedOutput = new HashMap<>();\n        expectedOutput.put(\"I\", 1);\n        expectedOutput.put(\"will\", 1);\n        expectedOutput.put(\"not\", 1);\n        expectedOutput.put(\"go\", 1);\n        expectedOutput.put(\"to\", 1);\n        expectedOutput.put(\"the\", 1);\n        expectedOutput.put(\"school's\", 1);\n        expectedOutput.put(\"park\", 1);\n\n        Map<String, Integer> actualOutput = wordFilterCounter(text, filterWords);\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    // Method to be tested\n    private Map<String, Integer> wordFilterCounter(String text, List<String> filterWords) {\n        // Convert filter words to lowercase for case-insensitive comparison\n        Set<String> filterWordsSet = new HashSet<>();\n        for (String word : filterWords) {\n            filterWordsSet.add(word.toLowerCase());\n        }\n\n        // Find all words in the text using a regex pattern\n        Pattern pattern = Pattern.compile(\"\\\\b\\\\w+(?:'\\\\w+)?\\\\b\");\n        Matcher matcher = pattern.matcher(text.toLowerCase());\n        List<String> words = new ArrayList<>();\n        while (matcher.find()) {\n            words.add(matcher.group());\n        }\n\n        // Count occurrences of filtered words\n        Map<String, Integer> wordCounts = new HashMap<>();\n        for (String word : words) {\n            if (filterWordsSet.contains(word)) {\n                wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);\n            }\n        }\n\n        // Create an ordered output based on the original order of filterWords\n        Map<String, Integer> orderedOutput = new LinkedHashMap<>();\n        for (String word : filterWords) {\n            orderedOutput.put(word, wordCounts.getOrDefault(word.toLowerCase(), 0));\n        }\n\n        return orderedOutput;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Counts the occurrences of specified words in the given text.\n *\n * This function filters the words from the text based on the provided list,\n * counts their occurrences, and returns a map with the words in the\n * order they were provided.\n *\n * @param text The input text from which to count words.\n * @param filterWords A list of words to filter and count.\n * @return A map with the count of each filter word in the text,\n *         maintaining the order from filterWords.\n */\npublic static Map<String, Integer> wordFilterCounter(String text, List<String> filterWords) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 522, "code_type": "method", "original_language": "python", "file_path": "Facial_Expressions_Impact_3DFR\\9fab644a538bed6d2b96305a47fce2c1de0c34e7\\src\\src\\src\\utils.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "Rotate the point cloud around the Y axis by a given angle.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef rotate_point_cloud(point_cloud: np.ndarray, rotation_angle: float) -> np.ndarray:\n    \"\"\"\n    Rotate the point cloud around the Y axis by a given angle.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        rotation_angle (float): The angle (in radians) to rotate the point cloud.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the rotated point cloud.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestRotatePointCloud(unittest.TestCase):\n\n    def test_no_rotation(self):\n        \"\"\"Test when rotation angle is 0 (should return the same point cloud).\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        rotation_angle = 0\n        expected_output = point_cloud\n        np.testing.assert_array_almost_equal(rotate_point_cloud(point_cloud, rotation_angle), expected_output)\n\n    def test_180_degree_rotation(self):\n        \"\"\"Test rotation of 180 degrees (\u03c0 radians) around Y axis.\"\"\"\n        point_cloud = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]])\n        rotation_angle = np.pi  # 180 degrees\n        expected_output = np.array([[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]])  # [1,0,0] -> [-1,0,0]\n        np.testing.assert_array_almost_equal(rotate_point_cloud(point_cloud, rotation_angle), expected_output)\n\n    def test_full_rotation(self):\n        \"\"\"Test rotation of 360 degrees (2\u03c0 radians) around Y axis (should return same point cloud).\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        rotation_angle = 2 * np.pi  # 360 degrees\n        expected_output = point_cloud  # Should return the same point cloud\n        np.testing.assert_array_almost_equal(rotate_point_cloud(point_cloud, rotation_angle), expected_output)\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef rotate_point_cloud(point_cloud: np.ndarray, rotation_angle: float) -> np.ndarray:\n    \"\"\"\n    Rotate the point cloud around the Y axis by a given angle.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        rotation_angle (float): The angle (in radians) to rotate the point cloud.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the rotated point cloud.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Rotate the point cloud around the Y axis by a given angle.\n *\n * @param pointCloud An N x 3 Eigen matrix representing the 3D point cloud.\n * @param rotationAngle The angle (in radians) to rotate the point cloud.\n *\n * @return An N x 3 Eigen matrix of the rotated point cloud.\n */\nEigen::MatrixXd rotate_point_cloud(const Eigen::MatrixXd& pointCloud, double rotationAngle) {\n\n}", "test_code": "TEST_CASE(\"Test Rotate Point Cloud\", \"[rotate_point_cloud]\") {\n    SECTION(\"Test no rotation\") {\n        Eigen::MatrixXd pointCloud(1, 3);\n        pointCloud << 1.0, 2.0, 3.0;\n        double rotationAngle = 0;\n        Eigen::MatrixXd expectedOutput(1, 3);\n        expectedOutput << 1.0, 2.0, 3.0;\n\n        Eigen::MatrixXd rotatedPointCloud = rotate_point_cloud(pointCloud, rotationAngle);\n\n        REQUIRE(rotatedPointCloud.isApprox(expectedOutput));\n    }\n\n    SECTION(\"Test 180-degree rotation\") {\n        Eigen::MatrixXd pointCloud(2, 3);\n        pointCloud << 1.0, 0.0, 0.0,\n                      0.0, 1.0, 0.0;\n        double rotationAngle = M_PI;  // 180 degrees\n        Eigen::MatrixXd expectedOutput(2, 3);\n        expectedOutput << -1.0, 0.0, 0.0,\n                           0.0, 1.0, 0.0;\n\n        Eigen::MatrixXd rotatedPointCloud = rotate_point_cloud(pointCloud, rotationAngle);\n\n        REQUIRE(rotatedPointCloud.isApprox(expectedOutput));\n    }\n\n    SECTION(\"Test full rotation\") {\n        Eigen::MatrixXd pointCloud(1, 3);\n        pointCloud << 1.0, 2.0, 3.0;\n        double rotationAngle = 2 * M_PI;  // 360 degrees\n        Eigen::MatrixXd expectedOutput(1, 3);\n        expectedOutput << 1.0, 2.0, 3.0;\n\n        Eigen::MatrixXd rotatedPointCloud = rotate_point_cloud(pointCloud, rotationAngle);\n\n        REQUIRE(rotatedPointCloud.isApprox(expectedOutput));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Rotate the point cloud around the Y axis by a given angle.\n *\n * @param pointCloud An N x 3 Eigen matrix representing the 3D point cloud.\n * @param rotationAngle The angle (in radians) to rotate the point cloud.\n *\n * @return An N x 3 Eigen matrix of the rotated point cloud.\n */\nEigen::MatrixXd rotate_point_cloud(const Eigen::MatrixXd& pointCloud, double rotationAngle) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Rotates the point cloud around the Y axis by a given angle.\n *\n * @param pointCloud A N x 3 matrix representing the 3D point cloud.\n * @param rotationAngle The angle (in radians) to rotate the point cloud.\n * @return A N x 3 matrix of the rotated point cloud.\n */\npublic static SimpleMatrix rotatePointCloud(SimpleMatrix pointCloud, double rotationAngle) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.ejml.simple.SimpleMatrix;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for rotating a 3D point cloud.\n */\npublic class Tester {\n\n    private static final double DELTA = 1e-6;\n\n    /**\n     * Test when the rotation angle is 0 (should return the same point cloud).\n     */\n    @Test\n    public void testNoRotation() {\n        SimpleMatrix pointCloud = new SimpleMatrix(new double[][]{{1.0, 2.0, 3.0}});\n        double rotationAngle = 0;\n        SimpleMatrix expectedOutput = pointCloud;\n\n        SimpleMatrix rotatedPointCloud = rotatePointCloud(pointCloud, rotationAngle);\n\n        assertEquals(expectedOutput, rotatedPointCloud, DELTA);\n    }\n\n    /**\n     * Test rotation of 180 degrees (\u03c0 radians) around the Y axis.\n     */\n    @Test\n    public void test180DegreeRotation() {\n        SimpleMatrix pointCloud = new SimpleMatrix(new double[][]{{1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}});\n        double rotationAngle = Math.PI; // 180 degrees\n        SimpleMatrix expectedOutput = new SimpleMatrix(new double[][]{{-1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}});\n\n        SimpleMatrix rotatedPointCloud = rotatePointCloud(pointCloud, rotationAngle);\n\n        assertEquals(expectedOutput, rotatedPointCloud, DELTA);\n    }\n\n    /**\n     * Test rotation of 360 degrees (2\u03c0 radians) around the Y axis (should return the same point cloud).\n     */\n    @Test\n    public void testFullRotation() {\n        SimpleMatrix pointCloud = new SimpleMatrix(new double[][]{{1.0, 2.0, 3.0}});\n        double rotationAngle = 2 * Math.PI; // 360 degrees\n        SimpleMatrix expectedOutput = pointCloud;\n\n        SimpleMatrix rotatedPointCloud = rotatePointCloud(pointCloud, rotationAngle);\n\n        assertEquals(expectedOutput, rotatedPointCloud, DELTA);\n    }\n\n    /**\n     * Helper method to rotate the point cloud.\n     *\n     * @param pointCloud A N x 3 matrix representing the 3D point cloud.\n     * @param rotationAngle The angle (in radians) to rotate the point cloud.\n     * @return A N x 3 matrix of the rotated point cloud.\n     */\n    private SimpleMatrix rotatePointCloud(SimpleMatrix pointCloud, double rotationAngle) {\n        // Create the rotation matrix for a rotation around the Y axis\n        SimpleMatrix rotationMatrix = new SimpleMatrix(3, 3);\n        rotationMatrix.set(0, 0, Math.cos(rotationAngle));\n        rotationMatrix.set(0, 2, Math.sin(rotationAngle));\n        rotationMatrix.set(2, 0, -Math.sin(rotationAngle));\n        rotationMatrix.set(2, 2, Math.cos(rotationAngle));\n        rotationMatrix.set(1, 1, 1);\n\n        // Rotate the point cloud by multiplying with the rotation matrix\n        SimpleMatrix rotatedPointCloud = pointCloud.mult(rotationMatrix);\n\n        return rotatedPointCloud;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Rotates the point cloud around the Y axis by a given angle.\n *\n * @param pointCloud A N x 3 matrix representing the 3D point cloud.\n * @param rotationAngle The angle (in radians) to rotate the point cloud.\n * @return A N x 3 matrix of the rotated point cloud.\n */\npublic static SimpleMatrix rotatePointCloud(SimpleMatrix pointCloud, double rotationAngle) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 523, "code_type": "method", "original_language": "python", "file_path": "Facial_Expressions_Impact_3DFR\\9fab644a538bed6d2b96305a47fce2c1de0c34e7\\src\\src\\src\\utils.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "Translate the point cloud by a given vector.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef translate_point_cloud(point_cloud: np.ndarray, translation_vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Translate the point cloud by a given vector.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        translation_vector (np.ndarray): A 1 x 3 numpy array or list representing the translation vector.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the translated point cloud.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestTranslatePointCloud(unittest.TestCase):\n\n    def test_simple_translation(self):\n        \"\"\"Test a simple translation of a single point.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        translation_vector = np.array([1.0, 1.0, 1.0])\n        expected_output = np.array([[2.0, 3.0, 4.0]])\n        np.testing.assert_array_almost_equal(translate_point_cloud(point_cloud, translation_vector), expected_output)\n\n    def test_multiple_points_translation(self):\n        \"\"\"Test translation of multiple points.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        translation_vector = np.array([1.0, 2.0, 3.0])\n        expected_output = np.array([[2.0, 4.0, 6.0], [5.0, 7.0, 9.0]])\n        np.testing.assert_array_almost_equal(translate_point_cloud(point_cloud, translation_vector), expected_output)\n\n    def test_zero_translation(self):\n        \"\"\"Test translation by a zero vector (should return the same point cloud).\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        translation_vector = np.array([0.0, 0.0, 0.0])\n        expected_output = point_cloud  # No change expected\n        np.testing.assert_array_almost_equal(translate_point_cloud(point_cloud, translation_vector), expected_output)\n\n    def test_negative_translation(self):\n        \"\"\"Test translation with negative values.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        translation_vector = np.array([-1.0, -2.0, -3.0])\n        expected_output = np.array([[0.0, 0.0, 0.0]])\n        np.testing.assert_array_almost_equal(translate_point_cloud(point_cloud, translation_vector), expected_output)", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef translate_point_cloud(point_cloud: np.ndarray, translation_vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Translate the point cloud by a given vector.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        translation_vector (np.ndarray): A 1 x 3 numpy array or list representing the translation vector.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the translated point cloud.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Translates the point cloud by a given vector.\n *\n * @param pointCloud An M x 3 Eigen matrix representing the 3D point cloud.\n * @type pointCloud Eigen::MatrixXd\n *\n * @param translationVector A 1 x 3 Eigen row vector representing the translation vector.\n * @type translationVector Eigen::RowVector3d\n *\n * @return An M x 3 Eigen matrix of the translated point cloud.\n * @rtype Eigen::MatrixXd\n */\nEigen::MatrixXd translate_point_cloud(const Eigen::MatrixXd& pointCloud, const Eigen::RowVector3d& translationVector){\n\n}\n\n", "test_code": "TEST_CASE(\"TestTranslatePointCloud\", \"[translatePointCloud]\") {\n    SECTION(\"test_simple_translation\") {\n        // Test a simple translation of a single point\n        Eigen::MatrixXd pointCloud(1, 3);\n        pointCloud << 1.0, 2.0, 3.0;\n        Eigen::RowVector3d translationVector(1.0, 1.0, 1.0);\n        Eigen::MatrixXd expectedOutput(1, 3);\n        expectedOutput << 2.0, 3.0, 4.0;\n\n        REQUIRE(translate_point_cloud(pointCloud, translationVector).isApprox(expectedOutput));\n    }\n\n    SECTION(\"test_multiple_points_translation\") {\n        // Test translation of multiple points\n        Eigen::MatrixXd pointCloud(2, 3);\n        pointCloud << 1.0, 2.0, 3.0,\n                      4.0, 5.0, 6.0;\n        Eigen::RowVector3d translationVector(1.0, 2.0, 3.0);\n        Eigen::MatrixXd expectedOutput(2, 3);\n        expectedOutput << 2.0, 4.0, 6.0,\n                          5.0, 7.0, 9.0;\n\n        REQUIRE(translate_point_cloud(pointCloud, translationVector).isApprox(expectedOutput));\n    }\n\n    SECTION(\"test_zero_translation\") {\n        // Test translation by a zero vector (should return the same point cloud)\n        Eigen::MatrixXd pointCloud(2, 3);\n        pointCloud << 1.0, 2.0, 3.0,\n                      4.0, 5.0, 6.0;\n        Eigen::RowVector3d translationVector(0.0, 0.0, 0.0);\n        Eigen::MatrixXd expectedOutput = pointCloud;  // No change expected\n\n        REQUIRE(translate_point_cloud(pointCloud, translationVector).isApprox(expectedOutput));\n    }\n\n    SECTION(\"test_negative_translation\") {\n        // Test translation with negative values\n        Eigen::MatrixXd pointCloud(1, 3);\n        pointCloud << 1.0, 2.0, 3.0;\n        Eigen::RowVector3d translationVector(-1.0, -2.0, -3.0);\n        Eigen::MatrixXd expectedOutput(1, 3);\n        expectedOutput << 0.0, 0.0, 0.0;\n\n        REQUIRE(translate_point_cloud(pointCloud, translationVector).isApprox(expectedOutput));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Translates the point cloud by a given vector.\n *\n * @param pointCloud An M x 3 Eigen matrix representing the 3D point cloud.\n * @type pointCloud Eigen::MatrixXd\n *\n * @param translationVector A 1 x 3 Eigen row vector representing the translation vector.\n * @type translationVector Eigen::RowVector3d\n *\n * @return An M x 3 Eigen matrix of the translated point cloud.\n * @rtype Eigen::MatrixXd\n */\nEigen::MatrixXd translate_point_cloud(const Eigen::MatrixXd& pointCloud, const Eigen::RowVector3d& translationVector){\n\n}\n\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Translates the point cloud by a given vector.\n *\n * @param pointCloud An N x 3 INDArray representing the 3D point cloud.\n * @param translationVector A 1 x 3 double array representing the translation vector.\n * @return An N x 3 INDArray of the translated point cloud.\n */\npublic static INDArray translatePointCloud(INDArray pointCloud, double[] translationVector) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport org.nd4j.linalg.api.ndarray.INDArray;\nimport org.nd4j.linalg.factory.Nd4j;\n\npublic class Tester {\n\n    private static final double DELTA = 1e-15;\n\n    @Test\n    public void testSimpleTranslation() {\n        // Test a simple translation of a single point\n        INDArray pointCloud = Nd4j.create(new double[][]{{1.0, 2.0, 3.0}});\n        double[] translationVector = {1.0, 1.0, 1.0};\n        INDArray expectedOutput = Nd4j.create(new double[][]{{2.0, 3.0, 4.0}});\n\n        INDArray translatedPointCloud = Answer.translatePointCloud(pointCloud, translationVector);\n\n        assertEquals(expectedOutput, translatedPointCloud, DELTA);\n    }\n\n    @Test\n    public void testMultiplePointsTranslation() {\n        // Test translation of multiple points\n        INDArray pointCloud = Nd4j.create(new double[][]{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}});\n        double[] translationVector = {1.0, 2.0, 3.0};\n        INDArray expectedOutput = Nd4j.create(new double[][]{{2.0, 4.0, 6.0}, {5.0, 7.0, 9.0}});\n\n        INDArray translatedPointCloud = Answer.translatePointCloud(pointCloud, translationVector);\n\n        assertEquals(expectedOutput, translatedPointCloud, DELTA);\n    }\n\n    @Test\n    public void testZeroTranslation() {\n        // Test translation by a zero vector (should return the same point cloud)\n        INDArray pointCloud = Nd4j.create(new double[][]{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}});\n        double[] translationVector = {0.0, 0.0, 0.0};\n        INDArray expectedOutput = pointCloud;  // No change expected\n\n        INDArray translatedPointCloud = Answer.translatePointCloud(pointCloud, translationVector);\n\n        assertEquals(expectedOutput, translatedPointCloud, DELTA);\n    }\n\n    @Test\n    public void testNegativeTranslation() {\n        // Test translation with negative values\n        INDArray pointCloud = Nd4j.create(new double[][]{{1.0, 2.0, 3.0}});\n        double[] translationVector = {-1.0, -2.0, -3.0};\n        INDArray expectedOutput = Nd4j.create(new double[][]{{0.0, 0.0, 0.0}});\n\n        INDArray translatedPointCloud = Answer.translatePointCloud(pointCloud, translationVector);\n\n        assertEquals(expectedOutput, translatedPointCloud, DELTA);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Translates the point cloud by a given vector.\n *\n * @param pointCloud An N x 3 INDArray representing the 3D point cloud.\n * @param translationVector A 1 x 3 double array representing the translation vector.\n * @return An N x 3 INDArray of the translated point cloud.\n */\npublic static INDArray translatePointCloud(INDArray pointCloud, double[] translationVector) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 524, "code_type": "method", "original_language": "python", "file_path": "Facial_Expressions_Impact_3DFR\\9fab644a538bed6d2b96305a47fce2c1de0c34e7\\src\\src\\src\\utils.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "Scale the point cloud by a given factor.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\ndef scale_point_cloud(point_cloud: np.ndarray, scale_factor: float) -> np.ndarray:\n    \"\"\"\n    Scale the point cloud by a given factor.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        scale_factor ( float): A float representing the scaling factor.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the scaled point cloud.\n    \"\"\"", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestScalePointCloud(unittest.TestCase):\n\n    def test_simple_scaling(self):\n        \"\"\"Test scaling of a single point.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        scale_factor = 2.0\n        expected_output = np.array([[2.0, 4.0, 6.0]])\n        np.testing.assert_array_almost_equal(scale_point_cloud(point_cloud, scale_factor), expected_output)\n\n    def test_multiple_points_scaling(self):\n        \"\"\"Test scaling of multiple points.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        scale_factor = 0.5\n        expected_output = np.array([[0.5, 1.0, 1.5], [2.0, 2.5, 3.0]])\n        np.testing.assert_array_almost_equal(scale_point_cloud(point_cloud, scale_factor), expected_output)\n\n    def test_zero_scaling(self):\n        \"\"\"Test scaling by a factor of zero (should return a point cloud of zeros).\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        scale_factor = 0.0\n        expected_output = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n        np.testing.assert_array_almost_equal(scale_point_cloud(point_cloud, scale_factor), expected_output)\n\n    def test_negative_scaling(self):\n        \"\"\"Test scaling with a negative factor.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        scale_factor = -2.0\n        expected_output = np.array([[-2.0, -4.0, -6.0]])\n        np.testing.assert_array_almost_equal(scale_point_cloud(point_cloud, scale_factor), expected_output)\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\ndef scale_point_cloud(point_cloud: np.ndarray, scale_factor: float) -> np.ndarray:\n    \"\"\"\n    Scale the point cloud by a given factor.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        scale_factor ( float): A float representing the scaling factor.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the scaled point cloud.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Scale the point cloud by a given factor.\n *\n * @param pointCloud A N x 3 Eigen matrix representing the 3D point cloud.\n * @param scaleFactor A double representing the scaling factor.\n * @return An N x 3 Eigen matrix of the scaled point cloud.\n */\nEigen::MatrixXd scale_point_cloud(const Eigen::MatrixXd& pointCloud, double scaleFactor) {\n\n}", "test_code": "#include <catch2/catch_test_macros.hpp>\n#include <Eigen/Dense>\n#include <stdexcept>\n\nTEST_CASE(\"Test scaling of point clouds\", \"[scalePointCloud]\") {\n    SECTION(\"Test simple scaling\") {\n        Eigen::MatrixXd pointCloud(1, 3);\n        pointCloud << 1.0, 2.0, 3.0;\n        double scale_factor = 2.0;\n        Eigen::MatrixXd expected_output(1, 3);\n        expected_output << 2.0, 4.0, 6.0;\n\n        REQUIRE((scale_point_cloud(pointCloud, scale_factor)).isApprox(expected_output));\n    }\n\n    SECTION(\"Test multiple points scaling\") {\n        Eigen::MatrixXd pointCloud(2, 3);\n        pointCloud << 1.0, 2.0, 3.0,\n                      4.0, 5.0, 6.0;\n        double scale_factor = 0.5;\n        Eigen::MatrixXd expected_output(2, 3);\n        expected_output << 0.5, 1.0, 1.5,\n                           2.0, 2.5, 3.0;\n\n        REQUIRE((scale_point_cloud(pointCloud, scale_factor)).isApprox(expected_output));\n    }\n\n    SECTION(\"Test zero scaling\") {\n        Eigen::MatrixXd pointCloud(2, 3);\n        pointCloud << 1.0, 2.0, 3.0,\n                      4.0, 5.0, 6.0;\n        double scale_factor = 0.0;\n        Eigen::MatrixXd expected_output(2, 3);\n        expected_output << 0.0, 0.0, 0.0,\n                           0.0, 0.0, 0.0;\n\n        REQUIRE((scale_point_cloud(pointCloud, scale_factor)).isApprox(expected_output));\n    }\n\n    SECTION(\"Test negative scaling\") {\n        Eigen::MatrixXd pointCloud(1, 3);\n        pointCloud << 1.0, 2.0, 3.0;\n        double scale_factor = -2.0;\n        Eigen::MatrixXd expected_output(1, 3);\n        expected_output << -2.0, -4.0, -6.0;\n\n        REQUIRE((scale_point_cloud(pointCloud, scale_factor)).isApprox(expected_output));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Scale the point cloud by a given factor.\n *\n * @param pointCloud A N x 3 Eigen matrix representing the 3D point cloud.\n * @param scaleFactor A double representing the scaling factor.\n * @return An N x 3 Eigen matrix of the scaled point cloud.\n */\nEigen::MatrixXd scale_point_cloud(const Eigen::MatrixXd& pointCloud, double scaleFactor) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Scales the point cloud by a given factor.\n *\n * @param pointCloud A 2D array representing the 3D point cloud with shape (N, 3).\n * @param scaleFactor A double representing the scaling factor.\n * @return A 2D array of the scaled point cloud with shape (N, 3).\n * @throws IllegalArgumentException If the point cloud is not a 2D array with shape (N, 3).\n */\npublic static double[][] scalePointCloud(double[][] pointCloud, double scaleFactor) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\n\n/**\n * Test class for scaling a 3D point cloud.\n */\npublic class Tester {\n\n    /**\n     * Tests scaling of a single point.\n     */\n    @Test\n    public void testSimpleScaling() {\n        double[][] pointCloud = {{1.0, 2.0, 3.0}};\n        double scaleFactor = 2.0;\n        double[][] expectedOutput = {{2.0, 4.0, 6.0}};\n\n        double[][] scaledPointCloud = scalePointCloud(pointCloud, scaleFactor);\n\n        assertArrayEquals(expectedOutput, scaledPointCloud, 0.001);\n    }\n\n    /**\n     * Tests scaling of multiple points.\n     */\n    @Test\n    public void testMultiplePointsScaling() {\n        double[][] pointCloud = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}};\n        double scaleFactor = 0.5;\n        double[][] expectedOutput = {{0.5, 1.0, 1.5}, {2.0, 2.5, 3.0}};\n\n        double[][] scaledPointCloud = scalePointCloud(pointCloud, scaleFactor);\n\n        assertArrayEquals(expectedOutput, scaledPointCloud, 0.001);\n    }\n\n    /**\n     * Tests scaling by a factor of zero (should return a point cloud of zeros).\n     */\n    @Test\n    public void testZeroScaling() {\n        double[][] pointCloud = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}};\n        double scaleFactor = 0.0;\n        double[][] expectedOutput = {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}};\n\n        double[][] scaledPointCloud = scalePointCloud(pointCloud, scaleFactor);\n\n        assertArrayEquals(expectedOutput, scaledPointCloud, 0.001);\n    }\n\n    /**\n     * Tests scaling with a negative factor.\n     */\n    @Test\n    public void testNegativeScaling() {\n        double[][] pointCloud = {{1.0, 2.0, 3.0}};\n        double scaleFactor = -2.0;\n        double[][] expectedOutput = {{-2.0, -4.0, -6.0}};\n\n        double[][] scaledPointCloud = scalePointCloud(pointCloud, scaleFactor);\n\n        assertArrayEquals(expectedOutput, scaledPointCloud, 0.001);\n    }\n\n    // Utility method to scale the point cloud\n    private double[][] scalePointCloud(double[][] pointCloud, double scaleFactor) {\n        // Ensure pointCloud is a 2D array\n        if (pointCloud == null || pointCloud.length == 0 || pointCloud[0].length != 3) {\n            throw new IllegalArgumentException(\"pointCloud must be a 2D array with shape (N, 3)\");\n        }\n\n        // Scale the point cloud by the given factor\n        double[][] scaledPointCloud = new double[pointCloud.length][3];\n        for (int i = 0; i < pointCloud.length; i++) {\n            scaledPointCloud[i] = Arrays.stream(pointCloud[i])\n                                        .map(x -> x * scaleFactor)\n                                        .toArray();\n        }\n\n        return scaledPointCloud;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Scales the point cloud by a given factor.\n *\n * @param pointCloud A 2D array representing the 3D point cloud with shape (N, 3).\n * @param scaleFactor A double representing the scaling factor.\n * @return A 2D array of the scaled point cloud with shape (N, 3).\n * @throws IllegalArgumentException If the point cloud is not a 2D array with shape (N, 3).\n */\npublic static double[][] scalePointCloud(double[][] pointCloud, double scaleFactor) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 525, "code_type": "method", "original_language": "python", "file_path": "Facial_Expressions_Impact_3DFR\\9fab644a538bed6d2b96305a47fce2c1de0c34e7\\src\\src\\src\\utils.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "Flip the point cloud across a specified axis.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef flip_point_cloud(point_cloud: np.ndarray, axis: int) -> np.ndarray:\n    \"\"\"\n    Flip the point cloud across a specified axis.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        axis (int): An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the flipped point cloud.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestFlipPointCloud(unittest.TestCase):\n\n    def test_flip_x_axis(self):\n        \"\"\"Test flipping the point cloud across the x-axis.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        expected_output = np.array([[1.0, -2.0, 3.0], [4.0, -5.0, 6.0]])\n        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=1), expected_output)\n\n    def test_flip_y_axis(self):\n        \"\"\"Test flipping the point cloud across the y-axis.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        expected_output = np.array([[-1.0, 2.0, 3.0], [-4.0, 5.0, 6.0]])\n        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=0), expected_output)\n\n    def test_flip_z_axis(self):\n        \"\"\"Test flipping the point cloud across the z-axis.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        expected_output = np.array([[1.0, 2.0, -3.0], [4.0, 5.0, -6.0]])\n        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=2), expected_output)\n\n    def test_invalid_axis(self):\n        \"\"\"Test handling of an invalid axis.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        self.assertRaises(Exception)\n\n\n    def test_empty_point_cloud(self):\n        \"\"\"Test flipping an empty point cloud.\"\"\"\n        point_cloud = np.array([]).reshape(0, 3)  # Empty point cloud with shape (0, 3)\n        expected_output = np.array([]).reshape(0, 3)  # Expect the output to be the same\n        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=0), expected_output)", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef flip_point_cloud(point_cloud: np.ndarray, axis: int) -> np.ndarray:\n    \"\"\"\n    Flip the point cloud across a specified axis.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        axis (int): An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the flipped point cloud.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Flip the point cloud across a specified axis.\n *\n * @param pointCloud A N x 3 matrix representing the 3D point cloud.\n * @param axis An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n * @return A N x 3 matrix of the flipped point cloud.\n */\nMatrixXd flip_point_cloud(const MatrixXd& pointCloud, int axis) {\n\n}", "test_code": "#include <catch2/catch_test_macros.hpp>\n#include <Eigen/Dense>\n#include <stdexcept>\n\nusing Eigen::MatrixXd;\nTEST_CASE(\"TestFlipPointCloud\", \"[FlipPointCloud]\") {\n    SECTION(\"test_flip_x_axis\") {\n        // Test flipping the point cloud across the x-axis.\n        MatrixXd pointCloud(2, 3);\n        pointCloud << 1.0, 2.0, 3.0,\n                      4.0, 5.0, 6.0;\n\n        MatrixXd expectedOutput(2, 3);\n        expectedOutput << 1.0, -2.0, 3.0,\n                         4.0, -5.0, 6.0;\n\n        MatrixXd flippedPointCloud = flip_point_cloud(pointCloud, 1);\n        REQUIRE(flippedPointCloud.isApprox(expectedOutput));\n    }\n\n    SECTION(\"test_flip_y_axis\") {\n        // Test flipping the point cloud across the y-axis.\n        MatrixXd pointCloud(2, 3);\n        pointCloud << 1.0, 2.0, 3.0,\n                      4.0, 5.0, 6.0;\n\n        MatrixXd expectedOutput(2, 3);\n        expectedOutput << -1.0, 2.0, 3.0,\n                          -4.0, 5.0, 6.0;\n\n        MatrixXd flippedPointCloud = flip_point_cloud(pointCloud, 0);\n        REQUIRE(flippedPointCloud.isApprox(expectedOutput));\n    }\n\n    SECTION(\"test_flip_z_axis\") {\n        // Test flipping the point cloud across the z-axis.\n        MatrixXd pointCloud(2, 3);\n        pointCloud << 1.0, 2.0, 3.0,\n                      4.0, 5.0, 6.0;\n\n        MatrixXd expectedOutput(2, 3);\n        expectedOutput << 1.0, 2.0, -3.0,\n                         4.0, 5.0, -6.0;\n\n        MatrixXd flippedPointCloud = flip_point_cloud(pointCloud, 2);\n        REQUIRE(flippedPointCloud.isApprox(expectedOutput));\n    }\n\n    SECTION(\"test_invalid_axis\") {\n        // Test handling of an invalid axis.\n        MatrixXd pointCloud(1, 3);\n        pointCloud << 1.0, 2.0, 3.0;\n\n        REQUIRE_THROWS_AS(flip_point_cloud(pointCloud, 3), std::invalid_argument);\n    }\n\n    SECTION(\"test_empty_point_cloud\") {\n        // Test flipping an empty point cloud.\n        MatrixXd pointCloud(0, 3);\n        MatrixXd expectedOutput(0, 3);\n\n        MatrixXd flippedPointCloud = flip_point_cloud(pointCloud, 0);\n        REQUIRE(flippedPointCloud.rows() == expectedOutput.rows());\n        REQUIRE(flippedPointCloud.cols() == expectedOutput.cols());\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Flip the point cloud across a specified axis.\n *\n * @param pointCloud A N x 3 matrix representing the 3D point cloud.\n * @param axis An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n * @return A N x 3 matrix of the flipped point cloud.\n */\nMatrixXd flip_point_cloud(const MatrixXd& pointCloud, int axis) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Flips the point cloud across a specified axis.\n *\n * @param pointCloud A N x 3 array representing the 3D point cloud.\n * @param axis       An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n * @return A N x 3 array of the flipped point cloud.\n */\npublic static double[][] flipPointCloud(double[][] pointCloud, int axis) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertThrows;\n\n/**\n * Test class for verifying the correctness of the flipPointCloud method.\n */\npublic class Tester {\n\n    /**\n     * Test flipping the point cloud across the x-axis.\n     */\n    @Test\n    public void testFlipXAxis() {\n        double[][] pointCloud = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}};\n        double[][] expectedOutput = {{1.0, -2.0, 3.0}, {4.0, -5.0, 6.0}};\n        assertArrayEquals(expectedOutput, flipPointCloud(pointCloud, 1), 1e-6);\n    }\n\n    /**\n     * Test flipping the point cloud across the y-axis.\n     */\n    @Test\n    public void testFlipYAxis() {\n        double[][] pointCloud = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}};\n        double[][] expectedOutput = {{-1.0, 2.0, 3.0}, {-4.0, 5.0, 6.0}};\n        assertArrayEquals(expectedOutput, flipPointCloud(pointCloud, 0), 1e-6);\n    }\n\n    /**\n     * Test flipping the point cloud across the z-axis.\n     */\n    @Test\n    public void testFlipZAxis() {\n        double[][] pointCloud = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}};\n        double[][] expectedOutput = {{1.0, 2.0, -3.0}, {4.0, 5.0, -6.0}};\n        assertArrayEquals(expectedOutput, flipPointCloud(pointCloud, 2), 1e-6);\n    }\n\n    /**\n     * Test handling of an invalid axis.\n     */\n    @Test\n    public void testInvalidAxis() {\n        double[][] pointCloud = {{1.0, 2.0, 3.0}};\n        assertThrows(IllegalArgumentException.class, () -> flipPointCloud(pointCloud, 3));\n    }\n\n    /**\n     * Test flipping an empty point cloud.\n     */\n    @Test\n    public void testEmptyPointCloud() {\n        double[][] pointCloud = new double[0][3]; // Empty point cloud with shape (0, 3)\n        double[][] expectedOutput = new double[0][3]; // Expect the output to be the same\n        assertArrayEquals(expectedOutput, flipPointCloud(pointCloud, 0), 1e-6);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Flips the point cloud across a specified axis.\n *\n * @param pointCloud A N x 3 array representing the 3D point cloud.\n * @param axis       An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n * @return A N x 3 array of the flipped point cloud.\n */\npublic static double[][] flipPointCloud(double[][] pointCloud, int axis) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 526, "code_type": "method", "original_language": "python", "file_path": "NeetCode\\822d5781a0d703330ae1940fa2a9c8cbc3b3717a\\sliding_window\\minimum_window_substring.py\n", "question_type": "Algorithm and data structure", "summary": "Find the minimum window substring in `s` that contains all characters of `t`.", "language_version_list": {"python": {"code_signature": "from collections import Counter\n\n\ndef min_window(s: str, t: str) -> str:\n    \"\"\"\n    Find the minimum window substring in `s` that contains all characters of `t`.\n\n    Args:\n        s (str): The input string in which to search for the substring.\n        t (str): The target string whose characters must be included in the substring.\n\n    Returns:\n        str: The minimum window substring of `s` that contains all characters of `t`.Returns an empty string if no such substring exists.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestMinWindow(unittest.TestCase):\n\n    def test_basic_case(self):\n        \"\"\"Test with a normal case where the minimum window exists.\"\"\"\n        s = \"ADOBECODEBANC\"\n        t = \"ABC\"\n        expected_output = \"BANC\"\n        self.assertEqual(min_window(s, t), expected_output)\n\n    def test_no_window_exists(self):\n        \"\"\"Test where no window can satisfy the condition.\"\"\"\n        s = \"A\"\n        t = \"AA\"\n        expected_output = \"\"\n        self.assertEqual(min_window(s, t), expected_output)\n\n    def test_empty_string(self):\n        \"\"\"Test with an empty input string s.\"\"\"\n        s = \"\"\n        t = \"ABC\"\n        expected_output = \"\"\n        self.assertEqual(min_window(s, t), expected_output)\n\n\n    def test_multiple_valid_windows(self):\n        \"\"\"Test with multiple valid windows to ensure the smallest one is returned.\"\"\"\n        s = \"AA\"\n        t = \"AA\"\n        expected_output = \"AA\"\n        self.assertEqual(min_window(s, t), expected_output)\n", "prompt": "please write a python function , the function signature as below from collections import Counter\n\n\ndef min_window(s: str, t: str) -> str:\n    \"\"\"\n    Find the minimum window substring in `s` that contains all characters of `t`.\n\n    Args:\n        s (str): The input string in which to search for the substring.\n        t (str): The target string whose characters must be included in the substring.\n\n    Returns:\n        str: The minimum window substring of `s` that contains all characters of `t`.Returns an empty string if no such substring exists.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/*\n *   Find the minimum window substring in `s` that contains all characters of `t`.\n *   Args:\n *       s: The input string in which to search for the substring.\n *       t: The target string whose characters must be included in the substring.\n *   Returns:\n *       The minimum window substring of `s` that contains all characters of `t`.\n *       Returns an empty string if no such substring exists.\n */\nstd::string min_window(const std::string& s, const std::string& t) {\n\n}", "test_code": "// Test class using Catch2\nTEST_CASE(\"Test cases for min_window\", \"[min_window]\") {\n    SECTION(\"Test with a normal case where the minimum window exists\") {\n        std::string s = \"ADOBECODEBANC\";\n        std::string t = \"ABC\";\n        std::string expected_output = \"BANC\";\n        REQUIRE(min_window(s, t) == expected_output);\n    }\n\n    SECTION(\"Test where no window can satisfy the condition\") {\n        std::string s = \"A\";\n        std::string t = \"AA\";\n        std::string expected_output = \"\";\n        REQUIRE(min_window(s, t) == expected_output);\n    }\n\n    SECTION(\"Test with an empty input string s\") {\n        std::string s = \"\";\n        std::string t = \"ABC\";\n        std::string expected_output = \"\";\n        REQUIRE(min_window(s, t) == expected_output);\n    }\n\n    SECTION(\"Test with multiple valid windows to ensure the smallest one is returned\") {\n        std::string s = \"AA\";\n        std::string t = \"AA\";\n        std::string expected_output = \"AA\";\n        REQUIRE(min_window(s, t) == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /*\n *   Find the minimum window substring in `s` that contains all characters of `t`.\n *   Args:\n *       s: The input string in which to search for the substring.\n *       t: The target string whose characters must be included in the substring.\n *   Returns:\n *       The minimum window substring of `s` that contains all characters of `t`.\n *       Returns an empty string if no such substring exists.\n */\nstd::string min_window(const std::string& s, const std::string& t) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds the minimum window substring in `s` that contains all characters of `t`.\n *\n * @param s The input string in which to search for the substring.\n * @param t The target string whose characters must be included in the substring.\n * @return The minimum window substring of `s` that contains all characters of `t`.\n *         Returns an empty string if no such substring exists.\n */\npublic static String minWindow(String s, String t) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    /**\n     * Tests a basic case where the minimum window exists.\n     */\n    @Test\n    public void testBasicCase() {\n        String s = \"ADOBECODEBANC\";\n        String t = \"ABC\";\n        String expectedOutput = \"BANC\";\n        assertEquals(expectedOutput, Answer.minWindow(s, t));\n    }\n\n    /**\n     * Tests a case where no window can satisfy the condition.\n     */\n    @Test\n    public void testNoWindowExists() {\n        String s = \"A\";\n        String t = \"AA\";\n        String expectedOutput = \"\";\n        assertEquals(expectedOutput, Answer.minWindow(s, t));\n    }\n\n    /**\n     * Tests a case with an empty input string s.\n     */\n    @Test\n    public void testEmptyString() {\n        String s = \"\";\n        String t = \"ABC\";\n        String expectedOutput = \"\";\n        assertEquals(expectedOutput, Answer.minWindow(s, t));\n    }\n\n    /**\n     * Tests a case with multiple valid windows to ensure the smallest one is returned.\n     */\n    @Test\n    public void testMultipleValidWindows() {\n        String s = \"AA\";\n        String t = \"AA\";\n        String expectedOutput = \"AA\";\n        assertEquals(expectedOutput, Answer.minWindow(s, t));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds the minimum window substring in `s` that contains all characters of `t`.\n *\n * @param s The input string in which to search for the substring.\n * @param t The target string whose characters must be included in the substring.\n * @return The minimum window substring of `s` that contains all characters of `t`.\n *         Returns an empty string if no such substring exists.\n */\npublic static String minWindow(String s, String t) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 527, "code_type": "method", "original_language": "python", "file_path": "Brick-Breaker\\7c88c3316aaf18a428bc1c98e8861aec6686512d\\source\\Process\\Triangle.py\n", "question_type": "Algorithm and data structure", "summary": "Check if a point is inside a triangle defined by three vertices.", "language_version_list": {"python": {"code_signature": "def is_point_inside_triangle(px: float, py: float, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float):\n    \"\"\"\n    Check if a point is inside a triangle defined by three vertices.\n\n    Args:\n        px (float): The x-coordinate of the point to check.\n        py (float): The y-coordinate of the point to check.\n        x1 (float): The x-coordinate of the first vertex of the triangle.\n        y1 (float): The y-coordinate of the first vertex of the triangle.\n        x2 (float): The x-coordinate of the second vertex of the triangle.\n        y2 (float): The y-coordinate of the second vertex of the triangle.\n        x3 (float): The x-coordinate of the third vertex of the triangle.\n        y3 (float): The y-coordinate of the third vertex of the triangle.\n\n    Returns:\n        bool: True if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestPointInsideTriangle(unittest.TestCase):\n\n    def test_point_inside_triangle(self):\n        \"\"\"Test case where point is inside the triangle.\"\"\"\n        triangle_vertices = (0, 0, 5, 0, 2.5, 5)\n        point = (2.5, 2)  # Inside the triangle\n        self.assertTrue(is_point_inside_triangle(point[0], point[1], *triangle_vertices))\n\n    def test_point_on_edge(self):\n        \"\"\"Test case where point is on the edge of the triangle.\"\"\"\n        triangle_vertices = (0, 0, 5, 0, 2.5, 5)\n        point = (2.5, 0)  # On the edge of the triangle\n        self.assertTrue(is_point_inside_triangle(point[0], point[1], *triangle_vertices))\n\n    def test_point_outside_triangle(self):\n        \"\"\"Test case where point is outside the triangle.\"\"\"\n        triangle_vertices = (0, 0, 5, 0, 2.5, 5)\n        point = (6, 2)  # Outside the triangle\n        self.assertFalse(is_point_inside_triangle(point[0], point[1], *triangle_vertices))\n\n    def test_point_at_vertex(self):\n        \"\"\"Test case where point is at one of the triangle's vertices.\"\"\"\n        triangle_vertices = (0, 0, 5, 0, 2.5, 5)\n        point = (0, 0)  # At the vertex of the triangle\n        self.assertTrue(is_point_inside_triangle(point[0], point[1], *triangle_vertices))", "prompt": "please write a python function , the function signature as below def is_point_inside_triangle(px: float, py: float, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float):\n    \"\"\"\n    Check if a point is inside a triangle defined by three vertices.\n\n    Args:\n        px (float): The x-coordinate of the point to check.\n        py (float): The y-coordinate of the point to check.\n        x1 (float): The x-coordinate of the first vertex of the triangle.\n        y1 (float): The y-coordinate of the first vertex of the triangle.\n        x2 (float): The x-coordinate of the second vertex of the triangle.\n        y2 (float): The y-coordinate of the second vertex of the triangle.\n        x3 (float): The x-coordinate of the third vertex of the triangle.\n        y3 (float): The y-coordinate of the third vertex of the triangle.\n\n    Returns:\n        bool: True if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Check if a point is inside a triangle defined by three vertices.\n *\n * @param px The x-coordinate of the point to check.\n * @param py The y-coordinate of the point to check.\n * @param x1 The x-coordinate of the first vertex of the triangle.\n * @param y1 The y-coordinate of the first vertex of the triangle.\n * @param x2 The x-coordinate of the second vertex of the triangle.\n * @param y2 The y-coordinate of the second vertex of the triangle.\n * @param x3 The x-coordinate of the third vertex of the triangle.\n * @param y3 The y-coordinate of the third vertex of the triangle.\n * @return True if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); False otherwise.\n */\nbool is_point_inside_triangle(double px, double py, double x1, double y1, double x2, double y2, double x3, double y3) {}", "test_code": "TEST_CASE(\"Test cases for point inside triangle\", \"[point_inside_triangle]\") {\n    SECTION(\"Test case where point is inside the triangle\") {\n        double triangle_vertices[] = {0, 0, 5, 0, 2.5, 5};\n        double point[] = {2.5, 2};  // Inside the triangle\n        REQUIRE(is_point_inside_triangle(point[0], point[1], triangle_vertices[0], triangle_vertices[1], triangle_vertices[2], triangle_vertices[3], triangle_vertices[4], triangle_vertices[5]));\n    }\n\n    SECTION(\"Test case where point is on the edge of the triangle\") {\n        double triangle_vertices[] = {0, 0, 5, 0, 2.5, 5};\n        double point[] = {2.5, 0};  // On the edge of the triangle\n        REQUIRE(is_point_inside_triangle(point[0], point[1], triangle_vertices[0], triangle_vertices[1], triangle_vertices[2], triangle_vertices[3], triangle_vertices[4], triangle_vertices[5]));\n    }\n\n    SECTION(\"Test case where point is outside the triangle\") {\n        double triangle_vertices[] = {0, 0, 5, 0, 2.5, 5};\n        double point[] = {6, 2};  // Outside the triangle\n        REQUIRE_FALSE(is_point_inside_triangle(point[0], point[1], triangle_vertices[0], triangle_vertices[1], triangle_vertices[2], triangle_vertices[3], triangle_vertices[4], triangle_vertices[5]));\n    }\n\n    SECTION(\"Test case where point is at one of the triangle's vertices\") {\n        double triangle_vertices[] = {0, 0, 5, 0, 2.5, 5};\n        double point[] = {0, 0};  // At the vertex of the triangle\n        REQUIRE(is_point_inside_triangle(point[0], point[1], triangle_vertices[0], triangle_vertices[1], triangle_vertices[2], triangle_vertices[3], triangle_vertices[4], triangle_vertices[5]));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Check if a point is inside a triangle defined by three vertices.\n *\n * @param px The x-coordinate of the point to check.\n * @param py The y-coordinate of the point to check.\n * @param x1 The x-coordinate of the first vertex of the triangle.\n * @param y1 The y-coordinate of the first vertex of the triangle.\n * @param x2 The x-coordinate of the second vertex of the triangle.\n * @param y2 The y-coordinate of the second vertex of the triangle.\n * @param x3 The x-coordinate of the third vertex of the triangle.\n * @param y3 The y-coordinate of the third vertex of the triangle.\n * @return True if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); False otherwise.\n */\nbool is_point_inside_triangle(double px, double py, double x1, double y1, double x2, double y2, double x3, double y3) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks if a point is inside a triangle defined by three vertices.\n *\n * @param px The x-coordinate of the point to check.\n * @param py The y-coordinate of the point to check.\n * @param x1 The x-coordinate of the first vertex of the triangle.\n * @param y1 The y-coordinate of the first vertex of the triangle.\n * @param x2 The x-coordinate of the second vertex of the triangle.\n * @param y2 The y-coordinate of the second vertex of the triangle.\n * @param x3 The x-coordinate of the third vertex of the triangle.\n * @param y3 The y-coordinate of the third vertex of the triangle.\n * @return true if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); false otherwise.\n */\npublic static boolean isPointInsideTriangle(double px, double py, double x1, double y1, double x2, double y2, double x3, double y3) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Test class for checking if a point is inside a triangle.\n */\npublic class Tester {\n\n    /**\n     * Test case where the point is inside the triangle.\n     */\n    @Test\n    public void testPointInsideTriangle() {\n        double[] triangleVertices = {0, 0, 5, 0, 2.5, 5};\n        double px = 2.5;\n        double py = 2;  // Inside the triangle\n\n        assertTrue(isPointInsideTriangle(px, py, triangleVertices[0], triangleVertices[1],\n                                         triangleVertices[2], triangleVertices[3],\n                                         triangleVertices[4], triangleVertices[5]));\n    }\n\n    /**\n     * Test case where the point is on the edge of the triangle.\n     */\n    @Test\n    public void testPointOnEdge() {\n        double[] triangleVertices = {0, 0, 5, 0, 2.5, 5};\n        double px = 2.5;\n        double py = 0;  // On the edge of the triangle\n\n        assertTrue(isPointInsideTriangle(px, py, triangleVertices[0], triangleVertices[1],\n                                         triangleVertices[2], triangleVertices[3],\n                                         triangleVertices[4], triangleVertices[5]));\n    }\n\n    /**\n     * Test case where the point is outside the triangle.\n     */\n    @Test\n    public void testPointOutsideTriangle() {\n        double[] triangleVertices = {0, 0, 5, 0, 2.5, 5};\n        double px = 6;\n        double py = 2;  // Outside the triangle\n\n        assertFalse(isPointInsideTriangle(px, py, triangleVertices[0], triangleVertices[1],\n                                          triangleVertices[2], triangleVertices[3],\n                                          triangleVertices[4], triangleVertices[5]));\n    }\n\n    /**\n     * Test case where the point is at one of the triangle's vertices.\n     */\n    @Test\n    public void testPointAtVertex() {\n        double[] triangleVertices = {0, 0, 5, 0, 2.5, 5};\n        double px = 0;\n        double py = 0;  // At the vertex of the triangle\n\n        assertTrue(isPointInsideTriangle(px, py, triangleVertices[0], triangleVertices[1],\n                                         triangleVertices[2], triangleVertices[3],\n                                         triangleVertices[4], triangleVertices[5]));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks if a point is inside a triangle defined by three vertices.\n *\n * @param px The x-coordinate of the point to check.\n * @param py The y-coordinate of the point to check.\n * @param x1 The x-coordinate of the first vertex of the triangle.\n * @param y1 The y-coordinate of the first vertex of the triangle.\n * @param x2 The x-coordinate of the second vertex of the triangle.\n * @param y2 The y-coordinate of the second vertex of the triangle.\n * @param x3 The x-coordinate of the third vertex of the triangle.\n * @param y3 The y-coordinate of the third vertex of the triangle.\n * @return true if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); false otherwise.\n */\npublic static boolean isPointInsideTriangle(double px, double py, double x1, double y1, double x2, double y2, double x3, double y3) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 546, "code_type": "method", "original_language": "python", "file_path": "NephScripts/991e118f5c32db6fa954d21e4745a8ecfe06eff5/bin/tsv2md\n", "question_type": "Data processing and transformation", "summary": "    Reads tab-separated values (TSV) from standard input and returns a list of rows.\n\n    Each row is represented as a list of strings. If rows have unequal lengths,\n    they are padded with empty strings to ensure all rows have the same length.", "language_version_list": {"python": {"code_signature": "import csv\nimport sys\n\n\ndef read_tsv_from_stdin():\n    \"\"\"\n    Reads tab-separated values (TSV) from standard input and returns a list of rows.\n\n    Each row is represented as a list of strings. If rows have unequal lengths,\n    they are padded with empty strings to ensure all rows have the same length.\n\n    Returns:\n        list: A list of lists, where each inner list represents a row of data.\n    \"\"\"\n", "test_code": "import unittest\nimport sys\nimport io\nfrom unittest.mock import patch\n\n\nclass TestReadTsvFromStdin(unittest.TestCase):\n\n    @patch('sys.stdin', new_callable=io.StringIO)\n    def test_basic_tsv_input(self, mock_stdin):\n        mock_stdin.write(\"col1\\tcol2\\tcol3\\nval1\\tval2\\tval3\\n\")\n        mock_stdin.seek(0)  # Move to the start of the StringIO object\n        expected_output = [['col1', 'col2', 'col3'], ['val1', 'val2', 'val3']]\n        self.assertEqual(read_tsv_from_stdin(), expected_output)\n\n\n    @patch('sys.stdin', new_callable=io.StringIO)\n    def test_single_column(self, mock_stdin):\n        mock_stdin.write(\"col1\\nval1\\nval2\\n\")\n        mock_stdin.seek(0)\n        expected_output = [['col1'], ['val1'], ['val2']]\n        self.assertEqual(read_tsv_from_stdin(), expected_output)\n", "prompt": "please write a python function , the function signature as below import csv\nimport sys\n\n\ndef read_tsv_from_stdin():\n    \"\"\"\n    Reads tab-separated values (TSV) from standard input and returns a list of rows.\n\n    Each row is represented as a list of strings. If rows have unequal lengths,\n    they are padded with empty strings to ensure all rows have the same length.\n\n    Returns:\n        list: A list of lists, where each inner list represents a row of data.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Reads tab-separated values (TSV) from standard input and returns a list of rows.\n *\n * Each row is represented as a vector of strings. If rows have unequal lengths,\n * they are padded with empty strings to ensure all rows have the same length.\n *\n * @return A vector of vectors, where each inner vector represents a row of data.\n */\nstd::vector<std::vector<std::string>> read_tsv_from_stdin() {}", "test_code": "TEST_CASE(\"Test basic TSV input\") {\n    // Redirect standard input to a stringstream\n    std::istringstream input_stream(\"col1\\tcol2\\tcol3\\nval1\\tval2\\tval3\\n\");\n    std::streambuf* prev_cin = std::cin.rdbuf(input_stream.rdbuf());\n\n    // Expected output\n    const std::vector<std::vector<std::string>> expected_output = {\n        {\"col1\", \"col2\", \"col3\"},\n        {\"val1\", \"val2\", \"val3\"}\n    };\n\n    // Call the function\n    const auto result = read_tsv_from_stdin();\n\n    // Restore the original standard input\n    std::cin.rdbuf(prev_cin);\n\n    // Check the result\n    REQUIRE(result == expected_output);\n}\n\nTEST_CASE(\"Test single column\") {\n    // Redirect standard input to a stringstream\n    std::istringstream input_stream(\"col1\\nval1\\nval2\\n\");\n    std::streambuf* prev_cin = std::cin.rdbuf(input_stream.rdbuf());\n\n    // Expected output\n    const std::vector<std::vector<std::string>> expected_output = {\n        {\"col1\"},\n        {\"val1\"},\n        {\"val2\"}\n    };\n\n    // Call the function\n    const auto result = read_tsv_from_stdin();\n\n    // Restore the original standard input\n    std::cin.rdbuf(prev_cin);\n\n    // Check the result\n    REQUIRE(result == expected_output);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Reads tab-separated values (TSV) from standard input and returns a list of rows.\n *\n * Each row is represented as a vector of strings. If rows have unequal lengths,\n * they are padded with empty strings to ensure all rows have the same length.\n *\n * @return A vector of vectors, where each inner vector represents a row of data.\n */\nstd::vector<std::vector<std::string>> read_tsv_from_stdin() {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads TSV data from standard input and pads rows to ensure they have the same length.\n *\n * @return A list of lists containing the padded data.\n */\npublic static List<List<String>> readTSVFromStdin() {}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.when;\n\n@ExtendWith(MockitoExtension.class)\npublic class Tester {\n\n    @Mock\n    private InputStream mockStdin;\n\n    @BeforeEach\n    void setUp() {\n        // Set up the mock standard input stream\n        System.setIn(mockStdin);\n    }\n\n    @Test\n    void testBasicTsvInput() {\n        String input = \"col1\\tcol2\\tcol3\\nval1\\tval2\\tval3\\n\";\n        when(mockStdin.readAllBytes()).thenReturn(input.getBytes());\n\n        List<List<String>> expectedOutput = List.of(\n            List.of(\"col1\", \"col2\", \"col3\"),\n            List.of(\"val1\", \"val2\", \"val3\")\n        );\n\n        List<List<String>> actualOutput = readTsvFromStdin();\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    @Test\n    void testSingleColumn() {\n        String input = \"col1\\nval1\\nval2\\n\";\n        when(mockStdin.readAllBytes()).thenReturn(input.getBytes());\n\n        List<List<String>> expectedOutput = List.of(\n            List.of(\"col1\"),\n            List.of(\"val1\"),\n            List.of(\"val2\")\n        );\n\n        List<List<String>> actualOutput = readTsvFromStdin();\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Reads TSV data from standard input and pads rows to ensure they have the same length.\n *\n * @return A list of lists containing the padded data.\n */\npublic static List<List<String>> readTSVFromStdin() {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 547, "code_type": "method", "original_language": "python", "file_path": "NephScripts/991e118f5c32db6fa954d21e4745a8ecfe06eff5/bin/tsv2md\n", "question_type": "Data processing and transformation", "summary": "Calculate the maximum width of each column in a list of lists where each sub-list represents a row of table data.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef calculate_column_widths(data: List[List[str]]) -> List[int]:\n    \"\"\"\n    Calculate the maximum width of each column in a list of lists where each sub-list represents a row of table data.\n\n    Args:\n        data (List[List[str]]): A two-dimensional list containing rows of data, where each inner list contains string elements representing the values in each column.\n\n    Returns:\n        List[int]: A list containing the maximum width (in characters) of each column across all rows. The width of a column is defined by the longest string present in that column.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestCalculateColumnWidths(unittest.TestCase):\n\n    def test_standard_case(self):\n        data = [[\"Name\", \"Age\", \"City\"],\n                [\"Alice\", \"22\", \"New York\"],\n                [\"Bob\", \"30\", \"San Francisco\"]]\n        expected = [5, 3, 13]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n\n    def test_single_element(self):\n        data = [[\"Name\"]]\n        expected = [4]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_varied_length(self):\n        data = [[\"a\", \"bb\", \"ccc\"],\n                [\"dddd\", \"ee\", \"f\"]]\n        expected = [4, 2, 3]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_all_empty_strings(self):\n        data = [[\"\", \"\", \"\"],\n                [\"\", \"\", \"\"]]\n        expected = [0, 0, 0]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_mixed_content(self):\n        data = [[\"1234\", \"567\", \"890\"],\n                [\"abc\", \"defg\", \"h\"]]\n        expected = [4, 4, 3]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_single_column_multiple_rows(self):\n        data = [[\"one\"],\n                [\"two\"],\n                [\"three\"]]\n        expected = [5]\n        self.assertEqual(calculate_column_widths(data), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef calculate_column_widths(data: List[List[str]]) -> List[int]:\n    \"\"\"\n    Calculate the maximum width of each column in a list of lists where each sub-list represents a row of table data.\n\n    Args:\n        data (List[List[str]]): A two-dimensional list containing rows of data, where each inner list contains string elements representing the values in each column.\n\n    Returns:\n        List[int]: A list containing the maximum width (in characters) of each column across all rows. The width of a column is defined by the longest string present in that column.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the maximum width of each column in a table.\n *\n * This function takes a two-dimensional vector representing rows of table data,\n * where each sub-list contains string elements representing the values in each column.\n *\n * @param data A two-dimensional vector containing rows of data.\n *              Each inner vector contains string elements representing the values in each column.\n *\n * @return A vector containing the maximum width (in characters) of each column\n *         across all rows. The width of a column is defined by the longest string\n *         present in that column.\n */\nstd::vector<int> calculate_column_widths(const std::vector<std::vector<std::string>>& data) {}", "test_code": "TEST_CASE(\"Test calculate_column_widths\") {\n    SECTION(\"Standard case\") {\n        std::vector<std::vector<std::string>> data = {\n            {\"Name\", \"Age\", \"City\"},\n            {\"Alice\", \"22\", \"New York\"},\n            {\"Bob\", \"30\", \"San Francisco\"}\n        };\n        std::vector<int> expected = {5, 3, 13};\n        REQUIRE(calculate_column_widths(data) == expected);\n    }\n\n    SECTION(\"Single element\") {\n        std::vector<std::vector<std::string>> data = {{\"Name\"}};\n        std::vector<int> expected = {4};\n        REQUIRE(calculate_column_widths(data) == expected);\n    }\n\n    SECTION(\"Varied length\") {\n        std::vector<std::vector<std::string>> data = {\n            {\"a\", \"bb\", \"ccc\"},\n            {\"dddd\", \"ee\", \"f\"}\n        };\n        std::vector<int> expected = {4, 2, 3};\n        REQUIRE(calculate_column_widths(data) == expected);\n    }\n\n    SECTION(\"All empty strings\") {\n        std::vector<std::vector<std::string>> data = {\n            {\"\", \"\", \"\"},\n            {\"\", \"\", \"\"}\n        };\n        std::vector<int> expected = {0, 0, 0};\n        REQUIRE(calculate_column_widths(data) == expected);\n    }\n\n    SECTION(\"Mixed content\") {\n        std::vector<std::vector<std::string>> data = {\n            {\"1234\", \"567\", \"890\"},\n            {\"abc\", \"defg\", \"h\"}\n        };\n        std::vector<int> expected = {4, 4, 3};\n        REQUIRE(calculate_column_widths(data) == expected);\n    }\n\n    SECTION(\"Single column multiple rows\") {\n        std::vector<std::vector<std::string>> data = {\n            {\"one\"},\n            {\"two\"},\n            {\"three\"}\n        };\n        std::vector<int> expected = {5};\n        REQUIRE(calculate_column_widths(data) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the maximum width of each column in a table.\n *\n * This function takes a two-dimensional vector representing rows of table data,\n * where each sub-list contains string elements representing the values in each column.\n *\n * @param data A two-dimensional vector containing rows of data.\n *              Each inner vector contains string elements representing the values in each column.\n *\n * @return A vector containing the maximum width (in characters) of each column\n *         across all rows. The width of a column is defined by the longest string\n *         present in that column.\n */\nstd::vector<int> calculate_column_widths(const std::vector<std::vector<std::string>>& data) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the maximum width of each column in a list of lists where each sub-list represents a row of table data.\n *\n * @param data A two-dimensional list containing rows of data, where each inner list contains string elements representing the values in each column.\n * @return A list containing the maximum width (in characters) of each column across all rows. The width of a column is defined by the longest string present in that column.\n */\npublic static List<Integer> calculateColumnWidths(List<List<String>> data) {}", "test_code": "package org.real.temp;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n\n\npublic class Tester {\n\n    @Test\n    public void testStandardCase() {\n        List<List<String>> data = Arrays.asList(\n            Arrays.asList(\"Name\", \"Age\", \"City\"),\n            Arrays.asList(\"Alice\", \"22\", \"New York\"),\n            Arrays.asList(\"Bob\", \"30\", \"San Francisco\")\n        );\n        List<Integer> expected = Arrays.asList(5, 3, 13);\n        assertEquals(expected, calculateColumnWidths(data));\n    }\n\n    @Test\n    public void testSingleElement() {\n        List<List<String>> data = Arrays.asList(\n            Arrays.asList(\"Name\")\n        );\n        List<Integer> expected = Arrays.asList(4);\n        assertEquals(expected, calculateColumnWidths(data));\n    }\n\n    @Test\n    public void testVariedLength() {\n        List<List<String>> data = Arrays.asList(\n            Arrays.asList(\"a\", \"bb\", \"ccc\"),\n            Arrays.asList(\"dddd\", \"ee\", \"f\")\n        );\n        List<Integer> expected = Arrays.asList(4, 2, 3);\n        assertEquals(expected, calculateColumnWidths(data));\n    }\n\n    @Test\n    public void testAllEmptyStrings() {\n        List<List<String>> data = Arrays.asList(\n            Arrays.asList(\"\", \"\", \"\"),\n            Arrays.asList(\"\", \"\", \"\")\n        );\n        List<Integer> expected = Arrays.asList(0, 0, 0);\n        assertEquals(expected, calculateColumnWidths(data));\n    }\n\n    @Test\n    public void testMixedContent() {\n        List<List<String>> data = Arrays.asList(\n            Arrays.asList(\"1234\", \"567\", \"890\"),\n            Arrays.asList(\"abc\", \"defg\", \"h\")\n        );\n        List<Integer> expected = Arrays.asList(4, 4, 3);\n        assertEquals(expected, calculateColumnWidths(data));\n    }\n\n    @Test\n    public void testSingleColumnMultipleRows() {\n        List<List<String>> data = Arrays.asList(\n            Arrays.asList(\"one\"),\n            Arrays.asList(\"two\"),\n            Arrays.asList(\"three\")\n        );\n        List<Integer> expected = Arrays.asList(5);\n        assertEquals(expected, calculateColumnWidths(data));\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the maximum width of each column in a list of lists where each sub-list represents a row of table data.\n *\n * @param data A two-dimensional list containing rows of data, where each inner list contains string elements representing the values in each column.\n * @return A list containing the maximum width (in characters) of each column across all rows. The width of a column is defined by the longest string present in that column.\n */\npublic static List<Integer> calculateColumnWidths(List<List<String>> data) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 548, "code_type": "method", "original_language": "python", "file_path": "stock/2b2a2f8a1c6273e54e9fc873fd911e382094aa5b/pyplot_linechart_Revenue.py\n", "question_type": "Data processing and transformation", "summary": "Reads a text file, wraps its content in JSON brackets, and parses it into a Python object.", "language_version_list": {"python": {"code_signature": "import json\n\n\ndef read_txt_add_json_bracket(filename:str):\n    \"\"\"\n    Reads a text file, wraps its content in JSON brackets, and parses it into a Python object.\n\n    Args:\n        filename (str): The path to the text file to be read.\n\n    Returns:\n        list: A list parsed from the JSON content wrapped in brackets.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        json.JSONDecodeError: If the content cannot be parsed as JSON.\n    \"\"\"", "test_code": "import os\nimport unittest\nfrom unittest.mock import patch, mock_open\n\n\nclass TestReadTxtAddJsonBracket(unittest.TestCase):\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data='{\"key\": \"value\"}')\n    def test_valid_json(self, mock_file):\n        result = read_txt_add_json_bracket(\"fakefile.txt\")\n        self.assertEqual(result, [{\"key\": \"value\"}])\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data='[]')\n    def test_empty_json_array(self, mock_file):\n        result = read_txt_add_json_bracket(\"fakefile.txt\")\n        self.assertEqual(result, [[]])  # Should return an empty list\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data='{\"key\": \"value\"}\\n')\n    def test_valid_json_with_newline(self, mock_file):\n        result = read_txt_add_json_bracket(\"fakefile.txt\")\n        self.assertEqual(result, [{\"key\": \"value\"}])\n\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data='{\"key\": \"value\"}')\n    def test_json_with_array(self, mock_file):\n        result = read_txt_add_json_bracket(\"fakefile.txt\")\n        self.assertEqual(result, [{\"key\": \"value\"}])\n", "prompt": "please write a python function , the function signature as below import json\n\n\ndef read_txt_add_json_bracket(filename:str):\n    \"\"\"\n    Reads a text file, wraps its content in JSON brackets, and parses it into a Python object.\n\n    Args:\n        filename (str): The path to the text file to be read.\n\n    Returns:\n        list: A list parsed from the JSON content wrapped in brackets.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        json.JSONDecodeError: If the content cannot be parsed as JSON.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 549, "code_type": "method", "original_language": "python", "file_path": "xpsi/02e399f659576bf80daaf888128e1f46c078073f/examples/examples_modeling_tutorial/modules/helper_functions.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "Converts temperature from keV to log10(K) for a given input (scalar or tuple)", "language_version_list": {"python": {"code_signature": "from typing import Union, Tuple\n\nimport numpy as np\n\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\ndef get_T_in_log10_Kelvin(T_keV: Union[float, Tuple]):\n    \"\"\"\n    Converts temperature from keV to log10(K) for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5\n\n    Args:\n        T_keV (float or tuple): The temperature in keV. Can be a scalar or a tuple of temperatures.\n\n    Returns:\n        float or tuple: The temperature(s) in log10(K) corresponding to the input.\n\n    Raises:\n        ValueError: If the input is not a scalar (int or float) or a tuple.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\nclass TestGetTInLog10Kelvin(unittest.TestCase):\n\n    # Existing test cases here...\n\n    def test_scalar_input_high_temperature(self):\n        \"\"\"Test with a high scalar input.\"\"\"\n        T_keV = 100.0\n        expected_result = np.log10(T_keV / k_B_over_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_scalar_input_low_temperature(self):\n        \"\"\"Test with a low scalar input.\"\"\"\n        T_keV = 0.01\n        expected_result = np.log10(T_keV / k_B_over_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_tuple_input_large_range(self):\n        \"\"\"Test with a tuple of temperatures over a large range.\"\"\"\n        T_keV = (0.1, 1.0, 10.0, 100.0, 1000.0)\n        expected_results = tuple(np.log10(t / k_B_over_keV) for t in T_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertEqual(result, expected_results)\n\n    def test_tuple_input_repeated_values(self):\n        \"\"\"Test with a tuple of repeated temperature values.\"\"\"\n        T_keV = (1.0, 1.0, 1.0)\n        expected_results = tuple(np.log10(t / k_B_over_keV) for t in T_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertEqual(result, expected_results)\n\n    def test_scalar_input_non_integer(self):\n        \"\"\"Test with a non-integer scalar input.\"\"\"\n        T_keV = 2.5\n        expected_result = np.log10(T_keV / k_B_over_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_tuple_input_floating_point(self):\n        \"\"\"Test with a tuple of floating-point temperatures.\"\"\"\n        T_keV = (1.5, 2.5, 3.5)\n        expected_results = tuple(np.log10(t / k_B_over_keV) for t in T_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertEqual(result, expected_results)\n\n\n    def test_large_tuple_input(self):\n        \"\"\"Test with a large tuple of temperature values.\"\"\"\n        T_keV = tuple(np.arange(1, 1001, 1))  # Temperatures from 1 keV to 1000 keV\n        expected_results = tuple(np.log10(t / k_B_over_keV) for t in T_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertEqual(result, expected_results)\n", "prompt": "please write a python function , the function signature as below from typing import Union, Tuple\n\nimport numpy as np\n\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\ndef get_T_in_log10_Kelvin(T_keV: Union[float, Tuple]):\n    \"\"\"\n    Converts temperature from keV to log10(K) for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5\n\n    Args:\n        T_keV (float or tuple): The temperature in keV. Can be a scalar or a tuple of temperatures.\n\n    Returns:\n        float or tuple: The temperature(s) in log10(K) corresponding to the input.\n\n    Raises:\n        ValueError: If the input is not a scalar (int or float) or a tuple.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 550, "code_type": "method", "original_language": "python", "file_path": "xpsi/02e399f659576bf80daaf888128e1f46c078073f/examples/examples_modeling_tutorial/modules/helper_functions.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "Converts temperature from log10(K) to keV for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5", "language_version_list": {"python": {"code_signature": "from typing import Tuple, Union\n\nimport numpy as np\n\n# Define the constant for conversion: Boltzmann constant in keV/K\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\ndef convert_log10_K_to_keV(T_log10_K: Union[float, Tuple]):\n    \"\"\"\n    Converts temperature from log10(K) to keV for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5\n\n    Args:\n        T_log10_K (float or tuple): The temperature in log10(K). Can be a scalar or a tuple of temperatures.\n\n    Returns:\n        float or tuple: The temperature(s) in keV corresponding to the input.\n\n    Raises:\n        ValueError: If the input is not a scalar (int or float) or a tuple.\n    \"\"\"\n", "test_code": "import unittest\n\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\nclass TestConvertLog10KToKeV(unittest.TestCase):\n\n    def test_scalar_input(self):\n        \"\"\"Test conversion of a single scalar log10(K) value.\"\"\"\n        T_log10_K = 3.0\n        expected_result = 10 ** T_log10_K * k_B_over_keV\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_tuple_input(self):\n        \"\"\"Test conversion of a tuple of log10(K) values.\"\"\"\n        T_log10_K = (2.0, 3.0, 4.0)\n        expected_results = tuple(10 ** t * k_B_over_keV for t in T_log10_K)\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertEqual(result, expected_results)\n\n    def test_zero_input(self):\n        \"\"\"Test conversion of log10(K) = 0.\"\"\"\n        T_log10_K = 0.0\n        expected_result = 10 ** T_log10_K * k_B_over_keV\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_negative_input(self):\n        \"\"\"Test conversion of a negative log10(K) value.\"\"\"\n        T_log10_K = -1.0\n        expected_result = 10 ** T_log10_K * k_B_over_keV\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_large_tuple_input(self):\n        \"\"\"Test conversion of a large tuple of log10(K) values.\"\"\"\n        T_log10_K = (1.0, 2.0, 3.0, 4.0, 5.0)\n        expected_results = tuple(10 ** t * k_B_over_keV for t in T_log10_K)\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertEqual(result, expected_results)\n\n    def test_single_large_value(self):\n        \"\"\"Test conversion of a large log10(K) value.\"\"\"\n        T_log10_K = 10.0\n        expected_result = 10 ** T_log10_K * k_B_over_keV\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_invalid_input(self):\n        \"\"\"Test conversion with invalid input (string).\"\"\"\n        T_log10_K = \"invalid\"\n        with self.assertRaises(ValueError):\n            convert_log10_K_to_keV(T_log10_K)\n", "prompt": "please write a python function , the function signature as below from typing import Tuple, Union\n\nimport numpy as np\n\n# Define the constant for conversion: Boltzmann constant in keV/K\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\ndef convert_log10_K_to_keV(T_log10_K: Union[float, Tuple]):\n    \"\"\"\n    Converts temperature from log10(K) to keV for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5\n\n    Args:\n        T_log10_K (float or tuple): The temperature in log10(K). Can be a scalar or a tuple of temperatures.\n\n    Returns:\n        float or tuple: The temperature(s) in keV corresponding to the input.\n\n    Raises:\n        ValueError: If the input is not a scalar (int or float) or a tuple.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 551, "code_type": "method", "original_language": "python", "file_path": "xpsi/02e399f659576bf80daaf888128e1f46c078073f/examples/examples_modeling_tutorial/modules/helper_functions.py\n", "question_type": "Algorithm and data structure", "summary": "Calculate the midpoints from a given array of edges", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef get_mids_from_edges(edges: np.ndarray):\n    \"\"\"\n    Calculate the midpoints from a given array of edges.\n    For example:\n        input: [0, 1, 2]\n        output: [0.5, 1.5]\n\n    Args:\n        edges (np.ndarray): An array of edge values.\n\n    Returns:\n        np.ndarray: An array of midpoints calculated from the edges.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestGetMidsFromEdges(unittest.TestCase):\n\n    def test_basic_case(self):\n        \"\"\"Test with a standard range of edges.\"\"\"\n        edges = np.array([1, 2, 3, 4])\n        expected_mids = np.array([1.5, 2.5, 3.5])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_single_interval(self):\n        \"\"\"Test with two edges (single interval).\"\"\"\n        edges = np.array([5, 10])\n        expected_mids = np.array([7.5])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_multiple_intervals(self):\n        \"\"\"Test with multiple intervals.\"\"\"\n        edges = np.array([0, 1, 2, 3, 4, 5])\n        expected_mids = np.array([0.5, 1.5, 2.5, 3.5, 4.5])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_negative_edges(self):\n        \"\"\"Test with negative edges.\"\"\"\n        edges = np.array([-5, -3, -1, 1])\n        expected_mids = np.array([-4.0, -2.0, 0.0])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_zero_edges(self):\n        \"\"\"Test with edges including zero.\"\"\"\n        edges = np.array([0, 1, 2])\n        expected_mids = np.array([0.5, 1.5])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_float_edges(self):\n        \"\"\"Test with floating-point edges.\"\"\"\n        edges = np.array([0.0, 1.5, 3.0])\n        expected_mids = np.array([0.75, 2.25])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_empty_array(self):\n        \"\"\"Test with an empty array.\"\"\"\n        edges = np.array([])\n        expected_mids = np.array([])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef get_mids_from_edges(edges: np.ndarray):\n    \"\"\"\n    Calculate the midpoints from a given array of edges.\n    For example:\n        input: [0, 1, 2]\n        output: [0.5, 1.5]\n\n    Args:\n        edges (np.ndarray): An array of edge values.\n\n    Returns:\n        np.ndarray: An array of midpoints calculated from the edges.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the midpoints from a given array of edges.\n * For example:\n *     input: [0, 1, 2]\n *     output: [0.5, 1.5]\n *\n * @param edges A vector of edge values.\n * @return A vector of midpoints calculated from the edges.\n */\nstd::vector<double> get_mids_from_edges(const std::vector<double>& edges) {}", "test_code": "TEST_CASE(\"Test Get Mids From Edges\") {\n    SECTION(\"Basic Case\") {\n        std::vector<double> edges = {1, 2, 3, 4};\n        std::vector<double> expected_mids = {1.5, 2.5, 3.5};\n        REQUIRE(get_mids_from_edges(edges) == expected_mids);\n    }\n\n    SECTION(\"Single Interval\") {\n        std::vector<double> edges = {5, 10};\n        std::vector<double> expected_mids = {7.5};\n        REQUIRE(get_mids_from_edges(edges) == expected_mids);\n    }\n\n    SECTION(\"Multiple Intervals\") {\n        std::vector<double> edges = {0, 1, 2, 3, 4, 5};\n        std::vector<double> expected_mids = {0.5, 1.5, 2.5, 3.5, 4.5};\n        REQUIRE(get_mids_from_edges(edges) == expected_mids);\n    }\n\n    SECTION(\"Negative Edges\") {\n        std::vector<double> edges = {-5, -3, -1, 1};\n        std::vector<double> expected_mids = {-4.0, -2.0, 0.0};\n        REQUIRE(get_mids_from_edges(edges) == expected_mids);\n    }\n\n    SECTION(\"Zero Edges\") {\n        std::vector<double> edges = {0, 1, 2};\n        std::vector<double> expected_mids = {0.5, 1.5};\n        REQUIRE(get_mids_from_edges(edges) == expected_mids);\n    }\n\n    SECTION(\"Float Edges\") {\n        std::vector<double> edges = {0.0, 1.5, 3.0};\n        std::vector<double> expected_mids = {0.75, 2.25};\n        REQUIRE(get_mids_from_edges(edges) == expected_mids);\n    }\n\n    SECTION(\"Empty Array\") {\n        std::vector<double> edges = {};\n        std::vector<double> expected_mids = {};\n        REQUIRE(get_mids_from_edges(edges) == expected_mids);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the midpoints from a given array of edges.\n * For example:\n *     input: [0, 1, 2]\n *     output: [0.5, 1.5]\n *\n * @param edges A vector of edge values.\n * @return A vector of midpoints calculated from the edges.\n */\nstd::vector<double> get_mids_from_edges(const std::vector<double>& edges) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate the midpoints from a given array of edges.\n *\n * @param edges An array of edge values.\n * @return An array of midpoints calculated from the edges.\n */\npublic static double[] getMidsFromEdges(double[] edges) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\n\npublic class Tester {\n\n    /**\n     * Test with a standard range of edges.\n     */\n    @Test\n    public void testBasicCase() {\n        double[] edges = {1, 2, 3, 4};\n        double[] expectedMids = {1.5, 2.5, 3.5};\n        assertArrayEquals(expectedMids, getMidsFromEdges(edges), 0.001);\n    }\n\n    /**\n     * Test with two edges (single interval).\n     */\n    @Test\n    public void testSingleInterval() {\n        double[] edges = {5, 10};\n        double[] expectedMids = {7.5};\n        assertArrayEquals(expectedMids, getMidsFromEdges(edges), 0.001);\n    }\n\n    /**\n     * Test with multiple intervals.\n     */\n    @Test\n    public void testMultipleIntervals() {\n        double[] edges = {0, 1, 2, 3, 4, 5};\n        double[] expectedMids = {0.5, 1.5, 2.5, 3.5, 4.5};\n        assertArrayEquals(expectedMids, getMidsFromEdges(edges), 0.001);\n    }\n\n    /**\n     * Test with negative edges.\n     */\n    @Test\n    public void testNegativeEdges() {\n        double[] edges = {-5, -3, -1, 1};\n        double[] expectedMids = {-4.0, -2.0, 0.0};\n        assertArrayEquals(expectedMids, getMidsFromEdges(edges), 0.001);\n    }\n\n    /**\n     * Test with edges including zero.\n     */\n    @Test\n    public void testZeroEdges() {\n        double[] edges = {0, 1, 2};\n        double[] expectedMids = {0.5, 1.5};\n        assertArrayEquals(expectedMids, getMidsFromEdges(edges), 0.001);\n    }\n\n    /**\n     * Test with floating-point edges.\n     */\n    @Test\n    public void testFloatEdges() {\n        double[] edges = {0.0, 1.5, 3.0};\n        double[] expectedMids = {0.75, 2.25};\n        assertArrayEquals(expectedMids, getMidsFromEdges(edges), 0.001);\n    }\n\n    /**\n     * Test with an empty array.\n     */\n    @Test\n    public void testEmptyArray() {\n        double[] edges = {};\n        double[] expectedMids = {};\n        assertArrayEquals(expectedMids, getMidsFromEdges(edges), 0.001);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculate the midpoints from a given array of edges.\n *\n * @param edges An array of edge values.\n * @return An array of midpoints calculated from the edges.\n */\npublic static double[] getMidsFromEdges(double[] edges) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 552, "code_type": "method", "original_language": "python", "file_path": "gradescope_grading_template/78e5ac5f34188d8d8683763cb23d3c1b9821f1ac/assert_utilities.py\n", "question_type": "Algorithm and data structure", "summary": "Compares two sets of floats for equality within a relative and absolute tolerance.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef are_sets_equal(set1, set2, rtol=1e-5, atol=1e-6):\n    \"\"\"\n    Compares two sets of floats for equality within a relative and absolute tolerance.\n\n    Args:\n        set1: The first set of floats.\n        set2: The second set of floats.\n        rtol: The relative tolerance (default: 1e-5).\n        atol: The absolute tolerance (default: 1e-6).\n\n    Returns:\n        True if the sets are equal within the specified tolerances, False otherwise.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestAreSetsEqual(unittest.TestCase):\n\n    def test_identical_sets(self):\n        \"\"\"Test with two identical sets of floats.\"\"\"\n        set1 = {1.0, 2.0, 3.0}\n        set2 = {1.0, 2.0, 3.0}\n        self.assertTrue(are_sets_equal(set1, set2))\n\n    def test_sets_with_close_values(self):\n        \"\"\"Test with two sets that are close within the tolerance.\"\"\"\n        set1 = {1.0, 2.00001, 3.0}\n        set2 = {1.0, 2.00002, 3.0}\n        self.assertTrue(are_sets_equal(set1, set2, rtol=1e-5, atol=1e-6))\n\n    def test_sets_with_large_difference(self):\n        \"\"\"Test with two sets that have large differences beyond tolerance.\"\"\"\n        set1 = {1.0, 2.0, 3.0}\n        set2 = {1.0, 2.5, 3.0}\n        self.assertFalse(are_sets_equal(set1, set2))\n\n    def test_sets_with_one_different_values(self):\n        \"\"\"Test with two sets containing one different floats.\"\"\"\n        set1 = {1.0, 2.0, 3.0}\n        set2 = {1.0, 2.000001, 3.0}\n        self.assertTrue(are_sets_equal(set1, set2, rtol=1e-5, atol=1e-6))\n\n    def test_empty_sets(self):\n        \"\"\"Test with two empty sets.\"\"\"\n        set1 = set()\n        set2 = set()\n        self.assertTrue(are_sets_equal(set1, set2))\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef are_sets_equal(set1, set2, rtol=1e-5, atol=1e-6):\n    \"\"\"\n    Compares two sets of floats for equality within a relative and absolute tolerance.\n\n    Args:\n        set1: The first set of floats.\n        set2: The second set of floats.\n        rtol: The relative tolerance (default: 1e-5).\n        atol: The absolute tolerance (default: 1e-6).\n\n    Returns:\n        True if the sets are equal within the specified tolerances, False otherwise.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Compares two sets of floats for equality within a relative and absolute tolerance.\n *\n * @param set1 The first set of floats.\n * @param set2 The second set of floats.\n * @param rtol The relative tolerance (default: 1e-5).\n * @param atol The absolute tolerance (default: 1e-6).\n * @return True if the sets are equal within the specified tolerances, False otherwise.\n */\nbool are_sets_equal(const std::set<double>& set1, const std::set<double>& set2, double rtol = 1e-5, double atol = 1e-6) {}", "test_code": "TEST_CASE(\"TestAreSetsEqual\", \"[areSetsEqual]\") {\n    SECTION(\"test_identical_sets\") {\n        // Test with two identical sets of floats\n        std::set<double> set1 = {1.0, 2.0, 3.0};\n        std::set<double> set2 = {1.0, 2.0, 3.0};\n        REQUIRE(are_sets_equal(set1, set2));\n    }\n\n    SECTION(\"test_sets_with_close_values\") {\n        // Test with two sets that are close within the tolerance\n        std::set<double> set1 = {1.0, 2.00001, 3.0};\n        std::set<double> set2 = {1.0, 2.00002, 3.0};\n        REQUIRE(are_sets_equal(set1, set2, 1e-5, 1e-6));\n    }\n\n    SECTION(\"test_sets_with_large_difference\") {\n        // Test with two sets that have large differences beyond tolerance\n        std::.set<double> set1 = {1.0, 2.0, 3.0};\n        std::.set<double> set2 = {1.0, 2.5, 3.0};\n        REQUIRE_FALSE(are_sets_equal(set1, set2));\n    }\n\n    SECTION(\"test_sets_with_one_different_value\") {\n        // Test with two sets containing one different float\n        std::.set<double> set1 = {1.0, 2.0, 3.0};\n        std::.set<double> set2 = {1.0, 2.000001, 3.0};\n        REQUIRE(are_sets_equal(set1, set2, 1e-5, 1e-6));\n    }\n\n    SECTION(\"test_empty_sets\") {\n        // Test with two empty sets\n        std::.set<double> set1 = {};\n        std::.set<double> set2 = {};\n        REQUIRE(are_sets_equal(set1, set2));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Compares two sets of floats for equality within a relative and absolute tolerance.\n *\n * @param set1 The first set of floats.\n * @param set2 The second set of floats.\n * @param rtol The relative tolerance (default: 1e-5).\n * @param atol The absolute tolerance (default: 1e-6).\n * @return True if the sets are equal within the specified tolerances, False otherwise.\n */\nbool are_sets_equal(const std::set<double>& set1, const std::set<double>& set2, double rtol = 1e-5, double atol = 1e-6) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Compares two sets of floats for equality within a relative and absolute tolerance.\n *\n * @param set1 The first set of floats.\n * @param set2 The second set of floats.\n * @param rtol The relative tolerance (default: 1e-5).\n * @param atol The absolute tolerance (default: 1e-6).\n * @return True if the sets are equal within the specified tolerances, False otherwise.\n */\npublic static boolean areSetsEqual(Set<Double> set1, Set<Double> set2, double rtol, double atol) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.Arrays;\n\npublic class Tester {\n    @Test\n    public void testIdenticalSets() {\n        Set<Double> set1 = new TreeSet<>(Arrays.asList(1.0, 2.0, 3.0));\n        Set<Double> set2 = new TreeSet<>(Arrays.asList(1.0, 2.0, 3.0));\n        assertTrue(\"Two identical sets should be equal\", areSetsEqual(set1, set2, 1e-5, 1e-6));\n    }\n\n    @Test\n    public void testSetsWithCloseValues() {\n        Set<Double> set1 = new TreeSet<>(Arrays.asList(1.0, 2.00001, 3.0));\n        Set<Double> set2 = new TreeSet<>(Arrays.asList(1.0, 2.00002, 3.0));\n        assertTrue(\"Two sets with close values should be equal\", areSetsEqual(set1, set2, 1e-5, 1e-6));\n    }\n\n    @Test\n    public void testSetsWithLargeDifference() {\n        Set<Double> set1 = new TreeSet<>(Arrays.asList(1.0, 2.0, 3.0));\n        Set<Double> set2 = new TreeSet<>(Arrays.asList(1.0, 2.5, 3.0));\n        assertFalse(\"Two sets with large differences should not be equal\", areSetsEqual(set1, set2, 1e-5, 1e-6));\n    }\n\n    @Test\n    public void testSetsWithOneDifferentValue() {\n        Set<Double> set1 = new TreeSet<>(Arrays.asList(1.0, 2.0, 3.0));\n        Set<Double> set2 = new TreeSet<>(Arrays.asList(1.0, 2.000001, 3.0));\n        assertTrue(\"Two sets with one different value should be equal\", areSetsEqual(set1, set2, 1e-5, 1e-6));\n    }\n\n    @Test\n    public void testEmptySets() {\n        Set<Double> set1 = new TreeSet<>();\n        Set<Double> set2 = new TreeSet<>();\n        assertTrue(\"Two empty sets should be equal\", areSetsEqual(set1, set2, 1e-5, 1e-6));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Compares two sets of floats for equality within a relative and absolute tolerance.\n *\n * @param set1 The first set of floats.\n * @param set2 The second set of floats.\n * @param rtol The relative tolerance (default: 1e-5).\n * @param atol The absolute tolerance (default: 1e-6).\n * @return True if the sets are equal within the specified tolerances, False otherwise.\n */\npublic static boolean areSetsEqual(Set<Double> set1, Set<Double> set2, double rtol, double atol) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 555, "code_type": "method", "original_language": "python", "file_path": "rigamajig2/b8fc87142efd66e974c4cdc1af1624f4c787dedb/python/rigamajig2/maya/mathUtils.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "Convert a quaternion into an angle", "language_version_list": {"python": {"code_signature": "import math\nfrom typing import Tuple\n\n\ndef quaternion_to_angle(quaternion: Tuple[float]) -> float:\n    \"\"\"\n    Converts a quaternion to a rotation angle in radians.\n\n    Args:\n        quaternion (Tuple[float]): A tuple or list containing the quaternion components (w, x, y, z)\n\n    Returns:\n        float: The rotation angle in radians\n    \"\"\"\n", "test_code": "import math\nimport unittest\n\n\nclass TestQuaternionToAngle(unittest.TestCase):\n\n    def test_identity_quaternion(self):\n        \"\"\"Test the identity quaternion (no rotation).\"\"\"\n        quaternion = (1.0, 0.0, 0.0, 0.0)\n        expected_angle = 0.0\n        self.assertAlmostEqual(quaternion_to_angle(quaternion), expected_angle)\n\n\n    def test_180_degrees_rotation(self):\n        \"\"\"Test a quaternion representing a 180-degree rotation.\"\"\"\n        quaternion = (0.0, 0.0, 1.0, 0.0)  # 180 degrees around Z axis\n        expected_angle = math.pi  # 180 degrees in radians\n        self.assertAlmostEqual(quaternion_to_angle(quaternion), expected_angle)\n\n    def test_360_degrees_rotation(self):\n        \"\"\"Test a quaternion representing a full 360-degree rotation.\"\"\"\n        quaternion = (1.0, 0.0, 0.0, 0.0)  # Full rotation\n        expected_angle = 0.0  # 360 degrees is equivalent to 0 degrees\n        self.assertAlmostEqual(quaternion_to_angle(quaternion), expected_angle)\n\n\n    def test_non_unit_quaternion(self):\n        \"\"\"Test a non-unit quaternion (should still give correct angle).\"\"\"\n        quaternion = (0.5, 0.5, 0.5, 0.5)  # This is not normalized\n        # Normalize the quaternion first\n        norm = math.sqrt(sum(x ** 2 for x in quaternion))\n        normalized_quaternion = tuple(x / norm for x in quaternion)\n        expected_angle = 2 * math.acos(normalized_quaternion[0])  # Should be same angle\n        self.assertAlmostEqual(quaternion_to_angle(normalized_quaternion), expected_angle)\n\n    def test_invalid_quaternion(self):\n        \"\"\"Test that an invalid quaternion raises a ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            quaternion_to_angle((1.0, 0.0, 0.0))  # Only 3 components", "prompt": "please write a python function , the function signature as below import math\nfrom typing import Tuple\n\n\ndef quaternion_to_angle(quaternion: Tuple[float]) -> float:\n    \"\"\"\n    Converts a quaternion to a rotation angle in radians.\n\n    Args:\n        quaternion (Tuple[float]): A tuple or list containing the quaternion components (w, x, y, z)\n\n    Returns:\n        float: The rotation angle in radians\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts a quaternion to a rotation angle in radians.\n *\n * @param quaternion A vector containing the quaternion components (w, x, y, z)\n * @return The rotation angle in radians\n */\ndouble quaternion_to_angle(const std::vector<double>& quaternion) {}", "test_code": "TEST_CASE(\"Test Quaternion to Angle\", \"[quaternion_to_angle]\") {\n    SECTION(\"Test the identity quaternion (no rotation)\") {\n        std::vector<double> quaternion = {1.0, 0.0, 0.0, 0.0};\n        double expected_angle = 0.0;\n        REQUIRE(quaternion_to_angle(quaternion) == Approx(expected_angle));\n    }\n\n    SECTION(\"Test a quaternion representing a 180-degree rotation\") {\n        std::vector<double> quaternion = {0.0, 0.0, 1.0, 0.0};  // 180 degrees around Z axis\n        double expected_angle = M_PI;  // 180 degrees in radians\n        REQUIRE(quaternion_to_angle(quaternion) == Approx(expected_angle));\n    }\n\n    SECTION(\"Test a quaternion representing a full 360-degree rotation\") {\n        std::vector<double> quaternion = {1.0, 0.0, 0.0, 0.0};  // Full rotation\n        double expected_angle = 0.0;  // 360 degrees is equivalent to 0 degrees\n        REQUIRE(quaternion_to_angle(quaternion) == Approx(expected_angle));\n    }\n\n    SECTION(\"Test a non-unit quaternion (should still give correct angle)\") {\n        std::vector<double> quaternion = {0.5, 0.5, 0.5, 0.5};  // This is not normalized\n        // Normalize the quaternion first\n        double norm = std::sqrt(std::accumulate(quaternion.begin(), quaternion.end(), 0.0,\n                                                [](double sum, double value) { return sum + value * value; }));\n        std::vector<double> normalized_quaternion;\n        for (double x : quaternion) {\n            normalized_quaternion.push_back(x / norm);\n        }\n        double expected_angle = 2 * std::acos(normalized_quaternion[0]);  // Should be same angle\n        REQUIRE(quaternion_to_angle(normalized_quaternion) == Approx(expected_angle));\n    }\n\n    SECTION(\"Test that an invalid quaternion raises a std::invalid_argument\") {\n        REQUIRE_THROWS_AS(quaternion_to_angle({1.0, 0.0, 0.0}), std::invalid_argument);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts a quaternion to a rotation angle in radians.\n *\n * @param quaternion A vector containing the quaternion components (w, x, y, z)\n * @return The rotation angle in radians\n */\ndouble quaternion_to_angle(const std::vector<double>& quaternion) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a quaternion to a rotation angle in radians.\n *\n * @param quaternion An array containing the quaternion components (w, x, y, z)\n * @return The rotation angle in radians\n */\npublic static double quaternionToAngle(double[] quaternion) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\npublic class Tester {\n\n    private static final double DELTA = 1e-15;\n\n    @Test\n    public void testIdentityQuaternion() {\n        double[] quaternion = {1.0, 0.0, 0.0, 0.0};\n        double expectedAngle = 0.0;\n        assertEquals(expectedAngle, quaternionToAngle(quaternion), DELTA);\n    }\n\n    @Test\n    public void test180DegreesRotation() {\n        double[] quaternion = {0.0, 0.0, 1.0, 0.0};  // 180 degrees around Z axis\n        double expectedAngle = Math.PI;  // 180 degrees in radians\n        assertEquals(expectedAngle, quaternionToAngle(quaternion), DELTA);\n    }\n\n    @Test\n    public void test360DegreesRotation() {\n        double[] quaternion = {1.0, 0.0, 0.0, 0.0};  // Full rotation\n        double expectedAngle = 0.0;  // 360 degrees is equivalent to 0 degrees\n        assertEquals(expectedAngle, quaternionToAngle(quaternion), DELTA);\n    }\n\n    @Test\n    public void testNonUnitQuaternion() {\n        double[] quaternion = {0.5, 0.5, 0.5, 0.5};  // This is not normalized\n        // Normalize the quaternion first\n        double norm = Math.sqrt(Arrays.stream(quaternion).map(x -> x * x).sum());\n        double[] normalizedQuaternion = Arrays.stream(quaternion).map(x -> x / norm).toArray();\n        double expectedAngle = 2 * Math.acos(normalizedQuaternion[0]);  // Should be same angle\n        assertEquals(expectedAngle, quaternionToAngle(normalizedQuaternion), DELTA);\n    }\n\n    @Test\n    public void testInvalidQuaternion() {\n        assertThrows(IllegalArgumentException.class, () -> {\n            quaternionToAngle(new double[]{1.0, 0.0, 0.0});  // Only 3 components\n        });\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a quaternion to a rotation angle in radians.\n *\n * @param quaternion An array containing the quaternion components (w, x, y, z)\n * @return The rotation angle in radians\n */\npublic static double quaternionToAngle(double[] quaternion) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 557, "code_type": "method", "original_language": "python", "file_path": "rigamajig2/b8fc87142efd66e974c4cdc1af1624f4c787dedb/python/rigamajig2/maya/mathUtils.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "Convert an angle from radians to degrees", "language_version_list": {"python": {"code_signature": "def radians_to_degrees(radians: float) -> int:\n    \"\"\"\n    Convert an angle from radians to degrees.\n\n    Args:\n        radians (float): The angle in radians to convert.\n\n    Returns:\n        int: The angle in degrees.\n    \"\"\"\n", "test_code": "import math\nimport unittest\n\n\nclass TestRadiansToDegrees(unittest.TestCase):\n    def test_zero_radians(self):\n        \"\"\"Test conversion of 0 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(0), 0, places=5)\n\n    def test_pi_over_two_radians(self):\n        \"\"\"Test conversion of \u03c0/2 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(math.pi / 2), 90, places=5)\n\n    def test_pi_radians(self):\n        \"\"\"Test conversion of \u03c0 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(math.pi), 180, places=5)\n\n    def test_three_pi_over_two_radians(self):\n        \"\"\"Test conversion of 3\u03c0/2 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(3 * math.pi / 2), 270, places=5)\n\n    def test_two_pi_radians(self):\n        \"\"\"Test conversion of 2\u03c0 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(2 * math.pi), 360, places=5)\n\n    def test_negative_pi_over_two_radians(self):\n        \"\"\"Test conversion of -\u03c0/2 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(-math.pi / 2), -90, places=5)\n\n    def test_large_radians(self):\n        \"\"\"Test conversion of a large angle (4\u03c0 radians)\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(4 * math.pi), 720, places=5)", "prompt": "please write a python function , the function signature as below def radians_to_degrees(radians: float) -> int:\n    \"\"\"\n    Convert an angle from radians to degrees.\n\n    Args:\n        radians (float): The angle in radians to convert.\n\n    Returns:\n        int: The angle in degrees.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert an angle from radians to degrees.\n *\n * @param radians The angle in radians to convert.\n * @return The angle in degrees as an integer.\n */\nint radians_to_degrees(double radians) {}", "test_code": "TEST_CASE(\"Test conversion of various angles\", \"[RadiansToDegrees]\") {\n    SECTION(\"Test conversion of 0 radians\") {\n        REQUIRE(radians_to_degrees(0) == 0);\n    }\n\n    SECTION(\"Test conversion of \u03c0/2 radians\") {\n        REQUIRE_THAT(radians_to_degrees(M_PI / 2), Catch::Matchers::WithinAbs(90, 0.00001));\n    }\n\n    SECTION(\"Test conversion of \u03c0 radians\") {\n        REQUIRE_THAT(radians_to_degrees(M_PI), Catch::Matchers::WithinAbs(180, 0.00001));\n    }\n\n    SECTION(\"Test conversion of 3\u03c0/2 radians\") {\n        REQUIRE_THAT(radians_to_degrees(3 * M_PI / 2), Catch::Matchers::WithinAbs(270, 0.00001));\n    }\n\n    SECTION(\"Test conversion of 2\u03c0 radians\") {\n        REQUIRE_THAT(radians_to_degrees(2 * M_PI), Catch::Matchers::WithinAbs(360, 0.00001));\n    }\n\n    SECTION(\"Test conversion of -\u03c0/2 radians\") {\n        REQUIRE_THAT(radians_to_degrees(-M_PI / 2), Catch::Matchers::WithinAbs(-90, 0.00001));\n    }\n\n    SECTION(\"Test conversion of a large angle (4\u03c0 radians)\") {\n        REQUIRE_THAT(radians_to_degrees(4 * M_PI), Catch::Matchers::WithinAbs(720, 0.00001));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert an angle from radians to degrees.\n *\n * @param radians The angle in radians to convert.\n * @return The angle in degrees as an integer.\n */\nint radians_to_degrees(double radians) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts an angle from radians to degrees.\n *\n * @param radians The angle in radians to convert.\n * @return The angle in degrees as an integer.\n */\npublic static int radiansToDegrees(double radians) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for converting radians to degrees.\n */\npublic class Tester {\n\n    /**\n     * Test conversion of 0 radians.\n     */\n    @Test\n    public void testZeroRadians() {\n        assertEquals(\"Conversion of 0 radians\", 0, radiansToDegrees(0), 0.00001);\n    }\n\n    /**\n     * Test conversion of \u03c0/2 radians.\n     */\n    @Test\n    public void testPiOverTwoRadians() {\n        assertEquals(\"Conversion of \u03c0/2 radians\", 90, radiansToDegrees(Math.PI / 2), 0.00001);\n    }\n\n    /**\n     * Test conversion of \u03c0 radians.\n     */\n    @Test\n    public void testPiRadians() {\n        assertEquals(\"Conversion of \u03c0 radians\", 180, radiansToDegrees(Math.PI), 0.00001);\n    }\n\n    /**\n     * Test conversion of 3\u03c0/2 radians.\n     */\n    @Test\n    public void testThreePiOverTwoRadians() {\n        assertEquals(\"Conversion of 3\u03c0/2 radians\", 270, radiansToDegrees(3 * Math.PI / 2), 0.00001);\n    }\n\n    /**\n     * Test conversion of 2\u03c0 radians.\n     */\n    @Test\n    public void testTwoPiRadians() {\n        assertEquals(\"Conversion of 2\u03c0 radians\", 360, radiansToDegrees(2 * Math.PI), 0.00001);\n    }\n\n    /**\n     * Test conversion of -\u03c0/2 radians.\n     */\n    @Test\n    public void testNegativePiOverTwoRadians() {\n        assertEquals(\"Conversion of -\u03c0/2 radians\", -90, radiansToDegrees(-Math.PI / 2), 0.00001);\n    }\n\n    /**\n     * Test conversion of a large angle (4\u03c0 radians).\n     */\n    @Test\n    public void testLargeRadians() {\n        assertEquals(\"Conversion of 4\u03c0 radians\", 720, radiansToDegrees(4 * Math.PI), 0.00001);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts an angle from radians to degrees.\n *\n * @param radians The angle in radians to convert.\n * @return The angle in degrees as an integer.\n */\npublic static int radiansToDegrees(double radians) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 558, "code_type": "method", "original_language": "python", "file_path": "rigamajig2/b8fc87142efd66e974c4cdc1af1624f4c787dedb/python/rigamajig2/maya/mathUtils.py\n", "question_type": "Scientific computation and numerical analysis", "summary": "Convert an angle from degrees to radians", "language_version_list": {"python": {"code_signature": "import math\n\n\ndef degrees_to_radians(degrees: int) -> float:\n    \"\"\"\n    Convert an angle from degrees to radians.\n\n    Args:\n        degrees (int): The angle in degrees to convert.\n\n    Returns:\n        float: The angle in radians.\n    \"\"\"\n", "test_code": "import math\nimport unittest\n\n\nclass TestDegreesToRadians(unittest.TestCase):\n    def test_zero_degrees(self):\n        \"\"\"Test conversion of 0 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(0), 0, places=5)\n\n    def test_ninety_degrees(self):\n        \"\"\"Test conversion of 90 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(90), math.pi / 2, places=5)\n\n    def test_one_eighty_degrees(self):\n        \"\"\"Test conversion of 180 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(180), math.pi, places=5)\n\n    def test_two_seventy_degrees(self):\n        \"\"\"Test conversion of 270 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(270), 3 * math.pi / 2, places=5)\n\n    def test_three_sixty_degrees(self):\n        \"\"\"Test conversion of 360 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(360), 2 * math.pi, places=5)\n\n    def test_negative_degrees(self):\n        \"\"\"Test conversion of negative degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(-90), -math.pi / 2, places=5)\n\n    def test_large_degrees(self):\n        \"\"\"Test conversion of a large angle (720 degrees)\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(720), 4 * math.pi, places=5)\n", "prompt": "please write a python function , the function signature as below import math\n\n\ndef degrees_to_radians(degrees: int) -> float:\n    \"\"\"\n    Convert an angle from degrees to radians.\n\n    Args:\n        degrees (int): The angle in degrees to convert.\n\n    Returns:\n        float: The angle in radians.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert an angle from degrees to radians.\n *\n * @param degrees The angle in degrees to convert.\n * @return The angle in radians.\n */\ndouble degrees_to_radians(int degrees) {}", "test_code": "TEST_CASE(\"Test conversion of angles\", \"[degrees_to_radians]\") {\n    SECTION(\"Test conversion of 0 degrees\") {\n        REQUIRE(std::abs(degrees_to_radians(0) - 0) < 1e-5);\n    }\n\n    SECTION(\"Test conversion of 90 degrees\") {\n        REQUIRE(std::abs(degrees_to_radians(90) - (M_PI / 2)) < 1e-5);\n    }\n\n    SECTION(\"Test conversion of 180 degrees\") {\n        REQUIRE(std::abs(degrees_to_radians(180) - M_PI) < 1e-5);\n    }\n\n    SECTION(\"Test conversion of 270 degrees\") {\n        REQUIRE(std::abs(degrees_to_radians(270) - (3 * M_PI / 2)) < 1e-5);\n    }\n\n    SECTION(\"Test conversion of 360 degrees\") {\n        REQUIRE(std::abs(degrees_to_radians(360) - (2 * M_PI)) < 1e-5);\n    }\n\n    SECTION(\"Test conversion of negative degrees\") {\n        REQUIRE(std::abs(degrees_to_radians(-90) - (-M_PI / 2)) < 1e-5);\n    }\n\n    SECTION(\"Test conversion of a large angle (720 degrees)\") {\n        REQUIRE(std::abs(degrees_to_radians(720) - (4 * M_PI)) < 1e-5);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert an angle from degrees to radians.\n *\n * @param degrees The angle in degrees to convert.\n * @return The angle in radians.\n */\ndouble degrees_to_radians(int degrees) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts an angle from degrees to radians.\n *\n * @param degrees The angle in degrees to convert.\n * @return The angle in radians.\n */\npublic static double degreesToRadians(int degrees) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n    @Test\n    public void testZeroDegrees() {\n        // Test conversion of 0 degrees\n        assertEquals(0, degreesToRadians(0), 1e-5);\n    }\n\n    @Test\n    public void testNinetyDegrees() {\n        // Test conversion of 90 degrees\n        assertEquals(Math.PI / 2, degreesToRadians(90), 1e-5);\n    }\n\n    @Test\n    public void testOneEightyDegrees() {\n        // Test conversion of 180 degrees\n        assertEquals(Math.PI, degreesToRadians(180), 1e-5);\n    }\n\n    @Test\n    public void testTwoSeventyDegrees() {\n        // Test conversion of 270 degrees\n        assertEquals(3 * Math.PI / 2, degreesToRadians(270), 1e-5);\n    }\n\n    @Test\n    public void testThreeSixtyDegrees() {\n        // Test conversion of 360 degrees\n        assertEquals(2 * Math.PI, degreesToRadians(360), 1e-5);\n    }\n\n    @Test\n    public void testNegativeDegrees() {\n        // Test conversion of negative degrees\n        assertEquals(-Math.PI / 2, degreesToRadians(-90), 1e-5);\n    }\n\n    @Test\n    public void testLargeDegrees() {\n        // Test conversion of a large angle (720 degrees)\n        assertEquals(4 * Math.PI, degreesToRadians(720), 1e-5);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts an angle from degrees to radians.\n *\n * @param degrees The angle in degrees to convert.\n * @return The angle in radians.\n */\npublic static double degreesToRadians(int degrees) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 87, "code_type": "method", "original_language": "javascript", "file_path": "send-to-telegram\\8fa1f460972b02ae35f746e6e525dfe395b2b99e\\src\\pages\\js\\logs.js", "question_type": "User interface", "summary": "Convert UNIX timestamps to a more readable time format in month-date-24h format", "language_version_list": {"python": {"code_signature": "from datetime import datetime\n\n\ndef convert_unix_timestamp_to_readable_date(unix_timestamp: int) -> str:\n    \"\"\"\n    Convert the UNIX timestamp to the string format 'MMM D, H:MM'.\n\n    Example:\n        Input: 1672531200\n        Output: 'Jan 1, 8:00'\n\n        Input: 1696516800\n        Output: 'Oct 5, 22:40'\n\n    Args:\n        unix_timestamp (int): The UNIX timestamp to convert.\n\n    Returns:\n        str: A formatted date string in the form 'MMM D, H:MM'.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestTimestampToReadableDate(unittest.TestCase):\n    def test_convert_unix_timestamp_to_readable_format(self):\n        timestamp = 1696516800\n        self.assertEqual(convert_unix_timestamp_to_readable_date(timestamp), 'Oct 5, 22:40')\n\n    def test_handle_timestamp_at_start_of_year(self):\n        timestamp = 1672531200\n        self.assertEqual(convert_unix_timestamp_to_readable_date(timestamp), 'Jan 1, 8:00')\n\n    def test_handle_timestamp_at_end_of_year(self):\n        timestamp = 1672531199\n        self.assertEqual(convert_unix_timestamp_to_readable_date(timestamp), 'Jan 1, 7:59')\n\n    def test_handle_timestamps_in_leap_year(self):\n        timestamp = 1583020800\n        self.assertEqual(convert_unix_timestamp_to_readable_date(timestamp), 'Mar 1, 8:00')\n\n    def test_convert_timestamp_to_readable_format_with_single_digit_day(self):\n        timestamp = 1675190400\n        self.assertEqual(convert_unix_timestamp_to_readable_date(timestamp), 'Feb 1, 2:40')\n\n    def test_handle_zero_unix_timestamp(self):\n        timestamp = 0\n        self.assertEqual(convert_unix_timestamp_to_readable_date(timestamp), 'Jan 1, 8:00')\n", "prompt": "please write a python function , the function signature as below from datetime import datetime\n\n\ndef convert_unix_timestamp_to_readable_date(unix_timestamp: int) -> str:\n    \"\"\"\n    Convert the UNIX timestamp to the string format 'MMM D, H:MM'.\n\n    Example:\n        Input: 1672531200\n        Output: 'Jan 1, 8:00'\n\n        Input: 1696516800\n        Output: 'Oct 5, 22:40'\n\n    Args:\n        unix_timestamp (int): The UNIX timestamp to convert.\n\n    Returns:\n        str: A formatted date string in the form 'MMM D, H:MM'.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "/**\n * Convert the UNIX timestamp to the string format 'Jan 1, 8:00'.\n * For example:\n *      input: 1672531200 output: Jan 1, 8:00\n *      input: 1696516800 output: Oct 5, 22:40\n *\n * @param unixTimestamp the UNIX timestamp to convert\n * @return the formatted date string\n */\npublic String timestampToReadableDate(long unixTimestamp) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.Calendar;\nimport java.util.GregorianCalendar;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    private String timestampToReadableDate(long unixTimestamp) {\n        long millis = unixTimestamp * 1000;\n        Calendar calendar = new GregorianCalendar();\n        calendar.setTimeInMillis(millis);\n        \n        String[] monthNames = {\n            \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n            \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n        };\n        \n        String month = monthNames[calendar.get(Calendar.MONTH)];\n        int day = calendar.get(Calendar.DAY_OF_MONTH);\n        int hours = calendar.get(Calendar.HOUR_OF_DAY);\n        String minutes = String.format(\"%02d\", calendar.get(Calendar.MINUTE));\n        \n        return String.format(\"%s %d, %d:%s\", month, day, hours, minutes);\n    }\n\n    @Test\n    public void testConvertUnixTimestampToReadableFormat() {\n        long timestamp = 1696516800;\n        assertEquals(\"Oct 5, 22:40\", timestampToReadableDate(timestamp));\n    }\n\n    @Test\n    public void testHandleTimestampAtStartOfYear() {\n        long timestamp = 1672531200;\n        assertEquals(\"Jan 1, 8:00\", timestampToReadableDate(timestamp));\n    }\n\n    @Test\n    public void testHandleTimestampAtEndOfYear() {\n        long timestamp = 1672531199;\n        assertEquals(\"Jan 1, 7:59\", timestampToReadableDate(timestamp));\n    }\n\n    @Test\n    public void testHandleTimestampsInLeapYear() {\n        long timestamp = 1583020800;\n        assertEquals(\"Mar 1, 8:00\", timestampToReadableDate(timestamp));\n    }\n\n    @Test\n    public void testConvertTimestampToReadableFormatWithSingleDigitDay() {\n        long timestamp = 1675190400;\n        assertEquals(\"Feb 1, 2:40\", timestampToReadableDate(timestamp));\n    }\n\n    @Test\n    public void testHandleZeroUnixTimestamp() {\n        long timestamp = 0;\n        assertEquals(\"Jan 1, 8:00\", timestampToReadableDate(timestamp));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Convert the UNIX timestamp to the string format 'Jan 1, 8:00'.\n * For example:\n *      input: 1672531200 output: Jan 1, 8:00\n *      input: 1696516800 output: Oct 5, 22:40\n *\n * @param unixTimestamp the UNIX timestamp to convert\n * @return the formatted date string\n */\npublic String timestampToReadableDate(long unixTimestamp) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 88, "code_type": "method", "original_language": "javascript", "file_path": "yunzai-meme\\e0ff65cf02d95507e9bb3af75ba3ab0044d5c4c8\\meme.js", "question_type": "Configuration and deployment", "summary": "Parse a crom expression and determine whether it is between 2 a.m. and 4 a.m.\n", "language_version_list": {"python": {"code_signature": "def is_cron_between_2_and_4_am(cron_expression: str) -> bool:\n    \"\"\"\n    Parse a cron expression and determine whether it is between 2 a.m. and 4 a.m.\n\n    Args:\n        cron_expression (str): The cron expression to parse.\n\n    Returns:\n        bool: True if any hour in the cron expression is between 2 a.m. and 4 a.m., False otherwise.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsCronBetween2And4AM(unittest.TestCase):\n\n    def test_specific_hours(self):\n        \"\"\"should return true for specific hours 2, 3, and 4\"\"\"\n        self.assertTrue(is_cron_between_2_and_4_am('0 2,3,4 * * *'))\n\n    def test_range_includes_2_to_4_am(self):\n        \"\"\"should return false for range that includes 2 to 4 a.m.\"\"\"\n        self.assertFalse(is_cron_between_2_and_4_am('0 1-5 * * *'))\n\n    def test_range_excludes_2_to_4_am(self):\n        \"\"\"should return false for range that excludes 2 to 4 a.m.\"\"\"\n        self.assertFalse(is_cron_between_2_and_4_am('0 0-1,5-23 * * *'))\n\n    def test_wildcard_in_hour_field(self):\n        \"\"\"should return false for wildcard in hour field\"\"\"\n        self.assertFalse(is_cron_between_2_and_4_am('0 * * * *'))\n", "prompt": "please write a python function , the function signature as below def is_cron_between_2_and_4_am(cron_expression: str) -> bool:\n    \"\"\"\n    Parse a cron expression and determine whether it is between 2 a.m. and 4 a.m.\n\n    Args:\n        cron_expression (str): The cron expression to parse.\n\n    Returns:\n        bool: True if any hour in the cron expression is between 2 a.m. and 4 a.m., False otherwise.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Parse a cron expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression The cron expression to parse.\n * @return true if the expression contains hours between 2 and 4, otherwise false.\n */\nbool isCronBetween2And4AM(const std::string& cronExpression) {\n\n}", "test_code": "TEST_CASE(\"isCronBetween2And4AM\") {\n    SECTION(\"should return true for specific hours 2, 3, and 4\") {\n        REQUIRE(isCronBetween2And4AM(\"0 2,3,4 * * *\") == true);\n    }\n\n    SECTION(\"should return false for range that includes 2 to 4 a.m.\") {\n        REQUIRE(isCronBetween2And4AM(\"0 1-5 * * *\") == false);\n    }\n\n    SECTION(\"should return false for range that excludes 2 to 4 a.m.\") {\n        REQUIRE(isCronBetween2And4AM(\"0 0-1,5-23 * * *\") == false);\n    }\n\n    SECTION(\"should return false for wildcard in hour field\") {\n        REQUIRE(isCronBetween2And4AM(\"0 * * * *\") == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Parse a cron expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression The cron expression to parse.\n * @return true if the expression contains hours between 2 and 4, otherwise false.\n */\nbool isCronBetween2And4AM(const std::string& cronExpression) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Parse a cron expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression the cron expression to parse\n * @return true if the hours are between 2 and 4 a.m., otherwise false\n */\npublic boolean isCronBetween2And4AM(String cronExpression) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testSpecificHours() {\n        assertTrue(isCronBetween2And4AM(\"0 2,3,4 * * *\"));\n    }\n\n    @Test\n    public void testRangeIncludes2To4AM() {\n        assertFalse(isCronBetween2And4AM(\"0 1-5 * * *\"));\n    }\n\n    @Test\n    public void testRangeExcludes2To4AM() {\n        assertFalse(isCronBetween2And4AM(\"0 0-1,5-23 * * *\"));\n    }\n\n    @Test\n    public void testWildcardInHourField() {\n        assertFalse(isCronBetween2And4AM(\"0 * * * *\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Parse a cron expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression the cron expression to parse\n * @return true if the hours are between 2 and 4 a.m., otherwise false\n */\npublic boolean isCronBetween2And4AM(String cronExpression) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 89, "code_type": "method", "original_language": "javascript", "file_path": "memory_game\\47a81aaca8659296710ce620a860143a653ab310\\assets\\js\\script.js", "question_type": "User interface", "summary": "calculates the elapsed time from a given start time in milliseconds and returns\nit as a formatted string in \"minutes:seconds\" format.", "language_version_list": {"python": {"code_signature": "def time_passed(start_time_in_millis: int) -> str:\n    \"\"\"\n    Calculates the elapsed time from a given start time in milliseconds and returns\n    it as a formatted string in \"minutes:seconds\" format.\n\n    Args:\n        start_time_in_millis (int): The start time in milliseconds.\n\n    Returns:\n        str: A string representing the elapsed time in minutes and seconds.\n    \"\"\"", "test_code": "import unittest\nfrom unittest.mock import patch\n\n\nclass TestTimePassed(unittest.TestCase):\n\n    @patch('time.time', return_value=1609459200)  # Mocking time to freeze at Jan 1, 2021, 00:00:00\n    def test_time_passed_one_minute_ago(self, mock_time):\n        start_time = 1609459140000  # 1 minute earlier\n        self.assertEqual(time_passed(start_time), \"1:00\")\n\n    @patch('time.time', return_value=1609459200)  # Mocking time\n    def test_time_passed_boundary_59_seconds(self, mock_time):\n        start_time = 1609459194100  # 59 seconds and 900 milliseconds earlier\n        self.assertEqual(time_passed(start_time), \"0:05\")\n\n    @patch('time.time', return_value=1609459200)  # Mocking time\n    def test_time_passed_same_as_current_time(self, mock_time):\n        self.assertEqual(time_passed(1609459200000), \"0:00\")\n\n    @patch('time.time', return_value=1609459200)  # Mocking time\n    def test_time_passed_future_start_time(self, mock_time):\n        start_time = 1609459260000  # 1 minute into the future\n        result = time_passed(start_time)\n        self.assertRegex(result, '-')  # Expecting negative output or some error handling\n\n    @patch('time.time', return_value=1609459200)  # Mocking time\n    def test_time_passed_large_time_difference(self, mock_time):\n        start_time = 1483228800000  # January 1, 2017, 00:00:00 (4 years difference)\n        self.assertEqual(time_passed(start_time), \"2103840:00\")  # Calculated minutes for 4 years\n", "prompt": "please write a python function , the function signature as below def time_passed(start_time_in_millis: int) -> str:\n    \"\"\"\n    Calculates the elapsed time from a given start time in milliseconds and returns\n    it as a formatted string in \"minutes:seconds\" format.\n\n    Args:\n        start_time_in_millis (int): The start time in milliseconds.\n\n    Returns:\n        str: A string representing the elapsed time in minutes and seconds.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param startTimeInMillis The start time in milliseconds.\n * @return A string representing the elapsed time in minutes and seconds.\n */\nstd::string timePassed(long long startTimeInMillis) {}", "test_code": "TEST_CASE(\"timePassed function\") {\n    SECTION(\"should correctly calculate time passed from 1 minute ago\") {\n        long long startTime = 1609459140000; // 1 minute earlier\n        REQUIRE(timePassed(startTime) == \"1:00\");\n    }\n\n    SECTION(\"should handle the boundary of 59 seconds correctly\") {\n        long long startTime = 1609459194100; // 59 seconds and 900 milliseconds earlier\n        REQUIRE(timePassed(startTime) == \"0:05\");\n    }\n\n    SECTION(\"should return 0:00 when start time is the same as current time\") {\n        REQUIRE(timePassed(1609459200000) == \"0:00\");\n    }\n\n    SECTION(\"should handle negative time differences (future start time)\") {\n        long long startTime = 1609459260000; // 1 minute into the future\n        std::string result = timePassed(startTime);\n        REQUIRE(result.find('-') != std::string::npos); // Expecting negative output or error handling\n    }\n\n    SECTION(\"should handle very large time differences correctly\") {\n        long long startTime = 1483228800000; // January 1, 2017, 00:00:00 (4 years difference)\n        REQUIRE(timePassed(startTime) == \"2103840:00\"); // Calculated minutes for 4 years\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param startTimeInMillis The start time in milliseconds.\n * @return A string representing the elapsed time in minutes and seconds.\n */\nstd::string timePassed(long long startTimeInMillis) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param startTimeInMillis The start time in milliseconds.\n * @return A string representing the elapsed time in minutes and seconds.\n */\npublic static String timePassed(long startTimeInMillis) {\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    private long fixedTimestamp;\n\n    @Before\n    public void setUp() {\n        // Freeze the current time to a fixed timestamp\n        fixedTimestamp = 1609459200000L; // January 1, 2021, 00:00:00\n    }\n    \n\n    @Test\n    public void testTimePassedOneMinuteAgo() {\n        long startTime = fixedTimestamp - 60000; // 1 minute earlier\n        assertEquals(\"1:00\", timePassed(startTime));\n    }\n\n    @Test\n    public void testTimePassedBoundaryOf59Seconds() {\n        long startTime = fixedTimestamp - 5900; // 59 seconds and 900 milliseconds earlier\n        assertEquals(\"0:05\", timePassed(startTime));\n    }\n\n    @Test\n    public void testTimePassedSameAsCurrentTime() {\n        assertEquals(\"0:00\", timePassed(fixedTimestamp));\n    }\n\n    @Test\n    public void testTimePassedFutureStartTime() {\n        long startTime = fixedTimestamp + 60000; // 1 minute into the future\n        String result = timePassed(startTime);\n        assertTrue(result.startsWith(\"-\")); // Expecting negative output or some error handling\n    }\n\n    @Test\n    public void testTimePassedLargeTimeDifference() {\n        long startTime = 1483228800000L; // January 1, 2017, 00:00:00 (4 years difference)\n        assertEquals(\"2103840:00\", timePassed(startTime)); // Calculated minutes for 4 years\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param startTimeInMillis The start time in milliseconds.\n * @return A string representing the elapsed time in minutes and seconds.\n */\npublic static String timePassed(long startTimeInMillis) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 92, "code_type": "method", "original_language": "javascript", "file_path": "HackDaildemo\\b2cd54e9c43bc7f8aaa89682f30db1af5d2abf6c\\src\\content-script\\site-adapters\\youtube\\index.mjs", "question_type": "Data processing and transformation", "summary": "Decodes HTML entities in a given HTML string.", "language_version_list": {"python": {"code_signature": "def replace_html_entities(html_string: str) -> str:\n    \"\"\"\n    Decodes HTML entities in a given HTML string.\n\n    Args:\n        html_string (str): The HTML string containing entities to decode.\n\n    Returns:\n        str: The decoded string with HTML entities converted back to their original characters.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestReplaceHtmlEntities(unittest.TestCase):\n\n    def test_decodes_standard_html_entities(self):\n        input_string = 'The &amp; symbol should become an &quot;and&quot; sign.'\n        expected = 'The & symbol should become an \"and\" sign.'\n        self.assertEqual(replace_html_entities(input_string), expected)\n\n    def test_returns_empty_string_for_empty_input(self):\n        input_string = ''\n        expected = ''\n        self.assertEqual(replace_html_entities(input_string), expected)\n\n    def test_decodes_multiple_different_entities_in_one_string(self):\n        input_string = '&lt;div&gt;Hello &amp; Welcome to the &apos;World&apos;!&lt;/div&gt;'\n        expected = '<div>Hello & Welcome to the \\'World\\'!</div>'\n        self.assertEqual(replace_html_entities(input_string), expected)\n\n    def test_handles_strings_with_no_entities(self):\n        input_string = 'Just a normal string without entities.'\n        expected = 'Just a normal string without entities.'\n        self.assertEqual(replace_html_entities(input_string), expected)\n", "prompt": "please write a python function , the function signature as below def replace_html_entities(html_string: str) -> str:\n    \"\"\"\n    Decodes HTML entities in a given HTML string.\n\n    Args:\n        html_string (str): The HTML string containing entities to decode.\n\n    Returns:\n        str: The decoded string with HTML entities converted back to their original characters.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Decodes HTML entities in a given HTML string.\n * @param htmlString The HTML string containing entities to decode.\n * @returns The decoded string with HTML entities converted back to their original characters.\n */\nstd::string replaceHtmlEntities(const std::string& htmlString) {\n    // Function implementation goes here\n}", "test_code": "TEST_CASE(\"replaceHtmlEntities\") {\n    SECTION(\"decodes standard HTML entities\") {\n        std::string input = \"The &amp; symbol should become an &quot;and&quot; sign.\";\n        std::string expected = \"The & symbol should become an \\\"and\\\" sign.\";\n        REQUIRE(replaceHtmlEntities(input) == expected);\n    }\n\n    SECTION(\"returns empty string for empty input\") {\n        std::string input = \"\";\n        std::string expected = \"\";\n        REQUIRE(replaceHtmlEntities(input) == expected);\n    }\n\n    SECTION(\"decodes multiple different entities in one string\") {\n        std::string input = \"&lt;div&gt;Hello &amp; Welcome to the &apos;World&apos;!&lt;/div&gt;\";\n        std::string expected = \"<div>Hello & Welcome to the 'World'!</div>\";\n        REQUIRE(replaceHtmlEntities(input) == expected);\n    }\n\n    SECTION(\"handles strings with no entities\") {\n        std::string input = \"Just a normal string without entities.\";\n        std::string expected = \"Just a normal string without entities.\";\n        REQUIRE(replaceHtmlEntities(input) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Decodes HTML entities in a given HTML string.\n * @param htmlString The HTML string containing entities to decode.\n * @returns The decoded string with HTML entities converted back to their original characters.\n */\nstd::string replaceHtmlEntities(const std::string& htmlString) {\n    // Function implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Decodes HTML entities in a given HTML string.\n * @param htmlString The HTML string containing entities to decode.\n * @return The decoded string with HTML entities converted back to their original characters.\n */\npublic static String replaceHtmlEntities(String htmlString) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testDecodesStandardHtmlEntities() {\n        String input = \"The &amp; symbol should become an &quot;and&quot; sign.\";\n        String expected = \"The & symbol should become an \\\"and\\\" sign.\";\n        assertEquals(expected, replaceHtmlEntities(input));\n    }\n\n    @Test\n    public void testReturnsEmptyStringForEmptyInput() {\n        String input = \"\";\n        String expected = \"\";\n        assertEquals(expected, replaceHtmlEntities(input));\n    }\n\n    @Test\n    public void testDecodesMultipleDifferentEntitiesInOneString() {\n        String input = \"&lt;div&gt;Hello &amp; Welcome to the &apos;World&apos;!&lt;/div&gt;\";\n        String expected = \"<div>Hello & Welcome to the 'World'!</div>\";\n        assertEquals(expected, replaceHtmlEntities(input));\n    }\n\n    @Test\n    public void testHandlesStringsWithNoEntities() {\n        String input = \"Just a normal string without entities.\";\n        String expected = \"Just a normal string without entities.\";\n        assertEquals(expected, replaceHtmlEntities(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Decodes HTML entities in a given HTML string.\n * @param htmlString The HTML string containing entities to decode.\n * @return The decoded string with HTML entities converted back to their original characters.\n */\npublic static String replaceHtmlEntities(String htmlString) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 93, "code_type": "method", "original_language": "javascript", "file_path": "Using-Konduktiva-With-MIDI\\94908d0d20eb0345457fe9275fec534ce0756330\\konduktiva-revised-2.js", "question_type": "Algorithm and data structure", "summary": "produces a character array of length 52 containing all lowercase uppercase letters in alphabetical order", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef get_all_alphabets() -> List[str]:\n    \"\"\"\n    Produces a list of length 52 containing all lowercase and uppercase letters in alphabetical order.\n\n    Returns:\n        list[str]: A list of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGetAllAlphabets(unittest.TestCase):\n\n    def test_return_length(self):\n        result = get_all_alphabets()\n        self.assertEqual(len(result), 52)\n\n    def test_lowercase_alphabets(self):\n        result = get_all_alphabets()\n        lowercase_alphabets = result[:26]\n        self.assertEqual(lowercase_alphabets, [\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n        ])\n\n    def test_uppercase_alphabets(self):\n        result = get_all_alphabets()\n        uppercase_alphabets = result[26:]\n        self.assertEqual(uppercase_alphabets, [\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'\n        ])\n\n    def test_first_element(self):\n        result = get_all_alphabets()\n        self.assertEqual(result[0], 'a')\n\n    def test_last_element(self):\n        result = get_all_alphabets()\n        self.assertEqual(result[-1], 'Z')\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef get_all_alphabets() -> List[str]:\n    \"\"\"\n    Produces a list of length 52 containing all lowercase and uppercase letters in alphabetical order.\n\n    Returns:\n        list[str]: A list of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * produces a character array of length 52 containing all lowercase and uppercase letters in alphabetical order\n *\n * @returns std::vector<char> A vector of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\nstd::vector<char> getAllAlphabets() {\n    // Function implementation goes here\n}", "test_code": "TEST_CASE(\"getAllAlphabets\") {\n    SECTION(\"should return a vector of 52 characters\") {\n        auto result = getAllAlphabets();\n        REQUIRE(result.size() == 52);\n    }\n\n    SECTION(\"should start with lowercase letters from a to z\") {\n        auto result = getAllAlphabets();\n        std::vector<char> lowercaseAlphabets(result.begin(), result.begin() + 26);\n        std::vector<char> expected = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n                                       'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};\n        REQUIRE(lowercaseAlphabets == expected);\n    }\n\n    SECTION(\"should end with uppercase letters from A to Z\") {\n        auto result = getAllAlphabets();\n        std::vector<char> uppercaseAlphabets(result.begin() + 26, result.end());\n        std::vector<char> expected = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n                                       'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};\n        REQUIRE(uppercaseAlphabets == expected);\n    }\n\n    SECTION(\"should return 'a' as the first element\") {\n        auto result = getAllAlphabets();\n        REQUIRE(result[0] == 'a');\n    }\n\n    SECTION(\"should return 'Z' as the last element\") {\n        auto result = getAllAlphabets();\n        REQUIRE(result.back() == 'Z');\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * produces a character array of length 52 containing all lowercase and uppercase letters in alphabetical order\n *\n * @returns std::vector<char> A vector of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\nstd::vector<char> getAllAlphabets() {\n    // Function implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Produces a character array of length 52 containing all lowercase and uppercase letters in alphabetical order.\n *\n * @return An array of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\npublic static char[] getAllAlphabets() {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testGetAllAlphabetsLength() {\n        char[] result =getAllAlphabets();\n        assertEquals(52, result.length);\n    }\n\n    @Test\n    public void testGetAllAlphabetsLowercase() {\n        char[] result =getAllAlphabets();\n        char[] lowercaseAlphabets = new char[26];\n        System.arraycopy(result, 0, lowercaseAlphabets, 0, 26);\n\n        char[] expected = {\n                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n                'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n                'u', 'v', 'w', 'x', 'y', 'z'\n        };\n\n        assertArrayEquals(expected, lowercaseAlphabets);\n    }\n\n    @Test\n    public void testGetAllAlphabetsUppercase() {\n        char[] result =getAllAlphabets();\n        char[] uppercaseAlphabets = new char[26];\n        System.arraycopy(result, 26, uppercaseAlphabets, 0, 26);\n\n        char[] expected = {\n                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n                'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n                'U', 'V', 'W', 'X', 'Y', 'Z'\n        };\n\n        assertArrayEquals(expected, uppercaseAlphabets);\n    }\n\n    @Test\n    public void testGetAllAlphabetsFirstElement() {\n        char[] result =getAllAlphabets();\n        assertEquals('a', result[0]);\n    }\n\n    @Test\n    public void testGetAllAlphabetsLastElement() {\n        char[] result =getAllAlphabets();\n        assertEquals('Z', result[result.length - 1]);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Produces a character array of length 52 containing all lowercase and uppercase letters in alphabetical order.\n *\n * @return An array of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\npublic static char[] getAllAlphabets() {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 94, "code_type": "yes", "original_language": "javascript", "file_path": "Using-Konduktiva-With-MIDI\\dbb39f39670ffae329b1cce77ed641f9ef758710\\example-melodies-data.js", "question_type": "Algorithm and data structure", "summary": "generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef create_circle_of_fifths(starting_note: str) -> List[str]:\n    \"\"\"\n    Generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note.\n\n    Args:\n        starting_note (str): The musical note to start the Circle of Fifths from (e.g., \"C\").\n\n    Returns:\n        List[str]: A list representing the Circle of Fifths.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCreateCircleOfFifths(unittest.TestCase):\n    def test_should_return_12_notes_in_the_circle(self):\n        result = create_circle_of_fifths('C')\n        self.assertEqual(len(result), 12)\n\n    def test_should_start_with_the_given_starting_note(self):\n        starting_note = 'G'\n        result = create_circle_of_fifths(starting_note)\n        self.assertEqual(result[0], starting_note)\n\n    def test_should_correctly_generate_the_circle_of_fifths_starting_from_C(self):\n        result = create_circle_of_fifths('C')\n        expected_circle = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#']\n        self.assertEqual(result, expected_circle)\n\n    def test_should_correctly_generate_the_circle_of_fifths_starting_from_G(self):\n        result = create_circle_of_fifths('G')\n        expected_circle = ['G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#', 'B#']\n        self.assertEqual(result, expected_circle)\n\n    def test_should_correctly_generate_the_circle_of_fifths_starting_from_F(self):\n        result = create_circle_of_fifths('F')\n        expected_circle = ['F', 'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#']\n        self.assertEqual(result, expected_circle)\n", "prompt": null, "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 95, "code_type": "method", "original_language": "javascript", "file_path": "Using-Konduktiva-With-MIDI\\a4fe0844bfcb987ecdd1d62441365df72220678a\\infoFromArray.js", "question_type": "Algorithm and data structure", "summary": "finds the matching elements and their indices in the input array according to the specified comparison function", "language_version_list": {"python": {"code_signature": "from typing import List, Any, Callable, Dict\n\n\ndef find_matching_elements(arr: List[Any], comparison_fn: Callable[[Any], bool]) -> List[Dict[str, Any]]:\n    \"\"\"\n    Finds matching elements and their indices in the input array\n    based on the specified comparison function.\n    Args:\n        arr (str): The input array to search through.\n        comparison_fn (): The comparison function to determine matches.\n\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries, each containing the matched element and its index.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFindMatchingElements(unittest.TestCase):\n\n    def test_empty_input_array(self):\n        result = find_matching_elements([], lambda el: el > 0)\n        self.assertEqual(result, [])\n\n    def test_matching_elements_and_indices(self):\n        input_array = [1, 2, 3, 4, 5]\n        comparison_function = lambda num: num > 3\n        result = find_matching_elements(input_array, comparison_function)\n        self.assertEqual(result, [\n            {'element': 4, 'index': 3},\n            {'element': 5, 'index': 4},\n        ])\n\n    def test_string_matching_condition(self):\n        input_array = ['apple', 'banana', 'cherry', 'date']\n        comparison_function = lambda fruit: fruit.startswith('b')\n        result = find_matching_elements(input_array, comparison_function)\n        self.assertEqual(result, [\n            {'element': 'banana', 'index': 1},\n        ])\n\n    def test_multiple_elements_with_same_value(self):\n        input_array = [1, 2, 2, 3, 2, 4]\n        comparison_function = lambda num: num == 2\n        result = find_matching_elements(input_array, comparison_function)\n        self.assertEqual(result, [\n            {'element': 2, 'index': 1},\n            {'element': 2, 'index': 2},\n            {'element': 2, 'index': 4},\n        ])\n\n    def test_matching_objects_based_on_property(self):\n        input_array = [\n            {'name': 'Alice', 'age': 25},\n            {'name': 'Bob', 'age': 30},\n            {'name': 'Charlie', 'age': 30},\n        ]\n        comparison_function = lambda person: person['age'] == 30\n        result = find_matching_elements(input_array, comparison_function)\n        self.assertEqual(result, [\n            {'element': {'name': 'Bob', 'age': 30}, 'index': 1},\n            {'element': {'name': 'Charlie', 'age': 30}, 'index': 2},\n        ])\n\n    def test_no_elements_if_no_matches_found(self):\n        input_array = [1, 3, 5, 7]\n        comparison_function = lambda num: num % 2 == 0  # looking for even numbers\n        result = find_matching_elements(input_array, comparison_function)\n        self.assertEqual(result, [])\n\n    def test_negative_numbers_condition(self):\n        input_array = [-1, -2, 0, 1, 2]\n        comparison_function = lambda num: num < 0\n        result = find_matching_elements(input_array, comparison_function)\n        self.assertEqual(result, [\n            {'element': -1, 'index': 0},\n            {'element': -2, 'index': 1},\n        ])\n", "prompt": "please write a python function , the function signature as below from typing import List, Any, Callable, Dict\n\n\ndef find_matching_elements(arr: List[Any], comparison_fn: Callable[[Any], bool]) -> List[Dict[str, Any]]:\n    \"\"\"\n    Finds matching elements and their indices in the input array\n    based on the specified comparison function.\n    Args:\n        arr (str): The input array to search through.\n        comparison_fn (): The comparison function to determine matches.\n\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries, each containing the matched element and its index.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Finds matching elements and their indices in the input array\n * based on the specified comparison function.\n *\n * @param arr - The input array to search through.\n * @param comparisonFn - The comparison function to determine matches.\n * @returns A vector of Match structs, each containing the matched element and its index.\n */\nstd::vector<Match> findMatchingElements(const std::vector<int>& arr, std::function<bool(int)> comparisonFn) {\n}", "test_code": "TEST_CASE(\"findMatchingElements\") {\n    \n    SECTION(\"should return an empty array for an empty input array\") {\n        auto result = findMatchingElements({}, [](const std::string&) { return false; });\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"should return matching elements and their indices\") {\n        std::vector<int> inputArray = {1, 2, 3, 4, 5};\n        auto comparisonFunction = [](int num) { return num > 3; };\n        auto result = findMatchingElements(inputArray, comparisonFunction);\n        REQUIRE(result == std::vector<Match>{{4, 3}, {5, 4}});\n    }\n\n    SECTION(\"should return elements that are strings matching a specific condition\") {\n        std::vector<std::string> inputArray = {\"apple\", \"banana\", \"cherry\", \"date\"};\n        auto comparisonFunction = [](const std::string& fruit) { return fruit.starts_with('b'); };\n        auto result = findMatchingElements(inputArray, comparisonFunction);\n        REQUIRE(result == std::vector<Match>{{\"banana\", 1}});\n    }\n\n    SECTION(\"should return multiple elements with the same value\") {\n        std::vector<int> inputArray = {1, 2, 2, 3, 2, 4};\n        auto comparisonFunction = [](int num) { return num == 2; };\n        auto result = findMatchingElements(inputArray, comparisonFunction);\n        REQUIRE(result == std::vector<Match>{{2, 1}, {2, 2}, {2, 4}});\n    }\n\n    SECTION(\"should return matching objects based on a property\") {\n        std::vector<std::map<std::string, int>> inputArray = {\n            {\"name\", 25},\n            {\"name\", 30},\n            {\"name\", 30},\n        };\n        auto comparisonFunction = [](const auto& person) { return person.at(\"age\") == 30; };\n        auto result = findMatchingElements(inputArray, comparisonFunction);\n        REQUIRE(result == std::vector<Match>{{{\"Bob\", 30}, 1}, {{\"Charlie\", 30}, 2}});\n    }\n\n    SECTION(\"should return no elements if no matches found\") {\n        std::vector<int> inputArray = {1, 3, 5, 7};\n        auto comparisonFunction = [](int num) { return num % 2 == 0; }; // looking for even numbers\n        auto result = findMatchingElements(inputArray, comparisonFunction);\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"should work with a comparison function that checks for negative numbers\") {\n        std::vector<int> inputArray = {-1, -2, 0, 1, 2};\n        auto comparisonFunction = [](int num) { return num < 0; };\n        auto result = findMatchingElements(inputArray, comparisonFunction);\n        REQUIRE(result == std::vector<Match>{{-1, 0}, {-2, 1}});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Finds matching elements and their indices in the input array\n * based on the specified comparison function.\n *\n * @param arr - The input array to search through.\n * @param comparisonFn - The comparison function to determine matches.\n * @returns A vector of Match structs, each containing the matched element and its index.\n */\nstd::vector<Match> findMatchingElements(const std::vector<int>& arr, std::function<bool(int)> comparisonFn) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds matching elements and their indices in the input array\n * based on the specified comparison function.\n *\n * @param arr - The input array to search through.\n * @param comparisonFn - The comparison function to determine matches.\n * @return - A list of objects, each containing the matched element and its index.\n */\npublic static class MatchResult {\n    private Object element;\n    private int index;\n\n    public MatchResult(Object element, int index) {\n        this.element = element;\n        this.index = index;\n    }\n\n    public Object getElement() {\n        return element;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n}\npublic static List<MatchResult> findMatchingElements(Object[] arr, Predicate<Object> comparisonFn) {\n    \n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.List;\nimport java.util.function.Predicate;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.findMatchingElements;\n\npublic class Tester {\n\n    @Test\n    public void testEmptyArray() {\n        List<Answer.MatchResult> result = findMatchingElements(new Object[]{}, el -> false);\n        assertEquals(0, result.size());\n    }\n\n    @Test\n    public void testMatchingElementsAndIndices() {\n        Object[] inputArray = {1, 2, 3, 4, 5};\n        Predicate<Object> comparisonFunction = num -> (Integer) num > 3;\n        List<Answer.MatchResult> result = findMatchingElements(inputArray, comparisonFunction);\n        assertEquals(2, result.size());\n        assertEquals(4, result.get(0).getElement());\n        assertEquals(3, result.get(0).getIndex());\n        assertEquals(5, result.get(1).getElement());\n        assertEquals(4, result.get(1).getIndex());\n    }\n\n    @Test\n    public void testStringMatchingCondition() {\n        Object[] inputArray = {\"apple\", \"banana\", \"cherry\", \"date\"};\n        Predicate<Object> comparisonFunction = fruit -> ((String) fruit).startsWith(\"b\");\n        List<Answer.MatchResult> result = findMatchingElements(inputArray, comparisonFunction);\n        assertEquals(1, result.size());\n        assertEquals(\"banana\", result.get(0).getElement());\n        assertEquals(1, result.get(0).getIndex());\n    }\n\n    @Test\n    public void testMultipleElementsWithSameValue() {\n        Object[] inputArray = {1, 2, 2, 3, 2, 4};\n        Predicate<Object> comparisonFunction = num -> (Integer) num == 2;\n        List<Answer.MatchResult> result = findMatchingElements(inputArray, comparisonFunction);\n        assertEquals(3, result.size());\n        assertEquals(2, result.get(0).getElement());\n        assertEquals(1, result.get(0).getIndex());\n        assertEquals(2, result.get(1).getElement());\n        assertEquals(2, result.get(1).getIndex());\n        assertEquals(2, result.get(2).getElement());\n        assertEquals(4, result.get(2).getIndex());\n    }\n\n    @Test\n    public void testMatchingObjectsByProperty() {\n        Object[] inputArray = {\n                new Person(\"Alice\", 25),\n                new Person(\"Bob\", 30),\n                new Person(\"Charlie\", 30)\n        };\n        Predicate<Object> comparisonFunction = person -> ((Person) person).getAge() == 30;\n        List<Answer.MatchResult> result = findMatchingElements(inputArray, comparisonFunction);\n        assertEquals(2, result.size());\n        assertEquals(\"Bob\", ((Person) result.get(0).getElement()).getName());\n        assertEquals(1, result.get(0).getIndex());\n        assertEquals(\"Charlie\", ((Person) result.get(1).getElement()).getName());\n        assertEquals(2, result.get(1).getIndex());\n    }\n\n    @Test\n    public void testNoMatchesFound() {\n        Object[] inputArray = {1, 3, 5, 7};\n        Predicate<Object> comparisonFunction = num -> (Integer) num % 2 == 0;\n        List<Answer.MatchResult> result = findMatchingElements(inputArray, comparisonFunction);\n        assertEquals(0, result.size());\n    }\n\n    @Test\n    public void testNegativeNumbers() {\n        Object[] inputArray = {-1, -2, 0, 1, 2};\n        Predicate<Object> comparisonFunction = num -> (Integer) num < 0;\n        List<Answer.MatchResult> result = findMatchingElements(inputArray, comparisonFunction);\n        assertEquals(2, result.size());\n        assertEquals(-1, result.get(0).getElement());\n        assertEquals(0, result.get(0).getIndex());\n        assertEquals(-2, result.get(1).getElement());\n        assertEquals(1, result.get(1).getIndex());\n    }\n\n    // Simple Person class for testing\n    public static class Person {\n        private String name;\n        private int age;\n\n        public Person(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public int getAge() {\n            return age;\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds matching elements and their indices in the input array\n * based on the specified comparison function.\n *\n * @param arr - The input array to search through.\n * @param comparisonFn - The comparison function to determine matches.\n * @return - A list of objects, each containing the matched element and its index.\n */\npublic static class MatchResult {\n    private Object element;\n    private int index;\n\n    public MatchResult(Object element, int index) {\n        this.element = element;\n        this.index = index;\n    }\n\n    public Object getElement() {\n        return element;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n}\npublic static List<MatchResult> findMatchingElements(Object[] arr, Predicate<Object> comparisonFn) {\n    \n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 96, "code_type": "method", "original_language": "javascript", "file_path": "seattlecontratunes\\b370e3192aeab7972e85821490627714c8323aaa\\seattlecontratunes\\song_directory\\static\\song_directory\\tune_manipulation\\changedClef.js", "question_type": "Data processing and transformation", "summary": "modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K:), or \"bass\" if no clef is specified", "language_version_list": {"python": {"code_signature": "def insert_clef(abc: str, clef: str = \"bass\") -> str:\n    \"\"\"\n    Modify the ABC string by inserting the specified clef (e.g., \"clef=bass\")\n    after the tone line (K:), or \"bass\" if no clef is specified.\n\n    Args:\n        abc (str): The ABC notation string.\n        clef (str): The clef to set (default is \"bass\").\n\n    Returns:\n        str: The updated ABC notation string with the new clef.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestChangedClef(unittest.TestCase):\n\n    def test_default_clef_insertion(self):\n        abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\"\n        result = insert_clef(abc)\n        expected = \"X:1\\nT:Test Tune\\nK:C clef=bass\\nC D E F|G A B c|\\n\"\n        self.assertEqual(result, expected)\n\n    def test_specific_clef_insertion(self):\n        abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\"\n        result = insert_clef(abc, \"treble\")\n        expected = \"X:1\\nT:Test Tune\\nK:C clef=treble\\nC D E F|G A B c|\\n\"\n        self.assertEqual(result, expected)\n\n    def test_no_newline_after_key_signature(self):\n        abc = \"X:1\\nT:Test Tune\\nK:C\"\n        result = insert_clef(abc, \"alto\")\n        expected = \"X:1\\nT:Test Tune\\nK:C clef=alto\"\n        self.assertEqual(result, expected)\n\n    def test_no_key_signature_found(self):\n        abc = \"X:1\\nT:Test Tune\\nC D E F|G A B c|\\n\"\n        result = insert_clef(abc, \"tenor\")\n        self.assertEqual(result, abc)  # Expect the original string to be returned unchanged\n\n    def test_multiple_key_signatures(self):\n        abc = \"X:1\\nT:Test Tune\\nK:G\\nG A B c|\\nK:D\\nD E F# G|\\n\"\n        result = insert_clef(abc, \"baritone\")\n        expected = \"X:1\\nT:Test Tune\\nK:G clef=baritone\\nG A B c|\\nK:D\\nD E F# G|\\n\"\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def insert_clef(abc: str, clef: str = \"bass\") -> str:\n    \"\"\"\n    Modify the ABC string by inserting the specified clef (e.g., \"clef=bass\")\n    after the tone line (K:), or \"bass\" if no clef is specified.\n\n    Args:\n        abc (str): The ABC notation string.\n        clef (str): The clef to set (default is \"bass\").\n\n    Returns:\n        str: The updated ABC notation string with the new clef.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K:), \n * or \"bass\" if no clef is specified.\n *\n * @param abc - The ABC notation string.\n * @param clef - The clef to set (default is \"bass\").\n * @returns - The updated ABC notation string with the new clef.\n */\nstd::string changedClef(const std::string& abc, const std::string& clef = \"bass\");", "test_code": "TEST_CASE(\"changedClef\", \"[changedClef]\") {\n    SECTION(\"should insert the clef at the correct position when the clef is not specified (default to 'bass')\") {\n        std::string abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        std::string result = changedClef(abc);\n        std::string expected = \"X:1\\nT:Test Tune\\nK:C clef=bass\\nC D E F|G A B c|\\n\";\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"should insert the clef at the correct position when a specific clef is provided\") {\n        std::string abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        std::string result = changedClef(abc, \"treble\");\n        std::string expected = \"X:1\\nT:Test Tune\\nK:C clef=treble\\nC D E F|G A B c|\\n\";\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"should handle cases where there is no newline after the key signature\") {\n        std::string abc = \"X:1\\nT:Test Tune\\nK:C\";\n        std::string result = changedClef(abc, \"alto\");\n        std::string expected = \"X:1\\nT:Test Tune\\nK:C clef=alto\";\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"should not alter the ABC notation if the key signature is not found\") {\n        std::string abc = \"X:1\\nT:Test Tune\\nC D E F|G A B c|\\n\";\n        std::string result = changedClef(abc, \"tenor\");\n        REQUIRE(result == abc); // Expect the original string to be returned unchanged\n    }\n\n    SECTION(\"should correctly handle ABC notation with multiple key signatures\") {\n        std::string abc = \"X:1\\nT:Test Tune\\nK:G\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        std::string result = changedClef(abc, \"baritone\");\n        std::string expected = \"X:1\\nT:Test Tune\\nK:G clef=baritone\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K:), \n * or \"bass\" if no clef is specified.\n *\n * @param abc - The ABC notation string.\n * @param clef - The clef to set (default is \"bass\").\n * @returns - The updated ABC notation string with the new clef.\n */\nstd::string changedClef(const std::string& abc, const std::string& clef = \"bass\");", "addition_info": ""}, "java": {"code_signature": "/**\n * Modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") \n * after the tone line (K:), or \"bass\" if no clef is specified.\n *\n * @param abc   The ABC notation string.\n * @param clef  The clef to set (default is \"bass\").\n * @return      The updated ABC notation string with the new clef.\n */\npublic static String changedClef(String abc, String clef) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testInsertClefDefault() {\n        String abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        String result = changedClef(abc, null);\n        String expected = \"X:1\\nT:Test Tune\\nK:C clef=bass\\nC D E F|G A B c|\\n\";\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testInsertClefSpecific() {\n        String abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        String result = changedClef(abc, \"treble\");\n        String expected = \"X:1\\nT:Test Tune\\nK:C clef=treble\\nC D E F|G A B c|\\n\";\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testNoNewlineAfterKeySignature() {\n        String abc = \"X:1\\nT:Test Tune\\nK:C\";\n        String result = changedClef(abc, \"alto\");\n        String expected = \"X:1\\nT:Test Tune\\nK:C clef=alto\";\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testNoKeySignatureFound() {\n        String abc = \"X:1\\nT:Test Tune\\nC D E F|G A B c|\\n\";\n        String result = changedClef(abc, \"tenor\");\n        assertEquals(abc, result); // Expect the original string to be returned unchanged\n    }\n\n    @Test\n    public void testMultipleKeySignatures() {\n        String abc = \"X:1\\nT:Test Tune\\nK:G\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        String result = changedClef(abc, \"baritone\");\n        String expected = \"X:1\\nT:Test Tune\\nK:G clef=baritone\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") \n * after the tone line (K:), or \"bass\" if no clef is specified.\n *\n * @param abc   The ABC notation string.\n * @param clef  The clef to set (default is \"bass\").\n * @return      The updated ABC notation string with the new clef.\n */\npublic static String changedClef(String abc, String clef) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 97, "code_type": "class", "original_language": "javascript", "file_path": "search-algo-visualizer\\fe16701379bbc1bb297e45ee0dd477c4ee60d5a5\\search-algo-visualizer\\src\\data-structures\\Queue.js", "question_type": "Data processing and transformation", "summary": "realize the basic functions of the data structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements", "language_version_list": {"python": {"code_signature": "class Queue:\n    def __init__(self):\n        \"\"\"Initialize an empty queue.\"\"\"\n        self.items = []\n\n    def enqueue(self, element):\n        \"\"\"Adds an element to the end of the queue.\n\n        Args:\n            element: The element to be added to the queue.\n        \"\"\"\n\n    def dequeue(self):\n        \"\"\"Removes and returns the element from the front of the queue.\n\n        Returns:\n            The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n        \"\"\"\n\n    def front(self):\n        \"\"\"Returns the front element of the queue without removing it.\n\n        Returns:\n            The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n        \"\"\"\n\n    def is_empty(self):\n        \"\"\"Checks if the queue is empty.\n\n        Returns:\n            True if the queue is empty, otherwise False.\n        \"\"\"\n        return len(self.items) == 0\n\n    def print_queue(self):\n        \"\"\"Returns a string representation of all the elements in the queue.\n\n        Returns:\n            A string containing all elements in the queue, separated by spaces.\n        \"\"\"", "test_code": "import unittest\n\n\nclass TestQueue(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Initialize an empty queue before each test.\"\"\"\n        self.queue = Queue()\n\n    def test_initialize_empty_queue(self):\n        \"\"\"Test if the queue is initialized empty.\"\"\"\n        self.assertTrue(self.queue.is_empty())\n\n    def test_enqueue_elements(self):\n        \"\"\"Test enqueueing elements into the queue.\"\"\"\n        self.queue.enqueue(1)\n        self.queue.enqueue(2)\n        self.queue.enqueue(3)\n        self.assertFalse(self.queue.is_empty())\n\n    def test_dequeue_elements(self):\n        \"\"\"Test dequeueing elements from the queue.\"\"\"\n        self.queue.enqueue(1)\n        self.queue.enqueue(2)\n        dequeued_element = self.queue.dequeue()\n        self.assertEqual(dequeued_element, 1)\n\n    def test_front_element(self):\n        \"\"\"Test getting the front element without removing it.\"\"\"\n        self.queue.enqueue(10)\n        self.queue.enqueue(20)\n        front_element = self.queue.front()\n        self.assertEqual(front_element, 10)\n\n    def test_check_empty_queue(self):\n        \"\"\"Test checking if the queue is empty.\"\"\"\n        self.assertTrue(self.queue.is_empty())\n        self.queue.enqueue(5)\n        self.assertFalse(self.queue.is_empty())\n        self.queue.dequeue()\n        self.assertTrue(self.queue.is_empty())\n", "prompt": "please write a python class , the class signature as below class Queue:\n    def __init__(self):\n        \"\"\"Initialize an empty queue.\"\"\"\n        self.items = []\n\n    def enqueue(self, element):\n        \"\"\"Adds an element to the end of the queue.\n\n        Args:\n            element: The element to be added to the queue.\n        \"\"\"\n\n    def dequeue(self):\n        \"\"\"Removes and returns the element from the front of the queue.\n\n        Returns:\n            The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n        \"\"\"\n\n    def front(self):\n        \"\"\"Returns the front element of the queue without removing it.\n\n        Returns:\n            The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n        \"\"\"\n\n    def is_empty(self):\n        \"\"\"Checks if the queue is empty.\n\n        Returns:\n            True if the queue is empty, otherwise False.\n        \"\"\"\n        return len(self.items) == 0\n\n    def print_queue(self):\n        \"\"\"Returns a string representation of all the elements in the queue.\n\n        Returns:\n            A string containing all elements in the queue, separated by spaces.\n        \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * realize the basic functions of the question structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements\n */\nclass Queue {\nprivate:\n    std::vector<int> items; // Change type as needed\n\npublic:\n    /**\n     * Adds an element to the end of the queue.\n     * @param element - The element to be added to the queue.\n     */\n    void enqueue(int element);\n\n    /**\n     * Removes and returns the element from the front of the queue.\n     * @returns The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n     */\n    std::string dequeue();\n\n    /**\n     * Returns the front element of the queue without removing it.\n     * @returns The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n     */\n    std::string front();\n\n    /**\n     * Checks if the queue is empty.\n     * @returns True if the queue is empty, otherwise false.\n     */\n    bool isEmpty();\n\n    /**\n     * Returns a string representation of all the elements in the queue.\n     * @returns A string containing all elements in the queue, separated by spaces.\n     */\n    std::string printQueue();\n};", "test_code": "TEST_CASE(\"Queue Class\", \"[queue]\") {\n    Queue queue;\n\n    SECTION(\"should initialize an empty queue\") {\n        REQUIRE(queue.isEmpty() == true);\n    }\n\n    SECTION(\"should enqueue elements to the queue\") {\n        queue.enqueue(1);\n        queue.enqueue(2);\n        queue.enqueue(3);\n        REQUIRE(queue.printQueue() == \"1 2 3\");\n        REQUIRE(queue.isEmpty() == false);\n    }\n\n    SECTION(\"should dequeue elements from the queue\") {\n        queue.enqueue(1);\n        queue.enqueue(2);\n        std::string dequeuedElement = queue.dequeue();\n        REQUIRE(dequeuedElement == \"1\");\n    }\n\n    SECTION(\"should return the front element without removing it\") {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        std::string frontElement = queue.front();\n        REQUIRE(frontElement == \"10\");\n    }\n\n    SECTION(\"should check if the queue is empty\") {\n        REQUIRE(queue.isEmpty() == true);\n        queue.enqueue(5);\n        REQUIRE(queue.isEmpty() == false);\n        queue.dequeue();\n        REQUIRE(queue.isEmpty() == true);\n    }\n}", "prompt": "please write a cpp class , the class signature as below /**\n * realize the basic functions of the question structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements\n */\nclass Queue {\nprivate:\n    std::vector<int> items; // Change type as needed\n\npublic:\n    /**\n     * Adds an element to the end of the queue.\n     * @param element - The element to be added to the queue.\n     */\n    void enqueue(int element);\n\n    /**\n     * Removes and returns the element from the front of the queue.\n     * @returns The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n     */\n    std::string dequeue();\n\n    /**\n     * Returns the front element of the queue without removing it.\n     * @returns The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n     */\n    std::string front();\n\n    /**\n     * Checks if the queue is empty.\n     * @returns True if the queue is empty, otherwise false.\n     */\n    bool isEmpty();\n\n    /**\n     * Returns a string representation of all the elements in the queue.\n     * @returns A string containing all elements in the queue, separated by spaces.\n     */\n    std::string printQueue();\n};", "addition_info": ""}, "java": {"code_signature": "\n\npublic class Answer{\nstatic class Queue {\n    private LinkedList<Object> items;\n\n    public Queue() {\n        this.items = new LinkedList<>();\n    }\n\n    /**\n     * Adds an element to the end of the queue.\n     * @param element The element to be added to the queue.\n     */\n    public void enqueue(Object element) {\n    }\n\n    /**\n     * Removes and returns the element from the front of the queue.\n     * @returns The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n     */\n    public Object dequeue() {\n    }\n\n    /**\n     * Returns the front element of the queue without removing it.\n     * @returns The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n     */\n    public Object front() {\n    }\n\n    /**\n     * Checks if the queue is empty.\n     * @returns True if the queue is empty, otherwise false.\n     */\n    public boolean isEmpty() {\n    }\n\n    /**\n     * Returns a string representation of all the elements in the queue.\n     * @returns A string containing all elements in the queue, separated by spaces.\n     */\n    public String printQueue() {\n    }\n}\n}\n\n\n", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n    private Queue queue;\n\n    @Before\n    public void setUp() {\n        queue = new Queue();\n    }\n\n    @Test\n    public void shouldInitializeAnEmptyQueue() {\n        assertTrue(queue.isEmpty());\n    }\n\n    @Test\n    public void shouldEnqueueElementsToTheQueue() {\n        queue.enqueue(1);\n        queue.enqueue(2);\n        queue.enqueue(3);\n        assertEquals(\"1 2 3\", queue.printQueue());\n        assertFalse(queue.isEmpty());\n    }\n\n    @Test\n    public void shouldDequeueElementsFromTheQueue() {\n        queue.enqueue(1);\n        queue.enqueue(2);\n        Object dequeuedElement = queue.dequeue();\n        assertEquals(1, dequeuedElement);\n    }\n\n    @Test\n    public void shouldReturnTheFrontElementWithoutRemovingIt() {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        Object frontElement = queue.front();\n        assertEquals(10, frontElement);\n    }\n\n    @Test\n    public void shouldCheckIfTheQueueIsEmpty() {\n        assertTrue(queue.isEmpty());\n        queue.enqueue(5);\n        assertFalse(queue.isEmpty());\n        queue.dequeue();\n        assertTrue(queue.isEmpty());\n    }\n}", "prompt": "please write a java class , the function signature as below \n\npublic class Answer{\nstatic class Queue {\n    private LinkedList<Object> items;\n\n    public Queue() {\n        this.items = new LinkedList<>();\n    }\n\n    /**\n     * Adds an element to the end of the queue.\n     * @param element The element to be added to the queue.\n     */\n    public void enqueue(Object element) {\n    }\n\n    /**\n     * Removes and returns the element from the front of the queue.\n     * @returns The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n     */\n    public Object dequeue() {\n    }\n\n    /**\n     * Returns the front element of the queue without removing it.\n     * @returns The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n     */\n    public Object front() {\n    }\n\n    /**\n     * Checks if the queue is empty.\n     * @returns True if the queue is empty, otherwise false.\n     */\n    public boolean isEmpty() {\n    }\n\n    /**\n     * Returns a string representation of all the elements in the queue.\n     * @returns A string containing all elements in the queue, separated by spaces.\n     */\n    public String printQueue() {\n    }\n}\n}\n\n\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 99, "code_type": "method", "original_language": "javascript", "file_path": "gptdoc\\108d3b70e187ed1f9c1b63424e0eb81fe13f7c0d\\example\\gpt.example.js", "question_type": "Algorithm and data structure", "summary": "Calculates the sum of all the numbers in a numeric array and returns it as a result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef calculate_sum(arr: List[int]):\n    \"\"\"\n    Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result.\n    For example, if you enter [1, 2, 3, 4, 5], the return value is 15.\n\n    Args:\n        arr (List[int]): The array of numbers to sum.\n\n    Returns:\n        int: The sum of all the numbers in the array.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSumFunction(unittest.TestCase):\n\n    def test_sum_of_positive_numbers(self):\n        \"\"\"Test the sum of a normal array of positive numbers.\"\"\"\n        self.assertEqual(calculate_sum([1, 2, 3, 4, 5]), 15)\n\n    def test_sum_of_negative_numbers(self):\n        \"\"\"Test the sum of an array containing negative numbers.\"\"\"\n        self.assertEqual(calculate_sum([-1, -2, -3, -4, -5]), -15)\n\n    def test_sum_of_empty_array(self):\n        \"\"\"Test that the sum of an empty array is 0.\"\"\"\n        self.assertEqual(calculate_sum([]), 0)\n\n    def test_sum_of_mixed_numbers(self):\n        \"\"\"Test the sum of an array containing both positive and negative numbers.\"\"\"\n        self.assertEqual(calculate_sum([10, -10, 5, -5, 15]), 15)\n\n    def test_sum_of_floating_point_numbers(self):\n        \"\"\"Test the sum of an array with floating point numbers.\"\"\"\n        self.assertAlmostEqual(calculate_sum([1.5, 2.5, 3.5]), 7.5)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef calculate_sum(arr: List[int]):\n    \"\"\"\n    Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result.\n    For example, if you enter [1, 2, 3, 4, 5], the return value is 15.\n\n    Args:\n        arr (List[int]): The array of numbers to sum.\n\n    Returns:\n        int: The sum of all the numbers in the array.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param arr - The vector of numbers to sum.\n */\nint sum(const std::vector<int>& arr) {\n    // Function implementation will go here\n}", "test_code": "TEST_CASE(\"Sum Function Tests\") {\n    SECTION(\"should return the sum of a normal array of positive numbers\") {\n        REQUIRE(sum({1, 2, 3, 4, 5}) == 15);\n    }\n\n    SECTION(\"should return the sum of an array containing negative numbers\") {\n        REQUIRE(sum({-1, -2, -3, -4, -5}) == -15);\n    }\n\n    SECTION(\"should return 0 for an empty array\") {\n        REQUIRE(sum({}) == 0);\n    }\n\n    SECTION(\"should return the sum of an array containing both positive and negative numbers\") {\n        REQUIRE(sum({10, -10, 5, -5, 15}) == 15);\n    }\n\n    SECTION(\"should return the sum of an array with floating point numbers\") {\n        REQUIRE(sum({1.5, 2.5, 3.5}) == Approx(7.5)); // Using Approx for floating-point comparison\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param arr - The vector of numbers to sum.\n */\nint sum(const std::vector<int>& arr) {\n    // Function implementation will go here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param arr The array of numbers to sum.\n */\npublic static int sum(int[] arr) {\n    \n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testSumNormalArray() {\n        assertEquals(15, sum(new int[]{1, 2, 3, 4, 5}));\n    }\n\n    @Test\n    public void testSumNegativeArray() {\n        assertEquals(-15, sum(new int[]{-1, -2, -3, -4, -5}));\n    }\n\n    @Test\n    public void testSumEmptyArray() {\n        assertEquals(0, sum(new int[]{}));\n    }\n\n    @Test\n    public void testSumMixedArray() {\n        assertEquals(15, sum(new int[]{10, -10, 5, -5, 15}));\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param arr The array of numbers to sum.\n */\npublic static int sum(int[] arr) {\n    \n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 100, "code_type": "method", "original_language": "javascript", "file_path": "GoogleSnakePudding\\95d53b7a49998d07b3fc715c7a9cb59f938e7002\\Libraries\\SpeedInfo.js", "question_type": "Data processing and transformation", "summary": "The function is to convert the ISO 8601 duration format to string format, for example PT2H5M is converted to 2h5m", "language_version_list": {"python": {"code_signature": "def convert_time(duration: str) -> str:\n    \"\"\"\n    Converts an ISO 8601 duration string into a more readable format.\n\n    Args:\n        duration (str): The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n\n    Returns:\n        str: A human-readable duration string (e.g., \"1h23m45s678ms\").\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestConvertTimeFunction(unittest.TestCase):\n\n    def test_full_iso_duration(self):\n        \"\"\"Test converting full ISO 8601 duration with hours, minutes, seconds, and milliseconds.\"\"\"\n        self.assertEqual(convert_time('PT1H23M45.678S'), '1h23m45s678ms')\n\n    def test_duration_with_seconds_and_milliseconds(self):\n        \"\"\"Test converting duration with only seconds and milliseconds.\"\"\"\n        self.assertEqual(convert_time('PT45.5S'), '45s500ms')\n\n    def test_duration_with_hours_and_minutes_no_seconds(self):\n        \"\"\"Test converting duration with hours and minutes, but no seconds.\"\"\"\n        self.assertEqual(convert_time('PT2H5M'), '2h5m')\n\n    def test_duration_with_only_seconds_no_milliseconds(self):\n        \"\"\"Test converting duration with only seconds, no milliseconds.\"\"\"\n        self.assertEqual(convert_time('PT20S'), '20s')\n", "prompt": "please write a python function , the function signature as below def convert_time(duration: str) -> str:\n    \"\"\"\n    Converts an ISO 8601 duration string into a more readable format.\n\n    Args:\n        duration (str): The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n\n    Returns:\n        str: A human-readable duration string (e.g., \"1h23m45s678ms\").\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <regex>\n#include <string>\n\n/**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param duration The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\nstd::string convertTime(const std::string& duration) {\n    std::regex regex(R\"(PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(\\.\\d+)?S)?)\");\n    std::smatch matches;\n\n    if (!std::regex_match(duration, matches, regex)) return \"\"; // Return an empty string if the input doesn't match\n\n    std::string convertedTime;\n    if (matches[1].length() > 0) {\n        convertedTime += matches[1].str() + \"h\";\n    }\n    if (matches[2].length() > 0) {\n        convertedTime += matches[2].str() + \"m\";\n    }\n    if (matches[3].length() > 0) {\n        convertedTime += matches[3].str() + \"s\";\n    }\n    if (matches[4].length() > 0) {\n        int milliseconds = static_cast<int>(std::round(std::stod(matches[4].str()) * 1000));\n        if (milliseconds > 0) {\n            convertedTime += std::to_string(milliseconds) + \"ms\";\n        }\n    }\n\n    return convertedTime;\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\nstd::string convertTime(const std::string& duration); // Forward declaration\n\nTEST_CASE(\"ConvertTime Function Tests\") {\n    SECTION(\"should correctly convert full ISO 8601 duration with hours, minutes, seconds, and milliseconds\") {\n        REQUIRE(convertTime(\"PT1H23M45.678S\") == \"1h23m45s678ms\");\n    }\n\n    SECTION(\"should correctly convert duration with only seconds and milliseconds\") {\n        REQUIRE(convertTime(\"PT45.5S\") == \"45s500ms\");\n    }\n\n    SECTION(\"should correctly convert duration with hours and minutes, but no seconds\") {\n        REQUIRE(convertTime(\"PT2H5M\") == \"2h5m\");\n    }\n\n    SECTION(\"should correctly convert duration with only seconds, no milliseconds\") {\n        REQUIRE(convertTime(\"PT20S\") == \"20s\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <regex>\n#include <string>\n\n/**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param duration The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\nstd::string convertTime(const std::string& duration) {\n    std::regex regex(R\"(PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(\\.\\d+)?S)?)\");\n    std::smatch matches;\n\n    if (!std::regex_match(duration, matches, regex)) return \"\"; // Return an empty string if the input doesn't match\n\n    std::string convertedTime;\n    if (matches[1].length() > 0) {\n        convertedTime += matches[1].str() + \"h\";\n    }\n    if (matches[2].length() > 0) {\n        convertedTime += matches[2].str() + \"m\";\n    }\n    if (matches[3].length() > 0) {\n        convertedTime += matches[3].str() + \"s\";\n    }\n    if (matches[4].length() > 0) {\n        int milliseconds = static_cast<int>(std::round(std::stod(matches[4].str()) * 1000));\n        if (milliseconds > 0) {\n            convertedTime += std::to_string(milliseconds) + \"ms\";\n        }\n    }\n\n    return convertedTime;\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param duration The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\npublic class TimeConverter {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testConvertTimeFullDuration() {\n        assertEquals(\"1h23m45s678ms\", convertTime(\"PT1H23M45.678S\"));\n    }\n\n    @Test\n    public void testConvertTimeOnlySecondsAndMilliseconds() {\n        assertEquals(\"45s500ms\", convertTime(\"PT45.5S\"));\n    }\n\n    @Test\n    public void testConvertTimeHoursAndMinutesNoSeconds() {\n        assertEquals(\"2h5m\", convertTime(\"PT2H5M\"));\n    }\n\n    @Test\n    public void testConvertTimeOnlySecondsNoMilliseconds() {\n        assertEquals(\"20s\", convertTime(\"PT20S\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param duration The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\npublic class TimeConverter {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 101, "code_type": "method", "original_language": "javascript", "file_path": "ElectronClassSchedule\\599a1c59f3880057548633e9b3774b78defed0a4\\js\\index.js", "question_type": "Data processing and transformation", "summary": "Determine whether the current time is within the specified time range (i.e., whether it is a break)\n", "language_version_list": {"python": {"code_signature": "def is_break_time(start_time: str, end_time: str, current_time: str) -> None:\n    \"\"\"\n    Determine whether the current time is within the specified time range (i.e., whether it is a break).\n\n    Args:\n        start_time (str): The start time of the break in HH:MM format.\n        end_time (str): The end time of the break in HH:MM format.\n        current_time (str): The current time in HH:MM format.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsBreakTime(unittest.TestCase):\n    def test_current_time_at_start(self):\n        self.assertTrue(is_break_time(\"09:00\", \"10:00\", \"09:00\"))\n\n    def test_current_time_within_range(self):\n        self.assertTrue(is_break_time(\"09:00\", \"10:00\", \"09:30\"))\n\n    def test_current_time_exceeds_end_time(self):\n        self.assertFalse(is_break_time(\"09:00\", \"10:00\", \"20:00\"))\n\n    def test_current_time_before_break_time(self):\n        self.assertFalse(is_break_time(\"09:00\", \"10:00\", \"08:59\"))\n\n    def test_current_time_after_break_time(self):\n        self.assertFalse(is_break_time(\"09:00\", \"10:00\", \"10:01\"))\n", "prompt": "please write a python function , the function signature as below def is_break_time(start_time: str, end_time: str, current_time: str) -> None:\n    \"\"\"\n    Determine whether the current time is within the specified time range (i.e., whether it is a break).\n\n    Args:\n        start_time (str): The start time of the break in HH:MM format.\n        end_time (str): The end time of the break in HH:MM format.\n        current_time (str): The current time in HH:MM format.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param startTime - The start time of the break in HH:MM format.\n * @param endTime - The end time of the break in HH:MM format.\n * @param currentTime - The current time in HH:MM format.\n * @return true if the current time is within the break time range, false otherwise.\n */\nbool isBreakTime(const std::string& startTime, const std::string& endTime, const std::string& currentTime) {\n    // Function implementation goes here\n}", "test_code": "TEST_CASE(\"isBreakTime Function Tests\") {\n    SECTION(\"should return true when current time is exactly at the start time\") {\n        REQUIRE(isBreakTime(\"09:00\", \"10:00\", \"09:00\") == true);\n    }\n\n    SECTION(\"should return true when current time is within the break time range\") {\n        REQUIRE(isBreakTime(\"09:00\", \"10:00\", \"09:30\") == true);\n    }\n\n    SECTION(\"should return false when current time exactly exceeds the end time\") {\n        REQUIRE(isBreakTime(\"09:00\", \"10:00\", \"10:00\") == false);\n    }\n\n    SECTION(\"should return false when current time is before the break time\") {\n        REQUIRE(isBreakTime(\"09:00\", \"10:00\", \"08:59\") == false);\n    }\n\n    SECTION(\"should return false when current time is after the break time\") {\n        REQUIRE(isBreakTime(\"09:00\", \"10:00\", \"10:01\") == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param startTime - The start time of the break in HH:MM format.\n * @param endTime - The end time of the break in HH:MM format.\n * @param currentTime - The current time in HH:MM format.\n * @return true if the current time is within the break time range, false otherwise.\n */\nbool isBreakTime(const std::string& startTime, const std::string& endTime, const std::string& currentTime) {\n    // Function implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param startTime - The start time of the break in HH:MM format.\n * @param endTime - The end time of the break in HH:MM format.\n * @param currentTime - The current time in HH:MM format.\n */\npublic static void isBreakTime(String startTime, String endTime, String currentTime) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testIsBreakTime_StartTime() {\n        assertTrue(isBreakTime(\"09:00\", \"10:00\", \"09:00\"));\n    }\n\n    @Test\n    public void testIsBreakTime_WithinRange() {\n        assertTrue(isBreakTime(\"09:00\", \"10:00\", \"09:30\"));\n    }\n\n    @Test\n    public void testIsBreakTime_ExceedEndTime() {\n        assertFalse(isBreakTime(\"09:00\", \"10:00\", \"20:00\"));\n    }\n\n    @Test\n    public void testIsBreakTime_BeforeStart() {\n        assertFalse(isBreakTime(\"09:00\", \"10:00\", \"08:59\"));\n    }\n\n    @Test\n    public void testIsBreakTime_AfterEnd() {\n        assertFalse(isBreakTime(\"09:00\", \"10:00\", \"10:01\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param startTime - The start time of the break in HH:MM format.\n * @param endTime - The end time of the break in HH:MM format.\n * @param currentTime - The current time in HH:MM format.\n */\npublic static void isBreakTime(String startTime, String endTime, String currentTime) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 103, "code_type": "method", "original_language": "javascript", "file_path": "Bing-Chat-History\\e84e3bded63150d605bba6647572445f0116eeff\\src\\pages\\js\\explorer.js", "question_type": "Data processing and transformation", "summary": "\nTruncate the string to the specified length, if the string exceeds the specified length, the excess part is used with an ellipsis (...) replace", "language_version_list": {"python": {"code_signature": "def truncate_string_with_replacement(s: str, max_length: int) -> str:\n    \"\"\"\n    Truncate a string to the specified length, replacing the excess part with an ellipsis.\n\n    Args:\n        s (str): The string to truncate.\n        max_length (int): The maximum length of the resulting string.\n\n    Returns:\n        str: The truncated string with ellipsis if applicable.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestTruncateStringWithReplacement(unittest.TestCase):\n\n    def test_should_return_original_string_if_shorter_than_max_length(self):\n        result = truncate_string_with_replacement('Hello World', 20)\n        self.assertEqual(result, 'Hello World')\n\n    def test_should_truncate_string_and_replace_excess_with_ellipsis(self):\n        result = truncate_string_with_replacement('This is a long string that needs to be truncated.', 20)\n        self.assertEqual(result, 'This is a long str...')\n\n    def test_should_truncate_string_at_max_length_and_add_ellipsis(self):\n        result = truncate_string_with_replacement('Short string', 10)\n        self.assertEqual(result, 'Short str...')\n\n    def test_should_handle_empty_string_correctly(self):\n        result = truncate_string_with_replacement('', 10)\n        self.assertEqual(result, '')\n\n    def test_should_return_original_string_when_max_length_equals_string_length(self):\n        result = truncate_string_with_replacement('Exact length', 12)\n        self.assertEqual(result, 'Exact length')\n\n    def test_should_replace_excess_with_ellipsis_in_string_with_special_characters(self):\n        result = truncate_string_with_replacement('This string has special characters: !@#$%^&*()', 30)\n        self.assertEqual(result, 'This string has special c...')\n\n    def test_should_return_ellipsis_only_when_max_length_is_0(self):\n        result = truncate_string_with_replacement('Hello, world!', 0)\n        self.assertEqual(result, '...')\n", "prompt": "please write a python function , the function signature as below def truncate_string_with_replacement(s: str, max_length: int) -> str:\n    \"\"\"\n    Truncate a string to the specified length, replacing the excess part with an ellipsis.\n\n    Args:\n        s (str): The string to truncate.\n        max_length (int): The maximum length of the resulting string.\n\n    Returns:\n        str: The truncated string with ellipsis if applicable.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Truncate a string to the specified length, replacing the excess part with an ellipsis.\n *\n * @param str - The string to truncate.\n * @param maxLength - The maximum length of the resulting string.\n * @returns - The truncated string with ellipsis if applicable.\n */\nstd::string truncateStringWithReplacement(const std::string& str, size_t maxLength) {\n}", "test_code": "TEST_CASE(\"truncateStringWithReplacement\") {\n    SECTION(\"should return the original string if it is shorter than maxLength\") {\n        REQUIRE(truncateStringWithReplacement(\"Hello World\", 20) == \"Hello World\");\n    }\n\n    SECTION(\"should truncate the string and replace the excess with ellipsis when longer than maxLength\") {\n        REQUIRE(truncateStringWithReplacement(\"This is a long string that needs to be truncated.\", 20) == \"This is a long str...\");\n    }\n\n    SECTION(\"should truncate the string at maxLength and add ellipsis\") {\n        REQUIRE(truncateStringWithReplacement(\"Short string\", 10) == \"Short str...\");\n    }\n\n    SECTION(\"should handle empty string correctly\") {\n        REQUIRE(truncateStringWithReplacement(\"\", 10) == \"\");\n    }\n\n    SECTION(\"should return the original string when maxLength is equal to string length\") {\n        REQUIRE(truncateStringWithReplacement(\"Exact length\", 12) == \"Exact length\");\n    }\n\n    SECTION(\"should replace excess part with ellipsis in a string with special characters\") {\n        REQUIRE(truncateStringWithReplacement(\"This string has special characters: !@#$%^&*()\", 30) == \"This string has special c...\");\n    }\n\n    SECTION(\"should return ellipsis only when the maxLength is 0\") {\n        REQUIRE(truncateStringWithReplacement(\"Hello, world!\", 0) == \"...\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Truncate a string to the specified length, replacing the excess part with an ellipsis.\n *\n * @param str - The string to truncate.\n * @param maxLength - The maximum length of the resulting string.\n * @returns - The truncated string with ellipsis if applicable.\n */\nstd::string truncateStringWithReplacement(const std::string& str, size_t maxLength) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Truncate a string to the specified length, replacing the excess part with an ellipsis.\n *\n * @param str - The string to truncate.\n * @param maxLength - The maximum length of the resulting string.\n * @return - The truncated string with ellipsis if applicable.\n */\npublic static String truncateStringWithReplacement(String str, int maxLength) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testOriginalStringShorterThanMaxLength() {\n        String result = truncateStringWithReplacement(\"Hello World\", 20);\n        assertEquals(\"Hello World\", result);\n    }\n\n\n    @Test\n    public void testHandleEmptyString() {\n        String result = truncateStringWithReplacement(\"\", 10);\n        assertEquals(\"\", result);\n    }\n\n    @Test\n    public void testOriginalStringEqualToMaxLength() {\n        String result = truncateStringWithReplacement(\"Exact length\", 12);\n        assertEquals(\"Exact length\", result);\n    }\n\n\n    @Test\n    public void testMaxLengthZeroReturnsEllipsis() {\n        String result = truncateStringWithReplacement(\"Hello, world!\", 0);\n        assertEquals(\"...\", result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Truncate a string to the specified length, replacing the excess part with an ellipsis.\n *\n * @param str - The string to truncate.\n * @param maxLength - The maximum length of the resulting string.\n * @return - The truncated string with ellipsis if applicable.\n */\npublic static String truncateStringWithReplacement(String str, int maxLength) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 104, "code_type": "method", "original_language": "javascript", "file_path": "Bing-Chat-History\\e84e3bded63150d605bba6647572445f0116eeff\\src\\pages\\js\\explorer.js", "question_type": "Data processing and transformation", "summary": "The incoming thread object is converted into a JSON file, which is represented as a Blob object.", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 106, "code_type": "method", "original_language": "javascript", "file_path": "Kommuniti\\d19d61943eb920b1705e05cf96a8fad534a0fb51\\lib\\utils.jsx", "question_type": "File operations and I/O operation", "summary": "Checks if the provided image data is a valid Base64 encoded image string.", "language_version_list": {"python": {"code_signature": "def is_base64_image(image_data: str) -> None:\n    \"\"\"\n    Checks if the provided image data is a valid Base64 encoded image string.\n\n    Args:\n        image_data (str): The image data string to be validated.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsBase64Image(unittest.TestCase):\n\n    def test_valid_png(self):\n        valid_png = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA'\n        self.assertTrue(is_base64_image(valid_png))\n\n    def test_valid_jpeg(self):\n        valid_jpeg = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAAAAAA'\n        self.assertTrue(is_base64_image(valid_jpeg))\n\n    def test_invalid_format(self):\n        invalid_format = 'data:text/plain;base64,SGVsbG8gd29ybGQ='\n        self.assertFalse(is_base64_image(invalid_format))\n\n    def test_invalid_base64_characters(self):\n        invalid_base64 = 'data:image/png;base64,invalidBase64String@#%'\n        self.assertFalse(is_base64_image(invalid_base64))\n\n    def test_empty_string(self):\n        self.assertFalse(is_base64_image(''))\n", "prompt": "please write a python function , the function signature as below def is_base64_image(image_data: str) -> None:\n    \"\"\"\n    Checks if the provided image data is a valid Base64 encoded image string.\n\n    Args:\n        image_data (str): The image data string to be validated.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param imageData - The image data string to be validated.\n */\nbool isBase64Image(const std::string& imageData) {\n    \n}", "test_code": "TEST_CASE(\"isBase64Image\") {\n    SECTION(\"should return true for a valid PNG Base64 image string\") {\n        std::string validPng = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\";\n        REQUIRE(isBase64Image(validPng) == true);\n    }\n\n    SECTION(\"should return true for a valid JPEG Base64 image string\") {\n        std::string validJpeg = \"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAAAAAA\";\n        REQUIRE(isBase64Image(validJpeg) == true);\n    }\n\n    SECTION(\"should return false for a string without the image data prefix\") {\n        std::string invalidFormat = \"data:text/plain;base64,SGVsbG8gd29ybGQ=\";\n        REQUIRE(isBase64Image(invalidFormat) == false);\n    }\n\n    SECTION(\"should return false for a string with invalid Base64 characters\") {\n        std::string invalidBase64 = \"data:image/png;base64,invalidBase64String@#%\";\n        REQUIRE(isBase64Image(invalidBase64) == false);\n    }\n\n    SECTION(\"should return false for an empty string\") {\n        REQUIRE(isBase64Image(\"\") == false);\n    }\n\n    SECTION(\"should return false for a null input\") {\n        // Since we can't pass nullptr for a std::string, we can check with an empty string or modify the function to handle nullptr\n        REQUIRE(isBase64Image(\"\") == false);  // Adjust as necessary for null handling\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param imageData - The image data string to be validated.\n */\nbool isBase64Image(const std::string& imageData) {\n    \n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param imageData - The image data string to be validated.\n */\npublic static boolean isBase64Image(String imageData) {\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.real.temp.Answer.*;\n\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testValidPngBase64() {\n        String validPng = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\";\n        assertTrue(isBase64Image(validPng));\n    }\n\n    @Test\n    public void testValidJpegBase64() {\n        String validJpeg = \"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAAAAAA\";\n        assertTrue(isBase64Image(validJpeg));\n    }\n\n    @Test\n    public void testInvalidFormat() {\n        String invalidFormat = \"data:text/plain;base64,SGVsbG8gd29ybGQ=\";\n        assertFalse(isBase64Image(invalidFormat));\n    }\n\n    @Test\n    public void testInvalidBase64Characters() {\n        String invalidBase64 = \"data:image/png;base64,invalidBase64String@#%\";\n        assertFalse(isBase64Image(invalidBase64));\n    }\n\n    @Test\n    public void testEmptyString() {\n        assertFalse(isBase64Image(\"\"));\n    }\n\n    @Test\n    public void testNullInput() {\n        assertFalse(isBase64Image(null));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param imageData - The image data string to be validated.\n */\npublic static boolean isBase64Image(String imageData) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 107, "code_type": "method", "original_language": "javascript", "file_path": "code-challenges\\3287f7e9be74d545375de59a03556e455f284bd2\\findMedian.js", "question_type": "Data processing and transformation", "summary": "Finds the median of a given array of numbers.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef find_median(arr: List[int]) -> float:\n    \"\"\"\n    Finds the median of a given array of numbers.\n\n    Args:\n        arr (list of int): The array of numbers to find the median of.\n\n    Returns:\n        float: The median of the array.\n    \"\"\"\n", "test_code": "import random\nimport unittest\n\n\nclass TestFindMedian(unittest.TestCase):\n\n    # Test Case 1: Check median for large array\n    def test_large_array_median(self):\n        large_array = [random.randint(0, 9999) for _ in range(10001)]\n        median_large_array = find_median(large_array)\n        # Test passes if the median is a number\n        self.assertIsInstance(median_large_array, (int, float))\n\n    # Test Case 2: Odd number of elements\n    def test_odd_number_of_elements(self):\n        arr = [3, 1, 4, 1, 5, 9, 2]\n        median = find_median(arr)\n        self.assertEqual(median, 3)\n\n    # Test Case 3: Even number of elements\n    def test_even_number_of_elements(self):\n        arr = [10, 2, 3, 5, 7, 8]\n        median = find_median(arr)\n        self.assertEqual(median, 6)\n\n    # Test Case 4: Array with duplicate elements\n    def test_array_with_duplicates(self):\n        arr = [1, 2, 2, 2, 3]\n        median = find_median(arr)\n        self.assertEqual(median, 2)\n\n    # Test Case 5: Array with negative numbers\n    def test_array_with_negative_numbers(self):\n        arr = [-5, -10, 0, 5, 10]\n        median = find_median(arr)\n        self.assertEqual(median, 0)\n\n    # Test Case 6: Array with a single element\n    def test_single_element_array(self):\n        arr = [42]\n        median = find_median(arr)\n        self.assertEqual(median, 42)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_median(arr: List[int]) -> float:\n    \"\"\"\n    Finds the median of a given array of numbers.\n\n    Args:\n        arr (list of int): The array of numbers to find the median of.\n\n    Returns:\n        float: The median of the array.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Finds the median of a given array of numbers.\n * \n * @param arr - The vector of integers to find the median of.\n */\ndouble findMedian(std::vector<int>& arr) {\n\n}", "test_code": "TEST_CASE(\"findMedian\", \"[median]\") {\n    // Example usage with a large array\n    SECTION(\"should find the median of a large array with 10001 random elements\") {\n        std::vector<int> largeArray(10001);\n        std::generate(largeArray.begin(), largeArray.end(), []() {\n            return rand() % 10000; // Random number between 0 and 9999\n        });\n        double medianLargeArray = findMedian(largeArray);\n        // Check if the result is a number (not NaN)\n        REQUIRE(!std::isnan(medianLargeArray));\n    }\n\n    // Test Case 1: Odd number of elements\n    SECTION(\"should return 3 for an array with odd number of elements\") {\n        std::vector<int> arr1 = {3, 1, 4, 1, 5, 9, 2};\n        double median1 = findMedian(arr1);\n        REQUIRE(median1 == 3);\n    }\n\n    // Test Case 2: Even number of elements\n    SECTION(\"should return 6 for an array with even number of elements\") {\n        std::vector<int> arr2 = {10, 2, 3, 5, 7, 8};\n        double median2 = findMedian(arr2);\n        REQUIRE(median2 == 6);\n    }\n\n    // Test Case 3: Array with duplicate elements\n    SECTION(\"should return 2 for an array with duplicate elements\") {\n        std::vector<int> arr3 = {1, 2, 2, 2, 3};\n        double median3 = findMedian(arr3);\n        REQUIRE(median3 == 2);\n    }\n\n    // Test Case 4: Array with negative numbers\n    SECTION(\"should return 0 for an array with negative and positive numbers\") {\n        std::vector<int> arr4 = {-5, -10, 0, 5, 10};\n        double median4 = findMedian(arr4);\n        REQUIRE(median4 == 0);\n    }\n\n    // Test Case 5: Array with a single element\n    SECTION(\"should return the only element for an array with a single element\") {\n        std::vector<int> arr5 = {42};\n        double median5 = findMedian(arr5);\n        REQUIRE(median5 == 42);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Finds the median of a given array of numbers.\n * \n * @param arr - The vector of integers to find the median of.\n */\ndouble findMedian(std::vector<int>& arr) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds the median of a given array of numbers.\n * \n * @param arr - The array of numbers to find the median of.\n */\npublic static double findMedian(int[] arr) {\n    \n}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\nimport org.junit.Test;\n\npublic class Tester {\n\n\n    @Test\n    public void testFindMedianOddElements() {\n        // Test Case 1: Odd number of elements\n        int[] arr1 = {3, 1, 4, 1, 5, 9, 2};\n        double median1 = findMedian(arr1);\n        assertEquals(3, median1, 0.001);\n    }\n\n    @Test\n    public void testFindMedianEvenElements() {\n        // Test Case 2: Even number of elements\n        int[] arr2 = {10, 2, 3, 5, 7, 8};\n        double median2 = findMedian(arr2);\n        assertEquals(6, median2, 0.001);\n    }\n\n    @Test\n    public void testFindMedianDuplicates() {\n        // Test Case 3: Array with duplicate elements\n        int[] arr3 = {1, 2, 2, 2, 3};\n        double median3 = findMedian(arr3);\n        assertEquals(2, median3, 0.001);\n    }\n\n    @Test\n    public void testFindMedianNegativeNumbers() {\n        // Test Case 4: Array with negative numbers\n        int[] arr4 = {-5, -10, 0, 5, 10};\n        double median4 = findMedian(arr4);\n        assertEquals(0, median4, 0.001);\n    }\n\n    @Test\n    public void testFindMedianSingleElement() {\n        // Test Case 5: Array with a single element\n        int[] arr5 = {42};\n        double median5 = findMedian(arr5);\n        assertEquals(42, median5, 0.001);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds the median of a given array of numbers.\n * \n * @param arr - The array of numbers to find the median of.\n */\npublic static double findMedian(int[] arr) {\n    \n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 108, "code_type": "method", "original_language": "javascript", "file_path": "pariwise_survey\\0a19f184ce750341185d8c0a6eada6f29515fcbb\\js\\elo.js", "question_type": "Data processing and transformation", "summary": "Sort the images in ascending order based on their scores and return the reordered image score, name, and ID", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef reorder_data(image_scores: List[int], image_names: List[str], image_ids: List[str]) -> dict:\n    \"\"\"\n    Sort the images in ascending order based on their scores and return the reordered image score, name, and ID.\n\n    Args:\n        image_scores (list[int]): Array of image scores.\n        image_names (list[str]): Array of image names corresponding to the scores.\n        image_ids (list[str]): Array of image IDs corresponding to the scores.\n\n    Returns:\n        dict: A dictionary containing the sorted scores, names, and IDs.\n              For example: {'resultScores': sorted_scores, 'resultNames': sorted_names, 'resultIDs': sorted_ids}\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestReorderData(unittest.TestCase):\n    def test_reorder_scores_ascending(self):\n        imageScores = [90, 85, 95]\n        imageNames = [\"image1.png\", \"image2.png\", \"image3.png\"]\n        imageIDs = [\"id1\", \"id2\", \"id3\"]\n        result = reorderData(imageScores, imageNames, imageIDs)\n        self.assertEqual(result.resultScores, [85, 90, 95])\n        self.assertEqual(result.resultNames, [\"image2.png\", \"image1.png\", \"image3.png\"])\n        self.assertEqual(result.resultIDs, [\"id2\", \"id1\", \"id3\"])\n\n    def test_scores_already_in_order(self):\n        imageScores = [70, 75, 80]\n        imageNames = [\"imageA.png\", \"imageB.png\", \"imageC.png\"]\n        imageIDs = [\"idA\", \"idB\", \"idC\"]\n        result = reorderData(imageScores, imageNames, imageIDs)\n        self.assertEqual(result.resultScores, [70, 75, 80])\n        self.assertEqual(result.resultNames, [\"imageA.png\", \"imageB.png\", \"imageC.png\"])\n        self.assertEqual(result.resultIDs, [\"idA\", \"idB\", \"idC\"])\n\n    def test_single_element(self):\n        imageScores = [50]\n        imageNames = [\"imageSingle.png\"]\n        imageIDs = [\"idSingle\"]\n        result = reorderData(imageScores, imageNames, imageIDs)\n        self.assertEqual(result.resultScores, [50])\n        self.assertEqual(result.resultNames, [\"imageSingle.png\"])\n        self.assertEqual(result.resultIDs, [\"idSingle\"])\n\n    def test_empty_array(self):\n        imageScores = []\n        imageNames = []\n        imageIDs = []\n        result = reorderData(imageScores, imageNames, imageIDs)\n        self.assertEqual(result.resultScores, [])\n        self.assertEqual(result.resultNames, [])\n        self.assertEqual(result.resultIDs, [])\n\n    def test_duplicate_scores(self):\n        imageScores = [88, 88, 92]\n        imageNames = [\"image1.png\", \"image2.png\", \"image3.png\"]\n        imageIDs = [\"id1\", \"id2\", \"id3\"]\n        result = reorderData(imageScores, imageNames, imageIDs)\n        self.assertEqual(result.resultScores, [88, 88, 92])\n        self.assertEqual(result.resultNames, [\"image1.png\", \"image2.png\", \"image3.png\"])\n        self.assertEqual(result.resultIDs, [\"id1\", \"id2\", \"id3\"])", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef reorder_data(image_scores: List[int], image_names: List[str], image_ids: List[str]) -> dict:\n    \"\"\"\n    Sort the images in ascending order based on their scores and return the reordered image score, name, and ID.\n\n    Args:\n        image_scores (list[int]): Array of image scores.\n        image_names (list[str]): Array of image names corresponding to the scores.\n        image_ids (list[str]): Array of image IDs corresponding to the scores.\n\n    Returns:\n        dict: A dictionary containing the sorted scores, names, and IDs.\n              For example: {'resultScores': sorted_scores, 'resultNames': sorted_names, 'resultIDs': sorted_ids}\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param const std::vector<int>& imageScores - Array of image scores.\n * @param const std::vector<std::string>& imageNames - Array of image names corresponding to the scores.\n * @param const std::vector<std::string>& imageIDs - Array of image IDs corresponding to the scores.\n * @returns std::tuple<std::vector<int>, std::vector<std::string>, std::vector<std::string>> - A tuple containing the sorted scores, names, and IDs.\n */\nstd::tuple<std::vector<int>, std::vector<std::string>, std::vector<std::string>> reorderData(\n\n) {\n\n}", "test_code": "TEST_CASE(\"reorderData\") {\n\n    SECTION(\"should reorder the question based on scores in ascending order\") {\n        std::vector<int> imageScores = {90, 85, 95};\n        std::vector<std::string> imageNames = {\"image1.png\", \"image2.png\", \"image3.png\"};\n        std::vector<std::string> imageIDs = {\"id1\", \"id2\", \"id3\"};\n\n        auto [resultScores, resultNames, resultIDs] = reorderData(imageScores, imageNames, imageIDs);\n\n        REQUIRE(resultScores == std::vector<int>{85, 90, 95});\n        REQUIRE(resultNames == std::vector<std::string>{\"image2.png\", \"image1.png\", \"image3.png\"});\n        REQUIRE(resultIDs == std::vector<std::string>{\"id2\", \"id1\", \"id3\"});\n    }\n\n    SECTION(\"should return the same order if scores are already in ascending order\") {\n        std::vector<int> imageScores = {70, 75, 80};\n        std::vector<std::string> imageNames = {\"imageA.png\", \"imageB.png\", \"imageC.png\"};\n        std::vector<std::string> imageIDs = {\"idA\", \"idB\", \"idC\"};\n\n        auto [resultScores, resultNames, resultIDs] = reorderData(imageScores, imageNames, imageIDs);\n\n        REQUIRE(resultScores == std::vector<int>{70, 75, 80});\n        REQUIRE(resultNames == std::vector<std::string>{\"imageA.png\", \"imageB.png\", \"imageC.png\"});\n        REQUIRE(resultIDs == std::vector<std::string>{\"idA\", \"idB\", \"idC\"});\n    }\n\n    SECTION(\"should handle an array with only one element\") {\n        std::vector<int> imageScores = {50};\n        std::vector<std::string> imageNames = {\"imageSingle.png\"};\n        std::vector<std::string> imageIDs = {\"idSingle\"};\n\n        auto [resultScores, resultNames, resultIDs] = reorderData(imageScores, imageNames, imageIDs);\n\n        REQUIRE(resultScores == std::vector<int>{50});\n        REQUIRE(resultNames == std::vector<std::string>{\"imageSingle.png\"});\n        REQUIRE(resultIDs == std::vector<std::string>{\"idSingle\"});\n    }\n\n    SECTION(\"should handle an empty array\") {\n        std::vector<int> imageScores = {};\n        std::vector<std::string> imageNames = {};\n        std::vector<std::string> imageIDs = {};\n\n        auto [resultScores, resultNames, resultIDs] = reorderData(imageScores, imageNames, imageIDs);\n\n        REQUIRE(resultScores == std::vector<int>{});\n        REQUIRE(resultNames == std::vector<std::string>{});\n        REQUIRE(resultIDs == std::vector<std::string>{});\n    }\n\n    SECTION(\"should reorder correctly when there are duplicate scores\") {\n        std::vector<int> imageScores = {88, 88, 92};\n        std::vector<std::string> imageNames = {\"image1.png\", \"image2.png\", \"image3.png\"};\n        std::vector<std::string> imageIDs = {\"id1\", \"id2\", \"id3\"};\n\n        auto [resultScores, resultNames, resultIDs] = reorderData(imageScores, imageNames, imageIDs);\n\n        REQUIRE(resultScores == std::vector<int>{88, 88, 92});\n        REQUIRE(resultNames == std::vector<std::string>{\"image1.png\", \"image2.png\", \"image3.png\"});\n        REQUIRE(resultIDs == std::vector<std::string>{\"id1\", \"id2\", \"id3\"});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param const std::vector<int>& imageScores - Array of image scores.\n * @param const std::vector<std::string>& imageNames - Array of image names corresponding to the scores.\n * @param const std::vector<std::string>& imageIDs - Array of image IDs corresponding to the scores.\n * @returns std::tuple<std::vector<int>, std::vector<std::string>, std::vector<std::string>> - A tuple containing the sorted scores, names, and IDs.\n */\nstd::tuple<std::vector<int>, std::vector<std::string>, std::vector<std::string>> reorderData(\n\n) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param imageScores Array of image scores.\n * @param imageNames Array of image names corresponding to the scores.\n * @param imageIDs Array of image IDs corresponding to the scores.\n * @return A map containing the sorted scores, names, and IDs, for example { \"resultScores\", \"resultNames\", \"resultIDs\" }\n */\npublic Map<String, Object> reorderData(int[] imageScores, String[] imageNames, String[] imageIDs) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.Map;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testReorderData_ShouldReorderBasedOnScoresInAscendingOrder() {\n        int[] imageScores = {90, 85, 95};\n        String[] imageNames = {\"image1.png\", \"image2.png\", \"image3.png\"};\n        String[] imageIDs = {\"id1\", \"id2\", \"id3\"};\n\n        Map<String, Object> result = reorderData(imageScores, imageNames, imageIDs);\n\n        assertArrayEquals(new int[]{85, 90, 95}, (int[]) result.get(\"resultScores\"));\n        assertArrayEquals(new String[]{\"image2.png\", \"image1.png\", \"image3.png\"}, (String[]) result.get(\"resultNames\"));\n        assertArrayEquals(new String[]{\"id2\", \"id1\", \"id3\"}, (String[]) result.get(\"resultIDs\"));\n    }\n\n    @Test\n    public void testReorderData_ShouldReturnSameOrderIfScoresAlreadyAscending() {\n        int[] imageScores = {70, 75, 80};\n        String[] imageNames = {\"imageA.png\", \"imageB.png\", \"imageC.png\"};\n        String[] imageIDs = {\"idA\", \"idB\", \"idC\"};\n\n        Map<String, Object> result = reorderData(imageScores, imageNames, imageIDs);\n\n        assertArrayEquals(new int[]{70, 75, 80}, (int[]) result.get(\"resultScores\"));\n        assertArrayEquals(new String[]{\"imageA.png\", \"imageB.png\", \"imageC.png\"}, (String[]) result.get(\"resultNames\"));\n        assertArrayEquals(new String[]{\"idA\", \"idB\", \"idC\"}, (String[]) result.get(\"resultIDs\"));\n    }\n\n    @Test\n    public void testReorderData_ShouldHandleSingleElementArray() {\n        int[] imageScores = {50};\n        String[] imageNames = {\"imageSingle.png\"};\n        String[] imageIDs = {\"idSingle\"};\n\n        Map<String, Object> result = reorderData(imageScores, imageNames, imageIDs);\n\n        assertArrayEquals(new int[]{50}, (int[]) result.get(\"resultScores\"));\n        assertArrayEquals(new String[]{\"imageSingle.png\"}, (String[]) result.get(\"resultNames\"));\n        assertArrayEquals(new String[]{\"idSingle\"}, (String[]) result.get(\"resultIDs\"));\n    }\n\n    @Test\n    public void testReorderData_ShouldHandleEmptyArray() {\n        int[] imageScores = {};\n        String[] imageNames = {};\n        String[] imageIDs = {};\n\n        Map<String, Object> result = reorderData(imageScores, imageNames, imageIDs);\n\n        assertArrayEquals(new int[]{}, (int[]) result.get(\"resultScores\"));\n        assertArrayEquals(new String[]{}, (String[]) result.get(\"resultNames\"));\n        assertArrayEquals(new String[]{}, (String[]) result.get(\"resultIDs\"));\n    }\n\n    @Test\n    public void testReorderData_ShouldReorderCorrectlyWithDuplicateScores() {\n        int[] imageScores = {88, 88, 92};\n        String[] imageNames = {\"image1.png\", \"image2.png\", \"image3.png\"};\n        String[] imageIDs = {\"id1\", \"id2\", \"id3\"};\n\n        Map<String, Object> result = reorderData(imageScores, imageNames, imageIDs);\n\n        assertArrayEquals(new int[]{88, 88, 92}, (int[]) result.get(\"resultScores\"));\n        assertArrayEquals(new String[]{\"image1.png\", \"image2.png\", \"image3.png\"}, (String[]) result.get(\"resultNames\"));\n        assertArrayEquals(new String[]{\"id1\", \"id2\", \"id3\"}, (String[]) result.get(\"resultIDs\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param imageScores Array of image scores.\n * @param imageNames Array of image names corresponding to the scores.\n * @param imageIDs Array of image IDs corresponding to the scores.\n * @return A map containing the sorted scores, names, and IDs, for example { \"resultScores\", \"resultNames\", \"resultIDs\" }\n */\npublic Map<String, Object> reorderData(int[] imageScores, String[] imageNames, String[] imageIDs) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 109, "code_type": "method", "original_language": "javascript", "file_path": "Bing-Chat-History\\a9b013bc573b42d867b0ad23e884928947a0c167\\src\\pages\\js\\utility.js", "question_type": "Algorithm and data structure", "summary": "Returns the object from the list with the given ID, or null if it is not present", "language_version_list": {"python": {"code_signature": "from typing import Union, List, Dict, Optional\n\n\ndef get_object_by_id(id: Union[str, int], obj_list: List[Dict]) -> Optional[Dict]:\n    \"\"\"\n    Returns the object from the list with the given ID, or None if it is not present.\n\n    Args:\n        id (Union[str, int]): The `id` to search for in the list.\n        obj_list (List[Dict]): The list of objects to search through.\n\n    Returns:\n        Optional[Dict]: The object with the matching `id`, or None if no match is found.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGetObjectById(unittest.TestCase):\n\n    def test_should_return_object_with_matching_id(self):\n        obj_list = [\n            {'id': 1, 'name': 'Object 1'},\n            {'id': 2, 'name': 'Object 2'},\n            {'id': 3, 'name': 'Object 3'}\n        ]\n        result = get_object_by_id(2, obj_list)\n        self.assertEqual(result, {'id': 2, 'name': 'Object 2'})\n\n    def test_should_return_none_if_no_object_with_matching_id(self):\n        obj_list = [\n            {'id': 1, 'name': 'Object 1'},\n            {'id': 2, 'name': 'Object 2'},\n            {'id': 3, 'name': 'Object 3'}\n        ]\n        result = get_object_by_id(4, obj_list)\n        self.assertIsNone(result)\n\n    def test_should_return_none_if_list_is_empty(self):\n        obj_list = []\n        result = get_object_by_id(1, obj_list)\n        self.assertIsNone(result)\n\n    def test_should_return_none_if_objects_do_not_have_id_property(self):\n        obj_list = [\n            {'name': 'Object 1'},\n            {'name': 'Object 2'},\n            {'name': 'Object 3'}\n        ]\n        result = get_object_by_id(1, obj_list)\n        self.assertIsNone(result)\n\n    def test_should_return_correct_object_when_id_is_string(self):\n        obj_list = [\n            {'id': 'a', 'name': 'Object A'},\n            {'id': 'b', 'name': 'Object B'},\n            {'id': 'c', 'name': 'Object C'}\n        ]\n        result = get_object_by_id('b', obj_list)\n        self.assertEqual(result, {'id': 'b', 'name': 'Object B'})\n", "prompt": "please write a python function , the function signature as below from typing import Union, List, Dict, Optional\n\n\ndef get_object_by_id(id: Union[str, int], obj_list: List[Dict]) -> Optional[Dict]:\n    \"\"\"\n    Returns the object from the list with the given ID, or None if it is not present.\n\n    Args:\n        id (Union[str, int]): The `id` to search for in the list.\n        obj_list (List[Dict]): The list of objects to search through.\n\n    Returns:\n        Optional[Dict]: The object with the matching `id`, or None if no match is found.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 110, "code_type": "method", "original_language": "javascript", "file_path": "Bing-Chat-History\\a9b013bc573b42d867b0ad23e884928947a0c167\\src\\pages\\js\\utility.js", "question_type": "Algorithm and data structure", "summary": "Generate a random UUID of length 36", "language_version_list": {"python": {"code_signature": "def generate_uuid() -> str:\n    \"\"\"\n    Generate a random UUID of length 36.\n\n    The UUID contains at least one uppercase letter, at least one lowercase letter, and at least one digit.\n\n    Returns:\n        str: A 36-character UUID string.\n    \"\"\"", "test_code": "import re\nimport unittest\n\n\nclass TestGenerateUUID(unittest.TestCase):\n\n    def test_should_return_a_string(self):\n        result = generate_uuid()\n        self.assertIsInstance(result, str)\n\n    def test_should_return_a_string_of_length_36(self):\n        result = generate_uuid()\n        self.assertEqual(len(result), 36)\n\n    def test_should_generate_different_UUIDs_on_consecutive_calls(self):\n        uuid1 = generate_uuid()\n        uuid2 = generate_uuid()\n        self.assertNotEqual(uuid1, uuid2)\n\n    def test_should_generate_UUIDs_that_include_uppercase(self):\n        result = generate_uuid()\n        self.assertTrue(re.search(r'[A-Z]', result) is not None)  # At least one uppercase letter\n\n    def test_should_generate_UUIDs_that_include_lowercase(self):\n        result = generate_uuid()\n        self.assertTrue(re.search(r'[a-z]', result) is not None)  # At least one lowercase letter\n\n    def test_should_generate_UUIDs_that_include_digits(self):\n        result = generate_uuid()\n        self.assertTrue(re.search(r'[0-9]', result) is not None)  # At least one digit\n", "prompt": "please write a python function , the function signature as below def generate_uuid() -> str:\n    \"\"\"\n    Generate a random UUID of length 36.\n\n    The UUID contains at least one uppercase letter, at least one lowercase letter, and at least one digit.\n\n    Returns:\n        str: A 36-character UUID string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Generate a random UUID of length 36\n * The UUID contains at least one uppercase letter, at least one lowercase letter, and at least one digit\n *\n * @returns A 36-character UUID string.\n */\nstd::string generateUUID() {\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n#include <regex>\n\n// Assume generateUUID() is defined elsewhere\n\nTEST_CASE(\"generateUUID\") {\n\n    SECTION(\"should return a string\") {\n        std::string result = generateUUID();\n        REQUIRE(!result.empty());\n    }\n\n    SECTION(\"should return a string of length 36\") {\n        std::string result = generateUUID();\n        REQUIRE(result.length() == 36);\n    }\n\n    SECTION(\"should generate different UUIDs on consecutive calls\") {\n        std::string uuid1 = generateUUID();\n        std::string uuid2 = generateUUID();\n        REQUIRE(uuid1 != uuid2);\n    }\n\n    SECTION(\"should generate UUIDs that include uppercase\") {\n        std::string result = generateUUID();\n        REQUIRE(std::regex_search(result, std::regex(\"[A-Z]\"))); // At least one uppercase letter\n    }\n\n    SECTION(\"should generate UUIDs that include lowercase letters\") {\n        std::string result = generateUUID();\n        REQUIRE(std::regex_search(result, std::regex(\"[a-z]\"))); // At least one lowercase letter\n    }\n\n    SECTION(\"should generate UUIDs that include digits\") {\n        std::string result = generateUUID();\n        REQUIRE(std::regex_search(result, std::regex(\"[0-9]\"))); // At least one digit\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Generate a random UUID of length 36\n * The UUID contains at least one uppercase letter, at least one lowercase letter, and at least one digit\n *\n * @returns A 36-character UUID string.\n */\nstd::string generateUUID() {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Generate a random UUID of length 36\n * The UUID includes at least one uppercase letter, one lowercase letter, and one digit.\n *\n * @return A 36-character UUID string.\n */\npublic static String generateUUID() {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testGenerateUUIDShouldReturnAString() {\n        String result = generateUUID();\n        assertTrue(result instanceof String);\n    }\n\n    @Test\n    public void testGenerateUUIDShouldReturnStringOfLength36() {\n        String result = generateUUID();\n        assertEquals(36, result.length());\n    }\n\n    @Test\n    public void testGenerateUUIDShouldGenerateDifferentUUIDsOnConsecutiveCalls() {\n        String uuid1 = generateUUID();\n        String uuid2 = generateUUID();\n        assertNotEquals(uuid1, uuid2);\n    }\n\n    @Test\n    public void testGenerateUUIDShouldIncludeUppercase() {\n        String result = generateUUID();\n        assertTrue(result.matches(\".*[A-Z].*\")); // At least one uppercase letter\n    }\n\n    @Test\n    public void testGenerateUUIDShouldIncludeLowercase() {\n        String result = generateUUID();\n        assertTrue(result.matches(\".*[a-z].*\")); // At least one lowercase letter\n    }\n\n    @Test\n    public void testGenerateUUIDShouldIncludeDigits() {\n        String result = generateUUID();\n        assertTrue(result.matches(\".*[0-9].*\")); // At least one digit\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Generate a random UUID of length 36\n * The UUID includes at least one uppercase letter, one lowercase letter, and one digit.\n *\n * @return A 36-character UUID string.\n */\npublic static String generateUUID() {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 111, "code_type": "method", "original_language": "javascript", "file_path": "Bing-Chat-History\\e84e3bded63150d605bba6647572445f0116eeff\\src\\content-scripts\\utility.js", "question_type": "Data processing and transformation", "summary": "Convert the chat logs to Markdown format and generate a Blob object containing them", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 112, "code_type": "method", "original_language": "javascript", "file_path": "Bing-Chat-History\\e84e3bded63150d605bba6647572445f0116eeff\\src\\content-scripts\\utility.js", "question_type": "Data processing and transformation", "summary": "Convert H1-H6 tags in HTML to corresponding paragraphs 1 through 6 in markdown, for example h1 xxx to # xxx", "language_version_list": {"python": {"code_signature": "def convert_html_headings_to_markdown(html: str) -> str:\n    \"\"\"\n    Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n\n    Args:\n        html (str): The HTML string containing headings.\n\n    Returns:\n        str: The converted Markdown string.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestConvertHtmlHeadingsToMarkdown(unittest.TestCase):\n\n    def test_convert_h1_to_markdown(self):\n        input_html = '<h1>This is a Heading 1</h1>'\n        expected_output = '# This is a Heading 1'\n        self.assertEqual(convert_html_headings_to_markdown(input_html), expected_output)\n\n    def test_convert_h2_to_markdown(self):\n        input_html = '<h2>This is a Heading 2</h2>'\n        expected_output = '## This is a Heading 2'\n        self.assertEqual(convert_html_headings_to_markdown(input_html), expected_output)\n\n    def test_convert_h3_to_markdown(self):\n        input_html = '<h3>This is a Heading 3</h3>'\n        expected_output = '### This is a Heading 3'\n        self.assertEqual(convert_html_headings_to_markdown(input_html), expected_output)\n\n    def test_convert_h4_to_markdown(self):\n        input_html = '<h4>This is a Heading 4</h4>'\n        expected_output = '#### This is a Heading 4'\n        self.assertEqual(convert_html_headings_to_markdown(input_html), expected_output)\n\n    def test_convert_h5_to_markdown(self):\n        input_html = '<h5>This is a Heading 5</h5>'\n        expected_output = '##### This is a Heading 5'\n        self.assertEqual(convert_html_headings_to_markdown(input_html), expected_output)\n\n    def test_convert_h6_to_markdown(self):\n        input_html = '<h6>This is a Heading 6</h6>'\n        expected_output = '###### This is a Heading 6'\n        self.assertEqual(convert_html_headings_to_markdown(input_html), expected_output)\n", "prompt": "please write a python function , the function signature as below def convert_html_headings_to_markdown(html: str) -> str:\n    \"\"\"\n    Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n\n    Args:\n        html (str): The HTML string containing headings.\n\n    Returns:\n        str: The converted Markdown string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n *\n * @param html - The HTML string containing headings.\n * @returns The converted Markdown string.\n */\nstd::string convertHtmlHeadingsToMarkdown(const std::string& html){\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\n// Function prototype (assuming it's defined elsewhere)\nstd::string convertHtmlHeadingsToMarkdown(const std::string& html);\n\nTEST_CASE(\"convertHtmlHeadingsToMarkdown\") {\n    SECTION(\"should convert <h1> to #\") {\n        std::string input = \"<h1>This is a Heading 1</h1>\";\n        std::string output = \"# This is a Heading 1\";\n        REQUIRE(convertHtmlHeadingsToMarkdown(input) == output);\n    }\n\n    SECTION(\"should convert <h2> to ##\") {\n        std::string input = \"<h2>This is a Heading 2</h2>\";\n        std::string output = \"## This is a Heading 2\";\n        REQUIRE(convertHtmlHeadingsToMarkdown(input) == output);\n    }\n\n    SECTION(\"should convert <h3> to ###\") {\n        std::string input = \"<h3>This is a Heading 3</h3>\";\n        std::string output = \"### This is a Heading 3\";\n        REQUIRE(convertHtmlHeadingsToMarkdown(input) == output);\n    }\n\n    SECTION(\"should convert <h4> to ####\") {\n        std::string input = \"<h4>This is a Heading 4</h4>\";\n        std::string output = \"#### This is a Heading 4\";\n        REQUIRE(convertHtmlHeadingsToMarkdown(input) == output);\n    }\n\n    SECTION(\"should convert <h5> to #####\") {\n        std::string input = \"<h5>This is a Heading 5</h5>\";\n        std::string output = \"##### This is a Heading 5\";\n        REQUIRE(convertHtmlHeadingsToMarkdown(input) == output);\n    }\n\n    SECTION(\"should convert <h6> to ######\") {\n        std::string input = \"<h6>This is a Heading 6</h6>\";\n        std::string output = \"###### This is a Heading 6\";\n        REQUIRE(convertHtmlHeadingsToMarkdown(input) == output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n *\n * @param html - The HTML string containing headings.\n * @returns The converted Markdown string.\n */\nstd::string convertHtmlHeadingsToMarkdown(const std::string& html){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n *\n * @param html - The HTML string containing headings.\n * @return - The converted Markdown string.\n */\npublic static String convertHtmlHeadingsToMarkdown(String html) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testConvertH1ToMarkdown() {\n        String input = \"<h1>This is a Heading 1</h1>\";\n        String output = \"# This is a Heading 1\";\n        assertEquals(output, convertHtmlHeadingsToMarkdown(input));\n    }\n\n    @Test\n    public void testConvertH2ToMarkdown() {\n        String input = \"<h2>This is a Heading 2</h2>\";\n        String output = \"## This is a Heading 2\";\n        assertEquals(output, convertHtmlHeadingsToMarkdown(input));\n    }\n\n    @Test\n    public void testConvertH3ToMarkdown() {\n        String input = \"<h3>This is a Heading 3</h3>\";\n        String output = \"### This is a Heading 3\";\n        assertEquals(output, convertHtmlHeadingsToMarkdown(input));\n    }\n\n    @Test\n    public void testConvertH4ToMarkdown() {\n        String input = \"<h4>This is a Heading 4</h4>\";\n        String output = \"#### This is a Heading 4\";\n        assertEquals(output, convertHtmlHeadingsToMarkdown(input));\n    }\n\n    @Test\n    public void testConvertH5ToMarkdown() {\n        String input = \"<h5>This is a Heading 5</h5>\";\n        String output = \"##### This is a Heading 5\";\n        assertEquals(output, convertHtmlHeadingsToMarkdown(input));\n    }\n\n    @Test\n    public void testConvertH6ToMarkdown() {\n        String input = \"<h6>This is a Heading 6</h6>\";\n        String output = \"###### This is a Heading 6\";\n        assertEquals(output, convertHtmlHeadingsToMarkdown(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n *\n * @param html - The HTML string containing headings.\n * @return - The converted Markdown string.\n */\npublic static String convertHtmlHeadingsToMarkdown(String html) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 113, "code_type": "method", "original_language": "javascript", "file_path": "Bing-Chat-History\\e84e3bded63150d605bba6647572445f0116eeff\\src\\content-scripts\\utility.js", "question_type": "Data processing and transformation", "summary": "Extract all the CSS rules from a given CSSStyleSheet and concatenate them into a string\n", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 114, "code_type": "method", "original_language": "javascript", "file_path": "utilsNodeJs\\8bd1fec924b2b1141b47c2a10911ed8035002918\\src\\Sorter.js", "question_type": "Data processing and transformation", "summary": "Sort the array of objects that contain timestamps based on the timestamp value\n", "language_version_list": {"python": {"code_signature": "from typing import List, Dict\n\n\ndef sort_by_timestamp(array: List[Dict]) -> List[Dict]:\n    \"\"\"\n    Sorts a list of dictionaries by the 'timestamp' property.\n\n    Args:\n        array (List[Dict]): The list of dictionaries to be sorted.\n\n    Returns:\n        List[Dict]: The sorted list, based on the 'timestamp' property.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSortByTimestamp(unittest.TestCase):\n\n    def test_empty_array(self):\n        self.assertEqual(sort_by_timestamp([]), [])\n\n    def test_single_element_array(self):\n        single_element_array = [{'id': 1, 'timestamp': \"2021-07-03T12:00:00Z\"}]\n        self.assertEqual(sort_by_timestamp(single_element_array), [{'id': 1, 'timestamp': \"2021-07-03T12:00:00Z\"}])\n\n    def test_sort_multiple_elements(self):\n        test_data = [\n            {'id': 3, 'timestamp': \"2021-07-01T09:45:00Z\"},\n            {'id': 1, 'timestamp': \"2021-07-03T12:00:00Z\"},\n            {'id': 2, 'timestamp': \"2021-07-02T15:30:00Z\"}\n        ]\n        expected = [\n            {'id': 3, 'timestamp': \"2021-07-01T09:45:00Z\"},\n            {'id': 2, 'timestamp': \"2021-07-02T15:30:00Z\"},\n            {'id': 1, 'timestamp': \"2021-07-03T12:00:00Z\"}\n        ]\n        self.assertEqual(sort_by_timestamp(test_data), expected)\n\n    def test_already_sorted_array(self):\n        sorted_array = [\n            {'id': 1, 'timestamp': \"2021-07-01T09:45:00Z\"},\n            {'id': 2, 'timestamp': \"2021-07-02T15:30:00Z\"},\n            {'id': 3, 'timestamp': \"2021-07-03T12:00:00Z\"}\n        ]\n        self.assertEqual(sort_by_timestamp(sorted_array), sorted_array)\n\n    def test_mixed_format_timestamps(self):\n        mixed_formats = [\n            {'id': 1, 'timestamp': \"2021/07/03 12:00:00\"},\n            {'id': 2, 'timestamp': \"July 2, 2021 15:30:00\"},\n            {'id': 3, 'timestamp': \"2021-07-01T09:45:00Z\"}\n        ]\n        expected = [\n            {'id': 3, 'timestamp': \"2021-07-01T09:45:00Z\"},\n            {'id': 2, 'timestamp': \"July 2, 2021 15:30:00\"},\n            {'id': 1, 'timestamp': \"2021/07/03 12:00:00\"}\n        ]\n        self.assertEqual(sort_by_timestamp(mixed_formats), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List, Dict\n\n\ndef sort_by_timestamp(array: List[Dict]) -> List[Dict]:\n    \"\"\"\n    Sorts a list of dictionaries by the 'timestamp' property.\n\n    Args:\n        array (List[Dict]): The list of dictionaries to be sorted.\n\n    Returns:\n        List[Dict]: The sorted list, based on the 'timestamp' property.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 115, "code_type": "method", "original_language": "javascript", "file_path": "acsense-tcd\\730cc723b81283d3dc791a27c5adde0146e33c5c\\acsense-tcd\\composables\\sortArrayOfObjectsByKey.js", "question_type": "Data processing and transformation", "summary": "sort the array of objects alphabetically by the specified key\n", "language_version_list": {"python": {"code_signature": "from typing import List, Dict\n\n\ndef sort_by_key(array: List[Dict], key: str) -> List[Dict]:\n    \"\"\"\n    Sorts a list of dictionaries alphabetically by a specified key.\n\n    Args:\n        array (List[Dict]):  The list of dictionaries to be sorted.\n        key (str): The key in the dictionaries to sort by.\n\n    Returns:\n        List[Dict]: The sorted list based on the specified key.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSortByKey(unittest.TestCase):\n\n    def test_empty_array(self):\n        result = sort_by_key([], 'name')\n        self.assertEqual(result, [])\n\n    def test_single_element(self):\n        single_element_array = [{'name': 'Apple'}]\n        self.assertEqual(sort_by_key(single_element_array, 'name'), [{'name': 'Apple'}])\n\n    def test_sort_by_key(self):\n        test_data = [\n            {'name': 'banana'},\n            {'name': 'apple'},\n            {'name': 'orange'}\n        ]\n        expected = [\n            {'name': 'apple'},\n            {'name': 'banana'},\n            {'name': 'orange'}\n        ]\n        self.assertEqual(sort_by_key(test_data, 'name'), expected)\n\n    def test_case_insensitive_sorting(self):\n        mixed_case_array = [\n            {'name': 'banana'},\n            {'name': 'Apple'},\n            {'name': 'orange'}\n        ]\n        expected = [\n            {'name': 'Apple'},\n            {'name': 'banana'},\n            {'name': 'orange'}\n        ]\n        self.assertEqual(sort_by_key(mixed_case_array, 'name'), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List, Dict\n\n\ndef sort_by_key(array: List[Dict], key: str) -> List[Dict]:\n    \"\"\"\n    Sorts a list of dictionaries alphabetically by a specified key.\n\n    Args:\n        array (List[Dict]):  The list of dictionaries to be sorted.\n        key (str): The key in the dictionaries to sort by.\n\n    Returns:\n        List[Dict]: The sorted list based on the specified key.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 116, "code_type": "method", "original_language": "javascript", "file_path": "acm-fish\\7e985493411a046eddd249394e7b554708072cc2\\foish.js", "question_type": "Data processing and transformation", "summary": "Calculates the toroidal difference between two points", "language_version_list": {"python": {"code_signature": "from typing import Dict, List\n\n\ndef calculate_toroidal_difference(point_a: Dict[str, float], point_b: Dict[str, float], width: float, height: float) -> List[float]:\n    \"\"\"\n    Calculates the toroidal difference between two points in a wrap-around space.\n\n    Args:\n        point_a (Dict[str, float]): The first point with keys 'x' and 'y'.\n        point_b (Dict[str, float]): The second point with keys 'x' and 'y'.\n        width (float): The width of the toroidal space.\n        height (float): The height of the toroidal space.\n\n    Returns:\n        List[float]: A list containing the x and y differences, accounting for wrap-around.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestToroidalDiff(unittest.TestCase):\n\n    def test_no_wrapping(self):\n        this_point = {'x': 2, 'y': 3}\n        other_point = {'x': 5, 'y': 6}\n        width = 10\n        height = 10\n        result = calculate_toroidal_difference(this_point, other_point, width, height)\n        self.assertEqual(result, [-3, -3])\n\n    def test_wrapping_x_dimension(self):\n        this_point = {'x': 9, 'y': 5}\n        other_point = {'x': 1, 'y': 5}\n        width = 10\n        height = 10\n        result = calculate_toroidal_difference(this_point, other_point, width, height)\n        self.assertEqual(result, [-2, 0])  # dx wraps around the toroidal boundary\n\n    def test_wrapping_y_dimension(self):\n        this_point = {'x': 4, 'y': 9}\n        other_point = {'x': 4, 'y': 1}\n        width = 10\n        height = 10\n        result = calculate_toroidal_difference(this_point, other_point, width, height)\n        self.assertEqual(result, [0, -2])  # dy wraps around the toroidal boundary\n\n    def test_wrapping_both_dimensions(self):\n        this_point = {'x': 9, 'y': 9}\n        other_point = {'x': 1, 'y': 1}\n        width = 10\n        height = 10\n        result = calculate_toroidal_difference(this_point, other_point, width, height)\n        self.assertEqual(result, [-2, -2])  # Both dx and dy wrap around\n\n    def test_same_position(self):\n        this_point = {'x': 5, 'y': 5}\n        other_point = {'x': 5, 'y': 5}\n        width = 10\n        height = 10\n        result = calculate_toroidal_difference(this_point, other_point, width, height)\n        self.assertEqual(result, [0, 0])  # No difference\n", "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef calculate_toroidal_difference(point_a: Dict[str, float], point_b: Dict[str, float], width: float, height: float) -> List[float]:\n    \"\"\"\n    Calculates the toroidal difference between two points in a wrap-around space.\n\n    Args:\n        point_a (Dict[str, float]): The first point with keys 'x' and 'y'.\n        point_b (Dict[str, float]): The second point with keys 'x' and 'y'.\n        width (float): The width of the toroidal space.\n        height (float): The height of the toroidal space.\n\n    Returns:\n        List[float]: A list containing the x and y differences, accounting for wrap-around.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculates the toroidal difference between two points.\n *\n * @param std::pair<double, double> thisPoint - The first point with properties x and y.\n * @param std::pair<double, double> otherPoint - The second point with properties x and y.\n * @param double width - The width of the toroidal space.\n * @param double height - The height of the toroidal space.\n * @returns std::vector<double> - A vector containing the x and y differences, accounting for wrap-around.\n */\nstd::vector<double> toroidalDiff(const std::pair<double, double>& thisPoint, const std::pair<double, double>& otherPoint, double width, double height) {\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <vector>\n#include <utility>\n\n// Assume toroidalDiff function is defined here\n\nTEST_CASE(\"toroidalDiff\", \"[toroidalDiff]\") {\n    SECTION(\"should return the direct difference when no wrapping is needed\") {\n        std::pair<double, double> thisPoint = {2, 3};\n        std::pair<double, double> otherPoint = {5, 6};\n        double width = 10;\n        double height = 10;\n        auto result = toroidalDiff(thisPoint, otherPoint, width, height);\n        REQUIRE(result == std::vector<double>{-3, -3});\n    }\n\n    SECTION(\"should handle wrapping around the x dimension\") {\n        std::pair<double, double> thisPoint = {9, 5};\n        std::pair<double, double> otherPoint = {1, 5};\n        double width = 10;\n        double height = 10;\n        auto result = toroidalDiff(thisPoint, otherPoint, width, height);\n        REQUIRE(result == std::vector<double>{-2, 0}); // dx wraps around the toroidal boundary\n    }\n\n    SECTION(\"should handle wrapping around the y dimension\") {\n        std::pair<double, double> thisPoint = {4, 9};\n        std::pair<double, double> otherPoint = {4, 1};\n        double width = 10;\n        double height = 10;\n        auto result = toroidalDiff(thisPoint, otherPoint, width, height);\n        REQUIRE(result == std::vector<double>{0, -2}); // dy wraps around the toroidal boundary\n    }\n\n    SECTION(\"should handle wrapping around both x and y dimensions\") {\n        std::pair<double, double> thisPoint = {9, 9};\n        std::pair<double, double> otherPoint = {1, 1};\n        double width = 10;\n        double height = 10;\n        auto result = toroidalDiff(thisPoint, otherPoint, width, height);\n        REQUIRE(result == std::vector<double>{-2, -2}); // Both dx and dy wrap around\n    }\n\n    SECTION(\"should return the direct difference for points at the same position\") {\n        std::pair<double, double> thisPoint = {5, 5};\n        std::pair<double, double> otherPoint = {5, 5};\n        double width = 10;\n        double height = 10;\n        auto result = toroidalDiff(thisPoint, otherPoint, width, height);\n        REQUIRE(result == std::vector<double>{0, 0}); // No difference\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculates the toroidal difference between two points.\n *\n * @param std::pair<double, double> thisPoint - The first point with properties x and y.\n * @param std::pair<double, double> otherPoint - The second point with properties x and y.\n * @param double width - The width of the toroidal space.\n * @param double height - The height of the toroidal space.\n * @returns std::vector<double> - A vector containing the x and y differences, accounting for wrap-around.\n */\nstd::vector<double> toroidalDiff(const std::pair<double, double>& thisPoint, const std::pair<double, double>& otherPoint, double width, double height) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the toroidal difference between two points.\n *\n * @param thisPoint - The first point with properties x and y.\n * @param otherPoint - The second point with properties x and y.\n * @param width - The width of the toroidal space.\n * @param height - The height of the toroidal space.\n * @returns - An array containing the x and y differences, accounting for wrap-around.\n */\npublic static class Point {\n    public double x;\n    public double y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\npublic static double[] toroidalDiff(Point thisPoint, Point otherPoint, double width, double height) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testDirectDifferenceNoWrapping() {\n        Point thisPoint = new Point(2, 3);\n        Point otherPoint = new Point(5, 6);\n        double width = 10;\n        double height = 10;\n        double[] result = toroidalDiff(thisPoint, otherPoint, width, height);\n        assertArrayEquals(new double[]{-3, -3}, result, 0.0001);\n    }\n\n    @Test\n    public void testWrappingAroundXDimension() {\n        Point thisPoint = new Point(9, 5);\n        Point otherPoint = new Point(1, 5);\n        double width = 10;\n        double height = 10;\n        double[] result = toroidalDiff(thisPoint, otherPoint, width, height);\n        assertArrayEquals(new double[]{-2, 0}, result, 0.0001); // dx wraps around the toroidal boundary\n    }\n\n    @Test\n    public void testWrappingAroundYDimension() {\n        Point thisPoint = new Point(4, 9);\n        Point otherPoint = new Point(4, 1);\n        double width = 10;\n        double height = 10;\n        double[] result = toroidalDiff(thisPoint, otherPoint, width, height);\n        assertArrayEquals(new double[]{0, -2}, result, 0.0001); // dy wraps around the toroidal boundary\n    }\n\n    @Test\n    public void testWrappingAroundBothDimensions() {\n        Point thisPoint = new Point(9, 9);\n        Point otherPoint = new Point(1, 1);\n        double width = 10;\n        double height = 10;\n        double[] result = toroidalDiff(thisPoint, otherPoint, width, height);\n        assertArrayEquals(new double[]{-2, -2}, result, 0.0001); // Both dx and dy wrap around\n    }\n\n    @Test\n    public void testSamePosition() {\n        Point thisPoint = new Point(5, 5);\n        Point otherPoint = new Point(5, 5);\n        double width = 10;\n        double height = 10;\n        double[] result = toroidalDiff(thisPoint, otherPoint, width, height);\n        assertArrayEquals(new double[]{0, 0}, result, 0.0001); // No difference\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the toroidal difference between two points.\n *\n * @param thisPoint - The first point with properties x and y.\n * @param otherPoint - The second point with properties x and y.\n * @param width - The width of the toroidal space.\n * @param height - The height of the toroidal space.\n * @returns - An array containing the x and y differences, accounting for wrap-around.\n */\npublic static class Point {\n    public double x;\n    public double y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\npublic static double[] toroidalDiff(Point thisPoint, Point otherPoint, double width, double height) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 117, "code_type": "method", "original_language": "javascript", "file_path": "libresprite-extensions\\dfd82d80fa0512f60fb423d304f8790dad32e96b\\src\\lib\\hsl.mjs", "question_type": "Data processing and transformation", "summary": "convert RGB colors to HSL color values\n", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef rgb_to_hsl(r: int, g: int, b: int) -> Dict:\n    \"\"\"\n    Converts an RGB color value to HSL.\n\n    Args:\n        r (int): The red component (0-255).\n        g (int): The green component (0-255).\n        b (int): The blue component (0-255).\n\n    Returns:\n        Dict: A dictionary containing the HSL values.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestRgbToHsl(unittest.TestCase):\n\n    def test_converts_pure_red_to_hsl(self):\n        self.assertEqual(rgb_to_hsl(255, 0, 0), {'h': 0, 's': 100, 'l': 50})\n\n    def test_converts_black_to_hsl(self):\n        self.assertEqual(rgb_to_hsl(0, 0, 0), {'h': 0, 's': 0, 'l': 0})\n\n    def test_converts_white_to_hsl(self):\n        self.assertEqual(rgb_to_hsl(255, 255, 255), {'h': 0, 's': 0, 'l': 100})\n\n    def test_converts_a_color_on_edge_of_rgb_range(self):\n        self.assertEqual(rgb_to_hsl(0, 255, 255), {'h': 180, 's': 100, 'l': 50})\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef rgb_to_hsl(r: int, g: int, b: int) -> Dict:\n    \"\"\"\n    Converts an RGB color value to HSL.\n\n    Args:\n        r (int): The red component (0-255).\n        g (int): The green component (0-255).\n        b (int): The blue component (0-255).\n\n    Returns:\n        Dict: A dictionary containing the HSL values.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts an RGB color value to HSL.\n *\n * @param r - The red component (0-255).\n * @param g - The green component (0-255).\n * @param b - The blue component (0-255).\n * @returns An object containing the HSL values.\n */\nHSL rgbToHsl(int r, int g, int b) {\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n\nHSL rgbToHsl(int r, int g, int b); // Function prototype\n\nTEST_CASE(\"rgbToHsl function\") {\n    SECTION(\"converts pure red to HSL\") {\n        REQUIRE(rgbToHsl(255, 0, 0) == HSL{0, 100, 50});\n    }\n\n    SECTION(\"converts black to HSL\") {\n        REQUIRE(rgbToHsl(0, 0, 0) == HSL{0, 0, 0});\n    }\n\n    SECTION(\"converts white to HSL\") {\n        REQUIRE(rgbToHsl(255, 255, 255) == HSL{0, 0, 100});\n    }\n\n    SECTION(\"converts a color on the edge of RGB range\") {\n        REQUIRE(rgbToHsl(0, 255, 255) == HSL{180, 100, 50});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts an RGB color value to HSL.\n *\n * @param r - The red component (0-255).\n * @param g - The green component (0-255).\n * @param b - The blue component (0-255).\n * @returns An object containing the HSL values.\n */\nHSL rgbToHsl(int r, int g, int b) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts an RGB color value to HSL.\n *\n * @param r The red component (0-255).\n * @param g The green component (0-255).\n * @param b The blue component (0-255).\n * @return An array containing the HSL values.\n */\npublic static int[] rgbToHsl(int r, int g, int b) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testRgbToHslPureRed() {\n        assertArrayEquals(new int[]{0, 100, 50}, rgbToHsl(255, 0, 0));\n    }\n\n    @Test\n    public void testRgbToHslBlack() {\n        assertArrayEquals(new int[]{0, 0, 0}, rgbToHsl(0, 0, 0));\n    }\n\n    @Test\n    public void testRgbToHslWhite() {\n        assertArrayEquals(new int[]{0, 0, 100}, rgbToHsl(255, 255, 255));\n    }\n\n    @Test\n    public void testRgbToHslCyan() {\n        assertArrayEquals(new int[]{180, 100, 50}, rgbToHsl(0, 255, 255));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts an RGB color value to HSL.\n *\n * @param r The red component (0-255).\n * @param g The green component (0-255).\n * @param b The blue component (0-255).\n * @return An array containing the HSL values.\n */\npublic static int[] rgbToHsl(int r, int g, int b) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 118, "code_type": "method", "original_language": "javascript", "file_path": "libresprite-extensions\\dfd82d80fa0512f60fb423d304f8790dad32e96b\\src\\lib\\hsl.mjs", "question_type": "Data processing and transformation", "summary": "convert HSL color values to RGB color values\n", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef hsl_to_rgb(h: int, s: int, l: int) -> Dict:\n    \"\"\"\n    Converts HSL color values to RGB.\n\n    Args:\n        h (int): Hue (0-360 degrees).\n        s (int): Saturation (0-100%).\n        l (int): Lightness (0-100%).\n\n    Returns:\n        Dict: A dictionary containing the RGB values.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestHSLToRGB(unittest.TestCase):\n\n    def test_converts_pure_red_hue_correctly(self):\n        self.assertEqual(hsl_to_rgb(0, 100, 50), {'r': 255, 'g': 0, 'b': 0})\n\n    def test_returns_gray_for_zero_saturation(self):\n        self.assertEqual(hsl_to_rgb(240, 0, 50), {'r': 128, 'g': 128, 'b': 128})\n\n    def test_returns_white_for_full_lightness(self):\n        self.assertEqual(hsl_to_rgb(120, 50, 100), {'r': 255, 'g': 255, 'b': 255})\n\n    def test_converts_full_saturation_and_mid_lightness_blue_correctly(self):\n        self.assertEqual(hsl_to_rgb(240, 100, 50), {'r': 0, 'g': 0, 'b': 255})\n\n    def test_handles_edge_hue_at_360_degrees_correctly(self):\n        self.assertEqual(hsl_to_rgb(360, 100, 50), {'r': 255, 'g': 0, 'b': 0})  # Should be the same as hue 0\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef hsl_to_rgb(h: int, s: int, l: int) -> Dict:\n    \"\"\"\n    Converts HSL color values to RGB.\n\n    Args:\n        h (int): Hue (0-360 degrees).\n        s (int): Saturation (0-100%).\n        l (int): Lightness (0-100%).\n\n    Returns:\n        Dict: A dictionary containing the RGB values.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts HSL color values to RGB.\n *\n * @param h - Hue (0-360 degrees).\n * @param s - Saturation (0-100%).\n * @param l - Lightness (0-100%).\n * @returns A tuple containing the RGB values.\n */\nstd::tuple<int, int, int> hslToRgb(double h, double s, double l) {\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <tuple>\n\n// Assuming hslToRgb function is defined somewhere above or in an included header\n\nTEST_CASE(\"hslToRgb function\", \"[color]\") {\n    SECTION(\"converts pure red hue correctly\") {\n        auto [r, g, b] = hslToRgb(0, 100, 50);\n        REQUIRE(r == 255);\n        REQUIRE(g == 0);\n        REQUIRE(b == 0);\n    }\n\n    SECTION(\"returns gray for zero saturation\") {\n        auto [r, g, b] = hslToRgb(240, 0, 50);\n        REQUIRE(r == 128);\n        REQUIRE(g == 128);\n        REQUIRE(b == 128);\n    }\n\n    SECTION(\"returns white for full lightness\") {\n        auto [r, g, b] = hslToRgb(120, 50, 100);\n        REQUIRE(r == 255);\n        REQUIRE(g == 255);\n        REQUIRE(b == 255);\n    }\n\n    SECTION(\"converts full saturation and mid lightness blue correctly\") {\n        auto [r, g, b] = hslToRgb(240, 100, 50);\n        REQUIRE(r == 0);\n        REQUIRE(g == 0);\n        REQUIRE(b == 255);\n    }\n\n    SECTION(\"handles edge hue at 360 degrees correctly\") {\n        auto [r, g, b] = hslToRgb(360, 100, 50);\n        REQUIRE(r == 255);\n        REQUIRE(g == 0);\n        REQUIRE(b == 0); // Should be the same as hue 0\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts HSL color values to RGB.\n *\n * @param h - Hue (0-360 degrees).\n * @param s - Saturation (0-100%).\n * @param l - Lightness (0-100%).\n * @returns A tuple containing the RGB values.\n */\nstd::tuple<int, int, int> hslToRgb(double h, double s, double l) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts HSL color values to RGB.\n *\n * @param h - Hue (0-360 degrees).\n * @param s - Saturation (0-100%).\n * @param l - Lightness (0-100%).\n * @returns An RGB object containing the RGB values.\n */\npublic static class RGB {\n    public int r, g, b;\n\n    public RGB(int r, int g, int b) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n    }\n}\npublic static RGB hslToRgb(double h, double s, double l) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testConvertsPureRedHueCorrectly() {\n        RGB result = ColorConverter.hslToRgb(0, 100, 50);\n        assertEquals(255, result.r);\n        assertEquals(0, result.g);\n        assertEquals(0, result.b);\n    }\n\n    @Test\n    public void testReturnsGrayForZeroSaturation() {\n        RGB result = ColorConverter.hslToRgb(240, 0, 50);\n        assertEquals(128, result.r);\n        assertEquals(128, result.g);\n        assertEquals(128, result.b);\n    }\n\n    @Test\n    public void testReturnsWhiteForFullLightness() {\n        RGB result = ColorConverter.hslToRgb(120, 50, 100);\n        assertEquals(255, result.r);\n        assertEquals(255, result.g);\n        assertEquals(255, result.b);\n    }\n\n    @Test\n    public void testConvertsFullSaturationMidLightnessBlueCorrectly() {\n        RGB result = ColorConverter.hslToRgb(240, 100, 50);\n        assertEquals(0, result.r);\n        assertEquals(0, result.g);\n        assertEquals(255, result.b);\n    }\n\n    @Test\n    public void testHandlesEdgeHueAt360DegreesCorrectly() {\n        RGB result = ColorConverter.hslToRgb(360, 100, 50);\n        assertEquals(255, result.r);\n        assertEquals(0, result.g);\n        assertEquals(0, result.b); // Should be the same as hue 0\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts HSL color values to RGB.\n *\n * @param h - Hue (0-360 degrees).\n * @param s - Saturation (0-100%).\n * @param l - Lightness (0-100%).\n * @returns An RGB object containing the RGB values.\n */\npublic static class RGB {\n    public int r, g, b;\n\n    public RGB(int r, int g, int b) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n    }\n}\npublic static RGB hslToRgb(double h, double s, double l) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 119, "code_type": "method", "original_language": "javascript", "file_path": "WTA2023Q2_FlappyBird\\64efa4c68ed31c685d15953c82896f15acf3d8b4\\scripts\\script.js", "question_type": "Data processing and transformation", "summary": "gets the cookie value for the specified name from the cookie in the browser. The format of the cookie is key=value;key=value;key=value\n", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 120, "code_type": "method", "original_language": "javascript", "file_path": "TP1-dev-web\\061607b28ef007131c6e6a1fa1be36b575bd2021\\src\\Components\\NestedGrid.js", "question_type": "Data processing and transformation", "summary": "Extract table data from a document object containing HTML tables and return the data organized as a two-dimensional array.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef extract_csv_data_from_html(html_content: str) -> List[List[str]]:\n    \"\"\"\n    Extract table question from an HTML string containing tables and return the question organized as a two-dimensional array.\n\n    Args:\n        html_content (str): A string containing HTML content.\n\n    Returns:\n        List[List[str]]: A two-dimensional array of strings representing the table data.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestHTMLToCSVExtraction(unittest.TestCase):\n\n    def test_table_with_multiple_rows_and_columns(self):\n        test_case_html = \"\"\"\n        <table class=\"waffle\">\n            <tbody>\n                <tr><td>Cell 1</td><td>Cell 2</td></tr>\n                <tr><td>Cell 3</td><td>Cell 4</td></tr>\n            </tbody>\n        </table>\n        \"\"\"\n        expected = [[\"Cell 1\", \"Cell 2\"], [\"Cell 3\", \"Cell 4\"]]\n        self.assertEqual(extract_csv_data_from_html(test_case_html), expected)\n\n    def test_table_with_empty_cells(self):\n        test_case_html = \"\"\"\n        <table class=\"waffle\">\n            <tbody>\n                <tr><td>Cell 1</td><td></td></tr>\n                <tr><td></td><td>Cell 4</td></tr>\n            </tbody>\n        </table>\n        \"\"\"\n        expected = [[\"Cell 1\", \"\"], [\"\", \"Cell 4\"]]\n        self.assertEqual(extract_csv_data_from_html(test_case_html), expected)\n\n    def test_table_with_only_one_row(self):\n        test_case_html = \"\"\"\n        <table class=\"waffle\">\n            <tbody>\n                <tr><td>Single Cell 1</td><td>Single Cell 2</td></tr>\n            </tbody>\n        </table>\n        \"\"\"\n        expected = [[\"Single Cell 1\", \"Single Cell 2\"]]\n        self.assertEqual(extract_csv_data_from_html(test_case_html), expected)\n\n    def test_table_with_only_one_column(self):\n        test_case_html = \"\"\"\n        <table class=\"waffle\">\n            <tbody>\n                <tr><td>Column Cell 1</td></tr>\n                <tr><td>Column Cell 2</td></tr>\n            </tbody>\n        </table>\n        \"\"\"\n        expected = [[\"Column Cell 1\"], [\"Column Cell 2\"]]\n        self.assertEqual(extract_csv_data_from_html(test_case_html), expected)\n\n    def test_no_table_with_class_waffle_present(self):\n        test_case_html = \"\"\"\n        <div>\n            <p>No table here!</p>\n        </div>\n        \"\"\"\n        expected = []\n        self.assertEqual(extract_csv_data_from_html(test_case_html), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef extract_csv_data_from_html(html_content: str) -> List[List[str]]:\n    \"\"\"\n    Extract table question from an HTML string containing tables and return the question organized as a two-dimensional array.\n\n    Args:\n        html_content (str): A string containing HTML content.\n\n    Returns:\n        List[List[str]]: A two-dimensional array of strings representing the table data.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 121, "code_type": "method", "original_language": "javascript", "file_path": "Using-Konduktiva-With-MIDI\\a4fe0844bfcb987ecdd1d62441365df72220678a\\arrayTransformations.js", "question_type": "Data processing and transformation", "summary": "Adjust the length of the input array according to the given target length (number). If the current length of the array is longer than the target length, the first part of the array is intercepted to match the target length; If the current length of the array is shorter than the target length, the elements in the array are repeated until the target length is reached.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef adjust_array_length(target_length: int, array: List) -> List:\n    \"\"\"\n    Adjust the length of the input array according to the given target length.\n    If the current length of the array is longer than the target length,\n    the first part of the array is intercepted to match the target length.\n    If the current length of the array is shorter than the target length,\n    the elements in the array are repeated until the target length is reached.\n\n    Args:\n        target_length (int): The desired length for the array.\n        array (List): The input array to be adjusted.\n\n    Returns:\n        List: A new array that has been adjusted to the target length.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestAdjustArrayLength(unittest.TestCase):\n\n    def test_array_length_equal_to_target_length(self):\n        result = adjust_array_length(5, [1, 2, 3, 4, 5])\n        self.assertEqual(result, [1, 2, 3, 4, 5])\n\n    def test_array_length_shorter_than_target_length(self):\n        result = adjust_array_length(8, [1, 2, 3])\n        self.assertEqual(result, [1, 2, 3, 1, 2, 3, 1, 2])\n\n    def test_array_length_shorter_than_target_length_multiple(self):\n        result = adjust_array_length(6, [10, 20])\n        self.assertEqual(result, [10, 20, 10, 20, 10, 20])\n\n    def test_array_length_shorter_than_target_length_not_multiple(self):\n        result = adjust_array_length(7, [7, 14, 21])\n        self.assertEqual(result, [7, 14, 21, 7, 14, 21, 7])\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef adjust_array_length(target_length: int, array: List) -> List:\n    \"\"\"\n    Adjust the length of the input array according to the given target length.\n    If the current length of the array is longer than the target length,\n    the first part of the array is intercepted to match the target length.\n    If the current length of the array is shorter than the target length,\n    the elements in the array are repeated until the target length is reached.\n\n    Args:\n        target_length (int): The desired length for the array.\n        array (List): The input array to be adjusted.\n\n    Returns:\n        List: A new array that has been adjusted to the target length.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Adjust the length of the input array according to the given target length (number).\n * If the current length of the array is longer than the target length, the first part\n * of the array is intercepted to match the target length; If the current length of the\n * array is shorter than the target length, the elements in the array are repeated until\n * the target length is reached.\n *\n * @param targetLength - The desired length for the array.\n * @param array - The input array to be adjusted.\n * @returns A new vector<int> that has been adjusted to the target length.\n */\nstd::vector<int> adjustArrayLength(int targetLength, const std::vector<int>& array) {\n    // function implementation\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <vector>\n\n// Function prototype\nstd::vector<int> adjustArrayLength(int targetLength, const std::vector<int>& array);\n\nTEST_CASE(\"adjustArrayLength function tests\") {\n    SECTION(\"Array length equal to the target length\") {\n        auto result = adjustArrayLength(5, {1, 2, 3, 4, 5});\n        REQUIRE(result == std::vector<int>{1, 2, 3, 4, 5});\n    }\n\n    SECTION(\"Array length shorter than the target length\") {\n        auto result = adjustArrayLength(8, {1, 2, 3});\n        REQUIRE(result == std::vector<int>{1, 2, 3, 1, 2, 3, 1, 2});\n    }\n\n    SECTION(\"Array length shorter than the target length, target length is a multiple of array length\") {\n        auto result = adjustArrayLength(6, {10, 20});\n        REQUIRE(result == std::vector<int>{10, 20, 10, 20, 10, 20});\n    }\n\n    SECTION(\"Array length shorter than the target length, target length is not a multiple of array length\") {\n        auto result = adjustArrayLength(7, {7, 14, 21});\n        REQUIRE(result == std::vector<int>{7, 14, 21, 7, 14, 21, 7});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Adjust the length of the input array according to the given target length (number).\n * If the current length of the array is longer than the target length, the first part\n * of the array is intercepted to match the target length; If the current length of the\n * array is shorter than the target length, the elements in the array are repeated until\n * the target length is reached.\n *\n * @param targetLength - The desired length for the array.\n * @param array - The input array to be adjusted.\n * @returns A new vector<int> that has been adjusted to the target length.\n */\nstd::vector<int> adjustArrayLength(int targetLength, const std::vector<int>& array) {\n    // function implementation\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Adjusts the length of the input array according to the given target length (int).\n * If the current length of the array is longer than the target length,\n * the first part of the array is intercepted to match the target length.\n * If the current length of the array is shorter than the target length,\n * the elements in the array are repeated until the target length is reached.\n *\n * @param targetLength - The desired length for the array.\n * @param array - The input array to be adjusted.\n * @returns A new array that has been adjusted to the target length.\n */\npublic static int[] adjustArrayLength(int targetLength, int[] array) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testArrayLengthEqualToTargetLength() {\n        int[] result = adjustArrayLength(5, new int[]{1, 2, 3, 4, 5});\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5}, result);\n    }\n\n    @Test\n    public void testArrayLengthShorterThanTargetLength() {\n        int[] result = adjustArrayLength(8, new int[]{1, 2, 3});\n        assertArrayEquals(new int[]{1, 2, 3, 1, 2, 3, 1, 2}, result);\n    }\n\n    @Test\n    public void testArrayLengthShorterThanTargetLengthMultiple() {\n        int[] result = adjustArrayLength(6, new int[]{10, 20});\n        assertArrayEquals(new int[]{10, 20, 10, 20, 10, 20}, result);\n    }\n\n    @Test\n    public void testArrayLengthShorterThanTargetLengthNotMultiple() {\n        int[] result = adjustArrayLength(7, new int[]{7, 14, 21});\n        assertArrayEquals(new int[]{7, 14, 21, 7, 14, 21, 7}, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Adjusts the length of the input array according to the given target length (int).\n * If the current length of the array is longer than the target length,\n * the first part of the array is intercepted to match the target length.\n * If the current length of the array is shorter than the target length,\n * the elements in the array are repeated until the target length is reached.\n *\n * @param targetLength - The desired length for the array.\n * @param array - The input array to be adjusted.\n * @returns A new array that has been adjusted to the target length.\n */\npublic static int[] adjustArrayLength(int targetLength, int[] array) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 122, "code_type": "method", "original_language": "javascript", "file_path": "Using-Konduktiva-With-MIDI\\a4fe0844bfcb987ecdd1d62441365df72220678a\\arrayTransformations.js", "question_type": "Data processing and transformation", "summary": "Safely splices an array by removing a specified number of elements from a given index,\n and optionally replaces them with a new element.", "language_version_list": {"python": {"code_signature": "def safe_splice(input_array:list, amount_to_remove, index_to_remove, replace_with=None):\n    \"\"\"\n    Safely splices an array by removing a specified number of elements from a given index,\n    and optionally replaces them with a new element.\n\n    Args:\n        input_array (list): The original array to be modified.\n        amount_to_remove (int): The number of elements to remove from the array.\n        index_to_remove (int): The index at which to start removing elements.\n        replace_with (any, optional): The element to replace the removed elements with.\n\n    Returns:\n        list: A new array with the specified elements removed and optionally replaced.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestSafeSplice(unittest.TestCase):\n\n    def test_replaces_removed_elements_with_a_new_element(self):\n        input_array = ['a', 'b', 'c', 'd', 'e']\n        expected = ['a', 'z', 'e']\n        result = safe_splice(input_array, 3, 1, 'z')\n        self.assertEqual(result, expected)\n\n    def test_removes_specified_elements_and_replaces_with_new_element(self):\n        input_array = [1, 2, 3, 4, 5]\n        amount_to_remove = 2\n        index_to_remove = 1\n        replace_with = 99\n        result = safe_splice(input_array, amount_to_remove, index_to_remove, replace_with)\n        self.assertEqual(result, [1, 99, 4, 5])\n\n    def test_handles_removing_elements_from_the_end_of_the_array(self):\n        input_array = [1, 2, 3, 4, 5]\n        amount_to_remove = 2\n        index_to_remove = 3\n        result = safe_splice(input_array, amount_to_remove, index_to_remove)\n        self.assertEqual(result, [1, 2, 3])\n\n    def test_handles_case_where_no_elements_are_removed(self):\n        input_array = [1, 2, 3, 4, 5]\n        amount_to_remove = 0\n        index_to_remove = 2\n        replace_with = 99\n        result = safe_splice(input_array, amount_to_remove, index_to_remove, replace_with)\n        self.assertEqual(result, [1, 2, 99, 3, 4, 5])\n\n    def test_handles_edge_case_with_empty_input_array(self):\n        input_array = []\n        amount_to_remove = 1\n        index_to_remove = 0\n        replace_with = 99\n        result = safe_splice(input_array, amount_to_remove, index_to_remove, replace_with)\n        self.assertEqual(result, [99])\n", "prompt": "please write a python function , the function signature as below def safe_splice(input_array:list, amount_to_remove, index_to_remove, replace_with=None):\n    \"\"\"\n    Safely splices an array by removing a specified number of elements from a given index,\n    and optionally replaces them with a new element.\n\n    Args:\n        input_array (list): The original array to be modified.\n        amount_to_remove (int): The number of elements to remove from the array.\n        index_to_remove (int): The index at which to start removing elements.\n        replace_with (any, optional): The element to replace the removed elements with.\n\n    Returns:\n        list: A new array with the specified elements removed and optionally replaced.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Safely splices a vector by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n *\n * @param std::vector<int> inputArray - The original vector to be modified.\n * @param int amountToRemove - The number of elements to remove from the vector.\n * @param int indexToRemove - The index at which to start removing elements.\n * @param std::optional<int> replaceWith - Optional. The element to replace the removed elements with.\n * @returns std::vector<int> - A new vector with the specified elements removed and optionally replaced.\n */\nstd::vector<int> safeSplice(const std::vector<int>& inputArray, int amountToRemove, int indexToRemove, std::optional<int> replaceWith){\n\n}\n", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <vector>\n#include <optional>\n\n// Assuming safeSplice function is declared here\n\nTEST_CASE(\"safeSplice\", \"[splice]\") {\n    SECTION(\"replaces removed elements with a new element\") {\n        std::vector<std::string> inputArray = {\"a\", \"b\", \"c\", \"d\", \"e\"};\n        std::vector<std::string> expected = {\"a\", \"z\", \"e\"};\n        REQUIRE(safeSplice(inputArray, 3, 1, \"z\") == expected);\n    }\n\n    SECTION(\"should remove specified elements and replace with new element\") {\n        std::vector<int> inputArray = {1, 2, 3, 4, 5};\n        int amountToRemove = 2;\n        int indexToRemove = 1;\n        int replaceWith = 99;\n        std::vector<int> result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        REQUIRE(result == std::vector<int>{1, 99, 4, 5});\n    }\n\n    SECTION(\"should handle removing elements from the end of the array\") {\n        std::vector<int> inputArray = {1, 2, 3, 4, 5};\n        int amountToRemove = 2;\n        int indexToRemove = 3;\n        std::vector<int> result = safeSplice(inputArray, amountToRemove, indexToRemove);\n        REQUIRE(result == std::vector<int>{1, 2, 3});\n    }\n\n    SECTION(\"should handle the case where no elements are removed\") {\n        std::vector<int> inputArray = {1, 2, 3, 4, 5};\n        int amountToRemove = 0;\n        int indexToRemove = 2;\n        int replaceWith = 99;\n        std::vector<int> result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        REQUIRE(result == std::vector<int>{1, 2, 99, 3, 4, 5});\n    }\n\n    SECTION(\"should handle edge case with an empty input array\") {\n        std::vector<int> inputArray = {};\n        int amountToRemove = 1;\n        int indexToRemove = 0;\n        int replaceWith = 99;\n        std::vector<int> result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        REQUIRE(result == std::vector<int>{99});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Safely splices a vector by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n *\n * @param std::vector<int> inputArray - The original vector to be modified.\n * @param int amountToRemove - The number of elements to remove from the vector.\n * @param int indexToRemove - The index at which to start removing elements.\n * @param std::optional<int> replaceWith - Optional. The element to replace the removed elements with.\n * @returns std::vector<int> - A new vector with the specified elements removed and optionally replaced.\n */\nstd::vector<int> safeSplice(const std::vector<int>& inputArray, int amountToRemove, int indexToRemove, std::optional<int> replaceWith){\n\n}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Safely splices a list by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n *\n * @param inputArray - The original list to be modified.\n * @param amountToRemove - The number of elements to remove from the list.\n * @param indexToRemove - The index at which to start removing elements.\n * @param replaceWith - Optional. The element to replace the removed elements with.\n * @return A new list with the specified elements removed and optionally replaced.\n */\npublic static List<Object> safeSplice(List<Object> inputArray, int amountToRemove, int indexToRemove, Object replaceWith) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertArrayEquals;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testReplacesRemovedElementsWithNewElement() {\n        List<Object> inputArray = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\");\n        List<Object> expected = Arrays.asList(\"a\", \"z\", \"e\");\n        assertArrayEquals(expected.toArray(), safeSplice(inputArray, 3, 1, \"z\").toArray());\n    }\n\n    @Test\n    public void testShouldRemoveSpecifiedElementsAndReplaceWithNewElement() {\n        List<Object> inputArray = Arrays.asList(1, 2, 3, 4, 5);\n        List<Object> expected = Arrays.asList(1, 99, 4, 5);\n        assertArrayEquals(expected.toArray(), safeSplice(inputArray, 2, 1, 99).toArray());\n    }\n\n    @Test\n    public void testShouldHandleRemovingElementsFromEnd() {\n        List<Object> inputArray = Arrays.asList(1, 2, 3, 4, 5);\n        List<Object> expected = Arrays.asList(1, 2, 3);\n        assertArrayEquals(expected.toArray(), safeSplice(inputArray, 2, 3, null).toArray());\n    }\n\n    @Test\n    public void testShouldHandleNoElementsRemoved() {\n        List<Object> inputArray = Arrays.asList(1, 2, 3, 4, 5);\n        List<Object> expected = Arrays.asList(1, 2, 99, 3, 4, 5);\n        assertArrayEquals(expected.toArray(), safeSplice(inputArray, 0, 2, 99).toArray());\n    }\n\n    @Test\n    public void testShouldHandleEmptyInputArray() {\n        List<Object> inputArray = Arrays.asList();\n        List<Object> expected = Arrays.asList(99);\n        assertArrayEquals(expected.toArray(), safeSplice(inputArray, 1, 0, 99).toArray());\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Safely splices a list by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n *\n * @param inputArray - The original list to be modified.\n * @param amountToRemove - The number of elements to remove from the list.\n * @param indexToRemove - The index at which to start removing elements.\n * @param replaceWith - Optional. The element to replace the removed elements with.\n * @return A new list with the specified elements removed and optionally replaced.\n */\npublic static List<Object> safeSplice(List<Object> inputArray, int amountToRemove, int indexToRemove, Object replaceWith) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 123, "code_type": "method", "original_language": "javascript", "file_path": "Using-Konduktiva-With-MIDI\\a4fe0844bfcb987ecdd1d62441365df72220678a\\arrayTransformations.js", "question_type": "Data processing and transformation", "summary": "Scale the values in an array from one range to another. To ensure that the values in the input array do not exceed the given minimum and maximum values, we can add checks to filter out values that are out of range", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef scale_to_range(input_array: List, input_min: float, input_max: float, output_min: float, output_max: float) -> List[\n    float]:\n    \"\"\"\n    Scales the values in an array from one range to another.\n    Args:\n        input_array (List): The array of input values to be scaled.\n        input_min (float): The minimum value in the input range.\n        input_max (float): The maximum value in the input range.\n        output_min (float): The minimum value in the output range.\n        output_max (float): The maximum value in the output range.\n\n    Returns:\n        List[float]: A new array with values scaled to the output range\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestScaleToRange(unittest.TestCase):\n    def test_simple_scaling(self):\n        result = scale_to_range([1, 2, 3, 4, 5], 1, 5, 10, 50)\n        self.assertEqual(result, [10, 20, 30, 40, 50])\n\n    def test_scaling_with_negative_input_range(self):\n        result = scale_to_range([-5, 0, 5], -5, 5, 0, 100)\n        self.assertEqual(result, [0, 50, 100])\n\n    def test_scaling_with_negative_output_range(self):\n        result = scale_to_range([0, 50, 100], 0, 100, -100, 100)\n        self.assertEqual(result, [-100, 0, 100])\n\n    def test_input_array_containing_the_same_value(self):\n        result = scale_to_range([2, 2, 2], 1, 3, 0, 10)\n        self.assertEqual(result, [5, 5, 5])\n\n    def test_input_value_out_of_range_should_throw_an_error(self):\n        with self.assertRaises(ValueError):\n            scale_to_range([1, 2, 3, 6], 1, 5, 0, 10)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef scale_to_range(input_array: List, input_min: float, input_max: float, output_min: float, output_max: float) -> List[\n    float]:\n    \"\"\"\n    Scales the values in an array from one range to another.\n    Args:\n        input_array (List): The array of input values to be scaled.\n        input_min (float): The minimum value in the input range.\n        input_max (float): The maximum value in the input range.\n        output_min (float): The minimum value in the output range.\n        output_max (float): The maximum value in the output range.\n\n    Returns:\n        List[float]: A new array with values scaled to the output range\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Scales the values in an array from one range to another.\n *\n * @param inputArray - The array of input values to be scaled.\n * @param inputMin - The minimum value in the input range.\n * @param inputMax - The maximum value in the input range.\n * @param outputMin - The minimum value in the output range.\n * @param outputMax - The maximum value in the output range.\n * @returns A new vector with values scaled to the output range.\n * @throws std::invalid_argument - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\nstd::vector<double> scaleToRange(const std::vector<double>& inputArray, double inputMin, double inputMax, double outputMin, double outputMax) {\n    // function implementation\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <vector>\n#include <stdexcept>\n\nstd::vector<double> scaleToRange(const std::vector<double>& inputArray, double inputMin, double inputMax, double outputMin, double outputMax);\n\nTEST_CASE(\"scaleToRange function tests\") {\n    SECTION(\"simple scaling\") {\n        auto result = scaleToRange({1, 2, 3, 4, 5}, 1, 5, 10, 50);\n        REQUIRE(result == std::vector<double>({10, 20, 30, 40, 50}));\n    }\n\n    SECTION(\"scaling with negative input range\") {\n        auto result = scaleToRange({-5, 0, 5}, -5, 5, 0, 100);\n        REQUIRE(result == std::vector<double>({0, 50, 100}));\n    }\n\n    SECTION(\"scaling with negative output range\") {\n        auto result = scaleToRange({0, 50, 100}, 0, 100, -100, 100);\n        REQUIRE(result == std::vector<double>({-100, 0, 100}));\n    }\n\n    SECTION(\"input array containing the same value\") {\n        auto result = scaleToRange({2, 2, 2}, 1, 3, 0, 10);\n        REQUIRE(result == std::vector<double>({5, 5, 5}));\n    }\n\n    SECTION(\"input value out of range should throw an error\") {\n        REQUIRE_THROWS_AS(scaleToRange({1, 2, 3, 6}, 1, 5, 0, 10), std::invalid_argument);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Scales the values in an array from one range to another.\n *\n * @param inputArray - The array of input values to be scaled.\n * @param inputMin - The minimum value in the input range.\n * @param inputMax - The maximum value in the input range.\n * @param outputMin - The minimum value in the output range.\n * @param outputMax - The maximum value in the output range.\n * @returns A new vector with values scaled to the output range.\n * @throws std::invalid_argument - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\nstd::vector<double> scaleToRange(const std::vector<double>& inputArray, double inputMin, double inputMax, double outputMin, double outputMax) {\n    // function implementation\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Scales the values in an array from one range to another.\n *\n * @param inputArray - The array of input values to be scaled.\n * @param inputMin - The minimum value in the input range.\n * @param inputMax - The maximum value in the input range.\n * @param outputMin - The minimum value in the output range.\n * @param outputMax - The maximum value in the output range.\n * @return A new array with values scaled to the output range.\n * @throws IllegalArgumentException - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\npublic static double[] scaleToRange(double[] inputArray, double inputMin, double inputMax, double outputMin, double outputMax) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\n\nimport org.junit.Test;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testSimpleScaling() {\n        double[] result = scaleToRange(new double[]{1, 2, 3, 4, 5}, 1, 5, 10, 50);\n        assertArrayEquals(new double[]{10, 20, 30, 40, 50}, result, 0.001);\n    }\n\n    @Test\n    public void testScalingWithNegativeInputRange() {\n        double[] result = scaleToRange(new double[]{-5, 0, 5}, -5, 5, 0, 100);\n        assertArrayEquals(new double[]{0, 50, 100}, result, 0.001);\n    }\n\n    @Test\n    public void testScalingWithNegativeOutputRange() {\n        double[] result = scaleToRange(new double[]{0, 50, 100}, 0, 100, -100, 100);\n        assertArrayEquals(new double[]{-100, 0, 100}, result, 0.001);\n    }\n\n    @Test\n    public void testInputArrayContainingSameValue() {\n        double[] result = scaleToRange(new double[]{2, 2, 2}, 1, 3, 0, 10);\n        assertArrayEquals(new double[]{5, 5, 5}, result, 0.001);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testInputValueOutOfRangeShouldThrowError() {\n        scaleToRange(new double[]{1, 2, 3, 6}, 1, 5, 0, 10);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Scales the values in an array from one range to another.\n *\n * @param inputArray - The array of input values to be scaled.\n * @param inputMin - The minimum value in the input range.\n * @param inputMax - The maximum value in the input range.\n * @param outputMin - The minimum value in the output range.\n * @param outputMax - The maximum value in the output range.\n * @return A new array with values scaled to the output range.\n * @throws IllegalArgumentException - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\npublic static double[] scaleToRange(double[] inputArray, double inputMin, double inputMax, double outputMin, double outputMax) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 124, "code_type": "method", "original_language": "javascript", "file_path": "Using-Konduktiva-With-MIDI\\a4fe0844bfcb987ecdd1d62441365df72220678a\\arrayTransformations.js", "question_type": "Data processing and transformation", "summary": "Randomly sort the input array, that is, rearrange the elements of the array in a random order.", "language_version_list": {"python": {"code_signature": "def shuffle(array: list) -> list:\n    \"\"\"\n    Randomly shuffles the elements of the input list in place.\n\n    Args:\n        array (list): The list of elements to be shuffled.\n\n    Returns:\n        list: The shuffled list with its elements in random order.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestShuffleFunction(unittest.TestCase):\n\n    def test_shuffles_array_of_numbers(self):\n        array = [1, 2, 3, 4, 5]\n        shuffled_array = shuffle(array.copy())\n        self.assertEqual(len(shuffled_array), len(array))\n        self.assertTrue(all(item in array for item in shuffled_array))\n        self.assertEqual(len(set(shuffled_array)), len(set(array)))  # Ensure no duplicates\n\n    def test_shuffles_array_of_strings(self):\n        array = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"]\n        shuffled_array = shuffle(array.copy())\n        self.assertEqual(len(shuffled_array), len(array))\n        self.assertTrue(all(item in array for item in shuffled_array))\n\n    def test_shuffles_array_with_duplicate_elements(self):\n        array = [1, 1, 2, 2, 3, 3]\n        shuffled_array = shuffle(array.copy())\n        self.assertEqual(len(shuffled_array), len(array))\n        self.assertTrue(all(item in array for item in shuffled_array))\n\n    def test_shuffles_array_with_single_element(self):\n        array = [42]\n        shuffled_array = shuffle(array.copy())\n        self.assertEqual(shuffled_array, array)\n\n    def test_shuffles_empty_array(self):\n        array = []\n        shuffled_array = shuffle(array.copy())\n        self.assertEqual(len(shuffled_array), 0)\n", "prompt": "please write a python function , the function signature as below def shuffle(array: list) -> list:\n    \"\"\"\n    Randomly shuffles the elements of the input list in place.\n\n    Args:\n        array (list): The list of elements to be shuffled.\n\n    Returns:\n        list: The shuffled list with its elements in random order.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Randomly shuffles the elements of the input vector in place.\n *\n * @param std::vector<int>& array - The vector of elements to be shuffled.\n * @returns std::vector<int> - The shuffled vector with its elements in random order.\n */\nstd::vector<int> shuffle(std::vector<int>& array) {\n    // function implementation\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n\nstd::vector<int> shuffle(std::vector<int>& array); // Declaration of the shuffle function\n\nTEST_CASE(\"shuffle function tests\") {\n    SECTION(\"shuffles an array of numbers\") {\n        std::vector<int> array = {1, 2, 3, 4, 5};\n        std::vector<int> shuffledArray = array;\n        shuffle(shuffledArray);\n\n        REQUIRE(shuffledArray.size() == array.size());\n        REQUIRE(std::all_of(shuffledArray.begin(), shuffledArray.end(), [&](int item) {\n            return std::find(array.begin(), array.end(), item) != array.end();\n        }));\n        REQUIRE(std::set<int>(shuffledArray.begin(), shuffledArray.end()).size() ==\n                std::set<int>(array.begin(), array.end()).size()); // Ensure no duplicates\n    }\n\n    SECTION(\"shuffles an array of strings\") {\n        std::vector<std::string> array = {\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"};\n        std::vector<std::string> shuffledArray = array;\n        shuffle(shuffledArray);\n\n        REQUIRE(shuffledArray.size() == array.size());\n        REQUIRE(std::all_of(shuffledArray.begin(), shuffledArray.end(), [&](const std::string& item) {\n            return std::find(array.begin(), array.end(), item) != array.end();\n        }));\n    }\n\n    SECTION(\"shuffles an array with duplicate elements\") {\n        std::vector<int> array = {1, 1, 2, 2, 3, 3};\n        std::vector<int> shuffledArray = array;\n        shuffle(shuffledArray);\n\n        REQUIRE(shuffledArray.size() == array.size());\n        REQUIRE(std::all_of(shuffledArray.begin(), shuffledArray.end(), [&](int item) {\n            return std::find(array.begin(), array.end(), item) != array.end();\n        }));\n    }\n\n    SECTION(\"shuffles an array with a single element\") {\n        std::vector<int> array = {42};\n        std::vector<int> shuffledArray = array;\n        shuffle(shuffledArray);\n\n        REQUIRE(shuffledArray == array);\n    }\n\n    SECTION(\"shuffles an empty array\") {\n        std::vector<int> array = {};\n        std::vector<int> shuffledArray = array;\n        shuffle(shuffledArray);\n\n        REQUIRE(shuffledArray.size() == 0);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Randomly shuffles the elements of the input vector in place.\n *\n * @param std::vector<int>& array - The vector of elements to be shuffled.\n * @returns std::vector<int> - The shuffled vector with its elements in random order.\n */\nstd::vector<int> shuffle(std::vector<int>& array) {\n    // function implementation\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Randomly shuffles the elements of the input array in place.\n *\n * @param array - The array of elements to be shuffled.\n * @return - The shuffled array with its elements in random order.\n */\npublic static int[] shuffle(int[] array) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testShuffleNumbers() {\n        int[] array = {1, 2, 3, 4, 5};\n        int[] shuffledArray = shuffle(Arrays.copyOf(array, array.length));\n        assertEquals(array.length, shuffledArray.length);\n        assertTrue(Arrays.stream(shuffledArray).allMatch(i -> Arrays.stream(array).anyMatch(j -> j == i)));\n        assertEquals(new HashSet<>(Arrays.asList(Arrays.stream(shuffledArray).boxed().toArray(Integer[]::new))).size(),\n                new HashSet<>(Arrays.asList(Arrays.stream(array).boxed().toArray(Integer[]::new))).size());\n    }\n\n    @Test\n    public void testShuffleStrings() {\n        String[] array = {\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"};\n        String[] shuffledArray = {\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"};\n        assertEquals(array.length, shuffledArray.length);\n        assertTrue(Arrays.stream(shuffledArray).allMatch(i -> Arrays.stream(array).anyMatch(j -> j.equals(i))));\n    }\n\n    @Test\n    public void testShuffleDuplicates() {\n        int[] array = {1, 1, 2, 2, 3, 3};\n        int[] shuffledArray = shuffle(Arrays.copyOf(array, array.length));\n        assertEquals(array.length, shuffledArray.length);\n        assertTrue(Arrays.stream(shuffledArray).allMatch(i -> Arrays.stream(array).anyMatch(j -> j == i)));\n    }\n\n    @Test\n    public void testShuffleSingleElement() {\n        int[] array = {42};\n        int[] shuffledArray = shuffle(Arrays.copyOf(array, array.length));\n        assertArrayEquals(array, shuffledArray);\n    }\n\n    @Test\n    public void testShuffleEmptyArray() {\n        int[] array = {};\n        int[] shuffledArray = shuffle(Arrays.copyOf(array, array.length));\n        assertEquals(0, shuffledArray.length);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Randomly shuffles the elements of the input array in place.\n *\n * @param array - The array of elements to be shuffled.\n * @return - The shuffled array with its elements in random order.\n */\npublic static int[] shuffle(int[] array) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 125, "code_type": "method", "original_language": "javascript", "file_path": "TopLandWeb\\50b18e20cbcd43d6f072a1530c6af93d2f12f689\\src\\htmlHelper.js", "question_type": "Data processing and transformation", "summary": "Compressing HTML strings removes unexpected whitespace and newlines from strings in tags", "language_version_list": {"python": {"code_signature": "def compress_html(html_string: str) -> str:\n    \"\"\"\n    Compresses an HTML string by removing unnecessary whitespace without disrupting\n    the integrity of content within <pre>, <div>, <script>, and <style> tags.\n\n    For example:\n        input: '   <div>   Content  </div>   '\n        output: '<div> Content </div>'\n\n    Args:\n        html_string (str): The HTML content to compress.\n\n    Returns:\n        str: The compressed HTML content.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCompressHTML(unittest.TestCase):\n\n    def test_remove_leading_and_trailing_spaces_around_tags(self):\n        input_html = '  <div>  <p>Test</p>  </div>  '\n        expected = '<div><p>Test</p></div>'\n        self.assertEqual(compress_html(input_html), expected)\n\n    def test_replace_multiple_newlines_with_single_space(self):\n        input_html = '<div>\\n\\n<p>Test</p>\\n\\n</div>'\n        expected = '<div> <p>Test</p> </div>'\n        self.assertEqual(compress_html(input_html), expected)\n\n    def test_remove_unnecessary_spaces_within_text(self):\n        input_html = '<p>This    is a test</p>'\n        expected = '<p>This is a test</p>'\n        self.assertEqual(compress_html(input_html), expected)\n\n    def test_handle_empty_strings(self):\n        input_html = ''\n        expected = ''\n        self.assertEqual(compress_html(input_html), expected)\n\n    def test_process_complex_nested_html_correctly(self):\n        input_html = '<div>   <span>    Text <i>    Italic </i> more text </span>   </div>'\n        expected = '<div><span>Text <i>Italic</i> more text</span></div>'\n        self.assertEqual(compress_html(input_html), expected)\n\n    def test_not_disrupt_content_within_pre_and_textarea_tags(self):\n        input_html = '<pre>\\n    function example() {\\n        console.log(\"example\");\\n    }\\n</pre>'\n        expected = '<pre>\\n    function example() {\\n        console.log(\"example\");\\n    }\\n</pre>'\n        self.assertEqual(compress_html(input_html), expected)\n\n    def test_handle_html_with_attributes_correctly(self):\n        input_html = '<a href=\"http://example.com\"    title=\"Example\" >Link</a>'\n        expected = '<a href=\"http://example.com\" title=\"Example\">Link</a>'\n        self.assertEqual(compress_html(input_html), expected)\n", "prompt": "please write a python function , the function signature as below def compress_html(html_string: str) -> str:\n    \"\"\"\n    Compresses an HTML string by removing unnecessary whitespace without disrupting\n    the integrity of content within <pre>, <div>, <script>, and <style> tags.\n\n    For example:\n        input: '   <div>   Content  </div>   '\n        output: '<div> Content </div>'\n\n    Args:\n        html_string (str): The HTML content to compress.\n\n    Returns:\n        str: The compressed HTML content.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <div>, <script>, and <style> tags.\n * For example:\n *      input: '   <div>   Content  </div>   '\n *      output: '<div> Content </div>'\n *\n * @param htmlString - The HTML content to compress.\n * @returns The compressed HTML content.\n */\nstd::string compressHTML(const std::string& htmlString) {\n    // Implementation goes here\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\n// Assume compressHTML is defined elsewhere\nstd::string compressHTML(const std::string& htmlString);\n\nTEST_CASE(\"compressHTML\") {\n    SECTION(\"should remove leading and trailing spaces around tags\") {\n        std::string input = \"  <div>  <p>Test</p>  </div>  \";\n        std::string expected = \"<div><p>Test</p></div>\";\n        REQUIRE(compressHTML(input) == expected);\n    }\n\n    SECTION(\"should replace multiple newlines with a single space\") {\n        std::string input = \"<div>\\n\\n<p>Test</p>\\n\\n</div>\";\n        std::string expected = \"<div> <p>Test</p> </div>\";\n        REQUIRE(compressHTML(input) == expected);\n    }\n\n    SECTION(\"should remove unnecessary spaces within text\") {\n        std::string input = \"<p>This    is a test</p>\";\n        std::string expected = \"<p>This is a test</p>\";\n        REQUIRE(compressHTML(input) == expected);\n    }\n\n    SECTION(\"should handle empty strings\") {\n        std::string input = \"\";\n        std::string expected = \"\";\n        REQUIRE(compressHTML(input) == expected);\n    }\n\n    SECTION(\"should process complex nested HTML correctly\") {\n        std::string input = \"<div>   <span>    Text <i>    Italic </i> more text </span>   </div>\";\n        std::string expected = \"<div><span>Text <i>Italic</i> more text</span></div>\";\n        REQUIRE(compressHTML(input) == expected);\n    }\n\n    SECTION(\"should not disrupt content within <pre> and <textarea> tags\") {\n        std::string input = \"<pre>\\n    function example() {\\n        console.log(\\\"example\\\");\\n    }\\n</pre>\";\n        std::string expected = \"<pre>\\n    function example() {\\n        console.log(\\\"example\\\");\\n    }\\n</pre>\"; // assuming no changes in <pre> and <textarea>\n        REQUIRE(compressHTML(input) == expected);\n    }\n\n    SECTION(\"should handle HTML with attributes correctly\") {\n        std::string input = \"<a href=\\\"http://example.com\\\"    title=\\\"Example\\\" >Link</a>\";\n        std::string expected = \"<a href=\\\"http://example.com\\\" title=\\\"Example\\\">Link</a>\";\n        REQUIRE(compressHTML(input) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <div>, <script>, and <style> tags.\n * For example:\n *      input: '   <div>   Content  </div>   '\n *      output: '<div> Content </div>'\n *\n * @param htmlString - The HTML content to compress.\n * @returns The compressed HTML content.\n */\nstd::string compressHTML(const std::string& htmlString) {\n    // Implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <div>, <script>, and <style> tags.\n * For example:\n *      input: '   <div>   Content  </div>   '\n *      output: '<div> Content </div>'\n *\n * @param htmlString The HTML content to compress.\n * @return The compressed HTML content.\n */\npublic static String compressHTML(String htmlString) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testRemoveLeadingAndTrailingSpacesAroundTags() {\n        String input = \"  <div>  <p>Test</p>  </div>  \";\n        String expected = \"<div><p>Test</p></div>\";\n        assertEquals(expected, compressHTML(input));\n    }\n\n    @Test\n    public void testReplaceMultipleNewlinesWithSingleSpace() {\n        String input = \"<div>\\n\\n<p>Test</p>\\n\\n</div>\";\n        String expected = \"<div> <p>Test</p> </div>\";\n        assertEquals(expected, compressHTML(input));\n    }\n\n    @Test\n    public void testRemoveUnnecessarySpacesWithinText() {\n        String input = \"<p>This    is a test</p>\";\n        String expected = \"<p>This is a test</p>\";\n        assertEquals(expected, compressHTML(input));\n    }\n\n    @Test\n    public void testHandleEmptyStrings() {\n        String input = \"\";\n        String expected = \"\";\n        assertEquals(expected, compressHTML(input));\n    }\n\n    @Test\n    public void testProcessComplexNestedHTMLCorrectly() {\n        String input = \"<div>   <span>    Text <i>    Italic </i> more text </span>   </div>\";\n        String expected = \"<div><span>Text <i>Italic</i> more text</span></div>\";\n        assertEquals(expected, compressHTML(input));\n    }\n\n    @Test\n    public void testDoNotDisruptContentWithinPreAndTextareaTags() {\n        String input = \"<pre>\\n    function example() {\\n        console.log(\\\"example\\\");\\n    }\\n</pre>\";\n        String expected = \"<pre>\\n    function example() {\\n        console.log(\\\"example\\\");\\n    }\\n</pre>\"; // assuming no changes in <pre> and <textarea>\n        assertEquals(expected, compressHTML(input));\n    }\n\n    @Test\n    public void testHandleHTMLWithAttributesCorrectly() {\n        String input = \"<a href=\\\"http://example.com\\\"    title=\\\"Example\\\" >Link</a>\";\n        String expected = \"<a href=\\\"http://example.com\\\" title=\\\"Example\\\">Link</a>\";\n        assertEquals(expected, compressHTML(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <div>, <script>, and <style> tags.\n * For example:\n *      input: '   <div>   Content  </div>   '\n *      output: '<div> Content </div>'\n *\n * @param htmlString The HTML content to compress.\n * @return The compressed HTML content.\n */\npublic static String compressHTML(String htmlString) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 127, "code_type": "method", "original_language": "javascript", "file_path": "Using-Konduktiva-With-MIDI\\dbb39f39670ffae329b1cce77ed641f9ef758710\\chords.js", "question_type": "Data processing and transformation", "summary": "Splits a list of MIDI note numbers into separate arrays of octaves and root notes.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef separate_octave_and_root(midi_notes: List[int])->dict:\n    \"\"\"\n    Splits a list of MIDI note numbers into separate lists of octaves and root notes.\n\n    Args:\n        midi_notes (List[int]): A list of MIDI note numbers.\n\n    Returns:\n        dict: A dictionary containing lists of octaves and root notes.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSeparateOctaveAndRoot(unittest.TestCase):\n\n    def test_correctly_separates_midi_notes(self):\n        midi_notes = [60, 61, 62]  # C4, C#4, D4\n        expected = {\n            'octaveNotes': [5, 5, 5],  # All notes are in the 5th octave\n            'rootNotes': [0, 1, 2]     # Root notes are C, C#, D\n        }\n        self.assertEqual(separate_octave_and_root(midi_notes), expected)\n\n    def test_handles_single_midi_note_input(self):\n        midi_notes = [24]  # C1\n        expected = {\n            'octaveNotes': [2],  # 2nd octave\n            'rootNotes': [0]     # C note\n        }\n        self.assertEqual(separate_octave_and_root(midi_notes), expected)\n\n    def test_returns_empty_arrays_for_empty_input_array(self):\n        midi_notes = []\n        expected = {\n            'octaveNotes': [],\n            'rootNotes': []\n        }\n        self.assertEqual(separate_octave_and_root(midi_notes), expected)\n\n    def test_throws_error_for_invalid_input_types(self):\n        invalid_inputs = [\"not an array\", [3.14]]\n        for invalid_input in invalid_inputs:\n            with self.assertRaises(TypeError):\n                separate_octave_and_root(invalid_input)\n\n    def test_handles_midi_notes_from_different_octaves(self):\n        midi_notes = [12, 25, 37]  # C1, C#2, D#3\n        expected = {\n            'octaveNotes': [1, 2, 3],  # 1st, 2nd, and 3rd octaves\n            'rootNotes': [0, 1, 1]     # Root notes are C, C#, D#\n        }\n        self.assertEqual(separate_octave_and_root(midi_notes), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef separate_octave_and_root(midi_notes: List[int])->dict:\n    \"\"\"\n    Splits a list of MIDI note numbers into separate lists of octaves and root notes.\n\n    Args:\n        midi_notes (List[int]): A list of MIDI note numbers.\n\n    Returns:\n        dict: A dictionary containing lists of octaves and root notes.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 129, "code_type": "method", "original_language": "javascript", "file_path": "ruffle\\6a94ec42bd9ad89ab68e1e57b94e8e3b125a81a4\\js\\tab.js", "question_type": "User interface", "summary": "Validates a URL string using a simplified and more comprehensive regular expression.", "language_version_list": {"python": {"code_signature": "def is_valid_url(url: str) -> bool:\n    \"\"\"\n    Validates a URL string using a simplified and comprehensive regular expression.\n\n    Args:\n        url (str): The URL string to validate.\n\n    Returns:\n        bool: True if the URL is valid, False otherwise.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestValidURL(unittest.TestCase):\n\n    def test_validates_standard_http_url(self):\n        url = 'http://www.example.com'\n        self.assertTrue(is_valid_url(url))\n\n    def test_validates_secure_https_url(self):\n        url = 'https://www.example.com'\n        self.assertTrue(is_valid_url(url))\n\n    def test_rejects_malformed_url(self):\n        url = 'htp:/www.example.com'\n        self.assertFalse(is_valid_url(url))\n", "prompt": "please write a python function , the function signature as below def is_valid_url(url: str) -> bool:\n    \"\"\"\n    Validates a URL string using a simplified and comprehensive regular expression.\n\n    Args:\n        url (str): The URL string to validate.\n\n    Returns:\n        bool: True if the URL is valid, False otherwise.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param str - The URL string to validate.\n * @returns True if the URL is valid, false otherwise.\n */\nbool validURL(const std::string& str) {\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\n// Assuming the validURL function is defined somewhere\nbool validURL(const std::string& str);\n\nTEST_CASE(\"validURL\", \"[url]\") {\n    SECTION(\"validates a standard HTTP URL\") {\n        std::string url = \"http://www.example.com\";\n        REQUIRE(validURL(url) == true);\n    }\n\n    SECTION(\"validates a secure HTTPS URL\") {\n        std::string url = \"https://www.example.com\";\n        REQUIRE(validURL(url) == true);\n    }\n\n    SECTION(\"rejects a malformed URL\") {\n        std::string url = \"htp:/www.example.com\";\n        REQUIRE(validURL(url) == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param str - The URL string to validate.\n * @returns True if the URL is valid, false otherwise.\n */\nbool validURL(const std::string& str) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param str The URL string to validate.\n * @return True if the URL is valid, false otherwise.\n */\npublic static boolean validURL(String str) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void validatesAStandardHttpUrl() {\n        String url = \"http://www.example.com\";\n        assertTrue(validURL(url));\n    }\n\n    @Test\n    public void validatesASecureHttpsUrl() {\n        String url = \"https://www.example.com\";\n        assertTrue(validURL(url));\n    }\n\n    @Test\n    public void rejectsAMalformedUrl() {\n        String url = \"htp:/www.example.com\";\n        assertFalse(validURL(url));\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param str The URL string to validate.\n * @return True if the URL is valid, false otherwise.\n */\npublic static boolean validURL(String str) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 130, "code_type": "method", "original_language": "javascript", "file_path": "nodejs-worker-threads-talk\\4111c47ff0b976a0e451441f5dcfb085ae7686f6\\07-pi-with-atomics\\compute-pi.js", "question_type": "Data processing and transformation", "summary": "Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library decimal.js", "language_version_list": {"python": {"code_signature": "def compute_pi(digits: int) -> str:\n    \"\"\"\n    Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library.\n\n    Args:\n        digits (int): The number of decimal digits to compute \u03c0 to.\n\n    Returns:\n        str: The value of \u03c0 to the specified number of digits.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestComputePi(unittest.TestCase):\n\n    def test_calculate_pi_5_decimal_places(self):\n        digits = 5\n        expected = '3.14159'\n        result = compute_pi(digits)\n        self.assertEqual(result, expected)\n\n    def test_calculate_pi_10_decimal_places(self):\n        digits = 10\n        expected = '3.1415926536'\n        result = compute_pi(digits)\n        self.assertEqual(result, expected)\n\n    def test_calculate_pi_15_decimal_places(self):\n        digits = 15\n        expected = '3.141592653589793'\n        result = compute_pi(digits)\n        self.assertEqual(result, expected)\n\n    def test_calculate_pi_20_decimal_places(self):\n        digits = 20\n        expected = '3.14159265358979323846'\n        result = compute_pi(digits)\n        self.assertEqual(result, expected)\n\n    def test_calculate_pi_30_decimal_places(self):\n        digits = 30\n        expected = '3.141592653589793238462643383280'\n        result = compute_pi(digits)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def compute_pi(digits: int) -> str:\n    \"\"\"\n    Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library.\n\n    Args:\n        digits (int): The number of decimal digits to compute \u03c0 to.\n\n    Returns:\n        str: The value of \u03c0 to the specified number of digits.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library\n *\n * @param digits - The number of decimal digits to compute \u03c0 to.\n * @returns - The value of \u03c0 to the specified number of digits as a string.\n */\nstd::string computePi(int digits) {\n    // Implementation goes here\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\n// Assuming computePi is defined elsewhere\nstd::string computePi(int digits);\n\nTEST_CASE(\"computePi\", \"[pi]\") {\n    SECTION(\"should calculate pi to 5 decimal places correctly\") {\n        int digits = 5;\n        std::string expected = \"3.14159\";\n        std::string result = computePi(digits);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"should calculate pi to 10 decimal places correctly\") {\n        int digits = 10;\n        std::string expected = \"3.1415926536\";\n        std::string result = computePi(digits);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"should calculate pi to 15 decimal places correctly\") {\n        int digits = 15;\n        std::string expected = \"3.141592653589793\";\n        std::string result = computePi(digits);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"should calculate pi to 20 decimal places correctly\") {\n        int digits = 20;\n        std::string expected = \"3.14159265358979323846\";\n        std::string result = computePi(digits);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"should calculate pi to 30 decimal places correctly\") {\n        int digits = 30;\n        std::string expected = \"3.141592653589793238462643383280\";\n        std::string result = computePi(digits);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library\n *\n * @param digits - The number of decimal digits to compute \u03c0 to.\n * @returns - The value of \u03c0 to the specified number of digits as a string.\n */\nstd::string computePi(int digits) {\n    // Implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic.\n *\n * @param digits - The number of decimal digits to compute \u03c0 to.\n * @return - The value of \u03c0 to the specified number of digits.\n */\npublic static String computePi(int digits) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testComputePiTo5DecimalPlaces() {\n        int digits = 5;\n        String expected = \"3.14159\";\n        String result = computePi(digits);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testComputePiTo10DecimalPlaces() {\n        int digits = 10;\n        String expected = \"3.1415926536\";\n        String result = computePi(digits);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testComputePiTo15DecimalPlaces() {\n        int digits = 15;\n        String expected = \"3.141592653589793\";\n        String result = computePi(digits);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testComputePiTo20DecimalPlaces() {\n        int digits = 20;\n        String expected = \"3.14159265358979323846\";\n        String result = computePi(digits);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testComputePiTo30DecimalPlaces() {\n        int digits = 30;\n        String expected = \"3.141592653589793238462643383280\";\n        String result = computePi(digits);\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic.\n *\n * @param digits - The number of decimal digits to compute \u03c0 to.\n * @return - The value of \u03c0 to the specified number of digits.\n */\npublic static String computePi(int digits) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 131, "code_type": "method", "original_language": "javascript", "file_path": "edge-extension-examples\\f947cd27891885bc2c8462f56ecbae793f41deb6\\sharepoint-extension\\content.js", "question_type": "User interface", "summary": "Add a CSS rule to the HTML document to highlight search results", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 132, "code_type": "method", "original_language": "javascript", "file_path": "edge-extension-examples\\f947cd27891885bc2c8462f56ecbae793f41deb6\\sharepoint-extension\\content.js", "question_type": "Configuration and deployment", "summary": "Use ESM syntax to import the file system module and define the file read and write operation functions", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 133, "code_type": "method", "original_language": "javascript", "file_path": "Python-Syslog-Server\\eda56760300b5b3f6e17618dd4c0de30f60fed40\\frontend\\app\\api\\validators.js", "question_type": "Data processing and transformation", "summary": "Verify that the input string is a significant number between 5 and 18 in length\n", "language_version_list": {"python": {"code_signature": "def is_significant_number(input_value: str) -> bool:\n    \"\"\"\n    Check if the given input is a significant number.\n\n    A significant number is defined as a string that:\n    - Has a length between 5 and 18 characters (inclusive).\n    - Contains only digit characters.\n    - Cannot start with '0' if its length is greater than 1.\n    Args:\n        input_value (str): The input value to be checked.\n\n    Returns:\n        bool: True if the input is a significant number, False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestIsSignificantNumber(unittest.TestCase):\n\n    def test_valid_significant_number_with_exactly_5_digits(self):\n        self.assertTrue(is_significant_number(\"12345\"))\n\n    def test_number_with_leading_zero(self):\n        self.assertFalse(is_significant_number(\"01234\"))\n\n    def test_valid_significant_number_with_exactly_18_digits(self):\n        self.assertTrue(is_significant_number(\"123456789012345678\"))\n\n    def test_number_with_less_than_5_digits(self):\n        self.assertFalse(is_significant_number(\"123\"))\n\n    def test_number_with_more_than_18_digits(self):\n        self.assertFalse(is_significant_number(\"1234567890123456789\"))\n\n    def test_number_containing_non_digit_characters(self):\n        self.assertFalse(is_significant_number(\"1234a\"))\n\n    def test_single_zero(self):\n        self.assertFalse(is_significant_number(\"0\"))\n\n    def test_non_string_input(self):\n        self.assertFalse(is_significant_number(12345))\n", "prompt": "please write a python function , the function signature as below def is_significant_number(input_value: str) -> bool:\n    \"\"\"\n    Check if the given input is a significant number.\n\n    A significant number is defined as a string that:\n    - Has a length between 5 and 18 characters (inclusive).\n    - Contains only digit characters.\n    - Cannot start with '0' if its length is greater than 1.\n    Args:\n        input_value (str): The input value to be checked.\n\n    Returns:\n        bool: True if the input is a significant number, False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Checks if the input string is a significant number.\n * A significant number is defined as a string that:\n * - Is between 5 and 18 characters in length.\n * - Consists only of digits (0-9).\n * - Does not start with '0' if its length is greater than 1.\n *\n * @param input - The input string to check.\n * @returns true if the input is a significant number; otherwise, false.\n */\nbool isSignificantNumber(const std::string& input){}", "test_code": "TEST_CASE(\"isSignificantNumber\") {\n    SECTION(\"should return true for a valid significant number with exactly 5 digits\") {\n        REQUIRE(isSignificantNumber(\"12345\") == true);\n    }\n\n    SECTION(\"should return false for a number with leading zero\") {\n        REQUIRE(isSignificantNumber(\"01234\") == false);\n    }\n\n    SECTION(\"should return true for a valid significant number with exactly 18 digits\") {\n        REQUIRE(isSignificantNumber(\"123456789012345678\") == true);\n    }\n\n    SECTION(\"should return false for a number with less than 5 digits\") {\n        REQUIRE(isSignificantNumber(\"123\") == false);\n    }\n\n    SECTION(\"should return false for a number with more than 18 digits\") {\n        REQUIRE(isSignificantNumber(\"1234567890123456789\") == false);\n    }\n\n    SECTION(\"should return false for a number containing non-digit characters\") {\n        REQUIRE(isSignificantNumber(\"1234a\") == false);\n    }\n\n    SECTION(\"should return false for a single zero\") {\n        REQUIRE(isSignificantNumber(\"0\") == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Checks if the input string is a significant number.\n * A significant number is defined as a string that:\n * - Is between 5 and 18 characters in length.\n * - Consists only of digits (0-9).\n * - Does not start with '0' if its length is greater than 1.\n *\n * @param input - The input string to check.\n * @returns true if the input is a significant number; otherwise, false.\n */\nbool isSignificantNumber(const std::string& input){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks if the input string is a significant number.\n * A significant number is defined as a string that:\n * - Is between 5 and 18 characters in length.\n * - Consists only of digits (0-9).\n * - Does not start with '0' if its length is greater than 1.\n *\n * @param input The input string to check.\n * @return Returns true if the input is a significant number; otherwise, false.\n */\npublic static boolean isSignificantNumber(String input) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testValidSignificantNumberWithFiveDigits() {\n        assertTrue(isSignificantNumber(\"12345\"));\n    }\n\n    @Test\n    public void testLeadingZero() {\n        assertFalse(isSignificantNumber(\"01234\"));\n    }\n\n    @Test\n    public void testValidSignificantNumberWithEighteenDigits() {\n        assertTrue(isSignificantNumber(\"123456789012345678\"));\n    }\n\n    @Test\n    public void testLessThanFiveDigits() {\n        assertFalse(isSignificantNumber(\"123\"));\n    }\n\n    @Test\n    public void testMoreThanEighteenDigits() {\n        assertFalse(isSignificantNumber(\"1234567890123456789\"));\n    }\n\n    @Test\n    public void testNonDigitCharacters() {\n        assertFalse(isSignificantNumber(\"1234a\"));\n    }\n\n    @Test\n    public void testSingleZero() {\n        assertFalse(isSignificantNumber(\"0\"));\n    }\n\n    @Test\n    public void testNonStringInput() {\n        assertFalse(isSignificantNumber(String.valueOf(12345)));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks if the input string is a significant number.\n * A significant number is defined as a string that:\n * - Is between 5 and 18 characters in length.\n * - Consists only of digits (0-9).\n * - Does not start with '0' if its length is greater than 1.\n *\n * @param input The input string to check.\n * @return Returns true if the input is a significant number; otherwise, false.\n */\npublic static boolean isSignificantNumber(String input) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 134, "code_type": "method", "original_language": "javascript", "file_path": "Python-Syslog-Server\\eda56760300b5b3f6e17618dd4c0de30f60fed40\\frontend\\app\\api\\validators.js", "question_type": "Data processing and transformation", "summary": "Checks whether the username is a string of length 5 to 16 that contains only alphanumeric Spaces", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef is_valid_username(username: str) -> bool:\n    \"\"\"\n    Checks whether the provided username is valid.\n    A valid username is defined as a string that:\n    - Has a length between 5 and 16 characters (inclusive).\n    - Contains only alphanumeric characters (letters and digits) and spaces.\n\n    Args:\n        username (str): The username to validate.\n\n    Returns:\n        bool: Returns True if the username is valid; otherwise, False.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestIsValidUsername(unittest.TestCase):\n\n    def test_valid_username_with_alphanumeric_characters(self):\n        self.assertTrue(is_valid_username('User123'))\n\n    def test_valid_username_with_spaces(self):\n        self.assertTrue(is_valid_username('User 123'))\n\n    def test_invalid_username_that_is_too_short(self):\n        self.assertFalse(is_valid_username('User'))\n\n    def test_invalid_username_that_is_too_long(self):\n        self.assertFalse(is_valid_username('ThisIsAVeryLongUsername'))\n\n    def test_invalid_username_with_special_characters(self):\n        self.assertFalse(is_valid_username('User!'))\n\n    def test_invalid_username_with_only_spaces(self):\n        self.assertFalse(is_valid_username('     '))\n\n    def test_invalid_input_type_number(self):\n        self.assertFalse(is_valid_username(12345))", "prompt": "please write a python function , the function signature as below import re\n\n\ndef is_valid_username(username: str) -> bool:\n    \"\"\"\n    Checks whether the provided username is valid.\n    A valid username is defined as a string that:\n    - Has a length between 5 and 16 characters (inclusive).\n    - Contains only alphanumeric characters (letters and digits) and spaces.\n\n    Args:\n        username (str): The username to validate.\n\n    Returns:\n        bool: Returns True if the username is valid; otherwise, False.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Checks whether the provided username is valid.\n * A valid username is defined as a string that:\n * - Has a length between 5 and 16 characters (inclusive).\n * - Contains only alphanumeric characters (letters and digits) and spaces.\n *\n * @param username - The username to validate.\n * @returns true if the username is valid; otherwise, false.\n */\nbool isValidUsername(const std::string& username){}", "test_code": "TEST_CASE(\"isValidUsername\") {\n    SECTION(\"valid username with alphanumeric characters\") {\n        REQUIRE(isValidUsername(\"User123\") == true);\n    }\n\n    SECTION(\"valid username with spaces\") {\n        REQUIRE(isValidUsername(\"User 123\") == true);\n    }\n\n    SECTION(\"invalid username that is too short\") {\n        REQUIRE(isValidUsername(\"User\") == false);\n    }\n\n    SECTION(\"invalid username that is too long\") {\n        REQUIRE(isValidUsername(\"ThisIsAVeryLongUsername\") == false);\n    }\n\n    SECTION(\"invalid username with special characters\") {\n        REQUIRE(isValidUsername(\"User!\") == false);\n    }\n\n    SECTION(\"invalid username with only spaces\") {\n        REQUIRE(isValidUsername(\"     \") == false);\n    }\n\n    SECTION(\"invalid input type (number)\") {\n        // C++ does not allow passing an int to a string parameter directly.\n        // Assuming isValidUsername has a proper overload or handles this internally.\n        REQUIRE(isValidUsername(std::to_string(12345)) == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Checks whether the provided username is valid.\n * A valid username is defined as a string that:\n * - Has a length between 5 and 16 characters (inclusive).\n * - Contains only alphanumeric characters (letters and digits) and spaces.\n *\n * @param username - The username to validate.\n * @returns true if the username is valid; otherwise, false.\n */\nbool isValidUsername(const std::string& username){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks whether the provided username is valid.\n * A valid username is defined as a string that:\n * - Has a length between 5 and 16 characters (inclusive).\n * - Contains only alphanumeric characters (letters and digits) and spaces.\n *\n * @param username - The username to validate.\n * @return Returns true if the username is valid; otherwise, false.\n */\npublic static boolean isValidUsername(String username) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void validUsernameWithAlphanumericCharacters() {\n        assertTrue(isValidUsername(\"User123\"));\n    }\n\n    @Test\n    public void validUsernameWithSpaces() {\n        assertTrue(isValidUsername(\"User 123\"));\n    }\n\n    @Test\n    public void invalidUsernameThatIsTooShort() {\n        assertFalse(isValidUsername(\"User\"));\n    }\n\n    @Test\n    public void invalidUsernameThatIsTooLong() {\n        assertFalse(isValidUsername(\"ThisIsAVeryLongUsername\"));\n    }\n\n    @Test\n    public void invalidUsernameWithSpecialCharacters() {\n        assertFalse(isValidUsername(\"User!\"));\n    }\n\n    @Test\n    public void invalidUsernameWithOnlySpaces() {\n        assertFalse(isValidUsername(\"     \"));\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks whether the provided username is valid.\n * A valid username is defined as a string that:\n * - Has a length between 5 and 16 characters (inclusive).\n * - Contains only alphanumeric characters (letters and digits) and spaces.\n *\n * @param username - The username to validate.\n * @return Returns true if the username is valid; otherwise, false.\n */\npublic static boolean isValidUsername(String username) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 135, "code_type": "method", "original_language": "javascript", "file_path": "Python-Syslog-Server\\eda56760300b5b3f6e17618dd4c0de30f60fed40\\frontend\\app\\api\\validators.js", "question_type": "Data processing and transformation", "summary": "Verify that the port number is within a valid range\n", "language_version_list": {"python": {"code_signature": "def is_valid_port_number(port: int) -> bool:\n    \"\"\"Checks if the provided port number is within the valid range of TCP/UDP ports.\n    \n    Valid TCP/UDP port numbers range from 1 to 65535.\n\n    Args:\n        port (int): The port number to verify.\n\n    Returns:\n        bool: Returns True if the port number is valid, False otherwise.\n\n    Raises:\n        TypeError: If the port number is not an integer.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsValidPortNumber(unittest.TestCase):\n\n    def test_valid_port_number_middle(self):\n        \"\"\"Returns true for a valid port number in the middle of the range.\"\"\"\n        self.assertTrue(is_valid_port_number(8080))\n\n    def test_lowest_valid_port_number(self):\n        \"\"\"Returns true for the lowest valid port number.\"\"\"\n        self.assertTrue(is_valid_port_number(1))\n\n    def test_highest_valid_port_number(self):\n        \"\"\"Returns true for the highest valid port number.\"\"\"\n        self.assertTrue(is_valid_port_number(65535))\n\n    def test_below_valid_range(self):\n        \"\"\"Returns false for a port number below the valid range.\"\"\"\n        self.assertFalse(is_valid_port_number(0))\n\n    def test_above_valid_range(self):\n        \"\"\"Returns false for a port number above the valid range.\"\"\"\n        self.assertFalse(is_valid_port_number(65536))\n", "prompt": "please write a python function , the function signature as below def is_valid_port_number(port: int) -> bool:\n    \"\"\"Checks if the provided port number is within the valid range of TCP/UDP ports.\n    \n    Valid TCP/UDP port numbers range from 1 to 65535.\n\n    Args:\n        port (int): The port number to verify.\n\n    Returns:\n        bool: Returns True if the port number is valid, False otherwise.\n\n    Raises:\n        TypeError: If the port number is not an integer.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param port - The port number to verify.\n * @returns true if the port number is valid, false otherwise.\n */\nbool isValidPortNumber(int port){}", "test_code": "TEST_CASE(\"isValidPortNumber\") {\n    SECTION(\"returns true for a valid port number in the middle of the range\") {\n        REQUIRE(isValidPortNumber(8080) == true);\n    }\n\n    SECTION(\"returns true for the lowest valid port number\") {\n        REQUIRE(isValidPortNumber(1) == true);\n    }\n\n    SECTION(\"returns true for the highest valid port number\") {\n        REQUIRE(isValidPortNumber(65535) == true);\n    }\n\n    SECTION(\"returns false for a port number below the valid range\") {\n        REQUIRE_THROWS_AS(isValidPortNumber(0), std::invalid_argument);\n    }\n\n    SECTION(\"returns false for a port number above the valid range\") {\n        REQUIRE_THROWS_AS(isValidPortNumber(65536), std::invalid_argument);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param port - The port number to verify.\n * @returns true if the port number is valid, false otherwise.\n */\nbool isValidPortNumber(int port){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param port The port number to verify.\n * @return Returns true if the port number is valid, false otherwise.\n */\npublic static boolean isValidPortNumber(int port) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void testValidPortNumber_MiddleOfRange() {\n        assertTrue(isValidPortNumber(8080));\n    }\n\n    @Test\n    public void testValidPortNumber_Lowest() {\n        assertTrue(isValidPortNumber(1));\n    }\n\n    @Test\n    public void testValidPortNumber_Highest() {\n        assertTrue(isValidPortNumber(65535));\n    }\n\n    @Test\n    public void testValidPortNumber_BelowRange() {\n        assertFalse(isValidPortNumber(0));\n    }\n\n    @Test\n    public void testValidPortNumber_AboveRange() {\n        assertFalse(isValidPortNumber(65536));\n    }\n\n    // The method to be tested\n    public static boolean isValidPortNumber(int port) {\n        return port >= 1 && port <= 65535;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param port The port number to verify.\n * @return Returns true if the port number is valid, false otherwise.\n */\npublic static boolean isValidPortNumber(int port) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 137, "code_type": "method", "original_language": "javascript", "file_path": "PolyPlus\\948c9b8fae1bdf899900825f2f2a125b9265932b\\settings.js", "question_type": "User interface", "summary": "Merges two objects into one object\n", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 138, "code_type": "method", "original_language": "javascript", "file_path": "ducky-poc\\f8f45ca20066958baaebb27f89bf79c0d8b20161\\chrome-ext\\chrome-extension\\content-old.js", "question_type": "Data processing and transformation", "summary": "removes all punctuation from a given string, converts the string to lowercase,\nand trims whitespace from both ends. ", "language_version_list": {"python": {"code_signature": "def remove_punctuation(s: str) -> str:\n    \"\"\"\n    Removes all punctuation from a given string, converts the string to lowercase,\n    and trims whitespace from both ends.\n\n    Args:\n        s (str): The string from which to remove punctuation.\n\n    Returns:\n        str: The cleaned and formatted string.\n    \"\"\"", "test_code": "import unittest\nimport re\n\nclass TestRemovePunctuation(unittest.TestCase):\n\n    def test_removes_punctuation_from_simple_sentence(self):\n        input_string = \"Hello, world!\"\n        expected = \"hello world\"\n        self.assertEqual(remove_punctuation(input_string), expected)\n\n    def test_handles_string_with_no_punctuation(self):\n        input_string = \"Hello world\"\n        expected = \"hello world\"\n        self.assertEqual(remove_punctuation(input_string), expected)\n\n    def test_converts_mixed_case_letters_to_lowercase(self):\n        input_string = \"HeLLo WoRLd!\"\n        expected = \"hello world\"\n        self.assertEqual(remove_punctuation(input_string), expected)\n\n    def test_removes_a_variety_of_punctuation(self):\n        input_string = \"Life, in a nutshell: eat, sleep, code!\"\n        expected = \"life in a nutshell eat sleep code\"\n        self.assertEqual(remove_punctuation(input_string), expected)\n\n    def test_trims_whitespace_from_ends(self):\n        input_string = \"   What a wonderful world!   \"\n        expected = \"what a wonderful world\"\n        self.assertEqual(remove_punctuation(input_string), expected)", "prompt": "please write a python function , the function signature as below def remove_punctuation(s: str) -> str:\n    \"\"\"\n    Removes all punctuation from a given string, converts the string to lowercase,\n    and trims whitespace from both ends.\n\n    Args:\n        s (str): The string from which to remove punctuation.\n\n    Returns:\n        str: The cleaned and formatted string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param str The string from which to remove punctuation.\n * @returns The cleaned and formatted string.\n */\nstd::string removePunctuation(const std::string& str) {}", "test_code": "TEST_CASE(\"removePunctuation\", \"[string]\") {\n    SECTION(\"removes punctuation from a simple sentence\") {\n        std::string input = \"Hello, world!\";\n        std::string expected = \"hello world\";\n        REQUIRE(removePunctuation(input) == expected);\n    }\n\n    SECTION(\"handles a string with no punctuation\") {\n        std::string input = \"Hello world\";\n        std::string expected = \"hello world\";\n        REQUIRE(removePunctuation(input) == expected);\n    }\n\n    SECTION(\"converts mixed case letters to lowercase\") {\n        std::string input = \"HeLLo WoRLd!\";\n        std::string expected = \"hello world\";\n        REQUIRE(removePunctuation(input) == expected);\n    }\n\n    SECTION(\"removes a variety of punctuation\") {\n        std::string input = \"Life, in a nutshell: eat, sleep, code!\";\n        std::string expected = \"life in a nutshell eat sleep code\";\n        REQUIRE(removePunctuation(input) == expected);\n    }\n\n    SECTION(\"trims whitespace from the ends of the string\") {\n        std::string input = \"   What a wonderful world!   \";\n        std::string expected = \"what a wonderful world\";\n        REQUIRE(removePunctuation(input) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param str The string from which to remove punctuation.\n * @returns The cleaned and formatted string.\n */\nstd::string removePunctuation(const std::string& str) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param str The string from which to remove punctuation.\n * @return The cleaned and formatted string.\n */\npublic static String removePunctuation(String str) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testRemovesPunctuationFromSimpleSentence() {\n        String input = \"Hello, world!\";\n        String expected = \"hello world\";\n        assertEquals(expected, removePunctuation(input));\n    }\n\n    @Test\n    public void testHandlesStringWithNoPunctuation() {\n        String input = \"Hello world\";\n        String expected = \"hello world\";\n        assertEquals(expected, removePunctuation(input));\n    }\n\n    @Test\n    public void testConvertsMixedCaseLettersToLowercase() {\n        String input = \"HeLLo WoRLd!\";\n        String expected = \"hello world\";\n        assertEquals(expected, removePunctuation(input));\n    }\n\n    @Test\n    public void testRemovesVarietyOfPunctuation() {\n        String input = \"Life, in a nutshell: eat, sleep, code!\";\n        String expected = \"life in a nutshell eat sleep code\";\n        assertEquals(expected, removePunctuation(input));\n    }\n\n    @Test\n    public void testTrimsWhitespaceFromEndsOfString() {\n        String input = \"   What a wonderful world!   \";\n        String expected = \"what a wonderful world\";\n        assertEquals(expected, removePunctuation(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param str The string from which to remove punctuation.\n * @return The cleaned and formatted string.\n */\npublic static String removePunctuation(String str) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 139, "code_type": "method", "original_language": "javascript", "file_path": "ai-news-scraper\\009b1eb29af2639aa6c9ef5e0e1df224ce3c9580\\utils\\parseCategoriesFromSummary.js", "question_type": "Data processing and transformation", "summary": "Extract Categories from the summary string, the first complete sentence", "language_version_list": {"python": {"code_signature": "def parse_categories_from_summary(summarized_output: str = '') -> dict:\n    \"\"\"\n    Extracts categories from a summarized output string and returns the cleaned summary and categories.\n\n    The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n\n    Args:\n        summarized_output (str): The summary text potentially containing categorized question.\n\n    Returns:\n        dict: A dictionary containing the cleaned summary text and a list of categories.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestParseCategoriesFromSummary(unittest.TestCase):\n    def test_extracts_categories_and_cleans_the_summary_correctly(self):\n        input_data = \"This is a summary. Categories: [Technology, Health]\"\n        expected = {\n            'summary': \"This is a summary.\",\n            'categories': [\"Technology\", \"Health\"]\n        }\n        self.assertEqual(parse_categories_from_summary(input_data), expected)\n\n    def test_returns_empty_categories_and_original_summary_when_no_categories_are_present(self):\n        input_data = \"This is a summary without categories.\"\n        expected = {\n            'summary': \"This is a summary without categories.\",\n            'categories': []\n        }\n        self.assertEqual(parse_categories_from_summary(input_data), expected)\n\n    def test_ignores_case_of_the_category_prefix(self):\n        input_data = \"Summary text. categories: [Education, Science]\"\n        expected = {\n            'summary': \"Summary text.\",\n            'categories': [\"Education\", \"Science\"]\n        }\n        self.assertEqual(parse_categories_from_summary(input_data), expected)\n\n    def test_handles_extra_spaces_and_malformed_category_strings_correctly(self):\n        input_data = \"Details follow. Categories: [ Business ,  , Finance]\"\n        expected = {\n            'summary': \"Details follow.\",\n            'categories': [\"Business\", \"Finance\"]\n        }\n        self.assertEqual(parse_categories_from_summary(input_data), expected)\n\n    def test_removes_the_category_string_correctly_even_if_it_appears_in_the_middle_of_the_summary(self):\n        input_data = \"Beginning of summary. Categories: [Art, Design] Continuation of summary.\"\n        expected = {\n            'summary': \"Beginning of summary. Continuation of summary.\",\n            'categories': [\"Art\", \"Design\"]\n        }\n        self.assertEqual(parse_categories_from_summary(input_data), expected)", "prompt": "please write a python function , the function signature as below def parse_categories_from_summary(summarized_output: str = '') -> dict:\n    \"\"\"\n    Extracts categories from a summarized output string and returns the cleaned summary and categories.\n\n    The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n\n    Args:\n        summarized_output (str): The summary text potentially containing categorized question.\n\n    Returns:\n        dict: A dictionary containing the cleaned summary text and a list of categories.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param summarizedOutput - The summary text potentially containing categorized question.\n * @returns A SummaryResult struct containing the cleaned summary text and a vector of categories.\n */\nSummaryResult parseCategoriesFromSummary(const std::string& summarizedOutput){}", "test_code": "TEST_CASE(\"parseCategoriesFromSummary\") {\n    SECTION(\"extracts categories and cleans the summary correctly\") {\n        std::string input = \"This is a summary. Categories: [Technology, Health]\";\n        SummaryResult expected = {\"This is a summary.\", {\"Technology\", \"Health\"}};\n        REQUIRE(parseCategoriesFromSummary(input) == expected);\n    }\n\n    SECTION(\"returns empty categories and original summary when no categories are present\") {\n        std::string input = \"This is a summary without categories.\";\n        SummaryResult expected = {\"This is a summary without categories.\", {}};\n        REQUIRE(parseCategoriesFromSummary(input) == expected);\n    }\n\n    SECTION(\"ignores case of the category prefix\") {\n        std::string input = \"Summary text. categories: [Education, Science]\";\n        SummaryResult expected = {\"Summary text.\", {\"Education\", \"Science\"}};\n        REQUIRE(parseCategoriesFromSummary(input) == expected);\n    }\n\n    SECTION(\"handles extra spaces and malformed category strings correctly\") {\n        std::string input = \"Details follow. Categories: [ Business ,  , Finance]\";\n        SummaryResult expected = {\"Details follow.\", {\"Business\", \"Finance\"}};\n        REQUIRE(parseCategoriesFromSummary(input) == expected);\n    }\n\n    SECTION(\"removes the category string correctly even if it appears in the middle of the summary\") {\n        std::string input = \"Beginning of summary. Categories: [Art, Design] Continuation of summary.\";\n        SummaryResult expected = {\"Beginning of summary. Continuation of summary.\", {\"Art\", \"Design\"}};\n        REQUIRE(parseCategoriesFromSummary(input) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param summarizedOutput - The summary text potentially containing categorized question.\n * @returns A SummaryResult struct containing the cleaned summary text and a vector of categories.\n */\nSummaryResult parseCategoriesFromSummary(const std::string& summarizedOutput){}", "addition_info": "struct SummaryResult {\n    std::string summary;\n    std::vector<std::string> categories;\n};"}, "java": {"code_signature": "/**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param summarizedOutput The summary text potentially containing categorized question.\n * @return A Result object containing the cleaned summary text and a list of categories.\n */\npublic static class Result {\n    public final String summary;\n    public final List<String> categories;\n\n    public Result(String summary, List<String> categories) {\n        this.summary = summary;\n        this.categories = categories;\n    }\n}\npublic static Result parseCategoriesFromSummary(String summarizedOutput) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testExtractsCategoriesAndCleansTheSummaryCorrectly() {\n        String input = \"This is a summary. Categories: [Technology, Health]\";\n        Result expected = new Result(\"This is a summary.\", Arrays.asList(\"Technology\", \"Health\"));\n        assertEquals(expected.summary, parseCategoriesFromSummary(input).summary);\n        assertEquals(expected.categories, parseCategoriesFromSummary(input).categories);\n    }\n\n    @Test\n    public void testReturnsEmptyCategoriesAndOriginalSummaryWhenNoCategoriesArePresent() {\n        String input = \"This is a summary without categories.\";\n        Result expected = new Result(\"This is a summary without categories.\", Arrays.asList());\n        assertEquals(expected.summary, parseCategoriesFromSummary(input).summary);\n        assertEquals(expected.categories, parseCategoriesFromSummary(input).categories);\n    }\n\n    @Test\n    public void testIgnoresCaseOfTheCategoryPrefix() {\n        String input = \"Summary text. categories: [Education, Science]\";\n        Result expected = new Result(\"Summary text.\", Arrays.asList(\"Education\", \"Science\"));\n        assertEquals(expected.summary, parseCategoriesFromSummary(input).summary);\n        assertEquals(expected.categories, parseCategoriesFromSummary(input).categories);\n    }\n\n    @Test\n    public void testHandlesExtraSpacesAndMalformedCategoryStringsCorrectly() {\n        String input = \"Details follow. Categories: [ Business ,  , Finance]\";\n        Result expected = new Result(\"Details follow.\", Arrays.asList(\"Business\", \"Finance\"));\n        assertEquals(expected.summary, parseCategoriesFromSummary(input).summary);\n        assertEquals(expected.categories, parseCategoriesFromSummary(input).categories);\n    }\n\n    @Test\n    public void testRemovesTheCategoryStringCorrectlyEvenIfItAppearsInTheMiddleOfTheSummary() {\n        String input = \"Beginning of summary. Categories: [Art, Design] Continuation of summary.\";\n        Result expected = new Result(\"Beginning of summary. Continuation of summary.\", Arrays.asList(\"Art\", \"Design\"));\n        assertEquals(expected.summary, parseCategoriesFromSummary(input).summary);\n        assertEquals(expected.categories, parseCategoriesFromSummary(input).categories);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param summarizedOutput The summary text potentially containing categorized question.\n * @return A Result object containing the cleaned summary text and a list of categories.\n */\npublic static class Result {\n    public final String summary;\n    public final List<String> categories;\n\n    public Result(String summary, List<String> categories) {\n        this.summary = summary;\n        this.categories = categories;\n    }\n}\npublic static Result parseCategoriesFromSummary(String summarizedOutput) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 292, "code_type": "method", "original_language": "javascript", "file_path": "mortgage-calculator\\d951b4501deb1597a631d56e73f4f8c11488cc4c\\logic.js", "question_type": "Algorithm and data structure", "summary": "Calculate the monthly payment on the loan", "language_version_list": {"python": {"code_signature": "def calculate_remaining_payment(principal: float, interest_rate: float, number_of_payments: int) -> float:\n    \"\"\"\n    Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n\n    Args:\n        principal (float): The initial amount of the debt.\n        interest_rate (float): The monthly interest rate as a decimal.\n        number_of_payments (int): The total number of payments.\n\n    Returns:\n        float: The calculated remaining payment.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestCalculateRemainingPayment(unittest.TestCase):\n\n    def test_typical_loan_conditions(self):\n        self.assertAlmostEqual(calculate_remaining_payment(10000, 0.005, 24), 0, places=2)\n\n    def test_high_interest_rate(self):\n        self.assertAlmostEqual(calculate_remaining_payment(10000, 0.1, 12), 0, places=2)\n\n    def test_low_interest_rate(self):\n        self.assertAlmostEqual(calculate_remaining_payment(10000, 0.001, 60), 0, places=2)\n\n    def test_very_short_term(self):\n        self.assertAlmostEqual(calculate_remaining_payment(10000, 0.005, 1), 0, places=2)\n\n    def test_no_payments(self):\n        self.assertAlmostEqual(calculate_remaining_payment(10000, 0.005, 0), 10000, places=2)\n\n    def test_long_term(self):\n        self.assertAlmostEqual(calculate_remaining_payment(10000, 0.005, 360), 0, places=2)\n", "prompt": "please write a python function , the function signature as below def calculate_remaining_payment(principal: float, interest_rate: float, number_of_payments: int) -> float:\n    \"\"\"\n    Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n\n    Args:\n        principal (float): The initial amount of the debt.\n        interest_rate (float): The monthly interest rate as a decimal.\n        number_of_payments (int): The total number of payments.\n\n    Returns:\n        float: The calculated remaining payment.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param principal - The initial amount of the debt.\n * @param interestRate - The monthly interest rate as a decimal.\n * @param numberOfPayments - The total number of payments.\n * @returns - The calculated remaining payment.\n */\ndouble calculateRemainingPayment(double principal, double interestRate, int numberOfPayments) {}", "test_code": "TEST_CASE(\"calculateRemainingPayment\") {\n    SECTION(\"calculates remaining balance for typical loan conditions\") {\n        REQUIRE(calculateRemainingPayment(10000, 0.005, 24) == Catch::Approx(0).margin(0.01));\n    }\n\n    SECTION(\"calculates remaining balance for high interest rate\") {\n        REQUIRE(calculateRemainingPayment(10000, 0.1, 12) == Catch::Approx(0).margin(0.01));\n    }\n\n    SECTION(\"calculates remaining balance for low interest rate\") {\n        REQUIRE(calculateRemainingPayment(10000, 0.001, 60) == Catch::Approx(0).margin(0.01));\n    }\n\n    SECTION(\"calculates remaining balance for very short term\") {\n        REQUIRE(calculateRemainingPayment(10000, 0.005, 1) == Catch::Approx(0).margin(0.01));\n    }\n\n    SECTION(\"calculates remaining balance with no payments\") {\n        REQUIRE(calculateRemainingPayment(10000, 0.005, 0) == Catch::Approx(10000).margin(0.01));\n    }\n\n    SECTION(\"calculates remaining balance for a long term\") {\n        REQUIRE(calculateRemainingPayment(10000, 0.005, 360) == Catch::Approx(0).margin(0.01));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param principal - The initial amount of the debt.\n * @param interestRate - The monthly interest rate as a decimal.\n * @param numberOfPayments - The total number of payments.\n * @returns - The calculated remaining payment.\n */\ndouble calculateRemainingPayment(double principal, double interestRate, int numberOfPayments) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param principal - The initial amount of the debt.\n * @param interestRate - The monthly interest rate as a decimal.\n * @param numberOfPayments - The total number of payments.\n * @return - The calculated remaining payment.\n */\npublic static double calculateRemainingPayment(double principal, double interestRate, int numberOfPayments) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testCalculateRemainingPaymentTypicalLoan() {\n        assertEquals(0, LoanCalculator.calculateRemainingPayment(10000, 0.005, 24), 0.01);\n    }\n\n    @Test\n    public void testCalculateRemainingPaymentHighInterest() {\n        assertEquals(0, LoanCalculator.calculateRemainingPayment(10000, 0.1, 12), 0.01);\n    }\n\n    @Test\n    public void testCalculateRemainingPaymentLowInterest() {\n        assertEquals(0, LoanCalculator.calculateRemainingPayment(10000, 0.001, 60), 0.01);\n    }\n\n    @Test\n    public void testCalculateRemainingPaymentVeryShortTerm() {\n        assertEquals(0, LoanCalculator.calculateRemainingPayment(10000, 0.005, 1), 0.01);\n    }\n\n    @Test\n    public void testCalculateRemainingPaymentNoPayments() {\n        assertEquals(10000, LoanCalculator.calculateRemainingPayment(10000, 0.005, 0), 0.01);\n    }\n\n    @Test\n    public void testCalculateRemainingPaymentLongTerm() {\n        assertEquals(0, LoanCalculator.calculateRemainingPayment(10000, 0.005, 360), 0.01);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param principal - The initial amount of the debt.\n * @param interestRate - The monthly interest rate as a decimal.\n * @param numberOfPayments - The total number of payments.\n * @return - The calculated remaining payment.\n */\npublic static double calculateRemainingPayment(double principal, double interestRate, int numberOfPayments) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 293, "code_type": "method", "original_language": "javascript", "file_path": "portfolio\\3bf98c1cd32d9a43d14f38f0222313220a491c47\\src\\app\\projects\\page.jsx", "question_type": "Algorithm and data structure", "summary": "Sort image names and ids based on their scores. Specifically, it accepts three arrays as input: an array of image cores, an array of image names, and an array of image ids. The function then combines these arrays, sorts the image data in ascending order based on imageScores, and returns the sorted array of scores, names, and ids.", "language_version_list": {"python": {"code_signature": "from typing import List, Union\n\n\ndef reorder_data(image_scores: List[float], image_names: List[str], image_ids: List[Union[str,float]]) -> dict:\n    \"\"\"\n    Reorders image questions based on scores in ascending order.\n\n    Args:\n        image_scores (list[float]): An array of numerical scores for the images.\n        image_names (list[str]): An array of image names corresponding to the scores.\n        image_ids (list[str | float]): An array of image IDs corresponding to the scores.\n\n    Returns:\n        dict: A dictionary containing the sorted scores, names, and IDs.\n            - resultScores (list[float]): A list of sorted numerical scores.\n            - resultNames (list[str]): A list of sorted image names.\n            - resultIDs (list[str | float]): A list of sorted image IDs.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestReorderData(unittest.TestCase):\n    \n    def test_sorts_question_correctly_for_basic_inputs(self):\n        scores = [3, 1, 2]\n        names = ['Image3', 'Image1', 'Image2']\n        ids = [103, 101, 102]\n        expected = {\n            'resultScores': [1, 2, 3],\n            'resultNames': ['Image1', 'Image2', 'Image3'],\n            'resultIDs': [101, 102, 103]\n        }\n        self.assertEqual(reorder_data(scores, names, ids), expected)\n\n    def test_sorts_question_correctly_with_mixed_scores(self):\n        scores = [5, 1, 3, 5, 2]\n        names = ['Image5', 'Image1', 'Image3', 'Image6', 'Image2']\n        ids = [105, 101, 103, 106, 102]\n        expected = {\n            'resultScores': [1, 2, 3, 5, 5],\n            'resultNames': ['Image1', 'Image2', 'Image3', 'Image5', 'Image6'],\n            'resultIDs': [101, 102, 103, 105, 106]\n        }\n        self.assertEqual(reorder_data(scores, names, ids), expected)\n\n    def test_handles_duplicate_scores(self):\n        scores = [2, 2, 1]\n        names = ['Image2', 'Image3', 'Image1']\n        ids = [102, 103, 101]\n        expected = {\n            'resultScores': [1, 2, 2],\n            'resultNames': ['Image1', 'Image2', 'Image3'],\n            'resultIDs': [101, 102, 103]\n        }\n        self.assertEqual(reorder_data(scores, names, ids), expected)\n\n    def test_handles_empty_arrays(self):\n        scores = []\n        names = []\n        ids = []\n        expected = {\n            'resultScores': [],\n            'resultNames': [],\n            'resultIDs': []\n        }\n        self.assertEqual(reorder_data(scores, names, ids), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List, Union\n\n\ndef reorder_data(image_scores: List[float], image_names: List[str], image_ids: List[Union[str,float]]) -> dict:\n    \"\"\"\n    Reorders image questions based on scores in ascending order.\n\n    Args:\n        image_scores (list[float]): An array of numerical scores for the images.\n        image_names (list[str]): An array of image names corresponding to the scores.\n        image_ids (list[str | float]): An array of image IDs corresponding to the scores.\n\n    Returns:\n        dict: A dictionary containing the sorted scores, names, and IDs.\n            - resultScores (list[float]): A list of sorted numerical scores.\n            - resultNames (list[str]): A list of sorted image names.\n            - resultIDs (list[str | float]): A list of sorted image IDs.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 298, "code_type": "method", "original_language": "javascript", "file_path": "IUM-TWEB\\b63d3b147923370e5578b6521c62b4f75da9ba3b\\Solution\\Main\\public\\javascripts\\club_valutation.js", "question_type": "Data processing and transformation", "summary": "Converts a numeric value to a format string with a thousand ('k') or million ('m') suffix to represent large values more concisely.", "language_version_list": {"python": {"code_signature": "from typing import Union\n\n\ndef set_eur_value(value: Union[str, int, float]) -> str:\n    \"\"\"\n    Converts a numerical value into a string representation with appropriate\n    suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n    if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n\n    Args:\n        value (Union[str, int, float]): The value to convert.\n\n    Returns:\n        str: The formatted string or an empty string if the input is invalid.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSetEurValue(unittest.TestCase):\n\n    def test_formats_standard_values_correctly(self):\n        self.assertEqual(set_eur_value('250'), '250')\n        self.assertEqual(set_eur_value('2500'), '2.5k')\n\n    def test_handles_boundary_values_accurately(self):\n        self.assertEqual(set_eur_value('999'), '999')\n        self.assertEqual(set_eur_value('1000'), '1.0k')\n        self.assertEqual(set_eur_value('999999'), '999.9k')  # Corrected from '1000.0k' to '999.9k'\n        self.assertEqual(set_eur_value('1000000'), '1.0m')\n\n    def test_returns_correct_format_for_zero_and_negative_inputs(self):\n        self.assertEqual(set_eur_value('0'), '0')\n\n    def test_returns_empty_string_for_invalid_inputs(self):\n        self.assertEqual(set_eur_value('hello'), '')\n        self.assertEqual(set_eur_value(None), '')\n        self.assertEqual(set_eur_value('undefined'), '')  # In JS, 'undefined' is not the same as None in Python\n\n    def test_ensures_precision_for_large_numbers(self):\n        self.assertEqual(set_eur_value('10000000'), '10.0m')\n        self.assertEqual(set_eur_value('987654321'), '987.7m')\n", "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef set_eur_value(value: Union[str, int, float]) -> str:\n    \"\"\"\n    Converts a numerical value into a string representation with appropriate\n    suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n    if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n\n    Args:\n        value (Union[str, int, float]): The value to convert.\n\n    Returns:\n        str: The formatted string or an empty string if the input is invalid.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param value - The value to convert (string representation of a number).\n * @returns The formatted string or an empty string if the input is invalid.\n */\nstd::string setEurValue(const std::string& value){}", "test_code": "TEST_CASE(\"setEurValue\") {\n    SECTION(\"formats standard values correctly\") {\n        REQUIRE(setEurValue(\"250\") == \"250\");\n        REQUIRE(setEurValue(\"2500\") == \"2.5k\");\n    }\n\n    SECTION(\"handles boundary values accurately\") {\n        REQUIRE(setEurValue(\"999\") == \"999\");\n        REQUIRE(setEurValue(\"1000\") == \"1.0k\");\n        REQUIRE(setEurValue(\"999999\") == \"999.9k\"); // Note: Fixed to '999.9k'\n        REQUIRE(setEurValue(\"1000000\") == \"1.0m\");\n    }\n\n    SECTION(\"returns correct format for zero and negative inputs\") {\n        REQUIRE(setEurValue(\"0\") == \"0\");\n    }\n\n    SECTION(\"returns an empty string for invalid inputs\") {\n        REQUIRE(setEurValue(\"hello\") == \"\");\n        REQUIRE(setEurValue(\"\") == \"\"); // Handling empty string instead of null/undefined\n    }\n\n    SECTION(\"ensures precision for large numbers\") {\n        REQUIRE(setEurValue(\"10000000\") == \"10.0m\");\n        REQUIRE(setEurValue(\"987654321\") == \"987.7m\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param value - The value to convert (string representation of a number).\n * @returns The formatted string or an empty string if the input is invalid.\n */\nstd::string setEurValue(const std::string& value){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param value - The value to convert. Can be a String or any Object.\n * @return - The formatted string or an empty string if the input is invalid.\n */\npublic static String setEurValue(Object value) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testFormatsStandardValuesCorrectly() {\n        assertEquals(\"250\", setEurValue(\"250\"));\n        assertEquals(\"2.5k\", setEurValue(\"2500\"));\n    }\n\n    @Test\n    public void testHandlesBoundaryValuesAccurately() {\n        assertEquals(\"999\", setEurValue(\"999\"));\n        assertEquals(\"1.0k\", setEurValue(\"1000\"));\n        assertEquals(\"1000.0k\", setEurValue(\"999999\"));\n        assertEquals(\"1.0m\", setEurValue(\"1000000\"));\n    }\n\n    @Test\n    public void testReturnsCorrectFormatForZeroAndNegativeInputs() {\n        assertEquals(\"0\", setEurValue(\"0\"));\n    }\n\n    @Test\n    public void testReturnsEmptyStringForInvalidInputs() {\n        assertEquals(\"\", setEurValue(\"hello\"));\n        assertEquals(\"\", setEurValue(null));\n        assertEquals(\"\", setEurValue(undefined));  // undefined can be represented as null\n    }\n\n    @Test\n    public void testEnsuresPrecisionForLargeNumbers() {\n        assertEquals(\"10.0m\", setEurValue(\"10000000\"));\n        assertEquals(\"987.7m\", setEurValue(\"987654321\"));\n    }\n    \n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param value - The value to convert. Can be a String or any Object.\n * @return - The formatted string or an empty string if the input is invalid.\n */\npublic static String setEurValue(Object value) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 299, "code_type": "method", "original_language": "javascript", "file_path": "IUM-TWEB\\b63d3b147923370e5578b6521c62b4f75da9ba3b\\Solution\\Main\\public\\javascripts\\club_valutation.js", "question_type": "Algorithm and data structure", "summary": "Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.", "language_version_list": {"python": {"code_signature": "def calculate_age(birth_date_string: str) -> str:\n    \"\"\"\n    Calculates the age from the given birth date string and returns a string containing\n    the original birth date and the calculated age. If the entered date string is invalid\n    or empty, the function returns an empty string.\n\n    Args:\n        birth_date_string (str): The birth date as a string in a recognizable date format\n                                  (e.g., 'YYYY-MM-DD').\n\n    Returns:\n        str: A string that includes the original birth date and the calculated age in the\n             format 'birth_date_string (age)', or an empty string if the input is invalid.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCalculateAge(unittest.TestCase):\n\n    def test_birthday_today(self):\n        self.assertEqual(calculate_age('2000-08-23'), '2000-08-23 (24)')\n\n    def test_birthday_passed_this_year(self):\n        self.assertEqual(calculate_age('1990-01-15'), '1990-01-15 (34)')\n\n    def test_birthday_at_end_of_year(self):\n        self.assertEqual(calculate_age('1985-12-31'), '1985-12-31 (38)')\n\n    def test_recently_turned_one_year_old(self):\n        self.assertEqual(calculate_age('2023-05-05'), '2023-05-05 (1)')\n\n    def test_invalid_date_input(self):\n        self.assertEqual(calculate_age('invalid-date'), '')\n", "prompt": "please write a python function , the function signature as below def calculate_age(birth_date_string: str) -> str:\n    \"\"\"\n    Calculates the age from the given birth date string and returns a string containing\n    the original birth date and the calculated age. If the entered date string is invalid\n    or empty, the function returns an empty string.\n\n    Args:\n        birth_date_string (str): The birth date as a string in a recognizable date format\n                                  (e.g., 'YYYY-MM-DD').\n\n    Returns:\n        str: A string that includes the original birth date and the calculated age in the\n             format 'birth_date_string (age)', or an empty string if the input is invalid.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.\n *\n * @param birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @returns A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', or an empty string if the input is invalid.\n */\nstd::string calculateAge(const std::string& birthDateString) {}", "test_code": "TEST_CASE(\"calculateAge\") {\n    SECTION(\"Birthday today, should be 24 years old\") {\n        REQUIRE(calculateAge(\"2000-08-23\") == \"2000-08-23 (24)\");\n    }\n\n    SECTION(\"Birthday has passed this year, should be 34 years old\") {\n        REQUIRE(calculateAge(\"1990-01-15\") == \"1990-01-15 (34)\");\n    }\n\n    SECTION(\"Birthday at the end of the year, should be 38 years old\") {\n        REQUIRE(calculateAge(\"1985-12-31\") == \"1985-12-31 (38)\");\n    }\n\n    SECTION(\"Recently turned 1 year old this year\") {\n        REQUIRE(calculateAge(\"2023-05-05\") == \"2023-05-05 (1)\");\n    }\n\n    SECTION(\"Invalid date input should return an empty string\") {\n        REQUIRE(calculateAge(\"invalid-date\") == \"\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.\n *\n * @param birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @returns A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', or an empty string if the input is invalid.\n */\nstd::string calculateAge(const std::string& birthDateString) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. \n * If the entered date string is invalid or empty, the method returns an empty string.\n *\n * @param birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @return A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', \n *         or an empty string if the input is invalid.\n */\npublic static String calculateAge(String birthDateString) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testBirthdayToday() {\n        assertEquals(\"2000-08-23 (24)\", calculateAge(\"2000-08-23\"));\n    }\n\n    @Test\n    public void testBirthdayHasPassed() {\n        assertEquals(\"1990-01-15 (34)\", calculateAge(\"1990-01-15\"));\n    }\n\n    @Test\n    public void testBirthdayAtEndOfYear() {\n        assertEquals(\"1985-12-31 (38)\", calculateAge(\"1985-12-31\"));\n    }\n\n    @Test\n    public void testRecentlyTurnedOne() {\n        assertEquals(\"2023-05-05 (1)\", calculateAge(\"2023-05-05\"));\n    }\n\n    @Test\n    public void testInvalidDateInput() {\n        assertEquals(\"\", calculateAge(\"invalid-date\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. \n * If the entered date string is invalid or empty, the method returns an empty string.\n *\n * @param birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @return A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', \n *         or an empty string if the input is invalid.\n */\npublic static String calculateAge(String birthDateString) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 300, "code_type": "method", "original_language": "javascript", "file_path": "dotfiles\\f984af6ad6e0c4111c00c57bcd26195a84320fe0\\.config\\qutebrowser\\greasemonkey\\instacartADRemover.user.js", "question_type": "User interface", "summary": "Iterate over list items on a web page and remove ads that contain a specific class name", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 305, "code_type": "class", "original_language": "javascript", "file_path": "NextNumber\\e1c82712c47ecec03add83c5a1d3efc337e51265\\script.js", "question_type": "Algorithm and data structure", "summary": "Define a class called SeededRandom for generating pseudorandom numbers with a specific seed", "language_version_list": {"python": {"code_signature": "class SeededRandom:\n    \"\"\"\n    Define a class called SeededRandom for generating pseudorandom numbers with a specific seed.\n    \"\"\"\n\n    def __init__(self, seed):\n        \"\"\"\n        Initializes a new instance of the SeededRandom class with a given seed.\n\n        :param seed: The initial seed value for the random number generator.\n        \"\"\"\n\n    def rand(self):\n        \"\"\"\n        Generates a random number between 0 and 1 using a Linear Congruential Generator (LCG) algorithm.\n\n        :returns: A pseudo-random number between 0 (inclusive) and 1 (exclusive).\n        \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSeededRandom(unittest.TestCase):\n\n    def test_consistent_numbers_with_same_seed(self):\n        \"\"\"Generates consistent numbers with the same seed.\"\"\"\n        seeded_rand1 = SeededRandom(42)\n        seeded_rand2 = SeededRandom(42)\n        self.assertAlmostEqual(seeded_rand1.rand(), seeded_rand2.rand(), places=10)\n        self.assertAlmostEqual(seeded_rand1.rand(), seeded_rand2.rand(), places=10)\n        self.assertAlmostEqual(seeded_rand1.rand(), seeded_rand2.rand(), places=10)\n\n    def test_different_numbers_with_different_seeds(self):\n        \"\"\"Generates different numbers with different seeds.\"\"\"\n        seeded_rand1 = SeededRandom(42)\n        seeded_rand2 = SeededRandom(24)\n        self.assertNotAlmostEqual(seeded_rand1.rand(), seeded_rand2.rand(), places=10)\n\n    def test_returns_numbers_between_0_and_1(self):\n        \"\"\"Returns numbers between 0 and 1.\"\"\"\n        seeded_rand = SeededRandom(123456)\n        for _ in range(1000):\n            rand_value = seeded_rand.rand()\n            self.assertGreaterEqual(rand_value, 0)\n            self.assertLess(rand_value, 1)\n\n    def test_different_sequences_with_different_seeds(self):\n        \"\"\"Produces different sequences with different seeds.\"\"\"\n        seeded_rand1 = SeededRandom(123)\n        seeded_rand2 = SeededRandom(456)\n        sequence1 = [seeded_rand1.rand() for _ in range(5)]\n        sequence2 = [seeded_rand2.rand() for _ in range(5)]\n        self.assertNotEqual(sequence1, sequence2)\n\n    def test_consistent_sequence_with_same_seed(self):\n        \"\"\"Consistent sequence with the same seed over multiple calls.\"\"\"\n        seeded_rand = SeededRandom(987654321)\n        sequence1 = [seeded_rand.rand() for _ in range(3)]\n        seeded_rand2 = SeededRandom(987654321)\n        sequence2 = [seeded_rand2.rand() for _ in range(3)]\n        self.assertEqual(sequence1, sequence2)\n", "prompt": "please write a python class , the class signature as below class SeededRandom:\n    \"\"\"\n    Define a class called SeededRandom for generating pseudorandom numbers with a specific seed.\n    \"\"\"\n\n    def __init__(self, seed):\n        \"\"\"\n        Initializes a new instance of the SeededRandom class with a given seed.\n\n        :param seed: The initial seed value for the random number generator.\n        \"\"\"\n\n    def rand(self):\n        \"\"\"\n        Generates a random number between 0 and 1 using a Linear Congruential Generator (LCG) algorithm.\n\n        :returns: A pseudo-random number between 0 (inclusive) and 1 (exclusive).\n        \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 306, "code_type": "method", "original_language": "javascript", "file_path": "2800-202410-DTC13\\d2a3fe8302d732cbde4a88b4452d081a5307af53\\js\\getPrice.js", "question_type": "Algorithm and data structure", "summary": "The recipe ID is hashed to produce a price in the specified range", "language_version_list": {"python": {"code_signature": "def get_price(recipe_id: str, min_val: float = 10, max_val: float = 30) -> float:\n    \"\"\"\n    The recipe ID is hashed to produce a price in the specified range.\n    Args:\n        recipe_id (str): The ID of the recipe to hash.\n        min_val (float): The minimum value of the price range (default is 10).\n        max_val (float): The maximum value of the price range (default is 30).\n\n    Returns:\n        float: The hashed price, mapped to the specified range with two decimal places.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGetPrice(unittest.TestCase):\n\n    def test_default_range(self):\n        price = get_price('recipe123')\n        self.assertGreaterEqual(price, 10)\n        self.assertLessEqual(price, 30)\n\n    def test_same_price_for_same_id(self):\n        price1 = get_price('recipe123')\n        price2 = get_price('recipe123')\n        self.assertEqual(price1, price2)\n\n    def test_different_prices_for_different_ids(self):\n        price1 = get_price('recipe123')\n        price2 = get_price('recipe456')\n        self.assertNotEqual(price1, price2)\n\n    def test_custom_range(self):\n        min_val = 20\n        max_val = 50\n        price = get_price('recipe789', min_val, max_val)\n        self.assertGreaterEqual(price, min_val)\n        self.assertLessEqual(price, max_val)\n\n    def test_long_recipe_id(self):\n        long_recipe_id = 'recipe' + 'A' * 1000\n        price = get_price(long_recipe_id)\n        self.assertGreaterEqual(price, 10)\n        self.assertLessEqual(price, 30)\n", "prompt": "please write a python function , the function signature as below def get_price(recipe_id: str, min_val: float = 10, max_val: float = 30) -> float:\n    \"\"\"\n    The recipe ID is hashed to produce a price in the specified range.\n    Args:\n        recipe_id (str): The ID of the recipe to hash.\n        min_val (float): The minimum value of the price range (default is 10).\n        max_val (float): The maximum value of the price range (default is 30).\n\n    Returns:\n        float: The hashed price, mapped to the specified range with two decimal places.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 308, "code_type": "method", "original_language": "javascript", "file_path": "2800-202410-BBY17\\fac3c1cea77c0cfaff9cd537d175ca25cc6cc103\\index.js", "question_type": "Program input code", "summary": "Gets the current date and returns it as YYYY-MM-DD", "language_version_list": {"python": {"code_signature": "def get_current_date() -> str:\n    \"\"\"Gets the current date and returns it as YYYY-MM-DD.\n\n    Returns:\n        str: The current date formatted as YYYY-MM-DD.\n    \"\"\"", "test_code": "import unittest\nfrom datetime import datetime\n\n\nclass TestGetCurrentDate(unittest.TestCase):\n\n    def test_should_return_a_string_in_the_format_YYYY_MM_DD(self):\n        \"\"\"Test that the return value is a string in the format YYYY-MM-DD.\"\"\"\n        date = get_current_date()\n        self.assertIsInstance(date, str)\n        self.assertRegex(date, r'^\\d{4}-\\d{2}-\\d{2}$')\n\n    def test_should_return_the_correct_date_for_today(self):\n        \"\"\"Test that the returned date is today's date in YYYY-MM-DD format.\"\"\"\n        expected_date = datetime.now().strftime('%Y-%m-%d')\n        actual_date = get_current_date()\n        self.assertEqual(actual_date, expected_date)\n\n    def test_should_return_the_correct_year_part_in_YYYY_MM_DD(self):\n        \"\"\"Test that the returned date has the correct year part (YYYY).\"\"\"\n        current_year = datetime.now().year\n        actual_date = get_current_date()\n        self.assertTrue(actual_date.startswith(str(current_year)))\n\n    def test_should_return_the_correct_month_part_in_YYYY_MM_DD(self):\n        \"\"\"Test that the returned date has the correct month part (MM).\"\"\"\n        current_month = datetime.now().strftime('%m')  # Zero-padded month\n        actual_date = get_current_date()\n        self.assertEqual(actual_date[5:7], current_month)\n\n    def test_should_return_the_correct_day_part_in_YYYY_MM_DD(self):\n        \"\"\"Test that the returned date has the correct day part (DD).\"\"\"\n        current_day = datetime.now().strftime('%d')  # Zero-padded day\n        actual_date = get_current_date()\n        self.assertEqual(actual_date[8:10], current_day)\n", "prompt": "please write a python function , the function signature as below def get_current_date() -> str:\n    \"\"\"Gets the current date and returns it as YYYY-MM-DD.\n\n    Returns:\n        str: The current date formatted as YYYY-MM-DD.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Gets the current date and returns it as YYYY-MM-DD\n *\n * @returns The current date formatted as YYYY-MM-DD.\n */\nstd::string getCurrentDate() {}", "test_code": "TEST_CASE(\"getCurrentDate\", \"[date]\") {\n    SECTION(\"should return a string in the format YYYY-MM-DD\") {\n        std::string date = getCurrentDate();\n        REQUIRE(!date.empty());\n        REQUIRE(std::regex_match(date, std::regex(\"^\\\\d{4}-\\\\d{2}-\\\\d{2}$\")));\n    }\n\n    SECTION(\"should return the correct date for today\") {\n        std::string expectedDate = getCurrentDate(); // Get the current date using the function\n        std::time_t now = std::time(0);\n        std::tm* tm_now = std::localtime(&now);\n        std::ostringstream oss;\n        oss << std::put_time(tm_now, \"%Y-%m-%d\");\n        std::string actualDate = oss.str();\n        REQUIRE(actualDate == expectedDate);\n    }\n\n    SECTION(\"should return the correct year part in YYYY-MM-DD\") {\n        std::time_t now = std::time(0);\n        std::tm* tm_now = std::localtime(&now);\n        std::string currentYear = std::to_string(tm_now->tm_year + 1900);\n        std::string actualDate = getCurrentDate();\n        REQUIRE(actualDate.starts_with(currentYear));\n    }\n\n    SECTION(\"should return the correct month part in YYYY-MM-DD\") {\n        std::time_t now = std::time(0);\n        std::tm* tm_now = std::localtime(&now);\n        std::string currentMonth = std::to_string(tm_now->tm_mon + 1);\n        if (currentMonth.length() < 2) {\n            currentMonth = \"0\" + currentMonth; // Add leading zero if needed\n        }\n        std::string actualDate = getCurrentDate();\n        REQUIRE(actualDate.substr(5, 2) == currentMonth);\n    }\n\n    SECTION(\"should return the correct day part in YYYY-MM-DD\") {\n        std::time_t now = std::time(0);\n        std::tm* tm_now = std::localtime(&now);\n        std::string currentDay = std::to_string(tm_now->tm_mday);\n        if (currentDay.length() < 2) {\n            currentDay = \"0\" + currentDay; // Add leading zero if needed\n        }\n        std::string actualDate = getCurrentDate();\n        REQUIRE(actualDate.substr(8, 2) == currentDay);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Gets the current date and returns it as YYYY-MM-DD\n *\n * @returns The current date formatted as YYYY-MM-DD.\n */\nstd::string getCurrentDate() {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 313, "code_type": "method", "original_language": "javascript", "file_path": "JS-Project-Color-Flipper\\14eb9584d3d693761c0d168514228d47c6d07d31\\js\\app.js", "question_type": NaN, "summary": "Detecting the light or dark state of the background element of a major element of a web page and returning the corresponding description string", "language_version_list": {"python": {"code_signature": "def is_background_too_dark_or_bright(computed_style):\n    \"\"\"Detecting the light or dark state of the background element and returning the corresponding description string.\n\n    Args:\n        computed_style (str): The computed background color in 'rgb(r, g, b)' format.\n\n    Returns:\n        str: \"dark\" if the background is too dark, \"bright\" if it is too bright, or \"normal\" if it is neither.\n    \"\"\"", "test_code": "class TestBackgroundBrightness(unittest.TestCase):\n    def test_dark_background(self):\n        \"\"\"Test for a dark background color.\"\"\"\n        background_color = 'rgb(30, 30, 30)'\n        result = is_background_too_dark_or_bright(background_color)\n        self.assertEqual(result, 'dark')\n\n    def test_bright_background(self):\n        \"\"\"Test for a bright background color.\"\"\"\n        background_color = 'rgb(250, 250, 250)'\n        result = is_background_too_dark_or_bright(background_color)\n        self.assertEqual(result, 'bright')\n\n    def test_normal_background(self):\n        \"\"\"Test for a background color with normal brightness.\"\"\"\n        background_color = 'rgb(150, 150, 150)'\n        result = is_background_too_dark_or_bright(background_color)\n        self.assertEqual(result, 'normal')\n\n    def test_high_red_component(self):\n        \"\"\"Test for a bright color with a high red component.\"\"\"\n        background_color = 'rgb(255, 100, 100)'\n        result = is_background_too_dark_or_bright(background_color)\n        self.assertEqual(result, 'normal')\n\n    def test_low_green_and_blue(self):\n        \"\"\"Test for a dark color with low green and blue components.\"\"\"\n        background_color = 'rgb(10, 10, 100)'\n        result = is_background_too_dark_or_bright(background_color)\n        self.assertEqual(result, 'dark')\n", "prompt": "please write a python function , the function signature as below def is_background_too_dark_or_bright(computed_style):\n    \"\"\"Detecting the light or dark state of the background element and returning the corresponding description string.\n\n    Args:\n        computed_style (str): The computed background color in 'rgb(r, g, b)' format.\n\n    Returns:\n        str: \"dark\" if the background is too dark, \"bright\" if it is too bright, or \"normal\" if it is neither.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 315, "code_type": "method", "original_language": "javascript", "file_path": "JS-Backend\\1ef25695146d98fe7004c6f19c9446ccba9b63dd\\src\\utils\\cloudinary.js", "question_type": "User interface", "summary": "extract the file name from the given URL\n", "language_version_list": {"python": {"code_signature": "def get_file_id_from_url(url: str) -> str:\n    \"\"\"Extract the file ID from the given URL query args.\n\n    If not found, return None.\n\n    Args:\n        url (str): The URL from which the file ID is to be extracted.\n\n    Returns:\n        str: The extracted file ID if present, otherwise None if the URL does not conform to the expected format.\n\n    Example:\n        Input: \"https://example.com/download?fileId=12345\"\n        Output: \"12345\"\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGetFileIdFromUrl(unittest.TestCase):\n    def test_valid_url_with_fileId(self):\n        url = 'https://example.com/download?fileId=12345'\n        self.assertEqual(get_file_id_from_url(url), '12345')\n\n    def test_missing_fileId_parameter(self):\n        url = 'https://example.com/download'\n        self.assertIsNone(get_file_id_from_url(url))\n\n    def test_empty_fileId_parameter(self):\n        url = 'https://example.com/download?fileId='\n        self.assertIsNone(get_file_id_from_url(url))\n\n    def test_malformed_url(self):\n        url = 'https://example.com/download?fileId=12345&otherParam'\n        self.assertEqual(get_file_id_from_url(url), '12345')  # Adjust based on the actual implementation\n", "prompt": "please write a python function , the function signature as below def get_file_id_from_url(url: str) -> str:\n    \"\"\"Extract the file ID from the given URL query args.\n\n    If not found, return None.\n\n    Args:\n        url (str): The URL from which the file ID is to be extracted.\n\n    Returns:\n        str: The extracted file ID if present, otherwise None if the URL does not conform to the expected format.\n\n    Example:\n        Input: \"https://example.com/download?fileId=12345\"\n        Output: \"12345\"\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Extract the fileId from the given URL query args. If not found, return an empty string.\n * For example:\n *      input: https://example.com/download?fileId=12345\n *      output: 12345\n *\n * @param std::string url - The URL from which the file ID is to be extracted.\n * @returns std::string - The extracted file ID if present, otherwise an empty string if the URL does not conform to the expected format.\n */\nstd::string getFileIdFromUrl(const std::string& url){}", "test_code": "TEST_CASE(\"getFileIdFromUrl\", \"[getFileIdFromUrl]\") {\n    SECTION(\"should return the file ID when a valid URL with fileId is provided\") {\n        std::string url = \"https://example.com/download?fileId=12345\";\n        REQUIRE(getFileIdFromUrl(url) == \"12345\");\n    }\n\n    SECTION(\"should return empty string when the fileId query parameter is missing\") {\n        std::string url = \"https://example.com/download\";\n        REQUIRE(getFileIdFromUrl(url) == \"\");\n    }\n\n    SECTION(\"should return empty string when the fileId query parameter is empty\") {\n        std::string url = \"https://example.com/download?fileId=\";\n        REQUIRE(getFileIdFromUrl(url) == \"\");\n    }\n\n    SECTION(\"should return the file ID for a malformed URL\") {\n        std::string url = \"https://example.com/download?fileId=12345&otherParam\";\n        REQUIRE(getFileIdFromUrl(url) == \"12345\"); // Adjust this depending on your needs; the function should still work correctly.\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Extract the fileId from the given URL query args. If not found, return an empty string.\n * For example:\n *      input: https://example.com/download?fileId=12345\n *      output: 12345\n *\n * @param std::string url - The URL from which the file ID is to be extracted.\n * @returns std::string - The extracted file ID if present, otherwise an empty string if the URL does not conform to the expected format.\n */\nstd::string getFileIdFromUrl(const std::string& url){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Extract the file ID from the given URL query args. If not found, return null.\n * For example:\n *      input: https://example.com/download?fileId=12345\n *      output: 12345\n *\n * @param url - The URL from which the file ID is to be extracted.\n * @return - The extracted file ID if present, otherwise null if the URL does not conform to the expected format.\n */\npublic static String getFileIdFromUrl(String url) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testValidUrlWithFileId() {\n        String url = \"https://example.com/download?fileId=12345\";\n        assertEquals(\"12345\", UrlUtil.getFileIdFromUrl(url));\n    }\n\n    @Test\n    public void testMissingFileIdParameter() {\n        String url = \"https://example.com/download\";\n        assertEquals(null, UrlUtil.getFileIdFromUrl(url));\n    }\n\n    @Test\n    public void testEmptyFileIdParameter() {\n        String url = \"https://example.com/download?fileId=\";\n        assertEquals(null, UrlUtil.getFileIdFromUrl(url));\n    }\n\n    @Test\n    public void testMalformedUrl() {\n        String url = \"https://example.com/download?fileId=12345&otherParam\";\n        assertEquals(\"12345\", UrlUtil.getFileIdFromUrl(url)); // Adjust as necessary\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extract the file ID from the given URL query args. If not found, return null.\n * For example:\n *      input: https://example.com/download?fileId=12345\n *      output: 12345\n *\n * @param url - The URL from which the file ID is to be extracted.\n * @return - The extracted file ID if present, otherwise null if the URL does not conform to the expected format.\n */\npublic static String getFileIdFromUrl(String url) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 317, "code_type": "method", "original_language": "javascript", "file_path": "cifra\\83917c840ea8c82df69df0db3d4b3b154746bd02\\script.js", "question_type": "Program input code", "summary": "count the number of letters in a string\n", "language_version_list": {"python": {"code_signature": "def count_letters(s: str) -> int:\n    \"\"\"Count the number of letters in a string.\n\n    Args:\n        s (str): The input string from which to count letters.\n\n    Returns:\n        int: The count of letters in the string.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCountLetters(unittest.TestCase):\n\n    def test_hello_world(self):\n        self.assertEqual(count_letters(\"Hello, World!\"), 10)\n\n    def test_no_letters(self):\n        self.assertEqual(count_letters(\"12345\"), 0)\n\n    def test_abc_123_xyz(self):\n        self.assertEqual(count_letters(\"abc 123 xyz!\"), 6)\n\n    def test_empty_string(self):\n        self.assertEqual(count_letters(\"\"), 0)\n\n    def test_A1B2C3(self):\n        self.assertEqual(count_letters(\"A1B2C3!@#\"), 3)\n\n    def test_mixed_case(self):\n        self.assertEqual(count_letters(\"AbCdE\"), 5)\n\n    def test_special_characters(self):\n        self.assertEqual(count_letters(\"Hello@2024!\"), 10)\n", "prompt": "please write a python function , the function signature as below def count_letters(s: str) -> int:\n    \"\"\"Count the number of letters in a string.\n\n    Args:\n        s (str): The input string from which to count letters.\n\n    Returns:\n        int: The count of letters in the string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Count the number of letters in a string.\n *\n * @param str - The input string from which to count letters.\n * @returns The count of letters in the string.\n */\nint countLetters(const std::string& str){}", "test_code": "TEST_CASE(\"countLetters\", \"[countLetters]\") {\n    SECTION(\"should return 10 for the string 'Hello, World!'\") {\n        REQUIRE(countLetters(\"Hello, World!\") == 10);\n    }\n\n    SECTION(\"should return 0 for a string with no letters '12345'\") {\n        REQUIRE(countLetters(\"12345\") == 0);\n    }\n\n    SECTION(\"should return 6 for the string 'abc 123 xyz!'\") {\n        REQUIRE(countLetters(\"abc 123 xyz!\") == 6);\n    }\n\n    SECTION(\"should return 0 for an empty string\") {\n        REQUIRE(countLetters(\"\") == 0);\n    }\n\n    SECTION(\"should return 3 for the string 'A1B2C3!@#'\") {\n        REQUIRE(countLetters(\"A1B2C3!@#\") == 3);\n    }\n\n    SECTION(\"should return 5 for a string with mixed case 'AbCdE'\") {\n        REQUIRE(countLetters(\"AbCdE\") == 5);\n    }\n\n    SECTION(\"should return 5 for a string with special characters 'Hello@2024!'\") {\n        REQUIRE(countLetters(\"Hello@2024!\") == 5);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Count the number of letters in a string.\n *\n * @param str - The input string from which to count letters.\n * @returns The count of letters in the string.\n */\nint countLetters(const std::string& str){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Count the number of letters in a string.\n *\n * @param str - The input string from which to count letters.\n * @return - The count of letters in the string.\n */\npublic static int countLetters(String str) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testCountLetters_HelloWorld() {\n        assertEquals(10, countLetters(\"Hello, World!\"));\n    }\n\n    @Test\n    public void testCountLetters_NoLetters() {\n        assertEquals(0, countLetters(\"12345\"));\n    }\n\n    @Test\n    public void testCountLetters_ABC123XYZ() {\n        assertEquals(6, countLetters(\"abc 123 xyz!\"));\n    }\n\n    @Test\n    public void testCountLetters_EmptyString() {\n        assertEquals(0, countLetters(\"\"));\n    }\n\n    @Test\n    public void testCountLetters_MixedCharacters() {\n        assertEquals(3, countLetters(\"A1B2C3!@#\"));\n    }\n\n    @Test\n    public void testCountLetters_MixedCase() {\n        assertEquals(5, countLetters(\"AbCdE\"));\n    }\n\n    @Test\n    public void testCountLetters_SpecialCharacters() {\n        assertEquals(5, countLetters(\"Hello@2024!\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Count the number of letters in a string.\n *\n * @param str - The input string from which to count letters.\n * @return - The count of letters in the string.\n */\npublic static int countLetters(String str) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 318, "code_type": "method", "original_language": "javascript", "file_path": "cifra\\83917c840ea8c82df69df0db3d4b3b154746bd02\\script.js", "question_type": "Program input code", "summary": "count the number of numbers in a string\n", "language_version_list": {"python": {"code_signature": "def count_numbers(s: str) -> int:\n    \"\"\"Count the number of numeric digits in a string.\n\n    Args:\n        s (str): The string from which to count numeric digits.\n\n    Returns:\n        int: The total count of numeric digits found in the string.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCountNumbers(unittest.TestCase):\n\n    def test_multiple_numbers(self):\n        result = count_numbers('There are 123 numbers in this string.')\n        self.assertEqual(result, 3)  # '123' contains three numeric characters\n\n    def test_no_numbers(self):\n        result = count_numbers('No numbers here!')\n        self.assertEqual(result, 0)  # No numeric characters in 'No numbers here!'\n\n    def test_mixed_characters(self):\n        result = count_numbers('Room 101 and Room 102')\n        self.assertEqual(result, 6)  # '101' and '102' together contain six numeric characters\n\n    def test_only_numbers(self):\n        result = count_numbers('1234567890')\n        self.assertEqual(result, 10)  # '1234567890' contains ten numeric characters\n\n    def test_empty_string(self):\n        result = count_numbers('')\n        self.assertEqual(result, 0)  # An empty string contains no numeric characters\n", "prompt": "please write a python function , the function signature as below def count_numbers(s: str) -> int:\n    \"\"\"Count the number of numeric digits in a string.\n\n    Args:\n        s (str): The string from which to count numeric digits.\n\n    Returns:\n        int: The total count of numeric digits found in the string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Count the number of numbers in a string.\n *\n * @param str - The string from which to count numeric digits.\n * @returns The total count of numeric digits found in the string.\n */\nint countNumbers(const std::string& str) {}", "test_code": "TEST_CASE(\"countNumbers\") {\n    SECTION(\"should return the correct count for a string with multiple numbers\") {\n        REQUIRE(countNumbers(\"There are 123 numbers in this string.\") == 3); // '123' contains three numeric characters\n    }\n\n    SECTION(\"should return 0 for a string with no numbers\") {\n        REQUIRE(countNumbers(\"No numbers here!\") == 0); // No numeric characters in 'No numbers here!'\n    }\n\n    SECTION(\"should return the correct count for a string with mixed characters\") {\n        REQUIRE(countNumbers(\"Room 101 and Room 102\") == 6); // '101' and '102' together contain six numeric characters\n    }\n\n    SECTION(\"should return the correct count for a string with only numbers\") {\n        REQUIRE(countNumbers(\"1234567890\") == 10); // '1234567890' contains ten numeric characters\n    }\n\n    SECTION(\"should return 0 for an empty string\") {\n        REQUIRE(countNumbers(\"\") == 0); // An empty string contains no numeric characters\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Count the number of numbers in a string.\n *\n * @param str - The string from which to count numeric digits.\n * @returns The total count of numeric digits found in the string.\n */\nint countNumbers(const std::string& str) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Count the number of numeric digits in a string.\n *\n * @param str The string from which to count numeric digits.\n * @returns The total count of numeric digits found in the string.\n */\npublic static int countNumbers(String str) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testCountNumbers_MultipleNumbers() {\n        int result = countNumbers(\"There are 123 numbers in this string.\");\n        assertEquals(3, result); // '123' contains three numeric characters\n    }\n\n    @Test\n    public void testCountNumbers_NoNumbers() {\n        int result = countNumbers(\"No numbers here!\");\n        assertEquals(0, result); // No numeric characters in 'No numbers here!'\n    }\n\n    @Test\n    public void testCountNumbers_MixedCharacters() {\n        int result = countNumbers(\"Room 101 and Room 102\");\n        assertEquals(6, result); // '101' and '102' together contain six numeric characters\n    }\n\n    @Test\n    public void testCountNumbers_OnlyNumbers() {\n        int result = countNumbers(\"1234567890\");\n        assertEquals(10, result); // '1234567890' contains ten numeric characters\n    }\n\n    @Test\n    public void testCountNumbers_EmptyString() {\n        int result = countNumbers(\"\");\n        assertEquals(0, result); // An empty string contains no numeric characters\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Count the number of numeric digits in a string.\n *\n * @param str The string from which to count numeric digits.\n * @returns The total count of numeric digits found in the string.\n */\npublic static int countNumbers(String str) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 319, "code_type": "method", "original_language": "javascript", "file_path": "cifra\\83917c840ea8c82df69df0db3d4b3b154746bd02\\script.js", "question_type": "Program input code", "summary": "count the number of dashes in a string\n", "language_version_list": {"python": {"code_signature": "def count_dashes(s: str) -> int:\n    \"\"\"Count the number of dashes in a string.\n\n    Args:\n        s (str): The string from which to count dash characters.\n\n    Returns:\n        int: The total count of dash characters found in the string.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCountDashes(unittest.TestCase):\n\n    def test_no_dashes(self):\n        \"\"\"Should return 0 for a string with no dashes.\"\"\"\n        result = count_dashes('hello world')\n        self.assertEqual(result, 0)  # 'hello world' contains no dashes\n\n    def test_one_dash(self):\n        \"\"\"Should return 1 for a string with one dash.\"\"\"\n        result = count_dashes('hello-world')\n        self.assertEqual(result, 1)  # 'hello-world' contains one dash\n\n    def test_multiple_dashes(self):\n        \"\"\"Should return 4 for a string with multiple dashes.\"\"\"\n        result = count_dashes('a-b-c-d-e')\n        self.assertEqual(result, 4)  # 'a-b-c-d-e' contains four dashes\n\n    def test_dashes_at_ends(self):\n        \"\"\"Should return 3 for a string with dashes at the beginning and end.\"\"\"\n        result = count_dashes('-start-end-')\n        self.assertEqual(result, 3)  # '-start-end-' contains three dashes\n\n    def test_empty_string(self):\n        \"\"\"Should return 0 for an empty string.\"\"\"\n        result = count_dashes('')\n        self.assertEqual(result, 0)  # An empty string contains no dashes\n", "prompt": "please write a python function , the function signature as below def count_dashes(s: str) -> int:\n    \"\"\"Count the number of dashes in a string.\n\n    Args:\n        s (str): The string from which to count dash characters.\n\n    Returns:\n        int: The total count of dash characters found in the string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Count the number of dashes in a string.\n *\n * @param str The string from which to count dash characters.\n * @returns The total count of dash characters found in the string.\n */\nint countDashes(const std::string& str) {\n}", "test_code": "TEST_CASE(\"countDashes\") {\n    SECTION(\"should return 0 for a string with no dashes\") {\n        REQUIRE(countDashes(\"hello world\") == 0); // 'hello world' contains no dashes\n    }\n\n    SECTION(\"should return 1 for a string with one dash\") {\n        REQUIRE(countDashes(\"hello-world\") == 1); // 'hello-world' contains one dash\n    }\n\n    SECTION(\"should return 4 for a string with multiple dashes\") {\n        REQUIRE(countDashes(\"a-b-c-d-e\") == 4); // 'a-b-c-d-e' contains four dashes\n    }\n\n    SECTION(\"should return 3 for a string with dashes at the beginning and end\") {\n        REQUIRE(countDashes(\"-start-end-\") == 3); // '-start-end-' contains three dashes\n    }\n\n    SECTION(\"should return 0 for an empty string\") {\n        REQUIRE(countDashes(\"\") == 0); // An empty string contains no dashes\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Count the number of dashes in a string.\n *\n * @param str The string from which to count dash characters.\n * @returns The total count of dash characters found in the string.\n */\nint countDashes(const std::string& str) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Count the number of dashes in a string.\n *\n * @param str The string from which to count dash characters.\n * @return The total count of dash characters found in the string.\n */\npublic static int countDashes(String str) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testCountDashes_NoDashes() {\n        int result = DashCounter.countDashes(\"hello world\");\n        assertEquals(0, result); // 'hello world' contains no dashes\n    }\n\n    @Test\n    public void testCountDashes_OneDash() {\n        int result = DashCounter.countDashes(\"hello-world\");\n        assertEquals(1, result); // 'hello-world' contains one dash\n    }\n\n    @Test\n    public void testCountDashes_MultipleDashes() {\n        int result = DashCounter.countDashes(\"a-b-c-d-e\");\n        assertEquals(4, result); // 'a-b-c-d-e' contains four dashes\n    }\n\n    @Test\n    public void testCountDashes_DashesAtEnds() {\n        int result = DashCounter.countDashes(\"-start-end-\");\n        assertEquals(3, result); // '-start-end-' contains three dashes\n    }\n\n    @Test\n    public void testCountDashes_EmptyString() {\n        int result = DashCounter.countDashes(\"\");\n        assertEquals(0, result); // An empty string contains no dashes\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Count the number of dashes in a string.\n *\n * @param str The string from which to count dash characters.\n * @return The total count of dash characters found in the string.\n */\npublic static int countDashes(String str) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 320, "code_type": "method", "original_language": "javascript", "file_path": "cifra\\83917c840ea8c82df69df0db3d4b3b154746bd02\\script.js", "question_type": "Program input code", "summary": "calculate the average of an array of numbers\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef get_array_average(array: List[float]) -> float:\n    \"\"\"\n    Calculate the average of an array of numbers.\n    Args:\n        array (List[float]): A list of numbers for which the average is to be calculated.\n\n    Returns:\n        float: The average (mean) of the array's elements, or float('nan') if the array is empty.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestGetArrayAverage(unittest.TestCase):\n\n    def test_average_of_positive_integers(self):\n        result = get_array_average([1, 2, 3, 4, 5])\n        self.assertEqual(result, 3)  # (1 + 2 + 3 + 4 + 5) / 5 = 3\n\n    def test_average_with_negative_numbers(self):\n        result = get_array_average([-1, -2, -3, -4, -5])\n        self.assertEqual(result, -3)  # (-1 + -2 + -3 + -4 + -5) / 5 = -3\n\n    def test_average_with_mixed_numbers(self):\n        result = get_array_average([1, -1, 2, -2, 3, -3])\n        self.assertEqual(result, 0)  # (1 + -1 + 2 + -2 + 3 + -3) / 6 = 0\n\n    def test_empty_array(self):\n        result = get_array_average([])\n        self.assertTrue(math.isnan(result))  # Division by zero, expected result is NaN\n\n    def test_single_element_array(self):\n        result = get_array_average([7])\n        self.assertEqual(result, 7)  # The average of [7] is 7\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef get_array_average(array: List[float]) -> float:\n    \"\"\"\n    Calculate the average of an array of numbers.\n    Args:\n        array (List[float]): A list of numbers for which the average is to be calculated.\n\n    Returns:\n        float: The average (mean) of the array's elements, or float('nan') if the array is empty.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * calculate the average of an array of numbers\n *\n * @param array - A vector of doubles for which the average is to be calculated.\n * @returns - The average (mean) of the vector's elements, or NaN if the vector is empty.\n */\ndouble getArrayAverage(const std::vector<double>& array) {}", "test_code": "TEST_CASE(\"getArrayAverage\") {\n    SECTION(\"should return the average of an array of positive integers\") {\n        REQUIRE(getArrayAverage({1, 2, 3, 4, 5}) == Approx(3)); // (1 + 2 + 3 + 4 + 5) / 5 = 3\n    }\n\n    SECTION(\"should return the average of an array with negative numbers\") {\n        REQUIRE(getArrayAverage({-1, -2, -3, -4, -5}) == Approx(-3)); // (-1 + -2 + -3 + -4 + -5) / 5 = -3\n    }\n\n    SECTION(\"should return the average of an array with mixed positive and negative numbers\") {\n        REQUIRE(getArrayAverage({1, -1, 2, -2, 3, -3}) == Approx(0)); // (1 + -1 + 2 + -2 + 3 + -3) / 6 = 0\n    }\n\n    SECTION(\"should handle an empty array (edge case)\") {\n        REQUIRE(std::isnan(getArrayAverage({}))); // Division by zero, expected result is NaN\n    }\n\n    SECTION(\"should return the single element when the array contains one item\") {\n        REQUIRE(getArrayAverage({7}) == Approx(7)); // The average of [7] is 7\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * calculate the average of an array of numbers\n *\n * @param array - A vector of doubles for which the average is to be calculated.\n * @returns - The average (mean) of the vector's elements, or NaN if the vector is empty.\n */\ndouble getArrayAverage(const std::vector<double>& array) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * calculate the average of an array of numbers\n *\n * @param array An array of integers for which the average is to be calculated.\n * @returns The average (mean) of the array's elements, or NaN if the array is empty.\n */\npublic static double getArrayAverage(int[] array) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testAverageOfPositiveIntegers() {\n        double result = ArrayUtils.getArrayAverage(new int[]{1, 2, 3, 4, 5});\n        assertEquals(3, result, 0.0001); // (1 + 2 + 3 + 4 + 5) / 5 = 3\n    }\n\n    @Test\n    public void testAverageWithNegativeNumbers() {\n        double result = ArrayUtils.getArrayAverage(new int[]{-1, -2, -3, -4, -5});\n        assertEquals(-3, result, 0.0001); // (-1 + -2 + -3 + -4 + -5) / 5 = -3\n    }\n\n    @Test\n    public void testAverageWithMixedNumbers() {\n        double result = ArrayUtils.getArrayAverage(new int[]{1, -1, 2, -2, 3, -3});\n        assertEquals(0, result, 0.0001); // (1 + -1 + 2 + -2 + 3 + -3) / 6 = 0\n    }\n\n    @Test\n    public void testEmptyArray() {\n        double result = ArrayUtils.getArrayAverage(new int[]{});\n        assertTrue(Double.isNaN(result)); // Division by zero, expected result is NaN\n    }\n\n    @Test\n    public void testSingleElementArray() {\n        double result = ArrayUtils.getArrayAverage(new int[]{7});\n        assertEquals(7, result, 0.0001); // The average of [7] is 7\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * calculate the average of an array of numbers\n *\n * @param array An array of integers for which the average is to be calculated.\n * @returns The average (mean) of the array's elements, or NaN if the array is empty.\n */\npublic static double getArrayAverage(int[] array) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 322, "code_type": "method", "original_language": "javascript", "file_path": "PrepPilot\\987ec93ebff6fbf7ec7b17c9500546f8c87861eb\\app\\static\\javascript\\auth_util.js", "question_type": "User interface", "summary": "verify that a string is a valid email address\n", "language_version_list": {"python": {"code_signature": "def is_valid_email(email: str) -> bool:\n    \"\"\"\n    Verify that a string is a valid email address.\n\n    Args:\n        email (str): The email address to be validated.\n\n    Returns:\n        bool: True if the email matches the regex pattern, indicating it is valid,or False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestIsValidEmail(unittest.TestCase):\n\n    def test_valid_simple_email(self):\n        result = is_valid_email('test@example.com')\n        self.assertTrue(result)  # 'test@example.com' is a valid email\n\n    def test_valid_email_with_subdomain(self):\n        result = is_valid_email('user@mail.example.com')\n        self.assertTrue(result)  # 'user@mail.example.com' is a valid email\n\n    def test_invalid_email_missing_at_symbol(self):\n        result = is_valid_email('invalid-email.com')\n        self.assertFalse(result)  # 'invalid-email.com' is missing the @ symbol\n\n    def test_invalid_email_missing_domain_part(self):\n        result = is_valid_email('user@.com')\n        self.assertFalse(result)  # 'user@.com' is missing a valid domain name\n\n    def test_invalid_email_with_spaces(self):\n        result = is_valid_email('user name@example.com')\n        self.assertFalse(result)  # 'user name@example.com' contains spaces\n", "prompt": "please write a python function , the function signature as below def is_valid_email(email: str) -> bool:\n    \"\"\"\n    Verify that a string is a valid email address.\n\n    Args:\n        email (str): The email address to be validated.\n\n    Returns:\n        bool: True if the email matches the regex pattern, indicating it is valid,or False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * verify that a string is a valid email address\n *\n * @param email - The email address to be validated.\n * @returns true if the email matches the regex pattern, indicating it is valid,\n *          or false otherwise.\n */\nbool isValidEmail(const std::string& email) {}", "test_code": "TEST_CASE(\"isValidEmail\") {\n    SECTION(\"should return true for a valid simple email\") {\n        REQUIRE(isValidEmail(\"test@example.com\") == true); // 'test@example.com' is a valid email\n    }\n\n    SECTION(\"should return true for a valid email with subdomain\") {\n        REQUIRE(isValidEmail(\"user@mail.example.com\") == true); // 'user@mail.example.com' is a valid email\n    }\n\n    SECTION(\"should return false for an email missing the @ symbol\") {\n        REQUIRE(isValidEmail(\"invalid-email.com\") == false); // 'invalid-email.com' is missing the @ symbol\n    }\n\n    SECTION(\"should return false for an email missing the domain part\") {\n        REQUIRE(isValidEmail(\"user@.com\") == false); // 'user@.com' is missing a valid domain name\n    }\n\n    SECTION(\"should return false for an email with spaces\") {\n        REQUIRE(isValidEmail(\"user name@example.com\") == false); // 'user name@example.com' contains spaces\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * verify that a string is a valid email address\n *\n * @param email - The email address to be validated.\n * @returns true if the email matches the regex pattern, indicating it is valid,\n *          or false otherwise.\n */\nbool isValidEmail(const std::string& email) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Verify that a string is a valid email address.\n *\n * @param email The email address to be validated.\n * @return Returns true if the email matches the regex pattern, indicating it is valid,\n *         or false otherwise.\n */\npublic static boolean isValidEmail(String email) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\npublic class Tester {\n\n    @Test\n    public void testValidSimpleEmail() {\n        boolean result = EmailValidator.isValidEmail(\"test@example.com\");\n        assertTrue(result); // 'test@example.com' is a valid email\n    }\n\n    @Test\n    public void testValidEmailWithSubdomain() {\n        boolean result = EmailValidator.isValidEmail(\"user@mail.example.com\");\n        assertTrue(result); // 'user@mail.example.com' is a valid email\n    }\n\n    @Test\n    public void testEmailMissingAtSymbol() {\n        boolean result = EmailValidator.isValidEmail(\"invalid-email.com\");\n        assertFalse(result); // 'invalid-email.com' is missing the @ symbol\n    }\n\n    @Test\n    public void testEmailMissingDomainPart() {\n        boolean result = EmailValidator.isValidEmail(\"user@.com\");\n        assertFalse(result); // 'user@.com' is missing a valid domain name\n    }\n\n    @Test\n    public void testEmailWithSpaces() {\n        boolean result = EmailValidator.isValidEmail(\"user name@example.com\");\n        assertFalse(result); // 'user name@example.com' contains spaces\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Verify that a string is a valid email address.\n *\n * @param email The email address to be validated.\n * @return Returns true if the email matches the regex pattern, indicating it is valid,\n *         or false otherwise.\n */\npublic static boolean isValidEmail(String email) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 323, "code_type": "method", "original_language": "javascript", "file_path": "PrepPilot\\987ec93ebff6fbf7ec7b17c9500546f8c87861eb\\app\\static\\javascript\\auth_util.js", "question_type": "User interface", "summary": "verify that a string is a valid username and check that the username contains only letters, numbers, and underscores\n", "language_version_list": {"python": {"code_signature": "def is_valid_username(username: str) -> bool:\n    \"\"\"\n    Verify that a string is a valid username and check that the username contains only letters, numbers, and underscores.\n\n    Args:\n        username (str): The username to be validated.\n\n    Returns:\n        bool: True if the username matches the regex pattern, indicating it is valid;False if the username contains any characters outside of letters, numbers, and underscores.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestUsernameValidation(unittest.TestCase):\n\n    def test_valid_username_with_letters_numbers_and_underscores(self):\n        result = is_valid_username('user_123')\n        self.assertEqual(result, True)  # 'user_123' is a valid username\n\n    def test_valid_username_with_only_letters(self):\n        result = is_valid_username('username')\n        self.assertEqual(result, True)  # 'username' is a valid username\n\n    def test_invalid_username_with_special_characters(self):\n        result = is_valid_username('user-name')\n        self.assertEqual(result, False)  # 'user-name' contains a hyphen\n\n    def test_invalid_username_with_spaces(self):\n        result = is_valid_username('user name')\n        self.assertEqual(result, False)  # 'user name' contains spaces\n\n    def test_valid_username_with_only_numbers(self):\n        result = is_valid_username('12345')\n        self.assertEqual(result, True)  # '12345' is a valid username\n", "prompt": "please write a python function , the function signature as below def is_valid_username(username: str) -> bool:\n    \"\"\"\n    Verify that a string is a valid username and check that the username contains only letters, numbers, and underscores.\n\n    Args:\n        username (str): The username to be validated.\n\n    Returns:\n        bool: True if the username matches the regex pattern, indicating it is valid;False if the username contains any characters outside of letters, numbers, and underscores.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Verify that a string is a valid username and check that the username contains only letters, numbers, and underscores.\n *\n * @param username - The username to be validated.\n * @returns true if the username matches the regex pattern, indicating it is valid;\n *          returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\nbool isValidUsername(const std::string& username) {}", "test_code": "TEST_CASE(\"isValidUsername\", \"[username]\") {\n    SECTION(\"should return true for a valid username with letters, numbers, and underscores\") {\n        REQUIRE(isValidUsername(\"user_123\") == true); // 'user_123' is a valid username\n    }\n\n    SECTION(\"should return true for a valid username with only letters\") {\n        REQUIRE(isValidUsername(\"username\") == true); // 'username' is a valid username\n    }\n\n    SECTION(\"should return false for a username with special characters\") {\n        REQUIRE(isValidUsername(\"user-name\") == false); // 'user-name' contains a hyphen\n    }\n\n    SECTION(\"should return false for a username with spaces\") {\n        REQUIRE(isValidUsername(\"user name\") == false); // 'user name' contains spaces\n    }\n\n    SECTION(\"should return true for a valid username with only numbers\") {\n        REQUIRE(isValidUsername(\"12345\") == true); // '12345' is a valid username\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Verify that a string is a valid username and check that the username contains only letters, numbers, and underscores.\n *\n * @param username - The username to be validated.\n * @returns true if the username matches the regex pattern, indicating it is valid;\n *          returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\nbool isValidUsername(const std::string& username) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Verify that a string is a valid username and check that the username contains only letters, numbers, and underscores.\n *\n * @param username The username to be validated.\n * @return Returns true if the username matches the regex pattern, indicating it is valid;\n *         returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\npublic static boolean isValidUsername(String username) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\npublic class Tester {\n\n    @Test\n    public void testValidUsernameWithLettersNumbersAndUnderscores() {\n        boolean result = isValidUsername(\"user_123\");\n        assertTrue(result); // 'user_123' is a valid username\n    }\n\n    @Test\n    public void testValidUsernameWithOnlyLetters() {\n        boolean result = isValidUsername(\"username\");\n        assertTrue(result); // 'username' is a valid username\n    }\n\n    @Test\n    public void testUsernameWithSpecialCharacters() {\n        boolean result = isValidUsername(\"user-name\");\n        assertFalse(result); // 'user-name' contains a hyphen\n    }\n\n    @Test\n    public void testUsernameWithSpaces() {\n        boolean result = isValidUsername(\"user name\");\n        assertFalse(result); // 'user name' contains spaces\n    }\n\n    @Test\n    public void testValidUsernameWithOnlyNumbers() {\n        boolean result = isValidUsername(\"12345\");\n        assertTrue(result); // '12345' is a valid username\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Verify that a string is a valid username and check that the username contains only letters, numbers, and underscores.\n *\n * @param username The username to be validated.\n * @return Returns true if the username matches the regex pattern, indicating it is valid;\n *         returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\npublic static boolean isValidUsername(String username) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 326, "code_type": "method", "original_language": "javascript", "file_path": "cider\\ce18e81fa2b1f3921adc5c6cd47c93c3038e43d3\\website\\lib\\time-difference.js", "question_type": "Data processing and transformation", "summary": "Calculates the time difference between a given date and the current date, returning how many days, hours, and minutes elapsed between the two times", "language_version_list": {"python": {"code_signature": "def calculate_time_difference(given_date: str) -> dict:\n    \"\"\"\n    Calculates the time difference between a given date and the current date.\n\n    Args:\n        given_date (str): The date to compare against the current date.\n\n    Returns:\n        dict: A dictionary containing days, hours, and minutes elapsed.\n              {\n                  'days': days,\n                  'hours': remaining_hours,\n                  'minutes': remaining_minutes,\n              }\n    \"\"\"", "test_code": "import unittest\nfrom datetime import timedelta, datetime\n\n\nclass TestCalculateTimeDifference(unittest.TestCase):\n\n    def test_should_return_correct_time_difference_for_a_date_in_the_past(self):\n        past_date = datetime.now() - timedelta(days=3, minutes=5)  # 3 days and 5 minutes ago\n        result = calculate_time_difference(past_date)\n        self.assertEqual(result, {'days': 3, 'hours': 0, 'minutes': 5})\n\n    def test_should_return_correct_time_difference_for_a_date_that_is_exactly_now(self):\n        now = datetime.now()\n        result = calculate_time_difference(now)\n        self.assertEqual(result, {'days': 0, 'hours': 0, 'minutes': 0})\n\n    def test_should_return_correct_time_difference_for_a_date_just_seconds_ago(self):\n        just_now = datetime.now() - timedelta(seconds=45)  # 45 seconds ago\n        result = calculate_time_difference(just_now)\n        self.assertEqual(result, {'days': 0, 'hours': 0, 'minutes': 0})\n\n    def test_should_return_correct_time_difference_for_a_date_with_only_hours_difference(self):\n        hours_ago = datetime.now() - timedelta(hours=7)  # 7 hours ago\n        result = calculate_time_difference(hours_ago)\n        self.assertEqual(result, {'days': 0, 'hours': 7, 'minutes': 0})\n\n    def test_should_return_correct_time_difference_for_a_date_with_hours_and_minutes_difference(self):\n        hours_and_minutes_ago = datetime.now() - timedelta(days=1, minutes=3)  # 1 day and 3 minutes ago\n        result = calculate_time_difference(hours_and_minutes_ago)\n        self.assertEqual(result, {'days': 1, 'hours': 0, 'minutes': 3})\n", "prompt": "please write a python function , the function signature as below def calculate_time_difference(given_date: str) -> dict:\n    \"\"\"\n    Calculates the time difference between a given date and the current date.\n\n    Args:\n        given_date (str): The date to compare against the current date.\n\n    Returns:\n        dict: A dictionary containing days, hours, and minutes elapsed.\n              {\n                  'days': days,\n                  'hours': remaining_hours,\n                  'minutes': remaining_minutes,\n              }\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "struct TimeDifference {\n    int days;\n    int hours;\n    int minutes;\n};\n/**\n * Calculates the time difference between a given date and the current date.\n *\n * @param givenDate - The date to compare against the current date.\n * @returns - A struct containing days, hours, and minutes elapsed.\n * {\n *         int days;\n *         int hours;\n *         int minutes;\n * }\n */\nTimeDifference calculateTimeDifference(const std::string& givenDate){}", "test_code": "TEST_CASE(\"calculateTimeDifference\") {\n    SECTION(\"should return correct time difference for a date in the past\") {\n        auto pastDate = std::chrono::system_clock::now() - std::chrono::hours(3 * 24 + 5 / 60);\n        std::time_t pastTime = std::chrono::system_clock::to_time_t(pastDate);\n        std::tm* tmPast = std::localtime(&pastTime);\n        char buffer[20];\n        std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", tmPast);\n        \n        TimeDifference result = calculateTimeDifference(buffer);\n        REQUIRE(result.days == 3);\n        REQUIRE(result.hours == 0);\n        REQUIRE(result.minutes == 5);\n    }\n\n    SECTION(\"should return correct time difference for a date that is exactly now\") {\n        auto now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());\n        std::tm* tmNow = std::localtime(&now);\n        char buffer[20];\n        std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", tmNow);\n\n        TimeDifference result = calculateTimeDifference(buffer);\n        REQUIRE(result.days == 0);\n        REQUIRE(result.hours == 0);\n        REQUIRE(result.minutes == 0);\n    }\n\n    SECTION(\"should return correct time difference for a date just seconds ago\") {\n        auto justNow = std::chrono::system_clock::now() - std::chrono::seconds(45);\n        std::time_t justNowTime = std::chrono::system_clock::to_time_t(justNow);\n        std::tm* tmJustNow = std::localtime(&justNowTime);\n        char buffer[20];\n        std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", tmJustNow);\n        \n        TimeDifference result = calculateTimeDifference(buffer);\n        REQUIRE(result.days == 0);\n        REQUIRE(result.hours == 0);\n        REQUIRE(result.minutes == 0);\n    }\n\n    SECTION(\"should return correct time difference for a date with only hours difference\") {\n        auto hoursAgo = std::chrono::system_clock::now() - std::chrono::hours(7);\n        std::time_t hoursAgoTime = std::chrono::system_clock::to_time_t(hoursAgo);\n        std::tm* tmHoursAgo = std::localtime(&hoursAgoTime);\n        char buffer[20];\n        std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", tmHoursAgo);\n\n        TimeDifference result = calculateTimeDifference(buffer);\n        REQUIRE(result.days == 0);\n        REQUIRE(result.hours == 7);\n        REQUIRE(result.minutes == 0);\n    }\n\n    SECTION(\"should return correct time difference for a date with hours and minutes difference\") {\n        auto hoursAndMinutesAgo = std::chrono::system_clock::now() - std::chrono::hours(24) - std::chrono::minutes(3);\n        std::time_t hoursAndMinutesAgoTime = std::chrono::system_clock::to_time_t(hoursAndMinutesAgo);\n        std::tm* tmHoursAndMinutesAgo = std::localtime(&hoursAndMinutesAgoTime);\n        char buffer[20];\n        std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", tmHoursAndMinutesAgo);\n\n        TimeDifference result = calculateTimeDifference(buffer);\n        REQUIRE(result.days == 1);\n        REQUIRE(result.hours == 0);\n        REQUIRE(result.minutes == 3);\n    }\n}", "prompt": "please write a cpp function , the function signature as below struct TimeDifference {\n    int days;\n    int hours;\n    int minutes;\n};\n/**\n * Calculates the time difference between a given date and the current date.\n *\n * @param givenDate - The date to compare against the current date.\n * @returns - A struct containing days, hours, and minutes elapsed.\n * {\n *         int days;\n *         int hours;\n *         int minutes;\n * }\n */\nTimeDifference calculateTimeDifference(const std::string& givenDate){}", "addition_info": "struct TimeDifference {\n    int days;\n    int hours;\n    int minutes;\n};"}, "java": {"code_signature": "    public static class TimeDifference {\n        public long days;\n        public long hours;\n        public long minutes;\n\n        public TimeDifference(long days, long hours, long minutes) {\n            this.days = days;\n            this.hours = hours;\n            this.minutes = minutes;\n        }\n    }\n/**\n * Calculates the time difference between a given date and the current date.\n *\n * @param givenDate - The date to compare against the current date.\n * @returns TimeDifference - An object containing days, hours, and minutes elapsed.\n */\npublic static TimeDifference calculateTimeDifference(String givenDate) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testCalculateTimeDifferenceForPastDate() {\n        long pastDateMillis = System.currentTimeMillis() - (3 * 24 * 60 * 60 * 1000 + 5 * 60 * 1000); // 3 days and 5 minutes ago\n        TimeDifference result = TimeDifferenceCalculator.calculateTimeDifference(new Date(pastDateMillis));\n        assertEquals(3, result.days);\n        assertEquals(0, result.hours);\n        assertEquals(5, result.minutes);\n    }\n\n    @Test\n    public void testCalculateTimeDifferenceForNow() {\n        Date now = new Date();\n        TimeDifference result = TimeDifferenceCalculator.calculateTimeDifference(now);\n        assertEquals(0, result.days);\n        assertEquals(0, result.hours);\n        assertEquals(0, result.minutes);\n    }\n\n    @Test\n    public void testCalculateTimeDifferenceForJustSecondsAgo() {\n        long justNowMillis = System.currentTimeMillis() - 45 * 1000; // 45 seconds ago\n        TimeDifference result = TimeDifferenceCalculator.calculateTimeDifference(new Date(justNowMillis));\n        assertEquals(0, result.days);\n        assertEquals(0, result.hours);\n        assertEquals(0, result.minutes);\n    }\n\n    @Test\n    public void testCalculateTimeDifferenceForHoursDifference() {\n        long hoursAgoMillis = System.currentTimeMillis() - 7 * 60 * 60 * 1000; // 7 hours ago\n        TimeDifference result = TimeDifferenceCalculator.calculateTimeDifference(new Date(hoursAgoMillis));\n        assertEquals(0, result.days);\n        assertEquals(7, result.hours);\n        assertEquals(0, result.minutes);\n    }\n\n    @Test\n    public void testCalculateTimeDifferenceForHoursAndMinutesDifference() {\n        long hoursAndMinutesAgoMillis = System.currentTimeMillis() - (1 * 24 * 60 * 60 * 1000 + 3 * 60 * 1000); // 1 day and 3 minutes ago\n        TimeDifference result = TimeDifferenceCalculator.calculateTimeDifference(new Date(hoursAndMinutesAgoMillis));\n        assertEquals(1, result.days);\n        assertEquals(0, result.hours);\n        assertEquals(3, result.minutes);\n    }\n\n    public static class TimeDifference {\n        public long days;\n        public long hours;\n        public long minutes;\n\n        public TimeDifference(long days, long hours, long minutes) {\n            this.days = days;\n            this.hours = hours;\n            this.minutes = minutes;\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below     public static class TimeDifference {\n        public long days;\n        public long hours;\n        public long minutes;\n\n        public TimeDifference(long days, long hours, long minutes) {\n            this.days = days;\n            this.hours = hours;\n            this.minutes = minutes;\n        }\n    }\n/**\n * Calculates the time difference between a given date and the current date.\n *\n * @param givenDate - The date to compare against the current date.\n * @returns TimeDifference - An object containing days, hours, and minutes elapsed.\n */\npublic static TimeDifference calculateTimeDifference(String givenDate) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 447, "code_type": "method", "original_language": "javascript", "file_path": "IUM-TWEB\\b63d3b147923370e5578b6521c62b4f75da9ba3b\\Solution\\Main\\public\\javascripts\\club_valutation.js\n", "question_type": "Data processing and transformation", "summary": "Calculate age based on the birth date string entered by the user\n", "language_version_list": {"python": {"code_signature": "from typing import Union\n\n\ndef calculate_age(birth_date_string: str) -> Union[str,int]:\n    \"\"\"\n    Calculate age based on the birth date string entered by the user.\n\n    Input birth_date_string format such as \"2000-01-01\".\n\n    Args:\n        birth_date_string (str): The birth date in string format.\n\n    Returns:\n        str | int: The age as an integer or an error message as a string\n                    if the date format is invalid.\n    \"\"\"", "test_code": "from datetime import datetime, timedelta\nimport unittest\n\n\nclass TestCalculateAge(unittest.TestCase):\n\n    def test_calculates_age_correctly_for_a_birth_date_in_the_past(self):\n        self.assertEqual(calculate_age('2000-01-01'), datetime.now().year - 2000)\n\n    def test_calculates_age_correctly_for_a_birth_date_in_the_long_past(self):\n        self.assertEqual(calculate_age('1000-01-01'), datetime.now().year - 1000)\n\n    def test_calculates_age_correctly_for_a_birth_date_today(self):\n        today = datetime.now().strftime('%Y-%m-%d')  # Get today's date in YYYY-MM-DD format\n        self.assertEqual(calculate_age(today), 0)\n\n    def test_calculates_age_correctly_for_a_person_born_yesterday(self):\n        yesterday = datetime.now() - timedelta(days=1)  # Set to yesterday\n        birth_date_string = yesterday.strftime('%Y-%m-%d')  # Format as YYYY-MM-DD\n        self.assertEqual(calculate_age(birth_date_string), 0)\n", "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef calculate_age(birth_date_string: str) -> Union[str,int]:\n    \"\"\"\n    Calculate age based on the birth date string entered by the user.\n\n    Input birth_date_string format such as \"2000-01-01\".\n\n    Args:\n        birth_date_string (str): The birth date in string format.\n\n    Returns:\n        str | int: The age as an integer or an error message as a string\n                    if the date format is invalid.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate age based on the birth date string entered by the user. Input birthDateString format such as 2000-01-01\n * @param birthDateString\n * @returns int\n */\nint calculateAge(const std::string& birthDateString) {\n}", "test_code": "TEST_CASE(\"calculateAge\", \"[age]\") {\n    SECTION(\"calculates age correctly for a birth date in the past\") {\n        REQUIRE(calculateAge(\"2000-01-01\") == (std::time(0) / (365.25 * 24 * 60 * 60)) - 2000);\n    }\n\n    SECTION(\"calculates age correctly for a birth date in the long past\") {\n        REQUIRE(calculateAge(\"1000-01-01\") == (std::time(0) / (365.25 * 24 * 60 * 60)) - 1000);\n    }\n\n    SECTION(\"calculates age correctly for a birth date today\") {\n        std::time_t now = std::time(0);\n        std::tm* today = std::localtime(&now);\n        std::ostringstream oss;\n        oss << std::put_time(today, \"%Y-%m-%d\");\n        REQUIRE(calculateAge(oss.str()) == 0);\n    }\n\n    SECTION(\"calculates age correctly for a person born yesterday\") {\n        std::time_t now = std::time(0);\n        std::tm* yesterday = std::localtime(&now);\n        yesterday->tm_mday--; // Set to yesterday\n        std::mktime(yesterday); // Normalize the structure\n        std::ostringstream oss;\n        oss << std::put_time(yesterday, \"%Y-%m-%d\");\n        REQUIRE(calculateAge(oss.str()) == 0);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate age based on the birth date string entered by the user. Input birthDateString format such as 2000-01-01\n * @param birthDateString\n * @returns int\n */\nint calculateAge(const std::string& birthDateString) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate age based on the birth date string entered by the user. Input birthDateString format such as 2000-01-01\n * @param birthDateString the birth date in string format\n * @return the age as a string or a message indicating an invalid date\n */\npublic static String calculateAge(String birthDateString) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class Tester {\n\n    @Test\n    public void testCalculateAgeForBirthDateInThePast() {\n        assertEquals(new Date().getYear() + 1900 - 2000, Integer.parseInt(calculateAge(\"2000-01-01\")));\n    }\n\n    @Test\n    public void testCalculateAgeForBirthDateInTheLongPast() {\n        assertEquals(new Date().getYear() + 1900 - 1000, Integer.parseInt(calculateAge(\"1000-01-01\")));\n    }\n\n    @Test\n    public void testCalculateAgeForBirthDateToday() {\n        String today = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n        assertEquals(0, Integer.parseInt(calculateAge(today)));\n    }\n\n    @Test\n    public void testCalculateAgeForPersonBornYesterday() {\n        Calendar yesterday = Calendar.getInstance();\n        yesterday.add(Calendar.DAY_OF_MONTH, -1); // Set to yesterday\n        String birthDateString = new SimpleDateFormat(\"yyyy-MM-dd\").format(yesterday.getTime());\n        assertEquals(0, Integer.parseInt(calculateAge(birthDateString)));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculate age based on the birth date string entered by the user. Input birthDateString format such as 2000-01-01\n * @param birthDateString the birth date in string format\n * @return the age as a string or a message indicating an invalid date\n */\npublic static String calculateAge(String birthDateString) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 449, "code_type": "method", "original_language": "javascript", "file_path": "InstaBot\\f13614f5d1e21fe97c4379f2f3173f0e8bb39053\\Handlers\\DMHandler.js\n", "question_type": "Algorithm and data structure", "summary": "Convert Buffer to Base64 encoding", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 450, "code_type": "method", "original_language": "javascript", "file_path": "nimbase\\7ea48fafa204b418412efbc0bb9418504ecbf72f\\frontend\\src\\pages\\signup.jsx\n", "question_type": "Data processing and transformation", "summary": "Check whether the password string meets format requirements: contains at least one number.\nContain at least one lowercase letter.\nContain at least one uppercase letter.\nThe value contains at least 8 characters. Contains at least one punctuation mark", "language_version_list": {"python": {"code_signature": "def is_valid_password(password: str) -> bool:\n    \"\"\"\n    Checks whether the provided password meets the specified format requirements:\n    - At least one number\n    - At least one lowercase letter\n    - At least one uppercase letter\n    - At least one punctuation mark\n    - Minimum length of 8 characters\n\n    Args:\n        password (str): The password string to validate.\n\n    Returns:\n        bool: Returns True if the password meets all requirements; otherwise, False.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestPasswordValidator(unittest.TestCase):\n\n    def test_valid_password(self):\n        self.assertTrue(is_valid_password(\"Password1!\"))\n\n    def test_password_without_number(self):\n        self.assertFalse(is_valid_password(\"Password!\"))\n\n    def test_password_without_uppercase(self):\n        self.assertFalse(is_valid_password(\"password1!\"))\n\n    def test_password_without_lowercase(self):\n        self.assertFalse(is_valid_password(\"PASSWORD1!\"))\n\n    def test_password_without_punctuation(self):\n        self.assertFalse(is_valid_password(\"Password1\"))\n\n    def test_password_shorter_than_8_characters(self):\n        self.assertFalse(is_valid_password(\"Pass1!\"))\n", "prompt": "please write a python function , the function signature as below def is_valid_password(password: str) -> bool:\n    \"\"\"\n    Checks whether the provided password meets the specified format requirements:\n    - At least one number\n    - At least one lowercase letter\n    - At least one uppercase letter\n    - At least one punctuation mark\n    - Minimum length of 8 characters\n\n    Args:\n        password (str): The password string to validate.\n\n    Returns:\n        bool: Returns True if the password meets all requirements; otherwise, False.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Checks whether the provided password meets the specified format requirements:\n * - At least one number\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one punctuation mark\n * - Minimum length of 8 characters\n *\n * @param password - The password string to validate\n * @returns true if the password meets all requirements; otherwise, false.\n */\nbool isValidPassword(const std::string& password) {}", "test_code": "TEST_CASE(\"Password Validator Tests\") {\n    SECTION(\"Valid password\") {\n        REQUIRE(isValidPassword(\"Password1!\") == true);\n    }\n\n    SECTION(\"Password without a number\") {\n        REQUIRE(isValidPassword(\"Password!\") == false);\n    }\n\n    SECTION(\"Password without an uppercase letter\") {\n        REQUIRE(isValidPassword(\"password1!\") == false);\n    }\n\n    SECTION(\"Password without a lowercase letter\") {\n        REQUIRE(isValidPassword(\"PASSWORD1!\") == false);\n    }\n\n    SECTION(\"Password without a punctuation mark\") {\n        REQUIRE(isValidPassword(\"Password1\") == false);\n    }\n\n    SECTION(\"Password shorter than 8 characters\") {\n        REQUIRE(isValidPassword(\"Pass1!\") == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Checks whether the provided password meets the specified format requirements:\n * - At least one number\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one punctuation mark\n * - Minimum length of 8 characters\n *\n * @param password - The password string to validate\n * @returns true if the password meets all requirements; otherwise, false.\n */\nbool isValidPassword(const std::string& password) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks whether the provided password meets the specified format requirements:\n * - At least one number\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one punctuation mark\n * - Minimum length of 8 characters\n *\n * @param password - The password string to validate\n * @return Returns true if the password meets all requirements; otherwise, false.\n */\npublic static boolean isValidPassword(String password) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testValidPassword() {\n        assertTrue(PasswordValidator.isValidPassword(\"Password1!\"));\n    }\n\n    @Test\n    public void testPasswordWithoutNumber() {\n        assertFalse(PasswordValidator.isValidPassword(\"Password!\"));\n    }\n\n    @Test\n    public void testPasswordWithoutUppercase() {\n        assertFalse(PasswordValidator.isValidPassword(\"password1!\"));\n    }\n\n    @Test\n    public void testPasswordWithoutLowercase() {\n        assertFalse(PasswordValidator.isValidPassword(\"PASSWORD1!\"));\n    }\n\n    @Test\n    public void testPasswordWithoutPunctuation() {\n        assertFalse(PasswordValidator.isValidPassword(\"Password1\"));\n    }\n\n    @Test\n    public void testPasswordShorterThan8Characters() {\n        assertFalse(PasswordValidator.isValidPassword(\"Pass1!\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks whether the provided password meets the specified format requirements:\n * - At least one number\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one punctuation mark\n * - Minimum length of 8 characters\n *\n * @param password - The password string to validate\n * @return Returns true if the password meets all requirements; otherwise, false.\n */\npublic static boolean isValidPassword(String password) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 528, "code_type": "method", "original_language": "javascript", "file_path": "xinjs-ui\\5f02678148c0b8e4f2af7e78776a913e1a6d9394\\docs.js\n", "question_type": "File operations and I/O operation", "summary": "Searches for Markdown files in the specified directory and returns the path of the files as an array\n", "language_version_list": {"python": {"code_signature": "def find_markdown_files(dir_path: str) -> list:\n    \"\"\"\n    Searches for Markdown files in the specified directory and returns the paths of the files as a list.\n\n    Args:\n        dir_path (str): The directory path to search in.\n\n    Returns:\n        list: A list of paths to Markdown files.\n    \"\"\"", "test_code": "import unittest\nfrom unittest.mock import patch\n\n\nclass TestFindMarkdownFiles(unittest.TestCase):\n\n    @patch('os.listdir')\n    @patch('os.path.isdir')\n    def test_empty_directory(self, mock_isdir, mock_listdir):\n        mock_listdir.return_value = []\n        mock_isdir.return_value = False\n\n        result = find_markdown_files('emptyDir')\n        self.assertEqual(result, [])\n\n    @patch('os.listdir')\n    @patch('os.path.isdir')\n    def test_one_markdown_file(self, mock_isdir, mock_listdir):\n        mock_listdir.return_value = ['file1.md']\n        mock_isdir.return_value = False\n\n        result = find_markdown_files('dir')\n        self.assertEqual(result, ['dir/file1.md'])\n\n    @patch('os.listdir')\n    @patch('os.path.isdir')\n    def test_multiple_markdown_files(self, mock_isdir, mock_listdir):\n        mock_listdir.return_value = ['file1.md', 'file2.md']\n        mock_isdir.return_value = False\n\n        result = find_markdown_files('dir')\n        self.assertEqual(result, ['dir/file1.md', 'dir/file2.md'])\n\n    @patch('os.listdir')\n    @patch('os.path.isdir')\n    def test_ignore_non_markdown_files(self, mock_isdir, mock_listdir):\n        mock_listdir.return_value = ['file1.txt', 'file2.md', 'file3.doc']\n        mock_isdir.return_value = False\n\n        result = find_markdown_files('dir')\n        self.assertEqual(result, ['dir/file2.md'])\n\n    @patch('os.listdir')\n    @patch('os.path.isdir')\n    def test_only_non_markdown_files(self, mock_isdir, mock_listdir):\n        mock_listdir.return_value = ['file1.txt', 'file2.doc']\n        mock_isdir.return_value = False\n\n        result = find_markdown_files('dir')\n        self.assertEqual(result, [])\n", "prompt": "please write a python function , the function signature as below def find_markdown_files(dir_path: str) -> list:\n    \"\"\"\n    Searches for Markdown files in the specified directory and returns the paths of the files as a list.\n\n    Args:\n        dir_path (str): The directory path to search in.\n\n    Returns:\n        list: A list of paths to Markdown files.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Searches for Markdown files in the specified directory and returns the path of the files as a vector.\n *\n * @param dir - The directory path to search in.\n * @returns A vector of paths to Markdown files.\n */\nstd::vector<std::string> findMarkdownFiles(const fs::path& dir) {}", "test_code": "namespace fs {\n    std::vector<std::string> readdirSync(const std::string& dir) {\n        // Placeholder for mocking\n        return {};\n    }\n\n    bool isDirectory(const std::string& path) {\n        // Placeholder for mocking\n        return false;\n    }\n\n    void mockReaddirSync(const std::vector<std::string>& files) {\n        readdirSync = [files](const std::string&) { return files; };\n    }\n\n    void mockStatSync(const std::function<bool(const std::string&)>& statFunc) {\n        isDirectory = [statFunc](const std::string& path) { return statFunc(path); };\n    }\n}\n\n\nTEST_CASE(\"findMarkdownFiles tests\", \"[findMarkdownFiles]\") {\n    // Test for an empty directory\n    SECTION(\"should return an empty array for an empty directory\") {\n        fs::mockReaddirSync({});\n        fs::mockStatSync([](const std::string&) { return false; });\n\n        auto result = findMarkdownFiles(\"emptyDir\");\n        REQUIRE(result == std::vector<std::string>{});\n    }\n\n    // Test for one Markdown file\n    SECTION(\"should return an array with one Markdown file\") {\n        fs::mockReaddirSync({\"file1.md\"});\n        fs::mockStatSync([](const std::string&) { return false; });\n\n        auto result = findMarkdownFiles(\"dir\");\n        REQUIRE(result == std::vector<std::string>{\"file1.md\"});\n    }\n\n    // Test for multiple Markdown files in the same directory\n    SECTION(\"should return an array with multiple Markdown files in the same directory\") {\n        fs::mockReaddirSync({\"file1.md\", \"file2.md\"});\n        fs::mockStatSync([](const std::string&) { return false; });\n\n        auto result = findMarkdownFiles(\"dir\");\n        REQUIRE(result == std::vector<std::string>{\"file1.md\", \"file2.md\"});\n    }\n\n    // Test for ignoring non-Markdown files\n    SECTION(\"should return Markdown files while ignoring non-Markdown files\") {\n        fs::mockReaddirSync({\"file1.txt\", \"file2.md\", \"file3.doc\"});\n        fs::mockStatSync([](const std::string&) { return false; });\n\n        auto result = findMarkdownFiles(\"dir\");\n        REQUIRE(result == std::vector<std::string>{\"file2.md\"});\n    }\n\n    // Test for a directory with only non-Markdown files\n    SECTION(\"should handle a directory with only non-Markdown files\") {\n        fs::mockReaddirSync({\"file1.txt\", \"file2.doc\"});\n        fs::mockStatSync([](const std::string&) { return false; });\n\n        auto result = findMarkdownFiles(\"dir\");\n        REQUIRE(result == std::vector<std::string>{});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Searches for Markdown files in the specified directory and returns the path of the files as a vector.\n *\n * @param dir - The directory path to search in.\n * @returns A vector of paths to Markdown files.\n */\nstd::vector<std::string> findMarkdownFiles(const fs::path& dir) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Searches for Markdown files in the specified directory and returns the path of the files as a list.\n *\n * @param dir - The directory path to search in.\n * @return - A list of paths to Markdown files.\n */\npublic static List<String> findMarkdownFiles(String dir) {}", "test_code": "package org.real.temp;\n\nimport static org.mockito.Mockito.*;\nimport static org.junit.Assert.*;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Mockito;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Tester {\n\n    @Before\n    public void setUp() {\n        // Clear all mocks before each test\n        Mockito.reset();\n    }\n\n    @Test\n    public void shouldReturnEmptyListForEmptyDirectory() {\n        File mockDir = mock(File.class);\n        when(mockDir.listFiles()).thenReturn(new File[0]);\n\n        List<String> result = MarkdownFinder.findMarkdownFiles(mockDir.getAbsolutePath());\n        assertEquals(Collections.emptyList(), result);\n    }\n\n    @Test\n    public void shouldReturnListWithOneMarkdownFile() {\n        File mockDir = mock(File.class);\n        File mockFile = mock(File.class);\n        when(mockDir.listFiles()).thenReturn(new File[]{mockFile});\n        when(mockFile.getName()).thenReturn(\"file1.md\");\n        when(mockFile.isDirectory()).thenReturn(false);\n\n        List<String> result = MarkdownFinder.findMarkdownFiles(mockDir.getAbsolutePath());\n        assertEquals(Arrays.asList(\"dir\\\\file1.md\"), result);\n    }\n\n    @Test\n    public void shouldReturnListWithMultipleMarkdownFilesInSameDirectory() {\n        File mockDir = mock(File.class);\n        File mockFile1 = mock(File.class);\n        File mockFile2 = mock(File.class);\n        when(mockDir.listFiles()).thenReturn(new File[]{mockFile1, mockFile2});\n        when(mockFile1.getName()).thenReturn(\"file1.md\");\n        when(mockFile2.getName()).thenReturn(\"file2.md\");\n        when(mockFile1.isDirectory()).thenReturn(false);\n        when(mockFile2.isDirectory()).thenReturn(false);\n\n        List<String> result = MarkdownFinder.findMarkdownFiles(mockDir.getAbsolutePath());\n        assertEquals(Arrays.asList(\"dir\\\\file1.md\", \"dir\\\\file2.md\"), result);\n    }\n\n    @Test\n    public void shouldReturnMarkdownFilesIgnoringNonMarkdownFiles() {\n        File mockDir = mock(File.class);\n        File mockFile1 = mock(File.class);\n        File mockFile2 = mock(File.class);\n        File mockFile3 = mock(File.class);\n        when(mockDir.listFiles()).thenReturn(new File[]{mockFile1, mockFile2, mockFile3});\n        when(mockFile1.getName()).thenReturn(\"file1.txt\");\n        when(mockFile2.getName()).thenReturn(\"file2.md\");\n        when(mockFile3.getName()).thenReturn(\"file3.doc\");\n        when(mockFile1.isDirectory()).thenReturn(false);\n        when(mockFile2.isDirectory()).thenReturn(false);\n        when(mockFile3.isDirectory()).thenReturn(false);\n\n        List<String> result = MarkdownFinder.findMarkdownFiles(mockDir.getAbsolutePath());\n        assertEquals(Arrays.asList(\"dir\\\\file2.md\"), result);\n    }\n\n    @Test\n    public void shouldHandleDirectoryWithOnlyNonMarkdownFiles() {\n        File mockDir = mock(File.class);\n        File mockFile1 = mock(File.class);\n        File mockFile2 = mock(File.class);\n        when(mockDir.listFiles()).thenReturn(new File[]{mockFile1, mockFile2});\n        when(mockFile1.getName()).thenReturn(\"file1.txt\");\n        when(mockFile2.getName()).thenReturn(\"file2.doc\");\n        when(mockFile1.isDirectory()).thenReturn(false);\n        when(mockFile2.isDirectory()).thenReturn(false);\n\n        List<String> result = MarkdownFinder.findMarkdownFiles(mockDir.getAbsolutePath());\n        assertEquals(Collections.emptyList(), result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Searches for Markdown files in the specified directory and returns the path of the files as a list.\n *\n * @param dir - The directory path to search in.\n * @return - A list of paths to Markdown files.\n */\npublic static List<String> findMarkdownFiles(String dir) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 529, "code_type": "method", "original_language": "javascript", "file_path": "xinjs-ui\\5f02678148c0b8e4f2af7e78776a913e1a6d9394\\docs.js\n", "question_type": "File operations and I/O operation", "summary": "Converts the  data object to JSON format and saves it to the specified file path\n", "language_version_list": {"python": {"code_signature": "def save_as_json(data: dict, output_file_path: str) -> None:\n    \"\"\"\n    Converts the data object to JSON format and saves it to the specified file path.\n\n    Args:\n        data (dict): The data object to be converted to JSON.\n        output_file_path (str): The file path where the JSON will be saved.\n    \"\"\"", "test_code": "import json\nimport os\nimport unittest\nfrom io import StringIO\n\n\nclass TestSaveAsJSON(unittest.TestCase):\n    mock_file_path = 'test.json'\n\n    def setUp(self):\n        # Redirect console output\n        self.console_output = StringIO()\n        self.original_stdout = redirect_stdout(self.console_output)\n        self.original_stdout.__enter__()\n\n    def tearDown(self):\n        # Clean up after each test\n        if os.path.exists(self.mock_file_path):\n            os.remove(self.mock_file_path)  # Remove test file if it exists\n\n        self.original_stdout.__exit__(None, None, None)\n\n    def test_save_valid_object_to_json_file(self):\n        data = {\"name\": \"Alice\", \"age\": 25}\n        save_as_json(data, self.mock_file_path)\n        with open(self.mock_file_path, 'r', encoding='utf-8') as json_file:\n            saved_data = json_file.read()\n        self.assertEqual(saved_data, json.dumps(data, indent=2))\n\n    def test_handle_empty_object(self):\n        data = {}\n        save_as_json(data, self.mock_file_path)\n        with open(self.mock_file_path, 'r', encoding='utf-8') as json_file:\n            saved_data = json_file.read()\n        self.assertEqual(saved_data, json.dumps(data, indent=2))\n\n    def test_save_nested_object_to_json_file(self):\n        data = {\"user\": {\"name\": \"Bob\", \"age\": 30}, \"active\": True}\n        save_as_json(data, self.mock_file_path)\n        with open(self.mock_file_path, 'r', encoding='utf-8') as json_file:\n            saved_data = json_file.read()\n        self.assertEqual(saved_data, json.dumps(data, indent=2))\n\n    def test_save_array_of_objects_to_json_file(self):\n        data = [\n            {\"product\": {\"id\": 1, \"name\": \"Laptop\", \"price\": 999.99}, \"inStock\": True},\n            {\"product\": {\"id\": 2, \"name\": \"Phone\", \"price\": 499.99}, \"inStock\": False}\n        ]\n        save_as_json(data, self.mock_file_path)\n        with open(self.mock_file_path, 'r', encoding='utf-8') as json_file:\n            saved_data = json_file.read()\n        self.assertEqual(saved_data, json.dumps(data, indent=2))\n\n    def test_save_object_with_mixed_data_types_to_json_file(self):\n        data = {\n            \"title\": \"Shopping List\",\n            \"items\": [\"Milk\", \"Eggs\", \"Bread\"],\n            \"total\": 3.50,\n            \"completed\": False\n        }\n        save_as_json(data, self.mock_file_path)\n        with open(self.mock_file_path, 'r', encoding='utf-8') as json_file:\n            saved_data = json_file.read()\n        self.assertEqual(saved_data, json.dumps(data, indent=2))\n\n    def test_save_deeply_nested_object_to_json_file(self):\n        data = {\n            \"company\": {\n                \"name\": \"TechCorp\",\n                \"employees\": [\n                    {\n                        \"id\": 1,\n                        \"name\": \"Alice\",\n                        \"role\": \"Developer\",\n                        \"contact\": {\"email\": \"alice@techcorp.com\", \"phone\": \"123-456-7890\"}\n                    },\n                    {\n                        \"id\": 2,\n                        \"name\": \"Bob\",\n                        \"role\": \"Designer\",\n                        \"contact\": {\"email\": \"bob@techcorp.com\", \"phone\": \"098-765-4321\"}\n                    }\n                ]\n            },\n            \"established\": 2010\n        }\n        save_as_json(data, self.mock_file_path)\n        with open(self.mock_file_path, 'r', encoding='utf-8') as json_file:\n            saved_data = json_file.read()\n        self.assertEqual(saved_data, json.dumps(data, indent=2))\n", "prompt": "please write a python function , the function signature as below def save_as_json(data: dict, output_file_path: str) -> None:\n    \"\"\"\n    Converts the data object to JSON format and saves it to the specified file path.\n\n    Args:\n        data (dict): The data object to be converted to JSON.\n        output_file_path (str): The file path where the JSON will be saved.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts the data object to JSON format and saves it to the specified file path.\n * @param data - The data object to be converted to JSON.\n * @param outputFilePath - The file path where the JSON will be saved.\n */\nvoid saveAsJSON(const nlohmann::json& data, const std::string& outputFilePath) {}", "test_code": "TEST_CASE(\"saveAsJSON\", \"[json]\") {\n    const std::string mockFilePath = \"test.json\";\n\n    // Clean up after each test\n    auto cleanup = [&]() {\n        if (std::filesystem::exists(mockFilePath)) {\n            std::filesystem::remove(mockFilePath);\n        }\n    };\n\n    // Run cleanup after each test case\n    SECTION(\"Cleanup\") { cleanup(); }\n\n    SECTION(\"should save valid object to JSON file\") {\n        nlohmann::json data = {{\"name\", \"Alice\"}, {\"age\", 25}};\n        saveAsJSON(data, mockFilePath);\n        std::ifstream savedFile(mockFilePath);\n        std::string savedData((std::istreambuf_iterator<char>(savedFile)), std::istreambuf_iterator<char>());\n        REQUIRE(savedData == data.dump(2));\n        cleanup();\n    }\n\n    SECTION(\"should handle empty object\") {\n        nlohmann::json data = {};\n        saveAsJSON(data, mockFilePath);\n        std::ifstream savedFile(mockFilePath);\n        std::string savedData((std::istreambuf_iterator<char>(savedFile)), std::istreambuf_iterator<char>());\n        REQUIRE(savedData == data.dump(2));\n        cleanup();\n    }\n\n    SECTION(\"should save nested object to JSON file\") {\n        nlohmann::json data = {{\"user\", {{\"name\", \"Bob\"}, {\"age\", 30}}}, {\"active\", true}};\n        saveAsJSON(data, mockFilePath);\n        std::ifstream savedFile(mockFilePath);\n        std::string savedData((std::istreambuf_iterator<char>(savedFile)), std::istreambuf_iterator<char>());\n        REQUIRE(savedData == data.dump(2));\n        cleanup();\n    }\n\n    SECTION(\"should save array of objects to JSON file\") {\n        nlohmann::json data = {\n            {{\"product\", {{\"id\", 1}, {\"name\", \"Laptop\"}, {\"price\", 999.99}}}, {\"inStock\", true}},\n            {{\"product\", {{\"id\", 2}, {\"name\", \"Phone\"}, {\"price\", 499.99}}}, {\"inStock\", false}}\n        };\n        saveAsJSON(data, mockFilePath);\n        std::ifstream savedFile(mockFilePath);\n        std::string savedData((std::istreambuf_iterator<char>(savedFile)), std::istreambuf_iterator<char>());\n        REQUIRE(savedData == data.dump(2));\n        cleanup();\n    }\n\n    SECTION(\"should save object with mixed data types to JSON file\") {\n        nlohmann::json data = {{\"title\", \"Shopping List\"}, {\"items\", {\"Milk\", \"Eggs\", \"Bread\"}}, {\"total\", 3.50}, {\"completed\", false}};\n        saveAsJSON(data, mockFilePath);\n        std::ifstream savedFile(mockFilePath);\n        std::string savedData((std::istreambuf_iterator<char>(savedFile)), std::istreambuf_iterator<char>());\n        REQUIRE(savedData == data.dump(2));\n        cleanup();\n    }\n\n    SECTION(\"should save deeply nested object to JSON file\") {\n        nlohmann::json data = {\n            {\"company\", {\n                {\"name\", \"TechCorp\"},\n                {\"employees\", {\n                    {{\"id\", 1}, {\"name\", \"Alice\"}, {\"role\", \"Developer\"}, {\"contact\", {{\"email\", \"alice@techcorp.com\"}, {\"phone\", \"123-456-7890\"}}}},\n                    {{\"id\", 2}, {\"name\", \"Bob\"}, {\"role\", \"Designer\"}, {\"contact\", {{\"email\", \"bob@techcorp.com\"}, {\"phone\", \"098-765-4321\"}}}}\n                }}\n            }},\n            {\"established\", 2010}\n        };\n        saveAsJSON(data, mockFilePath);\n        std::ifstream savedFile(mockFilePath);\n        std::string savedData((std::istreambuf_iterator<char>(savedFile)), std::istreambuf_iterator<char>());\n        REQUIRE(savedData == data.dump(2));\n        cleanup();\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts the data object to JSON format and saves it to the specified file path.\n * @param data - The data object to be converted to JSON.\n * @param outputFilePath - The file path where the JSON will be saved.\n */\nvoid saveAsJSON(const nlohmann::json& data, const std::string& outputFilePath) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts the data object to JSON format and saves it to the specified file path.\n * @param data - The data object to be converted to JSON.\n * @param outputFilePath - The file path where the JSON will be saved.\n */\npublic static void saveAsJSON(Object data, String outputFilePath) {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class Tester {\n\n    private final String mockFilePath = \"test.json\";\n\n    @After\n    public void tearDown() throws Exception {\n        // Clean up after each test\n        File file = new File(mockFilePath);\n        if (file.exists()) {\n            file.delete(); // Remove test file if it exists\n        }\n    }\n\n    @Test\n    public void shouldSaveValidObjectToJSONFile() throws Exception {\n        Object data = new Object() {\n            String name = \"Alice\";\n            int age = 25;\n        };\n        saveAsJSON(data, mockFilePath);\n        String savedData = new String(Files.readAllBytes(Paths.get(mockFilePath)));\n        assertEquals(new Gson().toJson(data, null, 2), savedData);\n    }\n\n    @Test\n    public void shouldHandleEmptyObject() throws Exception {\n        Object data = new Object() {};\n        saveAsJSON(data, mockFilePath);\n        String savedData = new String(Files.readAllBytes(Paths.get(mockFilePath)));\n        assertEquals(new Gson().toJson(data, null, 2), savedData);\n    }\n\n    @Test\n    public void shouldSaveNestedObjectToJSONFile() throws Exception {\n        Object data = new Object() {\n            Object user = new Object() {\n                String name = \"Bob\";\n                int age = 30;\n            };\n            boolean active = true;\n        };\n        saveAsJSON(data, mockFilePath);\n        String savedData = new String(Files.readAllBytes(Paths.get(mockFilePath)));\n        assertEquals(new Gson().toJson(data, null, 2), savedData);\n    }\n\n    @Test\n    public void shouldSaveArrayOfObjectsToJSONFile() throws Exception {\n        Object data = new Object[] {\n            new Object() {\n                Object product = new Object() {\n                    int id = 1;\n                    String name = \"Laptop\";\n                    double price = 999.99;\n                };\n                boolean inStock = true;\n            },\n            new Object() {\n                Object product = new Object() {\n                    int id = 2;\n                    String name = \"Phone\";\n                    double price = 499.99;\n                };\n                boolean inStock = false;\n            }\n        };\n        saveAsJSON(data, mockFilePath);\n        String savedData = new String(Files.readAllBytes(Paths.get(mockFilePath)));\n        assertEquals(new Gson().toJson(data, null, 2), savedData);\n    }\n\n    @Test\n    public void shouldSaveObjectWithMixedDataTypesToJSONFile() throws Exception {\n        Object data = new Object() {\n            String title = \"Shopping List\";\n            String[] items = {\"Milk\", \"Eggs\", \"Bread\"};\n            double total = 3.50;\n            boolean completed = false;\n        };\n        saveAsJSON(data, mockFilePath);\n        String savedData = new String(Files.readAllBytes(Paths.get(mockFilePath)));\n        assertEquals(new Gson().toJson(data, null, 2), savedData);\n    }\n\n    @Test\n    public void shouldSaveDeeplyNestedObjectToJSONFile() throws Exception {\n        Object data = new Object() {\n            Object company = new Object() {\n                String name = \"TechCorp\";\n                Object[] employees = new Object[] {\n                    new Object() {\n                        int id = 1;\n                        String name = \"Alice\";\n                        String role = \"Developer\";\n                        Object contact = new Object() {\n                            String email = \"alice@techcorp.com\";\n                            String phone = \"123-456-7890\";\n                        };\n                    },\n                    new Object() {\n                        int id = 2;\n                        String name = \"Bob\";\n                        String role = \"Designer\";\n                        Object contact = new Object() {\n                            String email = \"bob@techcorp.com\";\n                            String phone = \"098-765-4321\";\n                        };\n                    }\n                };\n            };\n            int established = 2010;\n        };\n        saveAsJSON(data, mockFilePath);\n        String savedData = new String(Files.readAllBytes(Paths.get(mockFilePath)));\n        assertEquals(new Gson().toJson(data, null, 2), savedData);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts the data object to JSON format and saves it to the specified file path.\n * @param data - The data object to be converted to JSON.\n * @param outputFilePath - The file path where the JSON will be saved.\n */\npublic static void saveAsJSON(Object data, String outputFilePath) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 530, "code_type": "method", "original_language": "javascript", "file_path": "clrb-edition_tracker\\d40531e4d2dd5d324f69591176352ccd14808d8b\\src\\main\\resources\\static\\js\\main.js\n", "question_type": "Data processing and transformation", "summary": "Creates a matrix with the specified number of rows and columns,\nfilled with the given initial value.", "language_version_list": {"python": {"code_signature": "def create_matrix(rows: int, columns: int, initial_value: any) -> list:\n    \"\"\"Creates a matrix with the specified number of rows and columns,\n    filled with the given initial value.\n\n    Args:\n        rows (int): The number of rows in the matrix.\n        columns (int): The number of columns in the matrix.\n        initial_value (any): The value to fill the matrix with.\n                             It can be of any type (number, string, object, etc.).\n\n    Returns:\n        list: A two-dimensional list (matrix) filled with the initial value.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCreateMatrix(unittest.TestCase):\n\n    def test_create_2x2_matrix_filled_with_zeros(self):\n        result = create_matrix(2, 2, 0)\n        self.assertEqual(result, [[0, 0], [0, 0]])\n\n    def test_create_3x3_matrix_filled_with_ones(self):\n        result = create_matrix(3, 3, 1)\n        self.assertEqual(result, [[1, 1, 1], [1, 1, 1], [1, 1, 1]])\n\n    def test_create_4x5_matrix_filled_with_string(self):\n        result = create_matrix(4, 5, 'test')\n        self.assertEqual(result, [['test'] * 5 for _ in range(4)])\n\n    def test_create_0x0_matrix(self):\n        result = create_matrix(0, 0, None)\n        self.assertEqual(result, [])\n\n    def test_create_1x1_matrix_with_boolean(self):\n        result = create_matrix(1, 1, True)\n        self.assertEqual(result, [[True]])\n\n    def test_create_5x5_matrix_filled_with_negative_numbers(self):\n        result = create_matrix(5, 5, -1)\n        self.assertEqual(result, [[-1] * 5 for _ in range(5)])\n", "prompt": "please write a python function , the function signature as below def create_matrix(rows: int, columns: int, initial_value: any) -> list:\n    \"\"\"Creates a matrix with the specified number of rows and columns,\n    filled with the given initial value.\n\n    Args:\n        rows (int): The number of rows in the matrix.\n        columns (int): The number of columns in the matrix.\n        initial_value (any): The value to fill the matrix with.\n                             It can be of any type (number, string, object, etc.).\n\n    Returns:\n        list: A two-dimensional list (matrix) filled with the initial value.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Creates a matrix with the specified number of rows and columns,\n * filled with the given initial value.\n *\n * @param int rows - The number of rows in the matrix.\n * @param int columns - The number of columns in the matrix.\n * @param int initialValue - The value to fill the matrix with.\n *                          It can be of any type (int, std::string, etc.).\n * @returns std::vector<std::vector<int>> A two-dimensional vector (matrix) filled with the initial value.\n */\nstd::vector<std::vector<int>> createMatrix(int rows, int columns, int initialValue) {}", "test_code": "TEST_CASE(\"createMatrix\", \"[matrix]\") {\n    SECTION(\"should create a 2x2 matrix filled with zeros\") {\n        auto result = createMatrix(2, 2, 0);\n        REQUIRE(result == std::vector<std::vector<int>>{{0, 0}, {0, 0}});\n    }\n\n    SECTION(\"should create a 3x3 matrix filled with ones\") {\n        auto result = createMatrix(3, 3, 1);\n        REQUIRE(result == std::vector<std::vector<int>>{{1, 1, 1}, {1, 1, 1}, {1, 1, 1}});\n    }\n\n    SECTION(\"should create a 4x5 matrix filled with a string\") {\n        auto result = createMatrix(4, 5, std::string(\"test\"));\n        REQUIRE(result == std::vector<std::vector<std::string>>{\n            {\"test\", \"test\", \"test\", \"test\", \"test\"},\n            {\"test\", \"test\", \"test\", \"test\", \"test\"},\n            {\"test\", \"test\", \"test\", \"test\", \"test\"},\n            {\"test\", \"test\", \"test\", \"test\", \"test\"},\n        });\n    }\n\n    SECTION(\"should create a 0x0 matrix\") {\n        auto result = createMatrix(0, 0, 0);\n        REQUIRE(result == std::vector<std::vector<int>>{});\n    }\n\n    SECTION(\"should create a 1x1 matrix with a boolean\") {\n        auto result = createMatrix(1, 1, true);\n        REQUIRE(result == std::vector<std::vector<bool>>{{true}});\n    }\n\n    SECTION(\"should create a 5x5 matrix filled with negative numbers\") {\n        auto result = createMatrix(5, 5, -1);\n        REQUIRE(result == std::vector<std::vector<int>>{\n            {-1, -1, -1, -1, -1},\n            {-1, -1, -1, -1, -1},\n            {-1, -1, -1, -1, -1},\n            {-1, -1, -1, -1, -1},\n            {-1, -1, -1, -1, -1},\n        });\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Creates a matrix with the specified number of rows and columns,\n * filled with the given initial value.\n *\n * @param int rows - The number of rows in the matrix.\n * @param int columns - The number of columns in the matrix.\n * @param int initialValue - The value to fill the matrix with.\n *                          It can be of any type (int, std::string, etc.).\n * @returns std::vector<std::vector<int>> A two-dimensional vector (matrix) filled with the initial value.\n */\nstd::vector<std::vector<int>> createMatrix(int rows, int columns, int initialValue) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Creates a matrix with the specified number of rows and columns,\n * filled with the given initial value.\n *\n * @param rows - The number of rows in the matrix.\n * @param columns - The number of columns in the matrix.\n * @param initialValue - The value to fill the matrix with.\n *                      It can be of any type (number, string, object, etc.).\n * @returns A two-dimensional array (matrix) filled with the initial value.\n */\npublic static Object[][] createMatrix(int rows, int columns, Object initialValue) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\n\npublic class Tester {\n\n    @Test\n    public void testCreate2x2MatrixFilledWithZeros() {\n        Object[][] result = MatrixCreator.createMatrix(2, 2, 0);\n        assertArrayEquals(new Object[][]{{0, 0}, {0, 0}}, result);\n    }\n\n    @Test\n    public void testCreate3x3MatrixFilledWithOnes() {\n        Object[][] result = MatrixCreator.createMatrix(3, 3, 1);\n        assertArrayEquals(new Object[][]{{1, 1, 1}, {1, 1, 1}, {1, 1, 1}}, result);\n    }\n\n    @Test\n    public void testCreate4x5MatrixFilledWithString() {\n        Object[][] result = MatrixCreator.createMatrix(4, 5, \"test\");\n        assertArrayEquals(new Object[][]{\n            {\"test\", \"test\", \"test\", \"test\", \"test\"},\n            {\"test\", \"test\", \"test\", \"test\", \"test\"},\n            {\"test\", \"test\", \"test\", \"test\", \"test\"},\n            {\"test\", \"test\", \"test\", \"test\", \"test\"},\n        }, result);\n    }\n\n    @Test\n    public void testCreate0x0Matrix() {\n        Object[][] result = MatrixCreator.createMatrix(0, 0, null);\n        assertArrayEquals(new Object[0][0], result);\n    }\n\n    @Test\n    public void testCreate1x1MatrixWithBoolean() {\n        Object[][] result = MatrixCreator.createMatrix(1, 1, true);\n        assertArrayEquals(new Object[][]{{true}}, result);\n    }\n\n    @Test\n    public void testCreate5x5MatrixFilledWithNegativeNumbers() {\n        Object[][] result = MatrixCreator.createMatrix(5, 5, -1);\n        assertArrayEquals(new Object[][]{\n            {-1, -1, -1, -1, -1},\n            {-1, -1, -1, -1, -1},\n            {-1, -1, -1, -1, -1},\n            {-1, -1, -1, -1, -1},\n            {-1, -1, -1, -1, -1},\n        }, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Creates a matrix with the specified number of rows and columns,\n * filled with the given initial value.\n *\n * @param rows - The number of rows in the matrix.\n * @param columns - The number of columns in the matrix.\n * @param initialValue - The value to fill the matrix with.\n *                      It can be of any type (number, string, object, etc.).\n * @returns A two-dimensional array (matrix) filled with the initial value.\n */\npublic static Object[][] createMatrix(int rows, int columns, Object initialValue) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 532, "code_type": "method", "original_language": "javascript", "file_path": "Using-Konduktiva-With-MIDI\\554f86a5e9de09730cafe86ec9d27e131bb86600\\utilities-string.js\n", "question_type": "Data processing and transformation", "summary": "Counts the occurrences of consecutive identical letters in a given string.", "language_version_list": {"python": {"code_signature": "def count_letter_changes(input_string: str) -> list:\n    \"\"\"Counts the occurrences of consecutive identical letters in a given string.\n\n    Args:\n        input_string (str): The string to analyze for letter changes.\n\n    Returns:\n        list: A list of counts representing the number of consecutive\n              identical letters before a different letter is found.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCountLetterChanges(unittest.TestCase):\n\n    def test_count_consecutive_letters_correctly(self):\n        result = count_letter_changes(\"aaabbcdeee\")\n        self.assertEqual(result, [3, 2, 1, 1, 3])\n\n    def test_single_character_count(self):\n        result = count_letter_changes(\"a\")\n        self.assertEqual(result, [1])\n\n    def test_no_consecutive_letters(self):\n        result = count_letter_changes(\"abcdef\")\n        self.assertEqual(result, [1, 1, 1, 1, 1, 1])\n\n    def test_identical_letters(self):\n        result = count_letter_changes(\"rrrrrr\")\n        self.assertEqual(result, [6])\n\n    def test_long_string_random_letters(self):\n        result = count_letter_changes(\"xxxyyyzzzaaaab\")\n        self.assertEqual(result, [3, 3, 3, 4, 1])\n\n    def test_numeric_characters(self):\n        result = count_letter_changes(\"1122334455\")\n        self.assertEqual(result, [2, 2, 2, 2, 2])\n", "prompt": "please write a python function , the function signature as below def count_letter_changes(input_string: str) -> list:\n    \"\"\"Counts the occurrences of consecutive identical letters in a given string.\n\n    Args:\n        input_string (str): The string to analyze for letter changes.\n\n    Returns:\n        list: A list of counts representing the number of consecutive\n              identical letters before a different letter is found.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Counts the occurrences of consecutive identical letters in a given string.\n *\n * @param inputString - The string to analyze for letter changes.\n * @returns A vector of counts representing the number of consecutive\n *          identical letters before a different letter is found.\n */\nstd::vector<int> countLetterChanges(const std::string& inputString) {}", "test_code": "TEST_CASE(\"countLetterChanges\", \"[countLetterChanges]\") {\n    SECTION(\"should count consecutive letters correctly\") {\n        auto result = countLetterChanges(\"aaabbcdeee\");\n        REQUIRE(result == std::vector<int>{3, 2, 1, 1, 3});\n    }\n\n    SECTION(\"should return an array with one count for a single character\") {\n        auto result = countLetterChanges(\"a\");\n        REQUIRE(result == std::vector<int>{1});\n    }\n\n    SECTION(\"should return counts for a string with no consecutive letters\") {\n        auto result = countLetterChanges(\"abcdef\");\n        REQUIRE(result == std::vector<int>{1, 1, 1, 1, 1, 1});\n    }\n\n    SECTION(\"should handle a string with only identical letters\") {\n        auto result = countLetterChanges(\"rrrrrr\");\n        REQUIRE(result == std::vector<int>{6});\n    }\n\n    SECTION(\"should handle a long string with random letters\") {\n        auto result = countLetterChanges(\"xxxyyyzzzaaaab\");\n        REQUIRE(result == std::vector<int>{3, 3, 3, 4, 1});\n    }\n\n    SECTION(\"should handle numeric characters in the string\") {\n        auto result = countLetterChanges(\"1122334455\");\n        REQUIRE(result == std::vector<int>{2, 2, 2, 2, 2});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Counts the occurrences of consecutive identical letters in a given string.\n *\n * @param inputString - The string to analyze for letter changes.\n * @returns A vector of counts representing the number of consecutive\n *          identical letters before a different letter is found.\n */\nstd::vector<int> countLetterChanges(const std::string& inputString) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Counts the occurrences of consecutive identical letters in a given string.\n *\n * @param inputString The string to analyze for letter changes.\n * @returns A list of counts representing the number of consecutive\n *          identical letters before a different letter is found.\n */\npublic static List<Integer> countLetterChanges(String inputString) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testCountConsecutiveLettersCorrectly() {\n        List<Integer> result = LetterChangeCounter.countLetterChanges(\"aaabbcdeee\");\n        assertEquals(Arrays.asList(3, 2, 1, 1, 3), result);\n    }\n\n    @Test\n    public void testSingleCharacter() {\n        List<Integer> result = LetterChangeCounter.countLetterChanges(\"a\");\n        assertEquals(Arrays.asList(1), result);\n    }\n\n    @Test\n    public void testNoConsecutiveLetters() {\n        List<Integer> result = LetterChangeCounter.countLetterChanges(\"abcdef\");\n        assertEquals(Arrays.asList(1, 1, 1, 1, 1, 1), result);\n    }\n\n    @Test\n    public void testIdenticalLetters() {\n        List<Integer> result = LetterChangeCounter.countLetterChanges(\"rrrrrr\");\n        assertEquals(Arrays.asList(6), result);\n    }\n\n    @Test\n    public void testLongStringWithRandomLetters() {\n        List<Integer> result = LetterChangeCounter.countLetterChanges(\"xxxyyyzzzaaaab\");\n        assertEquals(Arrays.asList(3, 3, 3, 4, 1), result);\n    }\n\n    @Test\n    public void testNumericCharactersInString() {\n        List<Integer> result = LetterChangeCounter.countLetterChanges(\"1122334455\");\n        assertEquals(Arrays.asList(2, 2, 2, 2, 2), result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Counts the occurrences of consecutive identical letters in a given string.\n *\n * @param inputString The string to analyze for letter changes.\n * @returns A list of counts representing the number of consecutive\n *          identical letters before a different letter is found.\n */\npublic static List<Integer> countLetterChanges(String inputString) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 533, "code_type": "method", "original_language": "javascript", "file_path": "Using-Konduktiva-With-MIDI\\554f86a5e9de09730cafe86ec9d27e131bb86600\\utilities-string.js\n", "question_type": "Data processing and transformation", "summary": "Shuffles the characters in a given string randomly.", "language_version_list": {"python": {"code_signature": "def shuffle_string(input_string: str) -> str:\n    \"\"\"Shuffles the characters in a given string randomly.\n\n    Args:\n        input_string (str): The string to shuffle.\n\n    Returns:\n        str: A new string with the characters shuffled.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestShuffleString(unittest.TestCase):\n\n    def test_same_length(self):\n        input_string = \"abcdef\"\n        result = shuffle_string(input_string)\n        self.assertEqual(len(result), len(input_string))\n\n    def test_shuffle_characters(self):\n        input_string = \"hello\"\n        result = shuffle_string(input_string)\n        self.assertNotEqual(result, input_string)  # It should be different most of the time\n\n    def test_empty_string(self):\n        input_string = \"\"\n        result = shuffle_string(input_string)\n        self.assertEqual(result, \"\")  # Should return an empty string\n\n    def test_single_character(self):\n        input_string = \"a\"\n        result = shuffle_string(input_string)\n        self.assertEqual(result, \"a\")  # Should return the same single character\n\n    def test_identical_characters(self):\n        input_string = \"aaaaa\"\n        result = shuffle_string(input_string)\n        self.assertEqual(result, \"aaaaa\")  # Should return the same string\n\n    def test_long_string(self):\n        input_string = \"abcdefghijklmnopqrstuvwxyz\"\n        result = shuffle_string(input_string)\n        self.assertNotEqual(result, input_string)  # It should be different most of the time\n        self.assertEqual(len(result), len(input_string))  # Length should be the same\n\n    def test_same_string_characters(self):\n        input_string = \"111111\"\n        result = shuffle_string(input_string)\n        self.assertEqual(result, \"111111\")  # Should return the same string\n\n    def test_special_characters(self):\n        input_string = \"a!@#$%^&*()_+\"\n        result = shuffle_string(input_string)\n        self.assertEqual(len(result), len(input_string))  # Length should be the same\n        self.assertNotEqual(result, input_string)  # It should be different most of the time\n", "prompt": "please write a python function , the function signature as below def shuffle_string(input_string: str) -> str:\n    \"\"\"Shuffles the characters in a given string randomly.\n\n    Args:\n        input_string (str): The string to shuffle.\n\n    Returns:\n        str: A new string with the characters shuffled.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Shuffles the characters in a given string randomly.\n *\n * @param inputString The string to shuffle.\n * @returns A new string with the characters shuffled.\n */\nstd::string shuffleString(const std::string& inputString) {}", "test_code": "TEST_CASE(\"shuffleString\") {\n    SECTION(\"should return a string of the same length as the input\") {\n        std::string input = \"abcdef\";\n        std::string result = shuffleString(input);\n        REQUIRE(result.length() == input.length());\n    }\n\n    SECTION(\"should shuffle the characters in the string\") {\n        std::string input = \"hello\";\n        std::string result = shuffleString(input);\n        REQUIRE(result != input); // It should be different most of the time\n    }\n\n    SECTION(\"should return an empty string when given an empty string\") {\n        std::string input = \"\";\n        std::string result = shuffleString(input);\n        REQUIRE(result == \"\"); // Should return an empty string\n    }\n\n    SECTION(\"should handle a single character string\") {\n        std::string input = \"a\";\n        std::string result = shuffleString(input);\n        REQUIRE(result == \"a\"); // Should return the same single character\n    }\n\n    SECTION(\"should handle strings with identical characters\") {\n        std::string input = \"aaaaa\";\n        std::string result = shuffleString(input);\n        REQUIRE(result == \"aaaaa\"); // Should return the same string\n    }\n\n    SECTION(\"should return a shuffled string for longer strings\") {\n        std::string input = \"abcdefghijklmnopqrstuvwxyz\";\n        std::string result = shuffleString(input);\n        REQUIRE(result != input); // It should be different most of the time\n        REQUIRE(result.length() == input.length()); // Length should be the same\n    }\n\n    SECTION(\"should return the same string if all characters are the same\") {\n        std::string input = \"111111\";\n        std::string result = shuffleString(input);\n        REQUIRE(result == \"111111\"); // Should return the same string\n    }\n\n    SECTION(\"should shuffle a string containing special characters\") {\n        std::string input = \"a!@#$%^&*()_+\";\n        std::string result = shuffleString(input);\n        REQUIRE(result.length() == input.length()); // Length should be the same\n        REQUIRE(result != input); // It should be different most of the time\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Shuffles the characters in a given string randomly.\n *\n * @param inputString The string to shuffle.\n * @returns A new string with the characters shuffled.\n */\nstd::string shuffleString(const std::string& inputString) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Shuffles the characters in a given string randomly.\n *\n * @param inputString The string to shuffle.\n * @return A new string with the characters shuffled.\n */\npublic static String shuffleString(String inputString) {}\n", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testShuffleStringLength() {\n        String input = \"abcdef\";\n        String result = StringShuffler.shuffleString(input);\n        assertEquals(input.length(), result.length());\n    }\n\n    @Test\n    public void testShuffleStringCharacters() {\n        String input = \"hello\";\n        String result = StringShuffler.shuffleString(input);\n        assertNotEquals(input, result); // It should be different most of the time\n    }\n\n    @Test\n    public void testShuffleStringEmpty() {\n        String input = \"\";\n        String result = StringShuffler.shuffleString(input);\n        assertEquals(\"\", result); // Should return an empty string\n    }\n\n    @Test\n    public void testShuffleStringSingleCharacter() {\n        String input = \"a\";\n        String result = StringShuffler.shuffleString(input);\n        assertEquals(\"a\", result); // Should return the same single character\n    }\n\n    @Test\n    public void testShuffleStringIdenticalCharacters() {\n        String input = \"aaaaa\";\n        String result = StringShuffler.shuffleString(input);\n        assertEquals(\"aaaaa\", result); // Should return the same string\n    }\n\n    @Test\n    public void testShuffleStringLongerString() {\n        String input = \"abcdefghijklmnopqrstuvwxyz\";\n        String result = StringShuffler.shuffleString(input);\n        assertNotEquals(input, result); // It should be different most of the time\n        assertEquals(input.length(), result.length()); // Length should be the same\n    }\n\n    @Test\n    public void testShuffleStringSameCharacters() {\n        String input = \"111111\";\n        String result = StringShuffler.shuffleString(input);\n        assertEquals(\"111111\", result); // Should return the same string\n    }\n\n    @Test\n    public void testShuffleStringSpecialCharacters() {\n        String input = \"a!@#$%^&*()_+\";\n        String result = StringShuffler.shuffleString(input);\n        assertEquals(input.length(), result.length()); // Length should be the same\n        assertNotEquals(input, result); // It should be different most of the time\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Shuffles the characters in a given string randomly.\n *\n * @param inputString The string to shuffle.\n * @return A new string with the characters shuffled.\n */\npublic static String shuffleString(String inputString) {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 534, "code_type": "method", "original_language": "javascript", "file_path": "Bing-Chat-History\\a9b013bc573b42d867b0ad23e884928947a0c167\\src\\pages\\js\\utility.js\n", "question_type": "Algorithm and data structure", "summary": "Removes the first occurrence of a specified element from an array.", "language_version_list": {"python": {"code_signature": "def remove_element_in_array(array:list, element)->list:\n    \"\"\"\n    Removes the first occurrence of a specified element from a list.\n\n    Args:\n        array (list): The list from which to remove the element.\n        element: The element to remove from the list.\n\n    Returns:\n        list: A new list with the element removed, or the original list if the element is not found.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestRemoveElementInArray(unittest.TestCase):\n\n    def test_returns_original_array_when_element_not_found(self):\n        result = remove_element_in_array([1, 2, 3, 4], 5)\n        self.assertEqual(result, [1, 2, 3, 4])\n\n    def test_handles_empty_array_correctly(self):\n        result = remove_element_in_array([], 1)\n        self.assertEqual(result, [])\n\n    def test_removes_element_from_array_of_objects(self):\n        obj1 = {'id': 1}\n        obj2 = {'id': 2}\n        obj3 = {'id': 3}\n        result = remove_element_in_array([obj1, obj2, obj3], obj2)\n        self.assertEqual(result, [obj1, obj3])\n\n    def test_does_not_modify_original_array(self):\n        original_array = [1, 2, 3]\n        result = remove_element_in_array(original_array, 2)\n        self.assertEqual(original_array, [1, 2, 3])\n        self.assertEqual(result, [1, 3])\n", "prompt": "please write a python function , the function signature as below def remove_element_in_array(array:list, element)->list:\n    \"\"\"\n    Removes the first occurrence of a specified element from a list.\n\n    Args:\n        array (list): The list from which to remove the element.\n        element: The element to remove from the list.\n\n    Returns:\n        list: A new list with the element removed, or the original list if the element is not found.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Removes the first occurrence of a specified element from a vector.\n *\n * @param {std::vector<int>} array - The vector from which to remove the element.\n * @param {int} element - The element to remove from the vector.\n * @returns {std::vector<int>} A new vector with the element removed, or the original vector if the element is not found.\n */\nstd::vector<int> removeElementInArray(const std::vector<int>& array, int element) {\n    \n}", "test_code": "TEST_CASE(\"removeElementInArray\", \"[removeElementInArray]\") {\n    SECTION(\"returns the original array when the element is not found\") {\n        std::vector<int> result = removeElementInArray({1, 2, 3, 4}, 5);\n        REQUIRE(result == std::vector<int>({1, 2, 3, 4}));\n    }\n\n    SECTION(\"handles an empty array correctly\") {\n        std::vector<int> result = removeElementInArray({}, 1);\n        REQUIRE(result == std::vector<int>({}));\n    }\n\n    SECTION(\"removes an element from a vector of objects\") {\n        struct Obj {\n            int id;\n            bool operator==(const Obj& other) const {\n                return id == other.id;\n            }\n        };\n        \n        Obj obj1{1}, obj2{2}, obj3{3};\n        std::vector<Obj> result = removeElementInArray({obj1, obj2, obj3}, obj2);\n        REQUIRE(result == std::vector<Obj>({obj1, obj3}));\n    }\n\n    SECTION(\"does not modify the original array\") {\n        std::vector<int> originalArray = {1, 2, 3};\n        std::vector<int> result = removeElementInArray(originalArray, 2);\n        REQUIRE(originalArray == std::vector<int>({1, 2, 3}));\n        REQUIRE(result == std::vector<int>({1, 3}));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Removes the first occurrence of a specified element from a vector.\n *\n * @param {std::vector<int>} array - The vector from which to remove the element.\n * @param {int} element - The element to remove from the vector.\n * @returns {std::vector<int>} A new vector with the element removed, or the original vector if the element is not found.\n */\nstd::vector<int> removeElementInArray(const std::vector<int>& array, int element) {\n    \n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Removes the first occurrence of a specified element from a list.\n *\n * @param list - The list from which to remove the element.\n * @param element - The element to remove from the list.\n * @return A new list with the element removed, or the original list if the element is not found.\n */\npublic static <T> List<T> removeElementInArray(List<T> list, T element) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testReturnsOriginalArrayWhenElementNotFound() {\n        List<Integer> result = Answer.removeElementInArray(List.of(1, 2, 3, 4), 5);\n        assertEquals(List.of(1, 2, 3, 4), result);\n    }\n\n    @Test\n    public void testHandlesEmptyArrayCorrectly() {\n        List<Integer> result = Answer.removeElementInArray(new ArrayList<>(), 1);\n        assertEquals(new ArrayList<>(), result);\n    }\n\n    @Test\n    public void testRemovesElementFromArrayOfObjects() {\n        Object obj1 = new MyObject(1);\n        Object obj2 = new MyObject(2);\n        Object obj3 = new MyObject(3);\n        List<Object> result = Answer.removeElementInArray(List.of(obj1, obj2, obj3), obj2);\n        assertEquals(List.of(obj1, obj3), result);\n    }\n\n    @Test\n    public void testDoesNotModifyOriginalArray() {\n        List<Integer> originalArray = new ArrayList<>(List.of(1, 2, 3));\n        List<Integer> result = Answer.removeElementInArray(originalArray, 2);\n        assertEquals(List.of(1, 2, 3), originalArray);\n        assertEquals(List.of(1, 3), result);\n    }\n\n    private static class MyObject {\n        private int id;\n\n        public MyObject(int id) {\n            this.id = id;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            MyObject myObject = (MyObject) obj;\n            return id == myObject.id;\n        }\n\n        @Override\n        public int hashCode() {\n            return Integer.hashCode(id);\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Removes the first occurrence of a specified element from a list.\n *\n * @param list - The list from which to remove the element.\n * @param element - The element to remove from the list.\n * @return A new list with the element removed, or the original list if the element is not found.\n */\npublic static <T> List<T> removeElementInArray(List<T> list, T element) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 535, "code_type": "method", "original_language": "javascript", "file_path": "Bing-Chat-History\\a9b013bc573b42d867b0ad23e884928947a0c167\\src\\pages\\js\\utility.js\n", "question_type": "Data processing and transformation", "summary": "Compresses an HTML string by removing unnecessary whitespace,\nincluding newlines, tabs, and extra spaces,\nwhile preserving the structure of the HTML.", "language_version_list": {"python": {"code_signature": "def compress_html(html: str) -> str:\n    \"\"\"\n    Compresses an HTML string by removing unnecessary whitespace,\n    including newlines, tabs, and extra spaces,\n    while preserving the structure of the HTML.\n\n    Args:\n        html (str): The input HTML string to be compressed.\n\n    Returns:\n        str: The compressed HTML string with reduced whitespace.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCompressHtml(unittest.TestCase):\n\n    def test_remove_newlines_and_tabs(self):\n        input_html = \"\"\"            <div>                <p>Test paragraph.</p>            </div>        \"\"\"\n        expected_output = '<div><p>Test paragraph.</p></div>'\n        self.assertEqual(compress_html(input_html), expected_output)\n\n    def test_replace_multiple_spaces(self):\n        input_html = '<div>    <p>     Test with     multiple spaces.   </p></div>'\n        expected_output = '<div><p> Test with multiple spaces. </p></div>'\n        self.assertEqual(compress_html(input_html), expected_output)\n\n    def test_remove_spaces_between_tags(self):\n        input_html = '<div> <p>Test</p> </div>'\n        expected_output = '<div><p>Test</p></div>'\n        self.assertEqual(compress_html(input_html), expected_output)\n\n    def test_handle_empty_input(self):\n        input_html = ''\n        expected_output = ''\n        self.assertEqual(compress_html(input_html), expected_output)\n\n    def test_handle_html_with_only_spaces_and_newlines(self):\n        input_html = \"\"\"            <div>                  </div>        \"\"\"\n        expected_output = '<div></div>'\n        self.assertEqual(compress_html(input_html), expected_output)\n", "prompt": "please write a python function , the function signature as below def compress_html(html: str) -> str:\n    \"\"\"\n    Compresses an HTML string by removing unnecessary whitespace,\n    including newlines, tabs, and extra spaces,\n    while preserving the structure of the HTML.\n\n    Args:\n        html (str): The input HTML string to be compressed.\n\n    Returns:\n        str: The compressed HTML string with reduced whitespace.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace,\n * including newlines, tabs, and extra spaces,\n * while preserving the structure of the HTML.\n *\n * @param std::string html - The input HTML string to be compressed.\n * @returns std::string - The compressed HTML string with reduced whitespace.\n */\nstd::string compressHtml(const std::string& html) {\n}", "test_code": "TEST_CASE(\"compressHtml\", \"[html]\") {\n    SECTION(\"should remove newlines and tabs\") {\n        std::string input = R\"(\n            <div>\n                <p>Test paragraph.</p>\n            </div>\n        )\";\n        std::string expectedOutput = \"<div><p>Test paragraph.</p></div>\";\n        REQUIRE(compressHtml(input) == expectedOutput);\n    }\n\n    SECTION(\"should replace multiple spaces with a single space\") {\n        std::string input = \"<div>    <p>     Test with     multiple spaces.   </p></div>\";\n        std::string expectedOutput = \"<div><p> Test with multiple spaces. </p></div>\";\n        REQUIRE(compressHtml(input) == expectedOutput);\n    }\n\n    SECTION(\"should remove spaces between HTML tags\") {\n        std::string input = \"<div> <p>Test</p> </div>\";\n        std::string expectedOutput = \"<div><p>Test</p></div>\";\n        REQUIRE(compressHtml(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle empty input\") {\n        std::string input = \"\";\n        std::string expectedOutput = \"\";\n        REQUIRE(compressHtml(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle HTML with only spaces and newlines\") {\n        std::string input = R\"(\n            <div>      \n            </div>\n        )\";\n        std::string expectedOutput = \"<div></div>\";\n        REQUIRE(compressHtml(input) == expectedOutput);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace,\n * including newlines, tabs, and extra spaces,\n * while preserving the structure of the HTML.\n *\n * @param std::string html - The input HTML string to be compressed.\n * @returns std::string - The compressed HTML string with reduced whitespace.\n */\nstd::string compressHtml(const std::string& html) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace,\n * including newlines, tabs, and extra spaces,\n * while preserving the structure of the HTML.\n *\n * @param html The input HTML string to be compressed.\n * @return The compressed HTML string with reduced whitespace.\n */\npublic static String compressHtml(String html) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testRemoveNewlinesAndTabs() {\n        String input = \"\\n            <div>\\n                <p>Test paragraph.</p>\\n            </div>\\n        \";\n        String expectedOutput = \"<div><p>Test paragraph.</p></div>\";\n        assertEquals(expectedOutput, Answer.compressHtml(input));\n    }\n\n    @Test\n    public void testReplaceMultipleSpaces() {\n        String input = \"<div>    <p>     Test with     multiple spaces.   </p></div>\";\n        String expectedOutput = \"<div><p> Test with multiple spaces. </p></div>\";\n        assertEquals(expectedOutput, Answer.compressHtml(input));\n    }\n\n    @Test\n    public void testRemoveSpacesBetweenTags() {\n        String input = \"<div> <p>Test</p> </div>\";\n        String expectedOutput = \"<div><p>Test</p></div>\";\n        assertEquals(expectedOutput, Answer.compressHtml(input));\n    }\n\n    @Test\n    public void testHandleEmptyInput() {\n        String input = \"\";\n        String expectedOutput = \"\";\n        assertEquals(expectedOutput, Answer.compressHtml(input));\n    }\n\n    @Test\n    public void testHandleSpacesAndNewlines() {\n        String input = \"\\n            <div>      \\n            </div>\\n        \";\n        String expectedOutput = \"<div></div>\";\n        assertEquals(expectedOutput, Answer.compressHtml(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace,\n * including newlines, tabs, and extra spaces,\n * while preserving the structure of the HTML.\n *\n * @param html The input HTML string to be compressed.\n * @return The compressed HTML string with reduced whitespace.\n */\npublic static String compressHtml(String html) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 536, "code_type": "method", "original_language": "javascript", "file_path": "Bing-Chat-History\\a9b013bc573b42d867b0ad23e884928947a0c167\\src\\pages\\js\\utility.js\n", "question_type": "Data processing and transformation", "summary": "Gets the current date formatted as 'Month Day, Year'.", "language_version_list": {"python": {"code_signature": "def get_date() -> str:\n    \"\"\"\n    Gets the current date formatted as 'Month Day, Year'.\n\n    Returns:\n        str: The formatted date string.\n    \"\"\"", "test_code": "import unittest\nfrom datetime import datetime\nfrom unittest.mock import patch\n\n\nclass TestGetDate(unittest.TestCase):\n\n    @patch('datetime.datetime')\n    def setUp(self, mock_datetime):\n        # Mock the datetime to return a specific date\n        mock_datetime.now.return_value = datetime(2024, 10, 1)\n\n    def test_returns_date_in_format(self):\n        result = get_date()\n        self.assertEqual(result, 'October 1, 2024')\n\n    def test_returns_correct_year(self):\n        result = get_date()\n        self.assertIn('2024', result)\n\n    def test_returns_correct_month(self):\n        result = get_date()\n        self.assertIn('October', result)\n\n    def test_returns_correct_day(self):\n        result = get_date()\n        self.assertIn('1', result)\n\n    def test_returns_date_as_string(self):\n        result = get_date()\n        self.assertIsInstance(result, str)\n\n    def test_does_not_return_none(self):\n        result = get_date()\n        self.assertIsNotNone(result)\n", "prompt": "please write a python function , the function signature as below def get_date() -> str:\n    \"\"\"\n    Gets the current date formatted as 'Month Day, Year'.\n\n    Returns:\n        str: The formatted date string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Gets the current date formatted as 'Month Day, Year'.\n *\n * @returns A string containing the formatted date.\n */\nstd::string getDate() {}", "test_code": "std::string getDate() {\n    // Normally would return the actual date; here we simulate for testing\n    return \"October 1, 2024\"; \n}\n\nTEST_CASE(\"getDate\", \"[date]\") {\n    SECTION(\"returns date in 'Month Day, Year' format\") {\n        REQUIRE(getDate() == \"October 1, 2024\");\n    }\n\n    SECTION(\"returns correct year\") {\n        REQUIRE(getDate().find(\"2024\") != std::string::npos);\n    }\n\n    SECTION(\"returns correct month\") {\n        REQUIRE(getDate().find(\"October\") != std::string::npos);\n    }\n\n    SECTION(\"returns correct day\") {\n        REQUIRE(getDate().find(\"1\") != std::string::npos);\n    }\n\n    SECTION(\"returns date as a string\") {\n        REQUIRE(typeid(getDate()).name() == typeid(std::string).name());\n    }\n\n    SECTION(\"does not return undefined\") {\n        REQUIRE_FALSE(getDate().empty());\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Gets the current date formatted as 'Month Day, Year'.\n *\n * @returns A string containing the formatted date.\n */\nstd::string getDate() {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Gets the current date formatted as 'Month Day, Year'.\n *\n * @return The formatted date string.\n */\npublic static String getDate() {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\npublic class Tester {\n    private Date originalDate;\n\n    @Before\n    public void setUp() {\n        // Mock the current date\n        originalDate = new Date();\n        System.setProperty(\"current.test.date\", \"2024-10-01T00:00:00Z\");\n    }\n\n    @After\n    public void tearDown() {\n        // Restore the original date if needed\n        System.clearProperty(\"current.test.date\");\n    }\n\n    private String getDate() {\n        // Get the mocked date\n        String testDate = System.getProperty(\"current.test.date\");\n        Date currentDate = new Date(testDate);\n        \n        // Define the date format\n        SimpleDateFormat formatter = new SimpleDateFormat(\"MMMM d, yyyy\", Locale.ENGLISH);\n        \n        // Return the formatted date string\n        return formatter.format(currentDate);\n    }\n\n    @Test\n    public void testReturnsDateInMonthDayYearFormat() {\n        String result = getDate();\n        assertEquals(\"October 1, 2024\", result);\n    }\n\n    @Test\n    public void testReturnsCorrectYear() {\n        String result = getDate();\n        assertTrue(result.matches(\".*2024.*\"));\n    }\n\n    @Test\n    public void testReturnsCorrectMonth() {\n        String result = getDate();\n        assertTrue(result.matches(\".*October.*\"));\n    }\n\n    @Test\n    public void testReturnsCorrectDay() {\n        String result = getDate();\n        assertTrue(result.matches(\".*1.*\"));\n    }\n\n    @Test\n    public void testReturnsDateAsString() {\n        String result = getDate();\n        assertTrue(result instanceof String);\n    }\n\n    @Test\n    public void testDoesNotReturnUndefined() {\n        String result = getDate();\n        assertNotNull(result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Gets the current date formatted as 'Month Day, Year'.\n *\n * @return The formatted date string.\n */\npublic static String getDate() {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 537, "code_type": "method", "original_language": "javascript", "file_path": "Bing-Chat-History\\a9b013bc573b42d867b0ad23e884928947a0c167\\src\\pages\\js\\utility.js\n", "question_type": "Data processing and transformation", "summary": "Gets the current time formatted as 'hh:mm AM/PM'.", "language_version_list": {"python": {"code_signature": "def get_time() -> str:\n    \"\"\"\n    Gets the current time formatted as 'hh:mm AM/PM'.\n\n    Returns:\n        str: The formatted time string.\n    \"\"\"", "test_code": "import unittest\nfrom datetime import datetime\nfrom unittest.mock import patch\n\n\nclass TestGetTime(unittest.TestCase):\n\n    def mock_datetime(self, date_string):\n        \"\"\"Mock the datetime to return a specific date.\"\"\"\n        class MockDate(datetime):\n            @classmethod\n            def now(cls):\n                return datetime.strptime(date_string, '%Y-%m-%dT%H:%M:%S')\n\n        return MockDate\n\n    @patch('datetime.datetime', new_callable=lambda: datetime)\n    def test_should_return_a_string(self, mock_datetime):\n        mock_datetime.now = self.mock_datetime('2024-10-01T10:30:00').now\n        result = get_time()\n        self.assertIsInstance(result, str)\n\n    @patch('datetime.datetime', new_callable=lambda: datetime)\n    def test_should_return_formatted_time_string_including_AM_PM(self, mock_datetime):\n        mock_datetime.now = self.mock_datetime('2024-10-01T15:45:00').now\n        result = get_time()\n        self.assertRegex(result, r'^\\d{1,2}:\\d{2} (AM|PM)$')\n\n    @patch('datetime.datetime', new_callable=lambda: datetime)\n    def test_should_return_correct_time_during_AM_hours(self, mock_datetime):\n        mock_datetime.now = self.mock_datetime('2024-10-01T08:15:00').now\n        result = get_time()\n        self.assertEqual(result, '08:15 AM')\n\n    @patch('datetime.datetime', new_callable=lambda: datetime)\n    def test_should_return_correct_time_during_PM_hours(self, mock_datetime):\n        mock_datetime.now = self.mock_datetime('2024-10-01T17:20:00').now\n        result = get_time()\n        self.assertEqual(result, '05:20 PM')\n\n    @patch('datetime.datetime', new_callable=lambda: datetime)\n    def test_should_return_12_00_AM_at_midnight(self, mock_datetime):\n        mock_datetime.now = self.mock_datetime('2024-10-01T00:00:00').now\n        result = get_time()\n        self.assertEqual(result, '12:00 AM')\n\n    @patch('datetime.datetime', new_callable=lambda: datetime)\n    def test_should_return_12_00_PM_at_noon(self, mock_datetime):\n        mock_datetime.now = self.mock_datetime('2024-10-01T12:00:00').now\n        result = get_time()\n        self.assertEqual(result, '12:00 PM')\n\n    @patch('datetime.datetime', new_callable=lambda: datetime)\n    def test_should_handle_single_digit_minutes_correctly(self, mock_datetime):\n        mock_datetime.now = self.mock_datetime('2024-10-01T09:05:00').now\n        result = get_time()\n        self.assertEqual(result, '09:05 AM')\n", "prompt": "please write a python function , the function signature as below def get_time() -> str:\n    \"\"\"\n    Gets the current time formatted as 'hh:mm AM/PM'.\n\n    Returns:\n        str: The formatted time string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Gets the current time formatted as 'hh:mm AM/PM'.\n *\n * @returns The formatted time string.\n */\nstd::string getTime();", "test_code": "std::string getTime() {\n    std::time_t now = std::time(nullptr);\n    std::tm *localTime = std::localtime(&now);\n    std::ostringstream oss;\n    oss << std::put_time(localTime, \"%I:%M %p\");\n    return oss.str();\n}\n\nTEST_CASE(\"getTime\") {\n    // Mocking function to set a specific time\n    auto mockDate = [](const std::string& dateString) {\n        std::tm tm = {};\n        std::istringstream ss(dateString);\n        ss >> std::get_time(&tm, \"%Y-%m-%dT%H:%M:%S\");\n        std::time_t mockTime = std::mktime(&tm);\n        std::tm *localTime = std::localtime(&mockTime);\n        return localTime;\n    };\n\n    SECTION(\"should return a string\") {\n        std::tm* mockTime = mockDate(\"2024-10-01T10:30:00\");\n        std::string result = getTime(); // Adjust this to use mocked time in your actual implementation\n        REQUIRE(result.length() > 0);\n    }\n\n    SECTION(\"should return a formatted time string including AM/PM\") {\n        std::tm* mockTime = mockDate(\"2024-10-01T15:45:00\");\n        std::string result = getTime(); // Adjust this to use mocked time\n        REQUIRE(std::regex_match(result, std::regex(\"^\\\\d{1,2}:\\\\d{2} (AM|PM)$\")));\n    }\n\n    SECTION(\"should return the correct time during AM hours\") {\n        std::tm* mockTime = mockDate(\"2024-10-01T08:15:00\");\n        std::string result = getTime(); // Adjust this to use mocked time\n        REQUIRE(result == \"8:15 AM\");\n    }\n\n    SECTION(\"should return the correct time during PM hours\") {\n        std::tm* mockTime = mockDate(\"2024-10-01T17:20:00\");\n        std::string result = getTime(); // Adjust this to use mocked time\n        REQUIRE(result == \"5:20 PM\");\n    }\n\n    SECTION(\"should return '12:00 AM' at midnight\") {\n        std::tm* mockTime = mockDate(\"2024-10-01T00:00:00\");\n        std::string result = getTime(); // Adjust this to use mocked time\n        REQUIRE(result == \"12:00 AM\");\n    }\n\n    SECTION(\"should return '12:00 PM' at noon\") {\n        std::tm* mockTime = mockDate(\"2024-10-01T12:00:00\");\n        std::string result = getTime(); // Adjust this to use mocked time\n        REQUIRE(result == \"12:00 PM\");\n    }\n\n    SECTION(\"should handle single-digit minutes correctly\") {\n        std::tm* mockTime = mockDate(\"2024-10-01T09:05:00\");\n        std::string result = getTime(); // Adjust this to use mocked time\n        REQUIRE(result == \"9:05 AM\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Gets the current time formatted as 'hh:mm AM/PM'.\n *\n * @returns The formatted time string.\n */\nstd::string getTime();", "addition_info": ""}, "java": {"code_signature": "/**\n * Gets the current time formatted as 'hh:mm AM/PM'.\n *\n * @returns {String} The formatted time string.\n */\npublic String getTime() {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\npublic class Tester {\n    private static final String originalTimeZone = TimeZone.getDefault().getID();\n\n    @Before\n    public void setUp() {\n        TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\")); // Set a consistent timezone for testing\n    }\n\n    @After\n    public void tearDown() {\n        TimeZone.setDefault(TimeZone.getTimeZone(originalTimeZone)); // Restore original timezone\n    }\n\n    private String mockDate(String dateString) {\n        System.setProperty(\"current.time\", dateString); // Simulate mock date (you would need to implement this in getTime)\n        return getTime();\n    }\n\n    @Test\n    public void shouldReturnAString() {\n        String result = mockDate(\"2024-10-01T10:30:00\");\n        assertTrue(result instanceof String);\n    }\n\n    @Test\n    public void shouldReturnFormattedTimeStringIncludingAMPM() {\n        String result = mockDate(\"2024-10-01T15:45:00\");\n        assertTrue(result.matches(\"^\\\\d{1,2}:\\\\d{2} (AM|PM)$\"));\n    }\n\n    @Test\n    public void shouldReturnCorrectTimeDuringAMHours() {\n        String result = mockDate(\"2024-10-01T08:15:00\");\n        assertEquals(\"8:15 AM\", result);\n    }\n\n    @Test\n    public void shouldReturnCorrectTimeDuringPMHours() {\n        String result = mockDate(\"2024-10-01T17:20:00\");\n        assertEquals(\"5:20 PM\", result);\n    }\n\n    @Test\n    public void shouldReturn12AMAtMidnight() {\n        String result = mockDate(\"2024-10-01T00:00:00\");\n        assertEquals(\"12:00 AM\", result);\n    }\n\n    @Test\n    public void shouldReturn12PMAtNoon() {\n        String result = mockDate(\"2024-10-01T12:00:00\");\n        assertEquals(\"12:00 PM\", result);\n    }\n\n    @Test\n    public void shouldHandleSingleDigitMinutesCorrectly() {\n        String result = mockDate(\"2024-10-01T09:05:00\");\n        assertEquals(\"9:05 AM\", result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Gets the current time formatted as 'hh:mm AM/PM'.\n *\n * @returns {String} The formatted time string.\n */\npublic String getTime() {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 538, "code_type": "method", "original_language": "javascript", "file_path": "utilsNodeJs\\8bd1fec924b2b1141b47c2a10911ed8035002918\\src\\Sorter.js\n", "question_type": "Data processing and transformation", "summary": "Sorts an array of objects alphabetically based on a specified field.", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 540, "code_type": "method", "original_language": "javascript", "file_path": "contrast-color-picker\\f66d5be01d5eb6727d4a4d7c3705fbb2cdbe0659\\site\\lib\\getCombos.js\n", "question_type": "Algorithm and data structure", "summary": "Generates all unique combinations of pairs from an array.", "language_version_list": {"python": {"code_signature": "def generate_unique_pairs(array: list) -> list:\n    \"\"\"\n    Generates all unique combinations of pairs from a list.\n\n    Args:\n        array (list): The input list from which combinations are generated.\n\n    Returns:\n        list of lists: A list of lists, where each inner list contains a unique pair of elements.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGenerateUniquePairs(unittest.TestCase):\n\n    def test_generates_unique_pairs_from_three_elements(self):\n        items = ['A', 'B', 'C']\n        result = generate_unique_pairs(items)\n        self.assertEqual(result, [['A', 'B'], ['A', 'C'], ['B', 'C']])\n\n    def test_generates_unique_pairs_from_two_elements(self):\n        items = ['A', 'B']\n        result = generate_unique_pairs(items)\n        self.assertEqual(result, [['A', 'B']])\n\n    def test_returns_empty_array_when_input_array_is_empty(self):\n        items = []\n        result = generate_unique_pairs(items)\n        self.assertEqual(result, [])\n\n    def test_returns_empty_array_when_input_array_has_one_element(self):\n        items = ['A']\n        result = generate_unique_pairs(items)\n        self.assertEqual(result, [])\n\n    def test_handles_array_with_different_types_of_elements(self):\n        items = [1, 'A', {'key': 'value'}]\n        result = generate_unique_pairs(items)\n        self.assertEqual(result, [[1, 'A'], [1, {'key': 'value'}], ['A', {'key': 'value'}]])\n\n    def test_generates_pairs_from_array_with_more_than_three_elements(self):\n        items = ['A', 'B', 'C', 'D']\n        result = generate_unique_pairs(items)\n        self.assertEqual(result, [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']])\n", "prompt": "please write a python function , the function signature as below def generate_unique_pairs(array: list) -> list:\n    \"\"\"\n    Generates all unique combinations of pairs from a list.\n\n    Args:\n        array (list): The input list from which combinations are generated.\n\n    Returns:\n        list of lists: A list of lists, where each inner list contains a unique pair of elements.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Generates all unique combinations of pairs from an array.\n *\n * @param vector<int> array - The input vector from which combinations are generated.\n * @returns vector<vector<int>> - A vector of vectors, where each inner vector contains a unique pair of elements.\n */\nvector<vector<int>> generateUniquePairs(const vector<int>& array) {}", "test_code": "TEST_CASE(\"generateUniquePairs\") {\n    SECTION(\"generates unique pairs from an array with three elements\") {\n        vector<variant<int, string, struct {string key;}>> items = {\"A\", \"B\", \"C\"};\n        auto result = generateUniquePairs(items);\n        REQUIRE(result == vector<vector<variant<int, string, struct {string key;}>>>{ \n            {\"A\", \"B\"},\n            {\"A\", \"C\"},\n            {\"B\", \"C\"}\n        });\n    }\n\n    SECTION(\"generates unique pairs from an array with two elements\") {\n        vector<variant<int, string, struct {string key;}>> items = {\"A\", \"B\"};\n        auto result = generateUniquePairs(items);\n        REQUIRE(result == vector<vector<variant<int, string, struct {string key;}>>>{ \n            {\"A\", \"B\"}\n        });\n    }\n\n    SECTION(\"returns an empty array when the input array is empty\") {\n        vector<variant<int, string, struct {string key;}>> items = {};\n        auto result = generateUniquePairs(items);\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"returns an empty array when the input array has one element\") {\n        vector<variant<int, string, struct {string key;}>> items = {\"A\"};\n        auto result = generateUniquePairs(items);\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"handles an array with different types of elements\") {\n        vector<variant<int, string, struct {string key;}>> items = {1, \"A\", { \"value\" }};\n        auto result = generateUniquePairs(items);\n        REQUIRE(result == vector<vector<variant<int, string, struct {string key;}>>>{ \n            {1, \"A\"},\n            {1, { \"value\" }},\n            {\"A\", { \"value\" }}\n        });\n    }\n\n    SECTION(\"generates pairs from an array with more than three elements\") {\n        vector<variant<int, string, struct {string key;}>> items = {\"A\", \"B\", \"C\", \"D\"};\n        auto result = generateUniquePairs(items);\n        REQUIRE(result == vector<vector<variant<int, string, struct {string key;}>>>{ \n            {\"A\", \"B\"},\n            {\"A\", \"C\"},\n            {\"A\", \"D\"},\n            {\"B\", \"C\"},\n            {\"B\", \"D\"},\n            {\"C\", \"D\"}\n        });\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Generates all unique combinations of pairs from an array.\n *\n * @param vector<int> array - The input vector from which combinations are generated.\n * @returns vector<vector<int>> - A vector of vectors, where each inner vector contains a unique pair of elements.\n */\nvector<vector<int>> generateUniquePairs(const vector<int>& array) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Generates all unique combinations of pairs from an array.\n *\n * @param array - The input array from which combinations are generated.\n * @returns - A list of lists, where each inner list contains a unique pair of elements.\n */\npublic List<List<T>> generateUniquePairs(T[] array) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testGenerateUniquePairsWithThreeElements() {\n        String[] items = {\"A\", \"B\", \"C\"};\n        List<List<String>> result = generateUniquePairs(items);\n        List<List<String>> expected = Arrays.asList(\n            Arrays.asList(\"A\", \"B\"),\n            Arrays.asList(\"A\", \"C\"),\n            Arrays.asList(\"B\", \"C\")\n        );\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testGenerateUniquePairsWithTwoElements() {\n        String[] items = {\"A\", \"B\"};\n        List<List<String>> result = generateUniquePairs(items);\n        List<List<String>> expected = Arrays.asList(\n            Arrays.asList(\"A\", \"B\")\n        );\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testGenerateUniquePairsWithEmptyArray() {\n        String[] items = {};\n        List<List<String>> result = generateUniquePairs(items);\n        List<List<String>> expected = Arrays.asList();\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testGenerateUniquePairsWithOneElement() {\n        String[] items = {\"A\"};\n        List<List<String>> result = generateUniquePairs(items);\n        List<List<String>> expected = Arrays.asList();\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testGenerateUniquePairsWithDifferentTypes() {\n        Object[] items = {1, \"A\", new Object() { public String key = \"value\"; }};\n        List<List<Object>> result = generateUniquePairs(items);\n        List<List<Object>> expected = Arrays.asList(\n            Arrays.asList(1, \"A\"),\n            Arrays.asList(1, new Object() { public String key = \"value\"; }),\n            Arrays.asList(\"A\", new Object() { public String key = \"value\"; })\n        );\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testGenerateUniquePairsWithMoreThanThreeElements() {\n        String[] items = {\"A\", \"B\", \"C\", \"D\"};\n        List<List<String>> result = generateUniquePairs(items);\n        List<List<String>> expected = Arrays.asList(\n            Arrays.asList(\"A\", \"B\"),\n            Arrays.asList(\"A\", \"C\"),\n            Arrays.asList(\"A\", \"D\"),\n            Arrays.asList(\"B\", \"C\"),\n            Arrays.asList(\"B\", \"D\"),\n            Arrays.asList(\"C\", \"D\")\n        );\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Generates all unique combinations of pairs from an array.\n *\n * @param array - The input array from which combinations are generated.\n * @returns - A list of lists, where each inner list contains a unique pair of elements.\n */\npublic List<List<T>> generateUniquePairs(T[] array) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 541, "code_type": "method", "original_language": "javascript", "file_path": "gptlint\\5f32e707ba3eb796c0d1e969a1f121ec8736e1ef\\fixtures\\evals\\prefer-loose-array-bounds-checks-in-loops\\incorrect\\944c32ed.js", "question_type": "Data processing and transformation", "summary": "Filters elements from an array based on a qualification function.", "language_version_list": {"python": {"code_signature": "def filter_array(unfiltered_array: list, is_qualified: callable) -> list:\n    \"\"\"\n    Filters elements from an array based on a qualification function.\n\n    Args:\n        unfiltered_array (list): The array to filter.\n        is_qualified (callable): A function that determines if an element qualifies.\n\n    Returns:\n        list: A new list containing the elements that qualify.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFilterArray(unittest.TestCase):\n\n    def test_filters_out_numbers_less_than_or_equal_to_ten(self):\n        unfiltered_array = [5, 12, 3, 18, 7, 10, 15]\n        result = filter_array(unfiltered_array, lambda x: x > 10)\n        self.assertEqual(result, [12, 18, 15])\n\n    def test_returns_empty_array_when_all_elements_are_disqualified(self):\n        unfiltered_array = [1, 2, 3, 4, 5]\n        result = filter_array(unfiltered_array, lambda x: x > 10)\n        self.assertEqual(result, [])\n\n    def test_returns_same_array_when_all_elements_are_qualified(self):\n        unfiltered_array = [11, 12, 15, 20]\n        result = filter_array(unfiltered_array, lambda x: x > 10)\n        self.assertEqual(result, [11, 12, 15, 20])\n\n    def test_handles_empty_array_input(self):\n        unfiltered_array = []\n        result = filter_array(unfiltered_array, lambda x: x > 10)\n        self.assertEqual(result, [])\n\n    def test_filters_out_strings_based_on_length(self):\n        unfiltered_array = ['a', 'ab', 'abc', 'abcd', 'abcde']\n        result = filter_array(unfiltered_array, lambda x: len(x)>3)\n        self.assertEqual(result, ['abcd', 'abcde'])\n\n    def test_correctly_filters_array_with_mixed_types(self):\n        unfiltered_array = [1, 'hello', True, 'world', None]\n        result = filter_array(unfiltered_array, lambda x: isinstance(x, str))\n        self.assertEqual(result, ['hello', 'world'])\n\n    def test_filters_based_on_object_property(self):\n        unfiltered_array = [{'value': 3}, {'value': 5}, {'value': 7}]\n        result = filter_array(unfiltered_array, lambda x: x > 5)\n        self.assertEqual(result, [{'value': 7}])\n\n    def test_returns_empty_array_when_no_qualifying_function_provided(self):\n        unfiltered_array = [1, 2, 3, 4, 5]\n        result = filter_array(unfiltered_array, lambda x: False)  # Always returns false\n        self.assertEqual(result, [])\n", "prompt": "please write a python function , the function signature as below def filter_array(unfiltered_array: list, is_qualified: callable) -> list:\n    \"\"\"\n    Filters elements from an array based on a qualification function.\n\n    Args:\n        unfiltered_array (list): The array to filter.\n        is_qualified (callable): A function that determines if an element qualifies.\n\n    Returns:\n        list: A new list containing the elements that qualify.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Filters elements from a vector based on a qualification function.\n *\n * @param unfilteredArray - The vector to filter.\n * @param isQualified - The function that determines if an element qualifies.\n * @returns A new vector containing the elements that qualify.\n */\ntemplate <typename T>\nstd::vector<T> filterArray(const std::vector<T>& unfilteredArray, std::function<bool(const T&)> isQualified) {\n}", "test_code": "TEST_CASE(\"filterArray\") {\n    // Qualification function that checks if a number is greater than 10\n    auto isGreaterThanTen = [](int num) { return num > 10; };\n\n    SECTION(\"filters out numbers less than or equal to 10\") {\n        std::vector<int> unfilteredArray = {5, 12, 3, 18, 7, 10, 15};\n        auto result = filterArray(unfilteredArray, isGreaterThanTen);\n        REQUIRE(result == std::vector<int>({12, 18, 15}));\n    }\n\n    SECTION(\"returns an empty array when all elements are disqualified\") {\n        std::vector<int> unfilteredArray = {1, 2, 3, 4, 5};\n        auto result = filterArray(unfilteredArray, isGreaterThanTen);\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"returns the same array when all elements are qualified\") {\n        std::vector<int> unfilteredArray = {11, 12, 15, 20};\n        auto result = filterArray(unfilteredArray, isGreaterThanTen);\n        REQUIRE(result == std::vector<int>({11, 12, 15, 20}));\n    }\n\n    SECTION(\"handles an empty array input\") {\n        std::vector<int> unfilteredArray = {};\n        auto result = filterArray(unfilteredArray, isGreaterThanTen);\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"filters out strings based on length\") {\n        auto isLongerThanThreeChars = [](const std::string& str) { return str.length() > 3; };\n        std::vector<std::string> unfilteredArray = {\"a\", \"ab\", \"abc\", \"abcd\", \"abcde\"};\n        auto result = filterArray(unfilteredArray, isLongerThanThreeChars);\n        REQUIRE(result == std::vector<std::string>({\"abcd\", \"abcde\"}));\n    }\n\n    SECTION(\"correctly filters an array with mixed types\") {\n        auto isString = [](const std::variant<int, std::string, bool, std::nullptr_t>& item) {\n            return std::holds_alternative<std::string>(item);\n        };\n        std::vector<std::variant<int, std::string, bool, std::nullptr_t>> unfilteredArray = {1, \"hello\", true, \"world\", nullptr};\n        auto result = filterArray(unfilteredArray, isString);\n        REQUIRE(result == std::vector<std::variant<int, std::string, bool, std::nullptr_t>>({\"hello\", \"world\"}));\n    }\n\n    SECTION(\"filters based on an object property\") {\n        auto hasValueGreaterThanFive = [](const std::map<std::string, int>& obj) { return obj.at(\"value\") > 5; };\n        std::vector<std::map<std::string, int>> unfilteredArray = {{{\"value\", 3}}, {{\"value\", 5}}, {{\"value\", 7}}};\n        auto result = filterArray(unfilteredArray, hasValueGreaterThanFive);\n        REQUIRE(result == std::vector<std::map<std::string, int>>({{{\"value\", 7}}}));\n    }\n\n    SECTION(\"returns an empty array when no qualifying function is provided\") {\n        std::vector<int> unfilteredArray = {1, 2, 3, 4, 5};\n        auto result = filterArray(unfilteredArray, [](int) { return false; }); // Always returns false\n        REQUIRE(result.empty());\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Filters elements from a vector based on a qualification function.\n *\n * @param unfilteredArray - The vector to filter.\n * @param isQualified - The function that determines if an element qualifies.\n * @returns A new vector containing the elements that qualify.\n */\ntemplate <typename T>\nstd::vector<T> filterArray(const std::vector<T>& unfilteredArray, std::function<bool(const T&)> isQualified) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Filters elements from a list based on a qualification function.\n *\n * @param <T> - The type of elements in the list.\n * @param unfilteredList - The list to filter.\n * @param isQualified - The function that determines if an element qualifies.\n * @return - A new list containing the elements that qualify.\n */\npublic static <T> List<T> filterList(List<T> unfilteredList, Predicate<T> isQualified) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Predicate;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    // Qualification function that checks if a number is greater than 10\n    private Predicate<Integer> isGreaterThanTen = num -> num > 10;\n\n    @Test\n    public void testFiltersOutNumbersLessThanOrEqualToTen() {\n        List<Integer> unfilteredList = Arrays.asList(5, 12, 3, 18, 7, 10, 15);\n        List<Integer> result = Answer.filterList(unfilteredList, isGreaterThanTen);\n        assertEquals(Arrays.asList(12, 18, 15), result);\n    }\n\n    @Test\n    public void testReturnsEmptyListWhenAllElementsAreDisqualified() {\n        List<Integer> unfilteredList = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> result = Answer.filterList(unfilteredList, isGreaterThanTen);\n        assertEquals(Arrays.asList(), result);\n    }\n\n    @Test\n    public void testReturnsSameListWhenAllElementsAreQualified() {\n        List<Integer> unfilteredList = Arrays.asList(11, 12, 15, 20);\n        List<Integer> result = Answer.filterList(unfilteredList, isGreaterThanTen);\n        assertEquals(Arrays.asList(11, 12, 15, 20), result);\n    }\n\n    @Test\n    public void testHandlesEmptyListInput() {\n        List<Integer> unfilteredList = Arrays.asList();\n        List<Integer> result = Answer.filterList(unfilteredList, isGreaterThanTen);\n        assertEquals(Arrays.asList(), result);\n    }\n\n    @Test\n    public void testFiltersOutStringsBasedOnLength() {\n        Predicate<String> isLongerThanThreeChars = str -> str.length() > 3;\n        List<String> unfilteredList = Arrays.asList(\"a\", \"ab\", \"abc\", \"abcd\", \"abcde\");\n        List<String> result = Answer.filterList(unfilteredList, isLongerThanThreeChars);\n        assertEquals(Arrays.asList(\"abcd\", \"abcde\"), result);\n    }\n\n    @Test\n    public void testCorrectlyFiltersArrayWithMixedTypes() {\n        Predicate<Object> isString = item -> item instanceof String;\n        List<Object> unfilteredList = Arrays.asList(1, \"hello\", true, \"world\", null);\n        List<Object> result = Answer.filterList(unfilteredList, isString);\n        assertEquals(Arrays.asList(\"hello\", \"world\"), result);\n    }\n\n    @Test\n    public void testFiltersBasedOnObjectProperty() {\n        Predicate<Item> hasValueGreaterThanFive = obj -> obj.value > 5;\n        List<Item> unfilteredList = Arrays.asList(new Item(3), new Item(5), new Item(7));\n        List<Item> result = Answer.filterList(unfilteredList, hasValueGreaterThanFive);\n        assertEquals(Arrays.asList(new Item(7)), result);\n    }\n\n    @Test\n    public void testReturnsEmptyListWhenNoQualifyingFunctionProvided() {\n        List<Integer> unfilteredList = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> result = Answer.filterList(unfilteredList, num -> false); // Always returns false\n        assertEquals(Arrays.asList(), result);\n    }\n\n    // Helper class for the object property test\n    private static class Item {\n        int value;\n\n        Item(int value) {\n            this.value = value;\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Filters elements from a list based on a qualification function.\n *\n * @param <T> - The type of elements in the list.\n * @param unfilteredList - The list to filter.\n * @param isQualified - The function that determines if an element qualifies.\n * @return - A new list containing the elements that qualify.\n */\npublic static <T> List<T> filterList(List<T> unfilteredList, Predicate<T> isQualified) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 542, "code_type": "method", "original_language": "javascript", "file_path": "gptlint\\e7dde3d4fc94b7f543bd7fd21f3ba2543665a5a1\\fixtures\\evals\\prefer-early-return\\correct\\c9cdf147.js\n", "question_type": "Data processing and transformation", "summary": "Calculate the corresponding discount based on the given price and the actual price paid\n", "language_version_list": {"python": {"code_signature": "def calculate_discount(original_price: float, actual_price: float) -> float:\n    \"\"\"\n    Calculates the discount percentage based on the given price and the actual price paid.\n\n    Args:\n        original_price (float): The original price of the item.\n        actual_price (float): The actual price paid for the item.\n\n    Returns:\n        float: The discount percentage, rounded to two decimal places.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCalculateDiscount(unittest.TestCase):\n\n    def test_discount_25_percent(self):\n        self.assertEqual(calculate_discount(100, 75), 25.00)\n\n    def test_discount_0_percent(self):\n        self.assertEqual(calculate_discount(50, 50), 0.00)\n\n    def test_discount_100_percent(self):\n        self.assertEqual(calculate_discount(100, 0), 100.00)\n\n    def test_discount_50_percent(self):\n        self.assertEqual(calculate_discount(200, 100), 50.00)\n", "prompt": "please write a python function , the function signature as below def calculate_discount(original_price: float, actual_price: float) -> float:\n    \"\"\"\n    Calculates the discount percentage based on the given price and the actual price paid.\n\n    Args:\n        original_price (float): The original price of the item.\n        actual_price (float): The actual price paid for the item.\n\n    Returns:\n        float: The discount percentage, rounded to two decimal places.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculates the discount percentage based on the given price and the actual price paid.\n *\n * @param originalPrice - The original price of the item.\n * @param actualPrice - The actual price paid for the item.\n * @returns The discount percentage, rounded to two decimal places.\n */\ndouble calculateDiscount(double originalPrice, double actualPrice) {\n}", "test_code": "TEST_CASE(\"calculateDiscount\", \"[discount]\") {\n    SECTION(\"should return 25.00% discount for original price of 100 and actual price of 75\") {\n        REQUIRE(calculateDiscount(100, 75) == Approx(25.00).margin(0.01));\n    }\n\n    SECTION(\"should return 0.00% discount for original price of 50 and actual price of 50\") {\n        REQUIRE(calculateDiscount(50, 50) == Approx(0.00).margin(0.01));\n    }\n\n    SECTION(\"should return 100.00% discount for original price of 100 and actual price of 0\") {\n        REQUIRE(calculateDiscount(100, 0) == Approx(100.00).margin(0.01));\n    }\n\n    SECTION(\"should return 50.00% discount for original price of 200 and actual price of 100\") {\n        REQUIRE(calculateDiscount(200, 100) == Approx(50.00).margin(0.01));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculates the discount percentage based on the given price and the actual price paid.\n *\n * @param originalPrice - The original price of the item.\n * @param actualPrice - The actual price paid for the item.\n * @returns The discount percentage, rounded to two decimal places.\n */\ndouble calculateDiscount(double originalPrice, double actualPrice) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the discount percentage based on the given price and the actual price paid.\n *\n * @param originalPrice - The original price of the item.\n * @param actualPrice - The actual price paid for the item.\n * @return - The discount percentage, rounded to two decimal places.\n */\npublic static double calculateDiscount(double originalPrice, double actualPrice) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testCalculateDiscount1() {\n        assertEquals(25.00, DiscountCalculator.calculateDiscount(100, 75), 0.01);\n    }\n\n    @Test\n    public void testCalculateDiscount2() {\n        assertEquals(0.00, DiscountCalculator.calculateDiscount(50, 50), 0.01);\n    }\n\n    @Test\n    public void testCalculateDiscount3() {\n        assertEquals(100.00, DiscountCalculator.calculateDiscount(100, 0), 0.01);\n    }\n\n    @Test\n    public void testCalculateDiscount4() {\n        assertEquals(50.00, DiscountCalculator.calculateDiscount(200, 100), 0.01);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the discount percentage based on the given price and the actual price paid.\n *\n * @param originalPrice - The original price of the item.\n * @param actualPrice - The actual price paid for the item.\n * @return - The discount percentage, rounded to two decimal places.\n */\npublic static double calculateDiscount(double originalPrice, double actualPrice) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 543, "code_type": "method", "original_language": "javascript", "file_path": "gptlint\\e7dde3d4fc94b7f543bd7fd21f3ba2543665a5a1\\fixtures\\evals\\prefer-early-return\\correct\\6038a5f3.js\n", "question_type": "Data processing and transformation", "summary": "Increment the entered number. For non-positive numbers (less than or equal to 0), return the original value directly, and for positive numbers, return the value plus 1.\n", "language_version_list": {"python": {"code_signature": "def increment_number(num: float) -> float:\n    \"\"\"\n    Increments the entered number.\n\n    If the number is non-positive (<= 0), returns the original value.\n    If the number is positive, returns the value plus 1.\n\n    Args:\n        num (float): The number to increment.\n\n    Returns:\n        float: The incremented value or the original number.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIncrementNumber(unittest.TestCase):\n\n    def test_input_5(self):\n        self.assertEqual(increment_number(5), 6)\n\n    def test_input_0(self):\n        self.assertEqual(increment_number(0), 0)\n\n    def test_input_negative_3(self):\n        self.assertEqual(increment_number(-3), -3)\n\n    def test_input_0_5(self):\n        self.assertEqual(increment_number(0.5), 1.5)\n\n    def test_input_1(self):\n        self.assertEqual(increment_number(1), 2)\n\n    def test_input_negative_1(self):\n        self.assertEqual(increment_number(-1), -1)\n", "prompt": "please write a python function , the function signature as below def increment_number(num: float) -> float:\n    \"\"\"\n    Increments the entered number.\n\n    If the number is non-positive (<= 0), returns the original value.\n    If the number is positive, returns the value plus 1.\n\n    Args:\n        num (float): The number to increment.\n\n    Returns:\n        float: The incremented value or the original number.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Increments the entered number.\n * If the number is non-positive (<= 0), returns the original value.\n * If the number is positive, returns the value plus 1.\n *\n * @param num - The number to increment.\n * @returns The incremented value or the original number.\n */\nint incrementNumber(int num) {\n}", "test_code": "TEST_CASE(\"incrementNumber\") {\n    REQUIRE(incrementNumber(5) == 6);\n    REQUIRE(incrementNumber(0) == 0);\n    REQUIRE(incrementNumber(-3) == -3);\n    REQUIRE(incrementNumber(0.5) == 1.5);\n    REQUIRE(incrementNumber(1) == 2);\n    REQUIRE(incrementNumber(-1) == -1);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Increments the entered number.\n * If the number is non-positive (<= 0), returns the original value.\n * If the number is positive, returns the value plus 1.\n *\n * @param num - The number to increment.\n * @returns The incremented value or the original number.\n */\nint incrementNumber(int num) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Increments the entered number.\n * If the number is non-positive (<= 0), returns the original value.\n * If the number is positive, returns the value plus 1.\n *\n * @param num The number to increment.\n * @return The incremented value or the original number.\n */\npublic static int incrementNumber(int num) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testIncrementNumberInputFive() {\n        assertEquals(6, incrementNumber(5));\n    }\n\n    @Test\n    public void testIncrementNumberInputZero() {\n        assertEquals(0, incrementNumber(0));\n    }\n\n    @Test\n    public void testIncrementNumberInputNegativeThree() {\n        assertEquals(-3, incrementNumber(-3));\n    }\n\n    @Test\n    public void testIncrementNumberInputPointFive() {\n        assertEquals(1.5, incrementNumber(0.5), 0.001);\n    }\n\n    @Test\n    public void testIncrementNumberInputOne() {\n        assertEquals(2, incrementNumber(1));\n    }\n\n    @Test\n    public void testIncrementNumberInputNegativeOne() {\n        assertEquals(-1, incrementNumber(-1));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Increments the entered number.\n * If the number is non-positive (<= 0), returns the original value.\n * If the number is positive, returns the value plus 1.\n *\n * @param num The number to increment.\n * @return The incremented value or the original number.\n */\npublic static int incrementNumber(int num) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 544, "code_type": "method", "original_language": "javascript", "file_path": "gptlint\\5f32e707ba3eb796c0d1e969a1f121ec8736e1ef\\fixtures\\evals\\prefer-loose-array-bounds-checks-in-loops\\correct\\ef70f678.js\n", "question_type": "Data processing and transformation", "summary": "Filter out all even numbers from the original array data", "language_version_list": {"python": {"code_signature": "from typing import List\n\ndef filter_out_even_numbers(array: List[int]) -> List[int]:\n    \"\"\"\n    Filters out all even numbers from an array.\n\n    Args:\n        array (List[int]): The array of numbers to filter.\n\n    Returns:\n        List[int]: A new array containing only the odd numbers.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFilterOutEvenNumbers(unittest.TestCase):\n\n    def test_removes_all_even_numbers_from_the_array(self):\n        input_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        result = filter_out_even_numbers(input_array)\n        self.assertEqual(result, [1, 3, 5, 7, 9])\n\n    def test_returns_empty_array_when_input_is_empty(self):\n        input_array = []\n        result = filter_out_even_numbers(input_array)\n        self.assertEqual(result, [])\n\n    def test_returns_same_array_if_all_numbers_are_odd(self):\n        input_array = [1, 3, 5, 7, 9]\n        result = filter_out_even_numbers(input_array)\n        self.assertEqual(result, [1, 3, 5, 7, 9])\n\n    def test_returns_empty_array_if_all_numbers_are_even(self):\n        input_array = [2, 4, 6, 8, 10]\n        result = filter_out_even_numbers(input_array)\n        self.assertEqual(result, [])\n\n    def test_handles_mixed_positive_and_negative_numbers(self):\n        input_array = [-3, -2, -1, 0, 1, 2, 3]\n        result = filter_out_even_numbers(input_array)\n        self.assertEqual(result, [-3, -1, 1, 3])\n\n    def test_handles_large_numbers_and_zero_correctly(self):\n        input_array = [0, 1000000000, 1000000001, 1000000002, 1000000003]\n        result = filter_out_even_numbers(input_array)\n        self.assertEqual(result, [1000000001, 1000000003])\n", "prompt": "please write a python function , the function signature as below from typing import List\n\ndef filter_out_even_numbers(array: List[int]) -> List[int]:\n    \"\"\"\n    Filters out all even numbers from an array.\n\n    Args:\n        array (List[int]): The array of numbers to filter.\n\n    Returns:\n        List[int]: A new array containing only the odd numbers.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Filters out all even numbers from an array.\n *\n * @param array - The vector of numbers to filter.\n * @returns A new vector containing only the odd numbers.\n */\nstd::vector<int> filterOutEvenNumbers(const std::vector<int>& array) {}", "test_code": "TEST_CASE(\"filterOutEvenNumbers\") {\n    SECTION(\"removes all even numbers from the array\") {\n        std::vector<int> inputArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        std::vector<int> result = filterOutEvenNumbers(inputArray);\n        REQUIRE(result == std::vector<int>{1, 3, 5, 7, 9});\n    }\n\n    SECTION(\"returns an empty array when input is empty\") {\n        std::vector<int> inputArray = {};\n        std::vector<int> result = filterOutEvenNumbers(inputArray);\n        REQUIRE(result == std::vector<int>{});\n    }\n\n    SECTION(\"returns the same array if all numbers are odd\") {\n        std::vector<int> inputArray = {1, 3, 5, 7, 9};\n        std::vector<int> result = filterOutEvenNumbers(inputArray);\n        REQUIRE(result == std::vector<int>{1, 3, 5, 7, 9});\n    }\n\n    SECTION(\"returns an empty array if all numbers are even\") {\n        std::vector<int> inputArray = {2, 4, 6, 8, 10};\n        std::vector<int> result = filterOutEvenNumbers(inputArray);\n        REQUIRE(result == std::vector<int>{});\n    }\n\n    SECTION(\"handles mixed positive and negative numbers\") {\n        std::vector<int> inputArray = {-3, -2, -1, 0, 1, 2, 3};\n        std::vector<int> result = filterOutEvenNumbers(inputArray);\n        REQUIRE(result == std::vector<int>{-3, -1, 1, 3});\n    }\n\n    SECTION(\"handles large numbers and zero correctly\") {\n        std::vector<int> inputArray = {0, 1000000000, 1000000001, 1000000002, 1000000003};\n        std::vector<int> result = filterOutEvenNumbers(inputArray);\n        REQUIRE(result == std::vector<int>{1000000001, 1000000003});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Filters out all even numbers from an array.\n *\n * @param array - The vector of numbers to filter.\n * @returns A new vector containing only the odd numbers.\n */\nstd::vector<int> filterOutEvenNumbers(const std::vector<int>& array) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Filters out all even numbers from an array.\n *\n * @param array - The array of numbers to filter.\n * @return - A new list containing only the odd numbers.\n */\npublic static List<Integer> filterOutEvenNumbers(int[] array) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testRemovesAllEvenNumbers() {\n        int[] inputArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        List<Integer> result = filterOutEvenNumbers(inputArray);\n        List<Integer> expected = Arrays.asList(1, 3, 5, 7, 9);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testReturnsEmptyArrayWhenInputIsEmpty() {\n        int[] inputArray = {};\n        List<Integer> result = filterOutEvenNumbers(inputArray);\n        List<Integer> expected = Arrays.asList();\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testReturnsSameArrayIfAllNumbersAreOdd() {\n        int[] inputArray = {1, 3, 5, 7, 9};\n        List<Integer> result = filterOutEvenNumbers(inputArray);\n        List<Integer> expected = Arrays.asList(1, 3, 5, 7, 9);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testReturnsEmptyArrayIfAllNumbersAreEven() {\n        int[] inputArray = {2, 4, 6, 8, 10};\n        List<Integer> result = filterOutEvenNumbers(inputArray);\n        List<Integer> expected = Arrays.asList();\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testHandlesMixedPositiveAndNegativeNumbers() {\n        int[] inputArray = {-3, -2, -1, 0, 1, 2, 3};\n        List<Integer> result = filterOutEvenNumbers(inputArray);\n        List<Integer> expected = Arrays.asList(-3, -1, 1, 3);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testHandlesLargeNumbersAndZeroCorrectly() {\n        int[] inputArray = {0, 1000000000, 1000000001, 1000000002, 1000000003};\n        List<Integer> result = filterOutEvenNumbers(inputArray);\n        List<Integer> expected = Arrays.asList(1000000001, 1000000003);\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Filters out all even numbers from an array.\n *\n * @param array - The array of numbers to filter.\n * @return - A new list containing only the odd numbers.\n */\npublic static List<Integer> filterOutEvenNumbers(int[] array) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 545, "code_type": "method", "original_language": "javascript", "file_path": "gptlint\\5f32e707ba3eb796c0d1e969a1f121ec8736e1ef\\fixtures\\evals\\prefer-loose-array-bounds-checks-in-loops\\correct\\9a91a8b7.js\n", "question_type": "Data processing and transformation", "summary": "Iterate through the array of elements until the first null is encountered, returning the array before the null is encountered", "language_version_list": {"python": {"code_signature": "from typing import List, Any\n\n\ndef elements_before_null(array: List[Any]) -> List[Any]:\n    \"\"\"\n    Iterates through the array of elements until the first None is encountered,\n    returning a new list that includes all elements before None.\n\n    Args:\n        array (List[Any]): The array to iterate through.\n\n    Returns:\n        List[Any]: A new list containing elements before the first None.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestElementsBeforeNull(unittest.TestCase):\n\n    def test_returns_elements_before_first_null(self):\n        input_array = ['element1', 'element2', None, 'element3', 'element4']\n        result = elements_before_null(input_array)\n        self.assertEqual(result, ['element1', 'element2'])\n\n    def test_returns_empty_array_when_input_is_empty(self):\n        input_array = []\n        result = elements_before_null(input_array)\n        self.assertEqual(result, [])\n\n    def test_returns_same_array_if_no_null(self):\n        input_array = ['element1', 'element2', 'element3']\n        result = elements_before_null(input_array)\n        self.assertEqual(result, ['element1', 'element2', 'element3'])\n\n    def test_returns_empty_array_if_first_element_is_null(self):\n        input_array = [None, 'element2', 'element3']\n        result = elements_before_null(input_array)\n        self.assertEqual(result, [])\n\n    def test_handles_mixed_types_with_null(self):\n        input_array = [1, 'text', None, True, False]\n        result = elements_before_null(input_array)\n        self.assertEqual(result, [1, 'text'])\n\n    def test_handles_array_with_only_null(self):\n        input_array = [None]\n        result = elements_before_null(input_array)\n        self.assertEqual(result, [])\n", "prompt": "please write a python function , the function signature as below from typing import List, Any\n\n\ndef elements_before_null(array: List[Any]) -> List[Any]:\n    \"\"\"\n    Iterates through the array of elements until the first None is encountered,\n    returning a new list that includes all elements before None.\n\n    Args:\n        array (List[Any]): The array to iterate through.\n\n    Returns:\n        List[Any]: A new list containing elements before the first None.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Iterates through the vector of elements until the first null is encountered,\n * returning a new vector that includes all elements before the null.\n *\n * @param std::vector<int*> array - The vector to iterate through.\n * @returns std::vector<int*> - A new vector containing elements before the first null.\n */\nstd::vector<int*> elementsBeforeNull(const std::vector<int*>& array) {\n}", "test_code": "TEST_CASE(\"elementsBeforeNull\") {\n    SECTION(\"returns elements before the first null\") {\n        std::vector<std::string> inputArray = {\"element1\", \"element2\", \"\", \"element3\", \"element4\"};\n        auto result = elementsBeforeNull(inputArray);\n        REQUIRE(result == std::vector<std::string>{\"element1\", \"element2\"});\n    }\n\n    SECTION(\"returns an empty array when input is empty\") {\n        std::vector<std::string> inputArray = {};\n        auto result = elementsBeforeNull(inputArray);\n        REQUIRE(result == std::vector<std::string>{});\n    }\n\n    SECTION(\"returns the same array if there is no null\") {\n        std::vector<std::string> inputArray = {\"element1\", \"element2\", \"element3\"};\n        auto result = elementsBeforeNull(inputArray);\n        REQUIRE(result == std::vector<std::string>{\"element1\", \"element2\", \"element3\"});\n    }\n\n    SECTION(\"returns an empty array if the first element is null\") {\n        std::vector<std::string> inputArray = {\"\", \"element2\", \"element3\"};\n        auto result = elementsBeforeNull(inputArray);\n        REQUIRE(result == std::vector<std::string>{});\n    }\n\n    SECTION(\"handles mixed types with null\") {\n        std::vector<std::variant<int, std::string, bool>> inputArray = {1, \"text\", std::monostate{}, true, false};\n        auto result = elementsBeforeNull(inputArray);\n        REQUIRE(result == std::vector<std::variant<int, std::string, bool>>{1, \"text\"});\n    }\n\n    SECTION(\"handles an array with only null\") {\n        std::vector<std::string> inputArray = {\"\"};\n        auto result = elementsBeforeNull(inputArray);\n        REQUIRE(result == std::vector<std::string>{});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Iterates through the vector of elements until the first null is encountered,\n * returning a new vector that includes all elements before the null.\n *\n * @param std::vector<int*> array - The vector to iterate through.\n * @returns std::vector<int*> - A new vector containing elements before the first null.\n */\nstd::vector<int*> elementsBeforeNull(const std::vector<int*>& array) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Iterates through the array of elements until the first null is encountered,\n * returning a new list that includes all elements before the null.\n *\n * @param array - The array to iterate through.\n * @returns - A new list containing elements before the first null.\n */\npublic static List<Object> elementsBeforeNull(Object[] array) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void returnsElementsBeforeTheFirstNull() {\n        Object[] inputArray = {\"element1\", \"element2\", null, \"element3\", \"element4\"};\n        List<Object> result = Answer.elementsBeforeNull(inputArray);\n        assertEquals(Arrays.asList(\"element1\", \"element2\"), result);\n    }\n\n    @Test\n    public void returnsAnEmptyArrayWhenInputIsEmpty() {\n        Object[] inputArray = {};\n        List<Object> result = Answer.elementsBeforeNull(inputArray);\n        assertEquals(Arrays.asList(), result);\n    }\n\n    @Test\n    public void returnsTheSameArrayIfThereIsNoNull() {\n        Object[] inputArray = {\"element1\", \"element2\", \"element3\"};\n        List<Object> result = Answer.elementsBeforeNull(inputArray);\n        assertEquals(Arrays.asList(\"element1\", \"element2\", \"element3\"), result);\n    }\n\n    @Test\n    public void returnsAnEmptyArrayIfTheFirstElementIsNull() {\n        Object[] inputArray = {null, \"element2\", \"element3\"};\n        List<Object> result = Answer.elementsBeforeNull(inputArray);\n        assertEquals(Arrays.asList(), result);\n    }\n\n    @Test\n    public void handlesMixedTypesWithNull() {\n        Object[] inputArray = {1, \"text\", null, true, false};\n        List<Object> result = Answer.elementsBeforeNull(inputArray);\n        assertEquals(Arrays.asList(1, \"text\"), result);\n    }\n\n    @Test\n    public void handlesAnArrayWithOnlyNull() {\n        Object[] inputArray = {null};\n        List<Object> result = Answer.elementsBeforeNull(inputArray);\n        assertEquals(Arrays.asList(), result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Iterates through the array of elements until the first null is encountered,\n * returning a new list that includes all elements before the null.\n *\n * @param array - The array to iterate through.\n * @returns - A new list containing elements before the first null.\n */\npublic static List<Object> elementsBeforeNull(Object[] array) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 559, "code_type": "method", "original_language": "javascript", "file_path": "RISUCONT/90ca283a3a7be193fed6186eb072b37cd9734519/expander.js\n", "question_type": "Data processing and transformation", "summary": "Check whether a file name is a cpp language header file", "language_version_list": {"python": {"code_signature": "def is_cpp_header_file(file_name: str) -> bool:\n    \"\"\"\n    Checks whether a file name is a C++ header file.\n\n    Args:\n        file_name (str): The name of the file to check.\n\n    Returns:\n        bool: Returns True if the file is a C++ header file, False otherwise.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsCppHeaderFile(unittest.TestCase):\n\n    def test_returns_true_for_h_file(self):\n        self.assertTrue(is_cpp_header_file('example.h'))\n\n    def test_returns_true_for_hpp_file(self):\n        self.assertTrue(is_cpp_header_file('example.hpp'))\n\n    def test_returns_false_for_non_header_file_extension(self):\n        self.assertFalse(is_cpp_header_file('example.txt'))\n\n    def test_returns_false_for_file_without_extension(self):\n        self.assertFalse(is_cpp_header_file('example'))\n\n    def test_returns_false_for_c_file(self):\n        self.assertFalse(is_cpp_header_file('example.c'))\n", "prompt": "please write a python function , the function signature as below def is_cpp_header_file(file_name: str) -> bool:\n    \"\"\"\n    Checks whether a file name is a C++ header file.\n\n    Args:\n        file_name (str): The name of the file to check.\n\n    Returns:\n        bool: Returns True if the file is a C++ header file, False otherwise.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Checks whether a file name is a C++ header file.\n *\n * @param fileName - The name of the file to check.\n * @returns true if the file is a C++ header file, false otherwise.\n */\nbool isCppHeaderFile(const std::string& fileName) {}", "test_code": "TEST_CASE(\"isCppHeaderFile\") {\n    SECTION(\"returns true for a .h file\") {\n        REQUIRE(isCppHeaderFile(\"example.h\") == true);\n    }\n\n    SECTION(\"returns true for a .hpp file\") {\n        REQUIRE(isCppHeaderFile(\"example.hpp\") == true);\n    }\n\n    SECTION(\"returns false for a non-header file extension\") {\n        REQUIRE(isCppHeaderFile(\"example.txt\") == false);\n    }\n\n    SECTION(\"returns false for a file without an extension\") {\n        REQUIRE(isCppHeaderFile(\"example\") == false);\n    }\n\n    SECTION(\"returns false for a .c file\") {\n        REQUIRE(isCppHeaderFile(\"example.c\") == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Checks whether a file name is a C++ header file.\n *\n * @param fileName - The name of the file to check.\n * @returns true if the file is a C++ header file, false otherwise.\n */\nbool isCppHeaderFile(const std::string& fileName) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks whether a file name is a C++ header file.\n *\n * @param fileName - The name of the file to check.\n * @returns - Returns true if the file is a C++ header file, false otherwise.\n */\npublic static boolean isCppHeaderFile(String fileName) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testIsCppHeaderFile_HFile() {\n        assertTrue(isCppHeaderFile(\"example.h\"));\n    }\n\n    @Test\n    public void testIsCppHeaderFile_HppFile() {\n        assertTrue(isCppHeaderFile(\"example.hpp\"));\n    }\n\n    @Test\n    public void testIsCppHeaderFile_NonHeaderFile() {\n        assertFalse(isCppHeaderFile(\"example.txt\"));\n    }\n\n    @Test\n    public void testIsCppHeaderFile_NoExtension() {\n        assertFalse(isCppHeaderFile(\"example\"));\n    }\n\n    @Test\n    public void testIsCppHeaderFile_CFile() {\n        assertFalse(isCppHeaderFile(\"example.c\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks whether a file name is a C++ header file.\n *\n * @param fileName - The name of the file to check.\n * @returns - Returns true if the file is a C++ header file, false otherwise.\n */\npublic static boolean isCppHeaderFile(String fileName) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 560, "code_type": "method", "original_language": "javascript", "file_path": "RISUCONT/90ca283a3a7be193fed6186eb072b37cd9734519/expander.js\n", "question_type": "Data processing and transformation", "summary": "Gets the line number in the content at the specified index.", "language_version_list": {"python": {"code_signature": "def get_line_number(content: str, index: int) -> int:\n    \"\"\"\n    Gets the line number in the content at the specified index.\n\n    Args:\n        content (str): The string content to check.\n        index (int): The character index to find the line number for.\n\n    Returns:\n        int: The line number corresponding to the given index.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGetLineNumber(unittest.TestCase):\n\n    def test_returns_1_for_first_character(self):\n        self.assertEqual(get_line_number(\"Line 1\\nLine 2\\nLine 3\", 0), 1)\n\n    def test_returns_1_for_last_character_of_first_line(self):\n        self.assertEqual(get_line_number(\"Line 1\\nLine 2\\nLine 3\", 5), 1)\n\n    def test_returns_3_for_last_character_of_third_line(self):\n        self.assertEqual(get_line_number(\"Line 1\\nLine 2\\nLine 3\", 18), 3)\n\n    def test_returns_1_for_single_line_string(self):\n        self.assertEqual(get_line_number(\"Single line string\", 0), 1)\n\n    def test_returns_3_for_index_in_multiline_string_with_trailing_newlines(self):\n        self.assertEqual(get_line_number(\"Line 1\\nLine 2\\nLine 3\\n\\n\", 15), 3)\n", "prompt": "please write a python function , the function signature as below def get_line_number(content: str, index: int) -> int:\n    \"\"\"\n    Gets the line number in the content at the specified index.\n\n    Args:\n        content (str): The string content to check.\n        index (int): The character index to find the line number for.\n\n    Returns:\n        int: The line number corresponding to the given index.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Gets the line number in the content at the specified index.\n *\n * @param content - The string content to check.\n * @param index - The character index to find the line number for.\n * @returns The line number corresponding to the given index.\n */\nint getLineNumber(const std::string& content, size_t index){}", "test_code": "TEST_CASE(\"getLineNumber\") {\n    SECTION(\"returns 1 for the first character\") {\n        REQUIRE(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 0) == 1);\n    }\n\n    SECTION(\"returns 1 for the last character of the first line\") {\n        REQUIRE(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 5) == 1);\n    }\n\n    SECTION(\"returns 3 for the last character of the third line\") {\n        REQUIRE(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 18) == 3);\n    }\n\n    SECTION(\"returns 1 for a single line string\") {\n        REQUIRE(getLineNumber(\"Single line string\", 0) == 1);\n    }\n\n    SECTION(\"returns 3 for an index within a multiline string with trailing newlines\") {\n        REQUIRE(getLineNumber(\"Line 1\\nLine 2\\nLine 3\\n\\n\", 15) == 3);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Gets the line number in the content at the specified index.\n *\n * @param content - The string content to check.\n * @param index - The character index to find the line number for.\n * @returns The line number corresponding to the given index.\n */\nint getLineNumber(const std::string& content, size_t index){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Gets the line number in the content at the specified index.\n *\n * @param content The string content to check.\n * @param index The character index to find the line number for.\n * @return The line number corresponding to the given index.\n */\npublic static int getLineNumber(String content, int index) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testGetLineNumber_FirstCharacter() {\n        assertEquals(1, getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 0));\n    }\n\n    @Test\n    public void testGetLineNumber_LastCharacterOfFirstLine() {\n        assertEquals(1, getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 5));\n    }\n\n    @Test\n    public void testGetLineNumber_LastCharacterOfThirdLine() {\n        assertEquals(3, getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 18));\n    }\n\n    @Test\n    public void testGetLineNumber_SingleLineString() {\n        assertEquals(1, getLineNumber(\"Single line string\", 0));\n    }\n\n    @Test\n    public void testGetLineNumber_MultilineStringWithTrailingNewlines() {\n        assertEquals(3, getLineNumber(\"Line 1\\nLine 2\\nLine 3\\n\\n\", 15));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Gets the line number in the content at the specified index.\n *\n * @param content The string content to check.\n * @param index The character index to find the line number for.\n * @return The line number corresponding to the given index.\n */\npublic static int getLineNumber(String content, int index) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 140, "code_type": "method", "original_language": "typescript", "file_path": "baby-diary\\bb057d82b387febd88092a48760e510a31f4e582\\src\\utils\\dateUtils.ts", "question_type": "Data processing and transformation", "summary": "calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units\n", "language_version_list": {"python": {"code_signature": "from datetime import datetime\nfrom typing import Tuple\n\n\ndef get_time_since_born_until_now(birth_date: datetime) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n    Calculate the years, months, days, hours, and minutes that have passed\n    from the birth date to the current date and return them as a tuple.\n\n    Args:\n        birth_date (datetime): The birth date as a datetime object.\n\n    Returns:\n        Tuple[int, int, int, int, int]: A tuple containing the values of years, months, days, hours, and minutes.\n    \"\"\"\n", "test_code": "import unittest\nfrom datetime import datetime, timedelta\n\n# Assuming the function get_time_since_born_until_now is defined here\n\nclass TestGetTimeSinceBornUntilNow(unittest.TestCase):\n\n    def setUp(self):\n        # Set the system time to a fixed date\n        self.fixed_time = datetime(2024, 8, 23, 15, 45)\n        # Mock datetime.now() for the tests\n        self.original_datetime_now = datetime.now\n\n        def mock_datetime_now():\n            return self.fixed_time\n        \n        datetime.now = mock_datetime_now\n\n    def tearDown(self):\n        # Restore original datetime.now\n        datetime.now = self.original_datetime_now\n\n    def test_typical_birth_date(self):\n        birth_date = datetime(1990, 5, 15, 10, 30)\n        result = get_time_since_born_until_now(birth_date)\n        self.assertEqual(result, (34, 3, 8, 5, 15))  # 34 years, 3 months, 8 days, 5 hours, 15 minutes\n\n    def test_recent_birth_date(self):\n        birth_date = datetime(2024, 8, 20, 12, 0)\n        result = get_time_since_born_until_now(birth_date)\n        self.assertEqual(result, (0, 0, 3, 3, 45))  # 3 days, 3 hours, 45 minutes\n\n    def test_edge_case_end_of_year(self):\n        birth_date = datetime(2023, 12, 31, 23, 59)\n        result = get_time_since_born_until_now(birth_date)\n        self.assertEqual(result, (0, 7, 22, 15, 46))  # 7 months, 22 days, 15 hours, 46 minutes\n\n    def test_birthday_earlier_in_month(self):\n        birth_date = datetime(2024, 8, 1, 0, 0)\n        result = get_time_since_born_until_now(birth_date)\n        self.assertEqual(result, (0, 0, 22, 15, 45))  # 22 days, 15 hours, 45 minutes\n\n    def test_birthday_later_in_year_before_month(self):\n        birth_date = datetime(2024, 1, 1, 1, 0)\n        result = get_time_since_born_until_now(birth_date)\n        self.assertEqual(result, (0, 7, 22, 14, 45))  # 7 months, 22 days, 14 hours, 45 minutes\n\n    def test_birthday_previous_month(self):\n        birth_date = datetime(2024, 7, 30, 10, 0)\n        result = get_time_since_born_until_now(birth_date)\n        self.assertEqual(result, (0, 0, 24, 5, 45))  # 24 days, 5 hours, 45 minutes", "prompt": "please write a python function , the function signature as below from datetime import datetime\nfrom typing import Tuple\n\n\ndef get_time_since_born_until_now(birth_date: datetime) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n    Calculate the years, months, days, hours, and minutes that have passed\n    from the birth date to the current date and return them as a tuple.\n\n    Args:\n        birth_date (datetime): The birth date as a datetime object.\n\n    Returns:\n        Tuple[int, int, int, int, int]: A tuple containing the values of years, months, days, hours, and minutes.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units.\n * @param birthDate The birth date.\n * @return An array containing years, months, days, hours, and minutes.\n */\nstd::array<int, 5> getTimeSinceBornUntilNow(const std::tm& birthDate) {}", "test_code": "TEST_CASE(\"getTimeSinceBornUntilNow\") {\n    // Mocking system time for testing\n    std::tm mockTime = {};\n    strptime(\"2024-08-23 15:45:00\", \"%Y-%m-%d %H:%M:%S\", &mockTime);\n    time_t systemTime = mktime(&mockTime);\n    std::tm* oldTime = localtime(&systemTime);\n\n    SECTION(\"should return the correct difference for a typical birth date\") {\n        std::tm birthDate = {};\n        strptime(\"1990-05-15 10:30:00\", \"%Y-%m-%d %H:%M:%S\", &birthDate);\n        auto result = getTimeSinceBornUntilNow(birthDate);\n        REQUIRE(result == std::array<int, 5>{34, 3, 8, 5, 15});\n    }\n\n    SECTION(\"should return the correct difference for a recent birth date\") {\n        std::tm birthDate = {};\n        strptime(\"2024-08-20 12:00:00\", \"%Y-%m-%d %H:%M:%S\", &birthDate);\n        auto result = getTimeSinceBornUntilNow(birthDate);\n        REQUIRE(result == std::array<int, 5>{0, 0, 3, 3, 45});\n    }\n\n    SECTION(\"should handle edge cases at the end of the year\") {\n        std::tm birthDate = {};\n        strptime(\"2023-12-31 23:59:00\", \"%Y-%m-%d %H:%M:%S\", &birthDate);\n        auto result = getTimeSinceBornUntilNow(birthDate);\n        REQUIRE(result == std::array<int, 5>{0, 7, 22, 15, 46});\n    }\n\n    SECTION(\"should handle birthdays earlier in the current month\") {\n        std::tm birthDate = {};\n        strptime(\"2024-08-01 00:00:00\", \"%Y-%m-%d %H:%M:%S\", &birthDate);\n        auto result = getTimeSinceBornUntilNow(birthDate);\n        REQUIRE(result == std::array<int, 5>{0, 0, 22, 15, 45});\n    }\n\n    SECTION(\"should handle birthdays later in the current year before the current month\") {\n        std::tm birthDate = {};\n        strptime(\"2024-01-01 01:00:00\", \"%Y-%m-%d %H:%M:%S\", &birthDate);\n        auto result = getTimeSinceBornUntilNow(birthDate);\n        REQUIRE(result == std::array<int, 5>{0, 7, 22, 14, 45});\n    }\n\n    SECTION(\"should handle birthdays in the previous month of the same year\") {\n        std::tm birthDate = {};\n        strptime(\"2024-07-30 10:00:00\", \"%Y-%m-%d %H:%M:%S\", &birthDate);\n        auto result = getTimeSinceBornUntilNow(birthDate);\n        REQUIRE(result == std::array<int, 5>{0, 0, 24, 5, 45});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units.\n * @param birthDate The birth date.\n * @return An array containing years, months, days, hours, and minutes.\n */\nstd::array<int, 5> getTimeSinceBornUntilNow(const std::tm& birthDate) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units.\n * @param birthDate the date of birth\n * @return an array containing years, months, days, hours, and minutes\n */\npublic static int[] getTimeSinceBornUntilNow(Date birthDate) {\n}", "test_code": "\npackage org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertArrayEquals;\n\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.time.temporal.ChronoUnit;\n\npublic class Tester {\n\n    private LocalDateTime fixedTime;\n    private LocalDateTime originalNow;\n\n    @Before\n    public void setUp() {\n        // Set the system time to a fixed date\n        fixedTime = LocalDateTime.of(2024, 8, 23, 15, 45);\n        originalNow = LocalDateTime.now();\n\n        // Assuming we can mock or replace LocalDateTime.now() in the method being tested.\n        // If you can't mock the system time directly, consider passing a clock or fixed date to the method.\n    }\n\n    @After\n    public void tearDown() {\n        // Restore original time if needed\n        // This would typically be done through a static mock or resetting the context if using a library.\n    }\n\n    private long[] getTimeSinceBornUntilNow(LocalDateTime birthDate) {\n        // This is where you would implement or call your actual function.\n        // For demonstration, let's assume it's implemented correctly.\n        LocalDateTime now = fixedTime; // Use the fixed time for testing\n\n        // Calculate the time since birth\n        long years = ChronoUnit.YEARS.between(birthDate, now);\n        long months = ChronoUnit.MONTHS.between(birthDate.plusYears(years), now);\n        long days = ChronoUnit.DAYS.between(birthDate.plusYears(years).plusMonths(months), now);\n        long hours = ChronoUnit.HOURS.between(birthDate.plusYears(years).plusMonths(months).plusDays(days), now);\n        long minutes = ChronoUnit.MINUTES.between(birthDate.plusYears(years).plusMonths(months).plusDays(days).plusHours(hours), now);\n\n        return new long[]{years, months, days, hours, minutes};\n    }\n\n    @Test\n    public void testTypicalBirthDate() {\n        LocalDateTime birthDate = LocalDateTime.of(1990, 5, 15, 10, 30);\n        long[] result = getTimeSinceBornUntilNow(birthDate);\n        assertArrayEquals(new long[]{34, 3, 8, 5, 15}, result); // 34 years, 3 months, 8 days, 5 hours, 15 minutes\n    }\n\n    @Test\n    public void testRecentBirthDate() {\n        LocalDateTime birthDate = LocalDateTime.of(2024, 8, 20, 12, 0);\n        long[] result = getTimeSinceBornUntilNow(birthDate);\n        assertArrayEquals(new long[]{0, 0, 3, 3, 45}, result); // 3 days, 3 hours, 45 minutes\n    }\n\n    @Test\n    public void testEdgeCaseEndOfYear() {\n        LocalDateTime birthDate = LocalDateTime.of(2023, 12, 31, 23, 59);\n        long[] result = getTimeSinceBornUntilNow(birthDate);\n        assertArrayEquals(new long[]{0, 7, 22, 15, 46}, result); // 7 months, 22 days, 15 hours, 46 minutes\n    }\n\n    @Test\n    public void testBirthdayEarlierInMonth() {\n        LocalDateTime birthDate = LocalDateTime.of(2024, 8, 1, 0, 0);\n        long[] result = getTimeSinceBornUntilNow(birthDate);\n        assertArrayEquals(new long[]{0, 0, 22, 15, 45}, result); // 22 days, 15 hours, 45 minutes\n    }\n\n    @Test\n    public void testBirthdayLaterInYearBeforeMonth() {\n        LocalDateTime birthDate = LocalDateTime.of(2024, 1, 1, 1, 0);\n        long[] result = getTimeSinceBornUntilNow(birthDate);\n        assertArrayEquals(new long[]{0, 7, 22, 14, 45}, result); // 7 months, 22 days, 14 hours, 45 minutes\n    }\n\n    @Test\n    public void testBirthdayPreviousMonth() {\n        LocalDateTime birthDate = LocalDateTime.of(2024, 7, 30, 10, 0);\n        long[] result = getTimeSinceBornUntilNow(birthDate);\n        assertArrayEquals(new long[]{0, 0, 24, 5, 45}, result); // 24 days, 5 hours, 45 minutes\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units.\n * @param birthDate the date of birth\n * @return an array containing years, months, days, hours, and minutes\n */\npublic static int[] getTimeSinceBornUntilNow(Date birthDate) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 141, "code_type": "method", "original_language": "typescript", "file_path": "whiskerweb\\9a52b42647ff91ba28f974d5cdc29f6172fe1c81\\src\\engine\\HelperFunctions\\compareArrays.ts", "question_type": "Algorithm and data structure", "summary": "implement a generic compareArrays function that compares the elements of two arrays to each other", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "/**\n * Compares two arrays to determine if they contain the same unique elements, irrespective of order.\n *\n * @param arr1 - The first array to compare. Elements can be of any type T.\n * @param arr2 - The second array to compare. Elements should be of the same type as the first array.\n * @return Returns true if both arrays contain the same unique elements, otherwise returns false.\n *\n * @param <T> - The type of the elements in the arrays.\n */\npublic static <T> boolean compareArrays(T[] arr1, T[] arr2) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testIdenticalArraysSameOrder() {\n        Integer[] arr1 = {1, 2, 3};\n        Integer[] arr2 = {1, 2, 3};\n        assertTrue(compareArrays(arr1, arr2));\n    }\n\n    @Test\n    public void testIdenticalArraysDifferentOrder() {\n        Integer[] arr1 = {3, 2, 1};\n        Integer[] arr2 = {1, 2, 3};\n        assertTrue(compareArrays(arr1, arr2));\n    }\n\n    @Test\n    public void testDifferentElements() {\n        Integer[] arr1 = {1, 2, 3};\n        Integer[] arr2 = {4, 5, 6};\n        assertFalse(compareArrays(arr1, arr2));\n    }\n\n    @Test\n    public void testDifferentLengths() {\n        Integer[] arr1 = {1, 2, 3};\n        Integer[] arr2 = {1, 2};\n        assertFalse(compareArrays(arr1, arr2));\n    }\n\n    @Test\n    public void testDuplicateElementsSameUniqueSet() {\n        Integer[] arr1 = {1, 1, 2, 3, 3};\n        Integer[] arr2 = {3, 2, 1, 1};\n        assertTrue(compareArrays(arr1, arr2));\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Compares two arrays to determine if they contain the same unique elements, irrespective of order.\n *\n * @param arr1 - The first array to compare. Elements can be of any type T.\n * @param arr2 - The second array to compare. Elements should be of the same type as the first array.\n * @return Returns true if both arrays contain the same unique elements, otherwise returns false.\n *\n * @param <T> - The type of the elements in the arrays.\n */\npublic static <T> boolean compareArrays(T[] arr1, T[] arr2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 142, "code_type": "method", "original_language": "typescript", "file_path": "scouting-app-2024\\c83197ba3adfb9a8c604255361df47ae3023e145\\client\\src\\lib\\camelCaseConvert.ts", "question_type": "Program input code", "summary": "convert a string with hump nomenclature to a string with spaces and capitalize the initial letter\n", "language_version_list": {"python": {"code_signature": "def camel_case_to_capitalized_with_spaces(input: str) -> str:\n    \"\"\"\n    Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n\n    For example:\n        input: \"thisIsTest\"\n        output: \"This is test\"\n\n    Args:\n        input_string (str): The camelCase string to be converted.\n\n    Returns:\n        str: The converted string with spaces and initial capitalization.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCamelCaseConversion(unittest.TestCase):\n\n    def test_simple_camel_case(self):\n        input = \"thisIsTest\"\n        expected_output = \"This is test\"\n        self.assertEqual(camel_case_to_capitalized_with_spaces(input), expected_output)\n\n    def test_single_word_lowercase(self):\n        input = \"example\"\n        expected_output = \"Example\"\n        self.assertEqual(camel_case_to_capitalized_with_spaces(input), expected_output)\n\n    def test_multiple_uppercase_letters(self):\n        input = \"thisIsAnExampleString\"\n        expected_output = \"This is an example string\"\n        self.assertEqual(camel_case_to_capitalized_with_spaces(input), expected_output)\n\n    def test_single_uppercase_letter(self):\n        input = \"aSingleUppercaseLetterX\"\n        expected_output = \"A single uppercase letter x\"\n        self.assertEqual(camel_case_to_capitalized_with_spaces(input), expected_output)\n\n    def test_already_capitalized_string(self):\n        input = \"AlreadyCapitalized\"\n        expected_output = \"Already capitalized\"\n        self.assertEqual(camel_case_to_capitalized_with_spaces(input), expected_output)", "prompt": "please write a python function , the function signature as below def camel_case_to_capitalized_with_spaces(input: str) -> str:\n    \"\"\"\n    Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n\n    For example:\n        input: \"thisIsTest\"\n        output: \"This is test\"\n\n    Args:\n        input_string (str): The camelCase string to be converted.\n\n    Returns:\n        str: The converted string with spaces and initial capitalization.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n * For example:\n *      input: \"thisIsTest\"\n *      output: \"This is test\"\n *\n * @param input The camelCase string to be converted.\n * @returns The converted string with spaces and initial capitalization.\n */\nstd::string camelCaseToCapitalizedWithSpaces(const std::string& input) {\n    // Implementation goes here\n}", "test_code": "TEST_CASE(\"convertCamelCaseToSentence\") {\n    SECTION(\"should convert a simple camelCase string to a sentence\") {\n        std::string input = \"thisIsTest\";\n        std::string expectedOutput = \"This is test\";\n        REQUIRE(camelCaseToCapitalizedWithSpaces(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle single word starting with lowercase\") {\n        std::string input = \"example\";\n        std::string expectedOutput = \"Example\";\n        REQUIRE(camelCaseToCapitalizedWithSpaces(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle a camelCase string with multiple uppercase letters\") {\n        std::string input = \"thisIsAnExampleString\";\n        std::string expectedOutput = \"This is an example string\";\n        REQUIRE(camelCaseToCapitalizedWithSpaces(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle a single uppercase letter\") {\n        std::string input = \"aSingleUppercaseLetterX\";\n        std::string expectedOutput = \"A single uppercase letter x\";\n        REQUIRE(camelCaseToCapitalizedWithSpaces(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle an already capitalized string\") {\n        std::string input = \"AlreadyCapitalized\";\n        std::string expectedOutput = \"Already capitalized\";\n        REQUIRE(camelCaseToCapitalizedWithSpaces(input) == expectedOutput);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n * For example:\n *      input: \"thisIsTest\"\n *      output: \"This is test\"\n *\n * @param input The camelCase string to be converted.\n * @returns The converted string with spaces and initial capitalization.\n */\nstd::string camelCaseToCapitalizedWithSpaces(const std::string& input) {\n    // Implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n * For example:\n *      input: \"thisIsTest\"\n *      output: \"This is test\"\n *\n * @param input The camelCase string to be converted.\n * @return The converted string with spaces and initial capitalization.\n */\npublic static String camelCaseToCapitalizedWithSpaces(String input) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testConvertSimpleCamelCase() {\n        // Test for a simple camelCase string\n        String input = \"thisIsTest\";\n        String expectedOutput = \"This is test\";\n        assertEquals(expectedOutput, camelCaseToCapitalizedWithSpaces(input));\n    }\n\n    @Test\n    public void testConvertSingleLowercaseWord() {\n        // Test for a single word starting with lowercase\n        String input = \"example\";\n        String expectedOutput = \"Example\";\n        assertEquals(expectedOutput, camelCaseToCapitalizedWithSpaces(input));\n    }\n\n    @Test\n    public void testConvertCamelCaseWithMultipleUppercase() {\n        // Test for a camelCase string with multiple uppercase letters\n        String input = \"thisIsAnExampleString\";\n        String expectedOutput = \"This is an example string\";\n        assertEquals(expectedOutput, camelCaseToCapitalizedWithSpaces(input));\n    }\n\n    @Test\n    public void testConvertSingleUppercaseLetter() {\n        // Test for a single uppercase letter\n        String input = \"aSingleUppercaseLetterX\";\n        String expectedOutput = \"A single uppercase letter x\";\n        assertEquals(expectedOutput, camelCaseToCapitalizedWithSpaces(input));\n    }\n\n    @Test\n    public void testConvertAlreadyCapitalizedString() {\n        // Test for an already capitalized string\n        String input = \"AlreadyCapitalized\";\n        String expectedOutput = \"Already capitalized\";\n        assertEquals(expectedOutput, camelCaseToCapitalizedWithSpaces(input));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n * For example:\n *      input: \"thisIsTest\"\n *      output: \"This is test\"\n *\n * @param input The camelCase string to be converted.\n * @return The converted string with spaces and initial capitalization.\n */\npublic static String camelCaseToCapitalizedWithSpaces(String input) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 143, "code_type": "method", "original_language": "typescript", "file_path": "fintrack\\e39079007a57d383b978833e4a7dd24d82329457\\src\\lib\\utils.ts", "question_type": "Data processing and transformation", "summary": "convert Arabic digits in the string to corresponding English digits\n", "language_version_list": {"python": {"code_signature": "def arabic_to_english_numbers(s: str) -> str:\n    \"\"\"\n    Converts Arabic digits in the string to corresponding English digits.\n\n    Args:\n        s (str): The input string containing Arabic digits.\n\n    Returns:\n        str: The string with Arabic digits converted to English digits.\n    \"\"\"", "test_code": "import unittest\nclass TestArabicToEnglishNumbers(unittest.TestCase):\n    \n    def test_convert_arabic_numerals_to_english_numerals(self):\n        input_str = \"\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660\"\n        expected_output = \"1234567890\"\n        self.assertEqual(arabic_to_english_numbers(input_str), expected_output)\n\n    def test_return_same_string_if_no_arabic_numerals(self):\n        input_str = \"Hello, World!\"\n        expected_output = \"Hello, World!\"\n        self.assertEqual(arabic_to_english_numbers(input_str), expected_output)\n\n    def test_handle_mixed_arabic_numerals_and_english_characters(self):\n        input_str = \"\u0631\u0642\u0645 \u0661\u0662\u0663 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\"\n        expected_output = \"\u0631\u0642\u0645 123 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\"\n        self.assertEqual(arabic_to_english_numbers(input_str), expected_output)\n\n    def test_handle_empty_string(self):\n        input_str = \"\"\n        expected_output = \"\"\n        self.assertEqual(arabic_to_english_numbers(input_str), expected_output)\n\n    def test_handle_string_with_mixed_arabic_and_english_numerals(self):\n        input_str = \"The number is \u0663\u0665\u0666 and 789.\"\n        expected_output = \"The number is 356 and 789.\"\n        self.assertEqual(arabic_to_english_numbers(input_str), expected_output)", "prompt": "please write a python function , the function signature as below def arabic_to_english_numbers(s: str) -> str:\n    \"\"\"\n    Converts Arabic digits in the string to corresponding English digits.\n\n    Args:\n        s (str): The input string containing Arabic digits.\n\n    Returns:\n        str: The string with Arabic digits converted to English digits.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * convert Arabic digits in the string to corresponding English digits\n * @param str\n * @return converted string with English digits\n */\nstd::string arabicToEnglishNumbers(const std::string& str) {\n    // Function implementation goes here\n}", "test_code": "TEST_CASE(\"arabicToEnglishNumbers\") {\n    SECTION(\"should convert Arabic numerals to English numerals\") {\n        std::string input = \"\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660\";\n        std::string expectedOutput = \"1234567890\";\n        REQUIRE(arabicToEnglishNumbers(input) == expectedOutput);\n    }\n\n    SECTION(\"should return the same string if there are no Arabic numerals\") {\n        std::string input = \"Hello, World!\";\n        std::string expectedOutput = \"Hello, World!\";\n        REQUIRE(arabicToEnglishNumbers(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle a mix of Arabic numerals and English characters\") {\n        std::string input = \"\u0631\u0642\u0645 \u0661\u0662\u0663 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\";\n        std::string expectedOutput = \"\u0631\u0642\u0645 123 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\";\n        REQUIRE(arabicToEnglishNumbers(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle empty string\") {\n        std::string input = \"\";\n        std::string expectedOutput = \"\";\n        REQUIRE(arabicToEnglishNumbers(input) == expectedOutput);\n    }\n\n    SECTION(\"should handle a string with mixed Arabic and English numerals\") {\n        std::string input = \"The number is \u0663\u0665\u0666 and 789.\";\n        std::string expectedOutput = \"The number is 356 and 789.\";\n        REQUIRE(arabicToEnglishNumbers(input) == expectedOutput);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * convert Arabic digits in the string to corresponding English digits\n * @param str\n * @return converted string with English digits\n */\nstd::string arabicToEnglishNumbers(const std::string& str) {\n    // Function implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Convert Arabic digits in the string to corresponding English digits.\n * @param str the input string containing Arabic digits\n * @return a string with Arabic digits replaced by English digits\n */\npublic static String arabicToEnglishNumbers(String str) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testConvertsSingleArabicNumeralsToEnglish() {\n        assertEquals(\"1\", arabicToEnglishNumbers(\"\u0661\"));\n        assertEquals(\"5\", arabicToEnglishNumbers(\"\u0665\"));\n        assertEquals(\"9\", arabicToEnglishNumbers(\"\u0669\"));\n    }\n\n    @Test\n    public void testConvertsStringOfArabicNumeralsToEnglish() {\n        assertEquals(\"0123456789\", arabicToEnglishNumbers(\"\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\"));\n    }\n\n    @Test\n    public void testHandlesStringsWithArabicAndEnglishNumeralsMixed() {\n        assertEquals(\"012345\", arabicToEnglishNumbers(\"\u0660\u066123\u06645\"));\n    }\n\n    @Test\n    public void testLeavesNonNumeralCharactersUnchanged() {\n        assertEquals(\"Hello World!\", arabicToEnglishNumbers(\"Hello World!\"));\n        assertEquals(\"2022-2023\", arabicToEnglishNumbers(\"2022-\u0662\u0660\u0662\u0663\"));\n    }\n\n    @Test\n    public void testWorksWithFullSentencesIncludingArabicNumerals() {\n        assertEquals(\"The year is 2024!\", arabicToEnglishNumbers(\"The year is \u0662\u0660\u0662\u0664!\"));\n    }\n\n    @Test\n    public void testHandlesEmptyStringsCorrectly() {\n        assertEquals(\"\", arabicToEnglishNumbers(\"\"));\n    }\n\n    @Test\n    public void testProcessesArabicNumeralsInComplexMixedContext() {\n        assertEquals(\"Price: 500$ and Date: 2023-12-01\", \n                     arabicToEnglishNumbers(\"Price: \u0665\u0660\u0660$ and Date: \u0662\u0660\u0662\u0663-\u0661\u0662-\u0660\u0661\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Convert Arabic digits in the string to corresponding English digits.\n * @param str the input string containing Arabic digits\n * @return a string with Arabic digits replaced by English digits\n */\npublic static String arabicToEnglishNumbers(String str) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 144, "code_type": "method", "original_language": "typescript", "file_path": "fintrack\\e39079007a57d383b978833e4a7dd24d82329457\\src\\lib\\utils.ts", "question_type": "Data processing and transformation", "summary": "Converts a string containing Arabic numbers to a floating point number", "language_version_list": {"python": {"code_signature": "def arabic_to_english_numbers(value: str) -> str:\n    \"\"\"\n    Converts Arabic numerals in a string to English numerals.\n    This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n    with their corresponding English numerals (0-9) while leaving other characters unchanged.\n    For example:\n         input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n         output: 012345678\n\n    Args:\n        value (str): The string containing Arabic numerals to be converted.\n\n    Returns:\n        str: The converted string with Arabic numerals replaced by English numerals.\n    \"\"\"", "test_code": "import unittest\n\nclass TestArabicToEnglishNumbers(unittest.TestCase):\n    \n    def test_converts_single_arabic_numerals_to_english(self):\n        self.assertEqual(arabic_to_english_numbers('\u0661'), '1')\n        self.assertEqual(arabic_to_english_numbers('\u0665'), '5')\n        self.assertEqual(arabic_to_english_numbers('\u0669'), '9')\n\n    def test_converts_a_string_of_arabic_numerals_to_english(self):\n        self.assertEqual(arabic_to_english_numbers('\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669'), '0123456789')\n\n    def test_handles_strings_with_arabic_and_english_numerals_mixed(self):\n        self.assertEqual(arabic_to_english_numbers('\u0660\u066123\u06645'), '012345')\n\n    def test_leaves_non_numeral_characters_unchanged(self):\n        self.assertEqual(arabic_to_english_numbers('Hello World!'), 'Hello World!')\n        self.assertEqual(arabic_to_english_numbers('2022-\u0662\u0660\u0662\u0663'), '2022-2023')\n\n    def test_works_with_full_sentences_that_include_arabic_numerals(self):\n        self.assertEqual(arabic_to_english_numbers('The year is \u0662\u0660\u0662\u0664!'), 'The year is 2024!')\n\n    def test_handles_empty_strings_correctly(self):\n        self.assertEqual(arabic_to_english_numbers(''), '')\n\n    def test_processes_arabic_numerals_in_a_complex_mixed_context(self):\n        self.assertEqual(arabic_to_english_numbers('Price: \u0665\u0660\u0660$ and Date: \u0662\u0660\u0662\u0663-\u0661\u0662-\u0660\u0661'), 'Price: 500$ and Date: 2023-12-01')\n", "prompt": "please write a python function , the function signature as below def arabic_to_english_numbers(value: str) -> str:\n    \"\"\"\n    Converts Arabic numerals in a string to English numerals.\n    This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n    with their corresponding English numerals (0-9) while leaving other characters unchanged.\n    For example:\n         input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n         output: 012345678\n\n    Args:\n        value (str): The string containing Arabic numerals to be converted.\n\n    Returns:\n        str: The converted string with Arabic numerals replaced by English numerals.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts Arabic numerals in a string to English numerals.\n * This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n * with their corresponding English numerals (0-9) while leaving other characters unchanged.\n * For example:\n *      input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n *      output: 012345678\n *\n * @param value - The string containing Arabic numerals to be converted.\n * @returns The converted string with Arabic numerals replaced by English numerals.\n */\nstd::string arabicToEnglishNumbers(const std::string& value) {\n    // Implementation goes here\n}", "test_code": "TEST_CASE(\"arabicToEnglishNumbers\", \"[conversion]\") {\n    SECTION(\"converts single Arabic numerals to English\") {\n        REQUIRE(arabicToEnglishNumbers(\"\u0661\") == \"1\");\n        REQUIRE(arabicToEnglishNumbers(\"\u0665\") == \"5\");\n        REQUIRE(arabicToEnglishNumbers(\"\u0669\") == \"9\");\n    }\n\n    SECTION(\"converts a string of Arabic numerals to English\") {\n        REQUIRE(arabicToEnglishNumbers(\"\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\") == \"0123456789\");\n    }\n\n    SECTION(\"handles strings with Arabic and English numerals mixed\") {\n        REQUIRE(arabicToEnglishNumbers(\"\u0660\u066123\u06645\") == \"012345\");\n    }\n\n    SECTION(\"leaves non-numeral characters unchanged\") {\n        REQUIRE(arabicToEnglishNumbers(\"Hello World!\") == \"Hello World!\");\n        REQUIRE(arabicToEnglishNumbers(\"2022-\u0662\u0660\u0662\u0663\") == \"2022-2023\");\n    }\n\n    SECTION(\"works with full sentences that include Arabic numerals\") {\n        REQUIRE(arabicToEnglishNumbers(\"The year is \u0662\u0660\u0662\u0664!\") == \"The year is 2024!\");\n    }\n\n    SECTION(\"handles empty strings correctly\") {\n        REQUIRE(arabicToEnglishNumbers(\"\") == \"\");\n    }\n\n    SECTION(\"processes Arabic numerals in a complex mixed context\") {\n        REQUIRE(arabicToEnglishNumbers(\"Price: \u0665\u0660\u0660$ and Date: \u0662\u0660\u0662\u0663-\u0661\u0662-\u0660\u0661\") == \"Price: 500$ and Date: 2023-12-01\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts Arabic numerals in a string to English numerals.\n * This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n * with their corresponding English numerals (0-9) while leaving other characters unchanged.\n * For example:\n *      input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n *      output: 012345678\n *\n * @param value - The string containing Arabic numerals to be converted.\n * @returns The converted string with Arabic numerals replaced by English numerals.\n */\nstd::string arabicToEnglishNumbers(const std::string& value) {\n    // Implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts Arabic numerals in a string to English numerals.\n * This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n * with their corresponding English numerals (0-9) while leaving other characters unchanged.\n * For example:\n *      input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n *      output: 012345678\n *\n * @param value - The string containing Arabic numerals to be converted.\n * @return The converted string with Arabic numerals replaced by English numerals.\n */\npublic static String arabicToEnglishNumbers(String value) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testConvertsSingleArabicNumeralsToEnglish() {\n        assertEquals(\"1\", NumberConverter.arabicToEnglishNumbers(\"\u0661\"));\n        assertEquals(\"5\", NumberConverter.arabicToEnglishNumbers(\"\u0665\"));\n        assertEquals(\"9\", NumberConverter.arabicToEnglishNumbers(\"\u0669\"));\n    }\n\n    @Test\n    public void testConvertsStringOfArabicNumeralsToEnglish() {\n        assertEquals(\"0123456789\", NumberConverter.arabicToEnglishNumbers(\"\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\"));\n    }\n\n    @Test\n    public void testHandlesStringsWithArabicAndEnglishNumeralsMixed() {\n        assertEquals(\"012345\", NumberConverter.arabicToEnglishNumbers(\"\u0660\u066123\u06645\"));\n    }\n\n    @Test\n    public void testLeavesNonNumeralCharactersUnchanged() {\n        assertEquals(\"Hello World!\", NumberConverter.arabicToEnglishNumbers(\"Hello World!\"));\n        assertEquals(\"2022-2023\", NumberConverter.arabicToEnglishNumbers(\"2022-\u0662\u0660\u0662\u0663\"));\n    }\n\n    @Test\n    public void testWorksWithFullSentencesIncludingArabicNumerals() {\n        assertEquals(\"The year is 2024!\", NumberConverter.arabicToEnglishNumbers(\"The year is \u0662\u0660\u0662\u0664!\"));\n    }\n\n    @Test\n    public void testHandlesEmptyStringsCorrectly() {\n        assertEquals(\"\", NumberConverter.arabicToEnglishNumbers(\"\"));\n    }\n\n    @Test\n    public void testProcessesArabicNumeralsInComplexMixedContext() {\n        assertEquals(\"Price: 500$ and Date: 2023-12-01\", \n                     NumberConverter.arabicToEnglishNumbers(\"Price: \u0665\u0660\u0660$ and Date: \u0662\u0660\u0662\u0663-\u0661\u0662-\u0660\u0661\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts Arabic numerals in a string to English numerals.\n * This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n * with their corresponding English numerals (0-9) while leaving other characters unchanged.\n * For example:\n *      input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n *      output: 012345678\n *\n * @param value - The string containing Arabic numerals to be converted.\n * @return The converted string with Arabic numerals replaced by English numerals.\n */\npublic static String arabicToEnglishNumbers(String value) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 145, "code_type": "method", "original_language": "typescript", "file_path": "fintrack\\e39079007a57d383b978833e4a7dd24d82329457\\src\\lib\\utils.ts", "question_type": "Data processing and transformation", "summary": "Format a number as a string representation of the specified currency. It uses the given locale and currencyCode to generate string output that matches the currency format for that locale.", "language_version_list": {"python": {"code_signature": "def format_currency(value: float, currency_code: str, locale: str = \"en_US\") -> str:\n    \"\"\"\n    Formats a number as currency according to the specified locale and currency code.\n\n    Args:\n        value (float): The numerical value to be formatted.\n        currency_code (str): The currency code (e.g., \"USD\", \"EUR\").\n        locale (str): The locale string (e.g., \"en_US\", \"fr_FR\"). Default is \"en_US\".\n\n    Returns:\n        str: The formatted currency string.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestFormatCurrency(unittest.TestCase):\n    \n    def test_format_currency_usd(self):\n        value = 1234.56\n        currency_code = 'USD'\n        locale = 'en-US'\n        expected_output = '\\$1,234.56'  # Expected format for USD\n        self.assertEqual(format_currency(value, currency_code, locale), expected_output)\n\n    def test_format_currency_euro(self):\n        value = 1234.56\n        currency_code = 'EUR'\n        locale = 'en-US'\n        expected_output = '\u20ac1,234.56'  # Expected format for EUR\n        self.assertEqual(format_currency(value, currency_code, locale), expected_output)\n\n    def test_format_currency_gbp(self):\n        value = 1234.56\n        currency_code = 'GBP'\n        locale = 'en-GB'\n        expected_output = '\u00a31,234.56'  # Expected format for GBP\n        self.assertEqual(format_currency(value, currency_code, locale), expected_output)\n\n    def test_format_currency_negative(self):\n        value = -1234.56\n        currency_code = 'USD'\n        locale = 'en-US'\n        expected_output = '-\\$1,234.56'  # Expected format for negative USD\n        self.assertEqual(format_currency(value, currency_code, locale), expected_output)\n\n    def test_format_currency_zero(self):\n        value = 0\n        currency_code = 'JPY'\n        locale = 'en-JP'\n        expected_output = '\u00a50'  # Expected format for JPY (no decimals)\n        self.assertEqual(format_currency(value, currency_code, locale), expected_output)", "prompt": "please write a python function , the function signature as below def format_currency(value: float, currency_code: str, locale: str = \"en_US\") -> str:\n    \"\"\"\n    Formats a number as currency according to the specified locale and currency code.\n\n    Args:\n        value (float): The numerical value to be formatted.\n        currency_code (str): The currency code (e.g., \"USD\", \"EUR\").\n        locale (str): The locale string (e.g., \"en_US\", \"fr_FR\"). Default is \"en_US\".\n\n    Returns:\n        str: The formatted currency string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Formats a number as currency according to the specified locale and currency code.\n *\n * @param value - The numerical value to be formatted.\n * @param currencyCode - The currency code (e.g., \"USD\", \"EUR\").\n * @param locale - The locale string (e.g., \"en-US\", \"fr-FR\"). Default is \"en-US\".\n * @returns The formatted currency string.\n */\nstd::string formatCurrency(double value, const std::string& currencyCode, const std::string& locale = \"en-US\") {\n    // Function implementation goes here\n}", "test_code": "TEST_CASE(\"formatCurrency function tests\") {\n    SECTION(\"should format currency in US dollars\") {\n        double value = 1234.56;\n        std::string currencyCode = \"USD\";\n        std::string locale = \"en-US\";\n        std::string expectedOutput = \"$1,234.56\"; // Expected format for USD\n        REQUIRE(formatCurrency(value, currencyCode, locale) == expectedOutput);\n    }\n\n    SECTION(\"should format currency in Euro\") {\n        double value = 1234.56;\n        std::string currencyCode = \"EUR\";\n        std::string locale = \"en-US\";\n        std::string expectedOutput = \"\u20ac1,234.56\"; // Expected format for EUR\n        REQUIRE(formatCurrency(value, currencyCode, locale) == expectedOutput);\n    }\n\n    SECTION(\"should format currency in British Pound\") {\n        double value = 1234.56;\n        std::string currencyCode = \"GBP\";\n        std::string locale = \"en-GB\";\n        std::string expectedOutput = \"\u00a31,234.56\"; // Expected format for GBP\n        REQUIRE(formatCurrency(value, currencyCode, locale) == expectedOutput);\n    }\n\n    SECTION(\"should format currency with a negative value\") {\n        double value = -1234.56;\n        std::string currencyCode = \"USD\";\n        std::string locale = \"en-US\";\n        std::string expectedOutput = \"-$1,234.56\"; // Expected format for negative USD\n        REQUIRE(formatCurrency(value, currencyCode, locale) == expectedOutput);\n    }\n\n    SECTION(\"should handle zero value correctly\") {\n        double value = 0;\n        std::string currencyCode = \"JPY\";\n        std::string locale = \"en-JP\";\n        std::string expectedOutput = \"\u00a50\"; // Expected format for JPY (no decimals)\n        REQUIRE(formatCurrency(value, currencyCode, locale) == expectedOutput);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Formats a number as currency according to the specified locale and currency code.\n *\n * @param value - The numerical value to be formatted.\n * @param currencyCode - The currency code (e.g., \"USD\", \"EUR\").\n * @param locale - The locale string (e.g., \"en-US\", \"fr-FR\"). Default is \"en-US\".\n * @returns The formatted currency string.\n */\nstd::string formatCurrency(double value, const std::string& currencyCode, const std::string& locale = \"en-US\") {\n    // Function implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Formats a number as currency according to the specified locale and currency code.\n *\n * @param value - The numerical value to be formatted.\n * @param currencyCode - The currency code (e.g., \"USD\", \"EUR\").\n * @param locale - The locale string (e.g., \"en-US\", \"fr-FR\"). Default is \"en-US\".\n * @return The formatted currency string.\n */\npublic static String formatCurrency(double value, String currencyCode, String locale) {\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testFormatCurrencyInUSD() {\n        double value = 1234.56;\n        String currencyCode = \"USD\";\n        String locale = \"en-US\";\n        String expectedOutput = \"$1,234.56\"; // Expected format for USD\n        assertEquals(expectedOutput, formatCurrency(value, currencyCode, locale));\n    }\n\n    @Test\n    public void testFormatCurrencyInEuro() {\n        double value = 1234.56;\n        String currencyCode = \"EUR\";\n        String locale = \"en-US\";\n        String expectedOutput = \"\u20ac1,234.56\"; // Expected format for EUR\n        assertEquals(expectedOutput, formatCurrency(value, currencyCode, locale));\n    }\n\n    @Test\n    public void testFormatCurrencyInBritishPound() {\n        double value = 1234.56;\n        String currencyCode = \"GBP\";\n        String locale = \"en-GB\";\n        String expectedOutput = \"\u00a31,234.56\"; // Expected format for GBP\n        assertEquals(expectedOutput, formatCurrency(value, currencyCode, locale));\n    }\n\n    @Test\n    public void testFormatCurrencyNegativeValue() {\n        double value = -1234.56;\n        String currencyCode = \"USD\";\n        String locale = \"en-US\";\n        String expectedOutput = \"-$1,234.56\"; // Expected format for negative USD\n        assertEquals(expectedOutput, formatCurrency(value, currencyCode, locale));\n    }\n\n    @Test\n    public void testHandleZeroValueCorrectly() {\n        double value = 0;\n        String currencyCode = \"JPY\";\n        String locale = \"en-JP\";\n        String expectedOutput = \"\u00a50\"; // Expected format for JPY (no decimals)\n        assertEquals(expectedOutput, formatCurrency(value, currencyCode, locale));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Formats a number as currency according to the specified locale and currency code.\n *\n * @param value - The numerical value to be formatted.\n * @param currencyCode - The currency code (e.g., \"USD\", \"EUR\").\n * @param locale - The locale string (e.g., \"en-US\", \"fr-FR\"). Default is \"en-US\".\n * @return The formatted currency string.\n */\npublic static String formatCurrency(double value, String currencyCode, String locale) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 146, "code_type": "method", "original_language": "typescript", "file_path": "fintrack\\e39079007a57d383b978833e4a7dd24d82329457\\src\\lib\\utils.ts", "question_type": "Data processing and transformation", "summary": "Format the number of bytes as a human-readable file size string. It displays file sizes in different units and decimal places depending on the options provided.", "language_version_list": {"python": {"code_signature": "def format_bytes(bytes: int, options: dict = None) -> str:\n    \"\"\"\n    Formats a given number of bytes into a human-readable string representation,\n    using either the SI (decimal) or binary (accurate) size notation.\n\n    Args:\n        bytes (int): The number of bytes to format.\n        options (dict, optional): Optional settings to customize the output.\n            - 'decimals' (int): Number of decimal places to include in the result.\n            - 'sizeType' (str): Specifies whether to use binary (\"accurate\") or\n              decimal (\"normal\") units.\n              \"accurate\" uses units like KiB, MiB (base 1024).\n              \"normal\" uses units like KB, MB (base 1000).\n\n    Returns:\n        str: A string representation of the byte size in a human-readable format.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestFormatBytes(unittest.TestCase):\n\n    def test_zero_bytes(self):\n        result = format_bytes(0)\n        self.assertIn(result, ['0 B', '0 Byte'])\n\n    def test_two_kb(self):\n        result = format_bytes(2048)\n        self.assertIn(result, ['2 KB', '2.0 KB'])\n\n    def test_two_kib(self):\n        result = format_bytes(2048, {'sizeType': 'accurate'})\n        self.assertIn(result, ['2 KiB', '2.0 KiB'])\n\n    def test_five_mb(self):\n        result = format_bytes(5242880)\n        self.assertIn(result, ['5 MB', '5.0 MB'])\n\n    def test_five_mib_with_decimals(self):\n        result = format_bytes(5242880, {'decimals': 2, 'sizeType': 'accurate'})\n        self.assertEqual(result, '5.00 MiB')", "prompt": "please write a python function , the function signature as below def format_bytes(bytes: int, options: dict = None) -> str:\n    \"\"\"\n    Formats a given number of bytes into a human-readable string representation,\n    using either the SI (decimal) or binary (accurate) size notation.\n\n    Args:\n        bytes (int): The number of bytes to format.\n        options (dict, optional): Optional settings to customize the output.\n            - 'decimals' (int): Number of decimal places to include in the result.\n            - 'sizeType' (str): Specifies whether to use binary (\"accurate\") or\n              decimal (\"normal\") units.\n              \"accurate\" uses units like KiB, MiB (base 1024).\n              \"normal\" uses units like KB, MB (base 1000).\n\n    Returns:\n        str: A string representation of the byte size in a human-readable format.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param bytes - The number of bytes to format.\n * @param decimals - Optional number of decimal places to include in the output.\n * @param sizeType - Optional specification of whether to use binary (\"accurate\") \n *                   or decimal (\"normal\") units.\n *                   \"accurate\" uses units like KiB, MiB (base 1024).\n *                   \"normal\" uses units like KB, MB (base 1000).\n * @returns A string representation of the byte size in a human-readable format.\n */\nstd::string formatBytes()", "test_code": "TEST_CASE(\"formatBytes\", \"[formatBytes]\") {\n    SECTION(\"should return '0 Byte' for 0 bytes\") {\n        auto result = formatBytes(0);\n        REQUIRE(result == \"0 Byte\" || result == \"0 B\");\n    }\n\n    SECTION(\"should return '2.0 KB' for 2048 bytes\") {\n        auto result = formatBytes(2048);\n        REQUIRE(result == \"2 KB\" || result == \"2.0 KB\");\n    }\n\n    SECTION(\"should return '2.0 KiB' for 2048 bytes with sizeType 'accurate'\") {\n        auto result = formatBytes(2048, std::nullopt, \"accurate\");\n        REQUIRE(result == \"2 KiB\" || result == \"2.0 KiB\");\n    }\n\n    SECTION(\"should return '5.0 MB' for 5242880 bytes\") {\n        auto result = formatBytes(5242880);\n        REQUIRE(result == \"5 MB\" || result == \"5.0 MB\");\n    }\n\n    SECTION(\"should return '5.00 MiB' for 5242880 bytes with 2 decimal places and sizeType 'accurate'\") {\n        auto result = formatBytes(5242880, 2, \"accurate\");\n        REQUIRE(result == \"5.00 MiB\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param bytes - The number of bytes to format.\n * @param decimals - Optional number of decimal places to include in the output.\n * @param sizeType - Optional specification of whether to use binary (\"accurate\") \n *                   or decimal (\"normal\") units.\n *                   \"accurate\" uses units like KiB, MiB (base 1024).\n *                   \"normal\" uses units like KB, MB (base 1000).\n * @returns A string representation of the byte size in a human-readable format.\n */\nstd::string formatBytes()", "addition_info": ""}, "java": {"code_signature": "/**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param bytes The number of bytes to format.\n * @param options Optional settings to customize the output.\n * @param options.decimals Number of decimal places to include in the formatted result.\n * @param options.sizeType Specifies whether to use binary (\"accurate\") or decimal (\"normal\") units.\n *        \"accurate\" uses units like KiB, MiB (base 1024).\n *        \"normal\" uses units like KB, MB (base 1000).\n * @returns A string representation of the byte size in a human-readable format.\n */\npublic static String formatBytes(long bytes, FormatOptions options) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\n\npublic class Tester {\n\n    public static String arrayBufferToString(ByteBuffer buffer) {\n        byte[] byteArray = new byte[buffer.remaining()];\n        buffer.get(byteArray);\n        return new String(byteArray, StandardCharsets.UTF_8);\n    }\n\n    @Test\n    public void testEmptyBuffer() {\n        ByteBuffer buffer1 = ByteBuffer.allocate(0);\n        String result = arrayBufferToString(buffer1);\n        assertEquals(\"\", result); // Expected: \"\"\n    }\n\n    @Test\n    public void testSingleCharacter() {\n        ByteBuffer buffer2 = ByteBuffer.wrap(\"A\".getBytes(StandardCharsets.UTF_8));\n        String result = arrayBufferToString(buffer2);\n        assertEquals(\"A\", result); // Expected: \"A\"\n    }\n\n    @Test\n    public void testHelloString() {\n        ByteBuffer buffer3 = ByteBuffer.wrap(\"Hello\".getBytes(StandardCharsets.UTF_8));\n        String result = arrayBufferToString(buffer3);\n        assertEquals(\"Hello\", result); // Expected: \"Hello\"\n    }\n\n    @Test\n    public void testMultipleCharacters() {\n        ByteBuffer buffer4 = ByteBuffer.wrap(\"Hello, World!\".getBytes(StandardCharsets.UTF_8));\n        String result = arrayBufferToString(buffer4);\n        assertEquals(\"Hello, World!\", result); // Expected: \"Hello, World!\"\n    }\n    \n}", "prompt": "please write a java function , the function signature as below /**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param bytes The number of bytes to format.\n * @param options Optional settings to customize the output.\n * @param options.decimals Number of decimal places to include in the formatted result.\n * @param options.sizeType Specifies whether to use binary (\"accurate\") or decimal (\"normal\") units.\n *        \"accurate\" uses units like KiB, MiB (base 1024).\n *        \"normal\" uses units like KB, MB (base 1000).\n * @returns A string representation of the byte size in a human-readable format.\n */\npublic static String formatBytes(long bytes, FormatOptions options) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 147, "code_type": "method", "original_language": "typescript", "file_path": "factor\\fa8fdc17e29935d1be565650e19fef1cf7d107d8\\src\\util\\webauthn.ts", "question_type": "Network requests and API call", "summary": "Converts the ArrayBuffer object to a string", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 148, "code_type": "method", "original_language": "typescript", "file_path": "factor\\fa8fdc17e29935d1be565650e19fef1cf7d107d8\\src\\util\\webauthn.ts", "question_type": "Network requests and API call", "summary": "Converts a base64-encoded string to an ArrayBuffer. An ArrayBuffer is a generic, fixed-length buffer of raw binary data that is commonly used to represent binary data.", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 150, "code_type": "method", "original_language": "typescript", "file_path": "color-editor\\faf5fa2f8292bbcf8e6267ec4d524e99cb0f52ec\\src\\Helper.ts", "question_type": "Data processing and transformation", "summary": "Convert RGB colors to and from hexadecimal color format.", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef rgb_to_hex(rgb: Dict):\n    \"\"\"\n    Convert an RGB color object to a HEX color string.\n\n    Args:\n        rgb (dict): An object containing the red, green, and blue components of the color.\n                    Example: {'r': 255, 'g': 0, 'b': 0}\n\n    Returns:\n        str: A string representing the HEX color code.\n             Example: \"#FF0000\" for red.\n    \"\"\"\n\n\ndef hex_to_rgb(hex_color: str):\n    \"\"\"\n    Convert a HEX color string to an RGB color object.\n\n    Args:\n        hex_color (str): A string representing the HEX color code.\n                         Example: \"#FF0000\" for red.\n\n    Returns:\n        dict or None: An object containing the red, green, and blue components of the color.\n                       Returns None if the HEX code is invalid.\n                       Example: {'r': 255, 'g': 0, 'b': 0} for red.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestColorConversion(unittest.TestCase):\n    def test_rgb_to_hex(self):\n        rgb = {'r': 255, 'g': 99, 'b': 71}\n        result = rgbToHex(rgb)\n        self.assertEqual(result, '#ff6347')  # Expected HEX code for RGB(255, 99, 71)\n\n    def test_hex_to_rgb(self):\n        hex_code = '#ff6347'\n        result = hexToRgb(hex_code)\n        self.assertEqual(result, {'r': 255, 'g': 99, 'b': 71})  # Expected RGB object for HEX #ff6347\n\n    def test_invalid_rgb_components(self):\n        rgb = {'r': 300, 'g': -10, 'b': 128}\n        result = rgbToHex(rgb)\n        self.assertEqual(result, '#00c080')  # Clamped values should be \"00\", valid value should convert to \"80\"\n\n    def test_invalid_hex_string(self):\n        invalid_hex = '#ggg123'\n        result = hexToRgb(invalid_hex)\n        self.assertIsNone(result)  # Invalid HEX code should return None\n\n    def test_boundary_values_rgb(self):\n        rgb_black = {'r': 0, 'g': 0, 'b': 0}\n        result_black = rgbToHex(rgb_black)\n        self.assertEqual(result_black, '#000000')  # RGB(0, 0, 0) should convert to #000000\n        \n        rgb_white = {'r': 255, 'g': 255, 'b': 255}\n        result_white = rgbToHex(rgb_white)\n        self.assertEqual(result_white, '#ffffff')  # RGB(255, 255, 255) should convert to #ffffff\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef rgb_to_hex(rgb: Dict):\n    \"\"\"\n    Convert an RGB color object to a HEX color string.\n\n    Args:\n        rgb (dict): An object containing the red, green, and blue components of the color.\n                    Example: {'r': 255, 'g': 0, 'b': 0}\n\n    Returns:\n        str: A string representing the HEX color code.\n             Example: \"#FF0000\" for red.\n    \"\"\"\n\n\ndef hex_to_rgb(hex_color: str):\n    \"\"\"\n    Convert a HEX color string to an RGB color object.\n\n    Args:\n        hex_color (str): A string representing the HEX color code.\n                         Example: \"#FF0000\" for red.\n\n    Returns:\n        dict or None: An object containing the red, green, and blue components of the color.\n                       Returns None if the HEX code is invalid.\n                       Example: {'r': 255, 'g': 0, 'b': 0} for red.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - A struct containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\nstd::string rgbToHex(const RGB& rgb);\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An optional struct containing the red, green, and blue components of the color, or nullopt if the HEX code is invalid.\n */\nstd::optional<RGB> hexToRgb(const std::string& hex);", "test_code": "TEST_CASE(\"rgbToHex and hexToRgb\") {\n    \n    // Test the basic logic of rgbToHex function\n    SECTION(\"should correctly convert RGB to HEX\") {\n        RGB rgb = {255, 99, 71};\n        std::string result = rgbToHex(rgb);\n        REQUIRE(result == \"#ff6347\"); // Expected HEX code for RGB(255, 99, 71)\n    }\n\n    // Test the basic logic of hexToRgb function\n    SECTION(\"should correctly convert HEX to RGB\") {\n        std::string hex = \"#ff6347\";\n        auto result = hexToRgb(hex);\n        REQUIRE(result.has_value());\n        REQUIRE(result->r == 255);\n        REQUIRE(result->g == 99);\n        REQUIRE(result->b == 71); // Expected RGB object for HEX #ff6347\n    }\n\n    // Test the exception handling of rgbToHex function\n    SECTION(\"should handle invalid RGB components gracefully\") {\n        RGB rgb = {300, -10, 128};\n        std::string result = rgbToHex(rgb);\n        REQUIRE(result == \"#12c080\"); // Invalid values (300, -10) should be clamped to \"00\", valid value should convert to \"80\"\n    }\n\n    // Test the exception handling of hexToRgb function\n    SECTION(\"should return nullopt for invalid HEX strings\") {\n        std::string invalidHex = \"#ggg123\";\n        auto result = hexToRgb(invalidHex);\n        REQUIRE(!result.has_value()); // Invalid HEX code should return nullopt\n    }\n\n    // Test boundary values for rgbToHex function\n    SECTION(\"should handle boundary values in RGB correctly\") {\n        RGB rgb = {0, 0, 0};\n        std::string result = rgbToHex(rgb);\n        REQUIRE(result == \"#000000\"); // Boundary RGB(0, 0, 0) should convert to #000000\n\n        RGB rgbWhite = {255, 255, 255};\n        std::string resultWhite = rgbToHex(rgbWhite);\n        REQUIRE(resultWhite == \"#ffffff\"); // Boundary RGB(255, 255, 255) should convert to #ffffff\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - A struct containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\nstd::string rgbToHex(const RGB& rgb);\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An optional struct containing the red, green, and blue components of the color, or nullopt if the HEX code is invalid.\n */\nstd::optional<RGB> hexToRgb(const std::string& hex);", "addition_info": ""}, "java": {"code_signature": "/**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - An array containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\npublic static String rgbToHex(int[] rgb) {\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An array containing the red, green, and blue components of the color, or null if the HEX code is invalid.\n */\npublic static int[] hexToRgb(String hex) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    // Test rgbToHex function basic logic\n    @Test\n    public void testRgbToHex() {\n        int[] rgb = {255, 99, 71};\n        String result = rgbToHex(rgb);\n        assertEquals(\"#ff6347\", result); // Expected HEX code for RGB(255, 99, 71)\n    }\n\n    // Test hexToRgb function basic logic\n    @Test\n    public void testHexToRgb() {\n        String hex = \"#ff6347\";\n        int[] result = hexToRgb(hex);\n        assertArrayEquals(new int[]{255, 99, 71}, result); // Expected RGB object for HEX #ff6347\n    }\n    // Test hexToRgb function for invalid HEX strings\n    @Test\n    public void testInvalidHexString() {\n        String invalidHex = \"#ggg123\";\n        int[] result = hexToRgb(invalidHex);\n        assertNull(result); // Invalid HEX code should return null\n    }\n\n    // Test rgbToHex function boundary values\n    @Test\n    public void testBoundaryValuesInRgb() {\n        int[] rgbBlack = {0, 0, 0};\n        String resultBlack = rgbToHex(rgbBlack);\n        assertEquals(\"#000000\", resultBlack); // RGB(0, 0, 0) should convert to #000000\n\n        int[] rgbWhite = {255, 255, 255};\n        String resultWhite = rgbToHex(rgbWhite);\n        assertEquals(\"#ffffff\", resultWhite); // RGB(255, 255, 255) should convert to #ffffff\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - An array containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\npublic static String rgbToHex(int[] rgb) {\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An array containing the red, green, and blue components of the color, or null if the HEX code is invalid.\n */\npublic static int[] hexToRgb(String hex) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 151, "code_type": "method", "original_language": "typescript", "file_path": "color-editor\\faf5fa2f8292bbcf8e6267ec4d524e99cb0f52ec\\src\\Helper.ts", "question_type": "Data processing and transformation", "summary": "Convert RGB color values \u200b\u200bto HSL color values", "language_version_list": {"python": {"code_signature": "def rgb_to_hsl(rgb: dict) -> dict:\n    \"\"\"\n    Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n\n    The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n    - `h` (Hue) in the range of 0 to 360,\n    - `s` (Saturation) in the range of 0 to 100 (percentage),\n    - `l` (Lightness) in the range of 0 to 100 (percentage).\n\n    Args:\n        rgb (dict): The RGB color values.\n            - rgb['r'] (int): The red color value (0-255).\n            - rgb['g'] (int): The green color value (0-255).\n            - rgb['b'] (int): The blue color value (0-255).\n\n    Returns:\n        dict: A dictionary representing the HSL color values.\n            - h (int): The hue value (0-360).\n            - s (int): The saturation value (0-100).\n            - l (int): The lightness value (0-100).\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestRgbToHsl(unittest.TestCase):\n\n    def test_basic_rgb_red(self):\n        rgb = {'r': 255, 'g': 0, 'b': 0}\n        result = rgb_to_hsl(rgb)\n        self.assertEqual(result, {'h': 0, 's': 100, 'l': 50})\n\n    def test_grayscale_middle_gray(self):\n        rgb = {'r': 128, 'g': 128, 'b': 128}\n        result = rgb_to_hsl(rgb)\n        self.assertEqual(result, {'h': 0, 's': 0, 'l': 50})\n\n    def test_edge_case_white(self):\n        rgb = {'r': 255, 'g': 255, 'b': 255}\n        result = rgb_to_hsl(rgb)\n        self.assertEqual(result, {'h': 0, 's': 0, 'l': 100})\n\n    def test_edge_case_black(self):\n        rgb = {'r': 0, 'g': 0, 'b': 0}\n        result = rgb_to_hsl(rgb)\n        self.assertEqual(result, {'h': 0, 's': 0, 'l': 0})\n\n    def test_vibrant_green(self):\n        rgb = {'r': 0, 'g': 255, 'b': 0}\n        result = rgb_to_hsl(rgb)\n        self.assertEqual(result, {'h': 120, 's': 100, 'l': 50})\n\n    def test_deep_blue(self):\n        rgb = {'r': 0, 'g': 0, 'b': 255}\n        result = rgb_to_hsl(rgb)\n        self.assertEqual(result, {'h': 240, 's': 100, 'l': 50})\n", "prompt": "please write a python function , the function signature as below def rgb_to_hsl(rgb: dict) -> dict:\n    \"\"\"\n    Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n\n    The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n    - `h` (Hue) in the range of 0 to 360,\n    - `s` (Saturation) in the range of 0 to 100 (percentage),\n    - `l` (Lightness) in the range of 0 to 100 (percentage).\n\n    Args:\n        rgb (dict): The RGB color values.\n            - rgb['r'] (int): The red color value (0-255).\n            - rgb['g'] (int): The green color value (0-255).\n            - rgb['b'] (int): The blue color value (0-255).\n\n    Returns:\n        dict: A dictionary representing the HSL color values.\n            - h (int): The hue value (0-360).\n            - s (int): The saturation value (0-100).\n            - l (int): The lightness value (0-100).\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param rgb - The RGB color values.\n * @param rgb.r - The red color value (0-255).\n * @param rgb.g - The green color value (0-255).\n * @param rgb.b - The blue color value (0-255).\n * @returns An object representing the HSL color values.\n * @returns h - The hue value (0-360).\n * @returns s - The saturation value (0-100).\n * @returns l - The lightness value (0-100).\n */\nHSL rgbToHsl(const RGB& rgb);", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include \"color_conversion.h\" // Include your header file where rgbToHsl is defined\n\nTEST_CASE(\"rgbToHsl\", \"[color_conversion]\") {\n    SECTION(\"should convert basic RGB values correctly (red)\") {\n        RGB rgb = {255, 0, 0};\n        HSL result = rgbToHsl(rgb);\n        REQUIRE(result.h == 0);\n        REQUIRE(result.s == 100);\n        REQUIRE(result.l == 50);\n    }\n\n    SECTION(\"should handle grayscale values (middle gray)\") {\n        RGB rgb = {128, 128, 128};\n        HSL result = rgbToHsl(rgb);\n        REQUIRE(result.h == 0);\n        REQUIRE(result.s == 0);\n        REQUIRE(result.l == 50);\n    }\n\n    SECTION(\"should handle edge cases (white color)\") {\n        RGB rgb = {255, 255, 255};\n        HSL result = rgbToHsl(rgb);\n        REQUIRE(result.h == 0);\n        REQUIRE(result.s == 0);\n        REQUIRE(result.l == 100);\n    }\n\n    SECTION(\"should handle edge cases (black color)\") {\n        RGB rgb = {0, 0, 0};\n        HSL result = rgbToHsl(rgb);\n        REQUIRE(result.h == 0);\n        REQUIRE(result.s == 0);\n        REQUIRE(result.l == 0);\n    }\n\n    // Additional tests\n    SECTION(\"should handle vibrant green\") {\n        RGB rgb = {0, 255, 0};\n        HSL result = rgbToHsl(rgb);\n        REQUIRE(result.h == 120);\n        REQUIRE(result.s == 100);\n        REQUIRE(result.l == 50);\n    }\n\n    SECTION(\"should handle deep blue\") {\n        RGB rgb = {0, 0, 255};\n        HSL result = rgbToHsl(rgb);\n        REQUIRE(result.h == 240);\n        REQUIRE(result.s == 100);\n        REQUIRE(result.l == 50);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param rgb - The RGB color values.\n * @param rgb.r - The red color value (0-255).\n * @param rgb.g - The green color value (0-255).\n * @param rgb.b - The blue color value (0-255).\n * @returns An object representing the HSL color values.\n * @returns h - The hue value (0-360).\n * @returns s - The saturation value (0-100).\n * @returns l - The lightness value (0-100).\n */\nHSL rgbToHsl(const RGB& rgb);", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param r The red color value (0-255).\n * @param g The green color value (0-255).\n * @param b The blue color value (0-255).\n * @return An HSL object representing the HSL color values.\n * @return.h The hue value (0-360).\n * @return.s The saturation value (0-100).\n * @return.l The lightness value (0-100).\n */\npublic static class HSL {\n    public int h;\n    public int s;\n    public int l;\n\n    public HSL(int h, int s, int l) {\n        this.h = h;\n        this.s = s;\n        this.l = l;\n    }\n}\npublic static HSL rgbToHsl(int r, int g, int b) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testRgbToHslRed() {\n        HSL result = rgbToHsl(255, 0, 0);\n        assertEquals(0, result.h);\n        assertEquals(100, result.s);\n        assertEquals(50, result.l);\n    }\n\n    @Test\n    public void testRgbToHslMiddleGray() {\n        HSL result = rgbToHsl(128, 128, 128);\n        assertEquals(0, result.h);\n        assertEquals(0, result.s);\n        assertEquals(50, result.l);\n    }\n\n    @Test\n    public void testRgbToHslWhite() {\n        HSL result = rgbToHsl(255, 255, 255);\n        assertEquals(0, result.h);\n        assertEquals(0, result.s);\n        assertEquals(100, result.l);\n    }\n\n    @Test\n    public void testRgbToHslBlack() {\n        HSL result = rgbToHsl(0, 0, 0);\n        assertEquals(0, result.h);\n        assertEquals(0, result.s);\n        assertEquals(0, result.l);\n    }\n\n    @Test\n    public void testRgbToHslVibrantGreen() {\n        HSL result = rgbToHsl(0, 255, 0);\n        assertEquals(120, result.h);\n        assertEquals(100, result.s);\n        assertEquals(50, result.l);\n    }\n\n    @Test\n    public void testRgbToHslDeepBlue() {\n        HSL result = rgbToHsl(0, 0, 255);\n        assertEquals(240, result.h);\n        assertEquals(100, result.s);\n        assertEquals(50, result.l);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param r The red color value (0-255).\n * @param g The green color value (0-255).\n * @param b The blue color value (0-255).\n * @return An HSL object representing the HSL color values.\n * @return.h The hue value (0-360).\n * @return.s The saturation value (0-100).\n * @return.l The lightness value (0-100).\n */\npublic static class HSL {\n    public int h;\n    public int s;\n    public int l;\n\n    public HSL(int h, int s, int l) {\n        this.h = h;\n        this.s = s;\n        this.l = l;\n    }\n}\npublic static HSL rgbToHsl(int r, int g, int b) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 152, "code_type": "method", "original_language": "typescript", "file_path": "BibiGPT-v1\\25753bb3f719a0f4c1b39bd136e2ec0d3eeae99d\\utils\\formatSummary.ts", "question_type": "Data processing and transformation", "summary": "Converts each character in the input string to the corresponding \"mathematical sans serif italic\" character.", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 153, "code_type": "method", "original_language": "typescript", "file_path": "abais\\2947d0d885332e9151001cc86b383ce3297439d5\\utils\\userIdGenerator.ts", "question_type": "Data processing and transformation", "summary": "The input hash buffer is compressed into a number letter string of length no less than 5", "language_version_list": {"python": {"code_signature": "def compress_hash(hash_bytes: bytes) -> str:\n    \"\"\"\n    Compresses the input hash buffer into a string representation of at least length 5.\n\n    Args:\n        hash_bytes (bytes): The hash buffer to be compressed.\n\n    Returns:\n        str: A compressed string representation of the hash.\n              The output string will have a length no less than 5.\n    \"\"\"", "test_code": "import hashlib\nimport unittest\n\n\nclass TestCompressHash(unittest.TestCase):\n\n    def test_length_of_result(self):\n        \"\"\"should return a string of length 5\"\"\"\n        hash_bytes = hashlib.sha256(b'test').digest()\n        result = compress_hash(hash_bytes)\n        self.assertEqual(len(result), 5)\n\n    def test_different_inputs(self):\n        \"\"\"should return different strings for different inputs\"\"\"\n        hash1 = hashlib.sha256(b'test1').digest()\n        hash2 = hashlib.sha256(b'test2').digest()\n        result1 = compress_hash(hash1)\n        result2 = compress_hash(hash2)\n        self.assertNotEqual(result1, result2)\n\n    def test_consistent_result_for_same_input(self):\n        \"\"\"should return a consistent result for the same input\"\"\"\n        hash_bytes = hashlib.sha256(b'test').digest()\n        result1 = compress_hash(hash_bytes)\n        result2 = compress_hash(hash_bytes)\n        self.assertEqual(result1, result2)\n\n    def test_all_zeros(self):\n        \"\"\"should handle a hash of all zeros\"\"\"\n        hash_bytes = bytes([0] * 32)  # 32 bytes of zeros\n        result = compress_hash(hash_bytes)\n        self.assertRegex(result, r'^[0-9a-zA-Z]{5}$')\n\n    def test_all_ones(self):\n        \"\"\"should handle a hash of all ones\"\"\"\n        hash_bytes = bytes([255] * 32)  # 32 bytes of 0xFF (255 in decimal)\n        result = compress_hash(hash_bytes)\n        self.assertRegex(result, r'^[0-9a-zA-Z]{5}$')\n", "prompt": "please write a python function , the function signature as below def compress_hash(hash_bytes: bytes) -> str:\n    \"\"\"\n    Compresses the input hash buffer into a string representation of at least length 5.\n\n    Args:\n        hash_bytes (bytes): The hash buffer to be compressed.\n\n    Returns:\n        str: A compressed string representation of the hash.\n              The output string will have a length no less than 5.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * The input hash string is compressed into a number letter string of length no less than 5\n *\n * @param hash - The hash string to be compressed.\n * @returns A compressed string representation of the hash.\n */\nstd::string compressHash(const std::string& hash) {\n    // Function implementation will go here\n}", "test_code": "TEST_CASE(\"compressHash\") {\n    SECTION(\"should return a string of length 5\") {\n        std::string hash = createHash(\"test\");\n        std::string result = compressHash(hash);\n        REQUIRE(result.length() == 5);\n    }\n\n    SECTION(\"should return different strings for different inputs\") {\n        std::string hash1 = createHash(\"test1\");\n        std::string hash2 = createHash(\"test2\");\n        std::string result1 = compressHash(hash1);\n        std::string result2 = compressHash(hash2);\n        REQUIRE(result1 != result2);\n    }\n\n    SECTION(\"should return a consistent result for the same input\") {\n        std::string hash = createHash(\"test\");\n        std::string result1 = compressHash(hash);\n        std::string result2 = compressHash(hash);\n        REQUIRE(result1 == result2);\n    }\n\n    SECTION(\"should handle a hash of all zeros\") {\n        unsigned char zeroHash[32] = {0}; // 32 bytes of zeros\n        std::string result = compressHash(std::string(reinterpret_cast<char*>(zeroHash), 32));\n        REQUIRE(std::regex_match(result, std::regex(\"^[0-9a-zA-Z]{5}$\")));\n    }\n\n    SECTION(\"should handle a hash of all ones\") {\n        unsigned char oneHash[32] = {255}; // 32 bytes of 0xFF (255 in decimal)\n        std::string result = compressHash(std::string(reinterpret_cast<char*>(oneHash), 32));\n        REQUIRE(std::regex_match(result, std::regex(\"^[0-9a-zA-Z]{5}$\")));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * The input hash string is compressed into a number letter string of length no less than 5\n *\n * @param hash - The hash string to be compressed.\n * @returns A compressed string representation of the hash.\n */\nstd::string compressHash(const std::string& hash) {\n    // Function implementation will go here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * The input hash buffer is compressed into a number letter string of length no less than 5\n *\n * @param hash - The hash buffer to be compressed.\n * @return A compressed string representation of the hash.\n */\npublic static String compressHash(ByteBuffer hash) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\nimport java.nio.ByteBuffer;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    /**\n     * Utility method to create SHA-256 hash from a string.\n     */\n    private ByteBuffer createHash(String input) throws NoSuchAlgorithmException {\n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = digest.digest(input.getBytes());\n        return ByteBuffer.wrap(hash);\n    }\n\n    @Test\n    public void testShouldReturnStringOfLength5() throws NoSuchAlgorithmException {\n        ByteBuffer hash = createHash(\"test\");\n        String result = compressHash(hash);\n        assertEquals(5, result.length());\n    }\n\n    @Test\n    public void testShouldReturnDifferentStringsForDifferentInputs() throws NoSuchAlgorithmException {\n        ByteBuffer hash1 = createHash(\"test1\");\n        ByteBuffer hash2 = createHash(\"test2\");\n        String result1 = compressHash(hash1);\n        String result2 = compressHash(hash2);\n        assertNotEquals(result1, result2);\n    }\n\n    @Test\n    public void testShouldReturnConsistentResultForSameInput() throws NoSuchAlgorithmException {\n        ByteBuffer hash = createHash(\"test\");\n        String result1 = compressHash(hash);\n        String result2 = compressHash(hash);\n        assertEquals(result1, result2);\n    }\n\n    @Test\n    public void testShouldHandleHashOfAllZeros() {\n        ByteBuffer hash = ByteBuffer.allocate(32).put(new byte[32]);\n        String result = compressHash(hash);\n        assertTrue(result.matches(\"^[0-9a-zA-Z]{5}$\"));\n    }\n\n    @Test\n    public void testShouldHandleHashOfAllOnes() {\n        ByteBuffer hash = ByteBuffer.allocate(32).put(new byte[32]); // 32 bytes of 0xFF\n        for (int i = 0; i < 32; i++) {\n            hash.put(i, (byte) 0xFF);\n        }\n        String result = compressHash(hash);\n        assertTrue(result.matches(\"^[0-9a-zA-Z]{5}$\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * The input hash buffer is compressed into a number letter string of length no less than 5\n *\n * @param hash - The hash buffer to be compressed.\n * @return A compressed string representation of the hash.\n */\npublic static String compressHash(ByteBuffer hash) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 154, "code_type": "method", "original_language": "typescript", "file_path": "wxt-examples\\9d5e5c96539ca297544c3daf698a1ba6272ea3b1\\scripts\\parse-git-diff.ts", "question_type": "Data processing and transformation", "summary": "Parsing a string containing the contents of a Git diff returns an array of objects with details of each file's changes", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef parse_git_diff(diff_text: str) -> List:\n    \"\"\"\n    Parses a string containing the contents of a Git diff and returns a list of objects\n    detailing the changes for each file.\n\n    Args:\n        diff_text (str): The Git diff text to parse.\n\n    Returns:\n        list: A list of objects representing the diff for each file, where each object contains\n              details about the changes, such as file name, added lines, and removed lines.\n    \"\"\"", "test_code": "import unittest\n\nclass TestParseGitDiff(unittest.TestCase):\n\n    def test_parse_simple_file_addition(self):\n        diff_text = (\n            \"diff --git a/file.txt b/file.txt\\n\"\n            \"new file mode 100644\\n\"\n            \"index 0000000..e69de29\\n\"\n            \"--- /dev/null\\n\"\n            \"+++ b/file.txt\"\n        )\n        result = parse_git_diff(diff_text)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0].oldPath, 'file.txt')\n        self.assertEqual(result[0].newPath, 'file.txt')\n        self.assertEqual(result[0].newFileMode, '100644')\n\n    def test_parse_simple_file_deletion(self):\n        diff_text = (\n            \"diff --git a/file.txt b/file.txt\\n\"\n            \"deleted file mode 100644\\n\"\n            \"index e69de29..0000000\\n\"\n            \"--- a/file.txt\\n\"\n            \"+++ /dev/null\"\n        )\n        result = parse_git_diff(diff_text)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0].oldPath, 'file.txt')\n        self.assertEqual(result[0].newPath, 'file.txt')\n        self.assertEqual(result[0].deletedFileMode, '100644')\n\n    def test_parse_file_modification_with_changes(self):\n        diff_text = (\n            \"diff --git a/file.txt b/file.txt\\n\"\n            \"index e69de29..d95f3ad 100644\\n\"\n            \"--- a/file.txt\\n\"\n            \"+++ b/file.txt\\n\"\n            \"@@ -0,0 +1 @@\\n\"\n            \"+Hello World\"\n        )\n        result = parse_git_diff(diff_text)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0].oldPath, 'file.txt')\n        self.assertEqual(result[0].newPath, 'file.txt')\n        self.assertEqual(result[0].index, 'e69de29..d95f3ad')\n        self.assertEqual(result[0].changes, [\n            {\"code\": \"--- a/file.txt\"},\n            {\"code\": \"+++ b/file.txt\"},\n            {\"diff\": '@@ -0,0 +1 @@'},\n            {\"code\": '+Hello World'}\n        ])\n\n    def test_handle_multiple_file_diffs(self):\n        diff_text = (\n            \"diff --git a/file1.txt b/file1.txt\\n\"\n            \"index e69de29..d95f3ad 100644\\n\"\n            \"--- a/file1.txt\\n\"\n            \"+++ b/file1.txt\\n\"\n            \"@@ -0,0 +1 @@\\n\"\n            \"+Hello World\\n\"\n            \"diff --git a/file2.txt b/file2.txt\\n\"\n            \"index 0a1b2c3..d4e5f6a 100644\\n\"\n            \"--- a/file2.txt\\n\"\n            \"+++ b/file2.txt\\n\"\n            \"@@ -1 +1 @@\\n\"\n            \"-Hello\\n\"\n            \"+Hi\"\n        )\n        result = parse_git_diff(diff_text)\n        self.assertEqual(len(result), 2)\n        self.assertEqual(result[0].oldPath, 'file1.txt')\n        self.assertEqual(result[1].oldPath, 'file2.txt')\n\n    def test_return_empty_array_for_empty_diff_text(self):\n        result = parse_git_diff('')\n        self.assertEqual(result, [])\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef parse_git_diff(diff_text: str) -> List:\n    \"\"\"\n    Parses a string containing the contents of a Git diff and returns a list of objects\n    detailing the changes for each file.\n\n    Args:\n        diff_text (str): The Git diff text to parse.\n\n    Returns:\n        list: A list of objects representing the diff for each file, where each object contains\n              details about the changes, such as file name, added lines, and removed lines.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 155, "code_type": "method", "original_language": "typescript", "file_path": "chen-overflow\\01a7eec2df2579a0fa553407c62525fb86ef70c4\\lib\\utils.ts", "question_type": "Data processing and transformation", "summary": "Computes the difference between the specified date and the current time, returning it in a human-readable way", "language_version_list": {"python": {"code_signature": "from datetime import datetime\n\n\ndef get_timestamp(created_at: datetime) -> str:\n    \"\"\"Computes the difference between the specified date and the current time, returning it in a human-readable way.\n    \n    Args:\n        created_at (datetime): The date to calculate the time difference from.\n        \n    Returns:\n        str: A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n    \"\"\"\n", "test_code": "import unittest\nfrom datetime import datetime, timedelta\n\nclass TestGetTimestamp(unittest.TestCase):\n\n    def test_one_second_ago(self):\n        one_second_ago = datetime.now() - timedelta(seconds=1)  # 1 second ago\n        self.assertEqual(get_timestamp(one_second_ago), '1 second ago')\n\n    def test_five_minutes_ago(self):\n        five_minutes_ago = datetime.now() - timedelta(minutes=5)  # 5 minutes ago\n        self.assertEqual(get_timestamp(five_minutes_ago), '5 minutes ago')\n\n    def test_two_hours_ago(self):\n        two_hours_ago = datetime.now() - timedelta(hours=2)  # 2 hours ago\n        self.assertEqual(get_timestamp(two_hours_ago), '2 hours ago')\n\n    def test_three_days_ago(self):\n        three_days_ago = datetime.now() - timedelta(days=3)  # 3 days ago\n        self.assertEqual(get_timestamp(three_days_ago), '3 days ago')", "prompt": "please write a python function , the function signature as below from datetime import datetime\n\n\ndef get_timestamp(created_at: datetime) -> str:\n    \"\"\"Computes the difference between the specified date and the current time, returning it in a human-readable way.\n    \n    Args:\n        created_at (datetime): The date to calculate the time difference from.\n        \n    Returns:\n        str: A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way\n *\n * @param createdAt - The date to calculate the time difference from.\n * @returns A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\nstd::string getTimestamp(std::chrono::system_clock::time_point createdAt) {\n    // Implementation goes here\n}", "test_code": "TEST_CASE(\"getTimestamp\") {\n    SECTION(\"should return '1 second ago' for a date 1 second ago\") {\n        auto oneSecondAgo = std::chrono::system_clock::now() - std::chrono::seconds(1);\n        REQUIRE(getTimestamp(oneSecondAgo) == \"1 second ago\");\n    }\n\n    SECTION(\"should return '5 minutes ago' for a date 5 minutes ago\") {\n        auto fiveMinutesAgo = std::chrono::system_clock::now() - std::chrono::minutes(5);\n        REQUIRE(getTimestamp(fiveMinutesAgo) == \"5 minutes ago\");\n    }\n\n    SECTION(\"should return '2 hours ago' for a date 2 hours ago\") {\n        auto twoHoursAgo = std::chrono::system_clock::now() - std::chrono::hours(2);\n        REQUIRE(getTimestamp(twoHoursAgo) == \"2 hours ago\");\n    }\n\n    SECTION(\"should return '3 days ago' for a date 3 days ago\") {\n        auto threeDaysAgo = std::chrono::system_clock::now() - std::chrono::hours(72); // 3 days\n        REQUIRE(getTimestamp(threeDaysAgo) == \"3 days ago\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way\n *\n * @param createdAt - The date to calculate the time difference from.\n * @returns A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\nstd::string getTimestamp(std::chrono::system_clock::time_point createdAt) {\n    // Implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "\n/**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way.\n *\n * @param createdAt - The date to calculate the time difference from.\n * @return A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\npublic static String getTimestamp(Date createdAt) {\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Date;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testGetTimestampOneSecondAgo() {\n        Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000); // 1 second ago\n        assertEquals(\"1 second ago\",getTimestamp(oneSecondAgo));\n    }\n\n    @Test\n    public void testGetTimestampFiveMinutesAgo() {\n        Date fiveMinutesAgo = new Date(System.currentTimeMillis() - 5 * 60 * 1000); // 5 minutes ago\n        assertEquals(\"5 minutes ago\",getTimestamp(fiveMinutesAgo));\n    }\n\n    @Test\n    public void testGetTimestampTwoHoursAgo() {\n        Date twoHoursAgo = new Date(System.currentTimeMillis() - 2 * 60 * 60 * 1000); // 2 hours ago\n        assertEquals(\"2 hours ago\",getTimestamp(twoHoursAgo));\n    }\n\n    @Test\n    public void testGetTimestampThreeDaysAgo() {\n        Date threeDaysAgo = new Date(System.currentTimeMillis() - 3 * 24 * 60 * 60 * 1000); // 3 days ago\n        assertEquals(\"3 days ago\",getTimestamp(threeDaysAgo));\n    }\n}", "prompt": "please write a java function , the function signature as below \n/**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way.\n *\n * @param createdAt - The date to calculate the time difference from.\n * @return A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\npublic static String getTimestamp(Date createdAt) {\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 156, "code_type": "method", "original_language": "typescript", "file_path": "chen-overflow\\01a7eec2df2579a0fa553407c62525fb86ef70c4\\lib\\utils.ts", "question_type": "Data processing and transformation", "summary": "Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\"", "language_version_list": {"python": {"code_signature": "def format_number(num: float) -> str:\n    \"\"\"\n    Format the number into a more readable string representation, returning the original form if the number is less than 1,000.\n    If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\".\n    For a million or more, format it as \"x.xM\".\n\n    Args:\n        num (float): The number to be formatted.\n\n    Returns:\n        str: The formatted number as a string.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFormatNumber(unittest.TestCase):\n    def test_format_greater_than_equal_to_million(self):\n        \"\"\"should format numbers greater than or equal to 1,000,000 with 'M' suffix\"\"\"\n        self.assertEqual(format_number(1500000), '1.5M')\n        self.assertEqual(format_number(1000000), '1.0M')\n\n    def test_format_greater_than_equal_to_thousand(self):\n        \"\"\"should format numbers greater than or equal to 1,000 but less than 1,000,000 with 'K' suffix\"\"\"\n        self.assertEqual(format_number(2500), '2.5K')\n        self.assertEqual(format_number(1000), '1.0K')\n\n    def test_return_string_if_less_than_thousand(self):\n        \"\"\"should return the number as a string if it is less than 1,000\"\"\"\n        self.assertEqual(format_number(999), '999')\n        self.assertEqual(format_number(500), '500')\n\n    def test_handle_edge_cases(self):\n        \"\"\"should handle edge cases like exactly 1,000 or 1,000,000\"\"\"\n        self.assertEqual(format_number(1000), '1.0K')\n        self.assertEqual(format_number(1000000), '1.0M')\n", "prompt": "please write a python function , the function signature as below def format_number(num: float) -> str:\n    \"\"\"\n    Format the number into a more readable string representation, returning the original form if the number is less than 1,000.\n    If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\".\n    For a million or more, format it as \"x.xM\".\n\n    Args:\n        num (float): The number to be formatted.\n\n    Returns:\n        str: The formatted number as a string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\".\n *\n * @param num - The number to be formatted.\n * @returns The formatted number as a string.\n */\nstd::string formatNumber(double num);", "test_code": "TEST_CASE(\"formatNumber\") {\n    SECTION(\"should format numbers greater than or equal to 1,000,000 with 'M' suffix\") {\n        REQUIRE(formatNumber(1500000) == \"1.5M\");\n        REQUIRE(formatNumber(1000000) == \"1.0M\");\n    }\n\n    SECTION(\"should format numbers greater than or equal to 1,000 but less than 1,000,000 with 'K' suffix\") {\n        REQUIRE(formatNumber(2500) == \"2.5K\");\n        REQUIRE(formatNumber(1000) == \"1.0K\");\n    }\n\n    SECTION(\"should return the number as a string if it is less than 1,000\") {\n        REQUIRE(formatNumber(999) == \"999\");\n        REQUIRE(formatNumber(500) == \"500\");\n    }\n\n    SECTION(\"should handle edge cases like exactly 1,000 or 1,000,000\") {\n        REQUIRE(formatNumber(1000) == \"1.0K\");\n        REQUIRE(formatNumber(1000000) == \"1.0M\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\".\n *\n * @param num - The number to be formatted.\n * @returns The formatted number as a string.\n */\nstd::string formatNumber(double num);", "addition_info": ""}, "java": {"code_signature": "/**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000.\n * If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\".\n * For a million or more, format it as \"x.xM\".\n *\n * @param num The number to be formatted.\n * @return The formatted number as a string.\n */\npublic static String formatNumber(double num) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testFormatNumber_Million() {\n        assertEquals(\"1.5M\", formatNumber(1500000));\n        assertEquals(\"1.0M\", formatNumber(1000000));\n    }\n\n    @Test\n    public void testFormatNumber_Thousand() {\n        assertEquals(\"2.5K\", formatNumber(2500));\n        assertEquals(\"1.0K\", formatNumber(1000));\n    }\n\n    @Test\n    public void testFormatNumber_LessThanThousand() {\n        assertEquals(\"999\", formatNumber(999));\n        assertEquals(\"500\", formatNumber(500));\n    }\n\n    @Test\n    public void testFormatNumber_EdgeCases() {\n        assertEquals(\"1.0K\", formatNumber(1000));\n        assertEquals(\"1.0M\", formatNumber(1000000));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000.\n * If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\".\n * For a million or more, format it as \"x.xM\".\n *\n * @param num The number to be formatted.\n * @return The formatted number as a string.\n */\npublic static String formatNumber(double num) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 157, "code_type": "method", "original_language": "typescript", "file_path": "Morphify\\b42b6a8fde75e1e26e4fb43a000f720a111ce4e1\\lib\\utils.ts", "question_type": "Data processing and transformation", "summary": "Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places", "language_version_list": {"python": {"code_signature": "def bytes_to_size(bytes: int) -> str:\n    \"\"\"\n    Converts a given number of Bytes into a readable string representation\n    with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places.\n\n    Args:\n        bytes (int): The number of bytes to be converted.\n\n    Returns:\n        str: A string representation of the size in Bytes, KB, MB, GB, or TB.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestBytesToSize(unittest.TestCase):\n    def test_convert_bytes_to_kb(self):\n        self.assertEqual(bytes_to_size(1024), '1.00 KB')\n        self.assertEqual(bytes_to_size(2048), '2.00 KB')\n\n    def test_convert_bytes_to_mb(self):\n        self.assertEqual(bytes_to_size(1048576), '1.00 MB')\n        self.assertEqual(bytes_to_size(2097152), '2.00 MB')\n\n    def test_convert_bytes_to_gb(self):\n        self.assertEqual(bytes_to_size(1073741824), '1.00 GB')\n        self.assertEqual(bytes_to_size(2147483648), '2.00 GB')\n\n    def test_convert_bytes_to_tb(self):\n        self.assertEqual(bytes_to_size(1099511627776), '1.00 TB')\n        self.assertEqual(bytes_to_size(2199023255552), '2.00 TB')\n", "prompt": "please write a python function , the function signature as below def bytes_to_size(bytes: int) -> str:\n    \"\"\"\n    Converts a given number of Bytes into a readable string representation\n    with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places.\n\n    Args:\n        bytes (int): The number of bytes to be converted.\n\n    Returns:\n        str: A string representation of the size in Bytes, KB, MB, GB, or TB.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places.\n *\n * @param bytes - The number of bytes to be converted.\n * @returns A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\nstd::string bytesToSize(long long bytes);", "test_code": "TEST_CASE(\"bytesToSize\") {\n    SECTION(\"should convert bytes to KB correctly\") {\n        REQUIRE(bytesToSize(1024) == \"1.00 KB\");\n        REQUIRE(bytesToSize(2048) == \"2.00 KB\");\n    }\n\n    SECTION(\"should convert bytes to MB correctly\") {\n        REQUIRE(bytesToSize(1048576) == \"1.00 MB\");\n        REQUIRE(bytesToSize(2097152) == \"2.00 MB\");\n    }\n\n    SECTION(\"should convert bytes to GB correctly\") {\n        REQUIRE(bytesToSize(1073741824) == \"1.00 GB\");\n        REQUIRE(bytesToSize(2147483648) == \"2.00 GB\");\n    }\n\n    SECTION(\"should convert bytes to TB correctly\") {\n        REQUIRE(bytesToSize(1099511627776) == \"1.00 TB\");\n        REQUIRE(bytesToSize(2199023255552) == \"2.00 TB\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places.\n *\n * @param bytes - The number of bytes to be converted.\n * @returns A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\nstd::string bytesToSize(long long bytes);", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places.\n *\n * @param bytes - The number of bytes to be converted.\n * @return - A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\npublic static String bytesToSize(long bytes) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testBytesToSize_KB() {\n        assertEquals(\"1.00 KB\", bytesToSize(1024));\n        assertEquals(\"2.00 KB\", bytesToSize(2048));\n    }\n\n    @Test\n    public void testBytesToSize_MB() {\n        assertEquals(\"1.00 MB\", bytesToSize(1048576));\n        assertEquals(\"2.00 MB\", bytesToSize(2097152));\n    }\n\n    @Test\n    public void testBytesToSize_GB() {\n        assertEquals(\"1.00 GB\", bytesToSize(1073741824));\n        assertEquals(\"2.00 GB\", bytesToSize(2147483648L));\n    }\n\n    @Test\n    public void testBytesToSize_TB() {\n        assertEquals(\"1.00 TB\", bytesToSize(1099511627776L));\n        assertEquals(\"2.00 TB\", bytesToSize(2199023255552L));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places.\n *\n * @param bytes - The number of bytes to be converted.\n * @return - A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\npublic static String bytesToSize(long bytes) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 158, "code_type": "method", "original_language": "typescript", "file_path": "Morphify\\b42b6a8fde75e1e26e4fb43a000f720a111ce4e1\\lib\\utils.ts", "question_type": "Data processing and transformation", "summary": "Extract the file extension and return it if it exists. If not, an empty string is returned", "language_version_list": {"python": {"code_signature": "def get_file_extension(file_name: str) -> str:\n    \"\"\"\n    Extract the file extension and return it if it exists. If not, an empty string is returned.\n\n    Args:\n        file_name (str): The full name of the file from which to extract the extension.\n\n    Returns:\n        str: The file extension without the dot, or an empty string if no extension is found.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGetFileExtension(unittest.TestCase):\n\n    def test_standard_file_extension(self):\n        \"\"\"should return the file extension for a standard file\"\"\"\n        self.assertEqual(get_file_extension('example.txt'), 'txt')\n\n    def test_no_extension(self):\n        \"\"\"should return an empty string for files without an extension\"\"\"\n        self.assertEqual(get_file_extension('example'), '')\n\n    def test_multiple_dots(self):\n        \"\"\"should handle files with multiple dots\"\"\"\n        self.assertEqual(get_file_extension('example.with.many.dots.jpg'), 'jpg')\n\n    def test_filenames_ending_with_dot(self):\n        \"\"\"should return an empty string for filenames that end with a dot\"\"\"\n        self.assertEqual(get_file_extension('example.'), '')\n\n    def test_case_sensitivity(self):\n        \"\"\"should correctly handle case sensitivity\"\"\"\n        self.assertEqual(get_file_extension('example.JPG'), 'JPG')\n", "prompt": "please write a python function , the function signature as below def get_file_extension(file_name: str) -> str:\n    \"\"\"\n    Extract the file extension and return it if it exists. If not, an empty string is returned.\n\n    Args:\n        file_name (str): The full name of the file from which to extract the extension.\n\n    Returns:\n        str: The file extension without the dot, or an empty string if no extension is found.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Extract the file extension and return it if it exists. If not, an empty string is returned\n *\n * @param file_name - The full name of the file from which to extract the extension.\n * @returns The file extension without the dot, or an empty string if no extension is found.\n */\nstd::string getFileExtension(const std::string& file_name);", "test_code": "TEST_CASE(\"getFileExtension\", \"[extension]\") {\n    SECTION(\"should return the file extension for a standard file\") {\n        REQUIRE(getFileExtension(\"example.txt\") == \"txt\");\n    }\n\n    SECTION(\"should return an empty string for files without an extension\") {\n        REQUIRE(getFileExtension(\"example\") == \"\");\n    }\n\n    SECTION(\"should handle files with multiple dots\") {\n        REQUIRE(getFileExtension(\"example.with.many.dots.jpg\") == \"jpg\");\n    }\n\n    SECTION(\"should return an empty string for filenames that end with a dot\") {\n        REQUIRE(getFileExtension(\"example.\") == \"\");\n    }\n\n    SECTION(\"should correctly handle case sensitivity\") {\n        REQUIRE(getFileExtension(\"example.JPG\") == \"JPG\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Extract the file extension and return it if it exists. If not, an empty string is returned\n *\n * @param file_name - The full name of the file from which to extract the extension.\n * @returns The file extension without the dot, or an empty string if no extension is found.\n */\nstd::string getFileExtension(const std::string& file_name);", "addition_info": ""}, "java": {"code_signature": "/**\n * Extract the file extension and return it if it exists. If not, an empty string is returned.\n *\n * @param fileName The full name of the file from which to extract the extension.\n * @return The file extension without the dot, or an empty string if no extension is found.\n */\npublic static String getFileExtension(String fileName) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testGetFileExtension_standardFile() {\n        assertEquals(\"txt\", getFileExtension(\"example.txt\"));\n    }\n\n    @Test\n    public void testGetFileExtension_noExtension() {\n        assertEquals(\"\", getFileExtension(\"example\"));\n    }\n\n    @Test\n    public void testGetFileExtension_multipleDots() {\n        assertEquals(\"jpg\", getFileExtension(\"example.with.many.dots.jpg\"));\n    }\n\n    @Test\n    public void testGetFileExtension_trailingDot() {\n        assertEquals(\"\", getFileExtension(\"example.\"));\n    }\n\n    @Test\n    public void testGetFileExtension_caseSensitivity() {\n        assertEquals(\"JPG\", getFileExtension(\"example.JPG\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extract the file extension and return it if it exists. If not, an empty string is returned.\n *\n * @param fileName The full name of the file from which to extract the extension.\n * @return The file extension without the dot, or an empty string if no extension is found.\n */\npublic static String getFileExtension(String fileName) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 159, "code_type": "method", "original_language": "typescript", "file_path": "Morphify\\b42b6a8fde75e1e26e4fb43a000f720a111ce4e1\\lib\\utils.ts", "question_type": "Data processing and transformation", "summary": "Removes the extension of the given filename and returns the remainder", "language_version_list": {"python": {"code_signature": "def remove_file_extension(file_name: str) -> str:\n    \"\"\"\n    Removes the extension of the given filename and returns the remainder.\n\n    Args:\n        file_name (str): The full name of the file from which to remove the extension.\n\n    Returns:\n        str: The file name without the extension. If no extension is found, returns the original file name.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestRemoveFileExtension(unittest.TestCase):\n    def test_remove_standard_file_extension(self):\n        \"\"\"Should remove the file extension from a standard file.\"\"\"\n        self.assertEqual(remove_file_extension('document.txt'), 'document')\n\n    def test_return_original_filename_without_extension(self):\n        \"\"\"Should return the original filename for files without an extension.\"\"\"\n        self.assertEqual(remove_file_extension('document'), 'document')\n\n    def test_handle_files_with_multiple_dots(self):\n        \"\"\"Should handle files with multiple dots correctly.\"\"\"\n        self.assertEqual(remove_file_extension('my.file.with.many.extensions.pdf'), 'my.file.with.many.extensions')\n\n    def test_return_original_filename_if_ends_with_dot(self):\n        \"\"\"Should return the original filename if it ends with a dot.\"\"\"\n        self.assertEqual(remove_file_extension('document.'), 'document')\n\n    def test_handle_filenames_with_dots_in_directory_names(self):\n        \"\"\"Should correctly handle filenames with dots in directory names.\"\"\"\n        self.assertEqual(remove_file_extension('path.to/my.file.txt'), 'path.to/my.file')\n", "prompt": "please write a python function , the function signature as below def remove_file_extension(file_name: str) -> str:\n    \"\"\"\n    Removes the extension of the given filename and returns the remainder.\n\n    Args:\n        file_name (str): The full name of the file from which to remove the extension.\n\n    Returns:\n        str: The file name without the extension. If no extension is found, returns the original file name.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Removes the extension of the given filename and returns the remainder\n *\n * @param file_name - The full name of the file from which to remove the extension.\n * @returns The file name without the extension. If no extension is found, returns the original file name.\n */\nstd::string removeFileExtension(const std::string& file_name);", "test_code": "TEST_CASE(\"removeFileExtension\") {\n    SECTION(\"should remove the file extension from a standard file\") {\n        REQUIRE(removeFileExtension(\"document.txt\") == \"document\");\n    }\n\n    SECTION(\"should return the original filename for files without an extension\") {\n        REQUIRE(removeFileExtension(\"document\") == \"document\");\n    }\n\n    SECTION(\"should handle files with multiple dots correctly\") {\n        REQUIRE(removeFileExtension(\"my.file.with.many.extensions.pdf\") == \"my.file.with.many.extensions\");\n    }\n\n    SECTION(\"should return the original filename if it ends with a dot\") {\n        REQUIRE(removeFileExtension(\"document.\") == \"document\");\n    }\n\n    SECTION(\"should correctly handle filenames with dots in directory names\") {\n        REQUIRE(removeFileExtension(\"path.to/my.file.txt\") == \"path.to/my.file\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Removes the extension of the given filename and returns the remainder\n *\n * @param file_name - The full name of the file from which to remove the extension.\n * @returns The file name without the extension. If no extension is found, returns the original file name.\n */\nstd::string removeFileExtension(const std::string& file_name);", "addition_info": ""}, "java": {"code_signature": "/**\n * Removes the extension of the given filename and returns the remainder.\n *\n * @param fileName - The full name of the file from which to remove the extension.\n * @return The file name without the extension. If no extension is found, returns the original file name.\n */\npublic static String removeFileExtension(String fileName) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testRemoveFileExtensionStandardFile() {\n        assertEquals(\"document\", removeFileExtension(\"document.txt\"));\n    }\n\n    @Test\n    public void testRemoveFileExtensionNoExtension() {\n        assertEquals(\"document\", removeFileExtension(\"document\"));\n    }\n\n    @Test\n    public void testRemoveFileExtensionMultipleDots() {\n        assertEquals(\"my.file.with.many.extensions\", removeFileExtension(\"my.file.with.many.extensions.pdf\"));\n    }\n\n    @Test\n    public void testRemoveFileExtensionEndsWithDot() {\n        assertEquals(\"document\", removeFileExtension(\"document.\"));\n    }\n\n    @Test\n    public void testRemoveFileExtensionWithDotsInPath() {\n        assertEquals(\"path.to/my.file\", removeFileExtension(\"path.to/my.file.txt\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Removes the extension of the given filename and returns the remainder.\n *\n * @param fileName - The full name of the file from which to remove the extension.\n * @return The file name without the extension. If no extension is found, returns the original file name.\n */\npublic static String removeFileExtension(String fileName) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 160, "code_type": "method", "original_language": "typescript", "file_path": "Morphify\\b42b6a8fde75e1e26e4fb43a000f720a111ce4e1\\lib\\utils.ts", "question_type": "Data processing and transformation", "summary": "Compress the part of the file name before the file extension, and if the part exceeds the specified maximum length, replace the excess with***\n", "language_version_list": {"python": {"code_signature": "def compress_filename(file_name: str, max_length: int = 18) -> str:\n    \"\"\"\n    Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters.\n\n    For example:\n        compress_filename('verylongfilename.txt', 10) output: verylongfi***.txt\n\n    Args:\n        file_name (str): The original file name to be compressed.\n        max_length (int): The maximum allowed length for the compressed file name. Defaults to 18.\n\n    Returns:\n        str: The compressed file name, with the middle section replaced by ellipses ('...'),\n              or the original file name if it is within the maximum length.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCompressFilename(unittest.TestCase):\n    def test_return_filename_unchanged_if_under_max_length(self):\n        self.assertEqual(compress_filename('file.txt', 10), 'file.txt')\n\n    def test_truncate_and_append_if_exceeds_max_length(self):\n        self.assertEqual(compress_filename('verylongfilename.txt', 10), 'verylongfi***.txt')\n\n    def test_preserve_file_extension_after_compression(self):\n        self.assertEqual(compress_filename('document.pdf', 5), 'docum***.pdf')\n\n    def test_truncate_and_append_if_filename_exceeds(self):\n        self.assertEqual(compress_filename('short.mp3', 2), 'sh***.mp3')", "prompt": "please write a python function , the function signature as below def compress_filename(file_name: str, max_length: int = 18) -> str:\n    \"\"\"\n    Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters.\n\n    For example:\n        compress_filename('verylongfilename.txt', 10) output: verylongfi***.txt\n\n    Args:\n        file_name (str): The original file name to be compressed.\n        max_length (int): The maximum allowed length for the compressed file name. Defaults to 18.\n\n    Returns:\n        str: The compressed file name, with the middle section replaced by ellipses ('...'),\n              or the original file name if it is within the maximum length.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters.\n * For example:\n *      compressFileName(\"verylongfilename.txt\", 10) output: verylongfi***.txt\n *\n * @param fileName - The original file name to be compressed.\n * @param maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @returns The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\nstd::string compressFileName(const std::string& fileName, int maxLength = 18){}", "test_code": "TEST_CASE(\"compressFileName\") {\n    SECTION(\"should return the filename unchanged if under max length\") {\n        REQUIRE(compressFileName(\"file.txt\", 10) == \"file.txt\");\n    }\n\n    SECTION(\"should truncate and append *** if filename exceeds max length\") {\n        REQUIRE(compressFileName(\"verylongfilename.txt\", 10) == \"verylongfi***.txt\");\n    }\n\n    SECTION(\"should preserve file extension after compression\") {\n        REQUIRE(compressFileName(\"document.pdf\", 5) == \"docum***.pdf\");\n    }\n\n    SECTION(\"should truncate and append *** if filename exceeds\") {\n        REQUIRE(compressFileName(\"short.mp3\", 2) == \"sh***.mp3\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters.\n * For example:\n *      compressFileName(\"verylongfilename.txt\", 10) output: verylongfi***.txt\n *\n * @param fileName - The original file name to be compressed.\n * @param maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @returns The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\nstd::string compressFileName(const std::string& fileName, int maxLength = 18){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters.\n * For example:\n *      compressFileName(\"verylongfilename.txt\", 10) output: \"verylongfi***.txt\"\n *\n * @param fileName - The original file name to be compressed.\n * @param maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @return The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\npublic static String compressFileName(String fileName, int maxLength) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void shouldReturnFilenameUnchangedIfUnderMaxLength() {\n        assertEquals(\"file.txt\", compressFilename(\"file.txt\", 10));\n    }\n\n    @Test\n    public void shouldTruncateAndAppendIfFilenameExceedsMaxLength() {\n        assertEquals(\"verylongfi***.txt\", compressFilename(\"verylongfilename.txt\", 10));\n    }\n\n    @Test\n    public void shouldPreserveFileExtensionAfterCompression() {\n        assertEquals(\"docum***.pdf\", compressFilename(\"document.pdf\", 5));\n    }\n\n    @Test\n    public void shouldTruncateAndAppendIfFilenameExceeds() {\n        assertEquals(\"sh***.mp3\", compressFilename(\"short.mp3\", 2));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters.\n * For example:\n *      compressFileName(\"verylongfilename.txt\", 10) output: \"verylongfi***.txt\"\n *\n * @param fileName - The original file name to be compressed.\n * @param maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @return The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\npublic static String compressFileName(String fileName, int maxLength) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 161, "code_type": "method", "original_language": "typescript", "file_path": "conjure-extension\\cd7b718adce8d1b1536f8c1a51ee1f2de366ead3\\src\\option.ts", "question_type": "Algorithm and data structure", "summary": "Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array", "language_version_list": {"python": {"code_signature": "from typing import Dict, List\n\n\ndef generate_combinations(map: Dict[str, List[int]]) -> List[List[int]]:\n    \"\"\"\n    Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array.\n\n    Args:\n        map (Dict[str, List[int]]): A map where each key is a string, and each value is an array of numbers.\n\n    Returns:\n        List[List[int]]: An array of arrays, where each sub-array is a unique combination of numbers from the map's values.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGenerateCombinations(unittest.TestCase):\n\n    def test_single_key_multiple_values(self):\n        # Test: generates combinations for a single key with multiple values\n        map_data = {'a': [1, 2, 3]}\n        expected = [[1], [2], [3]]\n        self.assertEqual(generate_combinations(map_data), expected)\n\n    def test_multiple_keys_single_values(self):\n        # Test: generates combinations for multiple keys with single values\n        map_data = {'a': [1], 'b': [2]}\n        expected = [[1, 2]]\n        self.assertEqual(generate_combinations(map_data), expected)\n\n    def test_multiple_keys_multiple_values(self):\n        # Test: generates combinations for multiple keys with multiple values\n        map_data = {'a': [1, 2], 'b': [3, 4]}\n        expected = [\n            [1, 3], [1, 4],\n            [2, 3], [2, 4]\n        ]\n        self.assertEqual(generate_combinations(map_data), expected)\n\n    def test_empty_map(self):\n        # Test: handles an empty map\n        map_data = {}\n        expected = [[]]\n        self.assertEqual(generate_combinations(map_data), expected)\n\n    def test_empty_array_values(self):\n        # Test: handles keys with empty arrays as values\n        map_data = {'a': [], 'b': [1, 2]}\n        expected = []\n        self.assertEqual(generate_combinations(map_data), expected)\n", "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef generate_combinations(map: Dict[str, List[int]]) -> List[List[int]]:\n    \"\"\"\n    Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array.\n\n    Args:\n        map (Dict[str, List[int]]): A map where each key is a string, and each value is an array of numbers.\n\n    Returns:\n        List[List[int]]: An array of arrays, where each sub-array is a unique combination of numbers from the map's values.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array\n *\n * @param inputMap A map where each key is a string, and each value is a vector of integers.\n * @returns A vector of vectors, where each sub-vector is a unique combination of numbers from the map's values.\n */\nstd::vector<std::vector<int>> generateCombinations(const std::map<std::string, std::vector<int>>& inputMap) {\n    // Function implementation here\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <map>\n#include <vector>\n#include <string>\n\n// Function prototype\nstd::vector<std::vector<int>> generateCombinations(const std::map<std::string, std::vector<int>>& inputMap);\n\nTEST_CASE(\"generateCombinations\") {\n    SECTION(\"generates combinations for a single key with multiple values\") {\n        std::map<std::string, std::vector<int>> map = {{\"a\", {1, 2, 3}}};\n        std::vector<std::vector<int>> expected = {{1}, {2}, {3}};\n        REQUIRE(generateCombinations(map) == expected);\n    }\n\n    SECTION(\"generates combinations for multiple keys with single values\") {\n        std::map<std::string, std::vector<int>> map = {{\"a\", {1}}, {\"b\", {2}}};\n        std::vector<std::vector<int>> expected = {{1, 2}};\n        REQUIRE(generateCombinations(map) == expected);\n    }\n\n    SECTION(\"generates combinations for multiple keys with multiple values\") {\n        std::map<std::string, std::vector<int>> map = {{\"a\", {1, 2}}, {\"b\", {3, 4}}};\n        std::vector<std::vector<int>> expected = {\n            {1, 3}, {1, 4},\n            {2, 3}, {2, 4}\n        };\n        REQUIRE(generateCombinations(map) == expected);\n    }\n\n    SECTION(\"handles an empty map\") {\n        std::map<std::string, std::vector<int>> map;\n        std::vector<std::vector<int>> expected = {{}};\n        REQUIRE(generateCombinations(map) == expected);\n    }\n\n    SECTION(\"handles keys with empty arrays as values\") {\n        std::map<std::string, std::vector<int>> map = {{\"a\", {}}, {\"b\", {1, 2}}};\n        std::vector<std::vector<int>> expected = {};\n        REQUIRE(generateCombinations(map) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array\n *\n * @param inputMap A map where each key is a string, and each value is a vector of integers.\n * @returns A vector of vectors, where each sub-vector is a unique combination of numbers from the map's values.\n */\nstd::vector<std::vector<int>> generateCombinations(const std::map<std::string, std::vector<int>>& inputMap) {\n    // Function implementation here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Produces all combinations of numeric arrays for each key in the given map object\n * and returns them as a two-dimensional array.\n *\n * @param map A map where each key is a string, and each value is a list of integers.\n * @return A list of lists, where each sub-list is a unique combination of numbers from the map's values.\n */\npublic List<List<Integer>> generateCombinations(Map<String, List<Integer>> map) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport org.junit.Assert;\n\nimport java.util.*;\n\npublic class Tester {\n\n    @Test\n    public void testGeneratesCombinationsForSingleKeyWithMultipleValues() {\n        Map<String, List<Integer>> map = new HashMap<>();\n        map.put(\"a\", Arrays.asList(1, 2, 3));\n        List<List<Integer>> expected = Arrays.asList(Arrays.asList(1), Arrays.asList(2), Arrays.asList(3));\n        Assert.assertEquals(expected, generateCombinations(map));\n    }\n\n    @Test\n    public void testGeneratesCombinationsForMultipleKeysWithSingleValues() {\n        Map<String, List<Integer>> map = new HashMap<>();\n        map.put(\"a\", Collections.singletonList(1));\n        map.put(\"b\", Collections.singletonList(2));\n        List<List<Integer>> expected = Collections.singletonList(Arrays.asList(1, 2));\n        Assert.assertEquals(expected, generateCombinations(map));\n    }\n\n    @Test\n    public void testGeneratesCombinationsForMultipleKeysWithMultipleValues() {\n        Map<String, List<Integer>> map = new HashMap<>();\n        map.put(\"a\", Arrays.asList(1, 2));\n        map.put(\"b\", Arrays.asList(3, 4));\n        List<List<Integer>> expected = Arrays.asList(\n                Arrays.asList(1, 3), Arrays.asList(1, 4),\n                Arrays.asList(2, 3), Arrays.asList(2, 4)\n        );\n        Assert.assertEquals(expected, generateCombinations(map));\n    }\n\n    @Test\n    public void testHandlesEmptyMap() {\n        Map<String, List<Integer>> map = new HashMap<>();\n        List<List<Integer>> expected = Collections.singletonList(Collections.emptyList());\n        Assert.assertEquals(expected, generateCombinations(map));\n    }\n\n    @Test\n    public void testHandlesKeysWithEmptyArraysAsValues() {\n        Map<String, List<Integer>> map = new HashMap<>();\n        map.put(\"a\", Collections.emptyList());\n        map.put(\"b\", Arrays.asList(1, 2));\n        List<List<Integer>> expected = Collections.emptyList();\n        Assert.assertEquals(expected, generateCombinations(map));\n    }\n\n    // Assuming generateCombinations method is implemented in this class or imported\n    public List<List<Integer>> generateCombinations(Map<String, List<Integer>> map) {\n        // Implementation goes here\n        return new ArrayList<>(); // Placeholder\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Produces all combinations of numeric arrays for each key in the given map object\n * and returns them as a two-dimensional array.\n *\n * @param map A map where each key is a string, and each value is a list of integers.\n * @return A list of lists, where each sub-list is a unique combination of numbers from the map's values.\n */\npublic List<List<Integer>> generateCombinations(Map<String, List<Integer>> map) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 162, "code_type": "method", "original_language": "typescript", "file_path": "prague-meetup\\64b994944d07318affaa18c9c7485f98eb1a53ab\\src\\utils\\boolArrayCodec.ts", "question_type": "Data processing and transformation", "summary": "Converts the array of Boolean values to a binary string representation, which converts to the character 1 if the Boolean value is true. Otherwise, it is converted to the character 0, and the final string is returned", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef bool_array_to_binary_string(bool_array: List[bool]) -> str:\n    \"\"\"\n    Converts the array of Boolean values to a binary string representation,\n    which converts to the character '1' if the Boolean value is true.\n    Otherwise, it is converted to the character '0', and the final string is returned.\n\n    Args:\n        bool_array (list[bool]): An array of boolean values.\n\n    Returns:\n        str: A binary string where '1' represents true and '0' represents false.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestBoolArrayToBinaryString(unittest.TestCase):\n\n    def test_converts_all_true_values(self):\n        bool_array = [True, True, True]\n        expected = '111'\n        self.assertEqual(bool_array_to_binary_string(bool_array), expected)\n\n    def test_converts_all_false_values(self):\n        bool_array = [False, False, False]\n        expected = '000'\n        self.assertEqual(bool_array_to_binary_string(bool_array), expected)\n\n    def test_converts_mixed_true_and_false_values(self):\n        bool_array = [True, False, True, False]\n        expected = '1010'\n        self.assertEqual(bool_array_to_binary_string(bool_array), expected)\n\n    def test_handles_empty_array(self):\n        bool_array = []\n        expected = ''\n        self.assertEqual(bool_array_to_binary_string(bool_array), expected)\n\n    def test_handles_single_boolean_value(self):\n        bool_array = [True]\n        expected = '1'\n        self.assertEqual(bool_array_to_binary_string(bool_array), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef bool_array_to_binary_string(bool_array: List[bool]) -> str:\n    \"\"\"\n    Converts the array of Boolean values to a binary string representation,\n    which converts to the character '1' if the Boolean value is true.\n    Otherwise, it is converted to the character '0', and the final string is returned.\n\n    Args:\n        bool_array (list[bool]): An array of boolean values.\n\n    Returns:\n        str: A binary string where '1' represents true and '0' represents false.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts the array of Boolean values to a binary string representation,\n * which converts to the character '1' if the Boolean value is true.\n * Otherwise, it is converted to the character '0', and the final string is returned.\n *\n * @param boolArray An array of boolean values.\n * @returns A binary string where '1' represents true and '0' represents false.\n */\nstd::string boolArrayToBinaryString(const std::vector<bool>& boolArray) {\n    // Implementation will go here\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <vector>\n#include <string>\n\nstd::string boolArrayToBinaryString(const std::vector<bool>& boolArray);\n\nTEST_CASE(\"boolArrayToBinaryString\") {\n    SECTION(\"converts an array of all true values\") {\n        std::vector<bool> boolArray = {true, true, true};\n        std::string expected = \"111\";\n        REQUIRE(boolArrayToBinaryString(boolArray) == expected);\n    }\n\n    SECTION(\"converts an array of all false values\") {\n        std::vector<bool> boolArray = {false, false, false};\n        std::string expected = \"000\";\n        REQUIRE(boolArrayToBinaryString(boolArray) == expected);\n    }\n\n    SECTION(\"converts an array with a mix of true and false values\") {\n        std::vector<bool> boolArray = {true, false, true, false};\n        std::string expected = \"1010\";\n        REQUIRE(boolArrayToBinaryString(boolArray) == expected);\n    }\n\n    SECTION(\"handles an empty array\") {\n        std::vector<bool> boolArray = {};\n        std::string expected = \"\";\n        REQUIRE(boolArrayToBinaryString(boolArray) == expected);\n    }\n\n    SECTION(\"handles a single boolean value\") {\n        std::vector<bool> boolArray = {true};\n        std::string expected = \"1\";\n        REQUIRE(boolArrayToBinaryString(boolArray) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts the array of Boolean values to a binary string representation,\n * which converts to the character '1' if the Boolean value is true.\n * Otherwise, it is converted to the character '0', and the final string is returned.\n *\n * @param boolArray An array of boolean values.\n * @returns A binary string where '1' represents true and '0' represents false.\n */\nstd::string boolArrayToBinaryString(const std::vector<bool>& boolArray) {\n    // Implementation will go here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts the array of Boolean values to a binary string representation,\n * which converts to the character '1' if the Boolean value is true.\n * Otherwise, it is converted to the character '0', and the final string is returned.\n *\n * @param boolArray An array of boolean values.\n * @return A binary string where '1' represents true and '0' represents false.\n */\npublic static String boolArrayToBinaryString(boolean[] boolArray) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    /**\n     * Converts the array of Boolean values to a binary string representation,\n     * which converts to the character '1' if the Boolean value is true.\n     * Otherwise, it is converted to the character '0', and the final string is returned.\n     *\n     * @param boolArray An array of boolean values.\n     * @return A binary string where '1' represents true and '0' represents false.\n     */\n    public static String boolArrayToBinaryString(boolean[] boolArray) {\n        StringBuilder binaryString = new StringBuilder();\n        for (boolean value : boolArray) {\n            binaryString.append(value ? \"1\" : \"0\");\n        }\n        return binaryString.toString();\n    }\n\n    @Test\n    public void testConvertsAllTrueValues() {\n        boolean[] boolArray = {true, true, true};\n        String expected = \"111\";\n        assertEquals(expected, boolArrayToBinaryString(boolArray));\n    }\n\n    @Test\n    public void testConvertsAllFalseValues() {\n        boolean[] boolArray = {false, false, false};\n        String expected = \"000\";\n        assertEquals(expected, boolArrayToBinaryString(boolArray));\n    }\n\n    @Test\n    public void testConvertsMixedValues() {\n        boolean[] boolArray = {true, false, true, false};\n        String expected = \"1010\";\n        assertEquals(expected, boolArrayToBinaryString(boolArray));\n    }\n\n    @Test\n    public void testHandlesEmptyArray() {\n        boolean[] boolArray = {};\n        String expected = \"\";\n        assertEquals(expected, boolArrayToBinaryString(boolArray));\n    }\n\n    @Test\n    public void testHandlesSingleBooleanValue() {\n        boolean[] boolArray = {true};\n        String expected = \"1\";\n        assertEquals(expected, boolArrayToBinaryString(boolArray));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts the array of Boolean values to a binary string representation,\n * which converts to the character '1' if the Boolean value is true.\n * Otherwise, it is converted to the character '0', and the final string is returned.\n *\n * @param boolArray An array of boolean values.\n * @return A binary string where '1' represents true and '0' represents false.\n */\npublic static String boolArrayToBinaryString(boolean[] boolArray) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 163, "code_type": "method", "original_language": "typescript", "file_path": "prague-meetup\\64b994944d07318affaa18c9c7485f98eb1a53ab\\src\\utils\\boolArrayCodec.ts", "question_type": "Data processing and transformation", "summary": "Stores a second-level string in a set of 8-bit conversion integers in a Unit8Array and returns", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 164, "code_type": "method", "original_language": "typescript", "file_path": "prague-meetup\\64b994944d07318affaa18c9c7485f98eb1a53ab\\src\\utils\\boolArrayCodec.ts", "question_type": "Data processing and transformation", "summary": "The Unit8 array is converted into 4 Base64 characters as a group of 3 bytes for processing, and the output of less than 3 is filled with =, and the resulting Base64 string is returned", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 165, "code_type": "method", "original_language": "typescript", "file_path": "prague-meetup\\64b994944d07318affaa18c9c7485f98eb1a53ab\\src\\utils\\boolArrayCodec.ts", "question_type": "Data processing and transformation", "summary": "\nPlease convert a standard Base64 encoded string into a URL-safe Base64 encoded string. The steps include replacing \"+\" with \"-\", replacing \"/\" with \"_\", and removing the trailing \"=\" characters. The resulting string should be suitable for use in URLs.", "language_version_list": {"python": {"code_signature": "def base64_to_url_safe(base64: str) -> str:\n    \"\"\"\n    Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n\n    Args:\n        base64 (str): The standard Base64 encoded string to be converted.\n\n    Returns:\n        str: The URL-safe Base64 encoded string, which replaces '+' with '-' and '/' with '_'\n             and may remove any trailing '=' padding.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestBase64ToUrlSafe(unittest.TestCase):\n\n    def test_correct_conversion_to_url_safe_format(self):\n        base64 = \"YW55IGNhcm5hbCBwbGVhc3VyZS4+/w==\"\n        result = base64_to_url_safe(base64)\n        self.assertEqual(result, \"YW55IGNhcm5hbCBwbGVhc3VyZS4-_w\")\n\n    def test_empty_string_input(self):\n        base64 = \"\"\n        result = base64_to_url_safe(base64)\n        self.assertEqual(result, \"\")\n\n    def test_remove_trailing_equals(self):\n        base64 = \"dGVzdA==\"\n        result = base64_to_url_safe(base64)\n        self.assertEqual(result, \"dGVzdA\")\n\n    def test_no_replacement_needed(self):\n        base64 = \"dGVzdA\"\n        result = base64_to_url_safe(base64)\n        self.assertEqual(result, \"dGVzdA\")\n\n    def test_multiple_plus_and_slash(self):\n        base64 = \"aGVsbG8rL3dvcmxkLw==\"\n        result = base64_to_url_safe(base64)\n        self.assertEqual(result, \"aGVsbG8rL3dvcmxkLw\")\n\n    def test_non_string_input(self):\n        with self.assertRaises(TypeError):\n            base64_to_url_safe(None)  # Testing with None as input\n", "prompt": "please write a python function , the function signature as below def base64_to_url_safe(base64: str) -> str:\n    \"\"\"\n    Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n\n    Args:\n        base64 (str): The standard Base64 encoded string to be converted.\n\n    Returns:\n        str: The URL-safe Base64 encoded string, which replaces '+' with '-' and '/' with '_'\n             and may remove any trailing '=' padding.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param base64 - The standard Base64 encoded string to be converted.\n * @returns The URL-safe Base64 encoded string.\n */\nstd::string base64ToUrlSafe(const std::string& base64) {\n    // Function implementation goes here\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\n// Assuming base64ToUrlSafe is defined somewhere\nstd::string base64ToUrlSafe(const std::string& base64);\n\nTEST_CASE(\"base64ToUrlSafe\") {\n\n    SECTION(\"should correctly convert a standard Base64 string to URL-safe format\") {\n        std::string base64 = \"YW55IGNhcm5hbCBwbGVhc3VyZS4+/w==\";\n        std::string result = base64ToUrlSafe(base64);\n        REQUIRE(result == \"YW55IGNhcm5hbCBwbGVhc3VyZS4-_w\");\n    }\n\n    SECTION(\"should return an empty string when the input is an empty string\") {\n        std::string base64 = \"\";\n        std::string result = base64ToUrlSafe(base64);\n        REQUIRE(result == \"\");\n    }\n\n    SECTION(\"should remove only the trailing '=' characters\") {\n        std::string base64 = \"dGVzdA==\";\n        std::string result = base64ToUrlSafe(base64);\n        REQUIRE(result == \"dGVzdA\");\n    }\n\n    SECTION(\"should handle strings without any characters that need replacement\") {\n        std::string base64 = \"dGVzdA\";\n        std::string result = base64ToUrlSafe(base64);\n        REQUIRE(result == \"dGVzdA\");\n    }\n\n    SECTION(\"should handle a base64 string with multiple '+' and '/' characters\") {\n        std::string base64 = \"aGVsbG8rL3dvcmxkLw==\";\n        std::string result = base64ToUrlSafe(base64);\n        REQUIRE(result == \"aGVsbG8rL3dvcmxkLw\");\n    }\n\n    SECTION(\"should throw an error when input is not a string\") {\n        // Catch2 doesn't directly support throwing for invalid input types,\n        // so this section might be omitted or adjusted for your use case.\n        REQUIRE_THROWS_AS(base64ToUrlSafe(nullptr), std::invalid_argument);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param base64 - The standard Base64 encoded string to be converted.\n * @returns The URL-safe Base64 encoded string.\n */\nstd::string base64ToUrlSafe(const std::string& base64) {\n    // Function implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param base64 The standard Base64 encoded string to be converted.\n * @return The URL-safe Base64 encoded string.\n */\npublic static String base64ToUrlSafe(String base64) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testBase64ToUrlSafe_ConvertsStandardBase64() {\n        String base64 = \"YW55IGNhcm5hbCBwbGVhc3VyZS4+/w==\";\n        String result = base64ToUrlSafe(base64);\n        assertEquals(\"YW55IGNhcm5hbCBwbGVhc3VyZS4-_w\", result);\n    }\n\n    @Test\n    public void testBase64ToUrlSafe_EmptyString() {\n        String base64 = \"\";\n        String result = base64ToUrlSafe(base64);\n        assertEquals(\"\", result);\n    }\n\n    @Test\n    public void testBase64ToUrlSafe_RemovesTrailingEquals() {\n        String base64 = \"dGVzdA==\";\n        String result = base64ToUrlSafe(base64);\n        assertEquals(\"dGVzdA\", result);\n    }\n\n    @Test\n    public void testBase64ToUrlSafe_NoReplacementNeeded() {\n        String base64 = \"dGVzdA\";\n        String result = base64ToUrlSafe(base64);\n        assertEquals(\"dGVzdA\", result);\n    }\n\n    @Test\n    public void testBase64ToUrlSafe_MultipleCharacters() {\n        String base64 = \"aGVsbG8rL3dvcmxkLw==\";\n        String result = base64ToUrlSafe(base64);\n        assertEquals(\"aGVsbG8rL3dvcmxkLw\", result);\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param base64 The standard Base64 encoded string to be converted.\n * @return The URL-safe Base64 encoded string.\n */\npublic static String base64ToUrlSafe(String base64) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 166, "code_type": "method", "original_language": "typescript", "file_path": "100DaysOfDSA\\2d9d6bcf6f6039595ab9661d8b75510c6f0044e9\\Easy\\744 Find Smallest Letter Greater Than Target.ts", "question_type": "Algorithm and data structure", "summary": "Write a function that uses a binary search algorithm to find and return the smallest letter in a sorted array that is larger than a given target letter. If the target letter is greater than or equal to all the letters in the array, return the first letter in the array.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef next_greatest_letter(letters: List[str], target: str) -> str:\n    \"\"\"\n    Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n    If the target letter is greater than or equal to all letters in the array, the function returns\n    the first letter in the array.\n\n    Args:\n        letters (List[str]): A sorted array of letters (assumed to be unique and lowercase).\n        target (str): The target letter to find the next greatest letter for.\n\n    Returns:\n        str: The smallest letter in the array that is larger than the target letter.\n             If the target is greater than or equal to all letters, returns the first letter in the array.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestNextGreatestLetter(unittest.TestCase):\n\n    def test_target_greater_than_all_letters(self):\n        letters = ['c', 'f', 'j']\n        target = 'j'\n        result = next_greatest_letter(letters, target)\n        self.assertEqual(result, 'c')  # Expected output: 'c'\n\n    def test_typical_input(self):\n        letters = ['c', 'f', 'j']\n        target = 'a'\n        result = next_greatest_letter(letters, target)\n        self.assertEqual(result, 'c')  # Expected output: 'c'\n\n    def test_edge_case_between_two_letters(self):\n        letters = ['c', 'f', 'j']\n        target = 'd'\n        result = next_greatest_letter(letters, target)\n        self.assertEqual(result, 'f')  # Expected output: 'f'\n\n    def test_target_equal_to_largest_letter(self):\n        letters = ['a', 'b', 'c', 'd']\n        target = 'd'\n        result = next_greatest_letter(letters, target)\n        self.assertEqual(result, 'a')  # Expected output: 'a'\n\n    def test_single_letter_array(self):\n        letters = ['a']\n        target = 'z'\n        result = next_greatest_letter(letters, target)\n        self.assertEqual(result, 'a')  # Expected output: 'a'", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef next_greatest_letter(letters: List[str], target: str) -> str:\n    \"\"\"\n    Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n    If the target letter is greater than or equal to all letters in the array, the function returns\n    the first letter in the array.\n\n    Args:\n        letters (List[str]): A sorted array of letters (assumed to be unique and lowercase).\n        target (str): The target letter to find the next greatest letter for.\n\n    Returns:\n        str: The smallest letter in the array that is larger than the target letter.\n             If the target is greater than or equal to all letters, returns the first letter in the array.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param letters A sorted array of letters.\n * @param target The target letter to find the next greatest letter for.\n * @returns The smallest letter in the array that is larger than the target letter.\n */\nstd::string nextGreatestLetter(const std::vector<std::string>& letters, const std::string& target) {\n    // Function implementation...\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <vector>\n#include <string>\n\nstd::string nextGreatestLetter(const std::vector<std::string>& letters, const std::string& target);\n\nTEST_CASE(\"nextGreatestLetter\") {\n    SECTION(\"should return the first letter when target is greater than all letters in the array\") {\n        std::vector<std::string> letters = {\"c\", \"f\", \"j\"};\n        std::string target = \"j\";\n        std::string result = nextGreatestLetter(letters, target);\n        REQUIRE(result == \"c\"); // Expected output: 'c'\n    }\n\n    SECTION(\"should return the next greatest letter for a typical input\") {\n        std::vector<std::string> letters = {\"c\", \"f\", \"j\"};\n        std::string target = \"a\";\n        std::string result = nextGreatestLetter(letters, target);\n        REQUIRE(result == \"c\"); // Expected output: 'c'\n    }\n\n    SECTION(\"should handle the edge case where target is in between two letters\") {\n        std::vector<std::string> letters = {\"c\", \"f\", \"j\"};\n        std::string target = \"d\";\n        std::string result = nextGreatestLetter(letters, target);\n        REQUIRE(result == \"f\"); // Expected output: 'f'\n    }\n\n    SECTION(\"should return the first letter when the target is equal to the largest letter\") {\n        std::vector<std::string> letters = {\"a\", \"b\", \"c\", \"d\"};\n        std::string target = \"d\";\n        std::string result = nextGreatestLetter(letters, target);\n        REQUIRE(result == \"a\"); // Expected output: 'a'\n    }\n\n    SECTION(\"should return the correct letter when the array contains only one letter\") {\n        std::vector<std::string> letters = {\"a\"};\n        std::string target = \"z\";\n        std::string result = nextGreatestLetter(letters, target);\n        REQUIRE(result == \"a\"); // Expected output: 'a'\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param letters A sorted array of letters.\n * @param target The target letter to find the next greatest letter for.\n * @returns The smallest letter in the array that is larger than the target letter.\n */\nstd::string nextGreatestLetter(const std::vector<std::string>& letters, const std::string& target) {\n    // Function implementation...\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param letters - A sorted array of letters.\n * @param target - The target letter to find the next greatest letter for.\n * @returns The smallest letter in the array that is larger than the target letter.\n */\npublic static char nextGreatestLetter(char[] letters, char target) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testFirstLetterWhenTargetGreaterThanAll() {\n        char[] letters = {'c', 'f', 'j'};\n        char target = 'j';\n        char result = nextGreatestLetter(letters, target);\n        assertEquals('c', result); // Expected output: 'c'\n    }\n\n    @Test\n    public void testNextGreatestLetterForTypicalInput() {\n        char[] letters = {'c', 'f', 'j'};\n        char target = 'a';\n        char result = nextGreatestLetter(letters, target);\n        assertEquals('c', result); // Expected output: 'c'\n    }\n\n    @Test\n    public void testEdgeCaseWhereTargetInBetween() {\n        char[] letters = {'c', 'f', 'j'};\n        char target = 'd';\n        char result = nextGreatestLetter(letters, target);\n        assertEquals('f', result); // Expected output: 'f'\n    }\n\n    @Test\n    public void testFirstLetterWhenTargetEqualToLargest() {\n        char[] letters = {'a', 'b', 'c', 'd'};\n        char target = 'd';\n        char result = nextGreatestLetter(letters, target);\n        assertEquals('a', result); // Expected output: 'a'\n    }\n\n    @Test\n    public void testCorrectLetterWithSingleElementArray() {\n        char[] letters = {'a'};\n        char target = 'z';\n        char result = nextGreatestLetter(letters, target);\n        assertEquals('a', result); // Expected output: 'a'\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param letters - A sorted array of letters.\n * @param target - The target letter to find the next greatest letter for.\n * @returns The smallest letter in the array that is larger than the target letter.\n */\npublic static char nextGreatestLetter(char[] letters, char target) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 167, "code_type": "method", "original_language": "typescript", "file_path": "bit-test\\65606717613da465daf07518e73c78d936171217\\src\\index.ts", "question_type": "Program input code", "summary": "Write a function that determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer (ranging from 0 to 999) after removing the \".bit\" suffix. The function should involve removing the \".bit\" suffix, converting the remaining part to an integer, and using a regular expression to verify if it is a 3-digit number. The function should return a boolean indicating whether the string meets this criterion.", "language_version_list": {"python": {"code_signature": "def assert999(bit_name: str) -> bool:\n    \"\"\"\n    Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.\n    Removes the \".bit\" suffix, checks if the remaining part is a number,\n    and verifies if it falls within the range of 0 to 999.\n\n    Args:\n        bit_name (str): The string to validate, which should end with \".bit\".\n\n    Returns:\n        bool: True if the remaining part after removing \".bit\" is a valid 3-digit integer (0-999);\n              otherwise, False.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestAssert999(unittest.TestCase):\n    def test_valid_three_digit_number_with_suffix(self):\n        \"\"\"Test case for a valid 3-digit number with the \".bit\" suffix. Expected to return true.\"\"\"\n        input_value = \"123.bit\"\n        result = assert999(input_value)\n        self.assertTrue(result)\n\n    def test_valid_two_digit_number_with_suffix(self):\n        \"\"\"Test case for a valid 2-digit number with the \".bit\" suffix. Expected to return true.\"\"\"\n        input_value = \"12.bit\"\n        result = assert999(input_value)\n        self.assertTrue(result)\n\n    def test_non_numeric_characters_after_suffix(self):\n        \"\"\"Test case for a string containing non-numeric characters after removing \".bit\". Expected to return false.\"\"\"\n        input_value = \"12a.bit\"\n        result = assert999(input_value)\n        self.assertFalse(result)\n\n    def test_lower_boundary_value(self):\n        \"\"\"Test case for the lower boundary value \"0.bit\". Expected to return true.\"\"\"\n        input_value = \"0.bit\"\n        result = assert999(input_value)\n        self.assertTrue(result)\n\n    def test_upper_boundary_value(self):\n        \"\"\"Test case for the upper boundary value \"999.bit\". Expected to return true.\"\"\"\n        input_value = \"999.bit\"\n        result = assert999(input_value)\n        self.assertTrue(result)", "prompt": "please write a python function , the function signature as below def assert999(bit_name: str) -> bool:\n    \"\"\"\n    Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.\n    Removes the \".bit\" suffix, checks if the remaining part is a number,\n    and verifies if it falls within the range of 0 to 999.\n\n    Args:\n        bit_name (str): The string to validate, which should end with \".bit\".\n\n    Returns:\n        bool: True if the remaining part after removing \".bit\" is a valid 3-digit integer (0-999);\n              otherwise, False.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.\n * Removes the \".bit\" suffix, checks if the remaining part is a number and verifies if it falls within the range of 0 to 999.\n *\n * @param bitName - The string to validate.\n * @returns True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\nbool assert999(const std::string& bitName) {\n    // Implementation goes here\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\n// Assuming assert999 function is defined elsewhere\n\nTEST_CASE(\"assert999\") {\n    /**\n     * Test case for a valid 3-digit number with the \".bit\" suffix.\n     * Expected to return true.\n     */\n    SECTION(\"should return true for a valid 3-digit number with '.bit' suffix\") {\n        std::string input = \"123.bit\";\n        bool result = assert999(input);\n        REQUIRE(result == true);\n    }\n\n    /**\n     * Test case for a valid 2-digit number with the \".bit\" suffix.\n     * Expected to return true.\n     */\n    SECTION(\"should return true for a valid 2-digit number with '.bit' suffix\") {\n        std::string input = \"12.bit\";\n        bool result = assert999(input);\n        REQUIRE(result == true);\n    }\n\n    /**\n     * Test case for a string containing non-numeric characters after removing \".bit\".\n     * Expected to return false.\n     */\n    SECTION(\"should return false for a string with non-numeric characters after removing '.bit'\") {\n        std::string input = \"12a.bit\";\n        bool result = assert999(input);\n        REQUIRE(result == false);\n    }\n\n    /**\n     * Test case for the lower boundary value \"0.bit\".\n     * Expected to return true.\n     */\n    SECTION(\"should return true for the lower boundary value '0.bit'\") {\n        std::string input = \"0.bit\";\n        bool result = assert999(input);\n        REQUIRE(result == true);\n    }\n\n    /**\n     * Test case for the upper boundary value \"999.bit\".\n     * Expected to return true.\n     */\n    SECTION(\"should return true for the upper boundary value '999.bit'\") {\n        std::string input = \"999.bit\";\n        bool result = assert999(input);\n        REQUIRE(result == true);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.\n * Removes the \".bit\" suffix, checks if the remaining part is a number and verifies if it falls within the range of 0 to 999.\n *\n * @param bitName - The string to validate.\n * @returns True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\nbool assert999(const std::string& bitName) {\n    // Implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.\n * Removes the \".bit\" suffix, checks if the remaining part is a number and verifies if it falls within the range of 0 to 999.\n *\n * @param bitName The string to validate.\n * @return True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\npublic static boolean assert999(String bitName) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    /**\n     * Test case for a valid 3-digit number with the \".bit\" suffix.\n     * Expected to return true.\n     */\n    @Test\n    public void testValidThreeDigitNumber() {\n        String input = \"123.bit\";\n        boolean result = assert999(input);\n        assertTrue(result);\n    }\n\n    /**\n     * Test case for a valid 2-digit number with the \".bit\" suffix.\n     * Expected to return true.\n     */\n    @Test\n    public void testValidTwoDigitNumber() {\n        String input = \"12.bit\";\n        boolean result = assert999(input);\n        assertTrue(result);\n    }\n\n    /**\n     * Test case for a string containing non-numeric characters after removing \".bit\".\n     * Expected to return false.\n     */\n    @Test\n    public void testNonNumericCharacters() {\n        String input = \"12a.bit\";\n        boolean result = assert999(input);\n        assertFalse(result);\n    }\n\n    /**\n     * Test case for the lower boundary value \"0.bit\".\n     * Expected to return true.\n     */\n    @Test\n    public void testLowerBoundaryValue() {\n        String input = \"0.bit\";\n        boolean result = assert999(input);\n        assertTrue(result);\n    }\n\n    /**\n     * Test case for the upper boundary value \"999.bit\".\n     * Expected to return true.\n     */\n    @Test\n    public void testUpperBoundaryValue() {\n        String input = \"999.bit\";\n        boolean result = assert999(input);\n        assertTrue(result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.\n * Removes the \".bit\" suffix, checks if the remaining part is a number and verifies if it falls within the range of 0 to 999.\n *\n * @param bitName The string to validate.\n * @return True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\npublic static boolean assert999(String bitName) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 168, "code_type": "method", "original_language": "typescript", "file_path": "pinstop\\6c8202202ae311c9078e1c70afa46cf492cdcb02\\src\\lib\\utils.ts", "question_type": "Data processing and transformation", "summary": "Please convert a date string into a relative time description. Based on the time difference between the current time and the input date, generate a string that represents the relative time, such as \"X days ago,\" \"X hours ago,\" \"X minutes ago,\" or \"X seconds ago.\" Ensure the output displays the time difference in a user-friendly manner.", "language_version_list": {"python": {"code_signature": "def format_date(date_string: str) -> str:\n    \"\"\"\n    Converts a date string into a relative time description.\n    For example, now time 2024-08-25T12:00:00\n         input: 2024-08-24T12:00:00 output: 1 day ago\n         input: 2024-08-25T07:00:00 output: 5 hours ago\n\n    Args:\n        date_string (str): The date string to convert.\n\n    Returns:\n        str: A user-friendly string representing the relative time difference from the current date.\n    \"\"\"", "test_code": "import unittest\nfrom datetime import datetime\nfrom unittest.mock import patch\n\n\nclass TestFormatDate(unittest.TestCase):\n\n    @patch('your_module.datetime')\n    def setUp(self, mock_datetime):\n        # Set the system time to a fixed date for consistent testing\n        mock_datetime.now.return_value = datetime(2024, 8, 25, 12, 0, 0)\n\n    def test_one_day_ago(self):\n        date_string = '2024-08-24T12:00:00'\n        result = format_date(date_string)\n        self.assertIn(result, ['1 day ago', '24 hours ago'])\n\n    def test_five_hours_ago(self):\n        date_string = '2024-08-25T07:00:00'\n        result = format_date(date_string)\n        self.assertEqual(result, '5 hours ago')\n\n    def test_two_minutes_ago(self):\n        date_string = '2024-08-25T11:58:00'\n        result = format_date(date_string)\n        self.assertEqual(result, '2 minutes ago')\n\n    def test_just_now(self):\n        date_string = '2024-08-25T11:59:59'\n        result = format_date(date_string)\n        self.assertIn(result, ['1 second ago', '1 seconds ago'])\n", "prompt": "please write a python function , the function signature as below def format_date(date_string: str) -> str:\n    \"\"\"\n    Converts a date string into a relative time description.\n    For example, now time 2024-08-25T12:00:00\n         input: 2024-08-24T12:00:00 output: 1 day ago\n         input: 2024-08-25T07:00:00 output: 5 hours ago\n\n    Args:\n        date_string (str): The date string to convert.\n\n    Returns:\n        str: A user-friendly string representing the relative time difference from the current date.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts a date string into a relative time description.\n * For example, now time 2024-08-25T12:00:00\n *      input: 2024-08-24T12:00:00 output: 1 day ago\n *      input: 2024-08-25T07:00:00 output: 5 hours ago\n *\n * @param dateString The date string to convert.\n * @returns A user-friendly string representing the relative time difference from the current date.\n */\nstd::string formatDate(const std::string& dateString){\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <chrono>\n#include <iomanip>\n#include <sstream>\n#include \"your_header_file.h\" // Include the header file with formatDate\n\nTEST_CASE(\"formatDate\") {\n    // Set the system time to a fixed date for consistent testing\n    std::tm fixedTime = {};\n    std::istringstream ss(\"2024-08-25 12:00:00\");\n    ss >> std::get_time(&fixedTime, \"%Y-%m-%d %H:%M:%S\");\n    time_t currentTime = mktime(&fixedTime);\n    std::time(nullptr) = currentTime; // Note: Adjust as needed for your test environment\n\n    SECTION(\"should return '1 day ago' for a date exactly one day before\") {\n        std::string dateString = \"2024-08-24T12:00:00\";\n        std::string result = formatDate(dateString);\n        REQUIRE((result == \"1 day ago\" || result == \"24 hours ago\"));\n    }\n\n    SECTION(\"should return '5 hours ago' for a date 5 hours before the current time\") {\n        std::string dateString = \"2024-08-25T07:00:00\";\n        std::string result = formatDate(dateString);\n        REQUIRE(result == \"5 hours ago\");\n    }\n\n    SECTION(\"should return '2 minutes ago' for a date 2 minutes before the current time\") {\n        std::string dateString = \"2024-08-25T11:58:00\";\n        std::string result = formatDate(dateString);\n        REQUIRE(result == \"2 minutes ago\");\n    }\n\n    SECTION(\"should return 'just now' for a date within the last second\") {\n        std::string dateString = \"2024-08-25T11:59:59\";\n        std::string result = formatDate(dateString);\n        REQUIRE((result == \"1 second ago\" || result == \"1 seconds ago\"));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts a date string into a relative time description.\n * For example, now time 2024-08-25T12:00:00\n *      input: 2024-08-24T12:00:00 output: 1 day ago\n *      input: 2024-08-25T07:00:00 output: 5 hours ago\n *\n * @param dateString The date string to convert.\n * @returns A user-friendly string representing the relative time difference from the current date.\n */\nstd::string formatDate(const std::string& dateString){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a date string into a relative time description.\n * For example, now time 2024-08-25T12:00:00\n *      input: 2024-08-24T12:00:00 output: 1 day ago\n *      input: 2024-08-25T07:00:00 output: 5 hours ago\n *\n * @param dateString The date string to convert.\n * @return A user-friendly string representing the relative time difference from the current date.\n * @throws IllegalArgumentException If the date string is invalid.\n */\npublic static String formatDate(String dateString) throws IllegalArgumentException {}", "test_code": "package org.real.temp;\n\nimport org.junit.BeforeClass;\nimport org.junit.AfterClass;\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @BeforeClass\n    public static void setUp() {\n        // Set the system time to a fixed date for consistent testing\n        // Note: Java does not allow changing system time directly;\n        // consider using a library for time manipulation in tests.\n        // This is a placeholder to indicate intent.\n    }\n\n    @AfterClass\n    public static void tearDown() {\n        // Restore the real system time after tests\n        // Placeholder for restoring time\n    }\n\n    @Test\n    public void testOneDayAgo() {\n        String dateString = \"2024-08-24T12:00:00\";\n        String result = DateFormatter.formatDate(dateString);\n        assertTrue(result.equals(\"1 day ago\") || result.equals(\"24 hours ago\"));\n    }\n\n    @Test\n    public void testFiveHoursAgo() {\n        String dateString = \"2024-08-25T07:00:00\";\n        String result = DateFormatter.formatDate(dateString);\n        assertEquals(\"5 hours ago\", result);\n    }\n\n    @Test\n    public void testTwoMinutesAgo() {\n        String dateString = \"2024-08-25T11:58:00\";\n        String result = DateFormatter.formatDate(dateString);\n        assertEquals(\"2 minutes ago\", result);\n    }\n\n    @Test\n    public void testJustNow() {\n        String dateString = \"2024-08-25T11:59:59\";\n        String result = DateFormatter.formatDate(dateString);\n        assertTrue(result.equals(\"1 second ago\") || result.equals(\"1 seconds ago\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a date string into a relative time description.\n * For example, now time 2024-08-25T12:00:00\n *      input: 2024-08-24T12:00:00 output: 1 day ago\n *      input: 2024-08-25T07:00:00 output: 5 hours ago\n *\n * @param dateString The date string to convert.\n * @return A user-friendly string representing the relative time difference from the current date.\n * @throws IllegalArgumentException If the date string is invalid.\n */\npublic static String formatDate(String dateString) throws IllegalArgumentException {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 169, "code_type": "method", "original_language": "typescript", "file_path": "whiskerweb\\9a52b42647ff91ba28f974d5cdc29f6172fe1c81\\src\\engine\\HelperFunctions\\convertToRoman.ts", "question_type": "Data processing and transformation", "summary": "Convert an Arabic numeral to a Roman numeral", "language_version_list": {"python": {"code_signature": "def convert_to_roman(num: int) -> str:\n    \"\"\"\n    Converts an Arabic numeral to its Roman numeral equivalent.\n\n    Args:\n        num (int): The number to convert.\n\n    Returns:\n        str: The Roman numeral representation of the input number.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestConvertToRoman(unittest.TestCase):\n    def test_typical_number(self):\n        result = convert_to_roman(1987)\n        self.assertEqual(result, 'MCMLXXXVII')  # 1987 = M + CM + LXXX + VII\n\n    def test_minimum_value(self):\n        result = convert_to_roman(1)\n        self.assertEqual(result, 'I')  # 1 = I\n\n    def test_large_number(self):\n        result = convert_to_roman(3999)\n        self.assertEqual(result, 'MMMCMXCIX')  # 3999 = MMM + CM + XC + IX\n\n    def test_different_numeral_repeats(self):\n        result = convert_to_roman(1666)\n        self.assertEqual(result, 'MDCLXVI')  # 1666 = M + D + CLX + VI\n\n    def test_no_fives_and_ones(self):\n        result = convert_to_roman(2000)\n        self.assertEqual(result, 'MM')  # 2000 = MM\n", "prompt": "please write a python function , the function signature as below def convert_to_roman(num: int) -> str:\n    \"\"\"\n    Converts an Arabic numeral to its Roman numeral equivalent.\n\n    Args:\n        num (int): The number to convert.\n\n    Returns:\n        str: The Roman numeral representation of the input number.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param num The number to convert.\n * @returns The Roman numeral representation of the input number.\n */\nstd::string convertToRoman(int num){\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include \"your_header_file.h\" // Include the header where convertToRoman is declared\n\nTEST_CASE(\"convertToRoman\", \"[roman]\") {\n    SECTION(\"should return the correct Roman numeral for a typical number\") {\n        std::string result = convertToRoman(1987);\n        REQUIRE(result == \"MCMLXXXVII\"); // 1987 = M + CM + LXXX + VII\n    }\n\n    SECTION(\"should return the correct Roman numeral for the minimum value (1)\") {\n        std::string result = convertToRoman(1);\n        REQUIRE(result == \"I\"); // 1 = I\n    }\n\n    SECTION(\"should return the correct Roman numeral for a large number (3999)\") {\n        std::string result = convertToRoman(3999);\n        REQUIRE(result == \"MMMCMXCIX\"); // 3999 = MMM + CM + XC + IX\n    }\n\n    SECTION(\"should return the correct Roman numeral for a number with different numeral repeats\") {\n        std::string result = convertToRoman(1666);\n        REQUIRE(result == \"MDCLXVI\"); // 1666 = M + D + CLX + VI\n    }\n\n    SECTION(\"should return the correct Roman numeral for number with no 5s and 1s\") {\n        std::string result = convertToRoman(2000);\n        REQUIRE(result == \"MM\"); // 2000 = MM\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param num The number to convert.\n * @returns The Roman numeral representation of the input number.\n */\nstd::string convertToRoman(int num){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param num The number to convert.\n * @return The Roman numeral representation of the input number.\n */\npublic String convertToRoman(int num) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testConvertToRomanTypicalNumber() {\n        String result = convertToRoman(1987);\n        assertEquals(\"MCMLXXXVII\", result); // 1987 = M + CM + LXXX + VII\n    }\n\n    @Test\n    public void testConvertToRomanMinimumValue() {\n        String result = convertToRoman(1);\n        assertEquals(\"I\", result); // 1 = I\n    }\n\n    @Test\n    public void testConvertToRomanLargeNumber() {\n        String result = convertToRoman(3999);\n        assertEquals(\"MMMCMXCIX\", result); // 3999 = MMM + CM + XC + IX\n    }\n\n    @Test\n    public void testConvertToRomanNumeralRepeats() {\n        String result = convertToRoman(1666);\n        assertEquals(\"MDCLXVI\", result); // 1666 = M + D + CLX + VI\n    }\n\n    @Test\n    public void testConvertToRomanNoFivesAndOnes() {\n        String result = convertToRoman(2000);\n        assertEquals(\"MM\", result); // 2000 = MM\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param num The number to convert.\n * @return The Roman numeral representation of the input number.\n */\npublic String convertToRoman(int num) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 331, "code_type": "method", "original_language": "typescript", "file_path": "Organick_Food_Store\\2093856b6b11a157d85a9ce2680d48586192af5b\\lib\\utils.ts", "question_type": "Data processing and transformation", "summary": "Calculates  the final price after applying a discount to the original price.Both price and discount are expected as strings and should represent valid numbers.The discount should be a percentage value between 0 and 100.\n", "language_version_list": {"python": {"code_signature": "def calculate_final_price(price: str, discount: str) -> float:\n    \"\"\"\n    Calculates the final price after applying a discount to the original price.\n    Both price and discount are expected as strings and should represent valid numbers.\n    The discount should be a percentage value between 0 and 100.\n\n    Args:\n        price (str): The original price as a string.\n        discount (str): The discount percentage as a string.\n\n    Returns:\n        float: The final price after applying the discount, rounded to two decimal places.\n\n    Raises:\n        ValueError: Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCalculateFinalPrice(unittest.TestCase):\n\n    def test_calculate_final_price_with_valid_inputs(self):\n        \"\"\"\n        should calculate the final price correctly with valid inputs\n        \"\"\"\n        result = calculate_final_price('200', '10')\n        self.assertEqual(result, 180.0)\n\n    def test_discount_is_zero(self):\n        \"\"\"\n        should return the original price when the discount is 0%\n        \"\"\"\n        result = calculate_final_price('150', '0')\n        self.assertEqual(result, 150.0)\n\n    def test_discount_is_hundred(self):\n        \"\"\"\n        should return zero when the discount is 100%\n        \"\"\"\n        result = calculate_final_price('100', '100')\n        self.assertEqual(result, 0.0)\n", "prompt": "please write a python function , the function signature as below def calculate_final_price(price: str, discount: str) -> float:\n    \"\"\"\n    Calculates the final price after applying a discount to the original price.\n    Both price and discount are expected as strings and should represent valid numbers.\n    The discount should be a percentage value between 0 and 100.\n\n    Args:\n        price (str): The original price as a string.\n        discount (str): The discount percentage as a string.\n\n    Returns:\n        float: The final price after applying the discount, rounded to two decimal places.\n\n    Raises:\n        ValueError: Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\ndouble calculateFinalPrice(const std::string& price, const std::string& discount) {\n    // Function implementation goes here\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <stdexcept>\n\n// Assuming the calculateFinalPrice function is declared above or in another included file\n\nTEST_CASE(\"calculateFinalPrice\", \"[calculateFinalPrice]\") {\n    SECTION(\"should calculate the final price correctly with valid inputs\") {\n        double result = calculateFinalPrice(\"200\", \"10\");\n        REQUIRE(result == 180);\n    }\n\n    SECTION(\"should return the original price when the discount is 0%\") {\n        double result = calculateFinalPrice(\"150\", \"0\");\n        REQUIRE(result == 150);\n    }\n\n    SECTION(\"should return zero when the discount is 100%\") {\n        double result = calculateFinalPrice(\"100\", \"100\");\n        REQUIRE(result == 0);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\ndouble calculateFinalPrice(const std::string& price, const std::string& discount) {\n    // Function implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws IllegalArgumentException if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\npublic static double calculateFinalPrice(String price, String discount) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testCalculateFinalPriceWithValidInputs() {\n        double result = PriceCalculator.calculateFinalPrice(\"200\", \"10\");\n        assertEquals(180.0, result, 0.01);\n    }\n\n    @Test\n    public void testCalculateFinalPriceWithZeroDiscount() {\n        double result = PriceCalculator.calculateFinalPrice(\"150\", \"0\");\n        assertEquals(150.0, result, 0.01);\n    }\n\n    @Test\n    public void testCalculateFinalPriceWithHundredPercentDiscount() {\n        double result = PriceCalculator.calculateFinalPrice(\"100\", \"100\");\n        assertEquals(0.0, result, 0.01);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws IllegalArgumentException if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\npublic static double calculateFinalPrice(String price, String discount) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 334, "code_type": "method", "original_language": "typescript", "file_path": "us-holidays\\63a5374d589b1f20d79f2e30dc04ab23a13e23d2\\src\\year.ts", "question_type": "Data processing and transformation", "summary": "Calculate the date of Good Friday in a given year", "language_version_list": {"python": {"code_signature": "from datetime import date\n\n\ndef calculate_good_friday(year: int) -> str:\n    \"\"\"\n    Calculate the date of Good Friday in a given year.\n\n    For example:\n        input: 2024\n        output: Fri Mar 29 2024\n\n    Args:\n        year (int): The year for which to calculate Good Friday.\n\n    Returns:\n        str: The date of Good Friday.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestCalculateGoodFriday(unittest.TestCase):\n\n    def test_calculate_good_friday_2024(self):\n        result = calculate_good_friday(2024)\n        self.assertEqual(result.strftime('%a %b %d %Y'), 'Fri Mar 29 2024')\n\n    def test_calculate_good_friday_2021(self):\n        result = calculate_good_friday(2021)\n        self.assertEqual(result.strftime('%a %b %d %Y'), 'Fri Apr 02 2021')\n\n    def test_calculate_good_friday_2000(self):\n        result = calculate_good_friday(2000)\n        self.assertEqual(result.strftime('%a %b %d %Y'), 'Fri Apr 21 2000')\n\n    def test_calculate_good_friday_2019(self):\n        result = calculate_good_friday(2019)\n        self.assertEqual(result.strftime('%a %b %d %Y'), 'Fri Apr 19 2019')\n\n    def test_calculate_good_friday_1999(self):\n        result = calculate_good_friday(1999)\n        self.assertEqual(result.strftime('%a %b %d %Y'), 'Fri Apr 02 1999')\n\n    def test_calculate_good_friday_1981(self):\n        result = calculate_good_friday(1981)\n        self.assertEqual(result.strftime('%a %b %d %Y'), 'Fri Apr 17 1981')\n\n    def test_calculate_good_friday_1954(self):\n        result = calculate_good_friday(1954)\n        self.assertEqual(result.strftime('%a %b %d %Y'), 'Fri Apr 16 1954')\n", "prompt": "please write a python function , the function signature as below from datetime import date\n\n\ndef calculate_good_friday(year: int) -> str:\n    \"\"\"\n    Calculate the date of Good Friday in a given year.\n\n    For example:\n        input: 2024\n        output: Fri Mar 29 2024\n\n    Args:\n        year (int): The year for which to calculate Good Friday.\n\n    Returns:\n        str: The date of Good Friday.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculate the date of Good Friday in a given year\n * For example:\n *      input: 2024\n *      output: Fri Mar 29 2024\n * @param year The year for which to calculate Good Friday\n * @return std::tm structure representing Good Friday\n */\nstd::tm calculateGoodFriday(int year){\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <iomanip>\n#include <sstream>\n#include <ctime>\n\nstd::tm calculateGoodFriday(int year); // Declaration of the function\n\nstd::string formatDate(const std::tm& date) {\n    std::ostringstream oss;\n    oss << std::put_time(&date, \"%a %b %d %Y\");\n    return oss.str();\n}\n\nTEST_CASE(\"calculateGoodFriday\", \"[GoodFriday]\") {\n    SECTION(\"should correctly calculate Good Friday for 2024\") {\n        std::tm result = calculateGoodFriday(2024);\n        REQUIRE(formatDate(result) == \"Fri Mar 29 2024\");\n    }\n\n    SECTION(\"should correctly calculate Good Friday for 2021\") {\n        std::tm result = calculateGoodFriday(2021);\n        REQUIRE(formatDate(result) == \"Fri Apr 02 2021\");\n    }\n\n    SECTION(\"should correctly calculate Good Friday for 2000\") {\n        std::tm result = calculateGoodFriday(2000);\n        REQUIRE(formatDate(result) == \"Fri Apr 21 2000\");\n    }\n\n    SECTION(\"should correctly calculate Good Friday for 2019\") {\n        std::tm result = calculateGoodFriday(2019);\n        REQUIRE(formatDate(result) == \"Fri Apr 19 2019\");\n    }\n\n    SECTION(\"should correctly calculate Good Friday for 1999\") {\n        std::tm result = calculateGoodFriday(1999);\n        REQUIRE(formatDate(result) == \"Fri Apr 02 1999\");\n    }\n\n    SECTION(\"should correctly calculate Good Friday for 1981\") {\n        std::tm result = calculateGoodFriday(1981);\n        REQUIRE(formatDate(result) == \"Fri Apr 17 1981\");\n    }\n\n    SECTION(\"should correctly calculate Good Friday for 1954\") {\n        std::tm result = calculateGoodFriday(1954);\n        REQUIRE(formatDate(result) == \"Fri Apr 16 1954\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculate the date of Good Friday in a given year\n * For example:\n *      input: 2024\n *      output: Fri Mar 29 2024\n * @param year The year for which to calculate Good Friday\n * @return std::tm structure representing Good Friday\n */\nstd::tm calculateGoodFriday(int year){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate the date of Good Friday in a given year.\n * For example:\n *      input: 2024\n *      output: Fri Mar 29 2024\n * @param year the year for which to calculate Good Friday\n * @return the date of Good Friday\n */\npublic static Date calculateGoodFriday(int year) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport java.util.Date;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n    @Test\n    public void testCalculateGoodFriday2024() {\n        Date result = EasterCalculator.calculateGoodFriday(2024);\n        assertEquals(\"Fri Mar 29 00:00:00 UTC 2024\", result.toString());\n    }\n\n    @Test\n    public void testCalculateGoodFriday2021() {\n        Date result = EasterCalculator.calculateGoodFriday(2021);\n        assertEquals(\"Fri Apr 02 00:00:00 UTC 2021\", result.toString());\n    }\n\n    @Test\n    public void testCalculateGoodFriday2000() {\n        Date result = EasterCalculator.calculateGoodFriday(2000);\n        assertEquals(\"Fri Apr 21 00:00:00 UTC 2000\", result.toString());\n    }\n\n    @Test\n    public void testCalculateGoodFriday2019() {\n        Date result = EasterCalculator.calculateGoodFriday(2019);\n        assertEquals(\"Fri Apr 19 00:00:00 UTC 2019\", result.toString());\n    }\n\n    @Test\n    public void testCalculateGoodFriday1999() {\n        Date result = EasterCalculator.calculateGoodFriday(1999);\n        assertEquals(\"Fri Apr 02 00:00:00 UTC 1999\", result.toString());\n    }\n\n    @Test\n    public void testCalculateGoodFriday1981() {\n        Date result = EasterCalculator.calculateGoodFriday(1981);\n        assertEquals(\"Fri Apr 17 00:00:00 UTC 1981\", result.toString());\n    }\n\n    @Test\n    public void testCalculateGoodFriday1954() {\n        Date result = EasterCalculator.calculateGoodFriday(1954);\n        assertEquals(\"Fri Apr 16 00:00:00 UTC 1954\", result.toString());\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculate the date of Good Friday in a given year.\n * For example:\n *      input: 2024\n *      output: Fri Mar 29 2024\n * @param year the year for which to calculate Good Friday\n * @return the date of Good Friday\n */\npublic static Date calculateGoodFriday(int year) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 341, "code_type": "method", "original_language": "typescript", "file_path": "heavenfire\\68785b702cec5a3d92ad55339e3036d0315399cb\\javascript\\control_panel\\src\\utils.ts", "question_type": "Data processing and transformation", "summary": "Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.", "language_version_list": {"python": {"code_signature": "def convert_time_hms_string_to_ms(time_str: str) -> int:\n    \"\"\"\n    Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n\n    Args:\n        time_str (str): The input string representing the time duration.\n\n    Returns:\n        int: The time in milliseconds.\n\n    Raises:\n        ValueError: If the input string does not match the expected format.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestConvertTimeHmsStringToMs(unittest.TestCase):\n\n    def test_converts_typical_time_string_correctly(self):\n        result = convert_time_hms_string_to_ms('1h30m15s')\n        self.assertEqual(result, 5415000)  # 1 hour + 30 minutes + 15 seconds in ms\n\n    def test_correctly_converts_string_with_zero_values(self):\n        result = convert_time_hms_string_to_ms('0h0m0s')\n        self.assertEqual(result, 0)  # 0 ms\n\n    def test_converts_maximum_single_digit_values(self):\n        result = convert_time_hms_string_to_ms('9h59m59s')\n        self.assertEqual(result, 35999000)  # 9 hours + 59 minutes + 59 seconds in ms\n\n    def test_handles_large_values(self):\n        result = convert_time_hms_string_to_ms('100h0m0s')\n        self.assertEqual(result, 360000000)  # 100 hours in ms\n\n    def test_correctly_converts_strings_with_leading_zeros(self):\n        result = convert_time_hms_string_to_ms('01h01m01s')\n        self.assertEqual(result, 3661000)  # 1 hour + 1 minute + 1 second in ms\n", "prompt": "please write a python function , the function signature as below def convert_time_hms_string_to_ms(time_str: str) -> int:\n    \"\"\"\n    Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n\n    Args:\n        time_str (str): The input string representing the time duration.\n\n    Returns:\n        int: The time in milliseconds.\n\n    Raises:\n        ValueError: If the input string does not match the expected format.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @returns The time in milliseconds.\n * @throws std::invalid_argument if the input string does not match the expected format.\n */\nlong long convertTimeHmsStringToMs(const std::string& str) {\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include \"your_header_file.h\" // Include the header file where your function is declared\n\nTEST_CASE(\"convertTimeHmsStringToMs\", \"[conversion]\") {\n    SECTION(\"converts typical time string correctly (1h30m15s)\") {\n        long long result = convertTimeHmsStringToMs(\"1h30m15s\");\n        REQUIRE(result == 5415000);  // 1 hour + 30 minutes + 15 seconds in ms\n    }\n\n    SECTION(\"correctly converts string with zero values (0h0m0s)\") {\n        long long result = convertTimeHmsStringToMs(\"0h0m0s\");\n        REQUIRE(result == 0);  // 0 ms\n    }\n\n    SECTION(\"converts maximum single digit values (9h59m59s)\") {\n        long long result = convertTimeHmsStringToMs(\"9h59m59s\");\n        REQUIRE(result == 35999000); // 9 hours + 59 minutes + 59 seconds in ms\n    }\n\n    SECTION(\"handles large values (100h0m0s)\") {\n        long long result = convertTimeHmsStringToMs(\"100h0m0s\");\n        REQUIRE(result == 360000000); // 100 hours in ms\n    }\n\n    SECTION(\"correctly converts strings with leading zeros (01h01m01s)\") {\n        long long result = convertTimeHmsStringToMs(\"01h01m01s\");\n        REQUIRE(result == 3661000); // 1 hour + 1 minute + 1 second in ms\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @returns The time in milliseconds.\n * @throws std::invalid_argument if the input string does not match the expected format.\n */\nlong long convertTimeHmsStringToMs(const std::string& str) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @return The time in milliseconds.\n * @throws IllegalArgumentException if the input string does not match the expected format.\n */\npublic static long convertTimeHmsStringToMs(String str) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testConvertTypicalTimeString() {\n        long result = TimeConverter.convertTimeHmsStringToMs(\"1h30m15s\");\n        assertEquals(5415000, result);  // 1 hour + 30 minutes + 15 seconds in ms\n    }\n\n    @Test\n    public void testConvertZeroValues() {\n        long result = TimeConverter.convertTimeHmsStringToMs(\"0h0m0s\");\n        assertEquals(0, result);  // 0 ms\n    }\n\n    @Test\n    public void testConvertMaxSingleDigitValues() {\n        long result = TimeConverter.convertTimeHmsStringToMs(\"9h59m59s\");\n        assertEquals(35999000, result); // 9 hours + 59 minutes + 59 seconds in ms\n    }\n\n    @Test\n    public void testHandleLargeValues() {\n        long result = TimeConverter.convertTimeHmsStringToMs(\"100h0m0s\");\n        assertEquals(360000000, result); // 100 hours in ms\n    }\n\n    @Test\n    public void testConvertLeadingZeros() {\n        long result = TimeConverter.convertTimeHmsStringToMs(\"01h01m01s\");\n        assertEquals(3661000, result); // 1 hour + 1 minute + 1 second in ms\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @return The time in milliseconds.\n * @throws IllegalArgumentException if the input string does not match the expected format.\n */\npublic static long convertTimeHmsStringToMs(String str) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 342, "code_type": "method", "original_language": "typescript", "file_path": "portfolio\\88d051ebeb004653bfa6528297815bb2c764f9c1\\lib\\mdx\\title-parser.ts", "question_type": "Data processing and transformation", "summary": "Parses the Markdown string title, extracts the first-level title, second-level title, third-level title, and returns it in the form of a dictionary array", "language_version_list": {"python": {"code_signature": "from typing import Dict, List\n\n\ndef parse_markdown_titles(markdown: str) -> Dict[str, List[str]]:\n    \"\"\"\n    Parses markdown text to extract titles of different levels.\n\n    This function takes a string of markdown content as input and returns an\n    object containing arrays of titles categorized by their level:\n    level 1 (H1), level 2 (H2), and level 3 (H3).\n\n    Args:\n        markdown (str): A string containing markdown formatted text.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary with three properties: level1, level2, and level3,\n                               each holding a list of corresponding titles found in the markdown.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestParseMarkdownTitles(unittest.TestCase):\n\n    def test_extract_first_second_and_third_level_titles(self):\n        markdown = \"\"\"        \n        # Title 1\n        Content here.\n        ## Subtitle 1.1\n        More content.\n        ### Subsubtitle 1.1.1\n        Even more content.\n        # Title 2\n        Another content.\n        \"\"\"\n        result = parse_markdown_titles(markdown)\n        self.assertEqual(result, {\n            'level1': [\"Title 1\", \"Title 2\"],\n            'level2': [\"Subtitle 1.1\"],\n            'level3': [\"Subsubtitle 1.1.1\"],\n        })\n\n    def test_handle_missing_headers(self):\n        markdown = \"\"\"        \n        This is just some text without headers.\n        \"\"\"\n        result = parse_markdown_titles(markdown)\n        self.assertEqual(result, {\n            'level1': [],\n            'level2': [],\n            'level3': [],\n        })\n\n    def test_handle_only_first_level_headers(self):\n        markdown = \"\"\"        \n        # Only Title 1\n        Content without subtitles.\n\n        # Only Title 2\n        More content.\n        \"\"\"\n        result = parse_markdown_titles(markdown)\n        self.assertEqual(result, {\n            'level1': [\"Only Title 1\", \"Only Title 2\"],\n            'level2': [],\n            'level3': [],\n        })\n\n    def test_handle_mixed_headers_with_empty_lines(self):\n        markdown = \"\"\"        \n        # Title 1\n        ## Subtitle 1.1\n        Some content here.\n        ### Subsubtitle 1.1.1\n\n        # Title 2\n        \"\"\"\n        result = parse_markdown_titles(markdown)\n        self.assertEqual(result, {\n            'level1': [\"Title 1\", \"Title 2\"],\n            'level2': [\"Subtitle 1.1\"],\n            'level3': [\"Subsubtitle 1.1.1\"],\n        })\n\n    def test_handle_headers_with_special_characters(self):\n        markdown = \"\"\"        \n        # Title 1 - Special Characters!\n        ## Subtitle 1.1: The Beginning\n        ### Subsubtitle 1.1.1 (Note)\n        \"\"\"\n        result = parse_markdown_titles(markdown)\n        self.assertEqual(result, {\n            'level1': [\"Title 1 - Special Characters!\"],\n            'level2': [\"Subtitle 1.1: The Beginning\"],\n            'level3': [\"Subsubtitle 1.1.1 (Note)\"],\n        })\n", "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef parse_markdown_titles(markdown: str) -> Dict[str, List[str]]:\n    \"\"\"\n    Parses markdown text to extract titles of different levels.\n\n    This function takes a string of markdown content as input and returns an\n    object containing arrays of titles categorized by their level:\n    level 1 (H1), level 2 (H2), and level 3 (H3).\n\n    Args:\n        markdown (str): A string containing markdown formatted text.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary with three properties: level1, level2, and level3,\n                               each holding a list of corresponding titles found in the markdown.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Parses markdown text to extract titles of different levels.\n *\n * This function takes a string of markdown content as input and returns an\n * object containing arrays of titles categorized by their level:\n * level 1 (H1), level 2 (H2), and level 3 (H3).\n *\n * @param markdown - A string containing markdown formatted text.\n * @returns An unordered_map with three keys: \"level1\", \"level2\", and \"level3\",\n *          each holding a vector of corresponding titles found in the markdown.\n */\nstd::unordered_map<std::string, std::vector<std::string>> parseMarkdownTitles(const std::string& markdown){\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include \"your_header_file.h\" // Replace with the actual header file containing the function\n\nTEST_CASE(\"parseMarkdownTitles\") {\n    SECTION(\"should extract first, second, and third level titles\") {\n        std::string markdown = R\"(\n        # Title 1\n        Content here.\n\n        ## Subtitle 1.1\n        More content.\n\n        ### Subsubtitle 1.1.1\n        Even more content.\n\n        # Title 2\n        Another content.\n        )\";\n\n        auto result = parseMarkdownTitles(markdown);\n        REQUIRE(result[\"level1\"] == std::vector<std::string>{\"Title 1\", \"Title 2\"});\n        REQUIRE(result[\"level2\"] == std::vector<std::string>{\"Subtitle 1.1\"});\n        REQUIRE(result[\"level3\"] == std::vector<std::string>{\"Subsubtitle 1.1.1\"});\n    }\n\n    SECTION(\"should handle missing headers\") {\n        std::string markdown = R\"(\n        This is just some text without headers.\n        )\";\n\n        auto result = parseMarkdownTitles(markdown);\n        REQUIRE(result[\"level1\"].empty());\n        REQUIRE(result[\"level2\"].empty());\n        REQUIRE(result[\"level3\"].empty());\n    }\n\n    SECTION(\"should handle only first-level headers\") {\n        std::string markdown = R\"(\n        # Only Title 1\n        Content without subtitles.\n\n        # Only Title 2\n        More content.\n        )\";\n\n        auto result = parseMarkdownTitles(markdown);\n        REQUIRE(result[\"level1\"] == std::vector<std::string>{\"Only Title 1\", \"Only Title 2\"});\n        REQUIRE(result[\"level2\"].empty());\n        REQUIRE(result[\"level3\"].empty());\n    }\n\n    SECTION(\"should handle mixed headers with empty lines\") {\n        std::string markdown = R\"(\n        # Title 1\n\n        ## Subtitle 1.1\n\n        Some content here.\n\n        ### Subsubtitle 1.1.1\n\n        # Title 2\n        )\";\n\n        auto result = parseMarkdownTitles(markdown);\n        REQUIRE(result[\"level1\"] == std::vector<std::string>{\"Title 1\", \"Title 2\"});\n        REQUIRE(result[\"level2\"] == std::vector<std::string>{\"Subtitle 1.1\"});\n        REQUIRE(result[\"level3\"] == std::vector<std::string>{\"Subsubtitle 1.1.1\"});\n    }\n\n    SECTION(\"should handle headers with special characters\") {\n        std::string markdown = R\"(\n        # Title 1 - Special Characters!\n        ## Subtitle 1.1: The Beginning\n        ### Subsubtitle 1.1.1 (Note)\n        )\";\n\n        auto result = parseMarkdownTitles(markdown);\n        REQUIRE(result[\"level1\"] == std::vector<std::string>{\"Title 1 - Special Characters!\"});\n        REQUIRE(result[\"level2\"] == std::vector<std::string>{\"Subtitle 1.1: The Beginning\"});\n        REQUIRE(result[\"level3\"] == std::vector<std::string>{\"Subsubtitle 1.1.1 (Note)\"});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Parses markdown text to extract titles of different levels.\n *\n * This function takes a string of markdown content as input and returns an\n * object containing arrays of titles categorized by their level:\n * level 1 (H1), level 2 (H2), and level 3 (H3).\n *\n * @param markdown - A string containing markdown formatted text.\n * @returns An unordered_map with three keys: \"level1\", \"level2\", and \"level3\",\n *          each holding a vector of corresponding titles found in the markdown.\n */\nstd::unordered_map<std::string, std::vector<std::string>> parseMarkdownTitles(const std::string& markdown){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Parses markdown text to extract titles of different levels.\n *\n * This function takes a string of markdown content as input and returns an\n * object containing lists of titles categorized by their level:\n * level 1 (H1), level 2 (H2), and level 3 (H3).\n *\n * @param markdown - A string containing markdown formatted text.\n * @return A map with three keys: level1, level2, and level3,\n *         each holding a list of corresponding titles found in the markdown.\n */\npublic static Map<String, List<String>> parseMarkdownTitles(String markdown) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport java.util.List;\nimport java.util.Map;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testExtractFirstSecondAndThirdLevelTitles() {\n        String markdown = \"# Title 1\\n\" +\n                          \"Content here.\\n\\n\" +\n                          \"## Subtitle 1.1\\n\" +\n                          \"More content.\\n\\n\" +\n                          \"### Subsubtitle 1.1.1\\n\" +\n                          \"Even more content.\\n\\n\" +\n                          \"# Title 2\\n\" +\n                          \"Another content.\";\n\n        Map<String, List<String>> result = MarkdownParser.parseMarkdownTitles(markdown);\n\n        assertEquals(List.of(\"Title 1\", \"Title 2\"), result.get(\"level1\"));\n        assertEquals(List.of(\"Subtitle 1.1\"), result.get(\"level2\"));\n        assertEquals(List.of(\"Subsubtitle 1.1.1\"), result.get(\"level3\"));\n    }\n\n    @Test\n    public void testHandleMissingHeaders() {\n        String markdown = \"This is just some text without headers.\";\n\n        Map<String, List<String>> result = MarkdownParser.parseMarkdownTitles(markdown);\n\n        assertEquals(List.of(), result.get(\"level1\"));\n        assertEquals(List.of(), result.get(\"level2\"));\n        assertEquals(List.of(), result.get(\"level3\"));\n    }\n\n    @Test\n    public void testHandleOnlyFirstLevelHeaders() {\n        String markdown = \"# Only Title 1\\n\" +\n                          \"Content without subtitles.\\n\\n\" +\n                          \"# Only Title 2\\n\" +\n                          \"More content.\";\n\n        Map<String, List<String>> result = MarkdownParser.parseMarkdownTitles(markdown);\n\n        assertEquals(List.of(\"Only Title 1\", \"Only Title 2\"), result.get(\"level1\"));\n        assertEquals(List.of(), result.get(\"level2\"));\n        assertEquals(List.of(), result.get(\"level3\"));\n    }\n\n    @Test\n    public void testHandleMixedHeadersWithEmptyLines() {\n        String markdown = \"# Title 1\\n\\n\" +\n                          \"## Subtitle 1.1\\n\\n\" +\n                          \"Some content here.\\n\\n\" +\n                          \"### Subsubtitle 1.1.1\\n\\n\" +\n                          \"# Title 2\\n\";\n\n        Map<String, List<String>> result = MarkdownParser.parseMarkdownTitles(markdown);\n\n        assertEquals(List.of(\"Title 1\", \"Title 2\"), result.get(\"level1\"));\n        assertEquals(List.of(\"Subtitle 1.1\"), result.get(\"level2\"));\n        assertEquals(List.of(\"Subsubtitle 1.1.1\"), result.get(\"level3\"));\n    }\n\n    @Test\n    public void testHandleHeadersWithSpecialCharacters() {\n        String markdown = \"# Title 1 - Special Characters!\\n\" +\n                          \"## Subtitle 1.1: The Beginning\\n\" +\n                          \"### Subsubtitle 1.1.1 (Note)\\n\";\n\n        Map<String, List<String>> result = MarkdownParser.parseMarkdownTitles(markdown);\n\n        assertEquals(List.of(\"Title 1 - Special Characters!\"), result.get(\"level1\"));\n        assertEquals(List.of(\"Subtitle 1.1: The Beginning\"), result.get(\"level2\"));\n        assertEquals(List.of(\"Subsubtitle 1.1.1 (Note)\"), result.get(\"level3\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Parses markdown text to extract titles of different levels.\n *\n * This function takes a string of markdown content as input and returns an\n * object containing lists of titles categorized by their level:\n * level 1 (H1), level 2 (H2), and level 3 (H3).\n *\n * @param markdown - A string containing markdown formatted text.\n * @return A map with three keys: level1, level2, and level3,\n *         each holding a list of corresponding titles found in the markdown.\n */\npublic static Map<String, List<String>> parseMarkdownTitles(String markdown) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 343, "code_type": "method", "original_language": "typescript", "file_path": "dotfiles\\7a8566b217a8d421fad073de95af292c7b4e9c07\\core\\utility\\deepEqual.ts", "question_type": "Algorithm and data structure", "summary": "Compare two objects for equal depth", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 565, "code_type": "method", "original_language": "typescript", "file_path": "galaga\\9e8425f877a2a9b4f5764c934d6ae5db4e07474c\\src\\game\\waves\\paths\\PathFollower.ts\n", "question_type": "Algorithm and data structure", "summary": "Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.", "language_version_list": {"python": {"code_signature": "from typing import List, Dict\n\n\ndef get_bezier_point(t: float, points: List[Dict[str, float]]) -> Dict[str, float]:\n    \"\"\"\n    Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n\n    Args:\n        t(float): A value between 0 and 1 representing the interpolation parameter.\n        points(List[Dict[str, float]]): A list of control points defining the B\u00e9zier curve.\n\n    Returns:\n        The calculated Coordinates at the given parameter t.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestGetBezierPoint(unittest.TestCase):\n\n    # Test case 1: Test with a simple linear curve\n    def test_midpoint_of_two_points(self):\n        points = [{'x': 0, 'y': 0}, {'x': 2, 'y': 2}]\n        result = get_bezier_point(0.5, points)\n        self.assertEqual(result, {'x': 1, 'y': 1})\n\n    # Test case 2: Test with three points (quadratic curve)\n    def test_quadratic_bezier_curve(self):\n        points = [\n            {'x': 0, 'y': 0},\n            {'x': 1, 'y': 2},\n            {'x': 2, 'y': 0}\n        ]\n        result = get_bezier_point(0.5, points)\n        self.assertEqual(result, {'x': 1, 'y': 1})\n\n    # Test case 3: Test with four points (cubic curve)\n    def test_cubic_bezier_curve(self):\n        points = [\n            {'x': 0, 'y': 0},\n            {'x': 1, 'y': 3},\n            {'x': 3, 'y': 1},\n            {'x': 4, 'y': 0}\n        ]\n        result = get_bezier_point(0.5, points)\n        self.assertEqual(result, {'x': 2, 'y': 1.5})\n\n    # Test case 4: Test with a single point (edge case)\n    def test_single_control_point(self):\n        points = [{'x': 5, 'y': 5}]\n        result = get_bezier_point(0.5, points)\n        self.assertEqual(result, {'x': 5, 'y': 5})\n\n    # Test case 5: Test with extreme t value (0)\n    def test_extreme_t_value_zero(self):\n        points = [\n            {'x': 0, 'y': 0},\n            {'x': 5, 'y': 5}\n        ]\n        result = get_bezier_point(0, points)\n        self.assertEqual(result, {'x': 0, 'y': 0})\n\n    # Test case 6: Test with extreme t value (1)\n    def test_extreme_t_value_one(self):\n        points = [\n            {'x': 0, 'y': 0},\n            {'x': 5, 'y': 5}\n        ]\n        result = get_bezier_point(1, points)\n        self.assertEqual(result, {'x': 5, 'y': 5})\n", "prompt": "please write a python function , the function signature as below from typing import List, Dict\n\n\ndef get_bezier_point(t: float, points: List[Dict[str, float]]) -> Dict[str, float]:\n    \"\"\"\n    Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n\n    Args:\n        t(float): A value between 0 and 1 representing the interpolation parameter.\n        points(List[Dict[str, float]]): A list of control points defining the B\u00e9zier curve.\n\n    Returns:\n        The calculated Coordinates at the given parameter t.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n *\n * @param t - A value between 0 and 1 representing the interpolation parameter.\n * @param points - A vector of control points defining the B\u00e9zier curve.\n * @returns The calculated Coordinates at the given parameter t.\n */\nCoordinates getBezierPoint(double t, const std::vector<Coordinates>& points) {\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <vector>\n\nstruct Coordinates {\n    double x;\n    double y;\n};\n\n// Function prototype\nCoordinates getBezierPoint(double t, const std::vector<Coordinates>& points);\n\nTEST_CASE(\"getBezierPoint\", \"[Bezier]\") {\n    // Test case 1: Test with a simple linear curve\n    SECTION(\"should return the midpoint of two points\") {\n        std::vector<Coordinates> points = {{0, 0}, {2, 2}};\n        Coordinates result = getBezierPoint(0.5, points);\n        REQUIRE(result.x == Approx(1));\n        REQUIRE(result.y == Approx(1));\n    }\n\n    // Test case 2: Test with three points (quadratic curve)\n    SECTION(\"should return the correct point on a quadratic B\u00e9zier curve\") {\n        std::vector<Coordinates> points = {{0, 0}, {1, 2}, {2, 0}};\n        Coordinates result = getBezierPoint(0.5, points);\n        REQUIRE(result.x == Approx(1));\n        REQUIRE(result.y == Approx(1));\n    }\n\n    // Test case 3: Test with four points (cubic curve)\n    SECTION(\"should return the correct point on a cubic B\u00e9zier curve\") {\n        std::vector<Coordinates> points = {{0, 0}, {1, 3}, {3, 1}, {4, 0}};\n        Coordinates result = getBezierPoint(0.5, points);\n        REQUIRE(result.x == Approx(2));\n        REQUIRE(result.y == Approx(1.5));\n    }\n\n    // Test case 4: Test with single point (edge case)\n    SECTION(\"should return the only point when there is a single control point\") {\n        std::vector<Coordinates> points = {{5, 5}};\n        Coordinates result = getBezierPoint(0.5, points);\n        REQUIRE(result.x == Approx(5));\n        REQUIRE(result.y == Approx(5));\n    }\n\n    // Test case 5: Test with extreme t value (0)\n    SECTION(\"should return the first control point when t is 0\") {\n        std::vector<Coordinates> points = {{0, 0}, {5, 5}};\n        Coordinates result = getBezierPoint(0, points);\n        REQUIRE(result.x == Approx(0));\n        REQUIRE(result.y == Approx(0));\n    }\n\n    // Test case 6: Test with extreme t value (1)\n    SECTION(\"should return the last control point when t is 1\") {\n        std::vector<Coordinates> points = {{0, 0}, {5, 5}};\n        Coordinates result = getBezierPoint(1, points);\n        REQUIRE(result.x == Approx(5));\n        REQUIRE(result.y == Approx(5));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n *\n * @param t - A value between 0 and 1 representing the interpolation parameter.\n * @param points - A vector of control points defining the B\u00e9zier curve.\n * @returns The calculated Coordinates at the given parameter t.\n */\nCoordinates getBezierPoint(double t, const std::vector<Coordinates>& points) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n *\n * @param t - A value between 0 and 1 representing the interpolation parameter.\n * @param points - An array of control points defining the B\u00e9zier curve.\n * @return The calculated Coordinates at the given parameter t.\n */\nstatic class Coordinates {\n    double x;\n    double y;\n\n    Coordinates(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\npublic static Coordinates getBezierPoint(double t, Coordinates[] points) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    // Test case 1: Test with a simple linear curve\n    @Test\n    public void testMidpointOfTwoPoints() {\n        Coordinates[] points = { new Coordinates(0, 0), new Coordinates(2, 2) };\n        Coordinates result = BezierCurve.getBezierPoint(0.5, points);\n        assertEquals(1.0, result.x, 0.001);\n        assertEquals(1.0, result.y, 0.001);\n    }\n\n    // Test case 2: Test with three points (quadratic curve)\n    @Test\n    public void testQuadraticBezierCurve() {\n        Coordinates[] points = {\n            new Coordinates(0, 0),\n            new Coordinates(1, 2),\n            new Coordinates(2, 0)\n        };\n        Coordinates result = BezierCurve.getBezierPoint(0.5, points);\n        assertEquals(1.0, result.x, 0.001);\n        assertEquals(1.0, result.y, 0.001);\n    }\n\n    // Test case 3: Test with four points (cubic curve)\n    @Test\n    public void testCubicBezierCurve() {\n        Coordinates[] points = {\n            new Coordinates(0, 0),\n            new Coordinates(1, 3),\n            new Coordinates(3, 1),\n            new Coordinates(4, 0)\n        };\n        Coordinates result = BezierCurve.getBezierPoint(0.5, points);\n        assertEquals(2.0, result.x, 0.001);\n        assertEquals(1.5, result.y, 0.001);\n    }\n\n    // Test case 4: Test with single point (edge case)\n    @Test\n    public void testSingleControlPoint() {\n        Coordinates[] points = { new Coordinates(5, 5) };\n        Coordinates result = BezierCurve.getBezierPoint(0.5, points);\n        assertEquals(5.0, result.x, 0.001);\n        assertEquals(5.0, result.y, 0.001);\n    }\n\n    // Test case 5: Test with extreme t value (0)\n    @Test\n    public void testExtremeTValueZero() {\n        Coordinates[] points = {\n            new Coordinates(0, 0),\n            new Coordinates(5, 5)\n        };\n        Coordinates result = BezierCurve.getBezierPoint(0, points);\n        assertEquals(0.0, result.x, 0.001);\n        assertEquals(0.0, result.y, 0.001);\n    }\n\n    // Test case 6: Test with extreme t value (1)\n    @Test\n    public void testExtremeTValueOne() {\n        Coordinates[] points = {\n            new Coordinates(0, 0),\n            new Coordinates(5, 5)\n        };\n        Coordinates result = BezierCurve.getBezierPoint(1, points);\n        assertEquals(5.0, result.x, 0.001);\n        assertEquals(5.0, result.y, 0.001);\n    }\n}package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    // Test case 1: Test with a simple linear curve\n    @Test\n    public void testMidpointOfTwoPoints() {\n        Coordinates[] points = { new Coordinates(0, 0), new Coordinates(2, 2) };\n        Coordinates result = BezierCurve.getBezierPoint(0.5, points);\n        assertEquals(1.0, result.x, 0.001);\n        assertEquals(1.0, result.y, 0.001);\n    }\n\n    // Test case 2: Test with three points (quadratic curve)\n    @Test\n    public void testQuadraticBezierCurve() {\n        Coordinates[] points = {\n            new Coordinates(0, 0),\n            new Coordinates(1, 2),\n            new Coordinates(2, 0)\n        };\n        Coordinates result = BezierCurve.getBezierPoint(0.5, points);\n        assertEquals(1.0, result.x, 0.001);\n        assertEquals(1.0, result.y, 0.001);\n    }\n\n    // Test case 3: Test with four points (cubic curve)\n    @Test\n    public void testCubicBezierCurve() {\n        Coordinates[] points = {\n            new Coordinates(0, 0),\n            new Coordinates(1, 3),\n            new Coordinates(3, 1),\n            new Coordinates(4, 0)\n        };\n        Coordinates result = BezierCurve.getBezierPoint(0.5, points);\n        assertEquals(2.0, result.x, 0.001);\n        assertEquals(1.5, result.y, 0.001);\n    }\n\n    // Test case 4: Test with single point (edge case)\n    @Test\n    public void testSingleControlPoint() {\n        Coordinates[] points = { new Coordinates(5, 5) };\n        Coordinates result = BezierCurve.getBezierPoint(0.5, points);\n        assertEquals(5.0, result.x, 0.001);\n        assertEquals(5.0, result.y, 0.001);\n    }\n\n    // Test case 5: Test with extreme t value (0)\n    @Test\n    public void testExtremeTValueZero() {\n        Coordinates[] points = {\n            new Coordinates(0, 0),\n            new Coordinates(5, 5)\n        };\n        Coordinates result = BezierCurve.getBezierPoint(0, points);\n        assertEquals(0.0, result.x, 0.001);\n        assertEquals(0.0, result.y, 0.001);\n    }\n\n    // Test case 6: Test with extreme t value (1)\n    @Test\n    public void testExtremeTValueOne() {\n        Coordinates[] points = {\n            new Coordinates(0, 0),\n            new Coordinates(5, 5)\n        };\n        Coordinates result = BezierCurve.getBezierPoint(1, points);\n        assertEquals(5.0, result.x, 0.001);\n        assertEquals(5.0, result.y, 0.001);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n *\n * @param t - A value between 0 and 1 representing the interpolation parameter.\n * @param points - An array of control points defining the B\u00e9zier curve.\n * @return The calculated Coordinates at the given parameter t.\n */\nstatic class Coordinates {\n    double x;\n    double y;\n\n    Coordinates(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\npublic static Coordinates getBezierPoint(double t, Coordinates[] points) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 566, "code_type": "method", "original_language": "typescript", "file_path": "whatsapp-clone\\8dc0cd4e5f5e2027a9e4efbce36495c365bfe185\\src\\lib\\utils.ts\n", "question_type": "Algorithm and data structure", "summary": "Checks if two timestamps correspond to the same day.", "language_version_list": {"python": {"code_signature": "def is_same_day(timestamp1: int, timestamp2: int) -> bool:\n    \"\"\"\n    Checks if two timestamps correspond to the same day.\n\n    Args:\n        timestamp1 (int): The first timestamp to compare.\n        timestamp2 (int): The second timestamp to compare.\n\n    Returns:\n        bool: True if both timestamps are on the same day;\n              False otherwise.\n    \"\"\"", "test_code": "import unittest\nfrom datetime import datetime\n\n\nclass TestIsSameDay(unittest.TestCase):\n\n    def test_different_days(self):\n        timestamp1 = int(datetime(2024, 10, 1, 10, 0, 0).timestamp())  # October 1, 2024, 10:00 AM UTC\n        timestamp2 = int(datetime(2024, 10, 2, 10, 0, 0).timestamp())  # October 2, 2024, 10:00 AM UTC\n        self.assertFalse(is_same_day(timestamp1, timestamp2))\n\n    def test_same_day_different_times(self):\n        timestamp1 = int(datetime(2024, 10, 1, 0, 0, 0).timestamp())  # October 1, 2024, 12:00 AM UTC\n        timestamp2 = int(datetime(2024, 10, 1, 12, 30, 0).timestamp())  # October 1, 2024, 12:30 PM UTC\n        self.assertTrue(is_same_day(timestamp1, timestamp2))\n\n    def test_same_day_different_time_zones(self):\n        timestamp1 = int(datetime(2024, 10, 1, 10, 0, 0).timestamp())  # UTC\n        timestamp2 = int(datetime.fromisoformat('2024-10-01T12:00:00+02:00').timestamp())  # October 1, 2024, 12:00 PM UTC+2\n        self.assertTrue(is_same_day(timestamp1, timestamp2))\n\n    def test_midnight_same_day(self):\n        timestamp1 = int(datetime(2024, 10, 1, 0, 0, 0).timestamp())  # October 1, 2024, 12:00 AM UTC\n        timestamp2 = int(datetime(2024, 10, 1, 0, 0, 0).timestamp())  # Same timestamp\n        self.assertTrue(is_same_day(timestamp1, timestamp2))\n\n    def test_different_years(self):\n        timestamp1 = int(datetime(2023, 10, 1, 10, 0, 0).timestamp())  # October 1, 2023, 10:00 AM UTC\n        timestamp2 = int(datetime(2024, 10, 1, 10, 0, 0).timestamp())  # October 1, 2024, 10:00 AM UTC\n        self.assertFalse(is_same_day(timestamp1, timestamp2))\n\n    def test_invalid_timestamps(self):\n        timestamp1 = int(datetime.fromisoformat('invalid').timestamp())  # This will raise an error, so handle it\n        timestamp2 = int(datetime(2024, 10, 1, 10, 0, 0).timestamp())  # Valid timestamp\n        with self.assertRaises(ValueError):\n            is_same_day(timestamp1, timestamp2)\n", "prompt": "please write a python function , the function signature as below def is_same_day(timestamp1: int, timestamp2: int) -> bool:\n    \"\"\"\n    Checks if two timestamps correspond to the same day.\n\n    Args:\n        timestamp1 (int): The first timestamp to compare.\n        timestamp2 (int): The second timestamp to compare.\n\n    Returns:\n        bool: True if both timestamps are on the same day;\n              False otherwise.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Checks if two timestamps correspond to the same day.\n *\n * @param timestamp1 - The first timestamp to compare.\n * @param timestamp2 - The second timestamp to compare.\n * @returns True if both timestamps are on the same day, false otherwise.\n */\nbool isSameDay(std::time_t timestamp1, std::time_t timestamp2) {\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <ctime>\n\n// Function declaration (assuming it is defined elsewhere)\nbool isSameDay(std::time_t timestamp1, std::time_t timestamp2);\n\nTEST_CASE(\"isSameDay\", \"[timestamp]\") {\n    SECTION(\"should return false for timestamps on different days\") {\n        std::time_t timestamp1 = std::mktime(new std::tm{0, 0, 10, 1, 9, 124}); // October 1, 2024, 10:00 AM UTC\n        std::time_t timestamp2 = std::mktime(new std::tm{0, 0, 10, 2, 9, 124}); // October 2, 2024, 10:00 AM UTC\n        REQUIRE(isSameDay(timestamp1, timestamp2) == false);\n    }\n\n    SECTION(\"should return true for timestamps on the same day but different times\") {\n        std::time_t timestamp1 = std::mktime(new std::tm{0, 0, 0, 1, 9, 124}); // October 1, 2024, 12:00 AM UTC\n        std::time_t timestamp2 = std::mktime(new std::tm{0, 30, 12, 1, 9, 124}); // October 1, 2024, 12:30 PM UTC\n        REQUIRE(isSameDay(timestamp1, timestamp2) == true);\n    }\n\n    SECTION(\"should return true for timestamps on the same day in different time zones\") {\n        std::time_t timestamp1 = std::mktime(new std::tm{0, 0, 10, 1, 9, 124}); // UTC\n        std::tm tm = {0};\n        tm.tm_year = 124; // Year 2024\n        tm.tm_mon = 9;    // October\n        tm.tm_mday = 1;   // 1st\n        tm.tm_hour = 12;  // 12 PM\n        tm.tm_min = 0;\n        tm.tm_sec = 0;\n        tm.tm_isdst = 0;  // Not daylight saving time\n        std::time_t timestamp2 = std::mktime(&tm) + 2 * 3600; // UTC+2\n        REQUIRE(isSameDay(timestamp1, timestamp2) == true);\n    }\n\n    SECTION(\"should return true for timestamps at midnight on the same day\") {\n        std::time_t timestamp1 = std::mktime(new std::tm{0, 0, 0, 1, 9, 124}); // October 1, 2024, 12:00 AM UTC\n        std::time_t timestamp2 = std::mktime(new std::tm{0, 0, 0, 1, 9, 124}); // Same timestamp\n        REQUIRE(isSameDay(timestamp1, timestamp2) == true);\n    }\n\n    SECTION(\"should return false for timestamps in different years\") {\n        std::time_t timestamp1 = std::mktime(new std::tm{0, 0, 10, 1, 9, 123}); // October 1, 2023, 10:00 AM UTC\n        std::time_t timestamp2 = std::mktime(new std::tm{0, 0, 10, 1, 9, 124}); // October 1, 2024, 10:00 AM UTC\n        REQUIRE(isSameDay(timestamp1, timestamp2) == false);\n    }\n\n    SECTION(\"should return false for invalid timestamps\") {\n        std::time_t timestamp1 = -1; // Invalid timestamp\n        std::time_t timestamp2 = std::mktime(new std::tm{0, 0, 10, 1, 9, 124}); // Valid timestamp\n        REQUIRE(isSameDay(timestamp1, timestamp2) == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Checks if two timestamps correspond to the same day.\n *\n * @param timestamp1 - The first timestamp to compare.\n * @param timestamp2 - The second timestamp to compare.\n * @returns True if both timestamps are on the same day, false otherwise.\n */\nbool isSameDay(std::time_t timestamp1, std::time_t timestamp2) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks if two timestamps correspond to the same day.\n *\n * @param timestamp1 - The first timestamp to compare.\n * @param timestamp2 - The second timestamp to compare.\n * @return True if both timestamps are on the same day, false otherwise.\n */\npublic static boolean isSameDay(long timestamp1, long timestamp2) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void testDifferentDays() {\n        long timestamp1 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 1, 10, 0, 0)).getTime(); // October 1, 2024, 10:00 AM UTC\n        long timestamp2 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 2, 10, 0, 0)).getTime(); // October 2, 2024, 10:00 AM UTC\n        assertFalse(isSameDay(timestamp1, timestamp2));\n    }\n\n    @Test\n    public void testSameDayDifferentTimes() {\n        long timestamp1 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 1, 0, 0, 0)).getTime(); // October 1, 2024, 12:00 AM UTC\n        long timestamp2 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 1, 12, 30, 0)).getTime(); // October 1, 2024, 12:30 PM UTC\n        assertTrue(isSameDay(timestamp1, timestamp2));\n    }\n\n    @Test\n    public void testSameDayDifferentTimeZones() {\n        long timestamp1 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 1, 10, 0, 0)).getTime(); // UTC\n        long timestamp2 = java.util.Date.parse(\"2024-10-01T12:00:00+02:00\"); // October 1, 2024, 12:00 PM UTC+2\n        assertTrue(isSameDay(timestamp1, timestamp2));\n    }\n\n    @Test\n    public void testMidnightSameDay() {\n        long timestamp1 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 1, 0, 0, 0)).getTime(); // October 1, 2024, 12:00 AM UTC\n        long timestamp2 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 1, 0, 0, 0)).getTime(); // Same timestamp\n        assertTrue(isSameDay(timestamp1, timestamp2));\n    }\n\n    @Test\n    public void testDifferentYears() {\n        long timestamp1 = new java.util.Date(java.util.Date.UTC(2023 - 1900, 9, 1, 10, 0, 0)).getTime(); // October 1, 2023, 10:00 AM UTC\n        long timestamp2 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 1, 10, 0, 0)).getTime(); // October 1, 2024, 10:00 AM UTC\n        assertFalse(isSameDay(timestamp1, timestamp2));\n    }\n\n    @Test\n    public void testInvalidTimestamps() {\n        long timestamp1 = new java.util.Date(\"invalid\").getTime(); // Invalid timestamp\n        long timestamp2 = new java.util.Date(java.util.Date.UTC(2024 - 1900, 9, 1, 10, 0, 0)).getTime(); // Valid timestamp\n        assertFalse(isSameDay(timestamp1, timestamp2));\n    }\n\n    // Assuming isSameDay method is defined elsewhere in this class\n    public static boolean isSameDay(long timestamp1, long timestamp2) {\n        // Implement the isSameDay method logic here\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks if two timestamps correspond to the same day.\n *\n * @param timestamp1 - The first timestamp to compare.\n * @param timestamp2 - The second timestamp to compare.\n * @return True if both timestamps are on the same day, false otherwise.\n */\npublic static boolean isSameDay(long timestamp1, long timestamp2) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 567, "code_type": "method", "original_language": "typescript", "file_path": "whatsapp-clone\\8dc0cd4e5f5e2027a9e4efbce36495c365bfe185\\src\\lib\\utils.ts\n", "question_type": "Data processing and transformation", "summary": "Returns a string of relative times, based on when the given message was created. If the message was created Today: Return \"Today\".\nIf the message was created Yesterday: return \"Yesterday\".\nIf the message was created within the past week but not today or yesterday: Return the corresponding day of the week.\nIf the message was created earlier than one week ago: Return the formatted date string", "language_version_list": {"python": {"code_signature": "from datetime import datetime\n\n\ndef get_relative_time(message_date: datetime) -> str:\n    \"\"\"\n    Returns a string representing the relative time since the given message was created.\n\n    - If the message was created today, it returns \"Today\".\n    - If the message was created yesterday, it returns \"Yesterday\".\n    - If the message was created within the past week (but not today or yesterday),\n      it returns the corresponding day of the week (e.g., \"Monday\").\n    - If the message was created earlier than one week ago, it returns a formatted date string\n      (e.g., \"YYYY/MM/DD\").\n\n    Args:\n        message_date (datetime): The date when the message was created. This should be a valid datetime object.\n\n    Returns:\n        str: A string indicating the relative time from the current date to the message creation date.\n    \"\"\"", "test_code": "import unittest\nfrom datetime import datetime, timedelta\nfrom unittest.mock import patch\n\n\nclass TestGetRelativeTime(unittest.TestCase):\n\n    @patch('datetime.datetime')\n    def setUp(self, mock_datetime):\n        # Mock the current date to ensure consistent test results\n        self.mock_now = datetime(2024, 10, 1)\n        mock_datetime.now.return_value = self.mock_now\n\n    def test_should_return_today_for_a_message_created_today(self):\n        message_date = datetime.now()  # Current date\n        self.assertEqual(get_relative_time(message_date), \"Today\")\n\n    def test_should_return_yesterday_for_a_message_created_yesterday(self):\n        message_date = datetime.now() - timedelta(days=1)  # Yesterday\n        self.assertEqual(get_relative_time(message_date), \"Yesterday\")\n\n    def test_should_return_formatted_date_string_for_a_message_created_10_days_ago(self):\n        message_date = datetime.now() - timedelta(days=10)  # 10 days ago\n        self.assertEqual(get_relative_time(message_date), \"2024/09/21\")  # Adjust based on the mock date\n\n    def test_should_return_formatted_date_string_for_a_message_created_15_days_ago(self):\n        message_date = datetime.now() - timedelta(days=15)  # 15 days ago\n        self.assertEqual(get_relative_time(message_date), \"2024/09/16\")  # Adjust based on the mock date\n", "prompt": "please write a python function , the function signature as below from datetime import datetime\n\n\ndef get_relative_time(message_date: datetime) -> str:\n    \"\"\"\n    Returns a string representing the relative time since the given message was created.\n\n    - If the message was created today, it returns \"Today\".\n    - If the message was created yesterday, it returns \"Yesterday\".\n    - If the message was created within the past week (but not today or yesterday),\n      it returns the corresponding day of the week (e.g., \"Monday\").\n    - If the message was created earlier than one week ago, it returns a formatted date string\n      (e.g., \"YYYY/MM/DD\").\n\n    Args:\n        message_date (datetime): The date when the message was created. This should be a valid datetime object.\n\n    Returns:\n        str: A string indicating the relative time from the current date to the message creation date.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Returns a string representing the relative time since the given message was created.\n *\n * - If the message was created today, it returns \"Today\".\n * - If the message was created yesterday, it returns \"Yesterday\".\n * - If the message was created within the past week (but not today or yesterday),\n *   it returns the corresponding day of the week (e.g., \"Monday\").\n * - If the message was created earlier than one week ago, it returns a formatted date string\n *   (e.g., \"YYYY/MM/DD\").\n *\n * @param messageDate - The date when the message was created. This should be a valid time_point.\n * @returns A string indicating the relative time from the current date to the message creation date.\n */\nstd::string getRelativeTime(const std::chrono::system_clock::time_point& messageDate){\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <chrono>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Assuming getRelativeTime is defined elsewhere\nstd::string getRelativeTime(const std::chrono::system_clock::time_point& messageDate);\n\nTEST_CASE(\"getRelativeTime\", \"[time]\") {\n    // Mock the current date\n    auto mockNow = std::chrono::system_clock::time_point(std::chrono::seconds(1729468800)); // 2024-10-01\n\n    SECTION(\"should return 'Today' for a message created today\") {\n        auto messageDate = mockNow; // Current date\n        REQUIRE(getRelativeTime(messageDate) == \"Today\");\n    }\n\n    SECTION(\"should return 'Yesterday' for a message created yesterday\") {\n        auto messageDate = mockNow - std::chrono::hours(24); // Yesterday\n        REQUIRE(getRelativeTime(messageDate) == \"Yesterday\");\n    }\n\n    SECTION(\"should return formatted date string for a message created 10 days ago\") {\n        auto messageDate = mockNow - std::chrono::hours(24 * 10); // 10 days ago\n        REQUIRE(getRelativeTime(messageDate) == \"2024/09/21\"); // Adjust based on the mock date\n    }\n\n    SECTION(\"should return formatted date string for a message created 15 days ago\") {\n        auto messageDate = mockNow - std::chrono::hours(24 * 15); // 15 days ago\n        REQUIRE(getRelativeTime(messageDate) == \"2024/09/16\"); // Adjust based on the mock date\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Returns a string representing the relative time since the given message was created.\n *\n * - If the message was created today, it returns \"Today\".\n * - If the message was created yesterday, it returns \"Yesterday\".\n * - If the message was created within the past week (but not today or yesterday),\n *   it returns the corresponding day of the week (e.g., \"Monday\").\n * - If the message was created earlier than one week ago, it returns a formatted date string\n *   (e.g., \"YYYY/MM/DD\").\n *\n * @param messageDate - The date when the message was created. This should be a valid time_point.\n * @returns A string indicating the relative time from the current date to the message creation date.\n */\nstd::string getRelativeTime(const std::chrono::system_clock::time_point& messageDate){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Returns a string representing the relative time since the given message was created.\n *\n * - If the message was created today, it returns \"Today\".\n * - If the message was created yesterday, it returns \"Yesterday\".\n * - If the message was created within the past week (but not today or yesterday),\n *   it returns the corresponding day of the week (e.g., \"Monday\").\n * - If the message was created earlier than one week ago, it returns a formatted date string\n *   (e.g., \"YYYY/MM/DD\").\n *\n * @param messageDate - The date when the message was created. This should be a valid Date object.\n * @returns A string indicating the relative time from the current date to the message creation date.\n */\npublic static String getRelativeTime(Date messageDate) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    private final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy/MM/dd\");\n\n    @Before\n    public void setUp() {\n        // Mock the current date to ensure consistent test results\n        // (In Java, we will just set a fixed date in the test cases)\n    }\n\n    @After\n    public void tearDown() {\n        // No specific teardown needed\n    }\n\n    @Test\n    public void testToday() {\n        Date messageDate = new Date(); // Current date\n        assertEquals(\"Today\", DateUtils.getRelativeTime(messageDate));\n    }\n\n    @Test\n    public void testYesterday() {\n        Date messageDate = new Date(System.currentTimeMillis() - 1000 * 60 * 60 * 24); // Yesterday\n        assertEquals(\"Yesterday\", DateUtils.getRelativeTime(messageDate));\n    }\n\n    @Test\n    public void testTenDaysAgo() {\n        Date messageDate = new Date(System.currentTimeMillis() - 1000 * 60 * 60 * 24 * 10); // 10 days ago\n        assertEquals(\"2024/09/21\", DateUtils.getRelativeTime(messageDate)); // Adjust based on the mock date\n    }\n\n    @Test\n    public void testFifteenDaysAgo() {\n        Date messageDate = new Date(System.currentTimeMillis() - 1000 * 60 * 60 * 24 * 15); // 15 days ago\n        assertEquals(\"2024/09/16\", DateUtils.getRelativeTime(messageDate)); // Adjust based on the mock date\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Returns a string representing the relative time since the given message was created.\n *\n * - If the message was created today, it returns \"Today\".\n * - If the message was created yesterday, it returns \"Yesterday\".\n * - If the message was created within the past week (but not today or yesterday),\n *   it returns the corresponding day of the week (e.g., \"Monday\").\n * - If the message was created earlier than one week ago, it returns a formatted date string\n *   (e.g., \"YYYY/MM/DD\").\n *\n * @param messageDate - The date when the message was created. This should be a valid Date object.\n * @returns A string indicating the relative time from the current date to the message creation date.\n */\npublic static String getRelativeTime(Date messageDate) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 569, "code_type": "method", "original_language": "typescript", "file_path": "PandoraBCI\\45580dc8e1b1eba9e1dd4b2fc4d8856b895df4ff\\client\\src\\renderer\\src\\utils\\utils.ts\n", "question_type": "Data processing and transformation", "summary": "Compresses a string to ensure its length does not exceed the specified maximum length.\nIf the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").", "language_version_list": {"python": {"code_signature": "def compress_string(input: str, max_length: int = 18) -> str:\n    \"\"\"\n    Compresses a string to ensure its length does not exceed the specified maximum length.\n    If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n\n    Args:\n        input (str): The string to be compressed.\n        max_length (int, optional): The maximum allowed length of the string (default is 18).\n\n    Returns:\n        str: A compressed string that does not exceed the specified length.\n             If truncation occurs, an ellipsis (\"...\") is appended.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCompressString(unittest.TestCase):\n    def test_short_string(self):\n        \"\"\" should return the original string if it is shorter than the max length \"\"\"\n        input_str = \"Short string\"\n        result = compress_string(input_str)\n        self.assertEqual(result, input_str)\n\n    def test_exact_length_string(self):\n        \"\"\" should return the original string if it is exactly equal to the max length \"\"\"\n        input_str = \"Exactly 18 chars\"\n        result = compress_string(input_str)\n        self.assertEqual(result, input_str)\n\n    def test_truncate_long_string(self):\n        \"\"\" should truncate the string and append \"...\" if it exceeds the max length \"\"\"\n        input_str = \"This is a long string that needs to be compressed.\"\n        result = compress_string(input_str)\n        self.assertEqual(result, \"This is a long ...\")\n\n    def test_truncate_with_custom_max_length(self):\n        \"\"\" should truncate the string to maxLength - 3 and append \"...\" when maxLength is specified \"\"\"\n        input_str = \"Another long string that is definitely too long.\"\n        result = compress_string(input_str, 25)\n        self.assertEqual(result, \"Another long string th...\")\n\n    def test_default_max_length(self):\n        \"\"\" should use default max length of 18 if no maxLength is provided \"\"\"\n        input_str = \"This string is way too long.\"\n        result = compress_string(input_str)\n        self.assertEqual(result, \"This string is ...\")\n\n    def test_empty_string(self):\n        \"\"\" should return the original string if it is empty \"\"\"\n        input_str = \"\"\n        result = compress_string(input_str)\n        self.assertEqual(result, input_str)\n", "prompt": "please write a python function , the function signature as below def compress_string(input: str, max_length: int = 18) -> str:\n    \"\"\"\n    Compresses a string to ensure its length does not exceed the specified maximum length.\n    If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n\n    Args:\n        input (str): The string to be compressed.\n        max_length (int, optional): The maximum allowed length of the string (default is 18).\n\n    Returns:\n        str: A compressed string that does not exceed the specified length.\n             If truncation occurs, an ellipsis (\"...\") is appended.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Compresses a string to ensure its length does not exceed the specified maximum length.\n * If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n *\n * @param input - The string to be compressed.\n * @param maxLength - The maximum allowed length of the string (default is 18).\n * @returns A compressed string that does not exceed the specified length.\n */\nstd::string compressString(const std::string& input, size_t maxLength = 18){\n\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\n// Assuming the compressString function is defined here or included.\n\nTEST_CASE(\"compressString\", \"[compressString]\") {\n\n    SECTION(\"should return the original string if it is shorter than the max length\") {\n        std::string input = \"Short string\";\n        std::string result = compressString(input);\n        REQUIRE(result == input);\n    }\n\n    SECTION(\"should return the original string if it is exactly equal to the max length\") {\n        std::string input = \"Exactly 18 chars\";\n        std::string result = compressString(input);\n        REQUIRE(result == input);\n    }\n\n    SECTION(\"should truncate the string and append '...' if it exceeds the max length\") {\n        std::string input = \"This is a long string that needs to be compressed.\";\n        std::string result = compressString(input);\n        REQUIRE(result == \"This is a long ...\");\n    }\n\n    SECTION(\"should truncate the string to maxLength - 3 and append '...' when maxLength is specified\") {\n        std::string input = \"Another long string that is definitely too long.\";\n        std::string result = compressString(input, 25);\n        REQUIRE(result == \"Another long string th...\");\n    }\n\n    SECTION(\"should use default max length of 18 if no maxLength is provided\") {\n        std::string input = \"This string is way too long.\";\n        std::string result = compressString(input);\n        REQUIRE(result == \"This string is ...\");\n    }\n\n    SECTION(\"should return the original string if it is empty\") {\n        std::string input = \"\";\n        std::string result = compressString(input);\n        REQUIRE(result == input);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Compresses a string to ensure its length does not exceed the specified maximum length.\n * If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n *\n * @param input - The string to be compressed.\n * @param maxLength - The maximum allowed length of the string (default is 18).\n * @returns A compressed string that does not exceed the specified length.\n */\nstd::string compressString(const std::string& input, size_t maxLength = 18){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Compresses a string to ensure its length does not exceed the specified maximum length.\n * If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n *\n * @param input - The string to be compressed.\n * @param maxLength - The maximum allowed length of the string (default is 18).\n * @returns A compressed string that does not exceed the specified length.\n */\npublic static String compressString(String input, int maxLength) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testOriginalStringShorterThanMaxLength() {\n        String input = \"Short string\";\n        String result = StringCompressor.compressString(input);\n        assertEquals(input, result);\n    }\n\n    @Test\n    public void testOriginalStringEqualToMaxLength() {\n        String input = \"Exactly 18 chars\";\n        String result = StringCompressor.compressString(input);\n        assertEquals(input, result);\n    }\n\n    @Test\n    public void testTruncateStringExceedsMaxLength() {\n        String input = \"This is a long string that needs to be compressed.\";\n        String result = StringCompressor.compressString(input);\n        assertEquals(\"This is a long ...\", result);\n    }\n\n    @Test\n    public void testTruncateWithSpecifiedMaxLength() {\n        String input = \"Another long string that is definitely too long.\";\n        String result = StringCompressor.compressString(input, 25);\n        assertEquals(\"Another long string th...\", result);\n    }\n\n    @Test\n    public void testDefaultMaxLength() {\n        String input = \"This string is way too long.\";\n        String result = StringCompressor.compressString(input);\n        assertEquals(\"This string is ...\", result);\n    }\n\n    @Test\n    public void testEmptyString() {\n        String input = \"\";\n        String result = StringCompressor.compressString(input);\n        assertEquals(input, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Compresses a string to ensure its length does not exceed the specified maximum length.\n * If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n *\n * @param input - The string to be compressed.\n * @param maxLength - The maximum allowed length of the string (default is 18).\n * @returns A compressed string that does not exceed the specified length.\n */\npublic static String compressString(String input, int maxLength) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 570, "code_type": "method", "original_language": "typescript", "file_path": "imaginify\\526564d880230c56d30baac6a9e9f7d9745f8efb\\lib\\utils.ts\n", "question_type": "Data processing and transformation", "summary": "Deeply merges two objects.\nIf properties are objects in both objects, they are recursively merged.\nIf a property exists in both objects but is not an object, the value from obj1 is used.", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 571, "code_type": "method", "original_language": "typescript", "file_path": "robotics-orin-gui\\4a94817a4b7996c1878b39b977d14f412f44c262\\src\\app\\coordinate-manager\\coordinate-manager.component.ts\n", "question_type": "Data processing and transformation", "summary": "Checks whether the string conforms to the latitude and longitude identification specification", "language_version_list": {"python": {"code_signature": "def is_valid_coordinate(coord: str) -> bool:\n    \"\"\"\n    Checks if the string conforms to the latitude and longitude identification specification.\n\n    Args:\n        coord: The coordinate string to check (can be latitude or longitude).\n\n    Returns:\n        A boolean indicating whether the coordinate is valid.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsValidCoordinate(unittest.TestCase):\n\n    def test_valid_latitude_with_direction(self):\n        coord = \"45.123N\"\n        self.assertTrue(is_valid_coordinate(coord))\n\n    def test_valid_latitude_without_direction(self):\n        coord = \"90.0\"\n        self.assertTrue(is_valid_coordinate(coord))\n\n    def test_valid_longitude_with_direction(self):\n        coord = \"180.0E\"\n        self.assertTrue(is_valid_coordinate(coord))\n\n    def test_valid_longitude_without_direction(self):\n        coord = \"-120.456\"\n        self.assertTrue(is_valid_coordinate(coord))\n\n    def test_invalid_longitude_exceeding_range(self):\n        coord = \"-200.5\"\n        self.assertFalse(is_valid_coordinate(coord))", "prompt": "please write a python function , the function signature as below def is_valid_coordinate(coord: str) -> bool:\n    \"\"\"\n    Checks if the string conforms to the latitude and longitude identification specification.\n\n    Args:\n        coord: The coordinate string to check (can be latitude or longitude).\n\n    Returns:\n        A boolean indicating whether the coordinate is valid.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Checks if the string conforms to the latitude and longitude identification specification.\n *\n * @param coord - The coordinate string to check (can be latitude or longitude).\n * @returns A boolean indicating whether the coordinate is valid.\n */\nbool isValidCoordinate(const std::string& coord) {\n}", "test_code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <string>\n\n// Assume isValidCoordinate is defined elsewhere\n\nTEST_CASE(\"isValidCoordinate\") {\n    SECTION(\"valid latitude with direction\") {\n        std::string coord = \"45.123N\";\n        REQUIRE(isValidCoordinate(coord) == true);\n    }\n\n    SECTION(\"valid latitude without direction\") {\n        std::string coord = \"90.0\";\n        REQUIRE(isValidCoordinate(coord) == true);\n    }\n\n    SECTION(\"valid longitude with direction\") {\n        std::string coord = \"180.0E\";\n        REQUIRE(isValidCoordinate(coord) == true);\n    }\n\n    SECTION(\"valid longitude without direction\") {\n        std::string coord = \"-120.456\";\n        REQUIRE(isValidCoordinate(coord) == true);\n    }\n\n    SECTION(\"invalid longitude exceeding range\") {\n        std::string coord = \"-200.5\";\n        REQUIRE(isValidCoordinate(coord) == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Checks if the string conforms to the latitude and longitude identification specification.\n *\n * @param coord - The coordinate string to check (can be latitude or longitude).\n * @returns A boolean indicating whether the coordinate is valid.\n */\nbool isValidCoordinate(const std::string& coord) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks if the string conforms to the latitude and longitude identification specification.\n *\n * @param coord - The coordinate string to check (can be latitude or longitude).\n * @returns A boolean indicating whether the coordinate is valid.\n */\npublic static boolean isValidCoordinate(String coord) {\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\npublic class Tester {\n\n    @Test\n    public void testValidLatitudeWithDirection() {\n        String coord = \"45.123N\";\n        assertTrue(CoordinateValidator.isValidCoordinate(coord));\n    }\n\n    @Test\n    public void testValidLatitudeWithoutDirection() {\n        String coord = \"90.0\";\n        assertTrue(CoordinateValidator.isValidCoordinate(coord));\n    }\n\n    @Test\n    public void testValidLongitudeWithDirection() {\n        String coord = \"180.0E\";\n        assertTrue(CoordinateValidator.isValidCoordinate(coord));\n    }\n\n    @Test\n    public void testValidLongitudeWithoutDirection() {\n        String coord = \"-120.456\";\n        assertTrue(CoordinateValidator.isValidCoordinate(coord));\n    }\n\n    @Test\n    public void testInvalidLongitudeExceedingRange() {\n        String coord = \"-200.5\";\n        assertFalse(CoordinateValidator.isValidCoordinate(coord));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks if the string conforms to the latitude and longitude identification specification.\n *\n * @param coord - The coordinate string to check (can be latitude or longitude).\n * @returns A boolean indicating whether the coordinate is valid.\n */\npublic static boolean isValidCoordinate(String coord) {\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 572, "code_type": "method", "original_language": "typescript", "file_path": "llm-functions\\df7bdff7ab44093528b213b391698f00b7d0232e\\packages\\llm-functions\\src\\utils.ts\n", "question_type": "Data processing and transformation", "summary": "Merges two arrays of objects, updating items in the first array with items\nfrom the second array based on a unique identifier. If an ID exists in both\narrays, the item from the second array will replace the one in the first.", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 575, "code_type": "method", "original_language": "typescript", "file_path": "zooma-web-app\\d356bce6089cd221aae683e40251c24166cbc5ff\\lib\\utils.ts\n", "question_type": "Data processing and transformation", "summary": "Formats the thread count into a user-friendly string.", "language_version_list": {"python": {"code_signature": "def format_thread_count(count: int) -> str:\n    \"\"\"\n    Formats the thread count into a user-friendly string.\n\n    The function formats the number of threads into a two-digit string\n    followed by \"Thread\" or \"Threads\" based on the count.\n\n    For example:\n        - Input: 3  Output: \"03 Threads\"\n        - Input: 1  Output: \"01 Thread\"\n\n    Args:\n        count (int): The number of threads.\n\n    Returns:\n        str: A formatted string indicating the number of threads.\n             The string will be in the format \"XX Thread\" or \"XX Threads\",\n             where XX is the count formatted as a two-digit number.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFormatThreadCount(unittest.TestCase):\n\n    def test_count_of_one(self):\n        \"\"\"should return '01 Thread' for a count of 1\"\"\"\n        self.assertEqual(format_thread_count(1), \"01 Thread\")\n\n    def test_count_of_five(self):\n        \"\"\"should return '05 Threads' for a count of 5\"\"\"\n        self.assertEqual(format_thread_count(5), \"05 Threads\")\n\n    def test_count_of_ten(self):\n        \"\"\"should return '10 Threads' for a count of 10\"\"\"\n        self.assertEqual(format_thread_count(10), \"10 Threads\")\n\n    def test_count_of_ninety_nine(self):\n        \"\"\"should return '99 Threads' for a count of 99\"\"\"\n        self.assertEqual(format_thread_count(99), \"99 Threads\")", "prompt": "please write a python function , the function signature as below def format_thread_count(count: int) -> str:\n    \"\"\"\n    Formats the thread count into a user-friendly string.\n\n    The function formats the number of threads into a two-digit string\n    followed by \"Thread\" or \"Threads\" based on the count.\n\n    For example:\n        - Input: 3  Output: \"03 Threads\"\n        - Input: 1  Output: \"01 Thread\"\n\n    Args:\n        count (int): The number of threads.\n\n    Returns:\n        str: A formatted string indicating the number of threads.\n             The string will be in the format \"XX Thread\" or \"XX Threads\",\n             where XX is the count formatted as a two-digit number.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Formats the thread count into a user-friendly string.\n * For example:\n *      input: 3 output: 03 Threads\n *      input: 1 output: 01 Thread\n *\n * @param count - The number of threads.\n * @returns A formatted string indicating the number of threads.\n */\nstd::string formatThreadCount(int count) {}", "test_code": "TEST_CASE(\"formatThreadCount\", \"[formatThreadCount]\") {\n    REQUIRE(formatThreadCount(1) == \"01 Thread\");\n    REQUIRE(formatThreadCount(5) == \"05 Threads\");\n    REQUIRE(formatThreadCount(10) == \"10 Threads\");\n    REQUIRE(formatThreadCount(99) == \"99 Threads\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Formats the thread count into a user-friendly string.\n * For example:\n *      input: 3 output: 03 Threads\n *      input: 1 output: 01 Thread\n *\n * @param count - The number of threads.\n * @returns A formatted string indicating the number of threads.\n */\nstd::string formatThreadCount(int count) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Formats the thread count into a user-friendly string.\n * For example:\n *      input: 3 output: 03 Threads\n *      input: 1 output: 01 Thread\n *\n * @param count - The number of threads.\n * @return - A formatted string indicating the number of threads.\n */\npublic String formatThreadCount(int count) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testFormatThreadCountForOne() {\n        assertEquals(\"01 Thread\", formatThreadCount(1));\n    }\n\n    @Test\n    public void testFormatThreadCountForFive() {\n        assertEquals(\"05 Threads\", formatThreadCount(5));\n    }\n\n    @Test\n    public void testFormatThreadCountForTen() {\n        assertEquals(\"10 Threads\", formatThreadCount(10));\n    }\n\n    @Test\n    public void testFormatThreadCountForNinetyNine() {\n        assertEquals(\"99 Threads\", formatThreadCount(99));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Formats the thread count into a user-friendly string.\n * For example:\n *      input: 3 output: 03 Threads\n *      input: 1 output: 01 Thread\n *\n * @param count - The number of threads.\n * @return - A formatted string indicating the number of threads.\n */\npublic String formatThreadCount(int count) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 576, "code_type": "method", "original_language": "typescript", "file_path": "TOFI\\5cb1997367d0a61c7f01764b81452a14a29b988e\\banking-app\\lib\\utils.ts\n", "question_type": "Data processing and transformation", "summary": "Hides the sensitive part of a bank account number with 17 characters only show the last 4 characters.", "language_version_list": {"python": {"code_signature": "def hide_bank_account(account: str) -> str:\n    \"\"\"\n    Hides the sensitive part of a bank account number with 17 digits, showing only the last 4 characters.\n\n    For example:\n        - Input: 12345678901234567\n        - Output: ****4567\n\n    Args:\n        account (str): The bank account number to hide. This must be exactly 17 characters long.\n\n    Returns:\n        str: The bank account number with the first part hidden, formatted as \"****XXXX\",\n             where \"XXXX\" are the last four digits of the account.\n\n    Raises:\n        ValueError: If the account number is not exactly 17 characters long.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestHideBankAccount(unittest.TestCase):\n    def test_should_return_hidden_part_for_valid_account(self):\n        self.assertEqual(hide_bank_account('12345678901234567'), '****4567')\n\n    def test_should_return_hidden_part_for_another_valid_account(self):\n        self.assertEqual(hide_bank_account('98765432109876543'), '****6543')\n\n    def test_should_return_hidden_part_for_yet_another_valid_account(self):\n        self.assertEqual(hide_bank_account('11111111111111100'), '****1100')\n\n    def test_should_throw_error_for_shorter_account(self):\n        with self.assertRaises(Exception):\n            hide_bank_account('1234567890123456')\n\n    def test_should_throw_error_for_longer_account(self):\n        with self.assertRaises(Exception):\n            hide_bank_account('123456789012345678')\n\n    def test_should_throw_error_for_empty_account(self):\n        with self.assertRaises(Exception):\n            hide_bank_account('')\n", "prompt": "please write a python function , the function signature as below def hide_bank_account(account: str) -> str:\n    \"\"\"\n    Hides the sensitive part of a bank account number with 17 digits, showing only the last 4 characters.\n\n    For example:\n        - Input: 12345678901234567\n        - Output: ****4567\n\n    Args:\n        account (str): The bank account number to hide. This must be exactly 17 characters long.\n\n    Returns:\n        str: The bank account number with the first part hidden, formatted as \"****XXXX\",\n             where \"XXXX\" are the last four digits of the account.\n\n    Raises:\n        ValueError: If the account number is not exactly 17 characters long.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Hides the sensitive part of a bank account number with 17 numbers, only showing the last 4 characters.\n * For example:\n *      input: 12345678901234567\n *      output: ****4567\n * @param account - The bank account number to hide.\n * @returns The bank account number with the first part hidden.\n * @throws std::invalid_argument - Throws an error if the account number is not exactly 17 characters long.\n */\nstd::string hideBankAccount(const std::string& account){}", "test_code": "TEST_CASE(\"hideBankAccount\", \"[hideBankAccount]\") {\n    SECTION(\"should return \\\"****4567\\\" for an account number of \\\"12345678901234567\\\"\") {\n        REQUIRE(hideBankAccount(\"12345678901234567\") == \"****4567\");\n    }\n\n    SECTION(\"should return \\\"****6543\\\" for an account number of \\\"98765432109876543\\\"\") {\n        REQUIRE(hideBankAccount(\"98765432109876543\") == \"****6543\");\n    }\n\n    SECTION(\"should return \\\"****1100\\\" for an account number of \\\"11111111111111100\\\"\") {\n        REQUIRE(hideBankAccount(\"11111111111111100\") == \"****1100\");\n    }\n\n    SECTION(\"should throw an error for an account number shorter than 17 characters\") {\n        REQUIRE_THROWS_AS(hideBankAccount(\"1234567890123456\"), std::invalid_argument);\n    }\n\n    SECTION(\"should throw an error for an account number longer than 17 characters\") {\n        REQUIRE_THROWS_AS(hideBankAccount(\"123456789012345678\"), std::invalid_argument);\n    }\n\n    SECTION(\"should throw an error for an account number with 0 characters\") {\n        REQUIRE_THROWS_AS(hideBankAccount(\"\"), std::invalid_argument);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Hides the sensitive part of a bank account number with 17 numbers, only showing the last 4 characters.\n * For example:\n *      input: 12345678901234567\n *      output: ****4567\n * @param account - The bank account number to hide.\n * @returns The bank account number with the first part hidden.\n * @throws std::invalid_argument - Throws an error if the account number is not exactly 17 characters long.\n */\nstd::string hideBankAccount(const std::string& account){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Hides the sensitive part of a bank account number with 17 numbers, only showing the last 4 characters.\n * For example:\n *      input: 12345678901234567\n *      output: ****4567\n * @param account The bank account number to hide.\n * @return The bank account number with the first part hidden.\n * @throws IllegalArgumentException Throws an exception if the account number is not exactly 17 characters long.\n */\npublic static String hideBankAccount(String account) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void testHideBankAccountValidCases() {\n        assertEquals(\"****4567\", BankAccountHider.hideBankAccount(\"12345678901234567\"));\n        assertEquals(\"****6543\", BankAccountHider.hideBankAccount(\"98765432109876543\"));\n        assertEquals(\"****1100\", BankAccountHider.hideBankAccount(\"11111111111111100\"));\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testHideBankAccountShorterThan17Characters() {\n        BankAccountHider.hideBankAccount(\"1234567890123456\");\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testHideBankAccountLongerThan17Characters() {\n        BankAccountHider.hideBankAccount(\"123456789012345678\");\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testHideBankAccountWithZeroCharacters() {\n        BankAccountHider.hideBankAccount(\"\");\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Hides the sensitive part of a bank account number with 17 numbers, only showing the last 4 characters.\n * For example:\n *      input: 12345678901234567\n *      output: ****4567\n * @param account The bank account number to hide.\n * @return The bank account number with the first part hidden.\n * @throws IllegalArgumentException Throws an exception if the account number is not exactly 17 characters long.\n */\npublic static String hideBankAccount(String account) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 577, "code_type": "method", "original_language": "typescript", "file_path": "TellUs-A-Social-Media-App\\2b53050016fc355d319d74fef9223965707a820f\\lib\\utils.ts\n", "question_type": "Data processing and transformation", "summary": "Formats the post count into a human-readable string.", "language_version_list": {"python": {"code_signature": "def format_post_count(count: int) -> str:\n    \"\"\"\n    Formats the post count into a human-readable string.\n\n    The function formats the number of posts into a two-digit string\n    followed by \"Post\" or \"Posts\" based on the count.\n\n    For example:\n        - Input: 3  Output: \"02 Posts\"\n        - Input: 1  Output: \"01 Post\"\n\n    Args:\n        count (int): The number of posts.\n\n    Returns:\n        str: A formatted string indicating the number of posts.\n             The string will be in the format \"XX Post\" or \"XX Posts\",\n             where XX is the count formatted as a two-digit number.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFormatPostCount(unittest.TestCase):\n\n    def test_return_one_post(self):\n        \"\"\"Should return \"01 Post\" for count of 1.\"\"\"\n        self.assertEqual(format_post_count(1), \"01 Post\")\n\n    def test_return_two_posts(self):\n        \"\"\"Should return \"02 Posts\" for count of 2.\"\"\"\n        self.assertEqual(format_post_count(2), \"02 Posts\")\n\n    def test_return_ten_posts(self):\n        \"\"\"Should return \"10 Posts\" for count of 10.\"\"\"\n        self.assertEqual(format_post_count(10), \"10 Posts\")\n\n    def test_return_ninety_nine_posts(self):\n        \"\"\"Should return \"99 Posts\" for count of 99.\"\"\"\n        self.assertEqual(format_post_count(99), \"99 Posts\")\n\n    def test_return_five_posts(self):\n        \"\"\"Should return \"05 Posts\" for count of 5.\"\"\"\n        self.assertEqual(format_post_count(5), \"05 Posts\")\n", "prompt": "please write a python function , the function signature as below def format_post_count(count: int) -> str:\n    \"\"\"\n    Formats the post count into a human-readable string.\n\n    The function formats the number of posts into a two-digit string\n    followed by \"Post\" or \"Posts\" based on the count.\n\n    For example:\n        - Input: 3  Output: \"02 Posts\"\n        - Input: 1  Output: \"01 Post\"\n\n    Args:\n        count (int): The number of posts.\n\n    Returns:\n        str: A formatted string indicating the number of posts.\n             The string will be in the format \"XX Post\" or \"XX Posts\",\n             where XX is the count formatted as a two-digit number.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Formats the post count into a human-readable string.\n * For example:\n *      input: 3 output: 02 Posts\n *      input: 1 output: 01 Post\n *\n * @param count - The number of posts.\n * @returns A formatted string indicating the number of posts.\n */\nstd::string formatPostCount(int count) {}", "test_code": "TEST_CASE(\"formatPostCount\", \"[formatPostCount]\") {\n    REQUIRE(formatPostCount(1) == \"01 Post\");\n    REQUIRE(formatPostCount(2) == \"02 Posts\");\n    REQUIRE(formatPostCount(10) == \"10 Posts\");\n    REQUIRE(formatPostCount(99) == \"99 Posts\");\n    REQUIRE(formatPostCount(5) == \"05 Posts\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Formats the post count into a human-readable string.\n * For example:\n *      input: 3 output: 02 Posts\n *      input: 1 output: 01 Post\n *\n * @param count - The number of posts.\n * @returns A formatted string indicating the number of posts.\n */\nstd::string formatPostCount(int count) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Formats the post count into a human-readable string.\n * For example:\n *      input: 3 output: 02 Posts\n *      input: 1 output: 01 Post\n *\n * @param count - The number of posts.\n * @return - A formatted string indicating the number of posts.\n */\npublic static String formatPostCount(int count) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testFormatPostCount_SinglePost() {\n        assertEquals(\"01 Post\", formatPostCount(1));\n    }\n\n    @Test\n    public void testFormatPostCount_TwoPosts() {\n        assertEquals(\"02 Posts\", formatPostCount(2));\n    }\n\n    @Test\n    public void testFormatPostCount_TenPosts() {\n        assertEquals(\"10 Posts\", formatPostCount(10));\n    }\n\n    @Test\n    public void testFormatPostCount_NinetyNinePosts() {\n        assertEquals(\"99 Posts\", formatPostCount(99));\n    }\n\n    @Test\n    public void testFormatPostCount_FivePosts() {\n        assertEquals(\"05 Posts\", formatPostCount(5));\n    }\n    }", "prompt": "please write a java function , the function signature as below /**\n * Formats the post count into a human-readable string.\n * For example:\n *      input: 3 output: 02 Posts\n *      input: 1 output: 01 Post\n *\n * @param count - The number of posts.\n * @return - A formatted string indicating the number of posts.\n */\npublic static String formatPostCount(int count) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 578, "code_type": "method", "original_language": "typescript", "file_path": "js-analyzer\\a9fd8d479f54079cb5ea24cf15d163a33e9bca5e\\src\\common\\constants\\index.ts\n", "question_type": "Data processing and transformation", "summary": "Detects whether the string is KEBAB_CASE", "language_version_list": {"python": {"code_signature": "def is_kebab_case(input: str) -> bool:\n    \"\"\"\n    Detects whether the string is in KEBAB_CASE.\n\n    KEBAB_CASE is defined as a string that:\n    - Contains only lowercase letters (a-z).\n    - May contain digits (0-9).\n    - Uses hyphens (-) as word separators.\n    - Does not start or end with a hyphen.\n    - Does not contain consecutive hyphens.\n\n    Args:\n        input (str): The string to check.\n\n    Returns:\n        bool: True if the string is in KEBAB_CASE, otherwise False.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsKebabCase(unittest.TestCase):\n\n    def test_valid_kebab_case(self):\n        \"\"\"Should return True for a valid kebab-case string.\"\"\"\n        self.assertTrue(is_kebab_case('kebab-case'))\n\n    def test_valid_kebab_case_multiple_words(self):\n        \"\"\"Should return True for a valid kebab-case string with multiple words.\"\"\"\n        self.assertTrue(is_kebab_case('this-is-a-valid-kebab-case'))\n\n    def test_uppercase_letters(self):\n        \"\"\"Should return False for a string with uppercase letters.\"\"\"\n        self.assertFalse(is_kebab_case('Kebab-Case'))\n\n    def test_consecutive_hyphens(self):\n        \"\"\"Should return False for a string with consecutive hyphens.\"\"\"\n        self.assertFalse(is_kebab_case('kebab--case'))\n\n    def test_empty_string(self):\n        \"\"\"Should return False for an empty string.\"\"\"\n        self.assertFalse(is_kebab_case(''))\n", "prompt": "please write a python function , the function signature as below def is_kebab_case(input: str) -> bool:\n    \"\"\"\n    Detects whether the string is in KEBAB_CASE.\n\n    KEBAB_CASE is defined as a string that:\n    - Contains only lowercase letters (a-z).\n    - May contain digits (0-9).\n    - Uses hyphens (-) as word separators.\n    - Does not start or end with a hyphen.\n    - Does not contain consecutive hyphens.\n\n    Args:\n        input (str): The string to check.\n\n    Returns:\n        bool: True if the string is in KEBAB_CASE, otherwise False.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Detects whether the string is in KEBAB_CASE.\n *\n * @param input - The string to check.\n * @returns True if the string is in KEBAB_CASE, otherwise false.\n */\nbool isKebabCase(const std::string& input){}", "test_code": "TEST_CASE(\"isKebabCase\", \"[kebab-case]\") {\n    SECTION(\"should return true for a valid kebab-case string\") {\n        REQUIRE(isKebabCase(\"kebab-case\") == true);\n    }\n\n    SECTION(\"should return true for a valid kebab-case string with multiple words\") {\n        REQUIRE(isKebabCase(\"this-is-a-valid-kebab-case\") == true);\n    }\n\n    SECTION(\"should return false for a string with uppercase letters\") {\n        REQUIRE(isKebabCase(\"Kebab-Case\") == false);\n    }\n\n    SECTION(\"should return false for a string with consecutive hyphens\") {\n        REQUIRE(isKebabCase(\"kebab--case\") == false);\n    }\n\n    SECTION(\"should return false for an empty string\") {\n        REQUIRE(isKebabCase(\"\") == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Detects whether the string is in KEBAB_CASE.\n *\n * @param input - The string to check.\n * @returns True if the string is in KEBAB_CASE, otherwise false.\n */\nbool isKebabCase(const std::string& input){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Detects whether the string is in KEBAB_CASE.\n *\n * @param input - The string to check.\n * @returns True if the string is in KEBAB_CASE, otherwise false.\n */\npublic boolean isKebabCase(String input) {\n    // Regular expression to match KEBAB_CASE\n    String kebabCaseRegex = \"^[a-z]+(-[a-z]+)*$\";\n    return input.matches(kebabCaseRegex);\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void testValidKebabCase() {\n        assertTrue(isKebabCase(\"kebab-case\"));\n    }\n\n    @Test\n    public void testValidKebabCaseWithMultipleWords() {\n        assertTrue(isKebabCase(\"this-is-a-valid-kebab-case\"));\n    }\n\n    @Test\n    public void testUppercaseLetters() {\n        assertFalse(isKebabCase(\"Kebab-Case\"));\n    }\n\n    @Test\n    public void testConsecutiveHyphens() {\n        assertFalse(isKebabCase(\"kebab--case\"));\n    }\n\n    @Test\n    public void testEmptyString() {\n        assertFalse(isKebabCase(\"\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Detects whether the string is in KEBAB_CASE.\n *\n * @param input - The string to check.\n * @returns True if the string is in KEBAB_CASE, otherwise false.\n */\npublic boolean isKebabCase(String input) {\n    // Regular expression to match KEBAB_CASE\n    String kebabCaseRegex = \"^[a-z]+(-[a-z]+)*$\";\n    return input.matches(kebabCaseRegex);\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 581, "code_type": "method", "original_language": "typescript", "file_path": "HASH\\596ee9a6b87e3c1f2c8fb53bef44e3ffbf93e238\\client\\app\\lib\\utils.ts\n", "question_type": "Data processing and transformation", "summary": "Abbreviates a number to a string with a suffix based on its magnitude.", "language_version_list": {"python": {"code_signature": "def abbreviate_number(number: float) -> str:\n    \"\"\"\n    Abbreviates a number to a string with a suffix based on its magnitude.\n\n    The function uses the following suffixes based on the number's magnitude:\n    - \"\" (no suffix) for values less than 1,000\n    - \"k\" for thousands (1,000)\n    - \"M\" for millions (1,000,000)\n    - \"B\" for billions (1,000,000,000)\n    - \"T\" for trillions (1,000,000,000,000)\n\n    For example:\n        - Input: 999             Output: \"999\"\n        - Input: 1549            Output: \"1.5k\"\n        - Input: 1000            Output: \"1k\"\n        - Input: 1234567890123   Output: \"1.2T\"\n\n    Args:\n        number (float): The number to abbreviate.\n\n    Returns:\n        str: The abbreviated string representation of the number.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestAbbreviateNumber(unittest.TestCase):\n\n    def test_less_than_1000(self):\n        # should return the same number for values less than 1000\n        self.assertEqual(abbreviate_number(999), '999')\n\n    def test_one_thousand(self):\n        # should return \"1k\" for 1000\n        result = abbreviate_number(1000)\n        self.assertIn(result, ['1k', '1.0k'])\n\n    def test_one_thousand_five_hundred(self):\n        # should return \"1.5k\" for 1500\n        self.assertEqual(abbreviate_number(1500), '1.5k')\n\n    def test_one_million(self):\n        # should return \"1M\" for 1 million\n        result = abbreviate_number(1000000)\n        self.assertIn(result, ['1M', '1.0M'])\n\n    def test_twenty_five_million(self):\n        # should return \"25M\" for 25 million\n        self.assertEqual(abbreviate_number(25000000), '25M')\n\n    def test_one_billion(self):\n        # should return \"1B\" for 1 billion\n        result = abbreviate_number(1000000000)\n        self.assertIn(result, ['1B', '1.0B'])\n\n    def test_one_point_two_trillion(self):\n        # should return \"1.2T\" for 1.2 trillion\n        self.assertEqual(abbreviate_number(1234567890123), '1.2T')\n", "prompt": "please write a python function , the function signature as below def abbreviate_number(number: float) -> str:\n    \"\"\"\n    Abbreviates a number to a string with a suffix based on its magnitude.\n\n    The function uses the following suffixes based on the number's magnitude:\n    - \"\" (no suffix) for values less than 1,000\n    - \"k\" for thousands (1,000)\n    - \"M\" for millions (1,000,000)\n    - \"B\" for billions (1,000,000,000)\n    - \"T\" for trillions (1,000,000,000,000)\n\n    For example:\n        - Input: 999             Output: \"999\"\n        - Input: 1549            Output: \"1.5k\"\n        - Input: 1000            Output: \"1k\"\n        - Input: 1234567890123   Output: \"1.2T\"\n\n    Args:\n        number (float): The number to abbreviate.\n\n    Returns:\n        str: The abbreviated string representation of the number.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Abbreviates a number to a string with a suffix based on its magnitude. \n * Suffixes: [\"\", \"k\", \"M\", \"B\", \"T\"] \n * 1000 is k, 1000000 is M, 1000000000 is B.\n * For example:\n *      input: 999 output: 999\n *      input: 1549 output: 1.5k\n *      input: 1000 output: 1k\n *      input: 1234567890123 output: 1.2T\n * @param number - The number to abbreviate.\n * @return The abbreviated string representation of the number.\n */\nstd::string abbreviateNumber(double number){}", "test_code": "TEST_CASE(\"abbreviateNumber\") {\n    SECTION(\"should return the same number for values less than 1000\") {\n        REQUIRE(abbreviateNumber(999) == \"999\");\n    }\n\n    SECTION(\"should return '1k' for 1000\") {\n        std::string result = abbreviateNumber(1000);\n        REQUIRE(result == \"1k\" || result == \"1.0k\");\n    }\n\n    SECTION(\"should return '1.5k' for 1500\") {\n        REQUIRE(abbreviateNumber(1500) == \"1.5k\");\n    }\n\n    SECTION(\"should return '1M' for 1 million\") {\n        std::string result = abbreviateNumber(1000000);\n        REQUIRE(result == \"1M\" || result == \"1.0M\");\n    }\n\n    SECTION(\"should return '25M' for 25 million\") {\n        REQUIRE(abbreviateNumber(25000000) == \"25M\");\n    }\n\n    SECTION(\"should return '1B' for 1 billion\") {\n        std::string result = abbreviateNumber(1000000000);\n        REQUIRE(result == \"1B\" || result == \"1.0B\");\n    }\n\n    SECTION(\"should return '1.2T' for 1.2 trillion\") {\n        REQUIRE(abbreviateNumber(1234567890123) == \"1.2T\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Abbreviates a number to a string with a suffix based on its magnitude. \n * Suffixes: [\"\", \"k\", \"M\", \"B\", \"T\"] \n * 1000 is k, 1000000 is M, 1000000000 is B.\n * For example:\n *      input: 999 output: 999\n *      input: 1549 output: 1.5k\n *      input: 1000 output: 1k\n *      input: 1234567890123 output: 1.2T\n * @param number - The number to abbreviate.\n * @return The abbreviated string representation of the number.\n */\nstd::string abbreviateNumber(double number){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Abbreviates a number to a string with a suffix based on its magnitude. \n * Suffix [\"\", \"k\", \"M\", \"B\", \"T\"]; 1000 is k, 1000000 is M, 1000000000 is B.\n * For example:\n *      input: 999 output: 999\n *      input: 1549 output: 1.5k\n *      input: 1000 output: 1k\n *      input: 1234567890123 output: 1.2T\n * @param number - The number to abbreviate.\n * @return - The abbreviated string representation of the number.\n */\npublic static String abbreviateNumber(double number) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void testAbbreviateNumber_LessThan1000() {\n        assertEquals(\"999\", NumberAbbreviator.abbreviateNumber(999));\n    }\n\n    @Test\n    public void testAbbreviateNumber_Exactly1000() {\n        String result = NumberAbbreviator.abbreviateNumber(1000);\n        assertTrue(result.equals(\"1k\") || result.equals(\"1.0k\"));\n    }\n\n    @Test\n    public void testAbbreviateNumber_1500() {\n        assertEquals(\"1.5k\", NumberAbbreviator.abbreviateNumber(1500));\n    }\n\n    @Test\n    public void testAbbreviateNumber_OneMillion() {\n        String result = NumberAbbreviator.abbreviateNumber(1000000);\n        assertTrue(result.equals(\"1M\") || result.equals(\"1.0M\"));\n    }\n\n    @Test\n    public void testAbbreviateNumber_TwentyFiveMillion() {\n        assertEquals(\"25M\", NumberAbbreviator.abbreviateNumber(25000000));\n    }\n\n    @Test\n    public void testAbbreviateNumber_OneBillion() {\n        String result = NumberAbbreviator.abbreviateNumber(1000000000);\n        assertTrue(result.equals(\"1B\") || result.equals(\"1.0B\"));\n    }\n\n    @Test\n    public void testAbbreviateNumber_OnePointTwoTrillion() {\n        assertEquals(\"1.2T\", NumberAbbreviator.abbreviateNumber(1234567890123));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Abbreviates a number to a string with a suffix based on its magnitude. \n * Suffix [\"\", \"k\", \"M\", \"B\", \"T\"]; 1000 is k, 1000000 is M, 1000000000 is B.\n * For example:\n *      input: 999 output: 999\n *      input: 1549 output: 1.5k\n *      input: 1000 output: 1k\n *      input: 1234567890123 output: 1.2T\n * @param number - The number to abbreviate.\n * @return - The abbreviated string representation of the number.\n */\npublic static String abbreviateNumber(double number) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 582, "code_type": "method", "original_language": "typescript", "file_path": "mern-events-app\\3a9933e0d2a81c578954b7c804063b7d739c12ad\\src\\lib\\utils.ts\n", "question_type": "Data processing and transformation", "summary": "Converts the parameter dictionary to the query parameter in the url", "language_version_list": {"python": {"code_signature": "def to_query_string(params: dict) -> str:\n    \"\"\"\n    Converts a dictionary of parameters to a query string.\n\n    For example:\n        - Input: {'search': 'test', 'page': 1, 'size': 10}\n        - Output: '?search=test&page=1&size=10'\n\n    Args:\n        params (dict): The parameters to convert. The keys should be strings\n                       and values can be of any type that can be converted to a string.\n\n    Returns:\n        str: The query string representation of the parameters.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestToQueryString(unittest.TestCase):\n\n    def test_convert_simple_object_to_query_string(self):\n        params = {'search': 'test', 'page': 1, 'size': 10}\n        result = to_query_string(params)\n        self.assertEqual(result, '?search=test&page=1&size=10')\n\n    def test_encode_special_characters_in_query_string(self):\n        params = {'search': 'hello world', 'filter': 'price < \\$50'}\n        result = to_query_string(params)\n        self.assertEqual(result, '?search=hello%20world&filter=price%20%3C%20%2450')\n\n    def test_handle_empty_string_values(self):\n        params = {'search': '', 'page': 1}\n        result = to_query_string(params)\n        self.assertEqual(result, '?search=&page=1')\n\n    def test_handle_boolean_values(self):\n        params = {'isActive': True, 'isVerified': False}\n        result = to_query_string(params)\n        self.assertEqual(result, '?isActive=True&isVerified=False')\n\n", "prompt": "please write a python function , the function signature as below def to_query_string(params: dict) -> str:\n    \"\"\"\n    Converts a dictionary of parameters to a query string.\n\n    For example:\n        - Input: {'search': 'test', 'page': 1, 'size': 10}\n        - Output: '?search=test&page=1&size=10'\n\n    Args:\n        params (dict): The parameters to convert. The keys should be strings\n                       and values can be of any type that can be converted to a string.\n\n    Returns:\n        str: The query string representation of the parameters.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts an object to a query string.\n * For example:\n *      input: { \"search\": \"test\", \"page\": \"1\", \"size\": \"10\" };\n *      output: ?search=test&page=1&size=10\n *\n * @param params - The parameters to convert.\n * @returns The query string.\n */\nstd::string toQueryString(const std::map<std::string, std::string>& params){}", "test_code": "TEST_CASE(\"toQueryString\") {\n    SECTION(\"should convert a simple object to a query string\") {\n        std::map<std::string, std::string> params = {{\"search\", \"test\"}, {\"page\", \"1\"}, {\"size\", \"10\"}};\n        std::string result = toQueryString(params);\n        REQUIRE(result == \"?search=test&page=1&size=10\");\n    }\n\n    SECTION(\"should encode special characters in the query string\") {\n        std::map<std::string, std::string> params = {{\"search\", \"hello world\"}, {\"filter\", \"price < $50\"}};\n        std::string result = toQueryString(params);\n        REQUIRE(result == \"?search=hello%20world&filter=price%20%3C%20%2450\");\n    }\n\n    SECTION(\"should handle empty string values\") {\n        std::map<std::string, std::string> params = {{\"search\", \"\"}, {\"page\", \"1\"}};\n        std::string result = toQueryString(params);\n        REQUIRE(result == \"?search=&page=1\");\n    }\n\n    SECTION(\"should handle boolean values\") {\n        std::map<std::string, std::string> params = {{\"isActive\", \"true\"}, {\"isVerified\", \"false\"}};\n        std::string result = toQueryString(params);\n        REQUIRE(result == \"?isActive=true&isVerified=false\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts an object to a query string.\n * For example:\n *      input: { \"search\": \"test\", \"page\": \"1\", \"size\": \"10\" };\n *      output: ?search=test&page=1&size=10\n *\n * @param params - The parameters to convert.\n * @returns The query string.\n */\nstd::string toQueryString(const std::map<std::string, std::string>& params){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a map to a query string.\n *\n * @param params - The parameters to convert.\n * @return - The query string.\n */\npublic static String toQueryString(Map<String, Object> params) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Tester {\n\n    @Test\n    public void testToQueryString_SimpleObject() {\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"search\", \"test\");\n        params.put(\"page\", 1);\n        params.put(\"size\", 10);\n\n        String result = QueryStringConverter.toQueryString(params);\n        assertEquals(\"?search=test&page=1&size=10\", result);\n    }\n\n    @Test\n    public void testToQueryString_EncodeSpecialCharacters() {\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"search\", \"hello world\");\n        params.put(\"filter\", \"price < $50\");\n\n        String result = QueryStringConverter.toQueryString(params);\n        assertEquals(\"?search=hello%20world&filter=price%20%3C%20%2450\", result);\n    }\n\n    @Test\n    public void testToQueryString_HandleEmptyStringValues() {\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"search\", \"\");\n        params.put(\"page\", 1);\n\n        String result = QueryStringConverter.toQueryString(params);\n        assertEquals(\"?search=&page=1\", result);\n    }\n\n    @Test\n    public void testToQueryString_HandleBooleanValues() {\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"isActive\", true);\n        params.put(\"isVerified\", false);\n\n        String result = QueryStringConverter.toQueryString(params);\n        assertEquals(\"?isActive=true&isVerified=false\", result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a map to a query string.\n *\n * @param params - The parameters to convert.\n * @return - The query string.\n */\npublic static String toQueryString(Map<String, Object> params) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 583, "code_type": "method", "original_language": "typescript", "file_path": "mern-events-app\\3a9933e0d2a81c578954b7c804063b7d739c12ad\\src\\lib\\utils.ts\n", "question_type": "Data processing and transformation", "summary": "Removes the parameters in the url query based on the given key", "language_version_list": {"python": {"code_signature": "def remove_query_param(url: str, key: str) -> str:\n    \"\"\"\n    Removes the specified parameter from the URL query string.\n\n    This function parses the URL, removes the specified query parameter,\n    and returns the modified URL. If the parameter does not exist,\n    the original URL is returned.\n\n    For example:\n        - Input: 'http://example.com/page?search=test&page=1', 'search'\n        - Output: 'http://example.com/page?page=1'\n\n    Args:\n        url (str): The URL from which to remove the parameter.\n        key (str): The key of the parameter to remove.\n\n    Returns:\n        str: The modified URL with the specified parameter removed.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestRemoveQueryParam(unittest.TestCase):\n\n    def test_remove_existing_parameter(self):\n        url = 'https://example.com?page=1&sort=asc&filter=red'\n        result = remove_query_param(url, 'sort')\n        self.assertEqual(result, 'https://example.com/?page=1&filter=red')\n\n    def test_no_modification_if_parameter_does_not_exist(self):\n        url = 'https://example.com?page=1&filter=red'\n        result = remove_query_param(url, 'sort')\n        self.assertEqual(result, 'https://example.com/?page=1&filter=red')\n\n    def test_return_original_url_if_no_query_parameters(self):\n        url = 'https://example.com'\n        result = remove_query_param(url, 'sort')\n        self.assertEqual(result, 'https://example.com/')\n\n    def test_remove_multiple_occurrences_of_a_parameter(self):\n        url = 'https://example.com?page=1&filter=red&filter=blue'\n        result = remove_query_param(url, 'filter')\n        self.assertEqual(result, 'https://example.com/?page=1')\n\n    def test_handle_encoded_characters_in_parameter(self):\n        url = 'https://example.com?page=1&sort=asc&filter=hello%20world'\n        result = remove_query_param(url, 'filter')\n        self.assertEqual(result, 'https://example.com/?page=1&sort=asc')\n\n    def test_handle_case_when_parameter_is_only_one_in_url(self):\n        url = 'https://example.com?sort=asc'\n        result = remove_query_param(url, 'sort')\n        self.assertEqual(result, 'https://example.com/')\n", "prompt": "please write a python function , the function signature as below def remove_query_param(url: str, key: str) -> str:\n    \"\"\"\n    Removes the specified parameter from the URL query string.\n\n    This function parses the URL, removes the specified query parameter,\n    and returns the modified URL. If the parameter does not exist,\n    the original URL is returned.\n\n    For example:\n        - Input: 'http://example.com/page?search=test&page=1', 'search'\n        - Output: 'http://example.com/page?page=1'\n\n    Args:\n        url (str): The URL from which to remove the parameter.\n        key (str): The key of the parameter to remove.\n\n    Returns:\n        str: The modified URL with the specified parameter removed.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "please write a cpp function , the function signature as below ", "addition_info": ""}, "java": {"code_signature": "/**\n * Removes the specified parameter from the URL query string.\n *\n * @param url The URL from which to remove the parameter.\n * @param key The key of the parameter to remove.\n * @return The modified URL with the specified parameter removed.\n * @throws URISyntaxException If the URL is malformed.\n */\npublic static String removeQueryParam(String url, String key) throws URISyntaxException {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void testRemoveExistingParameter() throws Exception {\n        String url = \"https://example.com?page=1&sort=asc&filter=red\";\n        String result = UrlUtils.removeQueryParam(url, \"sort\");\n        assertEquals(\"https://example.com/?page=1&filter=red\", result);\n    }\n\n    @Test\n    public void testNoModificationIfParameterDoesNotExist() throws Exception {\n        String url = \"https://example.com?page=1&filter=red\";\n        String result = UrlUtils.removeQueryParam(url, \"sort\");\n        assertEquals(\"https://example.com/?page=1&filter=red\", result);\n    }\n\n    @Test\n    public void testReturnOriginalUrlIfNoQueryParameters() throws Exception {\n        String url = \"https://example.com\";\n        String result = UrlUtils.removeQueryParam(url, \"sort\");\n        assertEquals(\"https://example.com/\", result);\n    }\n\n    @Test\n    public void testRemoveMultipleOccurrencesOfParameter() throws Exception {\n        String url = \"https://example.com?page=1&filter=red&filter=blue\";\n        String result = UrlUtils.removeQueryParam(url, \"filter\");\n        assertEquals(\"https://example.com/?page=1\", result);\n    }\n\n    @Test\n    public void testHandleEncodedCharactersInParameter() throws Exception {\n        String url = \"https://example.com?page=1&sort=asc&filter=hello%20world\";\n        String result = UrlUtils.removeQueryParam(url, \"filter\");\n        assertEquals(\"https://example.com/?page=1&sort=asc\", result);\n    }\n\n    @Test\n    public void testParameterIsOnlyOneInUrl() throws Exception {\n        String url = \"https://example.com?sort=asc\";\n        String result = UrlUtils.removeQueryParam(url, \"sort\");\n        assertEquals(\"https://example.com/\", result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Removes the specified parameter from the URL query string.\n *\n * @param url The URL from which to remove the parameter.\n * @param key The key of the parameter to remove.\n * @return The modified URL with the specified parameter removed.\n * @throws URISyntaxException If the URL is malformed.\n */\npublic static String removeQueryParam(String url, String key) throws URISyntaxException {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 584, "code_type": "method", "original_language": "typescript", "file_path": "js-analyzer\\a9fd8d479f54079cb5ea24cf15d163a33e9bca5e\\src\\common\\constants\\index.ts\n", "question_type": "Data processing and transformation", "summary": "Detects whether the string is KEBAB_CASE", "language_version_list": {"python": {"code_signature": "def is_pascal_case(input: str) -> bool:\n    \"\"\"\n    Detects whether the string is in PASCAL_CASE.\n\n    In PASCAL_CASE, each word starts with an uppercase letter and\n    there are no spaces or underscores separating the words.\n\n    Args:\n        input (str): The string to check.\n\n    Returns:\n        bool: True if the string is in PASCAL_CASE, otherwise False.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsPascalCase(unittest.TestCase):\n\n    def test_valid_pascal_case(self):\n        \"\"\"Should return true for a valid PascalCase string.\"\"\"\n        self.assertTrue(is_pascal_case('PascalCase'))\n\n    def test_valid_pascal_case_multiple_words(self):\n        \"\"\"Should return true for a valid PascalCase string with multiple words.\"\"\"\n        self.assertTrue(is_pascal_case('PascalCaseExample'))\n\n    def test_starts_with_lowercase(self):\n        \"\"\"Should return false for a string that starts with a lowercase letter.\"\"\"\n        self.assertFalse(is_pascal_case('pascalCase'))\n\n    def test_with_underscores(self):\n        \"\"\"Should return false for a string with underscores.\"\"\"\n        self.assertFalse(is_pascal_case('Pascal_case'))\n\n    def test_empty_string(self):\n        \"\"\"Should return false for a string that is empty.\"\"\"\n        self.assertFalse(is_pascal_case(''))\n", "prompt": "please write a python function , the function signature as below def is_pascal_case(input: str) -> bool:\n    \"\"\"\n    Detects whether the string is in PASCAL_CASE.\n\n    In PASCAL_CASE, each word starts with an uppercase letter and\n    there are no spaces or underscores separating the words.\n\n    Args:\n        input (str): The string to check.\n\n    Returns:\n        bool: True if the string is in PASCAL_CASE, otherwise False.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Detects whether the string is in PASCAL_CASE.\n *\n * @param input - The string to check.\n * @returns True if the string is in PASCAL_CASE, otherwise false.\n */\nbool isPascalCase(const std::string& input) {}", "test_code": "TEST_CASE(\"isPascalCase\", \"[PascalCase]\") {\n    REQUIRE(isPascalCase(\"PascalCase\") == true);\n    REQUIRE(isPascalCase(\"PascalCaseExample\") == true);\n    REQUIRE(isPascalCase(\"pascalCase\") == false);\n    REQUIRE(isPascalCase(\"Pascal_case\") == false);\n    REQUIRE(isPascalCase(\"\") == false);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Detects whether the string is in PASCAL_CASE.\n *\n * @param input - The string to check.\n * @returns True if the string is in PASCAL_CASE, otherwise false.\n */\nbool isPascalCase(const std::string& input) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Detects whether the string is in PASCAL_CASE.\n *\n * @param input - The string to check.\n * @return True if the string is in PASCAL_CASE, otherwise false.\n */\npublic boolean isPascalCase(String input) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void shouldReturnTrueForValidPascalCaseString() {\n        assertTrue(isPascalCase(\"PascalCase\"));\n    }\n\n    @Test\n    public void shouldReturnTrueForValidPascalCaseStringWithMultipleWords() {\n        assertTrue(isPascalCase(\"PascalCaseExample\"));\n    }\n\n    @Test\n    public void shouldReturnFalseForStringThatStartsWithLowercaseLetter() {\n        assertFalse(isPascalCase(\"pascalCase\"));\n    }\n\n    @Test\n    public void shouldReturnFalseForStringWithUnderscores() {\n        assertFalse(isPascalCase(\"Pascal_case\"));\n    }\n\n    @Test\n    public void shouldReturnFalseForEmptyString() {\n        assertFalse(isPascalCase(\"\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Detects whether the string is in PASCAL_CASE.\n *\n * @param input - The string to check.\n * @return True if the string is in PASCAL_CASE, otherwise false.\n */\npublic boolean isPascalCase(String input) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 585, "code_type": "method", "original_language": "typescript", "file_path": "js-analyzer\\a9fd8d479f54079cb5ea24cf15d163a33e9bca5e\\src\\common\\constants\\index.ts\n", "question_type": "Data processing and transformation", "summary": " Detects whether the string is in CAMEL_CASE.", "language_version_list": {"python": {"code_signature": "def is_camel_case(input: str) -> bool:\n    \"\"\"\n    Detects whether the string is in CAMEL_CASE.\n\n    In CAMEL_CASE, the first letter of the first word is lowercase,\n    and each subsequent word starts with an uppercase letter, with no spaces or underscores\n    separating the words.\n\n    Args:\n        input (str): The string to check.\n\n    Returns:\n        bool: True if the string is in CAMEL_CASE, otherwise False.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsCamelCase(unittest.TestCase):\n\n    def test_valid_camel_case(self):\n        \"\"\"Should return true for a valid camelCase string.\"\"\"\n        self.assertTrue(is_camel_case('camelCase'))\n\n    def test_valid_camel_case_multiple_words(self):\n        \"\"\"Should return true for a valid camelCase string with multiple words.\"\"\"\n        self.assertTrue(is_camel_case('camelCaseExample'))\n\n    def test_uppercase_start(self):\n        \"\"\"Should return false for a string that starts with an uppercase letter.\"\"\"\n        self.assertFalse(is_camel_case('CamelCase'))\n\n    def test_underscores(self):\n        \"\"\"Should return false for a string with underscores.\"\"\"\n        self.assertFalse(is_camel_case('camel_case'))\n\n    def test_empty_string(self):\n        \"\"\"Should return false for an empty string.\"\"\"\n        self.assertFalse(is_camel_case(''))\n", "prompt": "please write a python function , the function signature as below def is_camel_case(input: str) -> bool:\n    \"\"\"\n    Detects whether the string is in CAMEL_CASE.\n\n    In CAMEL_CASE, the first letter of the first word is lowercase,\n    and each subsequent word starts with an uppercase letter, with no spaces or underscores\n    separating the words.\n\n    Args:\n        input (str): The string to check.\n\n    Returns:\n        bool: True if the string is in CAMEL_CASE, otherwise False.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Detects whether the string is in CAMEL_CASE.\n *\n * @param input - The string to check.\n * @returns true if the string is in CAMEL_CASE, otherwise false.\n */\nbool isCamelCase(const std::string& input) {}", "test_code": "TEST_CASE(\"isCamelCase\") {\n    SECTION(\"should return true for a valid camelCase string\") {\n        REQUIRE(isCamelCase(\"camelCase\") == true);\n    }\n\n    SECTION(\"should return true for a valid camelCase string with multiple words\") {\n        REQUIRE(isCamelCase(\"camelCaseExample\") == true);\n    }\n\n    SECTION(\"should return false for a string that starts with an uppercase letter\") {\n        REQUIRE(isCamelCase(\"CamelCase\") == false);\n    }\n\n    SECTION(\"should return false for a string with underscores\") {\n        REQUIRE(isCamelCase(\"camel_case\") == false);\n    }\n\n    SECTION(\"should return false for an empty string\") {\n        REQUIRE(isCamelCase(\"\") == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Detects whether the string is in CAMEL_CASE.\n *\n * @param input - The string to check.\n * @returns true if the string is in CAMEL_CASE, otherwise false.\n */\nbool isCamelCase(const std::string& input) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Detects whether the string is in CAMEL_CASE.\n *\n * @param input - The string to check.\n * @return True if the string is in CAMEL_CASE, otherwise false.\n */\npublic static boolean isCamelCase(String input) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\npublic class Tester {\n\n    @Test\n    public void testValidCamelCaseString() {\n        assertTrue(isCamelCase(\"camelCase\"));\n    }\n\n    @Test\n    public void testValidCamelCaseStringWithMultipleWords() {\n        assertTrue(isCamelCase(\"camelCaseExample\"));\n    }\n\n    @Test\n    public void testStringStartingWithUppercaseLetter() {\n        assertFalse(isCamelCase(\"CamelCase\"));\n    }\n\n    @Test\n    public void testStringWithUnderscores() {\n        assertFalse(isCamelCase(\"camel_case\"));\n    }\n\n    @Test\n    public void testEmptyString() {\n        assertFalse(isCamelCase(\"\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Detects whether the string is in CAMEL_CASE.\n *\n * @param input - The string to check.\n * @return True if the string is in CAMEL_CASE, otherwise false.\n */\npublic static boolean isCamelCase(String input) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 586, "code_type": "method", "original_language": "typescript", "file_path": "js-analyzer\\a9fd8d479f54079cb5ea24cf15d163a33e9bca5e\\src\\common\\constants\\index.ts\n", "question_type": "Data processing and transformation", "summary": "Detects whether the string is in SNAKE_CASE.", "language_version_list": {"python": {"code_signature": "def is_snake_case(input: str) -> bool:\n    \"\"\"\n    Detects whether the string is in SNAKE_CASE.\n\n    In SNAKE_CASE, all letters are lowercase, and words are separated by underscores.\n    There should be no leading or trailing underscores, and no spaces or other special characters.\n\n    Args:\n        input (str): The string to check.\n\n    Returns:\n        bool: True if the string is in SNAKE_CASE, otherwise False.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIsSnakeCase(unittest.TestCase):\n\n    def test_valid_snake_case(self):\n        \"\"\"should return true for a valid snake_case string\"\"\"\n        self.assertTrue(is_snake_case('snake_case'))\n\n    def test_valid_snake_case_multiple_words(self):\n        \"\"\"should return true for a valid snake_case string with multiple words\"\"\"\n        self.assertTrue(is_snake_case('snake_case_example'))\n\n    def test_uppercase_start(self):\n        \"\"\"should return false for a string that starts with an uppercase letter\"\"\"\n        self.assertFalse(is_snake_case('Snake_Case'))\n\n    def test_mixed_case_letters(self):\n        \"\"\"should return false for a string with mixed case letters\"\"\"\n        self.assertFalse(is_snake_case('snakeCASE'))\n\n    def test_string_with_numbers(self):\n        \"\"\"should return false for a string with numbers\"\"\"\n        self.assertFalse(is_snake_case('snake_case_123'))\n\n    def test_empty_string(self):\n        \"\"\"should return false for an empty string\"\"\"\n        self.assertFalse(is_snake_case(''))\n", "prompt": "please write a python function , the function signature as below def is_snake_case(input: str) -> bool:\n    \"\"\"\n    Detects whether the string is in SNAKE_CASE.\n\n    In SNAKE_CASE, all letters are lowercase, and words are separated by underscores.\n    There should be no leading or trailing underscores, and no spaces or other special characters.\n\n    Args:\n        input (str): The string to check.\n\n    Returns:\n        bool: True if the string is in SNAKE_CASE, otherwise False.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Detects whether the string is in SNAKE_CASE.\n *\n * @param input - The string to check.\n * @returns True if the string is in SNAKE_CASE, otherwise false.\n */\nbool isSnakeCase(const std::string& input) {}", "test_code": "TEST_CASE(\"isSnakeCase\") {\n    SECTION(\"should return true for a valid snake_case string\") {\n        REQUIRE(isSnakeCase(\"snake_case\") == true);\n    }\n\n    SECTION(\"should return true for a valid snake_case string with multiple words\") {\n        REQUIRE(isSnakeCase(\"snake_case_example\") == true);\n    }\n\n    SECTION(\"should return false for a string that starts with an uppercase letter\") {\n        REQUIRE(isSnakeCase(\"Snake_Case\") == false);\n    }\n\n    SECTION(\"should return false for a string with mixed case letters\") {\n        REQUIRE(isSnakeCase(\"snakeCASE\") == false);\n    }\n\n    SECTION(\"should return false for a string with numbers\") {\n        REQUIRE(isSnakeCase(\"snake_case_123\") == false);\n    }\n\n    SECTION(\"should return false for an empty string\") {\n        REQUIRE(isSnakeCase(\"\") == false);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Detects whether the string is in SNAKE_CASE.\n *\n * @param input - The string to check.\n * @returns True if the string is in SNAKE_CASE, otherwise false.\n */\nbool isSnakeCase(const std::string& input) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Detects whether the string is in SNAKE_CASE.\n *\n * @param input The string to check.\n * @return True if the string is in SNAKE_CASE, otherwise false.\n */\npublic static boolean isSnakeCase(String input) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testValidSnakeCase() {\n        assertTrue(StringUtil.isSnakeCase(\"snake_case\"));\n    }\n\n    @Test\n    public void testValidSnakeCaseMultipleWords() {\n        assertTrue(StringUtil.isSnakeCase(\"snake_case_example\"));\n    }\n\n    @Test\n    public void testStartsWithUppercase() {\n        assertFalse(StringUtil.isSnakeCase(\"Snake_Case\"));\n    }\n\n    @Test\n    public void testMixedCaseLetters() {\n        assertFalse(StringUtil.isSnakeCase(\"snakeCASE\"));\n    }\n\n    @Test\n    public void testWithNumbers() {\n        assertFalse(StringUtil.isSnakeCase(\"snake_case_123\"));\n    }\n\n    @Test\n    public void testEmptyString() {\n        assertFalse(StringUtil.isSnakeCase(\"\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Detects whether the string is in SNAKE_CASE.\n *\n * @param input The string to check.\n * @return True if the string is in SNAKE_CASE, otherwise false.\n */\npublic static boolean isSnakeCase(String input) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 170, "code_type": "method", "original_language": "java", "file_path": "composum-AI\\2256cb29fb0dac57a3252a6e319f3869eae9bc87\\backend\\base\\src\\main\\java\\com\\composum\\ai\\backend\\base\\service\\chat\\impl\\HtmlToMarkdownConverter.java", "question_type": "Data processing and transformation", "summary": "convert the HTML string to the corresponding MarkDown formatted text. HTML tags that support conversion include a, strong, code, em, p, br, u, ul, li, ol\n", "language_version_list": {"python": {"code_signature": "def convert(html: str) -> str:\n    \"\"\"\n    Converts a string containing HTML to a Markdown-formatted string.\n\n    1. Line breaks (<br> or <br/>): Replaced with newline characters.\n    2. Paragraphs (<p> and </p>): Opening <p> tags are removed, while closing\n        </p> tags are replaced with two newline characters to separate paragraphs.\n    3. Strong emphasis (<strong> and </strong>): Replaced with double asterisks (**).\n    4. Italics (<em> and </em>): Replaced with single asterisks (*).\n    5. Underlined text (<u> and </u>): Replaced with single asterisks (*)\n        as underlining is not supported in Markdown.\n    6. Code snippets (<code> and </code>): Replaced with backticks (`).\n    7. Unordered lists (<ul> and </ul>): Opening and closing tags are removed.\n    8. Ordered lists (<ol> and </ol>): Opening and closing tags are removed.\n    9. List items (<li>): Opening <li> tags are replaced with an asterisk followed\n        by a space, while closing </li> tags are replaced with a newline character.\n    10. Hyperlinks (<a href=\"...\">...</a>): Replaced with the Markdown format\n        [text](URL), where \"text\" is the anchor text and \"URL\" is the link target.\n\n    Args:\n        html (str): The input string containing HTML content.\n\n    Returns:\n        str: A string formatted in Markdown, reflecting the input HTML structure.\n    \"\"\"", "test_code": "import unittest\n\nclass TestAnswer(unittest.TestCase):\n    \n    def test_simple_line_break(self):\n        input_html = \"Hello<br>World\"\n        expected_output = \"Hello\\nWorld\"\n        self.assertEqual(expected_output, convert(input_html))\n    \n    def test_strong_tags(self):\n        input_html = \"This is <strong>important</strong> text.\"\n        expected_output = \"This is **important** text.\"\n        self.assertEqual(expected_output, convert(input_html))\n    \n    def test_emphasis_tags(self):\n        input_html = \"This is <em>emphasized</em> text.\"\n        expected_output = \"This is *emphasized* text.\"\n        self.assertEqual(expected_output, convert(input_html))\n    \n    def test_unordered_list(self):\n        input_html = \"<ul><li>Item 1</li><li>Item 2</li></ul>\"\n        expected_output = \"* Item 1\\n* Item 2\"\n        self.assertEqual(expected_output, convert(input_html))\n    \n    def test_anchor_tags(self):\n        input_html = 'Check this link: <a href=\"http://example.com\">Example</a>.'\n        expected_output = 'Check this link: [Example](http://example.com).'\n        self.assertEqual(expected_output, convert(input_html))", "prompt": "please write a python function , the function signature as below def convert(html: str) -> str:\n    \"\"\"\n    Converts a string containing HTML to a Markdown-formatted string.\n\n    1. Line breaks (<br> or <br/>): Replaced with newline characters.\n    2. Paragraphs (<p> and </p>): Opening <p> tags are removed, while closing\n        </p> tags are replaced with two newline characters to separate paragraphs.\n    3. Strong emphasis (<strong> and </strong>): Replaced with double asterisks (**).\n    4. Italics (<em> and </em>): Replaced with single asterisks (*).\n    5. Underlined text (<u> and </u>): Replaced with single asterisks (*)\n        as underlining is not supported in Markdown.\n    6. Code snippets (<code> and </code>): Replaced with backticks (`).\n    7. Unordered lists (<ul> and </ul>): Opening and closing tags are removed.\n    8. Ordered lists (<ol> and </ol>): Opening and closing tags are removed.\n    9. List items (<li>): Opening <li> tags are replaced with an asterisk followed\n        by a space, while closing </li> tags are replaced with a newline character.\n    10. Hyperlinks (<a href=\"...\">...</a>): Replaced with the Markdown format\n        [text](URL), where \"text\" is the anchor text and \"URL\" is the link target.\n\n    Args:\n        html (str): The input string containing HTML content.\n\n    Returns:\n        str: A string formatted in Markdown, reflecting the input HTML structure.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a string containing HTML to a Markdown-formatted string.\n *\n * This function performs the following transformations:\n * \n * 1. **Line breaks** (`<br>` or `<br/>`): Replaced with newline characters.\n * 2. **Paragraphs** (`<p>` and `</p>`): Opening `<p>` tags are removed, \n *    while closing `</p>` tags are replaced with two newline characters \n *    to separate paragraphs.\n * 3. **Strong emphasis** (`<strong>` and `</strong>`): Replaced with \n *    double asterisks (`**`).\n * 4. **Italics** (`<em>` and `</em>`): Replaced with single asterisks (`*`).\n * 5. **Underlined text** (`<u>` and `</u>`): Replaced with single asterisks (`*`) \n *    as underlining is not supported in Markdown.\n * 6. **Code snippets** (`<code>` and `</code>`): Replaced with backticks (`` ` ``).\n * 7. **Unordered lists** (`<ul>` and `</ul>`): Opening and closing tags are removed.\n * 8. **Ordered lists** (`<ol>` and `</ol>`): Opening and closing tags are removed.\n * 9. **List items** (`<li>`): Opening `<li>` tags are replaced with an asterisk \n *    followed by a space, while closing `</li>` tags are replaced with a newline character.\n * 10. **Hyperlinks** (`<a href=\"...\">...</a>`): Replaced with the Markdown format \n *     `[\\$2](\\$1)`, where \"text\" is the anchor text and \"URL\" is the link target.\n *\n * @param html The input string containing HTML content.\n * @return A string formatted in Markdown, reflecting the input HTML structure.\n */\nstd::string convert(const std::string& html);", "test_code": "TEST_CASE(\"Test Simple Line Break\") {\n    std::string input = \"Hello<br>World\";\n    std::string expectedOutput = \"Hello\\nWorld\";\n    REQUIRE(convert(input) == expectedOutput);\n}\n\nTEST_CASE(\"Test Strong Tags\") {\n    std::string input = \"This is <strong>important</strong> text.\";\n    std::string expectedOutput = \"This is **important** text.\";\n    REQUIRE(convert(input) == expectedOutput);\n}\n\nTEST_CASE(\"Test Emphasis Tags\") {\n    std::string input = \"This is <em>emphasized</em> text.\";\n    std::string expectedOutput = \"This is *emphasized* text.\";\n    REQUIRE(convert(input) == expectedOutput);\n}\n\nTEST_CASE(\"Test Unordered List\") {\n    std::string input = \"<ul><li>Item 1</li><li>Item 2</li></ul>\";\n    std::string expectedOutput = \"* Item 1\\n* Item 2\";\n    REQUIRE(convert(input) == expectedOutput);\n}\n\nTEST_CASE(\"Test Anchor Tags\") {\n    std::string input = \"Check this link: <a href=\\\"http://example.com\\\">Example</a>.\";\n    std::string expectedOutput = \"Check this link: [Example](http://example.com).\";\n    REQUIRE(convert(input) == expectedOutput);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a string containing HTML to a Markdown-formatted string.\n *\n * This function performs the following transformations:\n * \n * 1. **Line breaks** (`<br>` or `<br/>`): Replaced with newline characters.\n * 2. **Paragraphs** (`<p>` and `</p>`): Opening `<p>` tags are removed, \n *    while closing `</p>` tags are replaced with two newline characters \n *    to separate paragraphs.\n * 3. **Strong emphasis** (`<strong>` and `</strong>`): Replaced with \n *    double asterisks (`**`).\n * 4. **Italics** (`<em>` and `</em>`): Replaced with single asterisks (`*`).\n * 5. **Underlined text** (`<u>` and `</u>`): Replaced with single asterisks (`*`) \n *    as underlining is not supported in Markdown.\n * 6. **Code snippets** (`<code>` and `</code>`): Replaced with backticks (`` ` ``).\n * 7. **Unordered lists** (`<ul>` and `</ul>`): Opening and closing tags are removed.\n * 8. **Ordered lists** (`<ol>` and `</ol>`): Opening and closing tags are removed.\n * 9. **List items** (`<li>`): Opening `<li>` tags are replaced with an asterisk \n *    followed by a space, while closing `</li>` tags are replaced with a newline character.\n * 10. **Hyperlinks** (`<a href=\"...\">...</a>`): Replaced with the Markdown format \n *     `[\\$2](\\$1)`, where \"text\" is the anchor text and \"URL\" is the link target.\n *\n * @param html The input string containing HTML content.\n * @return A string formatted in Markdown, reflecting the input HTML structure.\n */\nstd::string convert(const std::string& html);", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a string containing HTML to a Markdown-formatted string.\n *\n * 1. Line breaks (<br> or <br/>): Replaced with newline characters.\n * 2. Paragraphs (<p> and </p>): Opening <p> tags are removed, while closing\n *    </p> tags are replaced with two newline characters to separate paragraphs.\n * 3. Strong emphasis (<strong> and </strong>): Replaced with double asterisks (**).\n * 4. Italics (<em> and </em>): Replaced with single asterisks (*).\n * 5. Underlined text (<u> and </u>): Replaced with single asterisks (*)\n *    as underlining is not supported in Markdown.\n * 6. Code snippets (<code> and </code>): Replaced with backticks (`).\n * 7. Unordered lists (<ul> and </ul>): Opening and closing tags are removed.\n * 8. Ordered lists (<ol> and </ol>): Opening and closing tags are removed.\n * 9. List items (<li>): Opening <li> tags are replaced with an asterisk followed\n *    by a space, while closing </li> tags are replaced with a newline character.\n * 10. Hyperlinks (<a href=\"...\">...</a>): Replaced with the Markdown format\n *     [text](URL), where \"text\" is the anchor text and \"URL\" is the link target.\n *\n * @param html The input string containing HTML content.\n * @return A string formatted in Markdown, reflecting the input HTML structure.\n */\npublic static String convert(String html) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertArrayEquals;\n\nimport org.real.temp.*;\npublic class Tester {\n\n    @Test\n    public void testCubicBezier_t0() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 0.0;\n        double[] expected = {0.0, 0.0};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3),1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_t1() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 1.0;\n        double[] expected = {1.0, 0.0};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3),1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_t0_5() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 0.5;\n        double[] expected = {0.5, 0.75};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_midPoint() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {1.0, 1.0};\n        double[] p2 = {2.0, 1.0};\n        double[] p3 = {3.0, 0.0};\n\n        double t = 0.5;\n        double[] expected = {1.5, 0.75};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_arbitraryT() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 2.0};\n        double[] p2 = {2.0, 2.0};\n        double[] p3 = {2.0, 0.0};\n        double t = 0.75;\n        double[] expected = {1.6875, 1.125};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts a string containing HTML to a Markdown-formatted string.\n *\n * 1. Line breaks (<br> or <br/>): Replaced with newline characters.\n * 2. Paragraphs (<p> and </p>): Opening <p> tags are removed, while closing\n *    </p> tags are replaced with two newline characters to separate paragraphs.\n * 3. Strong emphasis (<strong> and </strong>): Replaced with double asterisks (**).\n * 4. Italics (<em> and </em>): Replaced with single asterisks (*).\n * 5. Underlined text (<u> and </u>): Replaced with single asterisks (*)\n *    as underlining is not supported in Markdown.\n * 6. Code snippets (<code> and </code>): Replaced with backticks (`).\n * 7. Unordered lists (<ul> and </ul>): Opening and closing tags are removed.\n * 8. Ordered lists (<ol> and </ol>): Opening and closing tags are removed.\n * 9. List items (<li>): Opening <li> tags are replaced with an asterisk followed\n *    by a space, while closing </li> tags are replaced with a newline character.\n * 10. Hyperlinks (<a href=\"...\">...</a>): Replaced with the Markdown format\n *     [text](URL), where \"text\" is the anchor text and \"URL\" is the link target.\n *\n * @param html The input string containing HTML content.\n * @return A string formatted in Markdown, reflecting the input HTML structure.\n */\npublic static String convert(String html) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 173, "code_type": "method", "original_language": "java", "file_path": "Figura\\46108431382ac91ed18971693adcfaff18c388bd\\common\\src\\main\\java\\org\\figuramc\\figura\\utils\\MathUtils.java", "question_type": "Algorithm and data structure", "summary": "Calculate the coordinates of a cubic B\u00e9zier curve at a given parametert(typically between 0 and 1).", "language_version_list": {"python": {"code_signature": "def cubic_bezier(t: float, p0: list, p1: list, p2: list, p3: list) -> list:\n    \"\"\"\n    Calculate the coordinates of a cubic B\u00e9zier curve at a given parameter t (typically between 0 and 1).\n\n    Args:\n        t (float): A float representing the parameter along the curve, where 0 <= t <= 1.\n        p0 (list): A list of size 2 representing the x and y coordinates of the start point.\n        p1 (list): A list of size 2 representing the x and y coordinates of the first control point.\n        p2 (list): A list of size 2 representing the x and y coordinates of the second control point.\n        p3 (list): A list of size 2 representing the x and y coordinates of the end point.\n\n    Returns:\n        list: A list of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n    \"\"\"", "test_code": "import unittest\nfrom typing import List\n\nclass TestCubicBezier(unittest.TestCase):\n    def test_cubic_bezier_t0(self):\n        p0 = [0.0, 0.0]\n        p1 = [0.0, 1.0]\n        p2 = [1.0, 1.0]\n        p3 = [1.0, 0.0]\n        t = 0.0\n        expected = [0.0, 0.0]\n        self.assertAlmostEqual(cubic_bezier(t, p0, p1, p2, p3), expected)\n\n    def test_cubic_bezier_t1(self):\n        p0 = [0.0, 0.0]\n        p1 = [0.0, 1.0]\n        p2 = [1.0, 1.0]\n        p3 = [1.0, 0.0]\n        t = 1.0\n        expected = [1.0, 0.0]\n        self.assertAlmostEqual(cubic_bezier(t, p0, p1, p2, p3), expected)\n\n    def test_cubic_bezier_t0_5(self):\n        p0 = [0.0, 0.0]\n        p1 = [0.0, 1.0]\n        p2 = [1.0, 1.0]\n        p3 = [1.0, 0.0]\n        t = 0.5\n        expected = [0.5, 0.75]\n        self.assertAlmostEqual(cubic_bezier(t, p0, p1, p2, p3), expected, places=9)\n\n    def test_cubic_bezier_mid_point(self):\n        p0 = [0.0, 0.0]\n        p1 = [1.0, 1.0]\n        p2 = [2.0, 1.0]\n        p3 = [3.0, 0.0]\n        t = 0.5\n        expected = [1.5, 0.75]\n        self.assertAlmostEqual(cubic_bezier(t, p0, p1, p2, p3), expected, places=9)\n\n    def test_cubic_bezier_arbitrary_t(self):\n        p0 = [0.0, 0.0]\n        p1 = [0.0, 2.0]\n        p2 = [2.0, 2.0]\n        p3 = [2.0, 0.0]\n        t = 0.75\n        expected = [1.6875, 1.125]\n        self.assertAlmostEqual(cubic_bezier(t, p0, p1, p2, p3), expected, places=9)", "prompt": "please write a python function , the function signature as below def cubic_bezier(t: float, p0: list, p1: list, p2: list, p3: list) -> list:\n    \"\"\"\n    Calculate the coordinates of a cubic B\u00e9zier curve at a given parameter t (typically between 0 and 1).\n\n    Args:\n        t (float): A float representing the parameter along the curve, where 0 <= t <= 1.\n        p0 (list): A list of size 2 representing the x and y coordinates of the start point.\n        p1 (list): A list of size 2 representing the x and y coordinates of the first control point.\n        p2 (list): A list of size 2 representing the x and y coordinates of the second control point.\n        p3 (list): A list of size 2 representing the x and y coordinates of the end point.\n\n    Returns:\n        list: A list of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parameter t (typically between 0 and 1).\n * @param t  A double representing the parameter along the curve, where 0 <= t <= 1.\n * @param p0 A std::array of size 2 representing the x and y coordinates of the start point.\n * @param p1 A std::array of size 2 representing the x and y coordinates of the first control point.\n * @param p2 A std::array of size 2 representing the x and y coordinates of the second control point.\n * @param p3 A std::array of size 2 representing the x and y coordinates of the end point.\n * @return   A std::array of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\nstd::array<double, 2> cubicBezier(double t, const std::array<double, 2>& p0, \n                                   const std::array<double, 2>& p1, \n                                   const std::array<double, 2>& p2, \n                                   const std::array<double, 2>& p3) {}", "test_code": "TEST_CASE(\"Cubic Bezier Curve Tests\") {\n    std::array<double, 2> p0 = {0.0, 0.0};\n    std::array<double, 2> p1 = {0.0, 1.0};\n    std::array<double, 2> p2 = {1.0, 1.0};\n    std::array<double, 2> p3 = {1.0, 0.0};\n\n    SECTION(\"t = 0.0\") {\n        double t = 0.0;\n        std::array<double, 2> expected = {0.0, 0.0};\n        REQUIRE(cubicBezier(t, p0, p1, p2, p3) == expected);\n    }\n\n    SECTION(\"t = 1.0\") {\n        double t = 1.0;\n        std::array<double, 2> expected = {1.0, 0.0};\n        REQUIRE(cubicBezier(t, p0, p1, p2, p3) == expected);\n    }\n\n    SECTION(\"t = 0.5\") {\n        double t = 0.5;\n        std::array<double, 2> expected = {0.5, 0.75};\n        REQUIRE_THAT(cubicBezier(t, p0, p1, p2, p3), Catch::Equals(expected, 1e-9));\n    }\n\n    SECTION(\"Mid point\") {\n        std::array<double, 2> p1 = {1.0, 1.0};\n        std::array<double, 2> p2 = {2.0, 1.0};\n        std::array<double, 2> p3 = {3.0, 0.0};\n        double t = 0.5;\n        std::array<double, 2> expected = {1.5, 0.75};\n        REQUIRE_THAT(cubicBezier(t, p0, p1, p2, p3), Catch::Equals(expected, 1e-9));\n    }\n\n    SECTION(\"Arbitrary t = 0.75\") {\n        std::array<double, 2> p1 = {0.0, 2.0};\n        std::array<double, 2> p2 = {2.0, 2.0};\n        std::array<double, 2> p3 = {2.0, 0.0};\n        double t = 0.75;\n        std::array<double, 2> expected = {1.6875, 1.125};\n        REQUIRE_THAT(cubicBezier(t, p0, p1, p2, p3), Catch::Equals(expected, 1e-9));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parameter t (typically between 0 and 1).\n * @param t  A double representing the parameter along the curve, where 0 <= t <= 1.\n * @param p0 A std::array of size 2 representing the x and y coordinates of the start point.\n * @param p1 A std::array of size 2 representing the x and y coordinates of the first control point.\n * @param p2 A std::array of size 2 representing the x and y coordinates of the second control point.\n * @param p3 A std::array of size 2 representing the x and y coordinates of the end point.\n * @return   A std::array of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\nstd::array<double, 2> cubicBezier(double t, const std::array<double, 2>& p0, \n                                   const std::array<double, 2>& p1, \n                                   const std::array<double, 2>& p2, \n                                   const std::array<double, 2>& p3) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parametert(typically between 0 and 1).\n * @param t  A double representing the parameter along the curve, where 0 <= t <= 1.\n * @param p0 A double array of size 2 representing the x and y coordinates of the start point.\n * @param p1 A double array of size 2 representing the x and y coordinates of the first control point.\n * @param p2 A double array of size 2 representing the x and y coordinates of the second control point.\n * @param p3 A double array of size 2 representing the x and y coordinates of the end point.\n * @return   A double array of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\npublic static double[] cubicBezier(double t, double[] p0, double[] p1, double[] p2, double[] p3) {}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertArrayEquals;\n\nimport org.real.temp.*;\npublic class Tester {\n\n    @Test\n    public void testCubicBezier_t0() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 0.0;\n        double[] expected = {0.0, 0.0};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3));\n    }\n\n    @Test\n    public void testCubicBezier_t1() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 1.0;\n        double[] expected = {1.0, 0.0};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3));\n    }\n\n    @Test\n    public void testCubicBezier_t0_5() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 0.5;\n        double[] expected = {0.5, 0.75};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_midPoint() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {1.0, 1.0};\n        double[] p2 = {2.0, 1.0};\n        double[] p3 = {3.0, 0.0};\n\n        double t = 0.5;\n        double[] expected = {1.5, 0.75};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_arbitraryT() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 2.0};\n        double[] p2 = {2.0, 2.0};\n        double[] p3 = {2.0, 0.0};\n        double t = 0.75;\n        double[] expected = {1.6875, 1.125};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parametert(typically between 0 and 1).\n * @param t  A double representing the parameter along the curve, where 0 <= t <= 1.\n * @param p0 A double array of size 2 representing the x and y coordinates of the start point.\n * @param p1 A double array of size 2 representing the x and y coordinates of the first control point.\n * @param p2 A double array of size 2 representing the x and y coordinates of the second control point.\n * @param p3 A double array of size 2 representing the x and y coordinates of the end point.\n * @return   A double array of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\npublic static double[] cubicBezier(double t, double[] p0, double[] p1, double[] p2, double[] p3) {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 174, "code_type": "method", "original_language": "java", "file_path": "Figura\\46108431382ac91ed18971693adcfaff18c388bd\\common\\src\\main\\java\\org\\figuramc\\figura\\utils\\MathUtils.java", "question_type": "Algorithm and data structure", "summary": "Implement a function using the secant method that takes a B\u00e9zier curve and a target x-value as inputs and returns the parameter t where the B\u00e9zier curve reaches the specified x-value.", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef find_t_for_x(target_x: float, p0: Tuple[float, float], p1: Tuple[float, float], p2: Tuple[float, float]) -> float:\n    \"\"\"\n    Find the parameter t corresponding to a given x-coordinate target_x\n    on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n\n    Args:\n        target_x (float): The x-coordinate for which we want to find the corresponding parameter t.\n        p0 (Tuple[float, float]): The first control point of the B\u00e9zier curve.\n        p1 (Tuple[float, float]): The second control point of the B\u00e9zier curve.\n        p2 (Tuple[float, float]): The third control point of the B\u00e9zier curve.\n\n    Returns:\n        float: The parameter t (in the range [0, 1]) for which the B\u00e9zier curve evaluated at t is closest to target_x.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestFindxTForX(unittest.TestCase):\n    TOLERANCE = 1e-6\n\n    def test_find_t_for_x_at_start(self):\n        p0 = 0.0\n        p1 = 0.5\n        p2 = 1.0\n        target_x = 0.0\n        t = find_t_for_x(target_x, p0, p1, p2)\n        self.assertAlmostEqual(t, 0.0, delta=self.TOLERANCE)\n\n    def test_find_t_for_x_at_end(self):\n        p0 = 0.0\n        p1 = 0.5\n        p2 = 1.0\n        target_x = 1.0\n        t = find_t_for_x(target_x, p0, p1, p2)\n        self.assertAlmostEqual(t, 1.0, delta=self.TOLERANCE)\n\n    def test_find_t_for_x_mid_curve(self):\n        p0 = 0.0\n        p1 = 0.5\n        p2 = 1.0\n        target_x = 0.25\n        t = find_t_for_x(target_x, p0, p1, p2)\n        self.assertAlmostEqual(t, 0.25, delta=self.TOLERANCE)\n\n    def test_find_t_for_x_near_mid_curve(self):\n        p0 = 0.0\n        p1 = 1.0\n        p2 = 2.0\n        target_x = 1.5\n        t = find_t_for_x(target_x, p0, p1, p2)\n        self.assertAlmostEqual(t, 0.75, delta=self.TOLERANCE)", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef find_t_for_x(target_x: float, p0: Tuple[float, float], p1: Tuple[float, float], p2: Tuple[float, float]) -> float:\n    \"\"\"\n    Find the parameter t corresponding to a given x-coordinate target_x\n    on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n\n    Args:\n        target_x (float): The x-coordinate for which we want to find the corresponding parameter t.\n        p0 (Tuple[float, float]): The first control point of the B\u00e9zier curve.\n        p1 (Tuple[float, float]): The second control point of the B\u00e9zier curve.\n        p2 (Tuple[float, float]): The third control point of the B\u00e9zier curve.\n\n    Returns:\n        float: The parameter t (in the range [0, 1]) for which the B\u00e9zier curve evaluated at t is closest to target_x.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Finds the parameter `t` corresponding to a given x-coordinate `targetX`\n * on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n * The function uses the secant method to iteratively approach the value of `t`\n * where the B\u00e9zier curve intersects with the vertical line at `targetX`.\n *\n * @param targetX The x-coordinate for which we want to find the corresponding\n *                parameter `t` on the B\u00e9zier curve.\n * @param p0 The first control point of the B\u00e9zier curve, representing the\n *            starting point.\n * @param p1 The second control point of the B\u00e9zier curve, affecting the curve's\n *            shape.\n * @param p2 The third control point of the B\u00e9zier curve, representing the\n *            ending point.\n * @return The parameter `t` (in the range [0, 1]) for which the B\u00e9zier curve\n *         evaluated at `t` is closest to `targetX`. If no precise value is\n *         found within the specified tolerance and iterations, the function\n *         returns the best approximation.\n */\ndouble find_t_for_x(double targetX, double p0, double p1, double p2) {}", "test_code": "TEST_CASE(\"Find T for X at start\", \"[bezier]\") {\n    const double TOLERANCE = 1e-6;\n    double p0 = 0.0;\n    double p1 = 0.5;\n    double p2 = 1.0;\n    double targetX = 0.0;\n\n    double t = find_t_for_x(targetX, p0, p1, p2);\n    REQUIRE(std::abs(t - 0.0) < TOLERANCE);\n}\n\nTEST_CASE(\"Find T for X at end\", \"[bezier]\") {\n    const double TOLERANCE = 1e-6;\n    double p0 = 0.0;\n    double p1 = 0.5;\n    double p2 = 1.0;\n    double targetX = 1.0;\n\n    double t = find_t_for_x(targetX, p0, p1, p2);\n    REQUIRE(std::abs(t - 1.0) < TOLERANCE);\n}\n\nTEST_CASE(\"Find T for X mid curve\", \"[bezier]\") {\n    const double TOLERANCE = 1e-6;\n    double p0 = 0.0;\n    double p1 = 0.5;\n    double p2 = 1.0;\n    double targetX = 0.25;\n\n    double t = find_t_for_x(targetX, p0, p1, p2);\n    REQUIRE(std::abs(t - 0.25) < TOLERANCE);\n}\n\nTEST_CASE(\"Find T for X near mid curve\", \"[bezier]\") {\n    const double TOLERANCE = 1e-6;\n    double p0 = 0.0;\n    double p1 = 1.0;\n    double p2 = 2.0;\n    double targetX = 1.5;\n\n    double t = find_t_for_x(targetX, p0, p1, p2);\n    REQUIRE(std::abs(t - 0.75) < TOLERANCE);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Finds the parameter `t` corresponding to a given x-coordinate `targetX`\n * on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n * The function uses the secant method to iteratively approach the value of `t`\n * where the B\u00e9zier curve intersects with the vertical line at `targetX`.\n *\n * @param targetX The x-coordinate for which we want to find the corresponding\n *                parameter `t` on the B\u00e9zier curve.\n * @param p0 The first control point of the B\u00e9zier curve, representing the\n *            starting point.\n * @param p1 The second control point of the B\u00e9zier curve, affecting the curve's\n *            shape.\n * @param p2 The third control point of the B\u00e9zier curve, representing the\n *            ending point.\n * @return The parameter `t` (in the range [0, 1]) for which the B\u00e9zier curve\n *         evaluated at `t` is closest to `targetX`. If no precise value is\n *         found within the specified tolerance and iterations, the function\n *         returns the best approximation.\n */\ndouble find_t_for_x(double targetX, double p0, double p1, double p2) {}", "addition_info": ""}, "java": {"code_signature": " /**\n * Finds the parameter `t` corresponding to a given x-coordinate `targetX`\n * on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n * The function uses a numerical method (Newton's method) to iteratively\n * approach the value of `t` where the B\u00e9zier curve intersects with the\n * vertical line at `targetX`.\n *\n * @param targetX The x-coordinate for which we want to find the corresponding\n *                parameter `t` on the B\u00e9zier curve.\n * @param p0 The first control point of the B\u00e9zier curve, representing the\n *            starting point.\n * @param p1 The second control point of the B\u00e9zier curve, affecting the curve's\n *            shape.\n * @param p2 The third control point of the B\u00e9zier curve, representing the\n *            ending point.\n * @return The parameter `t` (in the range [0, 1]) for which the B\u00e9zier curve\n *         evaluated at `t` is closest to `targetX`. If no precise value is\n *         found within the specified tolerance and iterations, the function\n *         returns the best approximation.\n */\npublic static double findTForX(double targetX, double p0, double p1, double p2) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; \nimport static org.junit.Assert.assertEquals; \nimport org.real.temp.*;\n\n\npublic class Tester {\n    // Tolerance level for floating-point comparisons\n    private static final double TOLERANCE = 1e-6;\n\n    @Test\n    public void testFindTForX_AtStart() {\n        double p0 = 0.0;\n        double p1 = 0.5;\n        double p2 = 1.0;\n        double targetX = 0.0;\n\n        double t = Answer.findTForX(targetX, p0, p1, p2);\n        assertEquals(0.0, t, TOLERANCE);\n    }\n\n    @Test\n    public void testFindTForX_AtEnd() {\n        double p0 = 0.0;\n        double p1 = 0.5;\n        double p2 = 1.0;\n        double targetX = 1.0;\n\n        double t = Answer.findTForX(targetX, p0, p1, p2);\n        assertEquals(1.0, t, TOLERANCE);\n    }\n\n    @Test\n    public void testFindTForX_MidCurve() {\n        double p0 = 0.0;\n        double p1 = 0.5;\n        double p2 = 1.0;\n        double targetX = 0.25;\n\n        double t = Answer.findTForX(targetX, p0, p1, p2);\n        assertEquals(0.25, t, TOLERANCE);\n    }\n\n\n    @Test\n    public void testFindTForX_NearMidCurve() {\n        double p0 = 0.0;\n        double p1 = 1.0;\n        double p2 = 2.0;\n        double targetX = 1.5;\n\n        double t = Answer.findTForX(targetX, p0, p1, p2);\n        assertEquals(0.75, t, TOLERANCE);\n    }\n\n}\n", "prompt": "please write a java function , the function signature as below  /**\n * Finds the parameter `t` corresponding to a given x-coordinate `targetX`\n * on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n * The function uses a numerical method (Newton's method) to iteratively\n * approach the value of `t` where the B\u00e9zier curve intersects with the\n * vertical line at `targetX`.\n *\n * @param targetX The x-coordinate for which we want to find the corresponding\n *                parameter `t` on the B\u00e9zier curve.\n * @param p0 The first control point of the B\u00e9zier curve, representing the\n *            starting point.\n * @param p1 The second control point of the B\u00e9zier curve, affecting the curve's\n *            shape.\n * @param p2 The third control point of the B\u00e9zier curve, representing the\n *            ending point.\n * @return The parameter `t` (in the range [0, 1]) for which the B\u00e9zier curve\n *         evaluated at `t` is closest to `targetX`. If no precise value is\n *         found within the specified tolerance and iterations, the function\n *         returns the best approximation.\n */\npublic static double findTForX(double targetX, double p0, double p1, double p2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 176, "code_type": "method", "original_language": "java", "file_path": "home-work\\a8e0d049688c59fe67ae27dcd9d4f3f656888c91\\src\\KNearestNeighbors.java", "question_type": "Algorithm and data structure", "summary": "Given a set of points and a query point, write an algorithm to find the K nearest neighbors to the query point. The algorithm should efficiently handle large datasets, and the output should include the coordinates or indices of these neighbors.", "language_version_list": {"python": {"code_signature": "import math\nfrom typing import List\n\n\nclass Point:\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n\n    def distance_to(self, other: 'Point') -> float:\n        \"\"\"Calculate the Euclidean distance to another point.\"\"\"\n        return math.sqrt((self.x - other.x) ** 2 + (self.y - other.y) ** 2)\n\n\ndef find_k_nearest_neighbors(points: List[Point], query_point: Point, k: int) -> List[Point]:\n    \"\"\"Find the k nearest neighbors to the query_point.\n\n    Args:\n        points (List[Point]): A list of Point objects representing the available points in the space.\n        query_point (Point): The Point object for which we want to find the nearest neighbors.\n        k (int): The number of nearest neighbors to find.\n\n    Returns:\n        List[Point]: A list of the k nearest Point objects to the query_point.\n    \"\"\"\n", "test_code": "import math\nimport unittest\n\n\nclass Point:\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n\n    def distance_to(self, other: 'Point') -> float:\n        return math.sqrt((self.x - other.x) ** 2 + (self.y - other.y) ** 2)\n\n\nclass Tester(unittest.TestCase):\n\n    def test_find_k_nearest_neighbors_simple_case(self):\n        points = [\n            Point(1, 2),\n            Point(3, 4),\n            Point(1, -1),\n            Point(5, 2)\n        ]\n        query_point = Point(2, 2)\n        k = 2\n        result = find_k_nearest_neighbors(points, query_point, k)\n\n        self.assertEqual(len(result), 2)\n        self.assertTrue(self.contains_point(result, Point(1, 2)))\n        self.assertTrue(self.contains_point(result, Point(3, 4)))\n\n    def test_find_k_nearest_neighbors_exact_match(self):\n        points = [\n            Point(1, 2),\n            Point(2, 2),\n            Point(3, 3)\n        ]\n        query_point = Point(2, 2)\n        k = 1\n        result = find_k_nearest_neighbors(points, query_point, k)\n\n        self.assertEqual(len(result), 1)\n        self.assertAlmostEqual(result[0].x, 2.0, delta=0.001)\n        self.assertAlmostEqual(result[0].y, 2.0, delta=0.001)\n\n    def test_find_k_nearest_neighbors_larger_k(self):\n        points = [\n            Point(1, 2),\n            Point(3, 4),\n            Point(1, -1),\n            Point(5, 2)\n        ]\n        query_point = Point(2, 2)\n        k = 5  # k is larger than the number of points\n        result = find_k_nearest_neighbors(points, query_point, k)\n\n        self.assertEqual(len(result), 4)\n\n    def test_find_k_nearest_neighbors_empty_points(self):\n        points = []\n        query_point = Point(2, 2)\n        k = 3\n        result = find_k_nearest_neighbors(points, query_point, k)\n\n        self.assertEqual(len(result), 0)\n\n    def test_find_k_nearest_neighbors_all_points_equidistant(self):\n        points = [\n            Point(2, 3),\n            Point(3, 2),\n            Point(1, 2),\n            Point(2, 1)\n        ]\n        query_point = Point(2, 2)\n        k = 2\n        result = find_k_nearest_neighbors(points, query_point, k)\n\n        self.assertEqual(len(result), 2)\n        self.assertTrue(self.contains_point(result, Point(2, 3)))\n        self.assertTrue(self.contains_point(result, Point(3, 2)))\n\n    def contains_point(self, points, point):\n        for p in points:\n            if math.isclose(p.x, point.x, abs_tol=0.001) and math.isclose(p.y, point.y, abs_tol=0.001):\n                return True\n        return False\n", "prompt": "please write a python function , the function signature as below import math\nfrom typing import List\n\n\nclass Point:\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n\n    def distance_to(self, other: 'Point') -> float:\n        \"\"\"Calculate the Euclidean distance to another point.\"\"\"\n        return math.sqrt((self.x - other.x) ** 2 + (self.y - other.y) ** 2)\n\n\ndef find_k_nearest_neighbors(points: List[Point], query_point: Point, k: int) -> List[Point]:\n    \"\"\"Find the k nearest neighbors to the query_point.\n\n    Args:\n        points (List[Point]): A list of Point objects representing the available points in the space.\n        query_point (Point): The Point object for which we want to find the nearest neighbors.\n        k (int): The number of nearest neighbors to find.\n\n    Returns:\n        List[Point]: A list of the k nearest Point objects to the query_point.\n    \"\"\"\n", "addition_info": "class Point:\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n\n    def distance_to(self, other: 'Point') -> float:\n        \"\"\"Calculate the Euclidean distance to another point.\"\"\"\n        return math.sqrt((self.x - other.x) ** 2 + (self.y - other.y) ** 2)"}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "\nclass Point {\npublic:\n    double x; // X-coordinate of the point\n    double y; // Y-coordinate of the point\n\n    // Constructor for the Point class\n    Point(double x, double y) : x(x), y(y) {}\n\n    // Calculate the Euclidean distance to another point\n    double distance_to(const Point& other) const;\n};\n/**\n * @brief Finds the k nearest neighbors to the specified query point.\n *\n * This function identifies the k nearest neighbors to a given query point \n * from a collection of available points in the space.\n *\n * @param points A list of Point objects representing the available points in the space.\n * @type points std::vector<Point>\n *\n * @param query_point The Point object for which we want to find the nearest neighbors.\n * @type query_point Point\n *\n * @param k The number of nearest neighbors to find.\n * @type k int\n *\n * @return A list of the k nearest Point objects to the query_point.\n * @rtype std::vector<Point>\n */\n\nstd::vector<Point> find_k_nearest_neighbors(const std::vector<Point>& points, const Point& query_point, int k);", "test_code": "TEST_CASE(\"Find k nearest neighbors simple case\") {\n    std::vector<Point> points = {\n        Point(1, 2),\n        Point(3, 4),\n        Point(1, -1),\n        Point(5, 2)\n    };\n    Point query_point(2, 2);\n    int k = 2;\n    auto result = find_k_nearest_neighbors(points, query_point, k);\n\n    REQUIRE(result.size() == 2);\n    REQUIRE(contains_point(result, Point(1, 2)));\n    REQUIRE(contains_point(result, Point(3, 4)));\n}\n\nTEST_CASE(\"Find k nearest neighbors exact match\") {\n    std::vector<Point> points = {\n        Point(1, 2),\n        Point(2, 2),\n        Point(3, 3)\n    };\n    Point query_point(2, 2);\n    int k = 1;\n    auto result = find_k_nearest_neighbors(points, query_point, k);\n\n    REQUIRE(result.size() == 1);\n    REQUIRE(std::fabs(result[0].x - 2.0) < 0.001);\n    REQUIRE(std::fabs(result[0].y - 2.0) < 0.001);\n}\n\nTEST_CASE(\"Find k nearest neighbors larger k\") {\n    std::vector<Point> points = {\n        Point(1, 2),\n        Point(3, 4),\n        Point(1, -1),\n        Point(5, 2)\n    };\n    Point query_point(2, 2);\n    int k = 5; // k is larger than the number of points\n    auto result = find_k_nearest_neighbors(points, query_point, k);\n\n    REQUIRE(result.size() == 4);\n}\n\nTEST_CASE(\"Find k nearest neighbors empty points\") {\n    std::vector<Point> points = {};\n    Point query_point(2, 2);\n    int k = 3;\n    auto result = find_k_nearest_neighbors(points, query_point, k);\n\n    REQUIRE(result.size() == 0);\n}\n\nTEST_CASE(\"Find k nearest neighbors all points equidistant\") {\n    std::vector<Point> points = {\n        Point(2, 3),\n        Point(3, 2),\n        Point(1, 2),\n        Point(2, 1)\n    };\n    Point query_point(2, 2);\n    int k = 2;\n    auto result = find_k_nearest_neighbors(points, query_point, k);\n\n    REQUIRE(result.size() == 2);\n    REQUIRE(contains_point(result, Point(2, 3)));\n    REQUIRE(contains_point(result, Point(3, 2)));\n}", "prompt": "please write a cpp function , the function signature as below \nclass Point {\npublic:\n    double x; // X-coordinate of the point\n    double y; // Y-coordinate of the point\n\n    // Constructor for the Point class\n    Point(double x, double y) : x(x), y(y) {}\n\n    // Calculate the Euclidean distance to another point\n    double distance_to(const Point& other) const;\n};\n/**\n * @brief Finds the k nearest neighbors to the specified query point.\n *\n * This function identifies the k nearest neighbors to a given query point \n * from a collection of available points in the space.\n *\n * @param points A list of Point objects representing the available points in the space.\n * @type points std::vector<Point>\n *\n * @param query_point The Point object for which we want to find the nearest neighbors.\n * @type query_point Point\n *\n * @param k The number of nearest neighbors to find.\n * @type k int\n *\n * @return A list of the k nearest Point objects to the query_point.\n * @rtype std::vector<Point>\n */\n\nstd::vector<Point> find_k_nearest_neighbors(const std::vector<Point>& points, const Point& query_point, int k);", "addition_info": ""}, "java": {"code_signature": "/**\n * Given a set of points and a query point, write an algorithm to find the K nearest neighbors to the query point. The algorithm should efficiently handle large datasets, and the output should include the coordinates or indices of these neighbors.\n *\n * @param points Array of points from which to find the nearest neighbors.\n * @param queryPoint The point to which the nearest neighbors are found.\n * @param k The number of nearest neighbors to find.\n * @return An array containing the k nearest neighbors.\n */\nclass Point {\n    double x, y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public double distanceTo(Point other) {\n        return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2));\n    }\n}\npublic Point[] findKNearestNeighbors(Point[] points, Point queryPoint, int k) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; \nimport static org.junit.Assert.assertEquals; \nimport static org.junit.Assert.assertTrue; \n\nimport org.real.temp.*;\n\npublic class Tester {\n    @Test\n    public void testFindKNearestNeighbors_SimpleCase() {\n        Answer knn = new Answer();\n        Answer.Point[] points = {\n                new Answer.Point(1, 2),\n                new Answer.Point(3, 4),\n                new Answer.Point(1, -1),\n                new Answer.Point(5, 2)\n        };\n        Answer.Point queryPoint = new Answer.Point(2, 2);\n        int k = 2;\n\n        Answer.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(2, result.length);\n        assertTrue(containsPoint(result, new Answer.Point(1, 2)));\n        assertTrue(containsPoint(result, new Answer.Point(3, 4)));\n    }\n\n    @Test\n    public void testFindKNearestNeighbors_ExactMatch() {\n        Answer knn = new Answer();\n        Answer.Point[] points = {\n                new Answer.Point(1, 2),\n                new Answer.Point(2, 2),\n                new Answer.Point(3, 3)\n        };\n        Answer.Point queryPoint = new Answer.Point(2, 2);\n        int k = 1;\n\n        Answer.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(1, result.length);\n        assertEquals(2.0, result[0].x, 0.001);\n        assertEquals(2.0, result[0].y, 0.001);\n    }\n\n    @Test\n    public void testFindKNearestNeighbors_LargerK() {\n        Answer knn = new Answer();\n        Answer.Point[] points = {\n                new Answer.Point(1, 2),\n                new Answer.Point(3, 4),\n                new Answer.Point(1, -1),\n                new Answer.Point(5, 2)\n        };\n        Answer.Point queryPoint = new Answer.Point(2, 2);\n        int k = 5;  // k is larger than the number of points\n\n        Answer.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(4, result.length);\n    }\n\n    @Test\n    public void testFindKNearestNeighbors_EmptyPoints() {\n        Answer knn = new Answer();\n        Answer.Point[] points = {};\n        Answer.Point queryPoint = new Answer.Point(2, 2);\n        int k = 3;\n\n        Answer.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(0, result.length);\n    }\n\n    @Test\n    public void testFindKNearestNeighbors_AllPointsEquidistant() {\n        Answer knn = new Answer();\n        Answer.Point[] points = {\n                new Answer.Point(2, 3),\n                new Answer.Point(3, 2),\n                new Answer.Point(1, 2),\n                new Answer.Point(2, 1)\n        };\n        Answer.Point queryPoint = new Answer.Point(2, 2);\n        int k = 2;\n\n        Answer.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(2, result.length);\n        assertTrue(containsPoint(result, new Answer.Point(2, 3)));\n        assertTrue(containsPoint(result, new Answer.Point(3, 2)));\n    }\n\n    private boolean containsPoint(Answer.Point[] points, Answer.Point point) {\n        for (Answer.Point p : points) {\n            if (Math.abs(p.x - point.x) < 0.001 && Math.abs(p.y - point.y) < 0.001) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Given a set of points and a query point, write an algorithm to find the K nearest neighbors to the query point. The algorithm should efficiently handle large datasets, and the output should include the coordinates or indices of these neighbors.\n *\n * @param points Array of points from which to find the nearest neighbors.\n * @param queryPoint The point to which the nearest neighbors are found.\n * @param k The number of nearest neighbors to find.\n * @return An array containing the k nearest neighbors.\n */\nclass Point {\n    double x, y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public double distanceTo(Point other) {\n        return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2));\n    }\n}\npublic Point[] findKNearestNeighbors(Point[] points, Point queryPoint, int k) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 177, "code_type": "method", "original_language": "java", "file_path": "HBV501G\\821afc5fc1b0082388f558deb2cbfcaf4af6a000\\Backend\\src\\main\\java\\hbv501g\\Utils\\PasswordUtils.java", "question_type": "Security", "summary": "Generates a 16-byte random salt value and hashes the password with that salt value and the SHA-256 hash algorithm", "language_version_list": {"python": {"code_signature": "import hashlib\nimport os\n\n\ndef hash_password_with_salt(password: str) -> bytes:\n    \"\"\"\n    Generates a 16-byte random salt value, hashes the provided password with that salt\n    using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n\n    Args:\n        password (str): The password to be hashed.\n\n    Returns:\n        bytes: A byte array containing the salt followed by the hashed password.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    def test_hashPasswordWithSaltLength(self):\n        \"\"\"Test that the hashPasswordWithSalt method returns a byte array with the correct length.\"\"\"\n        password = \"testPassword\"\n        result = hash_password_with_salt(password)\n        # SHA-256 hash length is 32 bytes, and the salt length is 16 bytes\n        self.assertEqual(len(result), 48, \"The combined salt and hashed password length should be 48 bytes.\")\n\n    def test_saltIsIncludedInResult(self):\n        \"\"\"Test that the salt is correctly generated and included in the hash result.\"\"\"\n        password = \"testPassword\"\n        result = hash_password_with_salt(password)\n        salt = result[:16]  # First 16 bytes represent the salt\n        self.assertIsNotNone(salt, \"Salt should not be None.\")\n        self.assertEqual(len(salt), 16, \"Salt length should be 16 bytes.\")\n\n    def test_differentPasswordsProduceDifferentHashes(self):\n        \"\"\"Test that two different passwords produce different hashes, even with the same salt.\"\"\"\n        password1 = \"password123\"\n        password2 = \"password456\"\n        hash1 = hash_password_with_salt(password1)\n        hash2 = hash_password_with_salt(password2)\n        self.assertNotEqual(hash1, hash2, \"Different passwords should produce different hashes.\")\n\n    def test_samePasswordDifferentSalts(self):\n        \"\"\"Test that the same password produces different hashes when hashed with different salts.\"\"\"\n        password = \"password123\"\n        hash1 = hash_password_with_salt(password)\n        hash2 = hash_password_with_salt(password)\n        # The salt is generated randomly, so the hashes should be different.\n        self.assertNotEqual(hash1, hash2, \"The same password should produce different hashes with different salts.\")", "prompt": "please write a python function , the function signature as below import hashlib\nimport os\n\n\ndef hash_password_with_salt(password: str) -> bytes:\n    \"\"\"\n    Generates a 16-byte random salt value, hashes the provided password with that salt\n    using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n\n    Args:\n        password (str): The password to be hashed.\n\n    Returns:\n        bytes: A byte array containing the salt followed by the hashed password.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Generates a 16-byte random salt value, hashes the provided password with that salt\n *        using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n *\n * @param password The password to be hashed.\n *\n * @return A byte array containing the salt followed by the hashed password.\n */\nstd::vector<uint8_t> hash_password_with_salt(const std::string& password);", "test_code": "TEST_CASE(\"Hash Password with Salt Length\", \"[hashing]\") {\n    /* Test that the hashPasswordWithSalt method returns a byte array with the correct length. */\n    std::string password = \"testPassword\";\n    auto result = hash_password_with_salt(password);\n    // SHA-256 hash length is 32 bytes, and the salt length is 16 bytes\n    REQUIRE(result.size() == 48);\n}\n\nTEST_CASE(\"Salt Is Included In Result\", \"[hashing]\") {\n    /* Test that the salt is correctly generated and included in the hash result. */\n    std::string password = \"testPassword\";\n    auto result = hash_password_with_salt(password);\n    std::vector<uint8_t> salt(result.begin(), result.begin() + 16);  // First 16 bytes represent the salt\n    REQUIRE(salt.size() == 16);\n    REQUIRE(salt.data() != nullptr);\n}\n\nTEST_CASE(\"Different Passwords Produce Different Hashes\", \"[hashing]\") {\n    /* Test that two different passwords produce different hashes, even with the same salt. */\n    std::string password1 = \"password123\";\n    std::string password2 = \"password456\";\n    auto hash1 = hash_password_with_salt(password1);\n    auto hash2 = hash_password_with_salt(password2);\n    REQUIRE(hash1 != hash2);\n}\n\nTEST_CASE(\"Same Password Different Salts\", \"[hashing]\") {\n    /* Test that the same password produces different hashes when hashed with different salts. */\n    std::string password = \"password123\";\n    auto hash1 = hash_password_with_salt(password);\n    auto hash2 = hash_password_with_salt(password);\n    // The salt is generated randomly, so the hashes should be different.\n    REQUIRE(hash1 != hash2);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Generates a 16-byte random salt value, hashes the provided password with that salt\n *        using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n *\n * @param password The password to be hashed.\n *\n * @return A byte array containing the salt followed by the hashed password.\n */\nstd::vector<uint8_t> hash_password_with_salt(const std::string& password);", "addition_info": ""}, "java": {"code_signature": "/**\n * Generates a 16-byte random salt value, hashes the provided password with that salt\n * using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n *\n * @param password The password to be hashed.\n * @return A byte array containing the salt followed by the hashed password.\n * @throws NoSuchAlgorithmException If the SHA-256 algorithm is not available.\n */\npublic static byte[] hashPasswordWithSalt(String password) throws NoSuchAlgorithmException {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*; \nimport java.security.NoSuchAlgorithmException; \nimport org.real.temp.*;\nimport java.util.Arrays;\n\n\npublic class Tester {\n\n    /**\n     * Test that the hashPasswordWithSalt method returns a byte array with the correct length.\n     * The length should be 48 bytes (16 bytes of salt + 32 bytes of SHA-256 hash).\n     */\n    @Test\n    public void testHashPasswordWithSaltLength() throws NoSuchAlgorithmException {\n        String password = \"testPassword\";\n        byte[] result = Answer.hashPasswordWithSalt(password);\n\n        // SHA-256 hash length is 32 bytes, and the salt length is 16 bytes\n        assertEquals(48, result.length);\n    }\n\n    /**\n     * Test that the salt is correctly generated and included in the hash result.\n     * The first 16 bytes of the result should represent the salt.\n     */\n    @Test\n    public void testSaltIsIncludedInResult() throws NoSuchAlgorithmException {\n        String password = \"testPassword\";\n        byte[] result = Answer.hashPasswordWithSalt(password);\n\n        byte[] salt = Arrays.copyOfRange(result, 0, 16);\n\n        assertEquals(16, salt.length);\n    }\n\n    /**\n     * Test that two different passwords produce different hashes, even with the same salt.\n     */\n    @Test\n    public void testDifferentPasswordsProduceDifferentHashes() throws NoSuchAlgorithmException {\n        String password1 = \"password123\";\n        String password2 = \"password456\";\n\n        byte[] hash1 = Answer.hashPasswordWithSalt(password1);\n        byte[] hash2 = Answer.hashPasswordWithSalt(password2);\n\n        assertNotEquals(Arrays.toString(hash1), Arrays.toString(hash2), \"Different passwords should produce different hashes.\");\n    }\n\n    /**\n     * Test that the same password produces different hashes when hashed with different salts.\n     */\n    @Test\n    public void testSamePasswordDifferentSalts() throws NoSuchAlgorithmException {\n        String password = \"password123\";\n\n        byte[] hash1 = Answer.hashPasswordWithSalt(password);\n        byte[] hash2 = Answer.hashPasswordWithSalt(password);\n\n        // The salt is generated randomly, so the hashes should be different.\n        assertNotEquals(Arrays.toString(hash1), Arrays.toString(hash2), \"The same password should produce different hashes with different salts.\");\n    }\n\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Generates a 16-byte random salt value, hashes the provided password with that salt\n * using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n *\n * @param password The password to be hashed.\n * @return A byte array containing the salt followed by the hashed password.\n * @throws NoSuchAlgorithmException If the SHA-256 algorithm is not available.\n */\npublic static byte[] hashPasswordWithSalt(String password) throws NoSuchAlgorithmException {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 178, "code_type": "method", "original_language": "java", "file_path": "MatchScope\\b5dcea6053f21d5ece686f03f5006e224e6aa1d1\\src\\main\\java\\com\\matchscope\\Utils.java", "question_type": "Algorithm and data structure", "summary": "Find the longest non-decreasing subsequence in the given list.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef find_longest_non_decreasing_subsequence(nums: List[int]) -> List[int]:\n    \"\"\"Find the longest non-decreasing subsequence in the given list.\n\n    Args:\n        nums (List[int]): The input array of integers.\n\n    Returns:\n        List[int]: A list containing the longest non-decreasing subsequence.\n    \"\"\"\n", "test_code": "import unittest\nfrom typing import List\n\n\nclass TestAnswer(unittest.TestCase):\n\n    def test_non_decreasing_sequence(self):\n        nums = [5, 7, 4, 8, 6, 10, 2, 11]\n        expected: List[int] = [5, 7, 8, 10, 11]\n        self.assertEqual(expected, find_longest_non_decreasing_subsequence(nums))\n\n    def test_all_increasing(self):\n        nums = [1, 2, 3, 4, 5]\n        expected: List[int] = [1, 2, 3, 4, 5]\n        self.assertEqual(expected, find_longest_non_decreasing_subsequence(nums))\n\n    def test_all_decreasing(self):\n        nums = [5, 4, 3, 2, 1]\n        expected: List[int] = [5]\n        self.assertEqual(expected, find_longest_non_decreasing_subsequence(nums))\n\n    def test_single_element(self):\n        nums = [10]\n        expected: List[int] = [10]\n        self.assertEqual(expected, find_longest_non_decreasing_subsequence(nums))\n\n    def test_empty_array(self):\n        nums = []\n        expected: List[int] = []\n        self.assertEqual(expected, find_longest_non_decreasing_subsequence(nums))", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_longest_non_decreasing_subsequence(nums: List[int]) -> List[int]:\n    \"\"\"Find the longest non-decreasing subsequence in the given list.\n\n    Args:\n        nums (List[int]): The input array of integers.\n\n    Returns:\n        List[int]: A list containing the longest non-decreasing subsequence.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds the longest non-decreasing subsequence in the given list of integers.\n *\n * @param nums The input array of integers.\n *\n * @return A vector containing the longest non-decreasing subsequence.\n */\n\nstd::vector<int> find_longest_non_decreasing_subsequence(const std::vector<int>& nums);", "test_code": "TEST_CASE(\"Test longest non-decreasing subsequence\") {\n    SECTION(\"Non-decreasing sequence\") {\n        std::vector<int> nums = {5, 7, 4, 8, 6, 10, 2, 11};\n        std::vector<int> expected = {5, 7, 8, 10, 11};\n        REQUIRE(expected == find_longest_non_decreasing_subsequence(nums));\n    }\n\n    SECTION(\"All increasing\") {\n        std::vector<int> nums = {1, 2, 3, 4, 5};\n        std::vector<int> expected = {1, 2, 3, 4, 5};\n        REQUIRE(expected == find_longest_non_decreasing_subsequence(nums));\n    }\n\n    SECTION(\"All decreasing\") {\n        std::vector<int> nums = {5, 4, 3, 2, 1};\n        std::vector<int> expected = {5};\n        REQUIRE(expected == find_longest_non_decreasing_subsequence(nums));\n    }\n\n    SECTION(\"Single element\") {\n        std::vector<int> nums = {10};\n        std::vector<int> expected = {10};\n        REQUIRE(expected == find_longest_non_decreasing_subsequence(nums));\n    }\n\n    SECTION(\"Empty array\") {\n        std::vector<int> nums = {};\n        std::vector<int> expected = {};\n        REQUIRE(expected == find_longest_non_decreasing_subsequence(nums));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds the longest non-decreasing subsequence in the given list of integers.\n *\n * @param nums The input array of integers.\n *\n * @return A vector containing the longest non-decreasing subsequence.\n */\n\nstd::vector<int> find_longest_non_decreasing_subsequence(const std::vector<int>& nums);", "addition_info": ""}, "java": {"code_signature": "/**\n * Find the longest non-decreasing subsequence in the given list.\n *\n * @param nums The input array of integers.\n * @return A list containing the longest non-decreasing subsequence.\n */\npublic static List<Integer> findLongestNonDecreasingSubsequence(int[] nums) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; // JUnit 4 Test annotation\nimport static org.junit.Assert.assertEquals; // JUnit 4 assertEquals\nimport java.util.Arrays;\nimport java.util.List;\n\n\nimport org.real.temp.*;\npublic class Tester {\n    @Test\n    public void testNonDecreasingSequence() {\n        int[] nums = {5, 7, 4, 8, 6, 10, 2, 11};\n        List<Integer> expected = Arrays.asList(5, 7, 8, 10, 11);\n        assertEquals(expected, Answer.findLongestNonDecreasingSubsequence(nums));\n    }\n\n    @Test\n    public void testAllIncreasing() {\n        int[] nums = {1, 2, 3, 4, 5};\n        List<Integer> expected = Arrays.asList(1, 2, 3, 4, 5);\n        assertEquals(expected, Answer.findLongestNonDecreasingSubsequence(nums));\n    }\n\n    @Test\n    public void testAllDecreasing() {\n        int[] nums = {5, 4, 3, 2, 1};\n        List<Integer> expected = Arrays.asList(5);\n        assertEquals(expected, Answer.findLongestNonDecreasingSubsequence(nums));\n    }\n\n    @Test\n    public void testSingleElement() {\n        int[] nums = {10};\n        List<Integer> expected = Arrays.asList(10);\n        assertEquals(expected, Answer.findLongestNonDecreasingSubsequence(nums));\n    }\n\n    @Test\n    public void testEmptyArray() {\n        int[] nums = {};\n        List<Integer> expected = Arrays.asList();\n        assertEquals(expected, Answer.findLongestNonDecreasingSubsequence(nums));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Find the longest non-decreasing subsequence in the given list.\n *\n * @param nums The input array of integers.\n * @return A list containing the longest non-decreasing subsequence.\n */\npublic static List<Integer> findLongestNonDecreasingSubsequence(int[] nums) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 179, "code_type": "method", "original_language": "java", "file_path": "Learning-Tomorrow\\0c232e5e92928c528dc4e4ef09a3e024b69d3cc0\\LearningTomorrow\\LearningTomorrowEditor\\LTEditor.java", "question_type": "File operations and I/O operation", "summary": "Copies all files and subdirectories in a directory to the specified directory", "language_version_list": {"python": {"code_signature": "def copy_directory(source_dir: str, target_dir: str) -> None:\n    \"\"\"\n    Copies all files and subdirectories from the source directory to the target directory.\n\n    Args:\n        source_dir (str): The source directory from which files and subdirectories will be copied.\n        target_dir (str): The target directory to which files and subdirectories will be copied.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import os\nimport shutil\nimport unittest\n\n\nclass TestDirectoryOperations(unittest.TestCase):\n\n    def setUp(self):\n        self.source_dir = \"testSourceDir\"\n        self.target_dir = \"testTargetDir\"\n\n        os.makedirs(self.source_dir, exist_ok=True)\n        os.makedirs(self.target_dir, exist_ok=True)\n\n    def tearDown(self):\n        self.delete_directory(self.source_dir)\n        self.delete_directory(self.target_dir)\n\n    def delete_directory(self, dir_path):\n        if os.path.exists(dir_path):\n            shutil.rmtree(dir_path)\n\n    def test_copy_empty_directory(self):\n        # Simulating Answer.copyDirectory functionality\n        copy_directory(self.source_dir, self.target_dir)\n\n        self.assertTrue(os.path.exists(self.target_dir), \"Target directory should exist after copying.\")\n        self.assertTrue(os.path.isdir(self.target_dir), \"Target directory should be a directory.\")\n        self.assertEqual(len(os.listdir(self.target_dir)), 0, \"Target directory should be empty.\")\n\n    def test_copy_directory_with_files(self):\n        test_file = os.path.join(self.source_dir, \"testFile.txt\")\n        with open(test_file, 'w') as f:\n            f.write(\"Sample content\")\n\n        copy_directory(self.source_dir, self.target_dir)\n\n        copied_file = os.path.join(self.target_dir, \"testFile.txt\")\n        self.assertTrue(os.path.exists(copied_file), \"File should be copied to target directory.\")\n        self.assertEqual(os.path.getsize(test_file), os.path.getsize(copied_file),\n                         \"File size should be the same after copying.\")\n\n    def test_non_existent_source_directory(self):\n        non_existent_dir = \"nonExistentDir\"\n\n        with self.assertRaises(Exception) as context:\n            copy_directory(non_existent_dir, self.target_dir)\n\n        self.assertEqual(str(context.exception), \"Source directory does not exist.\")\n\n    def test_copy_directory_with_subdirectories(self):\n        sub_dir = os.path.join(self.source_dir, \"subDir\")\n        os.makedirs(sub_dir, exist_ok=True)\n        test_file = os.path.join(sub_dir, \"testFile.txt\")\n        with open(test_file, 'w') as f:\n            f.write(\"Sample content in subdirectory\")\n\n        copy_directory(self.source_dir, self.target_dir)\n\n        copied_sub_dir = os.path.join(self.target_dir, \"subDir\")\n        copied_file = os.path.join(copied_sub_dir, \"testFile.txt\")\n\n        self.assertTrue(os.path.exists(copied_sub_dir), \"Subdirectory should be copied to target directory.\")\n        self.assertTrue(os.path.exists(copied_file), \"File within subdirectory should be copied to target directory.\")\n\n    def test_overwrite_file_in_target_directory(self):\n        # Create a source file with some content\n        test_file = os.path.join(self.source_dir, \"testFile.txt\")\n        with open(test_file, 'w') as f:\n            f.write(\"Source content\")\n\n        # Create a target file with different content\n        target_file = os.path.join(self.target_dir, \"testFile.txt\")\n        with open(target_file, 'w') as f:\n            f.write(\"Target content\")\n\n        # Copy the directory, which should overwrite the target file\n        copy_directory(self.source_dir, self.target_dir)\n\n        copied_file = os.path.join(self.target_dir, \"testFile.txt\")\n        self.assertTrue(os.path.exists(copied_file), \"File should be copied to target directory.\")\n\n        # Check that the content of the file is now the same as the source file\n        with open(copied_file, 'r') as f:\n            copied_content = f.read()\n\n        self.assertEqual(copied_content, \"Source content\",\n                         \"File in target directory should be overwritten with source content.\")\n", "prompt": "please write a python function , the function signature as below def copy_directory(source_dir: str, target_dir: str) -> None:\n    \"\"\"\n    Copies all files and subdirectories from the source directory to the target directory.\n\n    Args:\n        source_dir (str): The source directory from which files and subdirectories will be copied.\n        target_dir (str): The target directory to which files and subdirectories will be copied.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Copies all files and subdirectories from the source directory to the target directory.\n *\n * @param source_dir The source directory from which files and subdirectories will be copied.\n * @type source_dir const std::string&\n *\n * @param target_dir The target directory to which files and subdirectories will be copied.\n * @type target_dir const std::string&\n *\n * @return void\n */\nvoid copy_directory(const std::string& source_dir, const std::string& target_dir);", "test_code": "TEST_CASE_METHOD(TestDirectoryOperations, \"Copy empty directory\") {\n    copy_directory(source_dir, target_dir);\n\n    REQUIRE(fs::exists(target_dir));\n    REQUIRE(fs::is_directory(target_dir));\n    REQUIRE(fs::is_empty(target_dir));\n}\n\nTEST_CASE_METHOD(TestDirectoryOperations, \"Copy directory with files\") {\n    std::string test_file = (fs::path(source_dir) / \"testFile.txt\").string();\n    {\n        std::ofstream f(test_file);\n        f << \"Sample content\";\n    }\n\n    copy_directory(source_dir, target_dir);\n\n    std::string copied_file = (fs::path(target_dir) / \"testFile.txt\").string();\n    REQUIRE(fs::exists(copied_file));\n    REQUIRE(fs::file_size(test_file) == fs::file_size(copied_file));\n}\n\nTEST_CASE_METHOD(TestDirectoryOperations, \"Non-existent source directory\") {\n    std::string non_existent_dir = \"nonExistentDir\";\n\n    REQUIRE_THROWS_AS(copy_directory(non_existent_dir, target_dir), std::invalid_argument);\n}\n\nTEST_CASE_METHOD(TestDirectoryOperations, \"Copy directory with subdirectories\") {\n    std::string sub_dir = (fs::path(source_dir) / \"subDir\").string();\n    fs::create_directories(sub_dir);\n    std::string test_file = (fs::path(sub_dir) / \"testFile.txt\").string();\n    {\n        std::ofstream f(test_file);\n        f << \"Sample content in subdirectory\";\n    }\n\n    copy_directory(source_dir, target_dir);\n\n    std::string copied_sub_dir = (fs::path(target_dir) / \"subDir\").string();\n    std::string copied_file = (fs::path(copied_sub_dir) / \"testFile.txt\").string();\n\n    REQUIRE(fs::exists(copied_sub_dir));\n    REQUIRE(fs::exists(copied_file));\n}\n\nTEST_CASE_METHOD(TestDirectoryOperations, \"Overwrite file in target directory\") {\n    std::string test_file = (fs::path(source_dir) / \"testFile.txt\").string();\n    {\n        std::ofstream f(test_file);\n        f << \"Source content\";\n    }\n\n    std::string target_file = (fs::path(target_dir) / \"testFile.txt\").string();\n    {\n        std::ofstream f(target_file);\n        f << \"Target content\";\n    }\n\n    copy_directory(source_dir, target_dir);\n\n    std::string copied_file = (fs::path(target_dir) / \"testFile.txt\").string();\n    REQUIRE(fs::exists(copied_file));\n\n    std::ifstream f(copied_file);\n    std::string copied_content((std::istreambuf_iterator<char>(f)), std::istreambuf_iterator<char>());\n\n    REQUIRE(copied_content == \"Source content\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Copies all files and subdirectories from the source directory to the target directory.\n *\n * @param source_dir The source directory from which files and subdirectories will be copied.\n * @type source_dir const std::string&\n *\n * @param target_dir The target directory to which files and subdirectories will be copied.\n * @type target_dir const std::string&\n *\n * @return void\n */\nvoid copy_directory(const std::string& source_dir, const std::string& target_dir);", "addition_info": ""}, "java": {"code_signature": "/**\n* Copies all files and subdirectories from the source directory to the target directory.\n*\n* @param sourceDir The source directory from which files and subdirectories will be copied.\n* @param targetDir The target directory to which files and subdirectories will be copied.\n* @throws IOException If an I/O error occurs while copying files or directories.\n*/\npublic static void copyDirectory(File sourceDir, File targetDir) throws IOException {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport org.junit.After;\nimport org.junit.Before;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\n\nimport static org.junit.Assert.*; // Changed from org.junit.jupiter.api.Assertions to org.junit.Assert\n\nimport org.real.temp.Answer.*;\n\npublic class Tester {\n    private File sourceDir;\n    private File targetDir;\n\n    @Before\n    public void setUp() throws IOException {\n        sourceDir = new File(\"testSourceDir\");\n        targetDir = new File(\"testTargetDir\");\n\n        if (!sourceDir.exists()) {\n            sourceDir.mkdir();\n        }\n\n        if (!targetDir.exists()) {\n            targetDir.mkdir();\n        }\n    }\n\n    @After\n    public void tearDown() {\n        deleteDirectory(sourceDir);\n        deleteDirectory(targetDir);\n    }\n\n    /**\n     * Test copying an empty directory.\n     */\n    @Test\n    public void testCopyEmptyDirectory() throws IOException {\n        Answer.copyDirectory(sourceDir, targetDir);\n        assertTrue(\"Target directory should exist after copying.\", targetDir.exists());\n        assertTrue(\"Target directory should be a directory.\", targetDir.isDirectory());\n        assertEquals(\"Target directory should be empty.\", 0, targetDir.listFiles().length);\n    }\n\n    /**\n     * Test copying a directory with files.\n     */\n    @Test\n    public void testCopyDirectoryWithFiles() throws IOException {\n        File testFile = new File(sourceDir, \"testFile.txt\");\n        Files.createFile(testFile.toPath());\n\n        Answer.copyDirectory(sourceDir, targetDir);\n        File copiedFile = new File(targetDir, \"testFile.txt\");\n\n        assertTrue(\"File should be copied to target directory.\", copiedFile.exists());\n        assertEquals(\"File size should be the same after copying.\", testFile.length(), copiedFile.length());\n    }\n\n    /**\n     * Test handling of non-existent source directory.\n     */\n    @Test(expected = Exception.class) // Changed to expected for JUnit 4\n    public void testNonExistentSourceDirectory() throws IOException {\n        File nonExistentDir = new File(\"nonExistentDir\");\n        Answer.copyDirectory(nonExistentDir, targetDir); // No need for assertThrows\n    }\n\n    /**\n     * Test copying a directory with subdirectories.\n     */\n    @Test\n    public void testCopyDirectoryWithSubdirectories() throws IOException {\n        File subDir = new File(sourceDir, \"subDir\");\n        subDir.mkdir();\n        File testFile = new File(subDir, \"testFile.txt\");\n        Files.createFile(testFile.toPath());\n\n        Answer.copyDirectory(sourceDir, targetDir);\n        File copiedSubDir = new File(targetDir, \"subDir\");\n        File copiedFile = new File(copiedSubDir, \"testFile.txt\");\n\n        assertTrue(\"Subdirectory should be copied to target directory.\", copiedSubDir.exists());\n        assertTrue(\"File within subdirectory should be copied to target directory.\", copiedFile.exists());\n    }\n\n    /**\n     * Test overwriting files in the target directory.\n     */\n    @Test\n    public void testOverwriteFileInTargetDirectory() throws IOException {\n        // Create a source file with some content\n        File testFile = new File(sourceDir, \"testFile.txt\");\n        Files.writeString(testFile.toPath(), \"Source content\");\n\n        // Create a target file with different content\n        File targetFile = new File(targetDir, \"testFile.txt\");\n        Files.writeString(targetFile.toPath(), \"Target content\");\n\n        // Copy the directory, which should overwrite the target file\n        Answer.copyDirectory(sourceDir, targetDir);\n        File copiedFile = new File(targetDir, \"testFile.txt\");\n\n        assertTrue(\"File should be copied to target directory.\", copiedFile.exists());\n\n        // Check that the content of the file is now the same as the source file\n        String copiedContent = Files.readString(copiedFile.toPath());\n        assertEquals(\"File in target directory should be overwritten with source content.\", \"Source content\", copiedContent);\n    }\n\n    /**\n     * Helper method to delete a directory and its contents.\n     *\n     * @param dir The directory to delete.\n     */\n    private void deleteDirectory(File dir) {\n        File[] files = dir.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                if (file.isDirectory()) {\n                    deleteDirectory(file);\n                } else {\n                    file.delete();\n                }\n            }\n        }\n        dir.delete();\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n* Copies all files and subdirectories from the source directory to the target directory.\n*\n* @param sourceDir The source directory from which files and subdirectories will be copied.\n* @param targetDir The target directory to which files and subdirectories will be copied.\n* @throws IOException If an I/O error occurs while copying files or directories.\n*/\npublic static void copyDirectory(File sourceDir, File targetDir) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 180, "code_type": "method", "original_language": "java", "file_path": "Java-Granulator\\01568ae1599ea327aae81bdd2e3ee9f1cac53d8a\\src\\model\\LoudnessDensity.java", "question_type": "Data processing and transformation", "summary": "Implement binary search to find the target or the location closest to the target in the sorted array", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef binary_search_closest(array: List[int], target: int) -> int:\n    \"\"\"\n    Performs a binary search to find the index of the target value in a sorted array.\n    If the target value is not found, it returns the index of the closest value.\n\n    Args:\n        array (List[int]): The sorted array in which to search.The sorted array in which to search.\n        target (int): The target value to search for.\n\n    Returns:\n        int: The index of the target or the index of the closest value if the target is not found.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestBinarySearchClosest(unittest.TestCase):\n\n    def test_target_present(self):\n        \"\"\"Test when the target is present in the array.\"\"\"\n        array = [1, 3, 5, 7, 9, 11]\n        target = 7\n        result = binary_search_closest(array, target)\n        self.assertEqual(result, 3, \"Target should be found at index 3.\")\n\n    def test_closest_element_smaller(self):\n        \"\"\"Test when the target is not present and the closest element is smaller.\"\"\"\n        array = [1, 3, 5, 7, 9, 11]\n        target = 6\n        result = binary_search_closest(array, target)\n        self.assertEqual(result, 2, \"Closest element should be 5 at index 2.\")\n\n    def test_closest_element_larger(self):\n        \"\"\"Test when the target is not present and the closest element is larger.\"\"\"\n        array = [1, 3, 5, 7, 9, 11]\n        target = 8\n        result = binary_search_closest(array, target)\n        self.assertEqual(result, 3, \"Closest element should be 7 at index 3.\")\n\n    def test_target_smaller_than_all(self):\n        \"\"\"Test when the target is smaller than all elements in the array.\"\"\"\n        array = [1, 3, 5, 7, 9, 11]\n        target = 0\n        result = binary_search_closest(array, target)\n        self.assertEqual(result, 0, \"Closest element should be 1 at index 0.\")\n\n    def test_target_larger_than_all(self):\n        \"\"\"Test when the target is larger than all elements in the array.\"\"\"\n        array = [1, 3, 5, 7, 9, 11]\n        target = 12\n        result = binary_search_closest(array, target)\n        self.assertEqual(result, 5, \"Closest element should be 11 at index 5.\")\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef binary_search_closest(array: List[int], target: int) -> int:\n    \"\"\"\n    Performs a binary search to find the index of the target value in a sorted array.\n    If the target value is not found, it returns the index of the closest value.\n\n    Args:\n        array (List[int]): The sorted array in which to search.The sorted array in which to search.\n        target (int): The target value to search for.\n\n    Returns:\n        int: The index of the target or the index of the closest value if the target is not found.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Performs a binary search to find the index of the target value in a sorted array.\n *\n * @param array The sorted array in which to search.\n * @type array std::vector<int>\n *\n * @param target The target value to search for.\n * @type target int\n *\n * @return The index of the target or the index of the closest value if the target is not found.\n * @rtype int\n */\n\nint binary_search_closest(const std::vector<int>& array, int target){}", "test_code": "TEST_CASE(\"TestBinarySearchClosest\") {\n\n    SECTION(\"Target present\") {\n        // Test when the target is present in the array.\n        std::vector<int> array = {1, 3, 5, 7, 9, 11};\n        int target = 7;\n        int result = binary_search_closest(array, target);\n        REQUIRE(result == 3); // Target should be found at index 3.\n    }\n\n    SECTION(\"Closest element smaller\") {\n        // Test when the target is not present and the closest element is smaller.\n        std::vector<int> array = {1, 3, 5, 7, 9, 11};\n        int target = 6;\n        int result = binary_search_closest(array, target);\n        REQUIRE(result == 2); // Closest element should be 5 at index 2.\n    }\n\n    SECTION(\"Closest element larger\") {\n        // Test when the target is not present and the closest element is larger.\n        std::vector<int> array = {1, 3, 5, 7, 9, 11};\n        int target = 8;\n        int result = binary_search_closest(array, target);\n        REQUIRE(result == 3); // Closest element should be 7 at index 3.\n    }\n\n    SECTION(\"Target smaller than all\") {\n        // Test when the target is smaller than all elements in the array.\n        std::vector<int> array = {1, 3, 5, 7, 9, 11};\n        int target = 0;\n        int result = binary_search_closest(array, target);\n        REQUIRE(result == 0); // Closest element should be 1 at index 0.\n    }\n\n    SECTION(\"Target larger than all\") {\n        // Test when the target is larger than all elements in the array.\n        std::vector<int> array = {1, 3, 5, 7, 9, 11};\n        int target = 12;\n        int result = binary_search_closest(array, target);\n        REQUIRE(result == 5); // Closest element should be 11 at index 5.\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Performs a binary search to find the index of the target value in a sorted array.\n *\n * @param array The sorted array in which to search.\n * @type array std::vector<int>\n *\n * @param target The target value to search for.\n * @type target int\n *\n * @return The index of the target or the index of the closest value if the target is not found.\n * @rtype int\n */\n\nint binary_search_closest(const std::vector<int>& array, int target){}", "addition_info": ""}, "java": {"code_signature": "/**\n* Implement binary search to find the target or the location closest to the target in the sorted array\n*\n* @param array  The sorted array in which to search.\n* @param target The target value to search for.\n* @return The index of the target or the index of the closest value if the target is not found.\n*/\npublic static int binarySearchClosest(int[] array, int target) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; // Change this import to JUnit 4\nimport org.junit.After;\nimport org.junit.Before;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport static org.junit.Assert.*; // Change this import to JUnit 4 assertions\n\npublic class Tester {\n\n    private File testFile;\n\n    @Before\n    public void setUp() throws IOException {\n        testFile = new File(\"testFile.txt\");\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(\"Test content\".getBytes());\n        }\n    }\n\n    @After\n    public void tearDown() {\n        if (testFile.exists()) {\n            testFile.delete();\n        }\n    }\n\n    /**\n     * Test reading a file that exists and has content.\n     */\n    @Test\n    public void testReadFileWithContent() throws IOException {\n        byte[] content = Answer.readFileToByteArray(testFile.getAbsolutePath());\n        assertEquals(\"The file content should match the expected string.\", \"Test content\", new String(content));\n    }\n\n    /**\n     * Test reading an empty file.\n     */\n    @Test\n    public void testReadEmptyFile() throws IOException {\n        File emptyFile = new File(\"emptyFile.txt\");\n        emptyFile.createNewFile();\n\n        byte[] content = Answer.readFileToByteArray(emptyFile.getAbsolutePath());\n        assertEquals(\"The content of an empty file should be a byte array of length 0.\", 0, content.length);\n\n        emptyFile.delete();\n    }\n\n    /**\n     * Test reading a file that does not exist.\n     */\n    @Test(expected = Exception.class)\n    public void testReadNonExistentFile() throws IOException {\n        String nonExistentFilePath = \"nonExistentFile.txt\";\n        // Change to JUnit 4's way of asserting exceptions\n        Answer.readFileToByteArray(nonExistentFilePath);\n\n    }\n\n    /**\n     * Test reading a file with special characters in its content.\n     */\n    @Test\n    public void testReadFileWithSpecialCharacters() throws IOException {\n        String specialContent = \"Special content: !@#$%^&*()_+\";\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(specialContent.getBytes());\n        }\n\n        byte[] content = Answer.readFileToByteArray(testFile.getAbsolutePath());\n        assertEquals(\"The file content should match the special characters string.\", specialContent, new String(content));\n    }\n\n    /**\n     * Test reading a large file.\n     */\n    @Test\n    public void testReadLargeFile() throws IOException {\n        byte[] largeContent = new byte[10 * 1024 * 1024]; // 10 MB\n        for (int i = 0; i < largeContent.length; i++) {\n            largeContent[i] = (byte) (i % 256);\n        }\n\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(largeContent);\n        }\n\n        byte[] content = Answer.readFileToByteArray(testFile.getAbsolutePath());\n        assertArrayEquals(\"The content of the large file should match the expected byte array.\", largeContent, content);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n* Implement binary search to find the target or the location closest to the target in the sorted array\n*\n* @param array  The sorted array in which to search.\n* @param target The target value to search for.\n* @return The index of the target or the index of the closest value if the target is not found.\n*/\npublic static int binarySearchClosest(int[] array, int target) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 181, "code_type": "method", "original_language": "java", "file_path": "QRelcome\\d457c56ed9c5c0cad368182cbff2c6006bae3d52\\app\\src\\main\\java\\com\\example\\qrelcome\\CacheUUID.java", "question_type": "File operations and I/O operation", "summary": "Read the file content specified in the file path and return it as a byte array", "language_version_list": {"python": {"code_signature": "def read_file_to_byte_array(file_path: str) -> bytes:\n    \"\"\"\n    Reads the content of the file specified by the file path and returns it as a byte array.\n\n    Args:\n        file_path (str): The path to the file that needs to be read.\n\n    Returns:\n        bytes: A byte array containing the content of the file.\n    \"\"\"", "test_code": "import os\nimport unittest\n\n\nclass TestFileOperations(unittest.TestCase):\n    def setUp(self):\n        self.test_file = \"testFile.txt\"\n        with open(self.test_file, 'wb') as f:\n            f.write(b\"Test content\")\n\n    def tearDown(self):\n        if os.path.exists(self.test_file):\n            os.remove(self.test_file)\n\n    def test_read_file_with_content(self):\n        \"\"\"Test reading a file that exists and has content.\"\"\"\n        content = read_file_to_byte_array(self.test_file)\n        self.assertEqual(b\"Test content\", content, \"The file content should match the expected string.\")\n\n    def test_read_empty_file(self):\n        \"\"\"Test reading an empty file.\"\"\"\n        empty_file = \"emptyFile.txt\"\n        open(empty_file, 'a').close()  # Create an empty file\n        content = read_file_to_byte_array(empty_file)\n        self.assertEqual(len(content), 0, \"The content of an empty file should be a byte array of length 0.\")\n        os.remove(empty_file)  # Cleanup\n\n    def test_read_non_existent_file(self):\n        \"\"\"Test reading a file that does not exist.\"\"\"\n        non_existent_file_path = \"nonExistentFile.txt\"\n        with self.assertRaises(Exception):\n            read_file_to_byte_array(non_existent_file_path)\n\n    def test_read_file_with_special_characters(self):\n        \"\"\"Test reading a file with special characters in its content.\"\"\"\n        special_content = \"Special content: !@#$%^&*()_+\"\n        with open(self.test_file, 'wb') as f:\n            f.write(special_content.encode())\n        content = read_file_to_byte_array(self.test_file)\n        self.assertEqual(special_content.encode(), content, \"The file content should match the special characters string.\")\n\n    def test_read_large_file(self):\n        \"\"\"Test reading a large file.\"\"\"\n        large_content = bytes(range(256)) * (10 * 1024)  # 10 MB\n        with open(self.test_file, 'wb') as f:\n            f.write(large_content)\n        content = read_file_to_byte_array(self.test_file)\n        self.assertEqual(large_content, content, \"The content of the large file should match the expected byte array.\")", "prompt": "please write a python function , the function signature as below def read_file_to_byte_array(file_path: str) -> bytes:\n    \"\"\"\n    Reads the content of the file specified by the file path and returns it as a byte array.\n\n    Args:\n        file_path (str): The path to the file that needs to be read.\n\n    Returns:\n        bytes: A byte array containing the content of the file.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads the content of the file specified by the file path and returns it as a byte array.\n *\n * @param file_path The path to the file that needs to be read.\n * @return A vector of chars containing the content of the file.\n */\nstd::vector<char> read_file_to_byte_array(const std::string& file_path);", "test_code": "TEST_CASE(\"Test reading an empty file\") {\n    std::string empty_file = \"emptyFile.txt\";\n    std::ofstream(empty_file); // Create an empty file\n\n    auto content = read_file_to_byte_array(empty_file);\n    REQUIRE(content.size() == 0);\n\n    std::filesystem::remove(empty_file); // Cleanup\n}\n\nTEST_CASE(\"Test reading a file that does not exist\") {\n    std::string non_existent_file_path = \"nonExistentFile.txt\";\n    REQUIRE_THROWS_AS(read_file_to_byte_array(non_existent_file_path), std::runtime_error);\n}\n\nTEST_CASE(\"Test reading a file with special characters in its content\") {\n    std::string special_content = \"Special content: !@#$%^&*()_+\";\n    std::string test_file = \"testFile.txt\";\n\n    std::ofstream f(test_file, std::ios::binary);\n    f.write(special_content.c_str(), special_content.size());\n\n    auto content = read_file_to_byte_array(test_file);\n    REQUIRE(content == std::vector<char>(special_content.begin(), special_content.end()));\n}\n\nTEST_CASE(\"Test reading a large file\") {\n    std::string test_file = \"testFile.txt\";\n    std::vector<char> large_content(256);\n    for (int i = 0; i < 256; ++i) {\n        large_content[i] = static_cast<char>(i);\n    }\n    large_content.resize(10 * 1024 * 256); // 10 MB\n\n    std::ofstream f(test_file, std::ios::binary);\n    f.write(large_content.data(), large_content.size());\n\n    auto content = read_file_to_byte_array(test_file);\n    REQUIRE(content == large_content);", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads the content of the file specified by the file path and returns it as a byte array.\n *\n * @param file_path The path to the file that needs to be read.\n * @return A vector of chars containing the content of the file.\n */\nstd::vector<char> read_file_to_byte_array(const std::string& file_path);", "addition_info": ""}, "java": {"code_signature": "/**\n* Reads the content of the file specified by the file path and returns it as a byte array.\n*\n* @param filePath The path to the file that needs to be read.\n* @return A byte array containing the content of the file.\n* @throws IOException If an I/O error occurs while reading the file.\n*/\npublic static byte[] readFileToByteArray(String filePath) throws IOException {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nimport org.real.temp.*;\npublic class Tester {\n\n    private File testFile;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        testFile = new File(\"testFile.txt\");\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(\"Test content\".getBytes());\n        }\n    }\n\n    @Before\n    public void tearDown() {\n        if (testFile.exists()) {\n            testFile.delete();\n        }\n    }\n\n    /**\n     * Test reading a file that exists and has content.\n     */\n    @Test\n    public void testReadFileWithContent() throws IOException {\n        byte[] content = Answer.readFileToByteArray(testFile.getAbsolutePath());\n        assertEquals(\"Test content\", new String(content), \"The file content should match the expected string.\");\n    }\n\n    /**\n     * Test reading an empty file.\n     */\n    @Test\n    public void testReadEmptyFile() throws IOException {\n        File emptyFile = new File(\"emptyFile.txt\");\n        emptyFile.createNewFile();\n\n        byte[] content = Answer.readFileToByteArray(emptyFile.getAbsolutePath());\n        assertEquals(0, content.length, \"The content of an empty file should be a byte array of length 0.\");\n\n        emptyFile.delete();\n    }\n\n    /**\n     * Test reading a file that does not exist.\n     */\n    @Test\n    public void testReadNonExistentFile() {\n        String nonExistentFilePath = \"nonExistentFile.txt\";\n        assertThrows(Exception.class, () -> {\n            Answer.readFileToByteArray(nonExistentFilePath);\n        }, \"Reading a non-existent file should throw an IllegalArgumentException.\");\n    }\n\n    /**\n     * Test reading a file with special characters in its content.\n     */\n    @Test\n    public void testReadFileWithSpecialCharacters() throws IOException {\n        String specialContent = \"Special content: !@#$%^&*()_+\";\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(specialContent.getBytes());\n        }\n\n        byte[] content = Answer.readFileToByteArray(testFile.getAbsolutePath());\n        assertEquals(specialContent, new String(content), \"The file content should match the special characters string.\");\n    }\n\n    /**\n     * Test reading a large file.\n     */\n    @Test\n    public void testReadLargeFile() throws IOException {\n        byte[] largeContent = new byte[10 * 1024 * 1024]; // 10 MB\n        for (int i = 0; i < largeContent.length; i++) {\n            largeContent[i] = (byte) (i % 256);\n        }\n\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(largeContent);\n        }\n\n        byte[] content = Answer.readFileToByteArray(testFile.getAbsolutePath());\n        assertArrayEquals(largeContent, content, \"The content of the large file should match the expected byte array.\");\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n* Reads the content of the file specified by the file path and returns it as a byte array.\n*\n* @param filePath The path to the file that needs to be read.\n* @return A byte array containing the content of the file.\n* @throws IOException If an I/O error occurs while reading the file.\n*/\npublic static byte[] readFileToByteArray(String filePath) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 182, "code_type": "method", "original_language": "java", "file_path": "FileCopy\\8f7bd14ff5438f29ba22cdb615e1e5ab8c1d7f82\\src\\FileCopy.java", "question_type": "Configuration and deployment", "summary": "Use a buffer stream to copy the contents of one file to another and measure the time it takes to complete the operation", "language_version_list": {"python": {"code_signature": "def copy_file_with_buffered_stream(source_file_path: str, destination_file_path: str) -> int:\n    \"\"\"\n    Copies the contents of the source file to the destination file using a buffered stream\n    and measures the time it takes to complete the operation.\n\n    Args:\n        source_file_path (str): The path to the source file.\n        destination_file_path (str): The path to the destination file.\n\n    Returns:\n        int: The time taken to copy the file in milliseconds.\n    \"\"\"\n", "test_code": "import os\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n    def setUp(self):\n        self.source_file = \"testSourceFile.txt\"\n        self.destination_file = \"testDestinationFile.txt\"\n        with open(self.source_file, 'wb') as f:\n            f.write(b\"This is a test file content.\")\n\n    def tearDown(self):\n        for file in [self.source_file, self.destination_file]:\n            if os.path.exists(file):\n                os.remove(file)\n\n    def test_copy_file_with_content(self):\n        time_taken = copy_file_with_buffered_stream(self.source_file, self.destination_file)\n        self.assertTrue(os.path.exists(self.destination_file), \"Destination file should exist after copying.\")\n        self.assertEqual(os.path.getsize(self.source_file), os.path.getsize(self.destination_file), \"File sizes should match.\")\n        self.assertGreaterEqual(time_taken, 0, \"Time taken should be non-negative.\")\n\n    def test_copy_empty_file(self):\n        empty_file = \"emptyFile.txt\"\n        with open(empty_file, 'wb') as f:\n            pass  # Create an empty file\n        destination_empty_file = \"destinationEmptyFile.txt\"\n        time_taken = copy_file_with_buffered_stream(empty_file, destination_empty_file)\n        self.assertTrue(os.path.exists(destination_empty_file), \"Destination file should exist after copying.\")\n        self.assertEqual(os.path.getsize(destination_empty_file), 0, \"Empty file should have length 0.\")\n        self.assertGreaterEqual(time_taken, 0, \"Time taken should be non-negative.\")\n        os.remove(empty_file)\n        os.remove(destination_empty_file)\n\n    def test_copy_non_existent_file(self):\n        non_existent_file_path = \"nonExistentFile.txt\"\n        with self.assertRaises(Exception):\n            copy_file_with_buffered_stream(non_existent_file_path, self.destination_file)\n\n    def test_copy_file_overwrite(self):\n        with open(self.destination_file, 'wb') as f:\n            f.write(b\"Old content\")\n        time_taken = copy_file_with_buffered_stream(self.source_file, self.destination_file)\n        self.assertTrue(os.path.exists(self.destination_file), \"Destination file should exist after copying.\")\n        self.assertEqual(os.path.getsize(self.source_file), os.path.getsize(self.destination_file), \"File sizes should match after overwriting.\")\n        self.assertGreater(time_taken, 0, \"Time taken should be greater than 0.\")\n\n    def test_copy_large_file(self):\n        large_content = bytearray(10 * 1024 * 1024)  # 10 MB\n        for i in range(len(large_content)):\n            large_content[i] = i % 256\n        with open(self.source_file, 'wb') as f:\n            f.write(large_content)\n        time_taken = copy_file_with_buffered_stream(self.source_file, self.destination_file)\n        self.assertTrue(os.path.exists(self.destination_file), \"Destination file should exist after copying.\")\n        self.assertEqual(os.path.getsize(self.source_file), os.path.getsize(self.destination_file), \"File sizes should match.\")\n        self.assertGreater(time_taken, 0, \"Time taken should be greater than 0.\")", "prompt": "please write a python function , the function signature as below def copy_file_with_buffered_stream(source_file_path: str, destination_file_path: str) -> int:\n    \"\"\"\n    Copies the contents of the source file to the destination file using a buffered stream\n    and measures the time it takes to complete the operation.\n\n    Args:\n        source_file_path (str): The path to the source file.\n        destination_file_path (str): The path to the destination file.\n\n    Returns:\n        int: The time taken to copy the file in milliseconds.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Copies the contents of the source file to the destination file using a buffered stream\n * and measures the time it takes to complete the operation.\n *\n * @param source_file_path The path to the source file.\n * @param destination_file_path The path to the destination file.\n * @return The time taken to copy the file in milliseconds.\n */\nint copy_file_with_buffered_stream(const std::string& source_file_path, const std::string& destination_file_path);", "test_code": "TEST_CASE_METHOD(FileTest, \"Test copy file with content\") {\n    long long time_taken = copy_file_with_buffered_stream(source_file, destination_file);\n    \n    REQUIRE(std::filesystem::exists(destination_file));\n    REQUIRE(std::filesystem::file_size(source_file) == std::filesystem::file_size(destination_file));\n    REQUIRE(time_taken >= 0);\n}\n\nTEST_CASE(\"Test copy empty file\") {\n    std::string empty_file = \"emptyFile.txt\";\n    std::ofstream f(empty_file, std::ios::binary);\n    \n    std::string destination_empty_file = \"destinationEmptyFile.txt\";\n    long long time_taken = copy_file_with_buffered_stream(empty_file, destination_empty_file);\n\n    REQUIRE(std::filesystem::exists(destination_empty_file));\n    REQUIRE(std::filesystem::file_size(destination_empty_file) == 0);\n    REQUIRE(time_taken >= 0);\n\n    std::filesystem::remove(empty_file);\n    std::filesystem::remove(destination_empty_file);\n}\n\nTEST_CASE(\"Test copy non-existent file\") {\n    std::string non_existent_file_path = \"nonExistentFile.txt\";\n    REQUIRE_THROWS(copy_file_with_buffered_stream(non_existent_file_path, \"someDestination.txt\"));\n}\n\nTEST_CASE_METHOD(FileTest, \"Test copy file overwrite\") {\n    std::ofstream f(destination_file, std::ios::binary);\n    f.write(\"Old content\", 12);\n    \n    long long time_taken = copy_file_with_buffered_stream(source_file, destination_file);\n\n    REQUIRE(std::filesystem::exists(destination_file));\n    REQUIRE(std::filesystem::file_size(source_file) == std::filesystem::file_size(destination_file));\n    REQUIRE(time_taken > 0);\n}\n\nTEST_CASE(\"Test copy large file\") {\n    std::string large_file = \"largeFile.txt\";\n    std::ofstream f(large_file, std::ios::binary);\n    \n    std::vector<char> large_content(10 * 1024 * 1024); // 10 MB\n    for (size_t i = 0; i < large_content.size(); ++i) {\n        large_content[i] = static_cast<char>(i % 256);\n    }\n    f.write(large_content.data(), large_content.size());\n    \n    std::string destination_large_file = \"destinationLargeFile.txt\";\n    long long time_taken = copy_file_with_buffered_stream(large_file, destination_large_file);\n\n    REQUIRE(std::filesystem::exists(destination_large_file));\n    REQUIRE(std::filesystem::file_size(large_file) == std::filesystem::file_size(destination_large_file));\n    REQUIRE(time_taken > 0);\n\n    std::filesystem::remove(large_file);\n    std::filesystem::remove(destination_large_file);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Copies the contents of the source file to the destination file using a buffered stream\n * and measures the time it takes to complete the operation.\n *\n * @param source_file_path The path to the source file.\n * @param destination_file_path The path to the destination file.\n * @return The time taken to copy the file in milliseconds.\n */\nint copy_file_with_buffered_stream(const std::string& source_file_path, const std::string& destination_file_path);", "addition_info": ""}, "java": {"code_signature": "/**\n* Copies the contents of the source file to the destination file using a buffered stream\n* and measures the time it takes to complete the operation.\n*\n* @param sourceFilePath      The path to the source file.\n* @param destinationFilePath The path to the destination file.\n* @return The time taken to copy the file in milliseconds.\n* @throws IOException If an I/O error occurs during the copy operation.\n*/\npublic static long copyFileWithBufferedStream(String sourceFilePath, String destinationFilePath) throws IOException {}", "test_code": "package org.real.temp;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\nimport org.real.temp.*;\n\npublic class Tester {\n    private File sourceFile;\n    private File destinationFile;\n\n    @Before\n    public void setUp() throws IOException {\n        sourceFile = new File(\"testSourceFile.txt\");\n        destinationFile = new File(\"testDestinationFile.txt\");\n\n        try (FileOutputStream fos = new FileOutputStream(sourceFile)) {\n            fos.write(\"This is a test file content.\".getBytes());\n        }\n    }\n\n    @After\n    public void tearDown() {\n        if (sourceFile.exists()) {\n            sourceFile.delete();\n        }\n        if (destinationFile.exists()) {\n            destinationFile.delete();\n        }\n    }\n\n    /**\n     * Test copying a file with content.\n     */\n    @Test\n    public void testCopyFileWithContent() throws IOException {\n        long timeTaken = Answer.copyFileWithBufferedStream(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());\n        assertTrue(\"Destination file should exist after copying.\", destinationFile.exists());\n        assertEquals(\"File sizes should match.\", sourceFile.length(), destinationFile.length());\n        assertTrue(\"Time taken should be non-negative.\", timeTaken >= 0);\n    }\n\n    /**\n     * Test copying an empty file.\n     */\n    @Test\n    public void testCopyEmptyFile() throws IOException {\n        File emptyFile = new File(\"emptyFile.txt\");\n        emptyFile.createNewFile();\n        File destinationEmptyFile = new File(\"destinationEmptyFile.txt\");\n\n        long timeTaken = Answer.copyFileWithBufferedStream(emptyFile.getAbsolutePath(), destinationEmptyFile.getAbsolutePath());\n        assertTrue(\"Destination file should exist after copying.\", destinationEmptyFile.exists());\n        assertEquals(\"Empty file should have length 0.\", 0, destinationEmptyFile.length());\n        assertTrue(\"Time taken should be non-negative.\", timeTaken >= 0);\n\n        emptyFile.delete();\n        destinationEmptyFile.delete();\n    }\n\n    /**\n     * Test copying a non-existent source file.\n     */\n    @Test(expected = IOException.class)\n    public void testCopyNonExistentFile() throws IOException {\n        String nonExistentFilePath = \"nonExistentFile.txt\";\n        Answer.copyFileWithBufferedStream(nonExistentFilePath, destinationFile.getAbsolutePath());\n    }\n\n    /**\n     * Test copying a file to an existing destination file (overwriting).\n     */\n    @Test\n    public void testCopyFileOverwrite() throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(destinationFile)) {\n            fos.write(\"Old content\".getBytes());\n        }\n\n        long timeTaken = Answer.copyFileWithBufferedStream(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());\n        assertTrue(\"Destination file should exist after copying.\", destinationFile.exists());\n        assertEquals(\"File sizes should match after overwriting.\", sourceFile.length(), destinationFile.length());\n        assertTrue(\"Time taken should be greater than 0.\", timeTaken > 0);\n    }\n\n    /**\n     * Test copying a large file.\n     */\n    @Test\n    public void testCopyLargeFile() throws IOException {\n        byte[] largeContent = new byte[10 * 1024 * 1024]; // 10 MB\n        for (int i = 0; i < largeContent.length; i++) {\n            largeContent[i] = (byte) (i % 256);\n        }\n\n        try (FileOutputStream fos = new FileOutputStream(sourceFile)) {\n            fos.write(largeContent);\n        }\n\n        long timeTaken = Answer.copyFileWithBufferedStream(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());\n        assertTrue(\"Destination file should exist after copying.\", destinationFile.exists());\n        assertEquals(\"File sizes should match.\", sourceFile.length(), destinationFile.length());\n        assertTrue(\"Time taken should be greater than 0.\", timeTaken > 0);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n* Copies the contents of the source file to the destination file using a buffered stream\n* and measures the time it takes to complete the operation.\n*\n* @param sourceFilePath      The path to the source file.\n* @param destinationFilePath The path to the destination file.\n* @return The time taken to copy the file in milliseconds.\n* @throws IOException If an I/O error occurs during the copy operation.\n*/\npublic static long copyFileWithBufferedStream(String sourceFilePath, String destinationFilePath) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 348, "code_type": "method", "original_language": "java", "file_path": "isu\\6a0922ef2d920cc48d0b1e37fd5138fa0de3aaec\\ComS417\\Assignment2\\PrimeNumberFinder.java", "question_type": "Algorithm and data structure", "summary": "Find all primes in a given range and calculate the sum of those primes", "language_version_list": {"python": {"code_signature": "def find_primes(lower_bound: int, upper_bound: int) -> list:\n    \"\"\"Find all prime numbers within a specified range.\n\n    Args:\n        lower_bound (int): The lower limit of the range (inclusive).\n        upper_bound (int): The upper limit of the range (inclusive).\n\n    Returns:\n        list: A list containing all prime numbers within the specified range.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFindPrimesInRange(unittest.TestCase):\n    def test_find_primes_in_range(self):\n        expected = [2, 3, 5, 7, 11]\n        self.assertEqual(find_primes(1, 12), expected, \"Check primes between 1 and 12\")\n\n    def test_find_primes_single_prime(self):\n        expected = [29]\n        self.assertEqual(find_primes(29, 29), expected, \"Check single prime number\")\n\n    def test_find_primes_in_big_range(self):\n        expected = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n        self.assertEqual(find_primes(1, 100), expected, \"Check primes between 1 and 100\")\n\n    def test_find_primes_no_primes(self):\n        expected = []\n        self.assertEqual(find_primes(0, 1), expected, \"Check range with no primes\")\n", "prompt": "please write a python function , the function signature as below def find_primes(lower_bound: int, upper_bound: int) -> list:\n    \"\"\"Find all prime numbers within a specified range.\n\n    Args:\n        lower_bound (int): The lower limit of the range (inclusive).\n        upper_bound (int): The upper limit of the range (inclusive).\n\n    Returns:\n        list: A list containing all prime numbers within the specified range.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds all prime numbers within a specified range.\n *\n * @param lower_bound The lower limit of the range (inclusive).\n * @type lower_bound int\n *\n * @param upper_bound The upper limit of the range (inclusive).\n * @type upper_bound int\n *\n * @return A vector containing all prime numbers within the specified range.\n * @rtype std::vector<int>\n */\nstd::vector<int> find_primes(int lower_bound, int upper_bound);", "test_code": "TEST_CASE(\"TestFindPrimesInRange\") {\n    SECTION(\"Find primes in range\") {\n        std::vector<int> expected = {2, 3, 5, 7, 11};\n        REQUIRE(find_primes(1, 12) == expected);\n    }\n\n    SECTION(\"Find primes for a single prime\") {\n        std::vector<int> expected = {29};\n        REQUIRE(find_primes(29, 29) == expected);\n    }\n\n    SECTION(\"Find primes in a large range\") {\n        std::vector<int> expected = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n        REQUIRE(find_primes(1, 100) == expected);\n    }\n\n    SECTION(\"Find primes in a range with no primes\") {\n        std::vector<int> expected = {};\n        REQUIRE(find_primes(0, 1) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds all prime numbers within a specified range.\n *\n * @param lower_bound The lower limit of the range (inclusive).\n * @type lower_bound int\n *\n * @param upper_bound The upper limit of the range (inclusive).\n * @type upper_bound int\n *\n * @return A vector containing all prime numbers within the specified range.\n * @rtype std::vector<int>\n */\nstd::vector<int> find_primes(int lower_bound, int upper_bound);", "addition_info": ""}, "java": {"code_signature": "/**\n * Find all primes in a given range and calculate the sum of those primes\n *\n * @param lowerBound The starting point of the range to check for prime numbers. Must be a non-negative integer.\n * @param upperBound The endpoint of the range to check for prime numbers. Must be equal to or greater than lowerBound.\n * @return A List<Integer> containing all the prime numbers found in the specified range. The list will be empty if no primes are found.\n */\npublic static List<Integer> findPrimes(int lowerBound, int upperBound) {}\n", "test_code": "package org.real.temp;\nimport org.junit.jupiter.api.Test;\n\nimport org.real.temp.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Tester {\n    @Test\n    public void testFindPrimesInRange() {\n        List<Integer> expected = Arrays.asList(2, 3, 5, 7, 11);\n        assertEquals(expected, Answer.findPrimes(1, 12), \"Check primes between 1 and 12\");\n    }\n\n    @Test\n    public void testFindPrimesSinglePrime() {\n        List<Integer> expected = Arrays.asList(29);\n        assertEquals(expected, Answer.findPrimes(29, 29), \"Check single prime number\");\n    }\n\n    @Test\n    public void testFindPrimesInBigRange() {\n        List<Integer> expected = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97);\n        assertEquals(expected, Answer.findPrimes(1, 100), \"Check primes between 1 and 100\");\n    }\n\n    @Test\n    public void testFindPrimesNoPrimes() {\n        List<Integer> expected = Arrays.asList();\n        assertEquals(expected, Answer.findPrimes(0, 1), \"Check range with no primes\");\n    }\n\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Find all primes in a given range and calculate the sum of those primes\n *\n * @param lowerBound The starting point of the range to check for prime numbers. Must be a non-negative integer.\n * @param upperBound The endpoint of the range to check for prime numbers. Must be equal to or greater than lowerBound.\n * @return A List<Integer> containing all the prime numbers found in the specified range. The list will be empty if no primes are found.\n */\npublic static List<Integer> findPrimes(int lowerBound, int upperBound) {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 349, "code_type": "method", "original_language": "java", "file_path": "windowkill-Phase2\\2e450fa8ef7fb7a072cf85bfe77151cdb6461702\\src\\main\\java\\controller\\Utils.java", "question_type": "Algorithm and data structure", "summary": "Generates all possible combinations of elements from a list of lists, where each combination consists of\npicking exactly one element from each list in the input list of lists. This method is useful for generating\nproduct variations, scenarios in decision-making tools, or any other context where all possible combinations\nof a set of options need to be explored.", "language_version_list": {"python": {"code_signature": "from typing import List, Any\n\n\ndef generate_combinations(input_lists: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Generates all possible combinations of elements from a list of lists.\n    Each combination consists of picking exactly one element from each list in the input list of lists.\n    This method is useful for generating product variations, scenarios in decision-making tools,\n    or any context where all possible combinations of a set of options need to be explored.\n\n    Args:\n        input_lists (List[List[Any]]): A list of lists containing the elements to combine.\n                                         The lists must not be empty but can contain elements of any type.\n\n    Returns:\n        List[List[Any]]: A list of lists, where each inner list represents a possible combination of elements\n                         taken from the input lists. Returns an empty list if the input list is empty.\n    \"\"\"\n", "test_code": "import unittest\nfrom typing import List\n\n\nclass TestGenerateCombinations(unittest.TestCase):\n\n    def test_empty_input(self):\n        input_data: List[List[str]] = []\n        expected: List[List[str]] = []\n        self.assertEqual(generate_combinations(input_data), expected, \"Testing with empty input\")\n\n    def test_single_empty_list(self):\n        input_data: List[List[str]] = [[]]  # Equivalent to Arrays.asList(new ArrayList<>())\n        expected: List[List[str]] = []\n        self.assertEqual(generate_combinations(input_data), expected, \"Testing with a single empty list\")\n\n    def test_single_non_empty_list(self):\n        input_data: List[List[str]] = [[\"a\", \"b\", \"c\"]]  # Equivalent to Arrays.asList(Arrays.asList(\"a\", \"b\", \"c\"))\n        expected: List[List[str]] = [[\"a\"], [\"b\"], [\"c\"]]\n        self.assertEqual(generate_combinations(input_data), expected, \"Testing with a single non-empty list\")\n\n    def test_multiple_lists(self):\n        input_data: List[List[str]] = [[\"a\", \"b\"], [\"1\", \"2\"]]  # Equivalent to Arrays.asList(Arrays.asList(\"a\", \"b\"), Arrays.asList(\"1\", \"2\"))\n        expected: List[List[str]] = [[\"a\", \"1\"], [\"a\", \"2\"], [\"b\", \"1\"], [\"b\", \"2\"]]\n        self.assertEqual(generate_combinations(input_data), expected, \"Testing with multiple lists\")\n\n    def test_input_containing_empty_list(self):\n        input_data: List[List[str]] = [[\"a\", \"b\"], [], [\"1\", \"2\"]]  # Equivalent to the Java example\n        expected: List[List[str]] = []\n        self.assertEqual(generate_combinations(input_data), expected, \"Testing with an input that contains an empty list\")\n", "prompt": "please write a python function , the function signature as below from typing import List, Any\n\n\ndef generate_combinations(input_lists: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Generates all possible combinations of elements from a list of lists.\n    Each combination consists of picking exactly one element from each list in the input list of lists.\n    This method is useful for generating product variations, scenarios in decision-making tools,\n    or any context where all possible combinations of a set of options need to be explored.\n\n    Args:\n        input_lists (List[List[Any]]): A list of lists containing the elements to combine.\n                                         The lists must not be empty but can contain elements of any type.\n\n    Returns:\n        List[List[Any]]: A list of lists, where each inner list represents a possible combination of elements\n                         taken from the input lists. Returns an empty list if the input list is empty.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Generates all possible combinations of elements from a list of lists.\n *\n * @param input_lists A vector of vectors containing the elements to combine. \n *                    The vectors must not be empty but can contain elements of any type.\n * @type input_lists std::vector<std::vector<std::any>>\n *\n * @return A vector of vectors, where each inner vector represents a possible combination of elements taken from the input lists. \n *         Returns an empty vector if the input list is empty.\n * @rtype std::vector<std::vector<std::any>>\n */\n\nstd::vector<std::vector<std::any>> generate_combinations(const std::vector<std::vector<std::any>>& input_lists) {\n    // Function implementation goes here\n}", "test_code": "TEST_CASE(\"TestGenerateCombinations\") {\n\n    SECTION(\"Empty input\") {\n        std::vector<std::vector<std::string>> input_data = {};\n        std::vector<std::vector<std::string>> expected = {};\n        REQUIRE(generate_combinations(input_data) == expected);\n    }\n\n    SECTION(\"Single empty list\") {\n        std::vector<std::vector<std::string>> input_data = {{}};\n        std::vector<std::vector<std::string>> expected = {};\n        REQUIRE(generate_combinations(input_data) == expected);\n    }\n\n    SECTION(\"Single non-empty list\") {\n        std::vector<std::vector<std::string>> input_data = {{\"a\", \"b\", \"c\"}};\n        std::vector<std::vector<std::string>> expected = {{\"a\"}, {\"b\"}, {\"c\"}};\n        REQUIRE(generate_combinations(input_data) == expected);\n    }\n\n    SECTION(\"Multiple lists\") {\n        std::vector<std::vector<std::string>> input_data = {{\"a\", \"b\"}, {\"1\", \"2\"}};\n        std::vector<std::vector<std::string>> expected = {{\"a\", \"1\"}, {\"a\", \"2\"}, {\"b\", \"1\"}, {\"b\", \"2\"}};\n        REQUIRE(generate_combinations(input_data) == expected);\n    }\n\n    SECTION(\"Input containing empty list\") {\n        std::vector<std::vector<std::string>> input_data = {{\"a\", \"b\"}, {}, {\"1\", \"2\"}};\n        std::vector<std::vector<std::string>> expected = {};\n        REQUIRE(generate_combinations(input_data) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Generates all possible combinations of elements from a list of lists.\n *\n * @param input_lists A vector of vectors containing the elements to combine. \n *                    The vectors must not be empty but can contain elements of any type.\n * @type input_lists std::vector<std::vector<std::any>>\n *\n * @return A vector of vectors, where each inner vector represents a possible combination of elements taken from the input lists. \n *         Returns an empty vector if the input list is empty.\n * @rtype std::vector<std::vector<std::any>>\n */\n\nstd::vector<std::vector<std::any>> generate_combinations(const std::vector<std::vector<std::any>>& input_lists) {\n    // Function implementation goes here\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Generates all possible combinations of elements from a list of lists, where each combination consists of\n * picking exactly one element from each list in the input list of lists. This method is useful for generating\n * product variations, scenarios in decision-making tools, or any other context where all possible combinations\n * of a set of options need to be explored.\n *\n * @param inputLists A list of lists containing the elements to combine. The lists must not be null but can contain any type of elements.\n * @return A list of lists, where each list represents a possible combination of elements taken from the input lists.\n *         Returns an empty list if the input list is null or empty.\n */\npublic List<List<T>> generateCombinations(List<List<T>> inputLists) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n    @Test\n    public void testEmptyInput() {\n        Answer generator = new Answer();\n        List<List<String>> input = new ArrayList<>();\n        List<List<String>> expected = new ArrayList<>();\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with empty input\");\n    }\n\n    @Test\n    public void testSingleEmptyList() {\n        Answer generator = new Answer();\n        List<List<String>> input = Arrays.asList(new ArrayList<>());\n        List<List<String>> expected = new ArrayList<>();\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with a single empty list\");\n    }\n\n    @Test\n    public void testSingleNonEmptyList() {\n        Answer generator = new Answer();\n        List<List<String>> input = Arrays.asList(Arrays.asList(\"a\", \"b\", \"c\"));\n        List<List<String>> expected = Arrays.asList(\n                Arrays.asList(\"a\"), Arrays.asList(\"b\"), Arrays.asList(\"c\")\n        );\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with a single non-empty list\");\n    }\n\n    @Test\n    public void testMultipleLists() {\n        Answer generator = new Answer();\n        List<List<String>> input = Arrays.asList(\n                Arrays.asList(\"a\", \"b\"),\n                Arrays.asList(\"1\", \"2\")\n        );\n        List<List<String>> expected = Arrays.asList(\n                Arrays.asList(\"a\", \"1\"), Arrays.asList(\"a\", \"2\"),\n                Arrays.asList(\"b\", \"1\"), Arrays.asList(\"b\", \"2\")\n        );\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with multiple lists\");\n    }\n\n    @Test\n    public void testInputContainingEmptyList() {\n        Answer generator = new Answer();\n        List<List<String>> input = Arrays.asList(\n                Arrays.asList(\"a\", \"b\"),\n                new ArrayList<>(),\n                Arrays.asList(\"1\", \"2\")\n        );\n        List<List<String>> expected = new ArrayList<>();\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with an input that contains an empty list\");\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Generates all possible combinations of elements from a list of lists, where each combination consists of\n * picking exactly one element from each list in the input list of lists. This method is useful for generating\n * product variations, scenarios in decision-making tools, or any other context where all possible combinations\n * of a set of options need to be explored.\n *\n * @param inputLists A list of lists containing the elements to combine. The lists must not be null but can contain any type of elements.\n * @return A list of lists, where each list represents a possible combination of elements taken from the input lists.\n *         Returns an empty list if the input list is null or empty.\n */\npublic List<List<T>> generateCombinations(List<List<T>> inputLists) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 350, "code_type": "method", "original_language": "java", "file_path": "security-network\\5aebcdc86d82596f5907812f248533c41b528ba8\\src\\main\\java\\com\\dauphine\\security\\tp4\\CMAC.java", "question_type": "Security", "summary": "Converts a byte array into its corresponding hexadecimal string representation.", "language_version_list": {"python": {"code_signature": "def byte_array_to_hex_string(byte_array: bytes) -> str:\n    \"\"\"\n    Converts a byte array into its corresponding hexadecimal string representation.\n\n    Args:\n        byte_array (bytes): An array of bytes to be converted into a hexadecimal string.\n\n    Returns:\n        str: A string representing the hexadecimal values of the bytes in the input array.If the input array is empty, returns an empty string.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestAnswer(unittest.TestCase):\n\n    def test_empty_byte_array(self):\n        input_data = bytes()  # Empty byte array\n        self.assertEqual(\"\", byte_array_to_hex_string(input_data), \"Empty array should return empty string\")\n\n    def test_single_byte(self):\n        input_data = bytes([0x0F])  # 15 in decimal\n        result = byte_array_to_hex_string(input_data)\n        self.assertTrue(result in [\"0F\", \"0f\"])\n\n    def test_multiple_bytes(self):\n        input_data = bytes([0x01, 0x0A, 0xFF])\n        result = byte_array_to_hex_string(input_data)\n        self.assertTrue(result in [\"010aff\", \"010AFF\"])\n\n    def test_zero_bytes(self):\n        input_data = bytes([0x00, 0x00, 0x00])\n        self.assertEqual(\"000000\", byte_array_to_hex_string(input_data), \"Zero bytes should be converted to '000000'\")\n\n    def test_negative_bytes(self):\n        input_data = bytes([0x80, 0xFF])  # 128 and 255 in signed byte representation\n        result = byte_array_to_hex_string(input_data)\n        self.assertTrue(result in [\"80FF\", \"80ff\"])", "prompt": "please write a python function , the function signature as below def byte_array_to_hex_string(byte_array: bytes) -> str:\n    \"\"\"\n    Converts a byte array into its corresponding hexadecimal string representation.\n\n    Args:\n        byte_array (bytes): An array of bytes to be converted into a hexadecimal string.\n\n    Returns:\n        str: A string representing the hexadecimal values of the bytes in the input array.If the input array is empty, returns an empty string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a byte array into its corresponding hexadecimal string representation.\n *\n * @param byte_array The array of bytes to be converted into a hexadecimal string.\n *                   Must be a non-empty vector of unsigned char.\n * @type byte_array const std::vector<unsigned char>&\n *\n * @return A string representing the hexadecimal values of the bytes in the input array. \n *         Returns an empty string if the input array is empty.\n * @rtype std::string\n */\n\nstd::string byte_array_to_hex_string(const std::vector<unsigned char>& byte_array);", "test_code": "TEST_CASE(\"Test byte_array_to_hex_string function\") {\n    \n    SECTION(\"Empty byte array\") {\n        std::vector<unsigned char> input_data;  // Empty byte array\n        REQUIRE(byte_array_to_hex_string(input_data) == \"\");\n    }\n\n    SECTION(\"Single byte\") {\n        std::vector<unsigned char> input_data = {0x0F};  // 15 in decimal\n        std::string result = byte_array_to_hex_string(input_data);\n        REQUIRE(result == \"0F\" || result == \"0f\");\n    }\n\n    SECTION(\"Multiple bytes\") {\n        std::vector<unsigned char> input_data = {0x01, 0x0A, 0xFF};\n        std::string result = byte_array_to_hex_string(input_data);\n        REQUIRE(result == \"010aff\" || result == \"010AFF\");\n    }\n\n    SECTION(\"Zero bytes\") {\n        std::vector<unsigned char> input_data = {0x00, 0x00, 0x00};\n        REQUIRE(byte_array_to_hex_string(input_data) == \"000000\");\n    }\n\n    SECTION(\"Negative bytes\") {\n        std::vector<unsigned char> input_data = {0x80, 0xFF};  // 128 and 255\n        std::string result = byte_array_to_hex_string(input_data);\n        REQUIRE(result == \"80FF\" || result == \"80ff\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a byte array into its corresponding hexadecimal string representation.\n *\n * @param byte_array The array of bytes to be converted into a hexadecimal string.\n *                   Must be a non-empty vector of unsigned char.\n * @type byte_array const std::vector<unsigned char>&\n *\n * @return A string representing the hexadecimal values of the bytes in the input array. \n *         Returns an empty string if the input array is empty.\n * @rtype std::string\n */\n\nstd::string byte_array_to_hex_string(const std::vector<unsigned char>& byte_array);", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a byte array into its corresponding hexadecimal string representation.\n *\n * @param byteArray An array of bytes to be converted into a hexadecimal string.\n * @return A string representing the hexadecimal values of the bytes in the input array. If the input array\n *         is empty, returns an empty string.\n */\npublic static String byteArrayToHexString(byte[] byteArray) {}", "test_code": "package org.real.temp;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class Tester {\n    @Test\n    void testEmptyByteArray() {\n        byte[] input = new byte[0];\n        assertEquals(\"\", Answer.byteArrayToHexString(input), \"Empty array should return empty string\");\n    }\n\n    @Test\n    void testSingleByte() {\n        byte[] input = {0x0F}; // 15 in decimal\n        String result = Answer.byteArrayToHexString(input);\n        assertTrue(result.equals(\"0F\") || result.equals(\"0f\"));\n    }\n\n    @Test\n    void testMultipleBytes() {\n        byte[] input = {0x01, 0x0A, (byte) 0xFF};\n        String result = Answer.byteArrayToHexString(input);\n        assertTrue(result.equals(\"010aff\") || result.equals(\"010AFF\"));\n    }\n\n    @Test\n    void testZeroBytes() {\n        byte[] input = {0x00, 0x00, 0x00};\n        assertEquals(\"000000\", Answer.byteArrayToHexString(input), \"Zero bytes should be converted to '000000'\");\n    }\n\n    @Test\n    void testNegativeBytes() {\n        byte[] input = {(byte) 0x80, (byte) 0xFF}; // 128 and 255 in signed byte representation\n        String result = Answer.byteArrayToHexString(input);\n        assertTrue(result.equals(\"80FF\") || result.equals(\"80ff\"));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts a byte array into its corresponding hexadecimal string representation.\n *\n * @param byteArray An array of bytes to be converted into a hexadecimal string.\n * @return A string representing the hexadecimal values of the bytes in the input array. If the input array\n *         is empty, returns an empty string.\n */\npublic static String byteArrayToHexString(byte[] byteArray) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 351, "code_type": "method", "original_language": "java", "file_path": "FiguraParser\\46108431382ac91ed18971693adcfaff18c388bd\\common\\src\\main\\java\\org\\figuramc\\figura\\utils\\MathUtils.java", "question_type": "Algorithm and data structure", "summary": "Calculates the value of a cubic Bezier curve at a given parameter t.", "language_version_list": {"python": {"code_signature": "def bezier(t: float, p0: float, p1: float, p2: float, p3: float) -> float:\n    \"\"\"\n    Calculates the value of a cubic Bezier curve at a given parameter t.\n\n    Args:\n        t (float): The parameter value between 0 and 1 that represents a position along the curve.\n        p0 (float): The first control point of the curve, typically where the curve starts.\n        p1 (float): The second control point, which influences the tangent at the beginning of the curve.\n        p2 (float): The third control point, which influences the tangent at the end of the curve.\n        p3 (float): The fourth control point, typically where the curve ends.\n\n    Returns:\n        float: The point on the Bezier curve corresponding to the parameter t.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestAnswer(unittest.TestCase):\n\n    def test_bezier_at_start(self):\n        self.assertAlmostEqual(bezier(0, 1, 3, 3, 1), 1.0,\n                               msg=\"Bezier at t=0 should return the first control point p0\")\n\n    def test_bezier_at_end(self):\n        self.assertAlmostEqual(bezier(1, 1, 3, 3, 1), 1.0,\n                               msg=\"Bezier at t=1 should return the last control point p3\")\n\n    def test_bezier_at_middle(self):\n        expected = 1.0 * 0.125 + 3 * 0.375 + 3 * 0.375 + 1 * 0.125  # Calculate manually for t=0.5\n        self.assertAlmostEqual(bezier(0.5, 1, 3, 3, 1), expected,\n                               delta=0.001,\n                               msg=\"Bezier at t=0.5 should return the correct middle value\")\n\n    def test_bezier_with_identical_control_points(self):\n        self.assertAlmostEqual(bezier(0.5, 2, 2, 2, 2), 2.0,\n                               msg=\"Bezier with all control points the same should return that value\")\n", "prompt": "please write a python function , the function signature as below def bezier(t: float, p0: float, p1: float, p2: float, p3: float) -> float:\n    \"\"\"\n    Calculates the value of a cubic Bezier curve at a given parameter t.\n\n    Args:\n        t (float): The parameter value between 0 and 1 that represents a position along the curve.\n        p0 (float): The first control point of the curve, typically where the curve starts.\n        p1 (float): The second control point, which influences the tangent at the beginning of the curve.\n        p2 (float): The third control point, which influences the tangent at the end of the curve.\n        p3 (float): The fourth control point, typically where the curve ends.\n\n    Returns:\n        float: The point on the Bezier curve corresponding to the parameter t.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculates the value of a cubic Bezier curve at a given parameter t.\n *\n * @param t The parameter value between 0 and 1 that represents a position along the curve.\n * @type t float\n *\n * @param p0 The first control point of the curve, typically where the curve starts.\n * @type p0 float\n *\n * @param p1 The second control point, which influences the tangent at the beginning of the curve.\n * @type p1 float\n *\n * @param p2 The third control point, which influences the tangent at the end of the curve.\n * @type p2 float\n *\n * @param p3 The fourth control point, typically where the curve ends.\n * @type p3 float\n *\n * @return The point on the Bezier curve corresponding to the parameter \\( t \\).\n * @rtype float\n */\n\nfloat bezier(float t, float p0, float p1, float p2, float p3) {\n    float d = 1 - t;\n    return (p0 * d * d * d +\n            3 * p1 * d * d * t +\n            3 * p2 * d * t * t +\n            p3 * t * t * t);\n}", "test_code": "TEST_CASE(\"Test Bezier Curve\", \"[bezier]\") {\n    \n    SECTION(\"Bezier at t=0 should return the first control point p0\") {\n        REQUIRE(bezier(0, 1, 3, 3, 1) == Approx(1.0).epsilon(0.001));\n    }\n\n    SECTION(\"Bezier at t=1 should return the last control point p3\") {\n        REQUIRE(bezier(1, 1, 3, 3, 1) == Approx(1.0).epsilon(0.001));\n    }\n\n    SECTION(\"Bezier at t=0.5 should return the correct middle value\") {\n        float expected = 1.0 * 0.125 + 3 * 0.375 + 3 * 0.375 + 1 * 0.125; // Calculate manually for t=0.5\n        REQUIRE(bezier(0.5, 1, 3, 3, 1) == Approx(expected).epsilon(0.001));\n    }\n\n    SECTION(\"Bezier with all control points the same should return that value\") {\n        REQUIRE(bezier(0.5, 2, 2, 2, 2) == Approx(2.0).epsilon(0.001));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculates the value of a cubic Bezier curve at a given parameter t.\n *\n * @param t The parameter value between 0 and 1 that represents a position along the curve.\n * @type t float\n *\n * @param p0 The first control point of the curve, typically where the curve starts.\n * @type p0 float\n *\n * @param p1 The second control point, which influences the tangent at the beginning of the curve.\n * @type p1 float\n *\n * @param p2 The third control point, which influences the tangent at the end of the curve.\n * @type p2 float\n *\n * @param p3 The fourth control point, typically where the curve ends.\n * @type p3 float\n *\n * @return The point on the Bezier curve corresponding to the parameter \\( t \\).\n * @rtype float\n */\n\nfloat bezier(float t, float p0, float p1, float p2, float p3) {\n    float d = 1 - t;\n    return (p0 * d * d * d +\n            3 * p1 * d * d * t +\n            3 * p2 * d * t * t +\n            p3 * t * t * t);\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the value of a cubic Bezier curve at a given parameter t.\n *\n * @param t  The parameter value between 0 and 1 that represents a position along the curve.\n * @param p0 The first control point of the curve, typically where the curve starts.\n * @param p1 The second control point, which influences the tangent at the beginning of the curve.\n * @param p2 The third control point, which influences the tangent at the end of the curve.\n * @param p3 The fourth control point, typically where the curve ends.\n * @return The point on the Bezier curve corresponding to the parameter t.\n */\npublic static double bezier(double t, double p0, double p1, double p2, double p3) {}", "test_code": "package org.real.temp;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class Tester {\n    @Test\n    void testBezierAtStart() {\n        assertEquals(1.0, Answer.bezier(0, 1, 3, 3, 1), \"Bezier at t=0 should return the first control point p0\");\n    }\n\n    @Test\n    void testBezierAtEnd() {\n        assertEquals(1.0, Answer.bezier(1, 1, 3, 3, 1), \"Bezier at t=1 should return the last control point p3\");\n    }\n\n    @Test\n    void testBezierAtMiddle() {\n        double expected = 1.0 * 0.125 + 3 * 0.375 + 3 * 0.375 + 1 * 0.125; // Calculate manually for t=0.5\n        assertEquals(expected, Answer.bezier(0.5, 1, 3, 3, 1), 0.001, \"Bezier at t=0.5 should return the correct middle value\");\n    }\n\n\n    @Test\n    void testBezierWithIdenticalControlPoints() {\n        assertEquals(2.0, Answer.bezier(0.5, 2, 2, 2, 2), \"Bezier with all control points the same should return that value\");\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Calculates the value of a cubic Bezier curve at a given parameter t.\n *\n * @param t  The parameter value between 0 and 1 that represents a position along the curve.\n * @param p0 The first control point of the curve, typically where the curve starts.\n * @param p1 The second control point, which influences the tangent at the beginning of the curve.\n * @param p2 The third control point, which influences the tangent at the end of the curve.\n * @param p3 The fourth control point, typically where the curve ends.\n * @return The point on the Bezier curve corresponding to the parameter t.\n */\npublic static double bezier(double t, double p0, double p1, double p2, double p3) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 352, "code_type": "method", "original_language": "java", "file_path": "security-network\\5aebcdc86d82596f5907812f248533c41b528ba8\\src\\main\\java\\com\\dauphine\\security\\tp4\\CCM.java", "question_type": "Data processing and transformation", "summary": "Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n in a readable format, especially in networking, cryptography, and systems programming. ", "language_version_list": {"python": {"code_signature": "def hex_string_to_byte_array(hex_str: str) -> bytes:\n    \"\"\"Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n    in a readable format, especially in networking, cryptography, and systems programming.\n\n    Args:\n        hex_str (str): The hexadecimal string to be converted. This string should only contain hexadecimal characters\n                       (0-9, A-F, a-f). If the string has an odd number of characters, a leading zero is added to ensure\n                       proper conversion.\n\n    Returns:\n        bytes: A byte array representing the binary data encoded in the hex string.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestHexStringToByteArray(unittest.TestCase):\n    def test_normal_hex_string(self):\n        hex_str = \"1a3f\"\n        expected = bytes([0x1A, 0x3F])\n        self.assertEqual(expected, hex_string_to_byte_array(hex_str),\n                         \"Should correctly convert a normal hex string\")\n\n    def test_odd_length_hex_string(self):\n        hex_str = \"123\"\n        expected = bytes([0x01, 0x23])\n        self.assertEqual(expected, hex_string_to_byte_array(hex_str),\n                         \"Should handle odd-length hex strings by prepending zero\")\n\n    def test_empty_string(self):\n        hex_str = \"\"\n        expected = bytes()\n        self.assertEqual(expected, hex_string_to_byte_array(hex_str),\n                         \"Should return an empty array for an empty string\")\n\n    def test_hex_string_with_uppercase(self):\n        hex_str = \"1A3F\"\n        expected = bytes([0x1A, 0x3F])\n        self.assertEqual(expected, hex_string_to_byte_array(hex_str),\n                         \"Should correctly handle hex strings with uppercase letters\")\n", "prompt": "please write a python function , the function signature as below def hex_string_to_byte_array(hex_str: str) -> bytes:\n    \"\"\"Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n    in a readable format, especially in networking, cryptography, and systems programming.\n\n    Args:\n        hex_str (str): The hexadecimal string to be converted. This string should only contain hexadecimal characters\n                       (0-9, A-F, a-f). If the string has an odd number of characters, a leading zero is added to ensure\n                       proper conversion.\n\n    Returns:\n        bytes: A byte array representing the binary data encoded in the hex string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a hexadecimal string into a byte array.\n *\n * @param hex_str The hexadecimal string to be converted. \n *                This string should only contain hexadecimal characters (0-9, A-F, a-f). \n *                If the string has an odd number of characters, a leading zero is added \n *                to ensure proper conversion.\n * @type hex_str std::string\n *\n * @return A byte array representing the binary data encoded in the hex string.\n * @rtype std::vector<uint8_t>\n */\n\nstd::vector<uint8_t> hex_string_to_byte_array(const std::string& hex_str);", "test_code": "TEST_CASE(\"Hex string to byte array conversion\") {\n    \n    SECTION(\"Normal hex string\") {\n        std::string hex_str = \"1a3f\";\n        std::vector<uint8_t> expected = {0x1A, 0x3F};\n        REQUIRE(hex_string_to_byte_array(hex_str) == expected);\n    }\n\n    SECTION(\"Odd length hex string\") {\n        std::string hex_str = \"123\";\n        std::vector<uint8_t> expected = {0x01, 0x23};\n        REQUIRE(hex_string_to_byte_array(hex_str) == expected);\n    }\n\n    SECTION(\"Empty string\") {\n        std::string hex_str = \"\";\n        std::vector<uint8_t> expected = {};\n        REQUIRE(hex_string_to_byte_array(hex_str) == expected);\n    }\n\n    SECTION(\"Hex string with uppercase\") {\n        std::string hex_str = \"1A3F\";\n        std::vector<uint8_t> expected = {0x1A, 0x3F};\n        REQUIRE(hex_string_to_byte_array(hex_str) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a hexadecimal string into a byte array.\n *\n * @param hex_str The hexadecimal string to be converted. \n *                This string should only contain hexadecimal characters (0-9, A-F, a-f). \n *                If the string has an odd number of characters, a leading zero is added \n *                to ensure proper conversion.\n * @type hex_str std::string\n *\n * @return A byte array representing the binary data encoded in the hex string.\n * @rtype std::vector<uint8_t>\n */\n\nstd::vector<uint8_t> hex_string_to_byte_array(const std::string& hex_str);", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n * in a readable format, especially in networking, cryptography, and systems programming.\n *\n * @param hex The hexadecimal string to be converted. This string should only contain hexadecimal characters\n *            (0-9, A-F, a-f). If the string has an odd number of characters, a leading zero is added to ensure\n *            proper conversion.\n * @return A byte array representing the binary data encoded in the hex string.\n */\npublic static byte[] hexStringToByteArray(String hex) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Tester {\n    @Test\n    void testNormalHexString() {\n        String hex = \"1a3f\";\n        byte[] expected = { (byte) 0x1A, (byte) 0x3F };\n        assertArrayEquals(expected, Answer.hexStringToByteArray(hex), \"Should correctly convert a normal hex string\");\n    }\n\n    @Test\n    void testOddLengthHexString() {\n        String hex = \"123\";\n        byte[] expected = { (byte) 0x01, (byte) 0x23 };\n        assertArrayEquals(expected, Answer.hexStringToByteArray(hex), \"Should handle odd-length hex strings by prepending zero\");\n    }\n\n    @Test\n    void testEmptyString() {\n        String hex = \"\";\n        byte[] expected = new byte[0];\n        assertArrayEquals(expected, Answer.hexStringToByteArray(hex), \"Should return an empty array for an empty string\");\n    }\n\n    @Test\n    void testHexStringWithUppercase() {\n        String hex = \"1A3F\";\n        byte[] expected = { (byte) 0x1A, (byte) 0x3F };\n        assertArrayEquals(expected, Answer.hexStringToByteArray(hex), \"Should correctly handle hex strings with uppercase letters\");\n    }\n\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n * in a readable format, especially in networking, cryptography, and systems programming.\n *\n * @param hex The hexadecimal string to be converted. This string should only contain hexadecimal characters\n *            (0-9, A-F, a-f). If the string has an odd number of characters, a leading zero is added to ensure\n *            proper conversion.\n * @return A byte array representing the binary data encoded in the hex string.\n */\npublic static byte[] hexStringToByteArray(String hex) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 609, "code_type": "method", "original_language": "java", "file_path": "LeetCode\\2c44ee9d58710b2f54edf36d8e033534805f2077\\TwoSum\\src\\Main.java\n", "question_type": "Algorithm and data structure", "summary": "Given an integer array nums and an integer target value target, find the two integers in the array whose sum is the target value target and return their array subscripts\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef two_sum(nums: List[int], target: int) -> int:\n    \"\"\"\n    Finds two indices of numbers in the array that sum up to the target value.\n\n    Args:\n        nums (List[int]): The input array of integers.\n        target (int): The target sum value.\n\n    Returns:\n        list[int]: A list containing the indices of the two numbers.\n\n    Raises:\n        ValueError: If no such indices are found.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestAnswer(unittest.TestCase):\n    def test_valid_pair(self):\n        nums = [2, 7, 11, 15]\n        target = 9\n        expected = [0, 1]  # 2 + 7 = 9\n        self.assertEqual(expected, two_sum(nums, target))\n\n    def test_negative_numbers(self):\n        nums = [-1, -2, -3, -4, -5]\n        target = -8\n        expected = [2, 4]  # -3 + -5 = -8\n        self.assertEqual(expected, two_sum(nums, target))\n\n    def test_zero_sum(self):\n        nums = [0, 4, 3, 0]\n        target = 0\n        expected = [0, 3]  # 0 + 0 = 0\n        self.assertEqual(expected, two_sum(nums, target))\n\n    def test_no_solution(self):\n        nums = [1, 2, 3, 4, 5]\n        target = 10\n        with self.assertRaises(Exception):\n            two_sum(nums, target)\n\n    def test_same_number_twice(self):\n        nums = [3, 3]\n        target = 6\n        expected = [0, 1]  # 3 + 3 = 6\n        self.assertEqual(expected, two_sum(nums, target))\n\n    def test_large_numbers(self):\n        nums = [2147483647, -2147483648, 0, 1]\n        target = 1\n        expected = [2, 3]  # 0 + 1 = 1\n        self.assertEqual(expected, two_sum(nums, target))", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef two_sum(nums: List[int], target: int) -> int:\n    \"\"\"\n    Finds two indices of numbers in the array that sum up to the target value.\n\n    Args:\n        nums (List[int]): The input array of integers.\n        target (int): The target sum value.\n\n    Returns:\n        list[int]: A list containing the indices of the two numbers.\n\n    Raises:\n        ValueError: If no such indices are found.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds two indices of numbers in the input array that add up to a specified target sum.\n *\n *\n * @param nums The input array of integers.\n *             Must be a vector of integers with at least two elements.\n * @type nums std::vector<int>\n *\n * @param target The target sum value that two numbers from the array should add up to.\n * @type target int\n *\n * @return A vector containing the indices of the two numbers that sum to the target.\n * @rtype std::vector<int>\n *\n * @throws std::invalid_argument If no such indices are found.\n */\nstd::vector<int> two_sum(const std::vector<int>& nums, int target);", "test_code": "TEST_CASE(\"TestAnswer\") {\n    SECTION(\"Valid pair\") {\n        std::vector<int> nums = {2, 7, 11, 15};\n        int target = 9;\n        std::vector<int> expected = {0, 1};  // 2 + 7 = 9\n        REQUIRE(two_sum(nums, target) == expected);\n    }\n\n    SECTION(\"Negative numbers\") {\n        std::vector<int> nums = {-1, -2, -3, -4, -5};\n        int target = -8;\n        std::vector<int> expected = {2, 4};  // -3 + -5 = -8\n        REQUIRE(two_sum(nums, target) == expected);\n    }\n\n    SECTION(\"Zero sum\") {\n        std::vector<int> nums = {0, 4, 3, 0};\n        int target = 0;\n        std::vector<int> expected = {0, 3};  // 0 + 0 = 0\n        REQUIRE(two_sum(nums, target) == expected);\n    }\n\n    SECTION(\"No solution\") {\n        std::vector<int> nums = {1, 2, 3, 4, 5};\n        int target = 10;\n        REQUIRE_THROWS_AS(two_sum(nums, target), std::invalid_argument);\n    }\n\n    SECTION(\"Same number twice\") {\n        std::vector<int> nums = {3, 3};\n        int target = 6;\n        std::vector<int> expected = {0, 1};  // 3 + 3 = 6\n        REQUIRE(two_sum(nums, target) == expected);\n    }\n\n    SECTION(\"Large numbers\") {\n        std::vector<int> nums = {2147483647, -2147483648, 0, 1};\n        int target = 1;\n        std::vector<int> expected = {2, 3};  // 0 + 1 = 1\n        REQUIRE(two_sum(nums, target) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds two indices of numbers in the input array that add up to a specified target sum.\n *\n *\n * @param nums The input array of integers.\n *             Must be a vector of integers with at least two elements.\n * @type nums std::vector<int>\n *\n * @param target The target sum value that two numbers from the array should add up to.\n * @type target int\n *\n * @return A vector containing the indices of the two numbers that sum to the target.\n * @rtype std::vector<int>\n *\n * @throws std::invalid_argument If no such indices are found.\n */\nstd::vector<int> two_sum(const std::vector<int>& nums, int target);", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds two indices of numbers in the array that sum up to the target value.\n *\n * @param nums   the input array of integers\n * @param target the target sum value\n * @return an array containing the indices of the two numbers\n * @throws IllegalArgumentException if no such indices are found\n */\npublic int[] twoSum(int[] nums, int target) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Tester {\n\n    private final Answer answer = new Answer();\n\n    @Test\n    public void testValidPair() {\n        int[] nums = {2, 7, 11, 15};\n        int target = 9;\n        int[] expected = {0, 1}; // 2 + 7 = 9\n        assertArrayEquals(expected, answer.twoSum(nums, target));\n    }\n\n    @Test\n    public void testNegativeNumbers() {\n        int[] nums = {-1, -2, -3, -4, -5};\n        int target = -8;\n        int[] expected = {2, 4}; // -3 + -5 = -8\n        assertArrayEquals(expected, answer.twoSum(nums, target));\n    }\n\n    @Test\n    public void testZeroSum() {\n        int[] nums = {0, 4, 3, 0};\n        int target = 0;\n        int[] expected = {0, 3}; // 0 + 0 = 0\n        assertArrayEquals(expected, answer.twoSum(nums, target));\n    }\n\n    @Test\n    public void testNoSolution() {\n        int[] nums = {1, 2, 3, 4, 5};\n        int target = 10;\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> {\n            answer.twoSum(nums, target);\n        });\n        assertEquals(\"No two sum solution\", exception.getMessage());\n    }\n\n    @Test\n    public void testSameNumberTwice() {\n        int[] nums = {3, 3};\n        int target = 6;\n        int[] expected = {0, 1}; // 3 + 3 = 6\n        assertArrayEquals(expected, answer.twoSum(nums, target));\n    }\n\n    @Test\n    public void testLargeNumbers() {\n        int[] nums = {Integer.MAX_VALUE, Integer.MIN_VALUE, 0, 1};\n        int target = 1;\n        int[] expected = {2, 3}; // 0 + 1 = 1\n        assertArrayEquals(expected, answer.twoSum(nums, target));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds two indices of numbers in the array that sum up to the target value.\n *\n * @param nums   the input array of integers\n * @param target the target sum value\n * @return an array containing the indices of the two numbers\n * @throws IllegalArgumentException if no such indices are found\n */\npublic int[] twoSum(int[] nums, int target) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 610, "code_type": "method", "original_language": "java", "file_path": "jt-cmsi662\\8fef04ff1a2d5550d7dfb806db52a9b4a5c48881\\homework-2\\java\\SimpleShoppingCart.java\n", "question_type": "Data processing and transformation", "summary": "Rewrite the hashcode method in the content part of the class so that its hashcode is related to the name and age fields in the class\n", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "/**\n * Rewrite the hashcode method in the content part of the class so that its hashcode is related to the name and age fields in the class\n *\n * @return obj hashcode\n */\n@Override\npublic int hashCode() {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass Tester {\n\n    @Test\n    void testHashCode_SameNameAndAge() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Alice\", 25);\n        assertEquals(answer1.hashCode(), answer2.hashCode(), \"Hash codes should be equal for the same name and age.\");\n    }\n\n    @Test\n    void testHashCode_DifferentName() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Bob\", 25);\n        assertNotEquals(answer1.hashCode(), answer2.hashCode(), \"Hash codes should be different for different names.\");\n    }\n\n    @Test\n    void testHashCode_DifferentAge() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Alice\", 30);\n        assertNotEquals(answer1.hashCode(), answer2.hashCode(), \"Hash codes should be different for different ages.\");\n    }\n\n    @Test\n    void testEquals_SameReference() {\n        Answer answer = new Answer(\"Alice\", 25);\n        assertTrue(answer.equals(answer), \"An object should be equal to itself.\");\n    }\n\n    @Test\n    void testEquals_SameNameAndAge() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Alice\", 25);\n        assertTrue(answer1.equals(answer2), \"Two answers with the same name and age should be equal.\");\n    }\n\n    @Test\n    void testEquals_DifferentName() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Bob\", 25);\n        assertFalse(answer1.equals(answer2), \"Two answers with different names should not be equal.\");\n    }\n\n    @Test\n    void testEquals_DifferentAge() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Alice\", 30);\n        assertFalse(answer1.equals(answer2), \"Two answers with different ages should not be equal.\");\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Rewrite the hashcode method in the content part of the class so that its hashcode is related to the name and age fields in the class\n *\n * @return obj hashcode\n */\n@Override\npublic int hashCode() {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 611, "code_type": "method", "original_language": "java", "file_path": "chatty-backend\\9b990df69c3f62b1ec6794731a6360451fe57573\\src\\main\\java\\net\\nocpiun\\chatty\\utils\\UniqueID.java\n", "question_type": "Data processing and transformation", "summary": "Generates a random string of length 25 and must contain both upper case letters (A-Z) and lower case letters (a-z)\n", "language_version_list": {"python": {"code_signature": "def generate_random_string() -> str:\n    \"\"\"Generates a random string of length 25 containing both upper case (A-Z) and lower case (a-z) letters.\n\n    Returns:\n        str: A randomly generated string that meets the criteria of including both upper and lower case letters.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestGenerateRandomString(unittest.TestCase):\n\n    def test_length(self):\n        random_string = generate_random_string()\n        self.assertEqual(len(random_string), 25, \"The generated string length should be 25.\")\n\n    def test_contains_upper_case(self):\n        random_string = generate_random_string()\n        self.assertTrue(any(char.isupper() for char in random_string),\n                        \"The generated string should contain at least one uppercase letter.\")\n\n    def test_contains_lower_case(self):\n        random_string = generate_random_string()\n        self.assertTrue(any(char.islower() for char in random_string),\n                        \"The generated string should contain at least one lowercase letter.\")\n\n    def test_randomness(self):\n        string1 = generate_random_string()\n        string2 = generate_random_string()\n        self.assertNotEqual(string1, string2, \"Two generated strings should not be the same.\")\n\n    def test_multiple_generations(self):\n        num_tests = 100\n        has_upper_case = False\n        has_lower_case = False\n\n        for _ in range(num_tests):\n            random_string = generate_random_string()\n            has_upper_case |= any(char.isupper() for char in random_string)\n            has_lower_case |= any(char.islower() for char in random_string)\n\n        self.assertTrue(has_upper_case, \"At least one generated string should contain an uppercase letter.\")\n        self.assertTrue(has_lower_case, \"At least one generated string should contain a lowercase letter.\")\n", "prompt": "please write a python function , the function signature as below def generate_random_string() -> str:\n    \"\"\"Generates a random string of length 25 containing both upper case (A-Z) and lower case (a-z) letters.\n\n    Returns:\n        str: A randomly generated string that meets the criteria of including both upper and lower case letters.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Generates a random string of specified length containing both upper case \n *        (A-Z) and lower case (a-z) letters.\n *\n * @return A randomly generated string that meets the criteria of including both \n *         upper and lower case letters.\n * @rtype std::string\n */\n\nstd::string generate_random_string();", "test_code": "TEST_CASE(\"Test Generate Random String\") {\n\n    SECTION(\"Test length\") {\n        std::string random_string = generate_random_string();\n        REQUIRE(random_string.length() == 25);\n    }\n\n    SECTION(\"Test contains upper case\") {\n        std::string random_string = generate_random_string();\n        bool has_upper_case = std::any_of(random_string.begin(), random_string.end(), [](char c) {\n            return std::isupper(static_cast<unsigned char>(c));\n        });\n        REQUIRE(has_upper_case);\n    }\n\n    SECTION(\"Test contains lower case\") {\n        std::string random_string = generate_random_string();\n        bool has_lower_case = std::any_of(random_string.begin(), random_string.end(), [](char c) {\n            return std::islower(static_cast<unsigned char>(c));\n        });\n        REQUIRE(has_lower_case);\n    }\n\n    SECTION(\"Test randomness\") {\n        std::string string1 = generate_random_string();\n        std::string string2 = generate_random_string();\n        REQUIRE(string1 != string2);\n    }\n\n    SECTION(\"Test multiple generations\") {\n        const int num_tests = 100;\n        bool has_upper_case = false;\n        bool has_lower_case = false;\n\n        for (int i = 0; i < num_tests; ++i) {\n            std::string random_string = generate_random_string();\n            has_upper_case |= std::any_of(random_string.begin(), random_string.end(), [](char c) {\n                return std::isupper(static_cast<unsigned char>(c));\n            });\n            has_lower_case |= std::any_of(random_string.begin(), random_string.end(), [](char c) {\n                return std::islower(static_cast<unsigned char>(c));\n            });\n        }\n\n        REQUIRE(has_upper_case);\n        REQUIRE(has_lower_case);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Generates a random string of specified length containing both upper case \n *        (A-Z) and lower case (a-z) letters.\n *\n * @return A randomly generated string that meets the criteria of including both \n *         upper and lower case letters.\n * @rtype std::string\n */\n\nstd::string generate_random_string();", "addition_info": ""}, "java": {"code_signature": "/**\n * Generates a random string of length 25 and must contain both upper case letters (A-Z) and lower case letters (a-z)\n *\n * @return random string\n */\npublic static String generateRandomString() {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testLength() {\n        String randomString = Answer.generateRandomString();\n        assertEquals(25, randomString.length(), \"The generated string length should be 25.\");\n    }\n\n    @Test\n    public void testContainsUpperCase() {\n        String randomString = Answer.generateRandomString();\n        assertTrue(randomString.chars().anyMatch(Character::isUpperCase),\n                \"The generated string should contain at least one uppercase letter.\");\n    }\n\n    @Test\n    public void testContainsLowerCase() {\n        String randomString = Answer.generateRandomString();\n        assertTrue(randomString.chars().anyMatch(Character::isLowerCase),\n                \"The generated string should contain at least one lowercase letter.\");\n    }\n\n    @Test\n    public void testRandomness() {\n        String string1 = Answer.generateRandomString();\n        String string2 = Answer.generateRandomString();\n        assertNotEquals(string1, string2, \"Two generated strings should not be the same.\");\n    }\n\n    @Test\n    public void testMultipleGenerations() {\n        int numTests = 100;\n        boolean hasUpperCase = false;\n        boolean hasLowerCase = false;\n\n        for (int i = 0; i < numTests; i++) {\n            String randomString = Answer.generateRandomString();\n            hasUpperCase |= randomString.chars().anyMatch(Character::isUpperCase);\n            hasLowerCase |= randomString.chars().anyMatch(Character::isLowerCase);\n        }\n\n        assertTrue(hasUpperCase, \"At least one generated string should contain an uppercase letter.\");\n        assertTrue(hasLowerCase, \"At least one generated string should contain a lowercase letter.\");\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Generates a random string of length 25 and must contain both upper case letters (A-Z) and lower case letters (a-z)\n *\n * @return random string\n */\npublic static String generateRandomString() {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 612, "code_type": "method", "original_language": "java", "file_path": "HoldemEvaluator\\cb722a5471f2ac667e86c947e5061f2f9436d936\\ReplaceStringInAllJavaFiles.java\n", "question_type": "File operations and I/O operation", "summary": "Find and replace text in the specified file\n", "language_version_list": {"python": {"code_signature": "def find_and_replace_in_file(file_path:str, search_string:str, replace_string:str):\n    \"\"\"\n    Finds and replaces text in a specified file.\n\n    Args:\n        file_path (str): The path to the file.\n        search_string (str): The string to search for.\n        replace_string (str): The string to replace with.\n\n    Raises:\n        IOError: If an I/O error occurs reading from the file or writing to the file.\n    \"\"\"", "test_code": "import os\nimport unittest\n\n\nclass TestFindAndReplace(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory for the tests\n        self.temp_dir = os.path.join(os.path.dirname(__file__), 'temp')\n        os.makedirs(self.temp_dir, exist_ok=True)\n\n    def tearDown(self):\n        # Remove the temporary directory after tests\n        for file in os.listdir(self.temp_dir):\n            os.remove(os.path.join(self.temp_dir, file))\n        os.rmdir(self.temp_dir)\n\n    # Test case 1: Basic find and replace\n    def test_find_and_replace_basic(self):\n        file_path = os.path.join(self.temp_dir, \"testfile.txt\")\n        with open(file_path, 'w') as file:\n            file.writelines([\"Hello World\\n\", \"Goodbye World\\n\"])\n\n        find_and_replace_in_file(file_path, \"World\", \"Java\")\n\n        with open(file_path, 'r') as file:\n            result = file.readlines()\n\n        self.assertEqual(result, [\"Hello Java\\n\", \"Goodbye Java\\n\"])\n\n    # Test case 2: No occurrences of the search string\n    def test_find_and_replace_no_occurrences(self):\n        file_path = os.path.join(self.temp_dir, \"testfile.txt\")\n        with open(file_path, 'w') as file:\n            file.writelines([\"Hello World\\n\", \"Goodbye World\\n\"])\n\n        find_and_replace_in_file(file_path, \"Python\", \"Java\")\n\n        with open(file_path, 'r') as file:\n            result = file.readlines()\n\n        self.assertEqual(result, [\"Hello World\\n\", \"Goodbye World\\n\"])\n\n    # Test case 3: Multiple occurrences in a single line\n    def test_find_and_replace_multiple_occurrences(self):\n        file_path = os.path.join(self.temp_dir, \"testfile.txt\")\n        with open(file_path, 'w') as file:\n            file.writelines([\"Hello World World\\n\", \"Goodbye World\\n\"])\n\n        find_and_replace_in_file(file_path, \"World\", \"Java\")\n\n        with open(file_path, 'r') as file:\n            result = file.readlines()\n\n        self.assertEqual(result, [\"Hello Java Java\\n\", \"Goodbye Java\\n\"])\n\n    # Test case 4: Replace with an empty string\n    def test_find_and_replace_with_empty_string(self):\n        file_path = os.path.join(self.temp_dir, \"testfile.txt\")\n        with open(file_path, 'w') as file:\n            file.writelines([\"Hello World\\n\", \"Goodbye World\\n\"])\n\n        find_and_replace_in_file(file_path, \"World\", \"\")\n\n        with open(file_path, 'r') as file:\n            result = file.readlines()\n\n        self.assertEqual(result, [\"Hello \\n\", \"Goodbye \\n\"])\n\n    # Test case 5: Empty file\n    def test_find_and_replace_empty_file(self):\n        file_path = os.path.join(self.temp_dir, \"testfile.txt\")\n        with open(file_path, 'w') as file:\n            file.writelines([\"\\n\"])\n\n        find_and_replace_in_file(file_path, \"World\", \"Java\")\n\n        with open(file_path, 'r') as file:\n            result = file.readlines()\n\n        self.assertEqual(result, [\"\\n\"])\n", "prompt": "please write a python function , the function signature as below def find_and_replace_in_file(file_path:str, search_string:str, replace_string:str):\n    \"\"\"\n    Finds and replaces text in a specified file.\n\n    Args:\n        file_path (str): The path to the file.\n        search_string (str): The string to search for.\n        replace_string (str): The string to replace with.\n\n    Raises:\n        IOError: If an I/O error occurs reading from the file or writing to the file.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds and replaces text in a specified file.\n *\n * @param file_path The path to the file.\n * @param search_string The string to search for.\n * @param replace_string The string to replace with.\n *\n * @throws std::ios_base::failure If an I/O error occurs reading from the file or writing to the file.\n */\nvoid find_and_replace_in_file(const std::string& file_path, const std::string& search_string, const std::string& replace_string);", "test_code": "TEST_CASE_METHOD(TestFindAndReplace, \"Basic find and replace\") {\n    auto file_path = temp_dir / \"testfile.txt\";\n    std::ofstream(file_path) << \"Hello World\\nGoodbye World\\n\";\n\n    find_and_replace_in_file(file_path.string(), \"World\", \"Java\");\n\n    std::ifstream ifs(file_path);\n    std::string result((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());\n    REQUIRE(result == \"Hello Java\\nGoodbye Java\\n\");\n}\n\nTEST_CASE_METHOD(TestFindAndReplace, \"No occurrences of the search string\") {\n    auto file_path = temp_dir / \"testfile.txt\";\n    std::ofstream(file_path) << \"Hello World\\nGoodbye World\\n\";\n\n    find_and_replace_in_file(file_path.string(), \"Python\", \"Java\");\n\n    std::ifstream ifs(file_path);\n    std::string result((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());\n    REQUIRE(result == \"Hello World\\nGoodbye World\\n\");\n}\n\nTEST_CASE_METHOD(TestFindAndReplace, \"Multiple occurrences in a single line\") {\n    auto file_path = temp_dir / \"testfile.txt\";\n    std::ofstream(file_path) << \"Hello World World\\nGoodbye World\\n\";\n\n    find_and_replace_in_file(file_path.string(), \"World\", \"Java\");\n\n    std::ifstream ifs(file_path);\n    std::string result((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());\n    REQUIRE(result == \"Hello Java Java\\nGoodbye Java\\n\");\n}\n\nTEST_CASE_METHOD(TestFindAndReplace, \"Replace with an empty string\") {\n    auto file_path = temp_dir / \"testfile.txt\";\n    std::ofstream(file_path) << \"Hello World\\nGoodbye World\\n\";\n\n    find_and_replace_in_file(file_path.string(), \"World\", \"\");\n\n    std::ifstream ifs(file_path);\n    std::string result((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());\n    REQUIRE(result == \"Hello \\nGoodbye \\n\");\n}\n\nTEST_CASE_METHOD(TestFindAndReplace, \"Empty file\") {\n    auto file_path = temp_dir / \"testfile.txt\";\n    std::ofstream(file_path) << \"\\n\";\n\n    find_and_replace_in_file(file_path.string(), \"World\", \"Java\");\n\n    std::ifstream ifs(file_path);\n    std::string result((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());\n    REQUIRE(result == \"\\n\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds and replaces text in a specified file.\n *\n * @param file_path The path to the file.\n * @param search_string The string to search for.\n * @param replace_string The string to replace with.\n *\n * @throws std::ios_base::failure If an I/O error occurs reading from the file or writing to the file.\n */\nvoid find_and_replace_in_file(const std::string& file_path, const std::string& search_string, const std::string& replace_string);", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds and replaces text in a specified file.\n *\n * @param filePath      the path to the file\n * @param searchString  the string to search for\n * @param replaceString the string to replace with\n * @throws IOException if an I/O error occurs reading from the file or writing to the file\n */\npublic static void findAndReplaceInFile(Path filePath, String searchString, String replaceString) throws IOException {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.real.temp.Answer;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\n\npublic class Tester {\n\n    // Test case 1: Basic find and replace\n    @Test\n    public void testFindAndReplaceBasic(@TempDir Path tempDir) throws IOException {\n        Path filePath = tempDir.resolve(\"testfile.txt\");\n        Files.write(filePath, List.of(\"Hello World\", \"Goodbye World\"));\n\n        Answer.findAndReplaceInFile(filePath, \"World\", \"Java\");\n\n        List<String> result = Files.readAllLines(filePath);\n        assertEquals(List.of(\"Hello Java\", \"Goodbye Java\"), result);\n    }\n\n    // Test case 2: No occurrences of the search string\n    @Test\n    public void testFindAndReplaceNoOccurrences(@TempDir Path tempDir) throws IOException {\n        Path filePath = tempDir.resolve(\"testfile.txt\");\n        Files.write(filePath, List.of(\"Hello World\", \"Goodbye World\"));\n\n        Answer.findAndReplaceInFile(filePath, \"Python\", \"Java\");\n\n        List<String> result = Files.readAllLines(filePath);\n        assertEquals(List.of(\"Hello World\", \"Goodbye World\"), result);\n    }\n\n    // Test case 3: Multiple occurrences in a single line\n    @Test\n    public void testFindAndReplaceMultipleOccurrences(@TempDir Path tempDir) throws IOException {\n        Path filePath = tempDir.resolve(\"testfile.txt\");\n        Files.write(filePath, List.of(\"Hello World World\", \"Goodbye World\"));\n\n        Answer.findAndReplaceInFile(filePath, \"World\", \"Java\");\n\n        List<String> result = Files.readAllLines(filePath);\n        assertEquals(List.of(\"Hello Java Java\", \"Goodbye Java\"), result);\n    }\n\n    // Test case 4: Replace with an empty string\n    @Test\n    public void testFindAndReplaceWithEmptyString(@TempDir Path tempDir) throws IOException {\n        Path filePath = tempDir.resolve(\"testfile.txt\");\n        Files.write(filePath, List.of(\"Hello World\", \"Goodbye World\"));\n\n        Answer.findAndReplaceInFile(filePath, \"World\", \"\");\n\n        List<String> result = Files.readAllLines(filePath);\n        assertEquals(List.of(\"Hello \", \"Goodbye \"), result);\n    }\n\n    // Test case 5: Empty file\n    @Test\n    public void testFindAndReplaceEmptyFile(@TempDir Path tempDir) throws IOException {\n        Path filePath = tempDir.resolve(\"testfile.txt\");\n        Files.write(filePath, List.of(\"\"));\n\n        Answer.findAndReplaceInFile(filePath, \"World\", \"Java\");\n\n        List<String> result = Files.readAllLines(filePath);\n        assertEquals(List.of(\"\"), result);\n    }\n\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Finds and replaces text in a specified file.\n *\n * @param filePath      the path to the file\n * @param searchString  the string to search for\n * @param replaceString the string to replace with\n * @throws IOException if an I/O error occurs reading from the file or writing to the file\n */\npublic static void findAndReplaceInFile(Path filePath, String searchString, String replaceString) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 614, "code_type": "method", "original_language": "java", "file_path": "ArtemisTasks\\98db65f7d7f1e4e742047509c357f10877444215\\AdventuinParty\\pgdp\\adventuin\\AdventuinParty.java\n", "question_type": "Data processing and transformation", "summary": "Accept a list containing multiple integer values, calculate the difference from the previous data for each item of data, get a difference array, and calculate the average difference value\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef calculate_average_difference(numbers: List[int]) -> float:\n    \"\"\"Calculates the average difference between consecutive integers in the provided list.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        float: The average difference between consecutive integers, or 0 if there are fewer than 2 integers.\n    \"\"\"", "test_code": "import unittest\nfrom typing import List\n\n\nclass TestCalculateAverageDifference(unittest.TestCase):\n\n    def test_calculate_average_difference_positive_integers(self):\n        numbers: List[int] = [10, 20, 30, 40]\n        result = calculate_average_difference(numbers)\n        expected = 10.0\n        self.assertAlmostEqual(expected, result, msg=\"The average difference should be 10.0\")\n\n    def test_calculate_average_difference_mixed_positive_and_negative(self):\n        numbers: List[int] = [-10, 0, 10, 20]\n        result = calculate_average_difference(numbers)\n        expected = 10.0\n        self.assertAlmostEqual(expected, result, msg=\"The average difference should be 10.0\")\n\n    def test_calculate_average_difference_same_values(self):\n        numbers: List[int] = [5, 5, 5, 5]\n        result = calculate_average_difference(numbers)\n        expected = 0.0\n        self.assertAlmostEqual(expected, result, msg=\"The average difference should be 0.0 as all values are the same\")\n\n    def test_calculate_average_difference_single_element(self):\n        numbers: List[int] = [100]\n        result = calculate_average_difference(numbers)\n        expected = 0.0  # Not enough data to calculate differences\n        self.assertAlmostEqual(expected, result, msg=\"The average difference should be 0.0 for a single element list\")\n\n    def test_calculate_average_difference_empty_list(self):\n        numbers: List[int] = []\n        result = calculate_average_difference(numbers)\n        expected = 0.0  # Not enough data to calculate differences\n        self.assertAlmostEqual(expected, result, msg=\"The average difference should be 0.0 for an empty list\")", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef calculate_average_difference(numbers: List[int]) -> float:\n    \"\"\"Calculates the average difference between consecutive integers in the provided list.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        float: The average difference between consecutive integers, or 0 if there are fewer than 2 integers.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculates the average difference between consecutive integers in a provided list.\n *\n * @param numbers A vector of integers for which the average difference is to be calculated.\n * @type numbers std::vector<int>\n *\n * @return The average difference between consecutive integers, or 0 if there are fewer \n *         than two integers.\n * @rtype double\n */\n\ndouble calculate_average_difference(const std::vector<int>& numbers);", "test_code": "TEST_CASE(\"TestCalculateAverageDifference\") {\n    \n    SECTION(\"Positive integers\") {\n        std::vector<int> numbers = {10, 20, 30, 40};\n        double result = calculate_average_difference(numbers);\n        double expected = 10.0;\n        REQUIRE(result == Approx(expected).epsilon(0.001)); // Using Approx for floating-point comparison\n    }\n\n    SECTION(\"Mixed positive and negative integers\") {\n        std::vector<int> numbers = {-10, 0, 10, 20};\n        double result = calculate_average_difference(numbers);\n        double expected = 10.0;\n        REQUIRE(result == Approx(expected).epsilon(0.001));\n    }\n\n    SECTION(\"Same values\") {\n        std::vector<int> numbers = {5, 5, 5, 5};\n        double result = calculate_average_difference(numbers);\n        double expected = 0.0;\n        REQUIRE(result == Approx(expected).epsilon(0.001));\n    }\n\n    SECTION(\"Single element\") {\n        std::vector<int> numbers = {100};\n        double result = calculate_average_difference(numbers);\n        double expected = 0.0; // Not enough data to calculate differences\n        REQUIRE(result == Approx(expected).epsilon(0.001));\n    }\n\n    SECTION(\"Empty list\") {\n        std::vector<int> numbers = {};\n        double result = calculate_average_difference(numbers);\n        double expected = 0.0; // Not enough data to calculate differences\n        REQUIRE(result == Approx(expected).epsilon(0.001));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculates the average difference between consecutive integers in a provided list.\n *\n * @param numbers A vector of integers for which the average difference is to be calculated.\n * @type numbers std::vector<int>\n *\n * @return The average difference between consecutive integers, or 0 if there are fewer \n *         than two integers.\n * @rtype double\n */\n\ndouble calculate_average_difference(const std::vector<int>& numbers);", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the average difference between consecutive integers in the provided list.\n *\n * @param numbers a list of integers\n * @return the average difference, or 0 if there are fewer than 2 integers\n */\npublic static double calculateAverageDifference(List<Integer> numbers) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testCalculateAverageDifference_PositiveIntegers() {\n        List<Integer> numbers = List.of(10, 20, 30, 40);\n        double result = Answer.calculateAverageDifference(numbers);\n        double expected = 10.0;\n        assertEquals(expected, result, \"The average difference should be 10.0\");\n    }\n\n    @Test\n    public void testCalculateAverageDifference_MixedPositiveAndNegative() {\n        List<Integer> numbers = List.of(-10, 0, 10, 20);\n        double result = Answer.calculateAverageDifference(numbers);\n        double expected = 10.0;\n        assertEquals(expected, result, \"The average difference should be 10.0\");\n    }\n\n    @Test\n    public void testCalculateAverageDifference_SameValues() {\n        List<Integer> numbers = List.of(5, 5, 5, 5);\n        double result = Answer.calculateAverageDifference(numbers);\n        double expected = 0.0;\n        assertEquals(expected, result, \"The average difference should be 0.0 as all values are the same\");\n    }\n\n    @Test\n    public void testCalculateAverageDifference_SingleElement() {\n        List<Integer> numbers = List.of(100);\n        double result = Answer.calculateAverageDifference(numbers);\n        double expected = 0.0;  // Not enough data to calculate differences\n        assertEquals(expected, result, \"The average difference should be 0.0 for a single element list\");\n    }\n\n    @Test\n    public void testCalculateAverageDifference_EmptyList() {\n        List<Integer> numbers = List.of();\n        double result = Answer.calculateAverageDifference(numbers);\n        double expected = 0.0;  // Not enough data to calculate differences\n        assertEquals(expected, result, \"The average difference should be 0.0 for an empty list\");\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the average difference between consecutive integers in the provided list.\n *\n * @param numbers a list of integers\n * @return the average difference, or 0 if there are fewer than 2 integers\n */\npublic static double calculateAverageDifference(List<Integer> numbers) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 615, "code_type": "method", "original_language": "java", "file_path": "plantify\\8492e569496c820b6d2249ec1838439748954505\\plantifybackend\\src\\main\\java\\be\\kdg\\integration\\plantifybackend\\Util\\MovingAverage.java\n", "question_type": "Algorithm and data structure", "summary": "Calculates the average of a set of integer lists over a specified period\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef calculate(values: List[int], period: int) -> float:\n    \"\"\"Calculates the average of the last 'period' integers in the given list of values.\n\n    Args:\n        values (List[int]): The list of integers from which to calculate the average.\n        period (int): The number of last elements to include in the average calculation.\n\n    Returns:\n        float: The average of the last 'period' integers, or math.nan if the input list\n                does not contain enough elements or if the period is invalid (<= 0).\n    \"\"\"", "test_code": "import math\nimport unittest\n\n\nclass TestAnswer(unittest.TestCase):\n\n    def test_calculate_with_valid_input(self):\n        values = [1, 2, 3, 4, 5]\n        period = 3\n        expected = 4.0  # (3 + 4 + 5) / 3\n        self.assertEqual(expected, calculate(values, period))\n\n    def test_calculate_with_all_same_values(self):\n        values = [5, 5, 5, 5, 5]\n        period = 5\n        expected = 5.0  # (5 + 5 + 5 + 5 + 5) / 5\n        self.assertEqual(expected, calculate(values, period))\n\n    def test_calculate_with_single_value(self):\n        values = [10]\n        period = 1\n        expected = 10.0  # (10) / 1\n        self.assertEqual(expected, calculate(values, period))\n\n    def test_calculate_with_insufficient_values(self):\n        values = [1, 2]\n        period = 3\n        self.assertTrue(math.isnan(calculate(values, period)))  # Expecting NaN\n\n    def test_calculate_with_empty_list(self):\n        values = []\n        period = 1\n        self.assertTrue(math.isnan(calculate(values, period)))  # Expecting NaN\n\n    def test_calculate_with_negative_period(self):\n        values = [1, 2, 3, 4, 5]\n        period = -1\n        self.assertTrue(math.isnan(calculate(values, period)))  # Expecting NaN", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef calculate(values: List[int], period: int) -> float:\n    \"\"\"Calculates the average of the last 'period' integers in the given list of values.\n\n    Args:\n        values (List[int]): The list of integers from which to calculate the average.\n        period (int): The number of last elements to include in the average calculation.\n\n    Returns:\n        float: The average of the last 'period' integers, or math.nan if the input list\n                does not contain enough elements or if the period is invalid (<= 0).\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculates the average of the last 'period' integers in the given list of values.\n *\n * @param values A vector of integers from which to calculate the average.\n * @type values std::vector<int>\n *\n * @param period The number of last elements to include in the average calculation. \n *               Must be greater than zero.\n * @type period int\n *\n * @return The average of the last `period` integers, or `std::nan` if the input vector \n *         does not contain enough elements or if the period is invalid.\n * @rtype double\n */\n\ndouble calculate(const std::vector<int>& values, int period);", "test_code": "TEST_CASE(\"TestAnswer\") {\n    \n    SECTION(\"test_calculate_with_valid_input\") {\n        std::vector<int> values = {1, 2, 3, 4, 5};\n        int period = 3;\n        double expected = 4.0; // (3 + 4 + 5) / 3\n        REQUIRE(calculate(values, period) == Approx(expected));\n    }\n\n    SECTION(\"test_calculate_with_all_same_values\") {\n        std::vector<int> values = {5, 5, 5, 5, 5};\n        int period = 5;\n        double expected = 5.0; // (5 + 5 + 5 + 5 + 5) / 5\n        REQUIRE(calculate(values, period) == Approx(expected));\n    }\n\n    SECTION(\"test_calculate_with_single_value\") {\n        std::vector<int> values = {10};\n        int period = 1;\n        double expected = 10.0; // (10) / 1\n        REQUIRE(calculate(values, period) == Approx(expected));\n    }\n\n    SECTION(\"test_calculate_with_insufficient_values\") {\n        std::vector<int> values = {1, 2};\n        int period = 3;\n        REQUIRE(std::isnan(calculate(values, period))); // Expecting NaN\n    }\n\n    SECTION(\"test_calculate_with_empty_list\") {\n        std::vector<int> values = {};\n        int period = 1;\n        REQUIRE(std::isnan(calculate(values, period))); // Expecting NaN\n    }\n\n    SECTION(\"test_calculate_with_negative_period\") {\n        std::vector<int> values = {1, 2, 3, 4, 5};\n        int period = -1;\n        REQUIRE(std::isnan(calculate(values, period))); // Expecting NaN\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculates the average of the last 'period' integers in the given list of values.\n *\n * @param values A vector of integers from which to calculate the average.\n * @type values std::vector<int>\n *\n * @param period The number of last elements to include in the average calculation. \n *               Must be greater than zero.\n * @type period int\n *\n * @return The average of the last `period` integers, or `std::nan` if the input vector \n *         does not contain enough elements or if the period is invalid.\n * @rtype double\n */\n\ndouble calculate(const std::vector<int>& values, int period);", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the average of the last 'period' integers in the given list of values.\n *\n * @param values The list of integers from which to calculate the average.\n * @param period The number of last elements to include in the average calculation.\n * @return The average of the last 'period' integers, or Double.NaN if the input list\n *         does not contain enough elements or if the period is invalid (<= 0).\n */\npublic static double calculate(List<Integer> values, int period) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testCalculateWithValidInput() {\n        List<Integer> values = Arrays.asList(1, 2, 3, 4, 5);\n        int period = 3;\n        double expected = 4.0; // (3 + 4 + 5) / 3\n        assertEquals(expected, Answer.calculate(values, period));\n    }\n\n    @Test\n    public void testCalculateWithAllSameValues() {\n        List<Integer> values = Arrays.asList(5, 5, 5, 5, 5);\n        int period = 5;\n        double expected = 5.0; // (5 + 5 + 5 + 5 + 5) / 5\n        assertEquals(expected, Answer.calculate(values, period));\n    }\n\n    @Test\n    public void testCalculateWithSingleValue() {\n        List<Integer> values = Arrays.asList(10);\n        int period = 1;\n        double expected = 10.0; // (10) / 1\n        assertEquals(expected, Answer.calculate(values, period));\n    }\n\n    @Test\n    public void testCalculateWithInsufficientValues() {\n        List<Integer> values = Arrays.asList(1, 2);\n        int period = 3;\n        assertTrue(Double.isNaN(Answer.calculate(values, period))); // Expecting NaN\n    }\n\n    @Test\n    public void testCalculateWithEmptyList() {\n        List<Integer> values = Arrays.asList();\n        int period = 1;\n        assertTrue(Double.isNaN(Answer.calculate(values, period))); // Expecting NaN\n    }\n\n    @Test\n    public void testCalculateWithNegativePeriod() {\n        List<Integer> values = Arrays.asList(1, 2, 3, 4, 5);\n        int period = -1;\n        assertTrue(Double.isNaN(Answer.calculate(values, period))); // Expecting NaN\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the average of the last 'period' integers in the given list of values.\n *\n * @param values The list of integers from which to calculate the average.\n * @param period The number of last elements to include in the average calculation.\n * @return The average of the last 'period' integers, or Double.NaN if the input list\n *         does not contain enough elements or if the period is invalid (<= 0).\n */\npublic static double calculate(List<Integer> values, int period) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 616, "code_type": "method", "original_language": "java", "file_path": "airbyte\\480a43b9ab758e130832186116df78242b6086e2\\airbyte-integrations\\bases\\base-java\\src\\main\\java\\io\\airbyte\\integrations\\destination_async\\AirbyteFileUtils.java\n", "question_type": "Data processing and transformation", "summary": "Converts a size in bytes to a human-readable string representation.", "language_version_list": {"python": {"code_signature": "def byte_count_to_display_size(size_in_bytes: int) -> str:\n    \"\"\"Converts a size in bytes to a human-readable string representation.\n\n    Args:\n        size_in_bytes (int): The size in bytes to convert.\n\n    Returns:\n        str: A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestByteCountToDisplaySizeByteCountToDisplaySize(unittest.TestCase):\n\n    def test_zero_bytes(self):\n        \"\"\"Test case for 0 bytes.\"\"\"\n        input_size = 0\n        expected = \"0 bytes\"\n        self.assertEqual(byte_count_to_display_size(input_size), expected)\n\n    def test_bytes_less_than_kb(self):\n        \"\"\"Test case for bytes less than 1KB.\"\"\"\n        input_size = 500\n        expected = \"500 bytes\"\n        self.assertEqual(byte_count_to_display_size(input_size), expected)\n\n    def test_exactly_one_kb(self):\n        \"\"\"Test case for exactly 1KB.\"\"\"\n        input_size = 1024\n        result = byte_count_to_display_size(input_size)\n        self.assertTrue(result == \"1 KB\" or result == \"1.00 KB\")\n\n    def test_between_kb_and_mb(self):\n        \"\"\"Test case for a size between 1KB and 1MB.\"\"\"\n        input_size = 5000\n        expected = \"4.88 KB\"\n        self.assertEqual(byte_count_to_display_size(input_size), expected)\n\n    def test_exactly_one_mb(self):\n        \"\"\"Test case for exactly 1MB.\"\"\"\n        input_size = 1048576  # 1024 * 1024\n        result = byte_count_to_display_size(input_size)\n        self.assertTrue(result == \"1 MB\" or result == \"1.00 MB\")\n", "prompt": "please write a python function , the function signature as below def byte_count_to_display_size(size_in_bytes: int) -> str:\n    \"\"\"Converts a size in bytes to a human-readable string representation.\n\n    Args:\n        size_in_bytes (int): The size in bytes to convert.\n\n    Returns:\n        str: A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a size in bytes to a human-readable string representation.\n *\n * @param size_in_bytes The size in bytes to convert.\n * @return A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n */\nstd::string byte_count_to_display_size(int size_in_bytes);", "test_code": "", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a size in bytes to a human-readable string representation.\n *\n * @param size_in_bytes The size in bytes to convert.\n * @return A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n */\nstd::string byte_count_to_display_size(int size_in_bytes);", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a size in bytes to a human-readable string representation.\n *\n * @param sizeInBytes The size in bytes to convert.\n * @return A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n */\npublic static String byteCountToDisplaySize(final long sizeInBytes) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Objects;\n\nimport static junit.framework.TestCase.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class Tester {\n\n    /**\n     * Test the byteCountToDisplaySize function with various inputs.\n     */\n\n    @Test\n    public void testZeroBytes() {\n        // Test case for 0 bytes\n        long input = 0L;\n        String expected = \"0 bytes\";\n        assertEquals(expected, Answer.byteCountToDisplaySize(input));\n    }\n\n    @Test\n    public void testBytesLessThanKB() {\n        // Test case for bytes less than 1KB\n        long input = 500L;\n        String expected = \"500 bytes\";\n        assertEquals(expected, Answer.byteCountToDisplaySize(input));\n    }\n\n    @Test\n    public void testExactlyOneKB() {\n        // Test case for exactly 1KB\n        long input = 1024L;\n        assertTrue(Objects.equals(Answer.byteCountToDisplaySize(input), \"1 KB\") || Objects.equals(Answer.byteCountToDisplaySize(input), \"1.00 KB\"));\n    }\n\n    @Test\n    public void testBetweenKBAndMB() {\n        // Test case for a size between 1KB and 1MB\n        long input = 5000L;\n        String expected = \"4.88 KB\";\n        assertEquals(expected, Answer.byteCountToDisplaySize(input));\n    }\n\n    @Test\n    public void testExactlyOneMB() {\n        // Test case for exactly 1MB\n        long input = 1048576L; // 1024 * 1024\n        assertTrue(Objects.equals(Answer.byteCountToDisplaySize(input), \"1 MB\") || Objects.equals(Answer.byteCountToDisplaySize(input), \"1.00 MB\"));\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a size in bytes to a human-readable string representation.\n *\n * @param sizeInBytes The size in bytes to convert.\n * @return A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n */\npublic static String byteCountToDisplaySize(final long sizeInBytes) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 617, "code_type": "method", "original_language": "java", "file_path": "MakDan_project\\f6fdf07f3a1df20cbf2e1cdd4ebd4622e76486e5\\src\\main\\java\\com\\example\\makdan_project\\Main.java\n", "question_type": "Data processing and transformation", "summary": "Parse the JSON file and store the parsed content using MAP\n", "language_version_list": {"python": {"code_signature": "from typing import Dict, Any\n\n\ndef parse_json_file(file_path: str) -> Dict[str, Any]:\n    \"\"\"\n    Parses a JSON file and stores its contents in a dictionary.\n\n    Args:\n        file_path (str): The path to the JSON file to be parsed. The file must exist and contain valid JSON.\n                      The path should be a fully qualified path or relative to the current working directory.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing the key-value pairs parsed from the JSON file.\n    \"\"\"", "test_code": "import json\nimport os\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_valid_json(self):\n        json_content = '{\"name\": \"John\", \"age\": 30}'\n        path = 'temp_valid.json'\n\n        with open(path, 'w') as temp_file:\n            temp_file.write(json_content)\n\n        result = parse_json_file(path)\n        self.assertEqual(\"John\", result.get(\"name\"))\n        self.assertEqual(30, result.get(\"age\"))\n\n        os.remove(path)  # Clean up the temporary file\n\n    def test_empty_json(self):\n        json_content = '{}'\n        path = 'temp_empty.json'\n\n        with open(path, 'w') as temp_file:\n            temp_file.write(json_content)\n\n        result = parse_json_file(path)\n        self.assertTrue(len(result) == 0)\n\n        os.remove(path)  # Clean up the temporary file\n\n    def test_null_input(self):\n        with self.assertRaises(Exception):\n            parse_json_file(None)\n\n    def test_non_json_file(self):\n        not_json_content = \"Hello, World!\"\n        path = 'temp_not_json.txt'\n\n        with open(path, 'w') as temp_file:\n            temp_file.write(not_json_content)\n\n        with self.assertRaises(json.JSONDecodeError):\n            parse_json_file(path)\n\n        os.remove(path)  # Clean up the temporary file\n\n    def test_json_with_array(self):\n        json_content = '{\"names\": [\"John\", \"Doe\"]}'\n        path = 'temp_array.json'\n\n        with open(path, 'w') as temp_file:\n            temp_file.write(json_content)\n\n        result = parse_json_file(path)\n        self.assertIsNotNone(result.get(\"names\"))\n\n        os.remove(path)  # Clean up the temporary file", "prompt": "please write a python function , the function signature as below from typing import Dict, Any\n\n\ndef parse_json_file(file_path: str) -> Dict[str, Any]:\n    \"\"\"\n    Parses a JSON file and stores its contents in a dictionary.\n\n    Args:\n        file_path (str): The path to the JSON file to be parsed. The file must exist and contain valid JSON.\n                      The path should be a fully qualified path or relative to the current working directory.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing the key-value pairs parsed from the JSON file.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Parses a JSON file and stores its contents in a dictionary.\n *\n * @param file_path The path to the JSON file to be parsed.\n *                  Must be a valid file path leading to an existing JSON file.\n * @type file_path std::string\n *\n * @return A dictionary containing the key-value pairs parsed from the JSON file.\n * @rtype std::unordered_map<std::string, Any>\n */\n\nstd::unordered_map<std::string, Any> parse_json_file(const std::string& file_path){}", "test_code": "TEST_CASE(\"Tester\", \"[json]\") {\n    std::string path;\n\n    SECTION(\"valid JSON\") {\n        std::string json_content = R\"({\"name\": \"John\", \"age\": 30})\";\n        path = \"temp_valid.json\";\n\n        std::ofstream temp_file(path);\n        temp_file << json_content;\n        temp_file.close();\n\n        auto result = parse_json_file(path);\n        REQUIRE(result.at(\"name\") == \"John\");\n        REQUIRE(result.at(\"age\") == 30);\n\n        std::remove(path.c_str()); // Clean up the temporary file\n    }\n\n    SECTION(\"empty JSON\") {\n        std::string json_content = R\"({})\";\n        path = \"temp_empty.json\";\n\n        std::ofstream temp_file(path);\n        temp_file << json_content;\n        temp_file.close();\n\n        auto result = parse_json_file(path);\n        REQUIRE(result.empty());\n\n        std::remove(path.c_str()); // Clean up the temporary file\n    }\n\n    SECTION(\"null input\") {\n        REQUIRE_THROWS_AS(parse_json_file(nullptr), std::invalid_argument);\n    }\n\n    SECTION(\"non-JSON file\") {\n        std::string not_json_content = \"Hello, World!\";\n        path = \"temp_not_json.txt\";\n\n        std::ofstream temp_file(path);\n        temp_file << not_json_content;\n        temp_file.close();\n\n        REQUIRE_THROWS_AS(parse_json_file(path), std::runtime_error);\n\n        std::remove(path.c_str()); // Clean up the temporary file\n    }\n\n    SECTION(\"JSON with array\") {\n        std::string json_content = R\"({\"names\": [\"John\", \"Doe\"]})\";\n        path = \"temp_array.json\";\n\n        std::ofstream temp_file(path);\n        temp_file << json_content;\n        temp_file.close();\n\n        auto result = parse_json_file(path);\n        REQUIRE(result.find(\"names\") != result.end());\n\n        std::remove(path.c_str()); // Clean up the temporary file\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Parses a JSON file and stores its contents in a dictionary.\n *\n * @param file_path The path to the JSON file to be parsed.\n *                  Must be a valid file path leading to an existing JSON file.\n * @type file_path std::string\n *\n * @return A dictionary containing the key-value pairs parsed from the JSON file.\n * @rtype std::unordered_map<std::string, Any>\n */\n\nstd::unordered_map<std::string, Any> parse_json_file(const std::string& file_path){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Parses a JSON file and stores its contents in a Map.\n *\n * @param filePath the path to the JSON file to be parsed. The file must exist and contain valid JSON.\n *                 The path should be a fully qualified path or relative to the current working directory.\n * @return a Map<String, Object> containing the key-value pairs parsed from the JSON file. If the JSON\n *         file is empty or contains only simple key-value pairs without nested structures, the resulting\n *         Map will be correspondingly simple. The function returns an empty Map if the file is empty.\n * @throws FileNotFoundException if the specified file does not exist or cannot be opened. This exception\n *         is caught within the function and logged to the standard output, but it might be more appropriate\n *         in a real-world application to rethrow it or handle it in a way that informs the user more effectively.\n */\npublic static Map<String, Object> parseJsonFile(String filePath) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport org.junit.jupiter.api.Test;\nimport java.util.Map;\n\npublic class Tester {\n\n    @Test\n    public void testValidJson() throws IOException {\n        String jsonContent = \"{\\\"name\\\":\\\"John\\\", \\\"age\\\":30}\";\n        Path path = Files.createTempFile(null, \".json\");\n        Files.write(path, jsonContent.getBytes());\n\n        Map<String, Object> result = Answer.parseJsonFile(path.toString());\n        assertEquals(\"John\", result.get(\"name\"));\n        assertEquals(30, result.get(\"age\"));\n    }\n\n    @Test\n    public void testEmptyJson() throws IOException {\n        String jsonContent = \"{}\";\n        Path path = Files.createTempFile(null, \".json\");\n        Files.write(path, jsonContent.getBytes());\n\n        Map<String, Object> result = Answer.parseJsonFile(path.toString());\n        assertTrue(result.isEmpty());\n    }\n\n\n\n    @Test\n    public void testNullInput() {\n        assertThrows(NullPointerException.class, () -> Answer.parseJsonFile(null));\n    }\n\n    @Test\n    public void testNonJsonFile() throws IOException {\n        String notJsonContent = \"Hello, World!\";\n        Path path = Files.createTempFile(null, \".txt\");\n        Files.write(path, notJsonContent.getBytes());\n\n        assertThrows(Exception.class, () -> Answer.parseJsonFile(path.toString()));\n    }\n\n    @Test\n    public void testJsonWithArray() throws IOException {\n        String jsonContent = \"{\\\"names\\\":[\\\"John\\\", \\\"Doe\\\"]}\";\n        Path path = Files.createTempFile(null, \".json\");\n        Files.write(path, jsonContent.getBytes());\n\n        Map<String, Object> result = Answer.parseJsonFile(path.toString());\n        assertNotNull(result.get(\"names\"));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Parses a JSON file and stores its contents in a Map.\n *\n * @param filePath the path to the JSON file to be parsed. The file must exist and contain valid JSON.\n *                 The path should be a fully qualified path or relative to the current working directory.\n * @return a Map<String, Object> containing the key-value pairs parsed from the JSON file. If the JSON\n *         file is empty or contains only simple key-value pairs without nested structures, the resulting\n *         Map will be correspondingly simple. The function returns an empty Map if the file is empty.\n * @throws FileNotFoundException if the specified file does not exist or cannot be opened. This exception\n *         is caught within the function and logged to the standard output, but it might be more appropriate\n *         in a real-world application to rethrow it or handle it in a way that informs the user more effectively.\n */\npublic static Map<String, Object> parseJsonFile(String filePath) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 623, "code_type": "method", "original_language": "java", "file_path": "PDB-Explorer\\8726fe10f68d42c55d23327f7dd4d0481af45b4d\\src\\main\\java\\pdbexplorer\\window\\ChartHandler.java\n", "question_type": "Data processing and transformation", "summary": "Convert a Color object to its corresponding RGB color code string, formatted as a hexadecimal string\n", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a Color object to its corresponding RGB color code string.\n *\n * @param color the Color object to convert\n * @return a hexadecimal string representing the RGB color code\n */\npublic static String toRGBCode(Color color) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\nimport java.awt.Color;\n\npublic class Tester {\n\n    @Test\n    public void testToRGBCode_White() {\n        Color color = new Color(255, 255, 255); // White\n        String expected = \"#FFFFFF\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testToRGBCode_Black() {\n        Color color = new Color(0, 0, 0); // Black\n        String expected = \"#000000\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testToRGBCode_Red() {\n        Color color = new Color(255, 0, 0); // Red\n        String expected = \"#FF0000\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testToRGBCode_Green() {\n        Color color = new Color(0, 255, 0); // Green\n        String expected = \"#00FF00\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testToRGBCode_Blue() {\n        Color color = new Color(0, 0, 255); // Blue\n        String expected = \"#0000FF\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testToRGBCode_CustomColor() {\n        Color color = new Color(255, 87, 51); // Custom Color\n        String expected = \"#FF5733\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a Color object to its corresponding RGB color code string.\n *\n * @param color the Color object to convert\n * @return a hexadecimal string representing the RGB color code\n */\npublic static String toRGBCode(Color color) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 625, "code_type": "method", "original_language": "java", "file_path": "idatg2003.gr13.chaosGame\\aae8f3b053cf80a30cbdfeb520c7f56ff571c9c0\\src\\main\\java\\modul\\chaosgameclasses\\ChaosGameFileHandler.java\n", "question_type": "Data processing and transformation", "summary": "Read data from the file at the specified path, determine whether the string or integer or floating point number in each line of the file, and perform type conversion\n", "language_version_list": {"python": {"code_signature": "from typing import List, Union\n\n\ndef read_data_from_file(path: str) -> List[Union[int, float, str]]:\n    \"\"\"\n    Reads data from a specified file and determines the type of each line.\n    This function processes each line of the specified file and attempts to convert it\n    into either an integer, a floating-point number, or a string.\n\n    Args:\n        path (str): The path to the file to be read. The file should exist and be accessible for reading.\n\n    Returns:\n        list: A list containing the converted values of each line in the file. Each element\n              can be an int, float, or str, depending on the content of the line.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        PermissionError: If the program lacks permissions to read the file.\n        IOError: If an I/O error occurs while reading the file.\n    \"\"\"\n", "test_code": "import os\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def create_test_file(self, file_name, content):\n        with open(file_name, 'w') as writer:\n            writer.write(content)\n\n    def test_read_valid_integers(self):\n        file_path = \"valid_integers.txt\"\n        self.create_test_file(file_path, \"42\\n-7\\n0\\n100\\n\")\n        result = read_data_from_file(file_path)\n        self.assertEqual(4, len(result))\n        self.assertEqual(42, result[0])\n        self.assertEqual(-7, result[1])\n        self.assertEqual(0, result[2])\n        self.assertEqual(100, result[3])\n        os.remove(file_path)  # Clean up the test file\n\n    def test_read_valid_floats(self):\n        file_path = \"valid_floats.txt\"\n        self.create_test_file(file_path, \"3.14\\n-0.001\\n2.71828\\n0.0\\n\")\n        result = read_data_from_file(file_path)\n        self.assertEqual(4, len(result))\n        self.assertEqual(3.14, result[0])\n        self.assertEqual(-0.001, result[1])\n        self.assertEqual(2.71828, result[2])\n        self.assertEqual(0.0, result[3])\n        os.remove(file_path)  # Clean up the test file\n\n    def test_read_mixed_data(self):\n        file_path = \"mixed_data.txt\"\n        self.create_test_file(file_path, \"Hello\\n42\\n3.14\\nWorld\\n-19.99\\n\")\n        result = read_data_from_file(file_path)\n        self.assertEqual(5, len(result))\n        self.assertEqual(\"Hello\", result[0])\n        self.assertEqual(42, result[1])\n        self.assertEqual(3.14, result[2])\n        self.assertEqual(\"World\", result[3])\n        self.assertEqual(-19.99, result[4])\n        os.remove(file_path)  # Clean up the test file\n\n    def test_read_empty_file(self):\n        file_path = \"empty_file.txt\"\n        self.create_test_file(file_path, \"\")\n        result = read_data_from_file(file_path)\n        self.assertEqual(0, len(result))\n        os.remove(file_path)  # Clean up the test file\n\n    def test_read_invalid_data(self):\n        file_path = \"invalid_data.txt\"\n        self.create_test_file(file_path, \"Hello\\n42a\\n3.14.15\\nWorld!\\n\")\n        result = read_data_from_file(file_path)\n        self.assertEqual(4, len(result))\n        self.assertEqual(\"Hello\", result[0])\n        self.assertEqual(\"42a\", result[1])\n        self.assertEqual(\"3.14.15\", result[2])\n        self.assertEqual(\"World!\", result[3])\n        os.remove(file_path)  # Clean up the test file\n", "prompt": "please write a python function , the function signature as below from typing import List, Union\n\n\ndef read_data_from_file(path: str) -> List[Union[int, float, str]]:\n    \"\"\"\n    Reads data from a specified file and determines the type of each line.\n    This function processes each line of the specified file and attempts to convert it\n    into either an integer, a floating-point number, or a string.\n\n    Args:\n        path (str): The path to the file to be read. The file should exist and be accessible for reading.\n\n    Returns:\n        list: A list containing the converted values of each line in the file. Each element\n              can be an int, float, or str, depending on the content of the line.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        PermissionError: If the program lacks permissions to read the file.\n        IOError: If an I/O error occurs while reading the file.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads data from a specified file and determines the type of each line.\n *\n * @param path The path to the file to be read. The file should exist and be \n *             accessible for reading.\n * @type path const std::string&\n *\n * @return A vector containing the converted values of each line in the file. Each \n *         element can be an `int`, `float`, or `std::string`, depending on the content \n *         of the line.\n * @rtype std::vector<std::variant<int, float, std::string>>\n *\n * @throws std::runtime_error If the specified file does not exist or if there \n *         is an error reading the file.\n */\n\nstd::vector<std::variant<int, float, std::string>> read_data_from_file(const std::string& path);", "test_code": "void create_test_file(const std::string& file_name, const std::string& content) {\n    std::ofstream writer(file_name);\n    writer << content;\n    writer.close();\n}\n\nTEST_CASE(\"Read valid integers\") {\n    std::string file_path = \"valid_integers.txt\";\n    create_test_file(file_path, \"42\\n-7\\n0\\n100\\n\");\n    auto result = read_data_from_file(file_path);\n    \n    REQUIRE(result.size() == 4);\n    REQUIRE(std::get<int>(result[0]) == 42);\n    REQUIRE(std::get<int>(result[1]) == -7);\n    REQUIRE(std::get<int>(result[2]) == 0);\n    REQUIRE(std::get<int>(result[3]) == 100);\n\n    std::remove(file_path.c_str()); // Clean up the test file\n}\n\nTEST_CASE(\"Read valid floats\") {\n    std::string file_path = \"valid_floats.txt\";\n    create_test_file(file_path, \"3.14\\n-0.001\\n2.71828\\n0.0\\n\");\n    auto result = read_data_from_file(file_path);\n    \n    REQUIRE(result.size() == 4);\n    REQUIRE(std::get<float>(result[0]) == Approx(3.14f));\n    REQUIRE(std::get<float>(result[1]) == Approx(-0.001f));\n    REQUIRE(std::get<float>(result[2]) == Approx(2.71828f));\n    REQUIRE(std::get<float>(result[3]) == Approx(0.0f));\n\n    std::remove(file_path.c_str()); // Clean up the test file\n}\n\nTEST_CASE(\"Read mixed data\") {\n    std::string file_path = \"mixed_data.txt\";\n    create_test_file(file_path, \"Hello\\n42\\n3.14\\nWorld\\n-19.99\\n\");\n    auto result = read_data_from_file(file_path);\n    \n    REQUIRE(result.size() == 5);\n    REQUIRE(std::get<std::string>(result[0]) == \"Hello\");\n    REQUIRE(std::get<int>(result[1]) == 42);\n    REQUIRE(std::get<float>(result[2]) == Approx(3.14f));\n    REQUIRE(std::get<std::string>(result[3]) == \"World\");\n    REQUIRE(std::get<float>(result[4]) == Approx(-19.99f));\n\n    std::remove(file_path.c_str()); // Clean up the test file\n}\n\nTEST_CASE(\"Read empty file\") {\n    std::string file_path = \"empty_file.txt\";\n    create_test_file(file_path, \"\");\n    auto result = read_data_from_file(file_path);\n    \n    REQUIRE(result.size() == 0);\n\n    std::remove(file_path.c_str()); // Clean up the test file\n}\n\nTEST_CASE(\"Read invalid data\") {\n    std::string file_path = \"invalid_data.txt\";\n    create_test_file(file_path, \"Hello\\n42a\\n3.14.15\\nWorld!\\n\");\n    auto result = read_data_from_file(file_path);\n    \n    REQUIRE(result.size() == 4);\n    REQUIRE(std::get<std::string>(result[0]) == \"Hello\");\n    REQUIRE(std::get<std::string>(result[1]) == \"42a\");\n    REQUIRE(std::get<std::string>(result[2]) == \"3.14.15\");\n    REQUIRE(std::get<std::string>(result[3]) == \"World!\");\n\n    std::remove(file_path.c_str()); // Clean up the test file\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads data from a specified file and determines the type of each line.\n *\n * @param path The path to the file to be read. The file should exist and be \n *             accessible for reading.\n * @type path const std::string&\n *\n * @return A vector containing the converted values of each line in the file. Each \n *         element can be an `int`, `float`, or `std::string`, depending on the content \n *         of the line.\n * @rtype std::vector<std::variant<int, float, std::string>>\n *\n * @throws std::runtime_error If the specified file does not exist or if there \n *         is an error reading the file.\n */\n\nstd::vector<std::variant<int, float, std::string>> read_data_from_file(const std::string& path);", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads data from a specified file and determines the type of each line.\n * The method processes each line of the file and attempts to convert it\n * into either an integer, a floating-point number, or a string.\n *\n * @param path the path to the file to be read. The file should exist and be accessible for reading.\n *\n * @return a list of Objects where each object can be an Integer, Float, or String,\n *         representing the converted values of each line in the file.\n *\n * @throws IllegalArgumentException if an I/O error occurs while reading the file.\n *         This may happen if the file does not exist, or if the program lacks\n *         permissions to read the file.\n */\npublic List<Object> readDataFromFile(String path) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Tester {\n\n    private void createTestFile(String fileName, String content) throws IOException {\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(fileName))) {\n            writer.write(content);\n        }\n    }\n\n    @Test\n    void testReadValidIntegers() throws IOException {\n        String filePath = \"valid_integers.txt\";\n        createTestFile(filePath, \"42\\n-7\\n0\\n100\\n\");\n\n        Answer answer = new Answer();\n        List<Object> result = answer.readDataFromFile(filePath);\n\n        assertEquals(4, result.size());\n        assertEquals(42, result.get(0));\n        assertEquals(-7, result.get(1));\n        assertEquals(0, result.get(2));\n        assertEquals(100, result.get(3));\n    }\n\n    @Test\n    void testReadValidFloats() throws IOException {\n        String filePath = \"valid_floats.txt\";\n        createTestFile(filePath, \"3.14\\n-0.001\\n2.71828\\n0.0\\n\");\n\n        Answer answer = new Answer();\n        List<Object> result = answer.readDataFromFile(filePath);\n\n        assertEquals(4, result.size());\n        assertEquals(3.14f, result.get(0));\n        assertEquals(-0.001f, result.get(1));\n        assertEquals(2.71828f, result.get(2));\n        assertEquals(0.0f, result.get(3));\n    }\n\n    @Test\n    void testReadMixedData() throws IOException {\n        String filePath = \"mixed_data.txt\";\n        createTestFile(filePath, \"Hello\\n42\\n3.14\\nWorld\\n-19.99\\n\");\n\n        Answer answer = new Answer();\n        List<Object> result = answer.readDataFromFile(filePath);\n\n        assertEquals(5, result.size());\n        assertEquals(\"Hello\", result.get(0));\n        assertEquals(42, result.get(1));\n        assertEquals(3.14f, result.get(2));\n        assertEquals(\"World\", result.get(3));\n        assertEquals(-19.99f, result.get(4));\n    }\n\n    @Test\n    void testReadEmptyFile() throws IOException {\n        String filePath = \"empty_file.txt\";\n        createTestFile(filePath, \"\");\n\n        Answer answer = new Answer();\n        List<Object> result = answer.readDataFromFile(filePath);\n\n        assertEquals(0, result.size());\n    }\n\n    @Test\n    void testReadInvalidData() throws IOException {\n        String filePath = \"invalid_data.txt\";\n        createTestFile(filePath, \"Hello\\n42a\\n3.14.15\\nWorld!\\n\");\n\n        Answer answer = new Answer();\n        List<Object> result = answer.readDataFromFile(filePath);\n\n        assertEquals(4, result.size());\n        assertEquals(\"Hello\", result.get(0));\n        assertEquals(\"42a\", result.get(1));\n        assertEquals(\"3.14.15\", result.get(2));\n        assertEquals(\"World!\", result.get(3));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Reads data from a specified file and determines the type of each line.\n * The method processes each line of the file and attempts to convert it\n * into either an integer, a floating-point number, or a string.\n *\n * @param path the path to the file to be read. The file should exist and be accessible for reading.\n *\n * @return a list of Objects where each object can be an Integer, Float, or String,\n *         representing the converted values of each line in the file.\n *\n * @throws IllegalArgumentException if an I/O error occurs while reading the file.\n *         This may happen if the file does not exist, or if the program lacks\n *         permissions to read the file.\n */\npublic List<Object> readDataFromFile(String path) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 626, "code_type": "method", "original_language": "java", "file_path": "idatg2003.gr13.chaosGame\\aae8f3b053cf80a30cbdfeb520c7f56ff571c9c0\\src\\main\\java\\modul\\chaosgameclasses\\ChaosGameFileHandler.java\n", "question_type": "Data processing and transformation", "summary": "Read the file under the specified path, process each line of the file, remove in-line comments (parts starting with #), remove line breaks, and return a list of the processed line contents.\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef read_file_and_process_lines(path: str) -> List[str]:\n    \"\"\"\n    Reads a file from the specified path, processes each line to remove inline comments,\n    removes line breaks, and returns a list of the processed line contents.\n\n    Args:\n        path (str): The path to the file to be read.The path to the file to be read.\n\n    Returns:\n        List[str]: A list of strings, each representing a processed line from the file.\n    \"\"\"\n", "test_code": "import os\nimport unittest\n\n\nclass TestAnswer(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Create a temporary file for testing.\"\"\"\n        self.test_file_path = \"testFile.txt\"\n        open(self.test_file_path, 'w').close()  # Create an empty file\n\n    def write_to_file(self, content):\n        \"\"\"Helper method to write to the test file.\"\"\"\n        with open(self.test_file_path, 'w') as writer:\n            writer.write(content)\n\n    def test_normal_input(self):\n        \"\"\"Test processing of normal input.\"\"\"\n        self.write_to_file(\"Line 1\\nLine 2 # Comment\\nLine 3\\n\")\n        result = read_file_and_process_lines(self.test_file_path)\n        self.assertEqual(result, [\"Line 1\", \"Line 2\", \"Line 3\"])\n\n    def test_only_comments(self):\n        \"\"\"Test processing when only comments are present.\"\"\"\n        self.write_to_file(\"# This is a comment\\n# Another comment\\n\")\n        result = read_file_and_process_lines(self.test_file_path)\n        self.assertEqual(result, [])\n\n    def test_empty_lines(self):\n        \"\"\"Test processing with empty lines.\"\"\"\n        self.write_to_file(\"Line 1\\n\\nLine 2\\n\\n\\nLine 3 # Comment\\n\")\n        result = read_file_and_process_lines(self.test_file_path)\n        self.assertEqual(result, [\"Line 1\", \"Line 2\", \"Line 3\"])\n\n    def test_no_inline_comments(self):\n        \"\"\"Test processing when there are no inline comments.\"\"\"\n        self.write_to_file(\"Line 1\\nLine 2\\nLine 3\\n\")\n        result = read_file_and_process_lines(self.test_file_path)\n        self.assertEqual(result, [\"Line 1\", \"Line 2\", \"Line 3\"])\n\n    def test_only_new_lines(self):\n        \"\"\"Test processing with only new lines.\"\"\"\n        self.write_to_file(\"\\n\\n\\n\\n\")\n        result = read_file_and_process_lines(self.test_file_path)\n        self.assertEqual(result, [])\n\n    def test_mixed_content(self):\n        \"\"\"Test processing with mixed content.\"\"\"\n        self.write_to_file(\"Valid line\\n# This is a comment\\nLine 2\\n# Another comment\\n\\nLine 3 # End of line comment\\n\")\n        result = read_file_and_process_lines(self.test_file_path)\n        self.assertEqual(result, [\"Valid line\", \"Line 2\", \"Line 3\"])\n\n    def tearDown(self):\n        \"\"\"Cleanup after tests.\"\"\"\n        try:\n            os.remove(self.test_file_path)\n        except OSError:\n            pass  # Ignore if the file doesn't exist", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef read_file_and_process_lines(path: str) -> List[str]:\n    \"\"\"\n    Reads a file from the specified path, processes each line to remove inline comments,\n    removes line breaks, and returns a list of the processed line contents.\n\n    Args:\n        path (str): The path to the file to be read.The path to the file to be read.\n\n    Returns:\n        List[str]: A list of strings, each representing a processed line from the file.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "\n/**\n * @brief Reads a file from the specified path, processes each line to remove inline comments,\n * removes line breaks, and returns a list of the processed line contents.\n *\n * @param path The path to the file to be read.\n * @return std::vector<std::string> A vector of strings, each representing a processed line from the file.\n */\nstd::vector<std::string> read_file_and_process_lines(const std::string& path);", "test_code": "TEST_CASE_METHOD(TestAnswer, \"Test processing of normal input\") {\n    write_to_file(\"Line 1\\nLine 2 # Comment\\nLine 3\\n\");\n    auto result = read_file_and_process_lines(test_file_path);\n    REQUIRE(result == std::vector<std::string>{\"Line 1\", \"Line 2\", \"Line 3\"});\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test processing when only comments are present\") {\n    write_to_file(\"# This is a comment\\n# Another comment\\n\");\n    auto result = read_file_and_process_lines(test_file_path);\n    REQUIRE(result.empty());\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test processing with empty lines\") {\n    write_to_file(\"Line 1\\n\\nLine 2\\n\\n\\nLine 3 # Comment\\n\");\n    auto result = read_file_and_process_lines(test_file_path);\n    REQUIRE(result == std::vector<std::string>{\"Line 1\", \"Line 2\", \"Line 3\"});\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test processing when there are no inline comments\") {\n    write_to_file(\"Line 1\\nLine 2\\nLine 3\\n\");\n    auto result = read_file_and_process_lines(test_file_path);\n    REQUIRE(result == std::vector<std::string>{\"Line 1\", \"Line 2\", \"Line 3\"});\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test processing with only new lines\") {\n    write_to_file(\"\\n\\n\\n\\n\");\n    auto result = read_file_and_process_lines(test_file_path);\n    REQUIRE(result.empty());\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test processing with mixed content\") {\n    write_to_file(\"Valid line\\n# This is a comment\\nLine 2\\n# Another comment\\n\\nLine 3 # End of line comment\\n\");\n    auto result = read_file_and_process_lines(test_file_path);\n    REQUIRE(result == std::vector<std::string>{\"Valid line\", \"Line 2\", \"Line 3\"});\n}", "prompt": "please write a cpp function , the function signature as below \n/**\n * @brief Reads a file from the specified path, processes each line to remove inline comments,\n * removes line breaks, and returns a list of the processed line contents.\n *\n * @param path The path to the file to be read.\n * @return std::vector<std::string> A vector of strings, each representing a processed line from the file.\n */\nstd::vector<std::string> read_file_and_process_lines(const std::string& path);", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads a file from the specified path, processes each line to remove inline comments,\n * removes line breaks, and returns a list of the processed line contents.\n *\n * @param path The path to the file to be read.\n * @return A list of strings, each representing a processed line from the file.\n * @throws IllegalArgumentException if an I/O error occurs while reading the file.\n */\npublic List<String> readFileAndProcessLines(String path) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.BeforeEach;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass Tester {\n\n    private String testFilePath;\n\n    @BeforeEach\n    void setUp() throws IOException {\n        // Create a temporary file for testing\n        testFilePath = \"testFile.txt\";\n        File file = new File(testFilePath);\n        file.createNewFile();\n    }\n\n    // Helper method to write to the test file\n    private void writeToFile(String content) throws IOException {\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(testFilePath))) {\n            writer.write(content);\n        }\n    }\n\n    @Test\n    void testNormalInput() throws IOException {\n        writeToFile(\"Line 1\\nLine 2 # Comment\\nLine 3\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(\"Line 1\", \"Line 2\", \"Line 3\"), result);\n    }\n\n    @Test\n    void testOnlyComments() throws IOException {\n        writeToFile(\"# This is a comment\\n# Another comment\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(), result);\n    }\n\n    @Test\n    void testEmptyLines() throws IOException {\n        writeToFile(\"Line 1\\n\\nLine 2\\n\\n\\nLine 3 # Comment\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(\"Line 1\", \"Line 2\", \"Line 3\"), result);\n    }\n\n    @Test\n    void testNoInlineComments() throws IOException {\n        writeToFile(\"Line 1\\nLine 2\\nLine 3\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(\"Line 1\", \"Line 2\", \"Line 3\"), result);\n    }\n\n\n    @Test\n    void testOnlyNewLines() throws IOException {\n        writeToFile(\"\\n\\n\\n\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(), result);\n    }\n\n    @Test\n    void testMixedContent() throws IOException {\n        writeToFile(\"Valid line\\n# This is a comment\\nLine 2\\n# Another comment\\n\\nLine 3 # End of line comment\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(\"Valid line\", \"Line 2\", \"Line 3\"), result);\n    }\n\n    // Cleanup after tests\n    @AfterEach\n    void tearDown() throws IOException {\n        Files.deleteIfExists(Paths.get(testFilePath));\n    }\n\n    // The method to be tested\n    public List<String> readFileAndProcessLines(String path) {\n        List<String> processedLines = new ArrayList<>();\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {\n            String line;\n\n            while ((line = reader.readLine()) != null) {\n                // Remove inline comments\n                line = line.split(\"#\")[0].trim();\n                // Only add non-empty lines to the list\n                if (!line.isEmpty()) {\n                    processedLines.add(line);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new IllegalArgumentException(\"Error reading file: \" + e.getMessage());\n        }\n\n        return processedLines;\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Reads a file from the specified path, processes each line to remove inline comments,\n * removes line breaks, and returns a list of the processed line contents.\n *\n * @param path The path to the file to be read.\n * @return A list of strings, each representing a processed line from the file.\n * @throws IllegalArgumentException if an I/O error occurs while reading the file.\n */\npublic List<String> readFileAndProcessLines(String path) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 628, "code_type": "method", "original_language": "java", "file_path": "idatg2003.gr13.chaosGame\\aae8f3b053cf80a30cbdfeb520c7f56ff571c9c0\\src\\main\\java\\modul\\chaosgameclasses\\ChaosGameFileHandler.java\n", "question_type": "Data processing and transformation", "summary": "Modify a specific line in the specified file and update the content of the line based on the new value you enter\n", "language_version_list": {"python": {"code_signature": "def modify_line_in_file(file_path: str, line_number: int, new_value: str) -> None:\n    \"\"\"\n    Modifies a specific line in the given file.\n\n    Args:\n        file_path (str): The path of the file to be modified.\n        line_number (str): The line number to be modified (1-based index).\n        new_value (str): The new value to update the line with.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import os\nimport unittest\n\n\nclass TestAnswer(unittest.TestCase):\n    TEST_FILE = \"testFile.txt\"\n\n    def setUp(self):\n        # Create a test file with initial content\n        with open(self.TEST_FILE, 'w') as writer:\n            writer.write(\"Line 1\\n\")\n            writer.write(\"Line 2\\n\")\n            writer.write(\"Line 3\\n\")\n\n    def tearDown(self):\n        # Clean up the test file after each test\n        try:\n            os.remove(self.TEST_FILE)\n        except FileNotFoundError:\n            pass  # File might already be deleted\n\n    def test_modify_line_success(self):\n        modify_line_in_file(self.TEST_FILE, 2, \"Updated Line 2\")\n        with open(self.TEST_FILE, 'r') as reader:\n            self.assertEqual(\"Line 1\\n\", reader.readline())\n            self.assertEqual(\"Updated Line 2\\n\", reader.readline())\n            self.assertEqual(\"Line 3\\n\", reader.readline())\n\n    def test_modify_first_line(self):\n        modify_line_in_file(self.TEST_FILE, 1, \"Updated Line 1\")\n        with open(self.TEST_FILE, 'r') as reader:\n            self.assertEqual(\"Updated Line 1\\n\", reader.readline())\n            self.assertEqual(\"Line 2\\n\", reader.readline())\n            self.assertEqual(\"Line 3\\n\", reader.readline())\n\n    def test_modify_last_line(self):\n        modify_line_in_file(self.TEST_FILE, 3, \"Updated Line 3\")\n        with open(self.TEST_FILE, 'r') as reader:\n            self.assertEqual(\"Line 1\\n\", reader.readline())\n            self.assertEqual(\"Line 2\\n\", reader.readline())\n            self.assertEqual(\"Updated Line 3\\n\", reader.readline())\n\n    def test_modify_non_existent_line(self):\n        with self.assertRaises(Exception):\n            modify_line_in_file(self.TEST_FILE, 4, \"Should Fail\")\n\n    def test_modify_negative_line_number(self):\n        with self.assertRaises(Exception):\n            modify_line_in_file(self.TEST_FILE, 0, \"Should Fail\")\n", "prompt": "please write a python function , the function signature as below def modify_line_in_file(file_path: str, line_number: int, new_value: str) -> None:\n    \"\"\"\n    Modifies a specific line in the given file.\n\n    Args:\n        file_path (str): The path of the file to be modified.\n        line_number (str): The line number to be modified (1-based index).\n        new_value (str): The new value to update the line with.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Modifies a specific line in the given file.\n *\n * @param filePath The path of the file to be modified.\n *                 Must be a valid file path leading to an accessible file.\n * @type filePath std::string\n *\n * @param lineNumber The line number to be modified (1-based index).\n *                   Must be greater than zero and within the total number of lines in the file.\n * @type lineNumber int\n *\n * @param newValue The new value to update the line with.\n * @type newValue std::string\n *\n * @return void\n */\n\nvoid modifyLineInFile(const std::string& filePath, int lineNumber, const std::string& newValue);", "test_code": "TEST_CASE_METHOD(TestAnswer, \"Test Modify Line Success\") {\n    modifyLineInFile(TEST_FILE, 2, \"Updated Line 2\");\n    \n    std::ifstream reader(TEST_FILE);\n    std::string line;\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Line 1\");\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Updated Line 2\");\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Line 3\");\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test Modify First Line\") {\n    modifyLineInFile(TEST_FILE, 1, \"Updated Line 1\");\n    \n    std::ifstream reader(TEST_FILE);\n    std::string line;\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Updated Line 1\");\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Line 2\");\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Line 3\");\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test Modify Last Line\") {\n    modifyLineInFile(TEST_FILE, 3, \"Updated Line 3\");\n    \n    std::ifstream reader(TEST_FILE);\n    std::string line;\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Line 1\");\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Line 2\");\n    \n    REQUIRE(std::getline(reader, line));\n    REQUIRE(line == \"Updated Line 3\");\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test Modify Non-Existent Line\") {\n    REQUIRE_THROWS_AS(modifyLineInFile(TEST_FILE, 4, \"Should Fail\"), std::exception);\n}\n\nTEST_CASE_METHOD(TestAnswer, \"Test Modify Negative Line Number\") {\n    REQUIRE_THROWS_AS(modifyLineInFile(TEST_FILE, 0, \"Should Fail\"), std::exception);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Modifies a specific line in the given file.\n *\n * @param filePath The path of the file to be modified.\n *                 Must be a valid file path leading to an accessible file.\n * @type filePath std::string\n *\n * @param lineNumber The line number to be modified (1-based index).\n *                   Must be greater than zero and within the total number of lines in the file.\n * @type lineNumber int\n *\n * @param newValue The new value to update the line with.\n * @type newValue std::string\n *\n * @return void\n */\n\nvoid modifyLineInFile(const std::string& filePath, int lineNumber, const std::string& newValue);", "addition_info": ""}, "java": {"code_signature": "/**\n * Modifies a specific line in the given file.\n *\n * @param filePath the path of the file to be modified\n * @param lineNumber the line number to be modified (1-based index)\n * @param newValue the new value to update the line with\n * @throws IOException if an I/O error occurs\n */\npublic void modifyLineInFile(String filePath, int lineNumber, String newValue) throws IOException {}", "test_code": "{\n\n    private static final String TEST_FILE = \"testFile.txt\";\n    private Answer answer;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        answer = new Answer();\n        // Create a test file with initial content\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(TEST_FILE))) {\n            writer.write(\"Line 1\");\n            writer.newLine();\n            writer.write(\"Line 2\");\n            writer.newLine();\n            writer.write(\"Line 3\");\n            writer.newLine();\n        }\n    }\n\n    @AfterEach\n    public void tearDown() throws IOException {\n        // Clean up the test file after each test\n        Files.deleteIfExists(Paths.get(TEST_FILE));\n    }\n\n    @Test\n    public void testModifyLine_Success() throws IOException {\n        answer.modifyLineInFile(TEST_FILE, 2, \"Updated Line 2\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(TEST_FILE))) {\n            assertEquals(\"Line 1\", reader.readLine());\n            assertEquals(\"Updated Line 2\", reader.readLine());\n            assertEquals(\"Line 3\", reader.readLine());\n        }\n    }\n\n    @Test\n    public void testModifyFirstLine() throws IOException {\n        answer.modifyLineInFile(TEST_FILE, 1, \"Updated Line 1\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(TEST_FILE))) {\n            assertEquals(\"Updated Line 1\", reader.readLine());\n            assertEquals(\"Line 2\", reader.readLine());\n            assertEquals(\"Line 3\", reader.readLine());\n        }\n    }\n\n    @Test\n    public void testModifyLastLine() throws IOException {\n        answer.modifyLineInFile(TEST_FILE, 3, \"Updated Line 3\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(TEST_FILE))) {\n            assertEquals(\"Line 1\", reader.readLine());\n            assertEquals(\"Line 2\", reader.readLine());\n            assertEquals(\"Updated Line 3\", reader.readLine());\n        }\n    }\n\n    @Test\n    public void testModifyNonExistentLine() {\n        assertThrows(Exception.class, () -> {\n            answer.modifyLineInFile(TEST_FILE, 4, \"Should Fail\");\n        });\n    }\n\n    @Test\n    public void testModifyNegativeLineNumber() {\n        assertThrows(Exception.class, () -> {\n            answer.modifyLineInFile(TEST_FILE, 0, \"Should Fail\");\n        });\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Modifies a specific line in the given file.\n *\n * @param filePath the path of the file to be modified\n * @param lineNumber the line number to be modified (1-based index)\n * @param newValue the new value to update the line with\n * @throws IOException if an I/O error occurs\n */\npublic void modifyLineInFile(String filePath, int lineNumber, String newValue) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 630, "code_type": "method", "original_language": "java", "file_path": "algorithms4-sedgewick-wayne\\c40be7fb47a38629e59de0af49871446ed0d1a79\\src\\main\\java\\com\\chao\\chapter2\\session1\\Exercise17_animation_chatGPT.java\n", "question_type": "Algorithm and data structure", "summary": "Implement insertion sorting\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef insertion_sort(arr:List):\n    \"\"\"\n    Sorts a list of floats in ascending order using the insertion sort algorithm.\n\n    Args:\n        arr (List): The list of floats to be sorted.\n\n    Returns:\n\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestAnswer(unittest.TestCase):\n    def test_basic_unsorted_array(self):\n        \"\"\"Test case 1: Basic unsorted array.\"\"\"\n        arr = [12.4, 11.2, 13.5, 5.6, 6.7]\n        expected = [5.6, 6.7, 11.2, 12.4, 13.5]\n        insertion_sort(arr)\n        self.assertEqual(expected, arr)\n\n    def test_already_sorted_array(self):\n        \"\"\"Test case 2: Already sorted array.\"\"\"\n        arr = [1.1, 2.2, 3.3, 4.4, 5.5]\n        expected = [1.1, 2.2, 3.3, 4.4, 5.5]\n        insertion_sort(arr)\n        self.assertEqual(expected, arr)\n\n    def test_reverse_sorted_array(self):\n        \"\"\"Test case 3: Reverse sorted array.\"\"\"\n        arr = [5.5, 4.4, 3.3, 2.2, 1.1]\n        expected = [1.1, 2.2, 3.3, 4.4, 5.5]\n        insertion_sort(arr)\n        self.assertEqual(expected, arr)\n\n    def test_empty_array(self):\n        \"\"\"Test case 4: Empty array.\"\"\"\n        arr = []\n        expected = []\n        insertion_sort(arr)\n        self.assertEqual(expected, arr)\n\n    def test_single_element_array(self):\n        \"\"\"Test case 5: Single element array.\"\"\"\n        arr = [3.3]\n        expected = [3.3]\n        insertion_sort(arr)\n        self.assertEqual(expected, arr)\n\n    def test_array_with_duplicates(self):\n        \"\"\"Test case 6: Array with duplicate values.\"\"\"\n        arr = [2.2, 3.3, 2.2, 1.1, 3.3]\n        expected = [1.1, 2.2, 2.2, 3.3, 3.3]\n        insertion_sort(arr)\n        self.assertEqual(expected, arr)\n\n    def test_large_numbers(self):\n        \"\"\"Test case 7: Large numbers.\"\"\"\n        arr = [1e10, 1e9, 1e11, 1e8]\n        expected = [1e8, 1e9, 1e10, 1e11]\n        insertion_sort(arr)\n        self.assertEqual(expected, arr)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef insertion_sort(arr:List):\n    \"\"\"\n    Sorts a list of floats in ascending order using the insertion sort algorithm.\n\n    Args:\n        arr (List): The list of floats to be sorted.\n\n    Returns:\n\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "/**\n * Sorts an array of doubles in ascending order using the insertion sort algorithm.\n *\n * The insertion sort algorithm works by dividing the array into a sorted and an\n * unsorted portion. It iterates through the unsorted portion, taking one element\n * (the key) at a time and inserting it into its correct position in the sorted portion.\n *\n * @param arr the array of doubles to be sorted\n */\npublic static void insertionSort(double[] arr) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    // Test case 1: Basic unsorted array\n    @Test\n    public void testBasicUnsortedArray() {\n        double[] arr = {12.4, 11.2, 13.5, 5.6, 6.7};\n        double[] expected = {5.6, 6.7, 11.2, 12.4, 13.5};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 2: Already sorted array\n    @Test\n    public void testAlreadySortedArray() {\n        double[] arr = {1.1, 2.2, 3.3, 4.4, 5.5};\n        double[] expected = {1.1, 2.2, 3.3, 4.4, 5.5};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 3: Reverse sorted array\n    @Test\n    public void testReverseSortedArray() {\n        double[] arr = {5.5, 4.4, 3.3, 2.2, 1.1};\n        double[] expected = {1.1, 2.2, 3.3, 4.4, 5.5};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 4: Empty array\n    @Test\n    public void testEmptyArray() {\n        double[] arr = {};\n        double[] expected = {};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 5: Single element array\n    @Test\n    public void testSingleElementArray() {\n        double[] arr = {3.3};\n        double[] expected = {3.3};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 6: Array with duplicate values\n    @Test\n    public void testArrayWithDuplicates() {\n        double[] arr = {2.2, 3.3, 2.2, 1.1, 3.3};\n        double[] expected = {1.1, 2.2, 2.2, 3.3, 3.3};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 7: Large numbers\n    @Test\n    public void testLargeNumbers() {\n        double[] arr = {1e10, 1e9, 1e11, 1e8};\n        double[] expected = {1e8, 1e9, 1e10, 1e11};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Sorts an array of doubles in ascending order using the insertion sort algorithm.\n *\n * The insertion sort algorithm works by dividing the array into a sorted and an\n * unsorted portion. It iterates through the unsorted portion, taking one element\n * (the key) at a time and inserting it into its correct position in the sorted portion.\n *\n * @param arr the array of doubles to be sorted\n */\npublic static void insertionSort(double[] arr) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 631, "code_type": "method", "original_language": "java", "file_path": "fun_with_csv\\55a95f94460e59513851a3458fee67016593e541\\misc\\SimpleCSVNioDemo.java\n", "question_type": "Data processing and transformation", "summary": "Format a list of strings into a single-line string in CSV (comma-separated values) format and write it to a file\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef write_csv_to_file(strings: List[str], file_path: str):\n    \"\"\"\n    Formats a list of strings into a single-line CSV string and writes it to a specified file.\n\n    Args:\n        strings (List[str]): List of strings to be formatted into CSV.\n        file_path (str): The file path where the CSV string should be written.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import os\nimport unittest\n\n\nclass TestAnswer(unittest.TestCase):\n    def setUp(self):\n        self.test_file_path = \"test_output.csv\"  # Path for test output file\n\n    def tearDown(self):\n        # Delete the test file after each test\n        if os.path.exists(self.test_file_path):\n            os.remove(self.test_file_path)\n\n    def read_file(self, file_path):\n        \"\"\"Helper method to read file content as a string.\"\"\"\n        try:\n            with open(file_path, 'r') as file:\n                return file.read()\n        except IOError as e:\n            self.fail(f\"Failed to read file: {e}\")\n\n    def test_write_csv_to_file_with_multiple_strings(self):\n        data = [\"Apple\", \"Banana\", \"Cherry\"]\n        write_csv_to_file(data, self.test_file_path)\n        # Assert the content of the file\n        content = self.read_file(self.test_file_path)\n        self.assertEqual(\"Apple,Banana,Cherry\", content)\n\n    def test_write_csv_to_file_with_single_string(self):\n        data = [\"Apple\"]\n        write_csv_to_file(data, self.test_file_path)\n        # Assert the content of the file\n        content = self.read_file(self.test_file_path)\n        self.assertEqual(\"Apple\", content)\n\n    def test_write_csv_to_file_with_empty_list(self):\n        data = []\n        write_csv_to_file(data, self.test_file_path)\n        # Assert the content of the file is empty\n        content = self.read_file(self.test_file_path)\n        self.assertEqual(\"\", content)\n\n    def test_write_csv_to_file_with_special_characters(self):\n        data = [\"Apple\", \"Banana, Cherry\", \"Date\"]\n        write_csv_to_file(data, self.test_file_path)\n        # Assert the content of the file\n        content = self.read_file(self.test_file_path)\n        self.assertEqual(\"Apple,Banana, Cherry,Date\", content)\n\n    def test_write_csv_to_file_with_spaces(self):\n        data = [\"Apple \", \" Banana\", \" Cherry \"]\n        write_csv_to_file(data, self.test_file_path)\n        # Assert the content of the file with spaces\n        content = self.read_file(self.test_file_path)\n        self.assertEqual(\"Apple , Banana, Cherry \", content)\n\n    def test_write_csv_to_file_with_file_overwrite(self):\n        # First write to the file\n        first_data = [\"Apple\", \"Banana\"]\n        write_csv_to_file(first_data, self.test_file_path)\n\n        # Now overwrite with new data\n        second_data = [\"Cherry\", \"Date\"]\n        write_csv_to_file(second_data, self.test_file_path)\n\n        # Assert that the file now contains the new data\n        content = self.read_file(self.test_file_path)\n        self.assertEqual(\"Cherry,Date\", content)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef write_csv_to_file(strings: List[str], file_path: str):\n    \"\"\"\n    Formats a list of strings into a single-line CSV string and writes it to a specified file.\n\n    Args:\n        strings (List[str]): List of strings to be formatted into CSV.\n        file_path (str): The file path where the CSV string should be written.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "/**\n * Formats a list of strings into a single-line CSV string and writes it to a specified file.\n *\n * @param strings List of strings to be formatted into CSV.\n * @param filePath The file path where the CSV string should be written.\n */\npublic void writeCsvToFile(List<String> strings, String filePath) {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.*;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Tester {\n    private Answer answer;\n    private final String testFilePath = \"test_output.csv\"; // Path for test output file\n\n    @BeforeEach\n    public void setUp() {\n        answer = new Answer(); // Create an instance of the Answer class\n    }\n\n    @AfterEach\n    public void tearDown() throws IOException {\n        // Delete the test file after each test\n        Path path = Paths.get(testFilePath);\n        if (Files.exists(path)) {\n            Files.delete(path);\n        }\n    }\n\n    @Test\n    public void testWriteCsvToFile_WithMultipleStrings() {\n        List<String> data = List.of(\"Apple\", \"Banana\", \"Cherry\");\n        answer.writeCsvToFile(data, testFilePath);\n\n        // Assert the content of the file\n        String content = readFile(testFilePath);\n        assertEquals(\"Apple,Banana,Cherry\", content);\n    }\n\n    @Test\n    public void testWriteCsvToFile_WithSingleString() {\n        List<String> data = List.of(\"Apple\");\n        answer.writeCsvToFile(data, testFilePath);\n\n        // Assert the content of the file\n        String content = readFile(testFilePath);\n        assertEquals(\"Apple\", content);\n    }\n\n    @Test\n    public void testWriteCsvToFile_WithEmptyList() {\n        List<String> data = List.of();\n        answer.writeCsvToFile(data, testFilePath);\n\n        // Assert the content of the file is empty\n        String content = readFile(testFilePath);\n        assertEquals(\"\", content);\n    }\n\n\n    @Test\n    public void testWriteCsvToFile_WithSpecialCharacters() {\n        List<String> data = List.of(\"Apple\", \"Banana, Cherry\", \"Date\");\n        answer.writeCsvToFile(data, testFilePath);\n\n        // Assert the content of the file\n        String content = readFile(testFilePath);\n        assertEquals(\"Apple,Banana, Cherry,Date\", content);\n    }\n\n    @Test\n    public void testWriteCsvToFile_WithSpaces() {\n        List<String> data = List.of(\"Apple \", \" Banana\", \" Cherry \");\n        answer.writeCsvToFile(data, testFilePath);\n\n        // Assert the content of the file with spaces\n        String content = readFile(testFilePath);\n        assertEquals(\"Apple , Banana, Cherry \", content);\n    }\n\n    @Test\n    public void testWriteCsvToFile_WithFileOverwrite() {\n        // First write to the file\n        List<String> firstData = List.of(\"Apple\", \"Banana\");\n        answer.writeCsvToFile(firstData, testFilePath);\n\n        // Now overwrite with new data\n        List<String> secondData = List.of(\"Cherry\", \"Date\");\n        answer.writeCsvToFile(secondData, testFilePath);\n\n        // Assert that the file now contains the new data\n        String content = readFile(testFilePath);\n        assertEquals(\"Cherry,Date\", content);\n    }\n\n    // Helper method to read file content as a String\n    private String readFile(String filePath) {\n        try {\n            return Files.readString(Path.of(filePath));\n        } catch (IOException e) {\n            fail(\"Failed to read file: \" + e.getMessage());\n            return \"\";\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Formats a list of strings into a single-line CSV string and writes it to a specified file.\n *\n * @param strings List of strings to be formatted into CSV.\n * @param filePath The file path where the CSV string should be written.\n */\npublic void writeCsvToFile(List<String> strings, String filePath) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 632, "code_type": "method", "original_language": "java", "file_path": "url2024lfa1\\99e03865c0ddc20b3013114077923975889f6da9\\02022024_ExpresionAritmeticaAArbol\\src\\ShuntingYard.java\n", "question_type": "Data processing and transformation", "summary": "Parses a mathematical expression string, identifies its operators and operands, and stores them in a list\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef parse_expression(expression: str) -> List[str]:\n    \"\"\"\n    Parses a mathematical expression string into a list of tokens.\n    This function identifies both operands (numbers) and operators (+, -, *, /, etc.)\n    in the provided expression and returns them in a list format.\n\n    Args:\n        expression (str): The mathematical expression to be parsed.\n\n    Returns:\n        list[str]: A list containing the tokens identified in the expression.\n                    The list will include both operands and operators in the order they appear.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_simple_addition(self):\n        expression = \"2 + 2\"\n        result = parse_expression(expression)\n        self.assertEqual(result, [\"2\", \"+\", \"2\"])\n\n    def test_complex_expression(self):\n        expression = \"3 + 5 * (2 - 8)\"\n        result = parse_expression(expression)\n        self.assertEqual(result, [\"3\", \"+\", \"5\", \"*\", \"(\", \"2\", \"-\", \"8\", \")\"])\n\n    def test_negative_numbers(self):\n        expression = \"-1 + 4 - 5\"\n        result = parse_expression(expression)\n        self.assertEqual(result, [\"-\", \"1\", \"+\", \"4\", \"-\", \"5\"])\n\n    def test_decimals(self):\n        expression = \"3.5 + 2.1\"\n        result = parse_expression(expression)\n        self.assertEqual(result, [\"3.5\", \"+\", \"2.1\"])\n\n    def test_operators_only(self):\n        expression = \"+ - * /\"\n        result = parse_expression(expression)\n        self.assertEqual(result, [\"+\", \"-\", \"*\", \"/\"])\n\n    def test_empty_expression(self):\n        expression = \"\"\n        result = parse_expression(expression)\n        self.assertTrue(len(result) == 0)\n\n    def test_single_number(self):\n        expression = \"42\"\n        result = parse_expression(expression)\n        self.assertEqual(result, [\"42\"])", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef parse_expression(expression: str) -> List[str]:\n    \"\"\"\n    Parses a mathematical expression string into a list of tokens.\n    This function identifies both operands (numbers) and operators (+, -, *, /, etc.)\n    in the provided expression and returns them in a list format.\n\n    Args:\n        expression (str): The mathematical expression to be parsed.\n\n    Returns:\n        list[str]: A list containing the tokens identified in the expression.\n                    The list will include both operands and operators in the order they appear.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "/**\n * Parses a mathematical expression string into a list of tokens.\n * This method identifies both operands (numbers) and operators (+, -, *, /, etc.) \n * in the provided expression, and returns them in a list format.\n *\n * @param expression The mathematical expression to be parsed, represented as a String.\n *                   The expression can contain integers, decimal numbers, \n *                   and standard arithmetic operators, as well as parentheses.\n * @return A List<String> containing the tokens identified in the expression. \n *         The list will include both operands and operators in the order they appear.\n */\npublic List<String> parseExpression(String expression) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.util.List;\n\npublic class Tester {\n\n    private final Answer answer = new Answer();\n\n    @Test\n    public void testSimpleAddition() {\n        String expression = \"2 + 2\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"2\", \"+\", \"2\"), result);\n    }\n\n    @Test\n    public void testComplexExpression() {\n        String expression = \"3 + 5 * (2 - 8)\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"3\", \"+\", \"5\", \"*\", \"(\", \"2\", \"-\", \"8\", \")\"), result);\n    }\n\n    @Test\n    public void testNegativeNumbers() {\n        String expression = \"-1 + 4 - 5\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"-\", \"1\", \"+\", \"4\", \"-\", \"5\"), result);\n    }\n\n    @Test\n    public void testDecimals() {\n        String expression = \"3.5 + 2.1\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"3.5\", \"+\", \"2.1\"), result);\n    }\n\n    @Test\n    public void testOperatorsOnly() {\n        String expression = \"+ - * /\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"+\", \"-\", \"*\", \"/\"), result);\n    }\n\n    @Test\n    public void testEmptyExpression() {\n        String expression = \"\";\n        List<String> result = answer.parseExpression(expression);\n        assertTrue(result.isEmpty());\n    }\n\n    @Test\n    public void testSingleNumber() {\n        String expression = \"42\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"42\"), result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Parses a mathematical expression string into a list of tokens.\n * This method identifies both operands (numbers) and operators (+, -, *, /, etc.) \n * in the provided expression, and returns them in a list format.\n *\n * @param expression The mathematical expression to be parsed, represented as a String.\n *                   The expression can contain integers, decimal numbers, \n *                   and standard arithmetic operators, as well as parentheses.\n * @return A List<String> containing the tokens identified in the expression. \n *         The list will include both operands and operators in the order they appear.\n */\npublic List<String> parseExpression(String expression) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 633, "code_type": "method", "original_language": "java", "file_path": "fun_with_csv\\55a95f94460e59513851a3458fee67016593e541\\misc\\SimpleCSVNioDemo.java\n", "question_type": "Data processing and transformation", "summary": "Read the CSV file and parse each line into a list of strings\n", "language_version_list": {"python": {"code_signature": "import csv\nfrom typing import List\n\n\ndef read_csv(file_path: str) -> List[List[str]]:\n    \"\"\"\n    Reads a CSV file and parses each line into a list of strings.\n\n    Args:\n        file_path (str): The path to the CSV file.\n\n    Returns:\n        List[List[str]]: A list of string lists, where each list represents a line from the CSV.\n    \"\"\"\n", "test_code": "import os\nimport unittest\n\n\nclass TestAnswer(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary CSV file for testing\n        self.test_file_path = 'test.csv'\n        sample_csv_content = \"Name,Age,Location\\n\" + \\\n                             \"Alice,30,New York\\n\" + \\\n                             \"Bob,25,Los Angeles\\n\" + \\\n                             \"Charlie,35,Chicago\\n\"\n        with open(self.test_file_path, 'w') as file:\n            file.write(sample_csv_content)\n\n    def test_read_valid_csv(self):\n        result = read_csv(self.test_file_path)\n        self.assertEqual(len(result), 4)  # 4 lines including the header\n        self.assertEqual(result[0], [\"Name\", \"Age\", \"Location\"])  # Check header\n        self.assertEqual(result[1], [\"Alice\", \"30\", \"New York\"])\n        self.assertEqual(result[2], [\"Bob\", \"25\", \"Los Angeles\"])\n        self.assertEqual(result[3], [\"Charlie\", \"35\", \"Chicago\"])\n\n    def test_read_empty_csv(self):\n        # Create an empty CSV file\n        with open(self.test_file_path, 'w') as file:\n            file.write(\"\")\n        result = read_csv(self.test_file_path)\n        self.assertTrue(len(result) == 0)  # Expecting an empty list\n\n    def test_read_csv_with_quotes(self):\n        # Write CSV content with quoted fields\n        content_with_quotes = '\"Name\",\"Age\",\"Location\"\\n' + \\\n                              '\"Alice\",\"30\",\"New York\"\\n' + \\\n                              '\"Bob\",\"25\",\"Los Angeles\"\\n'\n        with open(self.test_file_path, 'w') as file:\n            file.write(content_with_quotes)\n        result = read_csv(self.test_file_path)\n        self.assertEqual(len(result), 3)  # 3 lines including the header\n        self.assertEqual(result[0], ['Name', 'Age', 'Location'])\n\n    def test_read_invalid_csv_file(self):\n        with self.assertRaises(FileNotFoundError):\n            read_csv('non_existent_file.csv')\n\n    def test_read_csv_with_different_delimiters(self):\n        # Write CSV content with semicolons instead of commas\n        content_with_semicolons = \"Name;Age;Location\\n\" + \\\n                                  \"Alice;30;New York\\n\" + \\\n                                  \"Bob;25;Los Angeles\\n\"\n        with open(self.test_file_path, 'w') as file:\n            file.write(content_with_semicolons)\n        result = read_csv(self.test_file_path)\n        self.assertEqual(len(result), 3)  # Expecting 3 lines\n        self.assertEqual(result[0], [\"Name;Age;Location\"])\n\n    def tearDown(self):\n        # Clean up: remove test file after tests\n        try:\n            os.remove(self.test_file_path)\n        except FileNotFoundError:\n            pass\n", "prompt": "please write a python function , the function signature as below import csv\nfrom typing import List\n\n\ndef read_csv(file_path: str) -> List[List[str]]:\n    \"\"\"\n    Reads a CSV file and parses each line into a list of strings.\n\n    Args:\n        file_path (str): The path to the CSV file.\n\n    Returns:\n        List[List[str]]: A list of string lists, where each list represents a line from the CSV.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads a CSV file and parses each line into a list of strings.\n *\n * @param filePath The path to the CSV file.\n * @return A list of string arrays, where each array represents a line from the CSV.\n * @throws IOException If there is an error reading the file.\n */\npublic List<List<String>> readCsv(String filePath) throws IOException {}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.AfterEach;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\npublic class Tester {\n\n    private final Answer answer = new Answer();\n    private final String testFilePath = \"test.csv\";\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        // Create a temporary CSV file for testing\n        // Writing sample CSV content to the file\n        String sampleCsvContent = \"Name,Age,Location\\n\" +\n                \"Alice,30,New York\\n\" +\n                \"Bob,25,Los Angeles\\n\" +\n                \"Charlie,35,Chicago\\n\";\n        Files.write(Paths.get(testFilePath), sampleCsvContent.getBytes(), StandardOpenOption.CREATE);\n    }\n\n    @Test\n    public void testReadValidCsv() throws IOException {\n        List<List<String>> result = answer.readCsv(testFilePath);\n        assertEquals(4, result.size()); // 4 lines including the header\n        assertEquals(List.of(\"Name\", \"Age\", \"Location\"), result.get(0)); // Check header\n        assertEquals(List.of(\"Alice\", \"30\", \"New York\"), result.get(1));\n        assertEquals(List.of(\"Bob\", \"25\", \"Los Angeles\"), result.get(2));\n        assertEquals(List.of(\"Charlie\", \"35\", \"Chicago\"), result.get(3));\n    }\n\n    @Test\n    public void testReadEmptyCsv() throws IOException {\n        // Create an empty CSV file\n        Files.write(Paths.get(testFilePath), \"\".getBytes(), StandardOpenOption.TRUNCATE_EXISTING);\n        List<List<String>> result = answer.readCsv(testFilePath);\n        assertTrue(result.isEmpty()); // Expecting an empty list\n    }\n\n\n    @Test\n    public void testReadCsvWithQuotes() throws IOException {\n        // Write CSV content with quoted fields\n        String contentWithQuotes = \"\\\"Name\\\",\\\"Age\\\",\\\"Location\\\"\\n\" +\n                \"\\\"Alice\\\",\\\"30\\\",\\\"New York\\\"\\n\" +\n                \"\\\"Bob\\\",\\\"25\\\",\\\"Los Angeles\\\"\\n\";\n        Files.write(Paths.get(testFilePath), contentWithQuotes.getBytes(), StandardOpenOption.TRUNCATE_EXISTING);\n        List<List<String>> result = answer.readCsv(testFilePath);\n        assertEquals(3, result.size()); // 3 lines including the header\n        assertEquals(List.of(\"\\\"Name\\\"\", \"\\\"Age\\\"\", \"\\\"Location\\\"\"), result.get(0));\n    }\n\n    @Test\n    public void testReadInvalidCsvFile() {\n        // Attempt to read a non-existent file and assert that a FileNotFoundException is thrown\n        assertThrows(Exception.class, () -> {\n            answer.readCsv(\"non_existent_file.csv\");\n        });\n    }\n\n    @Test\n    public void testReadCsvWithDifferentDelimiters() throws IOException {\n        // Write CSV content with semicolons instead of commas\n        String contentWithSemicolons = \"Name;Age;Location\\n\" +\n                \"Alice;30;New York\\n\" +\n                \"Bob;25;Los Angeles\\n\";\n        Files.write(Paths.get(testFilePath), contentWithSemicolons.getBytes(), StandardOpenOption.TRUNCATE_EXISTING);\n        // Modify the readCsv function to handle semicolons if necessary.\n        List<List<String>> result = answer.readCsv(testFilePath);\n        assertEquals(3, result.size()); // Expecting 3 lines\n        assertEquals(List.of(\"Name;Age;Location\"), result.get(0));\n    }\n\n    // Clean up after tests (Optional)\n    @AfterEach\n    public void tearDown() throws IOException {\n        Files.deleteIfExists(Paths.get(testFilePath)); // Remove test file after tests\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Reads a CSV file and parses each line into a list of strings.\n *\n * @param filePath The path to the CSV file.\n * @return A list of string arrays, where each array represents a line from the CSV.\n * @throws IOException If there is an error reading the file.\n */\npublic List<List<String>> readCsv(String filePath) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 183, "code_type": "method", "original_language": "c&cpp", "file_path": "cpp-raytracer\\cd33860cc5526fe95d6d60bed9a61340550acbb6\\Code\\cylinder.h", "question_type": "Algorithm and data structure", "summary": "Check whether the ray intersects the circle\n", "language_version_list": {"python": {"code_signature": "class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Ray:\n    def __init__(self, origin, direction):\n        self.origin = origin  # Starting point of the ray\n        self.direction = direction  # Direction of the ray (should be normalized)\n\n\nclass Circle:\n    def __init__(self, center, radius):\n        self.center = center  # Center of the circle\n        self.radius = radius  # Radius of the circle\n\n\ndef intersects(ray: Ray, circle: Circle) -> bool:\n    \"\"\"\n    Determines whether a ray intersects with a circle.\n\n    Args:\n        ray (Ray): The ray to be tested for intersection. It is assumed to contain properties such as an origin point (x, y) and a direction vector (dx, dy).\n        circle (Circle): The circle to check for intersection. It is assumed to contain properties such as a center point (h, k) and a radius r.\n\n    Returns:\n        bool: True if the ray intersects the circle; False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Ray:\n    def __init__(self, origin, direction):\n        self.origin = origin  # Starting point of the ray\n        self.direction = direction  # Direction of the ray (should be normalized)\n\n\nclass Circle:\n    def __init__(self, center, radius):\n        self.center = center  # Center of the circle\n        self.radius = radius  # Radius of the circle\n\n\nclass Tester(unittest.TestCase):\n    def test_ray_circle_intersection(self):\n        # Test Case 1: The ray intersects the circle at two points\n        ray = Ray(Point(0, 0), Point(1, 1))  # Origin at (0, 0), direction (1, 1)\n        circle = Circle(Point(3, 3), 2)  # Circle center at (3, 3), radius 2\n        self.assertTrue(intersects(ray, circle))\n\n        # Test Case 2: The ray is tangent to the circle (one intersection point)\n        ray = Ray(Point(2, 0), Point(0, 1))  # Origin at (2, 0), direction (0, 1)\n        circle = Circle(Point(2, 2), 1)  # Circle center at (2, 2), radius 1\n        self.assertTrue(intersects(ray, circle))\n\n        # Test Case 3: The ray starts inside the circle (one intersection point)\n        ray = Ray(Point(2, 2), Point(1, 0))  # Origin at (2, 2), direction (1, 0)\n        circle = Circle(Point(3, 2), 1)  # Circle center at (3, 2), radius 1\n        self.assertTrue(intersects(ray, circle))\n\n        # Test Case 4: The ray originates outside and goes away from the circle (no intersection)\n        ray = Ray(Point(5, 5), Point(1, 0))  # Origin at (5, 5), direction (1, 0)\n        circle = Circle(Point(3, 3), 1)  # Circle center at (3, 3), radius 1\n        self.assertFalse(intersects(ray, circle))\n\n        # Test Case 5: The ray is parallel to the line connecting the center of the circle and is outside (no intersection)\n        ray = Ray(Point(0, 3), Point(1, 0))  # Origin at (0, 3), direction (1, 0)\n        circle = Circle(Point(3, 3), 1)  # Circle center at (3, 3), radius 1\n        self.assertFalse(intersects(ray, circle))\n\n        # Test Case 6: The ray intersects the circle at one point when passing through the center\n        ray = Ray(Point(3, 0), Point(0, 1))  # Origin at (3, 0), direction (0, 1)\n        circle = Circle(Point(3, 3), 3)  # Circle center at (3, 3), radius 3\n        self.assertTrue(intersects(ray, circle))\n", "prompt": "please write a python function , the function signature as below class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Ray:\n    def __init__(self, origin, direction):\n        self.origin = origin  # Starting point of the ray\n        self.direction = direction  # Direction of the ray (should be normalized)\n\n\nclass Circle:\n    def __init__(self, center, radius):\n        self.center = center  # Center of the circle\n        self.radius = radius  # Radius of the circle\n\n\ndef intersects(ray: Ray, circle: Circle) -> bool:\n    \"\"\"\n    Determines whether a ray intersects with a circle.\n\n    Args:\n        ray (Ray): The ray to be tested for intersection. It is assumed to contain properties such as an origin point (x, y) and a direction vector (dx, dy).\n        circle (Circle): The circle to check for intersection. It is assumed to contain properties such as a center point (h, k) and a radius r.\n\n    Returns:\n        bool: True if the ray intersects the circle; False otherwise.\n    \"\"\"\n", "addition_info": "class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Ray:\n    def __init__(self, origin, direction):\n        self.origin = origin  # Starting point of the ray\n        self.direction = direction  # Direction of the ray (should be normalized)\n\n\nclass Circle:\n    def __init__(self, center, radius):\n        self.center = center  # Center of the circle\n        self.radius = radius  # Radius of the circle"}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <cmath>\n\nstruct Point {\n    float x, y;\n};\n\nstruct Ray {\n    Point origin;   // Starting point of the ray\n    Point direction; // Direction of the ray (should be normalized)\n};\n\nstruct Circle {\n    Point center; // Center of the circle\n    float radius; // Radius of the circle\n};\n\n/**\n * @brief Determines whether a ray intersects with a circle.\n *\n * This function checks if a given ray intersects with a specified circle\n * in a 2D space. It performs mathematical calculations to determine if\n * the ray, defined by its origin and direction, crosses the area of the\n * circle defined by its center and radius.\n *\n * @param ray The ray to be tested for intersection. It is assumed to\n * contain properties such as an origin point and a direction vector.\n * @param circle The circle to check for intersection. It is assumed to\n * contain properties such as a center point and a radius.\n *\n * @return true if the ray intersects the circle; false otherwise.\n */\nbool intersects(const Ray& ray, const Circle& circle) {}", "test_code": "TEST_CASE(\"Ray-Circle Intersection Tests\") {\n    // Test Case 1: The ray intersects the circle at two points\n    {\n        Ray ray = {{0, 0}, {1, 1}}; // Origin at (0, 0), direction (1, 1)\n        Circle circle = {{3, 3}, 2}; // Circle center at (3, 3), radius 2\n        REQUIRE(intersects(ray, circle) == true);\n    }\n\n    // Test Case 2: The ray is tangent to the circle (one intersection point)\n    {\n        Ray ray = {{2, 0}, {0, 1}}; // Origin at (2, 0), direction (0, 1)\n        Circle circle = {{2, 2}, 1}; // Circle center at (2, 2), radius 1\n        REQUIRE(intersects(ray, circle) == true);\n    }\n\n    // Test Case 3: The ray starts inside the circle (one intersection point)\n    {\n        Ray ray = {{2, 2}, {1, 0}}; // Origin at (2, 2), direction (1, 0)\n        Circle circle = {{3, 2}, 1}; // Circle center at (3, 2), radius 1\n        REQUIRE(intersects(ray, circle) == true);\n    }\n\n    // Test Case 4: The ray originates outside and goes away from the circle (no intersection)\n    {\n        Ray ray = {{5, 5}, {1, 0}}; // Origin at (5, 5), direction (1, 0)\n        Circle circle = {{3, 3}, 1}; // Circle center at (3, 3), radius 1\n        REQUIRE(intersects(ray, circle) == false);\n    }\n\n    // Test Case 5: The ray is parallel to the line connecting the center of the circle and is outside (no intersection)\n    {\n        Ray ray = {{0, 3}, {1, 0}}; // Origin at (0, 3), direction (1, 0)\n        Circle circle = {{3, 3}, 1}; // Circle center at (3, 3), radius 1\n        REQUIRE(intersects(ray, circle) == true);\n    }\n\n    // Test Case 6: The ray intersects the circle at one point when passing through the center\n    {\n        Ray ray = {{3, 0}, {0, 1}}; // Origin at (3, 0), direction (0, 1)\n        Circle circle = {{3, 3}, 3}; // Circle center at (3, 3), radius 3\n        REQUIRE(intersects(ray, circle) == true);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <cmath>\n\nstruct Point {\n    float x, y;\n};\n\nstruct Ray {\n    Point origin;   // Starting point of the ray\n    Point direction; // Direction of the ray (should be normalized)\n};\n\nstruct Circle {\n    Point center; // Center of the circle\n    float radius; // Radius of the circle\n};\n\n/**\n * @brief Determines whether a ray intersects with a circle.\n *\n * This function checks if a given ray intersects with a specified circle\n * in a 2D space. It performs mathematical calculations to determine if\n * the ray, defined by its origin and direction, crosses the area of the\n * circle defined by its center and radius.\n *\n * @param ray The ray to be tested for intersection. It is assumed to\n * contain properties such as an origin point and a direction vector.\n * @param circle The circle to check for intersection. It is assumed to\n * contain properties such as a center point and a radius.\n *\n * @return true if the ray intersects the circle; false otherwise.\n */\nbool intersects(const Ray& ray, const Circle& circle) {}", "addition_info": "#include <iostream>\n#include <cmath>\n\nstruct Point {\n    float x, y;\n};\n\nstruct Ray {\n    Point origin;   // Starting point of the ray\n    Point direction; // Direction of the ray (should be normalized)\n};\n\nstruct Circle {\n    Point center; // Center of the circle\n    float radius; // Radius of the circle\n};"}, "java": {"code_signature": "/**\n * Determines whether a ray intersects with a circle.\n *\n * This method checks if a given ray intersects with a specified circle\n * in a 2D space. It performs mathematical calculations to determine if\n * the ray, defined by its origin and direction, crosses the area of the\n * circle defined by its center and radius.\n *\n * @param ray The ray to be tested for intersection. It is assumed to\n * contain properties such as an origin point and a direction vector.\n * @param circle The circle to check for intersection. It is assumed to\n * contain properties such as a center point and a radius.\n *\n * @return true if the ray intersects the circle; false otherwise.\n */\n/**\n * Represents a point in 2D space.\n */\nstatic class Point {\n    float x, y;\n}\n\n/**\n * Represents a ray in 2D space.\n * The ray is defined by its origin and direction (which should be normalized).\n */\nstatic class Ray {\n\n}\n\n/**\n * Represents a circle in 2D space.\n * The circle is defined by its center and radius.\n */\nstatic class Circle {\n    Point center; // Center of the circle\n    float radius; // Radius of the circle\n\n}\npublic static boolean intersects(Ray ray, Circle circle) {\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testcase1() {\n        // Test Case 1: The ray intersects the circle at two points\n        Ray ray1 = new Ray(new Point(0, 0), new Point(1, 1)); // Origin at (0, 0), direction (1, 1)\n        Circle circle1 = new Circle(new Point(3, 3), 2); // Circle center at (3, 3), radius 2\n        assertTrue(intersects(ray1, circle1));\n\n    }\n\n    @Test\n    public void testcase2(){\n        // Test Case 2: The ray is tangent to the circle (one intersection point)\n        Ray ray2 = new Ray(new Point(2, 0), new Point(0, 1)); // Origin at (2, 0), direction (0, 1)\n        Circle circle2 = new Circle(new Point(2, 2), 1); // Circle center at (2, 2), radius 1\n        assertTrue(intersects(ray2, circle2));\n    }\n    @Test\n    public void testcase3(){\n        // Test Case 3: The ray starts inside the circle (one intersection point)\n        Ray ray3 = new Ray(new Point(2, 2), new Point(1, 0)); // Origin at (2, 2), direction (1, 0)\n        Circle circle3 = new Circle(new Point(3, 2), 1); // Circle center at (3, 2), radius 1\n        assertTrue(intersects(ray3, circle3));\n\n    }\n    @Test\n    public void testcase4(){\n        // Test Case 4: The ray originates outside and goes away from the circle (no intersection)\n        Ray ray4 = new Ray(new Point(5, 5), new Point(1, 0)); // Origin at (5, 5), direction (1, 0)\n        Circle circle4 = new Circle(new Point(3, 3), 1); // Circle center at (3, 3), radius 1\n        assertFalse(intersects(ray4, circle4));\n    }\n    @Test\n    public void testcase5(){\n        // Test Case 5: The ray is parallel to the line connecting the center of the circle and is outside (no intersection)\n        Ray ray5 = new Ray(new Point(0, 3), new Point(1, 0)); // Origin at (0, 3), direction (1, 0)\n        Circle circle5 = new Circle(new Point(3, 3), 1); // Circle center at (3, 3), radius 1\n        assertTrue(intersects(ray5, circle5));\n\n    }\n    @Test\n    public void testcase6(){\n\n        // Test Case 6: The ray intersects the circle at one point when passing through the center\n        Ray ray6 = new Ray(new Point(3, 0), new Point(0, 1)); // Origin at (3, 0), direction (0, 1)\n        Circle circle6 = new Circle(new Point(3, 3), 3); // Circle center at (3, 3), radius 3\n        assertTrue(intersects(ray6, circle6));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Determines whether a ray intersects with a circle.\n *\n * This method checks if a given ray intersects with a specified circle\n * in a 2D space. It performs mathematical calculations to determine if\n * the ray, defined by its origin and direction, crosses the area of the\n * circle defined by its center and radius.\n *\n * @param ray The ray to be tested for intersection. It is assumed to\n * contain properties such as an origin point and a direction vector.\n * @param circle The circle to check for intersection. It is assumed to\n * contain properties such as a center point and a radius.\n *\n * @return true if the ray intersects the circle; false otherwise.\n */\n/**\n * Represents a point in 2D space.\n */\nstatic class Point {\n    float x, y;\n}\n\n/**\n * Represents a ray in 2D space.\n * The ray is defined by its origin and direction (which should be normalized).\n */\nstatic class Ray {\n\n}\n\n/**\n * Represents a circle in 2D space.\n * The circle is defined by its center and radius.\n */\nstatic class Circle {\n    Point center; // Center of the circle\n    float radius; // Radius of the circle\n\n}\npublic static boolean intersects(Ray ray, Circle circle) {\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 184, "code_type": "class", "original_language": "c&cpp", "file_path": "PokeGame\\e4b26a4a58b6d97599583435b49d4775f50b392b\\src\\data_structures\\priority_queue.c", "question_type": "Algorithm and data structure", "summary": "Implement a priority queue and use the binary heap, or the maximum heap, as the underlying data structure\n", "language_version_list": {"python": {"code_signature": "class PriorityQueue:\n    def __init__(self):\n        self.heap = []  # This will store the elements of the heap\n\n    # Helper function to get the index of the parent\n    def parent(self, index):\n        pass\n\n    # Helper function to get the index of the left child\n    def left_child(self, index):\n        pass\n\n    # Helper function to get the index of the right child\n    def right_child(self, index):\n        pass\n\n    # Helper function to swap two elements in the heap\n    def swap(self, a, b):\n        pass\n\n    # Heapify up to maintain the max-heap property after insertion\n    def heapify_up(self, index):\n        pass\n\n    # Heapify down to maintain the max-heap property after deletion\n    def heapify_down(self, index):\n        pass\n\n    # Insert an element into the priority queue\n    def push(self, value):\n        pass\n\n    # Remove the maximum element from the priority queue\n    def pop(self):\n        pass\n\n    # Get the maximum element without removing it\n    def top(self):\n        pass\n\n    # Check if the priority queue is empty\n    def is_empty(self):\n        pass\n\n    # Get the size of the priority queue\n    def size(self):\n        pass", "test_code": "import unittest\n\nclass Tester(unittest.TestCase):\n    \n    def setUp(self):\n        \"\"\" Set up a new PriorityQueue instance for each test \"\"\"\n        self.pq = PriorityQueue()\n    \n    def test_insert_and_access_maximum_element(self):\n        \"\"\" Test case: Insert and access maximum element \"\"\"\n        self.pq.push(10)\n        self.pq.push(20)\n        self.pq.push(5)\n        self.pq.push(30)\n        self.pq.push(15)\n        self.assertEqual(self.pq.top(), 30)  # Ensure the max element is 30\n    \n    def test_remove_maximum_element(self):\n        \"\"\" Test case: Remove maximum element \"\"\"\n        self.pq.push(10)\n        self.pq.push(20)\n        self.pq.push(5)\n        self.pq.push(30)\n        self.pq.pop()  # Remove 30\n        self.assertEqual(self.pq.top(), 20)  # Now the max should be 20\n        self.pq.pop()  # Remove 20\n        self.assertEqual(self.pq.top(), 10)  # Now the max should be 10\n    \n    def test_check_empty_queue(self):\n        \"\"\" Test case: Check if the queue is empty \"\"\"\n        self.assertTrue(self.pq.isEmpty())  # Initially empty\n        self.pq.push(10)\n        self.assertFalse(self.pq.isEmpty())  # Now not empty\n        self.pq.pop()\n        self.assertTrue(self.pq.isEmpty())  # Back to empty\n    \n    def test_pop_from_empty_queue(self):\n        \"\"\" Test case: Pop from empty queue (should raise exception) \"\"\"\n        with self.assertRaises(RuntimeError):\n            self.pq.pop()  # Should raise an error\n    \n    def test_access_top_of_empty_queue(self):\n        \"\"\" Test case: Access top of empty queue (should raise exception) \"\"\"\n        with self.assertRaises(RuntimeError):\n            self.pq.top()  # Should raise an error\n    \n    def test_maintain_max_heap_property(self):\n        \"\"\" Test case: Maintain max-heap property \"\"\"\n        self.pq.push(3)\n        self.pq.push(1)\n        self.pq.push(4)\n        self.pq.push(2)\n        self.assertEqual(self.pq.top(), 4)  # Ensure max is 4\n        self.pq.pop()  # Remove 4\n        self.assertEqual(self.pq.top(), 3)  # Now max is 3\n        self.pq.push(5)  # Add 5\n        self.assertEqual(self.pq.top(), 5)  # Ensure max is now 5\n", "prompt": "please write a python class , the class signature as below class PriorityQueue:\n    def __init__(self):\n        self.heap = []  # This will store the elements of the heap\n\n    # Helper function to get the index of the parent\n    def parent(self, index):\n        pass\n\n    # Helper function to get the index of the left child\n    def left_child(self, index):\n        pass\n\n    # Helper function to get the index of the right child\n    def right_child(self, index):\n        pass\n\n    # Helper function to swap two elements in the heap\n    def swap(self, a, b):\n        pass\n\n    # Heapify up to maintain the max-heap property after insertion\n    def heapify_up(self, index):\n        pass\n\n    # Heapify down to maintain the max-heap property after deletion\n    def heapify_down(self, index):\n        pass\n\n    # Insert an element into the priority queue\n    def push(self, value):\n        pass\n\n    # Remove the maximum element from the priority queue\n    def pop(self):\n        pass\n\n    # Get the maximum element without removing it\n    def top(self):\n        pass\n\n    # Check if the priority queue is empty\n    def is_empty(self):\n        pass\n\n    # Get the size of the priority queue\n    def size(self):\n        pass", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass PriorityQueue {\nprivate:\n    std::vector<int> heap; // This will store the elements of the heap\n\n    // Helper function to get the index of the parent\n    int parent(int index) {}\n\n    // Helper function to get the index of the left child\n    int leftChild(int index) {}\n\n    // Helper function to get the index of the right child\n    int rightChild(int index) {}\n\n    // Helper function to swap two elements in the heap\n    void swap(int &a, int &b) {}\n\n    // Heapify up to maintain the max-heap property after insertion\n    void heapifyUp(int index) {}\n\n    // Heapify down to maintain the max-heap property after deletion\n    void heapifyDown(int index) {}\n\npublic:\n    // Insert an element into the priority queue\n    void push(int value) {}\n\n    // Remove the maximum element from the priority queue\n    void pop() {}\n\n    // Get the maximum element without removing it\n    int top() {}\n\n    // Check if the priority queue is empty\n    bool isEmpty() {}\n\n    // Get the size of the priority queue\n    int size() {}\n};", "test_code": "TEST_CASE(\"Priority Queue - Test Cases\") {\n    PriorityQueue pq;\n\n    SECTION(\"Insert and access maximum element\") {\n        pq.push(10);\n        pq.push(20);\n        pq.push(5);\n        pq.push(30);\n        pq.push(15);\n\n        REQUIRE(pq.top() == 30); // Ensure the max element is 30\n    }\n\n    SECTION(\"Remove maximum element\") {\n        pq.push(10);\n        pq.push(20);\n        pq.push(5);\n        pq.push(30);\n\n        pq.pop(); // Remove 30\n        REQUIRE(pq.top() == 20); // Now the max should be 20\n        pq.pop(); // Remove 20\n        REQUIRE(pq.top() == 10); // Now the max should be 10\n    }\n\n    SECTION(\"Check empty queue\") {\n        REQUIRE(pq.isEmpty() == true); // Initially empty\n        pq.push(10);\n        REQUIRE(pq.isEmpty() == false); // Now not empty\n        pq.pop();\n        REQUIRE(pq.isEmpty() == true); // Back to empty\n    }\n\n    SECTION(\"Pop from empty queue\") {\n        REQUIRE_THROWS_AS(pq.pop(), std::runtime_error); // Should throw an error\n    }\n\n    SECTION(\"Access top of empty queue\") {\n        REQUIRE_THROWS_AS(pq.top(), std::runtime_error); // Should throw an error\n    }\n\n    SECTION(\"Maintain max-heap property\") {\n        pq.push(3);\n        pq.push(1);\n        pq.push(4);\n        pq.push(2);\n\n        REQUIRE(pq.top() == 4); // Ensure max is 4\n\n        pq.pop(); // Remove 4\n        REQUIRE(pq.top() == 3); // Now max is 3\n\n        pq.push(5); // Add 5\n        REQUIRE(pq.top() == 5); // Ensure max is now 5\n    }\n}", "prompt": "please write a cpp class , the class signature as below #include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass PriorityQueue {\nprivate:\n    std::vector<int> heap; // This will store the elements of the heap\n\n    // Helper function to get the index of the parent\n    int parent(int index) {}\n\n    // Helper function to get the index of the left child\n    int leftChild(int index) {}\n\n    // Helper function to get the index of the right child\n    int rightChild(int index) {}\n\n    // Helper function to swap two elements in the heap\n    void swap(int &a, int &b) {}\n\n    // Heapify up to maintain the max-heap property after insertion\n    void heapifyUp(int index) {}\n\n    // Heapify down to maintain the max-heap property after deletion\n    void heapifyDown(int index) {}\n\npublic:\n    // Insert an element into the priority queue\n    void push(int value) {}\n\n    // Remove the maximum element from the priority queue\n    void pop() {}\n\n    // Get the maximum element without removing it\n    int top() {}\n\n    // Check if the priority queue is empty\n    bool isEmpty() {}\n\n    // Get the size of the priority queue\n    int size() {}\n};", "addition_info": ""}, "java": {"code_signature": "/**\n * A class representing a max-heap priority queue.\n */\npublic class Answer {\n    static class PriorityQueue{\nprivate List<Integer> heap; // This will store the elements of the heap\n\n    /** \n     * Constructor to initialize the priority queue.\n     */\n    public PriorityQueue() {\n        heap = new ArrayList<>();\n    }\n\n    /**\n     * Helper function to get the index of the parent.\n     * \n     * @param index The index of the child node.\n     * @return The index of the parent node.\n     */\n    private int parent(int index) {\n        return (index - 1) / 2;\n    }\n\n    /**\n     * Helper function to get the index of the left child.\n     * \n     * @param index The index of the parent node.\n     * @return The index of the left child node.\n     */\n    private int leftChild(int index) {\n        return 2 * index + 1;\n    }\n\n    /**\n     * Helper function to get the index of the right child.\n     * \n     * @param index The index of the parent node.\n     * @return The index of the right child node.\n     */\n    private int rightChild(int index) {\n        return 2 * index + 2;\n    }\n\n    /**\n     * Helper function to swap two elements in the heap.\n     * \n     * @param aIndex The index of the first element.\n     * @param bIndex The index of the second element.\n     */\n    private void swap(int aIndex, int bIndex) {\n\n    }\n\n    /**\n     * Heapify up to maintain the max-heap property after insertion.\n     * \n     * @param index The index of the newly inserted element.\n     */\n    private void heapifyUp(int index) {\n        \n    }\n\n    /**\n     * Heapify down to maintain the max-heap property after deletion.\n     * \n     * @param index The index of the element to be heapified down.\n     */\n    private void heapifyDown(int index) {\n        \n    }\n\n    /**\n     * Insert an element into the priority queue.\n     * \n     * @param value The value to be inserted.\n     */\n    public void push(int value) {\n        \n    }\n\n    /**\n     * Remove the maximum element from the priority queue.\n     * \n     * @throws RuntimeException if the priority queue is empty.\n     */\n    public void pop() {\n        \n    }\n\n    /**\n     * Get the maximum element without removing it.\n     * \n     * @return The maximum element.\n     * @throws RuntimeException if the priority queue is empty.\n     */\n    public int top() {\n        \n    }\n\n    /**\n     * Check if the priority queue is empty.\n     * \n     * @return true if the priority queue is empty, false otherwise.\n     */\n    public boolean isEmpty() {\n        return heap.isEmpty();\n    }\n\n    /**\n     * Get the size of the priority queue.\n     * \n     * @return The number of elements in the priority queue.\n     */\n    public int size() {\n        return heap.size();\n    }\n    }\n    \n}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static junit.framework.TestCase.*;\nimport static org.real.temp.Answer.*;\n\n\npublic class Tester {\n    private PriorityQueue pq;\n\n    @Before\n    public void setUp() {\n        pq = new PriorityQueue();\n    }\n\n    @Test\n    public void testInsertAndAccessMaximumElement() {\n        pq.push(10);\n        pq.push(20);\n        pq.push(5);\n        pq.push(30);\n        pq.push(15);\n\n        assertEquals(30, pq.top()); // Ensure the max element is 30\n    }\n\n    @Test\n    public void testRemoveMaximumElement() {\n        pq.push(10);\n        pq.push(20);\n        pq.push(5);\n        pq.push(30);\n\n        pq.pop(); // Remove 30\n        assertEquals(20, pq.top()); // Now the max should be 20\n        pq.pop(); // Remove 20\n        assertEquals(10, pq.top()); // Now the max should be 10\n    }\n\n    @Test\n    public void testCheckEmptyQueue() {\n        assertTrue(pq.isEmpty()); // Initially empty\n        pq.push(10);\n        assertFalse(pq.isEmpty()); // Now not empty\n        pq.pop();\n        assertTrue(pq.isEmpty()); // Back to empty\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testPopFromEmptyQueue() {\n        pq.pop(); // Should throw an error\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testAccessTopOfEmptyQueue() {\n        pq.top(); // Should throw an error\n    }\n\n    @Test\n    public void testMaintainMaxHeapProperty() {\n        pq.push(3);\n        pq.push(1);\n        pq.push(4);\n        pq.push(2);\n\n        assertEquals(4, pq.top()); // Ensure max is 4\n\n        pq.pop(); // Remove 4\n        assertEquals(3, pq.top()); // Now max is 3\n\n        pq.push(5); // Add 5\n        assertEquals(5, pq.top()); // Ensure max is now 5\n    }\n}", "prompt": "please write a java class , the function signature as below /**\n * A class representing a max-heap priority queue.\n */\npublic class Answer {\n    static class PriorityQueue{\nprivate List<Integer> heap; // This will store the elements of the heap\n\n    /** \n     * Constructor to initialize the priority queue.\n     */\n    public PriorityQueue() {\n        heap = new ArrayList<>();\n    }\n\n    /**\n     * Helper function to get the index of the parent.\n     * \n     * @param index The index of the child node.\n     * @return The index of the parent node.\n     */\n    private int parent(int index) {\n        return (index - 1) / 2;\n    }\n\n    /**\n     * Helper function to get the index of the left child.\n     * \n     * @param index The index of the parent node.\n     * @return The index of the left child node.\n     */\n    private int leftChild(int index) {\n        return 2 * index + 1;\n    }\n\n    /**\n     * Helper function to get the index of the right child.\n     * \n     * @param index The index of the parent node.\n     * @return The index of the right child node.\n     */\n    private int rightChild(int index) {\n        return 2 * index + 2;\n    }\n\n    /**\n     * Helper function to swap two elements in the heap.\n     * \n     * @param aIndex The index of the first element.\n     * @param bIndex The index of the second element.\n     */\n    private void swap(int aIndex, int bIndex) {\n\n    }\n\n    /**\n     * Heapify up to maintain the max-heap property after insertion.\n     * \n     * @param index The index of the newly inserted element.\n     */\n    private void heapifyUp(int index) {\n        \n    }\n\n    /**\n     * Heapify down to maintain the max-heap property after deletion.\n     * \n     * @param index The index of the element to be heapified down.\n     */\n    private void heapifyDown(int index) {\n        \n    }\n\n    /**\n     * Insert an element into the priority queue.\n     * \n     * @param value The value to be inserted.\n     */\n    public void push(int value) {\n        \n    }\n\n    /**\n     * Remove the maximum element from the priority queue.\n     * \n     * @throws RuntimeException if the priority queue is empty.\n     */\n    public void pop() {\n        \n    }\n\n    /**\n     * Get the maximum element without removing it.\n     * \n     * @return The maximum element.\n     * @throws RuntimeException if the priority queue is empty.\n     */\n    public int top() {\n        \n    }\n\n    /**\n     * Check if the priority queue is empty.\n     * \n     * @return true if the priority queue is empty, false otherwise.\n     */\n    public boolean isEmpty() {\n        return heap.isEmpty();\n    }\n\n    /**\n     * Get the size of the priority queue.\n     * \n     * @return The number of elements in the priority queue.\n     */\n    public int size() {\n        return heap.size();\n    }\n    }\n    \n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 187, "code_type": "method", "original_language": "c&cpp", "file_path": "392finalproject\\adf6d029b89d69fb819729655e8580737e8ef132\\mergesort_serial.c", "question_type": "Algorithm and data structure", "summary": "implement merge sort algorithm\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef merge_sort(arr: List[int], left: int, right: int):\n    \"\"\"\n    Sorts a portion of an array using the merge sort algorithm.\n\n    Args:\n        arr (List[int]): A list of integers that contains the elements to be sorted.\n        left (int): The starting index of the portion of the array to be sorted.\n        right (int): The ending index of the portion of the array to be sorted.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_sort_empty_array(self):\n        \"\"\"Test sorting an empty array.\"\"\"\n        empty_array = []\n        merge_sort(empty_array, 0, len(empty_array) - 1)\n        self.assertTrue(len(empty_array) == 0)  # Assert that the array is still empty\n\n    def test_sort_single_element_array(self):\n        \"\"\"Test sorting a single element array.\"\"\"\n        single_element = [1]\n        merge_sort(single_element, 0, len(single_element) - 1)\n        self.assertEqual(single_element, [1])  # Assert that it remains the same\n\n    def test_sort_sorted_array(self):\n        \"\"\"Test sorting a sorted array.\"\"\"\n        sorted_array = [1, 2, 3, 4, 5]\n        merge_sort(sorted_array, 0, len(sorted_array) - 1)\n        self.assertEqual(sorted_array, [1, 2, 3, 4, 5])  # Correct the expected value\n\n    def test_sort_reverse_sorted_array(self):\n        \"\"\"Test sorting a reverse sorted array.\"\"\"\n        reverse_sorted_array = [5, 4, 3, 2, 1]\n        merge_sort(reverse_sorted_array, 0, len(reverse_sorted_array) - 1)\n        self.assertEqual(reverse_sorted_array, [1, 2, 3, 4, 5])  # Assert it sorts correctly\n\n    def test_sort_random_integers(self):\n        \"\"\"Test sorting an array with random integers.\"\"\"\n        random_array = [38, 27, 43, 3, 9, 82, 10]\n        expected_sorted_array = [3, 9, 10, 27, 38, 43, 82]\n        merge_sort(random_array, 0, len(random_array) - 1)\n        self.assertEqual(random_array, expected_sorted_array)  # Assert the sorted array is correct\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef merge_sort(arr: List[int], left: int, right: int):\n    \"\"\"\n    Sorts a portion of an array using the merge sort algorithm.\n\n    Args:\n        arr (List[int]): A list of integers that contains the elements to be sorted.\n        left (int): The starting index of the portion of the array to be sorted.\n        right (int): The ending index of the portion of the array to be sorted.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Sorts a portion of an array using the merge sort algorithm.\n *\n *\n * @param arr A reference to a vector of integers that contains the\n *            elements to be sorted.\n * @param left The starting index of the portion of the array to be\n *             sorted.\n * @param right The ending index of the portion of the array to be\n *              sorted.\n */\nvoid merge_sort(std::vector<int>& arr, int left, int right) {}", "test_code": "TEST_CASE(\"Merge Sort Test Cases\", \"[merge_sort]\") {\n    SECTION(\"Sorting an empty array\") {\n        std::vector<int> empty_array = {};\n        merge_sort(empty_array, 0, empty_array.size() - 1);\n        REQUIRE(empty_array.empty() == true);\n    }\n\n    SECTION(\"Sorting a single element array\") {\n        std::vector<int> single_element = {1};\n        merge_sort(single_element, 0, single_element.size() - 1);\n        REQUIRE(single_element == std::vector<int>{1});\n    }\n\n    SECTION(\"Sorting a sorted array\") {\n        std::vector<int> sorted_array = {1, 2, 3, 4, 5};\n        merge_sort(sorted_array, 0, sorted_array.size() - 1);\n        REQUIRE(sorted_array == std::vector<int>{1, 2, 3, 2, 5});\n    }\n\n    SECTION(\"Sorting a reverse sorted array\") {\n        std::vector<int> reverse_sorted_array = {5, 4, 3, 2, 1};\n        merge_sort(reverse_sorted_array, 0, reverse_sorted_array.size() - 1);\n        REQUIRE(reverse_sorted_array == std::vector<int>{1, 2, 3, 4, 5});\n    }\n\n    SECTION(\"Sorting an array with random integers\") {\n        std::vector<int> random_array = {38, 27, 43, 3, 9, 82, 10};\n        std::vector<int> expected_sorted_array = {3, 9, 10, 27, 38, 43, 82};\n        merge_sort(random_array, 0, random_array.size() - 1);\n        REQUIRE(random_array == expected_sorted_array);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Sorts a portion of an array using the merge sort algorithm.\n *\n *\n * @param arr A reference to a vector of integers that contains the\n *            elements to be sorted.\n * @param left The starting index of the portion of the array to be\n *             sorted.\n * @param right The ending index of the portion of the array to be\n *              sorted.\n */\nvoid merge_sort(std::vector<int>& arr, int left, int right) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Sorts a portion of an array using the merge sort algorithm.\n *\n * @param arr An array of integers that contains the elements to be sorted.\n * @param left The starting index of the portion of the array to be sorted.\n * @param right The ending index of the portion of the array to be sorted.\n */\npublic void mergeSort(int[] arr, int left, int right) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testEmptyArray() {\n        int[] emptyArray = {};\n        mergeSort(emptyArray, 0, emptyArray.length - 1);\n        assertArrayEquals(new int[]{}, emptyArray);\n    }\n\n    @Test\n    public void testSingleElementArray() {\n        int[] singleElement = {1};\n        mergeSort(singleElement, 0, singleElement.length - 1);\n        assertArrayEquals(new int[]{1}, singleElement);\n    }\n\n    @Test\n    public void testSortedArray() {\n        int[] sortedArray = {1, 2, 3, 4, 5};\n        mergeSort(sortedArray, 0, sortedArray.length - 1);\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5}, sortedArray);\n    }\n\n    @Test\n    public void testReverseSortedArray() {\n        int[] reverseSortedArray = {5, 4, 3, 2, 1};\n        mergeSort(reverseSortedArray, 0, reverseSortedArray.length - 1);\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5}, reverseSortedArray);\n    }\n\n    @Test\n    public void testRandomArray() {\n        int[] randomArray = {38, 27, 43, 3, 9, 82, 10};\n        int[] expectedSortedArray = {3, 9, 10, 27, 38, 43, 82};\n        mergeSort(randomArray, 0, randomArray.length - 1);\n        assertArrayEquals(expectedSortedArray, randomArray);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Sorts a portion of an array using the merge sort algorithm.\n *\n * @param arr An array of integers that contains the elements to be sorted.\n * @param left The starting index of the portion of the array to be sorted.\n * @param right The ending index of the portion of the array to be sorted.\n */\npublic void mergeSort(int[] arr, int left, int right) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 188, "code_type": "method", "original_language": "c&cpp", "file_path": "392finalproject\\adf6d029b89d69fb819729655e8580737e8ef132\\shellsort_serial.c", "question_type": "Algorithm and data structure", "summary": "implement a function that performs Shell sort on an array", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef shell_sort(arr: List[int]):\n    \"\"\"\n    Implement a function that performs Shell sort on an array.\n\n    Args:\n        arr (List[int]): The array to be sorted.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\n\nfrom more_itertools import is_sorted\n\n\nclass Tester(unittest.TestCase):\n    \"\"\"Unit tests for the Shell sort functionality.\"\"\"\n\n    def test_already_sorted_array(self):\n        \"\"\"Test Case 1: Already sorted array.\"\"\"\n        arr = [1, 2, 3, 4, 5]\n        shell_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n    def test_reverse_sorted_array(self):\n        \"\"\"Test Case 2: Reverse sorted array.\"\"\"\n        arr = [5, 4, 3, 2, 1]\n        shell_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n    def test_array_with_duplicate_elements(self):\n        \"\"\"Test Case 3: Array with duplicate elements.\"\"\"\n        arr = [4, 2, 2, 4, 1]\n        shell_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n    def test_array_with_negative_numbers(self):\n        \"\"\"Test Case 4: Array with negative numbers.\"\"\"\n        arr = [-3, -1, -4, -2, 0]\n        shell_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n    def test_empty_array(self):\n        \"\"\"Test Case 5: Empty array.\"\"\"\n        arr = []\n        shell_sort(arr)\n        self.assertTrue(is_sorted(arr))\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef shell_sort(arr: List[int]):\n    \"\"\"\n    Implement a function that performs Shell sort on an array.\n\n    Args:\n        arr (List[int]): The array to be sorted.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * implement a function that performs Shell sort on an array\n * @param arr\n */\nvoid shellSort(std::vector<int>& arr) {\n}", "test_code": "\nbool isSorted(const std::vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nTEST_CASE(\"Shell sort - Basic functionality\", \"[shellSort]\") {\n    SECTION(\"Test Case 1: Already sorted array\") {\n        std::vector<int> arr = {1, 2, 3, 4, 5};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 2: Reverse sorted array\") {\n        std::vector<int> arr = {5, 4, 3, 2, 1};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 3: Array with duplicate elements\") {\n        std::vector<int> arr = {4, 2, 2, 4, 1};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 4: Array with negative numbers\") {\n        std::vector<int> arr = {-3, -1, -4, -2, 0};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 5: Empty array\") {\n        std::vector<int> arr = {};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * implement a function that performs Shell sort on an array\n * @param arr\n */\nvoid shellSort(std::vector<int>& arr) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Implement a function that performs Shell sort on an array.\n * @param arr the array to be sorted.\n */\npublic static void shellSort(int[] arr) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    public static boolean isSorted(int[] arr) {\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] < arr[i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testShellSortBasicFunctionality() {\n        // Test Case 1: Already sorted array\n        int[] arr1 = {1, 2, 3, 4, 5};\n        Answer.shellSort(arr1);\n        assertTrue(isSorted(arr1));\n\n        // Test Case 2: Reverse sorted array\n        int[] arr2 = {5, 4, 3, 2, 1};\n        Answer.shellSort(arr2);\n        assertTrue(isSorted(arr2));\n\n        // Test Case 3: Array with duplicate elements\n        int[] arr3 = {4, 2, 2, 4, 1};\n        Answer.shellSort(arr3);\n        assertTrue(isSorted(arr3));\n\n        // Test Case 4: Array with negative numbers\n        int[] arr4 = {-3, -1, -4, -2, 0};\n        Answer.shellSort(arr4);\n        assertTrue(isSorted(arr4));\n\n        // Test Case 5: Empty array\n        int[] arr5 = {};\n        Answer.shellSort(arr5);\n        assertTrue(isSorted(arr5));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Implement a function that performs Shell sort on an array.\n * @param arr the array to be sorted.\n */\npublic static void shellSort(int[] arr) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 189, "code_type": "method", "original_language": "c&cpp", "file_path": "wake_word\\d1495aa2811e7aae771cdff2fc4c63e14fc4a8ab\\firmware\\wake_word\\src\\utils\\base64.cpp", "question_type": "Data processing and transformation", "summary": "convert a byte array into a Base64 encoded string.", "language_version_list": {"python": {"code_signature": "def base64_encode(data: bytearray) -> str:\n    \"\"\"\n    Encodes a byte array into a Base64 encoded string.\n    Args:\n        data (bytearray): A bytearray representing the input data to be encoded.\n\n    Returns:\n        str: A string containing the Base64 encoded representation of the input data.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    \"\"\"Unit tests for Base64 encoding function.\"\"\"\n\n    def test_empty_input(self):\n        \"\"\"Empty input should return empty string.\"\"\"\n        input_data = bytearray([])\n        self.assertEqual(base64_encode(input_data), \"\")\n    \n    def test_encode_hello(self):\n        \"\"\"Encoding 'hello' should return 'aGVsbG8='.\"\"\"\n        input_data = bytearray([ord('h'), ord('e'), ord('l'), ord('l'), ord('o')])\n        self.assertEqual(base64_encode(input_data), \"aGVsbG8=\")\n    \n    def test_encode_world(self):\n        \"\"\"Encoding 'world' should return 'd29ybGQ='.\"\"\"\n        input_data = bytearray([ord('w'), ord('o'), ord('r'), ord('l'), ord('d')])\n        self.assertEqual(base64_encode(input_data), \"d29ybGQ=\")\n\n    def test_encode_foobar(self):\n        \"\"\"Encoding 'foobar' should return 'Zm9vYmFy'.\"\"\"\n        input_data = bytearray([ord('f'), ord('o'), ord('o'), ord('b'), ord('a'), ord('r')])\n        self.assertEqual(base64_encode(input_data), \"Zm9vYmFy\")\n\n    def test_encode_catch2(self):\n        \"\"\"Encoding 'Catch2' should return 'Q2F0Y2gy'.\"\"\"\n        input_data = bytearray([ord('C'), ord('a'), ord('t'), ord('c'), ord('h'), ord('2')])\n        self.assertEqual(base64_encode(input_data), \"Q2F0Y2gy\")\n    \n    def test_encode_single_byte(self):\n        \"\"\"Encoding single byte 'A' should return 'QQ=='.\"\"\"\n        input_data = bytearray([ord('A')])\n        self.assertEqual(base64_encode(input_data), \"QQ==\")\n", "prompt": "please write a python function , the function signature as below def base64_encode(data: bytearray) -> str:\n    \"\"\"\n    Encodes a byte array into a Base64 encoded string.\n    Args:\n        data (bytearray): A bytearray representing the input data to be encoded.\n\n    Returns:\n        str: A string containing the Base64 encoded representation of the input data.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Encodes a byte array into a Base64 encoded string.\n *\n * This function takes a vector of unsigned char data as input and converts it\n * into a Base64 encoded string.\n *\n * @param data A vector of unsigned char representing the input data to be encoded.\n * @return A std::string containing the Base64 encoded representation of the input data.\n *\n */\nstd::string base64_encode(const std::vector<unsigned char>& data);", "test_code": "TEST_CASE(\"Base64 Encode Tests\") {\n\n    SECTION(\"Empty input should return empty string\") {\n        std::vector<unsigned char> input = {};\n        REQUIRE(base64_encode(input) == \"\");\n    }\n\n    SECTION(\"Encoding 'hello' should return 'aGVsbG8='\") {\n        std::vector<unsigned char> input = {'h', 'e', 'l', 'l', 'o'};\n        REQUIRE(base64_encode(input) == \"aGVsbG8=\");\n    }\n\n    SECTION(\"Encoding 'world' should return 'd29ybGQ='\") {\n        std::vector<unsigned char> input = {'w', 'o', 'r', 'l', 'd'};\n        REQUIRE(base64_encode(input) == \"d29ybGQ=\");\n    }\n\n    SECTION(\"Encoding 'foobar' should return 'Zm9vYmFy'\") {\n        std::vector<unsigned char> input = {'f', 'o', 'o', 'b', 'a', 'r'};\n        REQUIRE(base64_encode(input) == \"Zm9vYmFy\");\n    }\n\n    SECTION(\"Encoding 'Catch2' should return 'Q2F0Y2gy'\") {\n        std::vector<unsigned char> input = {'C', 'a', 't', 'c', 'h', '2'};\n        REQUIRE(base64_encode(input) == \"Q2F0Y2gy\");\n    }\n\n    SECTION(\"Encoding single byte 'A' should return 'QQ=='\") {\n        std::vector<unsigned char> input = {'A'};\n        REQUIRE(base64_encode(input) == \"QQ==\");\n    }\n\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Encodes a byte array into a Base64 encoded string.\n *\n * This function takes a vector of unsigned char data as input and converts it\n * into a Base64 encoded string.\n *\n * @param data A vector of unsigned char representing the input data to be encoded.\n * @return A std::string containing the Base64 encoded representation of the input data.\n *\n */\nstd::string base64_encode(const std::vector<unsigned char>& data);", "addition_info": ""}, "java": {"code_signature": "/**\n * Encodes a byte array into a Base64 encoded string.\n *\n * This method takes a byte array as input and converts it\n * into a Base64 encoded string.\n *\n * @param data A byte array representing the input data to be encoded.\n * @return A String containing the Base64 encoded representation of the input data.\n */\npublic String base64Encode(byte[] data) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testEmptyInputShouldReturnEmptyString() {\n        byte[] input = {};\n        assertEquals(\"\", base64Encode(input));\n    }\n\n    @Test\n    public void testEncodingHelloShouldReturnAGVsbG8() {\n        byte[] input = {'h', 'e', 'l', 'l', 'o'};\n        assertEquals(\"aGVsbG8=\", base64Encode(input));\n    }\n\n    @Test\n    public void testEncodingWorldShouldReturnD29ybGQ() {\n        byte[] input = {'w', 'o', 'r', 'l', 'd'};\n        assertEquals(\"d29ybGQ=\", base64Encode(input));\n    }\n\n    @Test\n    public void testEncodingFoobarShouldReturnZm9vYmFy() {\n        byte[] input = {'f', 'o', 'o', 'b', 'a', 'r'};\n        assertEquals(\"Zm9vYmFy\", base64Encode(input));\n    }\n\n    @Test\n    public void testEncodingCatch2ShouldReturnQ2F0Y2gy() {\n        byte[] input = {'C', 'a', 't', 'c', 'h', '2'};\n        assertEquals(\"Q2F0Y2gy\", base64Encode(input));\n    }\n\n    @Test\n    public void testEncodingSingleByteAShouldReturnQQ() {\n        byte[] input = {'A'};\n        assertEquals(\"QQ==\", base64Encode(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Encodes a byte array into a Base64 encoded string.\n *\n * This method takes a byte array as input and converts it\n * into a Base64 encoded string.\n *\n * @param data A byte array representing the input data to be encoded.\n * @return A String containing the Base64 encoded representation of the input data.\n */\npublic String base64Encode(byte[] data) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 190, "code_type": "method", "original_language": "c&cpp", "file_path": "rvfpm\\f0a335a1b8af4f653780ba542084bd9aa9edffc1\\work\\src\\in_TestFloat.cpp", "question_type": "Data processing and transformation", "summary": "parses a given hexadecimal string into its corresponding floating-point number and returns the float value.", "language_version_list": {"python": {"code_signature": "def hex_string_to_float(hex_str: str) -> float:\n    \"\"\"\n    Parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n\n    Args:\n        hex_str (str): The hexadecimal string to be parsed.\n\n    Returns:\n        float: The corresponding floating-point number.\n    \"\"\"\n", "test_code": "import unittest\n\nclass Tester(unittest.TestCase):\n    \n    def test_positive_number(self):\n        \"\"\"Positive number: 40490FDB\"\"\"\n        hex_str = \"40490FDB\"  # 3.14159 in float\n        result = hex_string_to_float(hex_str)\n        self.assertAlmostEqual(result, 3.14159, delta=0.00001)\n\n    def test_negative_number(self):\n        \"\"\"Negative number: C0490FDB\"\"\"\n        hex_str = \"C0490FDB\"  # -3.14159 in float\n        result = hex_string_to_float(hex_str)\n        self.assertAlmostEqual(result, -3.14159, delta=0.00001)\n\n    def test_zero(self):\n        \"\"\"Zero: 00000000\"\"\"\n        hex_str = \"00000000\"  # 0.0 in float\n        result = hex_string_to_float(hex_str)\n        self.assertAlmostEqual(result, 0.0, delta=0.00001)\n\n    def test_small_positive_number(self):\n        \"\"\"Small positive number: 3F800000\"\"\"\n        hex_str = \"3F800000\"  # 1.0 in float\n        result = hex_string_to_float(hex_str)\n        self.assertAlmostEqual(result, 1.0, delta=0.00001)\n\n    def test_small_negative_number(self):\n        \"\"\"Small negative number: BF800000\"\"\"\n        hex_str = \"BF800000\"  # -1.0 in float\n        result = hex_string_to_float(hex_str)\n        self.assertAlmostEqual(result, -1.0, delta=0.00001)\n\n", "prompt": "please write a python function , the function signature as below def hex_string_to_float(hex_str: str) -> float:\n    \"\"\"\n    Parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n\n    Args:\n        hex_str (str): The hexadecimal string to be parsed.\n\n    Returns:\n        float: The corresponding floating-point number.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n * @param hexStr\n * @return\n */\nfloat hexStringToFloat(const std::string& hexStr) {\n\n}", "test_code": "TEST_CASE(\"Hexadecimal String to Float Conversion\", \"[hexStringToFloat]\") {\n\n    SECTION(\"Positive number: 40490FDB\") {\n        std::string hexStr = \"40490FDB\"; // 3.14159 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(3.14159f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Negative number: C0490FDB\") {\n        std::string hexStr = \"C0490FDB\"; // -3.14159 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(-3.14159f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Zero: 00000000\") {\n        std::string hexStr = \"00000000\"; // 0.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(0.0f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Small positive number: 3F800000\") {\n        std::string hexStr = \"3F800000\"; // 1.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(1.0f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Small negative number: BF800000\") {\n        std::string hexStr = \"BF800000\"; // -1.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(-1.0f).epsilon(0.00001f));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n * @param hexStr\n * @return\n */\nfloat hexStringToFloat(const std::string& hexStr) {\n\n}", "addition_info": ""}, "java": {"code_signature": "package org.real.temp;\n\n/**\n * Parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n *\n * @param hexStr the hexadecimal string to be parsed\n * @return the corresponding float value\n */\npublic float hexStringToFloat(String hexStr) {\n    // Method implementation goes here\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testHexStringToFloatPositive() {\n        String hexStr = \"40490FDB\"; // 3.14159 in float\n        float result = hexStringToFloat(hexStr);\n        assertEquals(3.14159f, result, 0.00001f);\n    }\n\n    @Test\n    public void testHexStringToFloatNegative() {\n        String hexStr = \"C0490FDB\"; // -3.14159 in float\n        float result = hexStringToFloat(hexStr);\n        assertEquals(-3.14159f, result, 0.00001f);\n    }\n\n    @Test\n    public void testHexStringToFloatZero() {\n        String hexStr = \"00000000\"; // 0.0 in float\n        float result = hexStringToFloat(hexStr);\n        assertEquals(0.0f, result, 0.00001f);\n    }\n\n    @Test\n    public void testHexStringToFloatSmallPositive() {\n        String hexStr = \"3F800000\"; // 1.0 in float\n        float result = hexStringToFloat(hexStr);\n        assertEquals(1.0f, result, 0.00001f);\n    }\n\n    @Test\n    public void testHexStringToFloatSmallNegative() {\n        String hexStr = \"BF800000\"; // -1.0 in float\n        float result = hexStringToFloat(hexStr);\n        assertEquals(-1.0f, result, 0.00001f);\n    }\n}", "prompt": "please write a java function , the function signature as below package org.real.temp;\n\n/**\n * Parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n *\n * @param hexStr the hexadecimal string to be parsed\n * @return the corresponding float value\n */\npublic float hexStringToFloat(String hexStr) {\n    // Method implementation goes here\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 191, "code_type": "method", "original_language": "c&cpp", "file_path": "rvfpm\\f0a335a1b8af4f653780ba542084bd9aa9edffc1\\work\\src\\in_TestFloat.cpp", "question_type": "Data processing and transformation", "summary": "Convert a floating-point number to a hexadecimal string. The process involves interpreting the bit pattern of the floating-point number as an unsigned integer and then formatting this integer value as a hexadecimal string without any prefix (like 0x). The output string should be 8 characters long, with leading zeros added if necessary to meet this length requirement.", "language_version_list": {"python": {"code_signature": "def float_to_hex(value: float) -> str:\n    \"\"\"\n    Converts a floating-point number to its hexadecimal representation.\n\n    Args:\n        value (float): The float value to be converted to hexadecimal.\n\n    Returns:\n        str: A string containing the hexadecimal representation of the input float.\n    \"\"\"\n", "test_code": "import unittest\n\nclass Tester(unittest.TestCase):\n    \"\"\"Test case for the float_to_hex function.\"\"\"\n\n    def test_positive_float(self):\n        \"\"\"Test with positive float 123.456.\"\"\"\n        input_value = 123.456\n        expected = \"42f6e979\"\n        self.assertEqual(float_to_hex(input_value), expected)\n\n    def test_negative_float(self):\n        \"\"\"Test with negative float -123.456.\"\"\"\n        input_value = -123.456\n        expected = \"c2f6e979\"\n        self.assertEqual(float_to_hex(input_value), expected)\n\n    def test_zero(self):\n        \"\"\"Test with zero.\"\"\"\n        input_value = 0.0\n        expected = \"00000000\"\n        self.assertEqual(float_to_hex(input_value), expected)\n\n    def test_small_positive_float(self):\n        \"\"\"Test with small positive float 0.0001.\"\"\"\n        input_value = 0.0001\n        expected = \"38d1b717\"\n        self.assertEqual(float_to_hex(input_value), expected)\n\n    def test_large_float(self):\n        \"\"\"Test with large float 1e30.\"\"\"\n        input_value = 1e30\n        expected = \"7149f2ca\"\n        self.assertEqual(float_to_hex(input_value), expected)\n", "prompt": "please write a python function , the function signature as below def float_to_hex(value: float) -> str:\n    \"\"\"\n    Converts a floating-point number to its hexadecimal representation.\n\n    Args:\n        value (float): The float value to be converted to hexadecimal.\n\n    Returns:\n        str: A string containing the hexadecimal representation of the input float.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a floating-point number to its hexadecimal representation.\n *\n * @param value The float value to be converted to hexadecimal.\n * @return A std::string containing the hexadecimal representation of the\n *         input float.\n *\n * @note The output string will be in lowercase hexadecimal format.\n */\nstd::string floatToHex(float value) {}", "test_code": "TEST_CASE(\"floatToHex tests\", \"[floatToHex]\") {\n    SECTION(\"Test with positive float 123.456\") {\n        float input = 123.456f;\n        std::string expected = \"42f6e979\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with negative float -123.456\") {\n        float input = -123.456f;\n        std::string expected = \"c2f6e979\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with zero\") {\n        float input = 0.0f;\n        std::string expected = \"00000000\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with small positive float 0.0001\") {\n        float input = 0.0001f;\n        std::string expected = \"38d1b717\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with large float 1e30\") {\n        float input = 1e30f;\n        std::string expected = \"7149f2ca\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a floating-point number to its hexadecimal representation.\n *\n * @param value The float value to be converted to hexadecimal.\n * @return A std::string containing the hexadecimal representation of the\n *         input float.\n *\n * @note The output string will be in lowercase hexadecimal format.\n */\nstd::string floatToHex(float value) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a floating-point number to its hexadecimal representation.\n *\n * @param value The float value to be converted to hexadecimal.\n * @return A String containing the hexadecimal representation of the\n *         input float.\n *\n * @note The output string will be in lowercase hexadecimal format.\n */\npublic static String floatToHex(float value) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testFloatToHexPositive() {\n        float input = 123.456f;\n        String expected = \"42f6e979\";\n        assertEquals(expected, Answer.floatToHex(input));\n    }\n\n    @Test\n    public void testFloatToHexNegative() {\n        float input = -123.456f;\n        String expected = \"c2f6e979\";\n        assertEquals(expected, Answer.floatToHex(input));\n    }\n\n    @Test\n    public void testFloatToHexZero() {\n        float input = 0.0f;\n        String expected = \"00000000\";\n        assertEquals(expected, Answer.floatToHex(input));\n    }\n\n    @Test\n    public void testFloatToHexSmallPositive() {\n        float input = 0.0001f;\n        String expected = \"38d1b717\";\n        assertEquals(expected, Answer.floatToHex(input));\n    }\n\n    @Test\n    public void testFloatToHexLarge() {\n        float input = 1e30f;\n        String expected = \"7149f2ca\";\n        assertEquals(expected, Answer.floatToHex(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a floating-point number to its hexadecimal representation.\n *\n * @param value The float value to be converted to hexadecimal.\n * @return A String containing the hexadecimal representation of the\n *         input float.\n *\n * @note The output string will be in lowercase hexadecimal format.\n */\npublic static String floatToHex(float value) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 192, "code_type": "method", "original_language": "c&cpp", "file_path": "rvfpm\\f0a335a1b8af4f653780ba542084bd9aa9edffc1\\work\\src\\in_TestFloat.cpp", "question_type": "Data processing and transformation", "summary": "Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.", "language_version_list": {"python": {"code_signature": "def hex_string_to_unsigned_int(hex_string: str) -> int:\n    \"\"\"\n    Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.\n\n    Args:\n        hex_string (str): The hexadecimal string to be converted.\n\n    Returns:\n        int: The unsigned integer value represented by the hexadecimal string.\n    \"\"\"\n", "test_code": "import unittest\n\nclass Tester(unittest.TestCase):\n    def test_hex_string_to_unsigned_int(self):\n        # Valid hex strings\n        self.assertEqual(hex_string_to_unsigned_int(\"1A3F\"), 6719)      # 1A3F in hex is 6719 in decimal\n        self.assertEqual(hex_string_to_unsigned_int(\"FFFF\"), 65535)     # FFFF in hex is 65535 in decimal\n        self.assertEqual(hex_string_to_unsigned_int(\"0\"), 0)            # 0 in hex is 0 in decimal\n        self.assertEqual(hex_string_to_unsigned_int(\"7F\"), 127)         # 7F in hex is 127 in decimal\n        self.assertEqual(hex_string_to_unsigned_int(\"ABC123\"), 11256099) # ABC123 in hex is 11256099 in decimal\n\n        # Lowercase hex string\n        self.assertEqual(hex_string_to_unsigned_int(\"abcd\"), 43981)     # abcd in hex is 43981 in decimal\n\n        # Hex string with leading zeroes\n        self.assertEqual(hex_string_to_unsigned_int(\"0001\"), 1)         # 0001 in hex is 1 in decimal\n\n        # Empty hex string\n        self.assertEqual(hex_string_to_unsigned_int(\"\"), 0)             # Empty string should be treated as 0\n\n        # Mixed case hex string\n        self.assertEqual(hex_string_to_unsigned_int(\"AbCdEf\"), 11259375) # AbCdEf in hex is 11259375 in decimal\n", "prompt": "please write a python function , the function signature as below def hex_string_to_unsigned_int(hex_string: str) -> int:\n    \"\"\"\n    Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.\n\n    Args:\n        hex_string (str): The hexadecimal string to be converted.\n\n    Returns:\n        int: The unsigned integer value represented by the hexadecimal string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.\n * @param hexString\n * @return\n */\nunsigned int hexStringToUnsignedInt(const std::string& hexString) {\n\n}", "test_code": "TEST_CASE(\"hexStringToUnsignedInt converts hex string to unsigned int\", \"[hexStringToUnsignedInt]\") {\n\n    SECTION(\"Valid hex strings\") {\n        REQUIRE(hexStringToUnsignedInt(\"1A3F\") == 6719); // 1A3F in hex is 6719 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"FFFF\") == 65535); // FFFF in hex is 65535 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"0\") == 0); // 0 in hex is 0 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"7F\") == 127); // 7F in hex is 127 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"ABC123\") == 11256099); // ABC123 in hex is 11256099 in decimal\n    }\n\n    SECTION(\"Lowercase hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"abcd\") == 43981); // abcd in hex is 43981 in decimal\n    }\n\n    SECTION(\"Hex string with leading zeroes\") {\n        REQUIRE(hexStringToUnsignedInt(\"0001\") == 1); // 0001 in hex is 1 in decimal\n    }\n\n    SECTION(\"Empty hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"\") == 0); // Empty string should be treated as 0\n    }\n\n    SECTION(\"Mixed case hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"AbCdEf\") == 11259375); // AbCdEf in hex is 11259375 in decimal\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.\n * @param hexString\n * @return\n */\nunsigned int hexStringToUnsignedInt(const std::string& hexString) {\n\n}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 193, "code_type": "method", "original_language": "c&cpp", "file_path": "rvfpm\\f0a335a1b8af4f653780ba542084bd9aa9edffc1\\work\\src\\in_TestFloat.cpp", "question_type": "Data processing and transformation", "summary": "Inverts the flag bits (the first five digits) of an unsigned integer to a hexadecimal string", "language_version_list": {"python": {"code_signature": "def conv_flags(value: int) -> str:\n    \"\"\"\n    Invert the flag bits of an unsigned integer to a hexadecimal string. The number of bits is not complete by 0.\n    Args:\n        value (int): The unsigned integer whose bits are to be inverted.\n\n    Returns:\n        str: A string containing the hexadecimal representation of the inverted bits.\n    \"\"\"\n", "test_code": "import unittest\n\nclass Tester(unittest.TestCase):\n    \"\"\"\n    Test cases for the conv_flags function.\n    \"\"\"\n    \n    def test_conv_flags(self):\n        self.assertEqual(conv_flags(0x0000001F), \"FFFFFFE0\")\n        self.assertEqual(conv_flags(0x00000015), \"FFFFFFEA\")\n        self.assertEqual(conv_flags(0xFFFFFFFF), \"0\")\n        self.assertEqual(conv_flags(0x12345678), \"EDCBA987\")\n        self.assertEqual(conv_flags(0x00000001), \"FFFFFFFE\")\n        self.assertEqual(conv_flags(0x00000003), \"FFFFFFFC\")\n        self.assertEqual(conv_flags(0x00000008), \"FFFFFFF7\")\n        self.assertEqual(conv_flags(0xABCDEF01), \"543210FE\")\n", "prompt": "please write a python function , the function signature as below def conv_flags(value: int) -> str:\n    \"\"\"\n    Invert the flag bits of an unsigned integer to a hexadecimal string. The number of bits is not complete by 0.\n    Args:\n        value (int): The unsigned integer whose bits are to be inverted.\n\n    Returns:\n        str: A string containing the hexadecimal representation of the inverted bits.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Invert the flag bits of an unsigned integer to a hexadecimal string. The number of bits is not complete by 0\n *\n * @param value The unsigned integer whose bits are to be inverted.\n * @return A std::string containing the hexadecimal representation of the inverted bits.\n */\nstd::string convFlags(unsigned int value) {\n\n}", "test_code": "TEST_CASE(\"convFlags Test Cases\", \"[convFlags]\") {\n    REQUIRE(convFlags(0x0000001F) == \"FFFFFFE0\");\n\n    REQUIRE(convFlags(0x00000015) == \"FFFFFFEA\");\n\n    REQUIRE(convFlags(0xFFFFFFFF) == \"0\");\n\n    REQUIRE(convFlags(0x12345678) == \"EDCBA987\");\n\n    REQUIRE(convFlags(0x00000001) == \"FFFFFFFE\");\n\n    REQUIRE(convFlags(0x00000003) == \"FFFFFFFC\");\n\n    REQUIRE(convFlags(0x00000008) == \"FFFFFFF7\");\n\n    REQUIRE(convFlags(0xABCDEF01) == \"543210FE\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Invert the flag bits of an unsigned integer to a hexadecimal string. The number of bits is not complete by 0\n *\n * @param value The unsigned integer whose bits are to be inverted.\n * @return A std::string containing the hexadecimal representation of the inverted bits.\n */\nstd::string convFlags(unsigned int value) {\n\n}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 194, "code_type": "method", "original_language": "c&cpp", "file_path": "exploring-CGO\\f73273080c90ce7d2114f4173d2674226885113e\\static\\gohello\\hello.c", "question_type": "Algorithm and data structure", "summary": "Returns a copy of the specified string via dynamic memory allocation", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Returns a copy of the specified string via dynamic memory allocation\n *\n * @param str The input C-string to be copied.\n * @return A pointer to the dynamically allocated copy of the input string.\n * @throws std::invalid_argument if the input string is null.\n */\nchar* return_string(const char* str) {\n\n}", "test_code": "\nTEST_CASE(\"return_string Test Cases\", \"[return_string]\") {\n    // Test Case 1: Copy a non-empty string\n    const char* original1 = \"Hello, World!\";\n    char* copy1 = return_string(original1);\n    REQUIRE(std::strcmp(copy1, original1) == 0);\n    delete[] copy1;\n\n    // Test Case 2: Copy an empty string\n    const char* original2 = \"\";\n    char* copy2 = return_string(original2);\n    REQUIRE(std::strcmp(copy2, original2) == 0);\n    delete[] copy2;\n\n    // Test Case 3: Copy a string with special characters\n    const char* original3 = \"C++ is fun! @#$%^&*()\";\n    char* copy3 = return_string(original3);\n    REQUIRE(std::strcmp(copy3, original3) == 0);\n    delete[] copy3;\n\n    // Test Case 4: Copy a single character string\n    const char* original4 = \"A\";\n    char* copy4 = return_string(original4);\n    REQUIRE(std::strcmp(copy4, original4) == 0);\n    delete[] copy4;\n\n    // Test Case 5: Passing a null pointer (should throw an exception)\n    REQUIRE_THROWS_AS(return_string(nullptr), std::invalid_argument);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Returns a copy of the specified string via dynamic memory allocation\n *\n * @param str The input C-string to be copied.\n * @return A pointer to the dynamically allocated copy of the input string.\n * @throws std::invalid_argument if the input string is null.\n */\nchar* return_string(const char* str) {\n\n}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 195, "code_type": "class", "original_language": "c&cpp", "file_path": "Environmental-Sensing-BLE-Device-ESP32\\8cbf50eae8bb1aab64fcf3bac97cbf60761c641a\\src\\basic_stack.h", "question_type": "Algorithm and data structure", "summary": "Implement a floating-point stack structure based on arrays", "language_version_list": {"python": {"code_signature": "class Stack:\n    \"\"\"\n    Implement a floating-point stack structure based on arrays.\n\n    This class provides basic stack operations including push, pop, peek, and checking if the stack is empty.\n    The stack is implemented using a fixed-size array. If the stack reaches its maximum capacity, no more elements\n    can be pushed onto it until space is freed by popping elements.\n    \"\"\"\n\n    def push(self, value: float):\n        \"\"\"\n        Pushes a floating-point number onto the stack.\n\n        :param value: The floating-point number to be pushed onto the stack.\n        :raises StackOverflowError: If the stack is full.\n        \"\"\"\n\n    def pop(self) -> float:\n        \"\"\"\n        Pops the top element off the stack and returns it.\n\n        :return: The floating-point number that was popped from the stack.\n        :raises StackUnderflowError: If the stack is empty.\n        \"\"\"\n\n    def peek(self) -> float:\n        \"\"\"\n        Returns the top element of the stack without removing it.\n\n        :return: The floating-point number at the top of the stack.\n        :raises StackUnderflowError: If the stack is empty.\n        \"\"\"\n\n    def is_empty(self) -> bool:\n        \"\"\"\n        Checks whether the stack is empty.\n\n        :return: True if the stack is empty; False otherwise.\n        \"\"\"\n", "test_code": "class Tester(unittest.TestCase):\n\n    def test_stack_operations(self):\n        \"\"\"Test stack_t Test Cases\"\"\"\n        stack = Stack(10)  # Provide capacity when creating the stack\n\n        # Test Case 1: Pushing and popping a single element\n        stack.push(3.14)\n        self.assertEqual(stack.pop(), 3.14)\n        self.assertTrue(stack.is_empty())  # Change to is_empty\n\n        # Test Case 2: Pushing multiple elements and checking peek\n        stack.push(1.23)\n        stack.push(4.56)\n        self.assertEqual(stack.peek(), 4.56)\n        self.assertEqual(stack.pop(), 4.56)\n        self.assertEqual(stack.pop(), 1.23)\n        self.assertTrue(stack.is_empty())  # Change to is_empty\n\n        # Test Case 3: Pop from an empty stack (should throw an exception)\n        with self.assertRaises(StackUnderflowError):\n            stack.pop()\n\n        # Test Case 4: Peek on an empty stack (should throw an exception)\n        with self.assertRaises(StackUnderflowError):\n            stack.peek()\n\n        # Test Case 5: Push elements until stack is full and attempt to push another element\n        full_stack = Stack(100)  # Provide capacity when creating the stack\n        for i in range(100):\n            full_stack.push(float(i) + 0.5)\n\n        with self.assertRaises(StackOverflowError):\n            full_stack.push(100.5)\n", "prompt": "please write a python class , the class signature as below class Stack:\n    \"\"\"\n    Implement a floating-point stack structure based on arrays.\n\n    This class provides basic stack operations including push, pop, peek, and checking if the stack is empty.\n    The stack is implemented using a fixed-size array. If the stack reaches its maximum capacity, no more elements\n    can be pushed onto it until space is freed by popping elements.\n    \"\"\"\n\n    def push(self, value: float):\n        \"\"\"\n        Pushes a floating-point number onto the stack.\n\n        :param value: The floating-point number to be pushed onto the stack.\n        :raises StackOverflowError: If the stack is full.\n        \"\"\"\n\n    def pop(self) -> float:\n        \"\"\"\n        Pops the top element off the stack and returns it.\n\n        :return: The floating-point number that was popped from the stack.\n        :raises StackUnderflowError: If the stack is empty.\n        \"\"\"\n\n    def peek(self) -> float:\n        \"\"\"\n        Returns the top element of the stack without removing it.\n\n        :return: The floating-point number at the top of the stack.\n        :raises StackUnderflowError: If the stack is empty.\n        \"\"\"\n\n    def is_empty(self) -> bool:\n        \"\"\"\n        Checks whether the stack is empty.\n\n        :return: True if the stack is empty; False otherwise.\n        \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Implement a floating-point stack structure based on arrays\n *\n * This class provides basic stack operations including push, pop, peek, and checking if the stack is empty.\n * The stack is implemented using a fixed-size array. If the stack reaches its maximum capacity, no more elements\n * can be pushed onto it until space is freed by popping elements.\n */\nclass stack_t {\n\t\n};", "test_code": "TEST_CASE(\"stack_t Test Cases\", \"[stack_t]\") {\n    stack_t stack(10); // Provide capacity when creating the stack\n\n    // Test Case 1: Pushing and popping a single element\n    stack.push(3.14f);\n    REQUIRE(stack.pop() == Approx(3.14f));\n    REQUIRE(stack.is_empty() == true); // Change to is_empty\n\n    // Test Case 2: Pushing multiple elements and checking peek\n    stack.push(1.23f);\n    stack.push(4.56f);\n    REQUIRE(stack.peek() == Approx(4.56f));\n    REQUIRE(stack.pop() == Approx(4.56f));\n    REQUIRE(stack.pop() == Approx(1.23f));\n    REQUIRE(stack.is_empty() == true); // Change to is_empty\n\n    // Test Case 3: Pop from an empty stack (should throw an exception)\n    REQUIRE_THROWS_AS(stack.pop(), std::underflow_error);\n\n    // Test Case 4: Peek on an empty stack (should throw an exception)\n    REQUIRE_THROWS_AS(stack.peek(), std::underflow_error);\n\n    // Test Case 5: Push elements until stack is full and attempt to push another element\n    stack_t fullStack(100); // Provide capacity when creating the stack\n    for (int i = 0; i < 100; ++i) {\n        fullStack.push(static_cast<float>(i) + 0.5f);\n    }\n    REQUIRE_THROWS_AS(fullStack.push(100.5f), std::overflow_error);\n}", "prompt": "please write a cpp class , the class signature as below /**\n * Implement a floating-point stack structure based on arrays\n *\n * This class provides basic stack operations including push, pop, peek, and checking if the stack is empty.\n * The stack is implemented using a fixed-size array. If the stack reaches its maximum capacity, no more elements\n * can be pushed onto it until space is freed by popping elements.\n */\nclass stack_t {\n\t\n};", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 196, "code_type": "method", "original_language": "c&cpp", "file_path": "learning\\5b9dc5c7470295980853b58c37c55d1350dc4480\\trv3wood\\assignment\\assignment5\\C2.cpp", "question_type": "Algorithm and data structure", "summary": "Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef generate_primes(limit: int) -> List[int]:\n    \"\"\"\n    Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm.\n\n    Args:\n        limit (int): The upper bound (inclusive) for finding prime numbers.\n\n    Returns:\n        List[int]: A list of integers containing all prime numbers less than or equal to the limit.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_small_limit(self):\n        \"\"\"Test Case 1: Small limit (10)\"\"\"\n        expected = [2, 3, 5, 7]\n        self.assertEqual(generate_primes(10), expected)\n\n    def test_prime_limit(self):\n        \"\"\"Test Case 2: Prime limit (29)\"\"\"\n        expected = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        self.assertEqual(generate_primes(29), expected)\n\n    def test_non_prime_limit(self):\n        \"\"\"Test Case 3: Non-prime limit (30)\"\"\"\n        expected = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        self.assertEqual(generate_primes(30), expected)\n\n    def test_limit_of_two(self):\n        \"\"\"Test Case 4: Limit of 2 (smallest prime)\"\"\"\n        expected = [2]\n        self.assertEqual(generate_primes(2), expected)\n\n    def test_invalid_limit(self):\n        \"\"\"Test Case 5: Invalid limit (1, should throw an exception)\"\"\"\n        with self.assertRaises(ValueError):  # Catch ValueError instead of std::invalid_argument\n            generate_primes(1)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef generate_primes(limit: int) -> List[int]:\n    \"\"\"\n    Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm.\n\n    Args:\n        limit (int): The upper bound (inclusive) for finding prime numbers.\n\n    Returns:\n        List[int]: A list of integers containing all prime numbers less than or equal to the limit.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return A vector of integers containing all prime numbers less than or equal to the limit.\n * @throws std::invalid_argument if the limit is less than 2.\n */\nstd::vector<int> generatePrimes(int limit) {\n\t\n}", "test_code": "TEST_CASE(\"Sieve of Eratosthenes Test Cases\", \"[generatePrimes]\") {\n    // Test Case 1: Small limit (10)\n    std::vector<int> expected1 = {2, 3, 5, 7};\n    REQUIRE(generatePrimes(10) == expected1);\n\n    // Test Case 2: Prime limit (29)\n    std::vector<int> expected2 = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    REQUIRE(generatePrimes(29) == expected2);\n\n    // Test Case 3: Non-prime limit (30)\n    std::vector<int> expected3 = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    REQUIRE(generatePrimes(30) == expected3);\n\n    // Test Case 4: Limit of 2 (smallest prime)\n    std::vector<int> expected4 = {2};\n    REQUIRE(generatePrimes(2) == expected4);\n\n    // Test Case 5: Invalid limit (1, should throw an exception)\n    REQUIRE_THROWS_AS(generatePrimes(1), std::invalid_argument);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return A vector of integers containing all prime numbers less than or equal to the limit.\n * @throws std::invalid_argument if the limit is less than 2.\n */\nstd::vector<int> generatePrimes(int limit) {\n\t\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return A list of integers containing all prime numbers less than or equal to the limit.\n * @throws IllegalArgumentException if the limit is less than 2.\n */\npublic static List<Integer> generatePrimes(int limit) {}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport org.junit.Rule;\nimport org.junit.rules.ExpectedException;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Rule\n    public ExpectedException thrown = ExpectedException.none();\n\n    @Test\n    public void testGeneratePrimes_SmallLimit() {\n        List<Integer> expected = Arrays.asList(2, 3, 5, 7);\n        assertEquals(expected, Answer.generatePrimes(10));\n    }\n\n    @Test\n    public void testGeneratePrimes_PrimeLimit() {\n        List<Integer> expected = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);\n        assertEquals(expected, Answer.generatePrimes(29));\n    }\n\n    @Test\n    public void testGeneratePrimes_NonPrimeLimit() {\n        List<Integer> expected = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);\n        assertEquals(expected, Answer.generatePrimes(30));\n    }\n\n    @Test\n    public void testGeneratePrimes_LimitOfTwo() {\n        List<Integer> expected = Arrays.asList(2);\n        assertEquals(expected, Answer.generatePrimes(2));\n    }\n\n    @Test\n    public void testGeneratePrimes_InvalidLimit() {\n        thrown.expect(IllegalArgumentException.class);\n        thrown.expectMessage(\"Limit must be greater than or equal to 2.\");\n        Answer.generatePrimes(1);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return A list of integers containing all prime numbers less than or equal to the limit.\n * @throws IllegalArgumentException if the limit is less than 2.\n */\npublic static List<Integer> generatePrimes(int limit) {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 197, "code_type": "method", "original_language": "c&cpp", "file_path": "learning\\5b9dc5c7470295980853b58c37c55d1350dc4480\\trv3wood\\assignment\\assignment5\\C3.cpp", "question_type": "Algorithm and data structure", "summary": "Use list data structure to simulate Joseph rings to solve Joseph rings problem\n", "language_version_list": {"python": {"code_signature": "def josephus(n: int, k: int) -> int:\n    \"\"\"\n    Simulates the Josephus problem using a list to represent the circle of people.\n    Args:\n        n (int): The number of people in the circle (1 to n).\n        k (int): The step count (every k-th person will be eliminated).\n\n    Returns:\n        int: The position of the last person remaining (1-indexed).\n    \"\"\"\n", "test_code": "# Unit Test Class\nimport unittest\n\n\nclass TestJosephusProblem(unittest.TestCase):\n\n    def test_case_1(self):\n        self.assertEqual(josephus(7, 3), 4)  # Standard case\n\n    def test_case_2(self):\n        self.assertEqual(josephus(1, 1), 1)  # Only one person\n\n    def test_case_3(self):\n        self.assertEqual(josephus(5, 2), 3)  # Smaller group, step 2\n\n    def test_case_4(self):\n        self.assertEqual(josephus(10, 5), 3)  # Larger group, step 5\n\n    def test_case_5(self):\n        self.assertEqual(josephus(6, 1), 6)  # Eliminate every 1st person\n\n    def test_case_6(self):\n        self.assertEqual(josephus(8, 4), 6)  # Step 4 in a group of 8\n\n    def test_case_7(self):\n        self.assertEqual(josephus(12, 7), 12)  # Larger group, arbitrary step", "prompt": "please write a python function , the function signature as below def josephus(n: int, k: int) -> int:\n    \"\"\"\n    Simulates the Josephus problem using a list to represent the circle of people.\n    Args:\n        n (int): The number of people in the circle (1 to n).\n        k (int): The step count (every k-th person will be eliminated).\n\n    Returns:\n        int: The position of the last person remaining (1-indexed).\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Simulate a game based on the order of prime numbers, using a circular linked list to represent the cyclic structure of players, and remove players one by one\n *\n * This function creates an instance of the PrimeGame class, which encapsulates the logic\n * for simulating the game. It then calls the findOrder method on the PrimeGame object\n * to determine and return the order in which players are removed based on the sequence of prime numbers.\n *\n * @param n The number of players in the game.\n * @return A vector of integers representing the order of players being removed from the ring.\n */\nvector<int> findOrder(int n) {\n\n}", "test_code": "TEST_CASE(\"FindOrder Test Cases\", \"[findOrder]\") {\n    // Test Case 1: Minimum valid input with 2 players\n    REQUIRE(findOrder(2) == std::vector<int>{2, 1});\n\n    // Test Case 2: 3 players\n    REQUIRE(findOrder(3) == std::vector<int>{2, 3, 1});\n\n    // Test Case 3: 5 players\n    REQUIRE(findOrder(5) == std::vector<int>{2, 5, 3, 4, 1});\n\n    // Test Case 4: 7 players\n    REQUIRE(findOrder(7) == std::vector<int>{ 2, 5, 4, 1, 6, 7, 3});\n\n    // Test Case 5: 10 players\n    REQUIRE(findOrder(10) == std::vector<int>{ 2, 5, 10, 9, 7, 3, 4, 6, 8, 1});\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Simulate a game based on the order of prime numbers, using a circular linked list to represent the cyclic structure of players, and remove players one by one\n *\n * This function creates an instance of the PrimeGame class, which encapsulates the logic\n * for simulating the game. It then calls the findOrder method on the PrimeGame object\n * to determine and return the order in which players are removed based on the sequence of prime numbers.\n *\n * @param n The number of players in the game.\n * @return A vector of integers representing the order of players being removed from the ring.\n */\nvector<int> findOrder(int n) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Simulates the Josephus problem using a list to represent the circle of people.\n *\n * @param n The number of people in the circle (1 to n).\n * @param k The step count (every k-th person will be eliminated).\n * @return The position of the last person remaining (1-indexed).\n */\npublic static int josephus(int n, int k) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n\n    @Test\n    public void testCase1() {\n        assertEquals(4, josephus(7, 3));  // Standard case\n    }\n\n    @Test\n    public void testCase2() {\n        assertEquals(1, josephus(1, 1));  // Only one person\n    }\n\n    @Test\n    public void testCase3() {\n        assertEquals(3, josephus(5, 2));  // Smaller group, step 2\n    }\n\n    @Test\n    public void testCase4() {\n        assertEquals(3, josephus(10, 5));  // Larger group, step 5\n    }\n\n    @Test\n    public void testCase5() {\n        assertEquals(6, josephus(6, 1));  // Eliminate every 1st person\n    }\n\n    @Test\n    public void testCase6() {\n        assertEquals(6, josephus(8, 4));  // Step 4 in a group of 8\n    }\n\n    @Test\n    public void testCase7() {\n        assertEquals(12, josephus(12, 7));  // Larger group, arbitrary step\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Simulates the Josephus problem using a list to represent the circle of people.\n *\n * @param n The number of people in the circle (1 to n).\n * @param k The step count (every k-th person will be eliminated).\n * @return The position of the last person remaining (1-indexed).\n */\npublic static int josephus(int n, int k) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 198, "code_type": "method", "original_language": "c&cpp", "file_path": "AOJ\\94f986991a57219ea2860ac8cf7992274b68db61\\alds1\\1d.cpp", "question_type": "Algorithm and data structure", "summary": "Calculate the maximum difference between any two elements in an array of integers, where the larger number must come after the smaller number (i.e., the subsequent element minus the previous element).", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef find_max_difference(l: List[int]) -> int:\n    \"\"\"\n    Finds the maximum difference between elements in the array such that the smaller element appears before the larger one.\n    Args:\n        l (List[int]): A list of integers containing the elements.\n\n    Returns:\n        int: The maximum difference.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_general_case(self):\n        l = [2, 3, 10, 6, 4, 8, 1]\n        self.assertEqual(find_max_difference(l), 8)  # Maximum difference is 10 - 2 = 8\n\n    def test_decreasing_sequence(self):\n        l = [10, 9, 8, 7, 6, 5]\n        self.assertEqual(find_max_difference(l), 0)  # Maximum difference should be 0\n\n    def test_all_elements_same(self):\n        l = [5, 5, 5, 5, 5]\n        self.assertEqual(find_max_difference(l), 0)  # Maximum difference is 5 - 5 = 0\n\n    def test_only_two_elements(self):\n        l = [3, 8]\n        self.assertEqual(find_max_difference(l), 5)  # Maximum difference is 8 - 3 = 5\n\n    def test_single_element(self):\n        l = [4]\n        self.assertEqual(find_max_difference(l), 0)  # Only one element, no difference to calculate\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_max_difference(l: List[int]) -> int:\n    \"\"\"\n    Finds the maximum difference between elements in the array such that the smaller element appears before the larger one.\n    Args:\n        l (List[int]): A list of integers containing the elements.\n\n    Returns:\n        int: The maximum difference.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l A vector of integers containing the elements.\n * @return The maximum difference.\n */\nint findMaxDifference(const vector<int> &l) {}", "test_code": "TEST_CASE(\"General case\", \"[findMaxDifference]\") {\n    std::vector<int> l = {2, 3, 10, 6, 4, 8, 1};\n    REQUIRE(findMaxDifference(l) == 8);  // Maximum difference is 10 - 2 = 8\n}\n\n// Test case 2: Decreasing sequence\nTEST_CASE(\"Decreasing sequence\", \"[findMaxDifference]\") {\n    std::vector<int> l = {10, 9, 8, 7, 6, 5};\n    REQUIRE(findMaxDifference(l) == 0);  // Maximum difference should be 0, as all differences are negative\n}\n\n// Test case 3: All elements the same\nTEST_CASE(\"All elements the same\", \"[findMaxDifference]\") {\n    std::vector<int> l = {5, 5, 5, 5, 5};\n    REQUIRE(findMaxDifference(l) == 0);  // Maximum difference is 5 - 5 = 0\n}\n\n// Test case 4: Only two elements\nTEST_CASE(\"Only two elements\", \"[findMaxDifference]\") {\n    std::vector<int> l = {3, 8};\n    REQUIRE(findMaxDifference(l) == 5);  // Maximum difference is 8 - 3 = 5\n}\n\n// Test case 5: Only one element\nTEST_CASE(\"Single element\", \"[findMaxDifference]\") {\n    std::vector<int> l = {4};\n    REQUIRE(findMaxDifference(l) == 0);  // Only one element, no difference to calculate\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l A vector of integers containing the elements.\n * @return The maximum difference.\n */\nint findMaxDifference(const vector<int> &l) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l A list of integers containing the elements.\n * @return The maximum difference.\n */\npublic static int findMaxDifference(List<Integer> l) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testGeneralCase() {\n        List<Integer> l = Arrays.asList(2, 3, 10, 6, 4, 8, 1);\n        assertEquals(8, Answer.findMaxDifference(l));  // Maximum difference is 10 - 2 = 8\n    }\n\n    @Test\n    public void testDecreasingSequence() {\n        List<Integer> l = Arrays.asList(10, 9, 8, 7, 6, 5);\n        assertEquals(0, Answer.findMaxDifference(l));  // Maximum difference should be 0\n    }\n\n    @Test\n    public void testAllElementsSame() {\n        List<Integer> l = Arrays.asList(5, 5, 5, 5, 5);\n        assertEquals(0, Answer.findMaxDifference(l));  // Maximum difference is 5 - 5 = 0\n    }\n\n    @Test\n    public void testOnlyTwoElements() {\n        List<Integer> l = Arrays.asList(3, 8);\n        assertEquals(5, Answer.findMaxDifference(l));  // Maximum difference is 8 - 3 = 5\n    }\n\n    @Test\n    public void testSingleElement() {\n        List<Integer> l = Arrays.asList(4);\n        assertEquals(0, Answer.findMaxDifference(l));  // Only one element, no difference to calculate\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l A list of integers containing the elements.\n * @return The maximum difference.\n */\npublic static int findMaxDifference(List<Integer> l) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 200, "code_type": "method", "original_language": "c&cpp", "file_path": "wake_word\\d1495aa2811e7aae771cdff2fc4c63e14fc4a8ab\\firmware\\wake_word\\src\\api\\token_manager.cpp", "question_type": "Data processing and transformation", "summary": "Extracts the string contained in the first pair of braces {} from an input string\n", "language_version_list": {"python": {"code_signature": "def extract_string_from_braces(input: str) -> str:\n    \"\"\"\n    Extracts the string contained in the first pair of braces `{}` from the input string.\n\n    Args:\n        input (str): The input string from which the braces content will be extracted.\n\n    Returns:\n        str: A substring enclosed within the first pair of braces, or an error message if braces are missing.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    \"\"\"Test cases for extract_string_from_braces function.\"\"\"\n\n    def test_basic_extraction(self):\n        \"\"\"Basic extraction.\"\"\"\n        input_data = \"This is a sample text with some data {data: \\\"value\\\"} and more text.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"{data: \\\"value\\\"}\")\n\n    def test_no_braces(self):\n        \"\"\"No braces.\"\"\"\n        input_data = \"This string has no braces.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"No opening brace found.\")\n\n    def test_only_opening_brace(self):\n        \"\"\"Only opening brace.\"\"\"\n        input_data = \"This string has an opening brace { but no closing brace.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"No closing brace found.\")\n\n    def test_only_closing_brace(self):\n        \"\"\"Only closing brace.\"\"\"\n        input_data = \"This string has a closing brace } but no opening brace.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"No opening brace found.\")\n\n    def test_multiple_braces(self):\n        \"\"\"Multiple braces.\"\"\"\n        input_data = \"First {first} and second {second} braces.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"{first}\")\n\n    def test_empty_braces(self):\n        \"\"\"Empty braces.\"\"\"\n        input_data = \"This string has empty braces {} and some text.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"{}\")\n\n", "prompt": "please write a python function , the function signature as below def extract_string_from_braces(input: str) -> str:\n    \"\"\"\n    Extracts the string contained in the first pair of braces `{}` from the input string.\n\n    Args:\n        input (str): The input string from which the braces content will be extracted.\n\n    Returns:\n        str: A substring enclosed within the first pair of braces, or an error message if braces are missing.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extracts the string contained in the first pair of braces `{}` from the input string.\n *\n * @param input The input string from which the braces content will be extracted.\n * @return A substring enclosed within the first pair of braces, or an error message if braces are missing.\n */\nstd::string extractStringFromBraces(const std::string& input) {}", "test_code": "TEST_CASE(\"Test cases for extractStringFromBraces function\") {\n\n    SECTION(\"Basic extraction\") {\n        std::string input = \"This is a sample text with some data {data: \\\"value\\\"} and more text.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"{data: \\\"value\\\"}\");\n    }\n\n    SECTION(\"No braces\") {\n        std::string input = \"This string has no braces.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"No opening brace found.\");\n    }\n\n    SECTION(\"Only opening brace\") {\n        std::string input = \"This string has an opening brace { but no closing brace.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"No closing brace found.\");\n    }\n\n    SECTION(\"Only closing brace\") {\n        std::string input = \"This string has a closing brace } but no opening brace.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"No opening brace found.\");\n    }\n    SECTION(\"Multiple braces\") {\n        std::string input = \"First {first} and second {second} braces.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"{first}\");\n    }\n\n    SECTION(\"Empty braces\") {\n        std::string input = \"This string has empty braces {} and some text.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"{}\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts the string contained in the first pair of braces `{}` from the input string.\n *\n * @param input The input string from which the braces content will be extracted.\n * @return A substring enclosed within the first pair of braces, or an error message if braces are missing.\n */\nstd::string extractStringFromBraces(const std::string& input) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Extracts the string contained in the first pair of braces `{}` from the input string.\n *\n * @param input The input string from which the braces content will be extracted.\n * @return A substring enclosed within the first pair of braces, or an error message if braces are missing.\n */\npublic static String extractStringFromBraces(String input) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testBasicExtraction() {\n        String input = \"This is a sample text with some data {data: \\\"value\\\"} and more text.\";\n        String result = extractStringFromBraces(input);\n        assertEquals(\"{data: \\\"value\\\"}\", result);\n    }\n\n    @Test\n    public void testNoBraces() {\n        String input = \"This string has no braces.\";\n        String result = extractStringFromBraces(input);\n        assertEquals(\"No opening brace found.\", result);\n    }\n\n    @Test\n    public void testOnlyOpeningBrace() {\n        String input = \"This string has an opening brace { but no closing brace.\";\n        String result = extractStringFromBraces(input);\n        assertEquals(\"No closing brace found.\", result);\n    }\n\n    @Test\n    public void testOnlyClosingBrace() {\n        String input = \"This string has a closing brace } but no opening brace.\";\n        String result = extractStringFromBraces(input);\n        assertEquals(\"No opening brace found.\", result);\n    }\n\n    @Test\n    public void testMultipleBraces() {\n        String input = \"First {first} and second {second} braces.\";\n        String result = extractStringFromBraces(input);\n        assertEquals(\"{first}\", result);\n    }\n\n    @Test\n    public void testEmptyBraces() {\n        String input = \"This string has empty braces {} and some text.\";\n        String result = extractStringFromBraces(input);\n        assertEquals(\"{}\", result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts the string contained in the first pair of braces `{}` from the input string.\n *\n * @param input The input string from which the braces content will be extracted.\n * @return A substring enclosed within the first pair of braces, or an error message if braces are missing.\n */\npublic static String extractStringFromBraces(String input) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 202, "code_type": "method", "original_language": "c&cpp", "file_path": "RCMS\\334326745eb8419775c4a37cd6094e022768c703\\appendices\\sales and costs and ratings\u00a0 generation\\generateSalesCosts.h", "question_type": "Data processing and transformation", "summary": "Based on the given year and month, returns the number of days in that month", "language_version_list": {"python": {"code_signature": "def get_days_in_month(year: int, month: int) -> int:\n    \"\"\"\n    Returns the number of days in a given month of a specific year.\n\n    This function accounts for leap years when calculating the number of days in February.\n\n    Args:\n        year (int): The year for which to get the number of days in the month. This should be\n                     a valid integer representing a year (e.g., 2024).\n        month (int): The month for which to get the number of days. It should be an integer\n                      between 1 and 12, where 1 corresponds to January and 12 to December.\n\n    Returns:\n        int: The number of days in the specified month of the specified year.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_leap_year_february(self):\n        \"\"\"Test for leap year February.\"\"\"\n        self.assertEqual(get_days_in_month(2024, 2), 29)  # 2024 is a leap year\n\n    def test_non_leap_year_february(self):\n        \"\"\"Test for non-leap year February.\"\"\"\n        self.assertEqual(get_days_in_month(2023, 2), 28)  # 2023 is not a leap year\n\n    def test_month_with_31_days(self):\n        \"\"\"Test for months with 31 days.\"\"\"\n        self.assertEqual(get_days_in_month(2023, 1), 31)  # January has 31 days\n        self.assertEqual(get_days_in_month(2023, 7), 31)  # July has 31 days\n\n    def test_month_with_30_days(self):\n        \"\"\"Test for months with 30 days.\"\"\"\n        self.assertEqual(get_days_in_month(2023, 4), 30)  # April has 30 days\n        self.assertEqual(get_days_in_month(2023, 11), 30) # November has 30 days\n\n    def test_invalid_month(self):\n        \"\"\"Test for invalid months.\"\"\"\n        with self.assertRaises(InvalidMonthError):\n            get_days_in_month(2023, 0)  # Month less than 1\n        with self.assertRaises(InvalidMonthError):\n            get_days_in_month(2023, 13)  # Month greater than 12\n", "prompt": "please write a python function , the function signature as below def get_days_in_month(year: int, month: int) -> int:\n    \"\"\"\n    Returns the number of days in a given month of a specific year.\n\n    This function accounts for leap years when calculating the number of days in February.\n\n    Args:\n        year (int): The year for which to get the number of days in the month. This should be\n                     a valid integer representing a year (e.g., 2024).\n        month (int): The month for which to get the number of days. It should be an integer\n                      between 1 and 12, where 1 corresponds to January and 12 to December.\n\n    Returns:\n        int: The number of days in the specified month of the specified year.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <stdexcept>\n/**\n * @brief Returns the number of days in a given month of a specific year.\n *\n * This function accounts for leap years when calculating the number of days in February.\n *\n * @param year The year for which to get the number of days in the month. This should be\n *             a valid integer representing a year (e.g., 2024).\n * @param month The month for which to get the number of days. It should be an integer\n *              between 1 and 12, where 1 corresponds to January and 12 to December.\n * @return The number of days in the specified month of the specified year.\n *\n */\n int getDaysInMonth(int year, int month){\n }", "test_code": "TEST_CASE(\"Leap year February\", \"[getDaysInMonth]\") {\n    REQUIRE(getDaysInMonth(2024, 2) == 29); // 2024 \u662f\u95f0\u5e74\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 2: \u975e\u95f0\u5e74\u7684\u4e8c\u6708\u4efd\nTEST_CASE(\"Non-leap year February\", \"[getDaysInMonth]\") {\n    REQUIRE(getDaysInMonth(2023, 2) == 28); // 2023 \u4e0d\u662f\u95f0\u5e74\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 3: \u5927\u6708\u4efd\uff0831\u5929\uff09\u7684\u60c5\u51b5\nTEST_CASE(\"Month with 31 days\", \"[getDaysInMonth]\") {\n    REQUIRE(getDaysInMonth(2023, 1) == 31); // \u4e00\u6708\u4efd\u6709 31 \u5929\n    REQUIRE(getDaysInMonth(2023, 7) == 31); // \u4e03\u6708\u4efd\u6709 31 \u5929\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 4: \u5c0f\u6708\u4efd\uff0830\u5929\uff09\u7684\u60c5\u51b5\nTEST_CASE(\"Month with 30 days\", \"[getDaysInMonth]\") {\n    REQUIRE(getDaysInMonth(2023, 4) == 30); // \u56db\u6708\u4efd\u6709 30 \u5929\n    REQUIRE(getDaysInMonth(2023, 11) == 30); // \u5341\u4e00\u6708\u4efd\u6709 30 \u5929\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 5: \u65e0\u6548\u7684\u6708\u4efd\nTEST_CASE(\"Invalid month\", \"[getDaysInMonth]\") {\n    REQUIRE_THROWS_AS(getDaysInMonth(2023, 0), std::invalid_argument);  // \u6708\u4efd\u5c0f\u4e8e 1\n    REQUIRE_THROWS_AS(getDaysInMonth(2023, 13), std::invalid_argument); // \u6708\u4efd\u5927\u4e8e 12\n}", "prompt": "please write a cpp function , the function signature as below #include <stdexcept>\n/**\n * @brief Returns the number of days in a given month of a specific year.\n *\n * This function accounts for leap years when calculating the number of days in February.\n *\n * @param year The year for which to get the number of days in the month. This should be\n *             a valid integer representing a year (e.g., 2024).\n * @param month The month for which to get the number of days. It should be an integer\n *              between 1 and 12, where 1 corresponds to January and 12 to December.\n * @return The number of days in the specified month of the specified year.\n *\n */\n int getDaysInMonth(int year, int month){\n }", "addition_info": ""}, "java": {"code_signature": "/**\n * @brief Returns the number of days in a given month of a specific year.\n *\n * This function accounts for leap years when calculating the number of days in February.\n *\n * @param year The year for which to get the number of days in the month. This should be\n *             a valid integer representing a year (e.g., 2024).\n * @param month The month for which to get the number of days. It should be an integer\n *              between 1 and 12, where 1 corresponds to January and 12 to December.\n * @return The number of days in the specified month of the specified year.\n *\n * @throws IllegalArgumentException if the month is not between 1 and 12.\n */\npublic static int getDaysInMonth(int year, int month) {\n    // Method implementation goes here\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.junit.Assert.assertThrows;\n\npublic class Tester {\n\n    @Test\n    public void testLeapYearFebruary() {\n        assertEquals(29, Answer.getDaysInMonth(2024, 2)); // 2024 is a leap year\n    }\n\n    @Test\n    public void testNonLeapYearFebruary() {\n        assertEquals(28, Answer.getDaysInMonth(2023, 2)); // 2023 is not a leap year\n    }\n\n    @Test\n    public void testMonthWith31Days() {\n        assertEquals(31, Answer.getDaysInMonth(2023, 1)); // January has 31 days\n        assertEquals(31, Answer.getDaysInMonth(2023, 7)); // July has 31 days\n    }\n\n    @Test\n    public void testMonthWith30Days() {\n        assertEquals(30, Answer.getDaysInMonth(2023, 4)); // April has 30 days\n        assertEquals(30, Answer.getDaysInMonth(2023, 11)); // November has 30 days\n    }\n\n    @Test\n    public void testInvalidMonth() {\n        assertThrows(IllegalArgumentException.class, () -> {\n            Answer.getDaysInMonth(2023, 0); // Month less than 1\n        });\n        assertThrows(IllegalArgumentException.class, () -> {\n            Answer.getDaysInMonth(2023, 13); // Month greater than 12\n        });\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * @brief Returns the number of days in a given month of a specific year.\n *\n * This function accounts for leap years when calculating the number of days in February.\n *\n * @param year The year for which to get the number of days in the month. This should be\n *             a valid integer representing a year (e.g., 2024).\n * @param month The month for which to get the number of days. It should be an integer\n *              between 1 and 12, where 1 corresponds to January and 12 to December.\n * @return The number of days in the specified month of the specified year.\n *\n * @throws IllegalArgumentException if the month is not between 1 and 12.\n */\npublic static int getDaysInMonth(int year, int month) {\n    // Method implementation goes here\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 203, "code_type": "method", "original_language": "c&cpp", "file_path": "cp-data-algo\\4806008571d7248f876e185b6973e0f938bd899f\\ds\\ds00_reverse.cpp", "question_type": "Algorithm and data structure", "summary": "Reverse the order of elements in the vectorvwithin the specified range[a, b].", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef reverse_range(v: List[int], a: int, b: int) -> None:\n    \"\"\"\n    Reverse the order of elements in the list v within the specified range [a, b].\n\n    Args:\n        v (List[int]): Reference to the list of integers to be modified.\n        a (int): The starting index of the range to be reversed.\n        b (int): The ending index of the range to be reversed.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_reverse_entire_vector(self):\n        v = [1, 2, 3, 4, 5]\n        reverse_range(v, 0, 4)\n        expected = [5, 4, 3, 2, 1]\n        self.assertEqual(v, expected)\n\n    def test_reverse_subrange_in_the_middle(self):\n        v = [1, 2, 3, 4, 5, 6, 7, 8]\n        reverse_range(v, 2, 5)\n        expected = [1, 2, 6, 5, 4, 3, 7, 8]\n        self.assertEqual(v, expected)\n\n    def test_reverse_single_element_range(self):\n        v = [1, 2, 3, 4, 5]\n        reverse_range(v, 2, 2)\n        expected = [1, 2, 3, 4, 5]\n        self.assertEqual(v, expected)\n\n    def test_reverse_range_with_invalid_indices(self):\n        v = [1, 2, 3, 4, 5]\n        reverse_range(v, -1, 3)  # Invalid start index\n        expected = [1, 2, 3, 4, 5]  # No change\n        self.assertEqual(v, expected)\n\n    def test_reverse_range_at_end_of_vector(self):\n        v = [1, 2, 3, 4, 5, 6]\n        reverse_range(v, 3, 5)\n        expected = [1, 2, 3, 6, 5, 4]\n        self.assertEqual(v, expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef reverse_range(v: List[int], a: int, b: int) -> None:\n    \"\"\"\n    Reverse the order of elements in the list v within the specified range [a, b].\n\n    Args:\n        v (List[int]): Reference to the list of integers to be modified.\n        a (int): The starting index of the range to be reversed.\n        b (int): The ending index of the range to be reversed.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Reverse the order of elements in the vectorvwithin the specified range[a, b].\n *\n * @param v Reference to the vector of integers to be modified.\n * @param a The starting index of the range to be reversed.\n * @param b The ending index of the range to be reversed.\n */\nvoid reverseRange(std::vector<int>& v, int a, int b) {}", "test_code": "TEST_CASE(\"Test reverseRange function\") {\n    SECTION(\"Reverse entire vector\") {\n        std::vector<int> v = {1, 2, 3, 4, 5};\n        reverseRange(v, 0, 4);\n        std::vector<int> expected = {5, 4, 3, 2, 1};\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse subrange in the middle\") {\n        std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8};\n        reverseRange(v, 2, 5);\n        std::vector<int> expected = {1, 2, 6, 5, 4, 3, 7, 8};\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse a single element range\") {\n        std::vector<int> v = {1, 2, 3, 4, 5};\n        reverseRange(v, 2, 2);\n        std::vector<int> expected = {1, 2, 3, 4, 5};\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse range with invalid indices\") {\n        std::vector<int> v = {1, 2, 3, 4, 5};\n        reverseRange(v, -1, 3);  // Invalid start index\n        std::vector<int> expected = {1, 2, 3, 4, 5}; // No change\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse range at the end of the vector\") {\n        std::vector<int> v = {1, 2, 3, 4, 5, 6};\n        reverseRange(v, 3, 5);\n        std::vector<int> expected = {1, 2, 3, 6, 5, 4};\n        REQUIRE(v == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Reverse the order of elements in the vectorvwithin the specified range[a, b].\n *\n * @param v Reference to the vector of integers to be modified.\n * @param a The starting index of the range to be reversed.\n * @param b The ending index of the range to be reversed.\n */\nvoid reverseRange(std::vector<int>& v, int a, int b) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Reverse the order of elements in the list within the specified range [a, b].\n *\n * @param v Reference to the list of integers to be modified.\n * @param a The starting index of the range to be reversed.\n * @param b The ending index of the range to be reversed.\n */\npublic static void reverseRange(List<Integer> v, int a, int b) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testSplitStringRegularSentence() {\n        String input = \"Hello world from Catch2\";\n        List<String> expected = Arrays.asList(\"Hello\", \"world\", \"from\", \"Catch2\");\n        assertEquals(expected, splitString(input));\n    }\n\n    @Test\n    public void testSplitStringMultipleSpaces() {\n        String input = \"Multiple   spaces between words\";\n        List<String> expected = Arrays.asList(\"Multiple\", \"spaces\", \"between\", \"words\");\n        assertEquals(expected, splitString(input));\n    }\n\n    @Test\n    public void testSplitStringSingleWord() {\n        String input = \"Single\";\n        List<String> expected = Arrays.asList(\"Single\");\n        assertEquals(expected, splitString(input));\n    }\n\n    @Test\n    public void testSplitStringEmpty() {\n        String input = \"\";\n        List<String> expected = Arrays.asList();\n        assertEquals(expected, splitString(input));\n    }\n\n    @Test\n    public void testSplitStringLeadingTrailingSpaces() {\n        String input = \"   Leading and trailing spaces   \";\n        List<String> expected = Arrays.asList(\"Leading\", \"and\", \"trailing\", \"spaces\");\n        assertEquals(expected, splitString(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Reverse the order of elements in the list within the specified range [a, b].\n *\n * @param v Reference to the list of integers to be modified.\n * @param a The starting index of the range to be reversed.\n * @param b The ending index of the range to be reversed.\n */\npublic static void reverseRange(List<Integer> v, int a, int b) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 204, "code_type": "method", "original_language": "c&cpp", "file_path": "bagconv\\260d097f17ba53dde36a8e5265b92aebdb78cdb6\\bagconv.cc", "question_type": "Data processing and transformation", "summary": "Split a string into multiple substrings based on spaces and return a vector containing these substrings.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef split_string(s: str) -> List[str]:\n    \"\"\"\n    Split a string into multiple substrings based on spaces and return a list containing these substrings.\n    Args:\n        s (str): The input string to be split into words.\n\n    Returns:\n        List[str]: A list of strings, each representing a word from the input string. Returns an empty list if the input string is empty or contains only spaces.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_split_string_regular_sentence(self):\n        \"\"\"Split a regular sentence.\"\"\"\n        input_str = \"Hello world from Catch2\"\n        expected = [\"Hello\", \"world\", \"from\", \"Catch2\"]\n        self.assertEqual(split_string(input_str), expected)\n\n    def test_handle_multiple_spaces(self):\n        \"\"\"Handle multiple spaces between words.\"\"\"\n        input_str = \"Multiple   spaces between words\"\n        expected = [\"Multiple\", \"spaces\", \"between\", \"words\"]\n        self.assertEqual(split_string(input_str), expected)\n\n    def test_single_word_input(self):\n        \"\"\"Single word input.\"\"\"\n        input_str = \"Single\"\n        expected = [\"Single\"]\n        self.assertEqual(split_string(input_str), expected)\n\n    def test_empty_string_input(self):\n        \"\"\"Empty string input.\"\"\"\n        input_str = \"\"\n        expected = []\n        self.assertEqual(split_string(input_str), expected)\n\n    def test_leading_and_trailing_spaces(self):\n        \"\"\"String with leading and trailing spaces.\"\"\"\n        input_str = \"   Leading and trailing spaces   \"\n        expected = [\"Leading\", \"and\", \"trailing\", \"spaces\"]\n        self.assertEqual(split_string(input_str), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef split_string(s: str) -> List[str]:\n    \"\"\"\n    Split a string into multiple substrings based on spaces and return a list containing these substrings.\n    Args:\n        s (str): The input string to be split into words.\n\n    Returns:\n        List[str]: A list of strings, each representing a word from the input string. Returns an empty list if the input string is empty or contains only spaces.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Split a string into multiple substrings based on spaces and return a vector containing these substrings.\n *\n * @param str The input string to be split into words.\n * @return A vector of strings, each representing a word from the input string. Returns an empty vector if the input string is empty or contains only spaces.\n */\nstd::vector<std::string> splitString(const std::string& str) {}", "test_code": "TEST_CASE(\"splitString function\") {\n\n    SECTION(\"Split a regular sentence\") {\n        std::string input = \"Hello world from Catch2\";\n        std::vector<std::string> expected = {\"Hello\", \"world\", \"from\", \"Catch2\"};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"Handle multiple spaces\") {\n        std::string input = \"Multiple   spaces between words\";\n        std::vector<std::string> expected = {\"Multiple\", \"spaces\", \"between\", \"words\"};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"Single word input\") {\n        std::string input = \"Single\";\n        std::vector<std::string> expected = {\"Single\"};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"Empty string input\") {\n        std::string input = \"\";\n        std::vector<std::string> expected = {};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"String with leading and trailing spaces\") {\n        std::string input = \"   Leading and trailing spaces   \";\n        std::vector<std::string> expected = {\"Leading\", \"and\", \"trailing\", \"spaces\"};\n        REQUIRE(splitString(input) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Split a string into multiple substrings based on spaces and return a vector containing these substrings.\n *\n * @param str The input string to be split into words.\n * @return A vector of strings, each representing a word from the input string. Returns an empty vector if the input string is empty or contains only spaces.\n */\nstd::vector<std::string> splitString(const std::string& str) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Split a string into multiple substrings based on spaces and return a list containing these substrings.\n *\n * @param str The input string to be split into words.\n * @return A list of strings, each representing a word from the input string. Returns an empty list if the input string is empty or contains only spaces.\n */\npublic static List<String> splitString(String str) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testSplitStringRegularSentence() {\n        String input = \"Hello world from Catch2\";\n        List<String> expected = Arrays.asList(\"Hello\", \"world\", \"from\", \"Catch2\");\n        assertEquals(expected, splitString(input));\n    }\n\n    @Test\n    public void testSplitStringMultipleSpaces() {\n        String input = \"Multiple   spaces between words\";\n        List<String> expected = Arrays.asList(\"Multiple\", \"spaces\", \"between\", \"words\");\n        assertEquals(expected, splitString(input));\n    }\n\n    @Test\n    public void testSplitStringSingleWord() {\n        String input = \"Single\";\n        List<String> expected = Arrays.asList(\"Single\");\n        assertEquals(expected, splitString(input));\n    }\n\n    @Test\n    public void testSplitStringEmpty() {\n        String input = \"\";\n        List<String> expected = Arrays.asList();\n        assertEquals(expected, splitString(input));\n    }\n\n    @Test\n    public void testSplitStringLeadingTrailingSpaces() {\n        String input = \"   Leading and trailing spaces   \";\n        List<String> expected = Arrays.asList(\"Leading\", \"and\", \"trailing\", \"spaces\");\n        assertEquals(expected, splitString(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Split a string into multiple substrings based on spaces and return a list containing these substrings.\n *\n * @param str The input string to be split into words.\n * @return A list of strings, each representing a word from the input string. Returns an empty list if the input string is empty or contains only spaces.\n */\npublic static List<String> splitString(String str) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 205, "code_type": "method", "original_language": "c&cpp", "file_path": "bagconv\\260d097f17ba53dde36a8e5265b92aebdb78cdb6\\bagconv.cc", "question_type": "Algorithm and data structure", "summary": "Retrieve the current date and return it as a string in the \"YYYY-MM-DD\" format.", "language_version_list": {"python": {"code_signature": "def get_current_date() -> str:\n    \"\"\"\n    Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n    Returns:\n        str: A string representing the current date in the format \"YYYY-MM-DD\".\n    \"\"\"", "test_code": "import datetime\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_get_current_date_format(self):\n        \"\"\"Correct format YYYY-MM-DD\"\"\"\n        current_date = get_current_date()\n        self.assertEqual(len(current_date), 10)\n        self.assertEqual(current_date[4], '-')\n        self.assertEqual(current_date[7], '-')\n\n    def test_get_current_date_year(self):\n        \"\"\"Returns correct year\"\"\"\n        now = datetime.datetime.now()\n        current_year = now.year\n        current_date = get_current_date()\n        year_part = current_date[:4]  # Get the year part\n        self.assertEqual(int(year_part), current_year)\n\n    def test_get_current_date_month(self):\n        \"\"\"Returns correct month\"\"\"\n        now = datetime.datetime.now()\n        current_month = now.month\n        current_date = get_current_date()\n        month_part = current_date[5:7]  # Get the month part\n        self.assertEqual(int(month_part), current_month)\n\n    def test_get_current_date_day(self):\n        \"\"\"Returns correct day\"\"\"\n        now = datetime.datetime.now()\n        current_day = now.day\n        current_date = get_current_date()\n        day_part = current_date[8:10]  # Get the day part\n        self.assertEqual(int(day_part), current_day)\n\n    def test_get_current_date_consistency(self):\n        \"\"\"Consistency of output within the same second\"\"\"\n        first_call = get_current_date()\n        second_call = get_current_date()\n        self.assertEqual(first_call, second_call)\n", "prompt": "please write a python function , the function signature as below def get_current_date() -> str:\n    \"\"\"\n    Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n    Returns:\n        str: A string representing the current date in the format \"YYYY-MM-DD\".\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n *\n * @return A string representing the current date in the format \"YYYY-MM-DD\".\n */\nstd::string getCurrentDate() {}", "test_code": "TEST_CASE(\"getCurrentDate function\") {\n\n    SECTION(\"Correct format YYYY-MM-DD\") {\n        std::string currentDate = getCurrentDate();\n        REQUIRE(currentDate.length() == 10);\n        REQUIRE(currentDate[4] == '-');\n        REQUIRE(currentDate[7] == '-');\n    }\n\n    SECTION(\"Returns correct year\") {\n        std::time_t t = std::time(nullptr);\n        std::tm* now = std::localtime(&t);\n        int currentYear = now->tm_year + 1900;\n\n        std::string currentDate = getCurrentDate();\n        std::string yearPart = currentDate.substr(0, 4);\n\n        REQUIRE(std::stoi(yearPart) == currentYear);\n    }\n\n    SECTION(\"Returns correct month\") {\n        std::time_t t = std::time(nullptr);\n        std::tm* now = std::localtime(&t);\n        int currentMonth = now->tm_mon + 1;\n\n        std::string currentDate = getCurrentDate();\n        std::string monthPart = currentDate.substr(5, 2);\n\n        REQUIRE(std::stoi(monthPart) == currentMonth);\n    }\n\n    SECTION(\"Returns correct day\") {\n        std::time_t t = std::time(nullptr);\n        std::tm* now = std::localtime(&t);\n        int currentDay = now->tm_mday;\n\n        std::string currentDate = getCurrentDate();\n        std::string dayPart = currentDate.substr(8, 2);\n\n        REQUIRE(std::stoi(dayPart) == currentDay);\n    }\n\n    SECTION(\"Consistency of output within the same second\") {\n        std::string firstCall = getCurrentDate();\n        std::string secondCall = getCurrentDate();\n        REQUIRE(firstCall == secondCall);\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n *\n * @return A string representing the current date in the format \"YYYY-MM-DD\".\n */\nstd::string getCurrentDate() {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 206, "code_type": "method", "original_language": "c&cpp", "file_path": "Duke-ECE-551\\a8f52255e06d04d606aab7af4de5642a6592e5fc\\ece551\\070_circle\\circle.cpp", "question_type": "Algorithm and data structure", "summary": "calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.", "language_version_list": {"python": {"code_signature": "def circle_intersection_area(x1: float, y1: float, r1: float, x2: float, y2: float, r2: float) -> float:\n    \"\"\"\n    Calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n\n    Args:\n        x1 (float): The x-coordinate of the center of the first circle.\n        y1 (float): The y-coordinate of the center of the first circle.\n        r1 (float): The radius of the first circle.\n        x2 (float): The x-coordinate of the center of the second circle.\n        y2 (float): The y-coordinate of the center of the second circle.\n        r2 (float): The radius of the second circle.\n\n    Returns:\n        float: The area of the intersection between the two circles.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_circle_intersection_area(self):\n        tolerance = 1e-5\n\n        # No overlap, circles far apart\n        self.assertAlmostEqual(circle_intersection_area(0.0, 0.0, 3.0, 10.0, 10.0, 3.0), 0.0, delta=tolerance)\n\n        # No overlap, circles just touching\n        self.assertAlmostEqual(circle_intersection_area(0.0, 0.0, 3.0, 6.0, 0.0, 3.0), 0.0, delta=tolerance)\n\n        # One circle inside the other\n        area = circle_intersection_area(0.0, 0.0, 5.0, 2.0, 0.0, 3.0)\n        self.assertAlmostEqual(area, 28.2743, delta=tolerance)  # Area of smaller circle\n\n        # Identical circles, full overlap\n        area = circle_intersection_area(0.0, 0.0, 3.0, 0.0, 0.0, 3.0)\n        self.assertAlmostEqual(area, 28.2743, delta=tolerance)  # Area of one circle\n", "prompt": "please write a python function , the function signature as below def circle_intersection_area(x1: float, y1: float, r1: float, x2: float, y2: float, r2: float) -> float:\n    \"\"\"\n    Calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n\n    Args:\n        x1 (float): The x-coordinate of the center of the first circle.\n        y1 (float): The y-coordinate of the center of the first circle.\n        r1 (float): The radius of the first circle.\n        x2 (float): The x-coordinate of the center of the second circle.\n        y2 (float): The y-coordinate of the center of the second circle.\n        r2 (float): The radius of the second circle.\n\n    Returns:\n        float: The area of the intersection between the two circles.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param x1 The x-coordinate of the center of the first circle.\n * @param y1 The y-coordinate of the center of the first circle.\n * @param r1 The radius of the first circle.\n * @param x2 The x-coordinate of the center of the second circle.\n * @param y2 The y-coordinate of the center of the second circle.\n * @param r2 The radius of the second circle.\n * @return The area of the intersection between the two circles.\n */\ndouble circleIntersectionArea(double x1, double y1, double r1, double x2, double y2, double r2) {}", "test_code": "TEST_CASE(\"Testing circleIntersectionArea function\") {\n    const double tolerance = 1e-5;\n\n    SECTION(\"No overlap, circles far apart\") {\n        REQUIRE(circleIntersectionArea(0.0, 0.0, 3.0, 10.0, 10.0, 3.0) == Approx(0.0).epsilon(tolerance));\n    }\n\n    SECTION(\"No overlap, circles just touching\") {\n        REQUIRE(circleIntersectionArea(0.0, 0.0, 3.0, 6.0, 0.0, 3.0) == Approx(0.0).epsilon(tolerance));\n    }\n\n    SECTION(\"One circle inside the other\") {\n        double area = circleIntersectionArea(0.0, 0.0, 5.0, 2.0, 0.0, 3.0);\n        REQUIRE(area == Approx(28.2743).epsilon(tolerance)); // Area of smaller circle\n    }\n\n    SECTION(\"Identical circles, full overlap\") {\n        double area = circleIntersectionArea(0.0, 0.0, 3.0, 0.0, 0.0, 3.0);\n        REQUIRE(area == Approx(28.2743).epsilon(tolerance)); // Area of one circle\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param x1 The x-coordinate of the center of the first circle.\n * @param y1 The y-coordinate of the center of the first circle.\n * @param r1 The radius of the first circle.\n * @param x2 The x-coordinate of the center of the second circle.\n * @param y2 The y-coordinate of the center of the second circle.\n * @param r2 The radius of the second circle.\n * @return The area of the intersection between the two circles.\n */\ndouble circleIntersectionArea(double x1, double y1, double r1, double x2, double y2, double r2) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param x1 The x-coordinate of the center of the first circle.\n * @param y1 The y-coordinate of the center of the first circle.\n * @param r1 The radius of the first circle.\n * @param x2 The x-coordinate of the center of the second circle.\n * @param y2 The y-coordinate of the center of the second circle.\n * @param r2 The radius of the second circle.\n * @return The area of the intersection between the two circles.\n */\npublic static double circleIntersectionArea(double x1, double y1, double r1, double x2, double y2, double r2) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    private static final double TOLERANCE = 1e-5;\n\n    @Test\n    public void testNoOverlapCirclesFarApart() {\n        assertEquals(0.0, Answer.circleIntersectionArea(0.0, 0.0, 3.0, 10.0, 10.0, 3.0), TOLERANCE);\n    }\n\n    @Test\n    public void testNoOverlapCirclesJustTouching() {\n        assertEquals(0.0, Answer.circleIntersectionArea(0.0, 0.0, 3.0, 6.0, 0.0, 3.0), TOLERANCE);\n    }\n\n    @Test\n    public void testOneCircleInsideTheOther() {\n        double area = Answer.circleIntersectionArea(0.0, 0.0, 5.0, 2.0, 0.0, 3.0);\n        assertEquals(28.2743, area, TOLERANCE); // Area of smaller circle\n    }\n\n    @Test\n    public void testIdenticalCirclesFullOverlap() {\n        double area = Answer.circleIntersectionArea(0.0, 0.0, 3.0, 0.0, 0.0, 3.0);\n        assertEquals(28.2743, area, TOLERANCE); // Area of one circle\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param x1 The x-coordinate of the center of the first circle.\n * @param y1 The y-coordinate of the center of the first circle.\n * @param r1 The radius of the first circle.\n * @param x2 The x-coordinate of the center of the second circle.\n * @param y2 The y-coordinate of the center of the second circle.\n * @param r2 The radius of the second circle.\n * @return The area of the intersection between the two circles.\n */\npublic static double circleIntersectionArea(double x1, double y1, double r1, double x2, double y2, double r2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 207, "code_type": "method", "original_language": "c&cpp", "file_path": "CP_SOLUTION\\c08a2733c31ce5f3104a3d0c54323fde30d7e495\\Codeforces\\Round 903 (Div. 3)\\C_Perfect_Square.cpp", "question_type": "Algorithm and data structure", "summary": "Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef min_changes_to_symmetric(matrix: List[List]) -> int:\n    \"\"\"\n    Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n    Args:\n        matrix (List[List]): A list of lists of characters representing the matrix to be analyzed.\n\n    Returns:\n        int: The minimum number of element changes required to make the matrix symmetric.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    def test_already_symmetric_matrix(self):\n        matrix = [\n            ['a', 'b', 'c'],\n            ['b', 'e', 'f'],\n            ['c', 'f', 'i']\n        ]\n        self.assertEqual(min_changes_to_symmetric(matrix), 0)\n\n    def test_one_change_needed(self):\n        matrix = [\n            ['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['c', 'h', 'i']\n        ]\n        self.assertEqual(min_changes_to_symmetric(matrix), 2)\n\n    def test_all_different_elements(self):\n        matrix = [\n            ['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['g', 'h', 'i']\n        ]\n        self.assertEqual(min_changes_to_symmetric(matrix), 3)\n\n    def test_large_symmetric_matrix(self):\n        matrix = [\n            ['a', 'b', 'c', 'd'],\n            ['b', 'e', 'f', 'g'],\n            ['c', 'f', 'h', 'i'],\n            ['d', 'g', 'i', 'j']\n        ]\n        self.assertEqual(min_changes_to_symmetric(matrix), 0)\n\n    def test_multiple_changes_needed(self):\n        matrix = [\n            ['a', 'x', 'c', 'd'],\n            ['y', 'e', 'f', 'g'],\n            ['z', 'h', 'i', 'j'],\n            ['d', 'g', 'k', 'l']\n        ]\n        self.assertEqual(min_changes_to_symmetric(matrix), 4)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef min_changes_to_symmetric(matrix: List[List]) -> int:\n    \"\"\"\n    Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n    Args:\n        matrix (List[List]): A list of lists of characters representing the matrix to be analyzed.\n\n    Returns:\n        int: The minimum number of element changes required to make the matrix symmetric.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param matrix A reference to a 2D vector of characters representing the matrix to be analyzed.\n * @return The minimum number of element changes required to make the matrix symmetric.\n */\nint minChangesToSymmetric(vector<vector<char>>& matrix) {}", "test_code": "TEST_CASE(\"Testing minChangesToSymmetric function\") {\n\n    SECTION(\"Already Symmetric Matrix\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c'},\n            {'b', 'e', 'f'},\n            {'c', 'f', 'i'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 0);\n    }\n\n    SECTION(\"One Change Needed\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c'},\n            {'d', 'e', 'f'},\n            {'c', 'h', 'i'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 2);\n    }\n\n    SECTION(\"All Different Elements\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c'},\n            {'d', 'e', 'f'},\n            {'g', 'h', 'i'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 3);\n    }\n\n    SECTION(\"Large Symmetric Matrix\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c', 'd'},\n            {'b', 'e', 'f', 'g'},\n            {'c', 'f', 'h', 'i'},\n            {'d', 'g', 'i', 'j'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 0);\n    }\n\n    SECTION(\"Multiple Changes Needed\") {\n        vector<vector<char>> matrix = {\n            {'a', 'x', 'c', 'd'},\n            {'y', 'e', 'f', 'g'},\n            {'z', 'h', 'i', 'j'},\n            {'d', 'g', 'k', 'l'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 4);\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param matrix A reference to a 2D vector of characters representing the matrix to be analyzed.\n * @return The minimum number of element changes required to make the matrix symmetric.\n */\nint minChangesToSymmetric(vector<vector<char>>& matrix) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param matrix A 2D array of characters representing the matrix to be analyzed.\n * @return The minimum number of element changes required to make the matrix symmetric.\n */\n\npublic static int minChangesToSymmetric(char[][] matrix) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testAlreadySymmetricMatrix() {\n        char[][] matrix = {\n            {'a', 'b', 'c'},\n            {'b', 'e', 'f'},\n            {'c', 'f', 'i'}\n        };\n        assertEquals(0, Answer.minChangesToSymmetric(matrix));\n    }\n\n    @Test\n    public void testOneChangeNeeded() {\n        char[][] matrix = {\n            {'a', 'b', 'c'},\n            {'d', 'e', 'f'},\n            {'c', 'h', 'i'}\n        };\n        assertEquals(2, Answer.minChangesToSymmetric(matrix));\n    }\n\n    @Test\n    public void testAllDifferentElements() {\n        char[][] matrix = {\n            {'a', 'b', 'c'},\n            {'d', 'e', 'f'},\n            {'g', 'h', 'i'}\n        };\n        assertEquals(3, Answer.minChangesToSymmetric(matrix));\n    }\n\n    @Test\n    public void testLargeSymmetricMatrix() {\n        char[][] matrix = {\n            {'a', 'b', 'c', 'd'},\n            {'b', 'e', 'f', 'g'},\n            {'c', 'f', 'h', 'i'},\n            {'d', 'g', 'i', 'j'}\n        };\n        assertEquals(0, Answer.minChangesToSymmetric(matrix));\n    }\n\n    @Test\n    public void testMultipleChangesNeeded() {\n        char[][] matrix = {\n            {'a', 'x', 'c', 'd'},\n            {'y', 'e', 'f', 'g'},\n            {'z', 'h', 'i', 'j'},\n            {'d', 'g', 'k', 'l'}\n        };\n        assertEquals(4, Answer.minChangesToSymmetric(matrix));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param matrix A 2D array of characters representing the matrix to be analyzed.\n * @return The minimum number of element changes required to make the matrix symmetric.\n */\n\npublic static int minChangesToSymmetric(char[][] matrix) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 209, "code_type": "class", "original_language": "c&cpp", "file_path": "DS_and_A\\9ebd32a0c8dae3e249dc17fa1def73fb70d34e32\\linked_lists\\singly_linked_list.c", "question_type": "Algorithm and data structure", "summary": "Implement a linked list", "language_version_list": {"python": {"code_signature": "class Node:\n    def __init__(self, value):\n        self.data = value  # Data held by the node\n        self.next = None   # Pointer to the next node in the list\n\n# LinkedList class definition\nclass LinkedList:\n    # Method to add a node at the beginning of the list\n    def insert_at_head(self, value):\n        pass\n\n    # Method to add a node at the end of the list\n    def insert_at_tail(self, value):\n        pass\n\n    # Method to delete a node with a specific value\n    def delete_value(self, value):\n        pass\n\n    # Method to search for a value in the list\n    def search(self, value):\n        pass\n\n    # Method to print all elements in the list\n    def print_list(self):\n        pass", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_insertion_at_head(self):\n        list = LinkedList()\n        list.insertAtHead(10)\n        list.insertAtHead(20)\n        list.insertAtHead(30)\n        # Expected: 30 -> 20 -> 10 -> None\n        self.assertTrue(list.search(10))\n        self.assertTrue(list.search(20))\n        self.assertTrue(list.search(30))\n        self.assertFalse(list.search(40))\n\n    def test_insertion_at_tail(self):\n        list = LinkedList()\n        list.insertAtTail(1)\n        list.insertAtTail(2)\n        list.insertAtTail(3)\n        # Expected: 1 -> 2 -> 3 -> None\n        self.assertTrue(list.search(1))\n        self.assertTrue(list.search(2))\n        self.assertTrue(list.search(3))\n        self.assertFalse(list.search(4))\n\n    def test_deletion_of_elements(self):\n        list = LinkedList()\n        list.insertAtHead(5)\n        list.insertAtHead(10)\n        list.insertAtHead(15)\n        list.deleteValue(10)\n        # Expected: 15 -> 5 -> None\n        self.assertFalse(list.search(10))\n        self.assertTrue(list.search(15))\n        self.assertTrue(list.search(5))\n\n        list.deleteValue(15)\n        # Expected: 5 -> None\n        self.assertFalse(list.search(15))\n        self.assertTrue(list.search(5))\n\n        list.deleteValue(5)\n        # Expected: None\n        self.assertFalse(list.search(5))\n\n    def test_search_functionality(self):\n        list = LinkedList()\n        list.insertAtTail(100)\n        list.insertAtTail(200)\n        list.insertAtTail(300)\n        self.assertTrue(list.search(100))\n        self.assertTrue(list.search(200))\n        self.assertTrue(list.search(300))\n        self.assertFalse(list.search(400))\n\n    def test_edge_case_empty_list(self):\n        list = LinkedList()\n        self.assertFalse(list.search(1))  # Searching in an empty list\n        list.deleteValue(1)  # Deleting from an empty list should not crash\n        # Expected: None (still empty)\n        self.assertEqual(list.printList(), None)  # or whatever the printList function returns for empty\n", "prompt": "please write a python class , the class signature as below class Node:\n    def __init__(self, value):\n        self.data = value  # Data held by the node\n        self.next = None   # Pointer to the next node in the list\n\n# LinkedList class definition\nclass LinkedList:\n    # Method to add a node at the beginning of the list\n    def insert_at_head(self, value):\n        pass\n\n    # Method to add a node at the end of the list\n    def insert_at_tail(self, value):\n        pass\n\n    # Method to delete a node with a specific value\n    def delete_value(self, value):\n        pass\n\n    # Method to search for a value in the list\n    def search(self, value):\n        pass\n\n    # Method to print all elements in the list\n    def print_list(self):\n        pass", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "struct Node {\n    int data;       // Data held by the node\n    Node* next;     // Pointer to the next node in the list\n\n    // Constructor to initialize a new node with given data\n    Node(int value) : data(value), next(nullptr) {}\n};\n\n// LinkedList class definition\nclass LinkedList {\n    // Method to add a node at the beginning of the list\n    void insertAtHead(int value) {\n\n    }\n\n    // Method to add a node at the end of the list\n    void insertAtTail(int value) {\n\n    }\n\n    // Method to delete a node with a specific value\n    void deleteValue(int value) {\n\n    }\n\n    // Method to search for a value in the list\n    bool search(int value) {\n\n    }\n\n    // Method to print all elements in the list\n    void printList() {\n\n    }\n}\n", "test_code": "TEST_CASE(\"LinkedList operations\", \"[LinkedList]\") {\n\n    SECTION(\"Insertion at the head\") {\n        LinkedList list;\n        list.insertAtHead(10);\n        list.insertAtHead(20);\n        list.insertAtHead(30);\n\n        std::ostringstream output;\n        list.printList(); // Expected: 30 -> 20 -> 10 -> nullptr\n        REQUIRE(list.search(10) == true);\n        REQUIRE(list.search(20) == true);\n        REQUIRE(list.search(30) == true);\n        REQUIRE(list.search(40) == false);\n    }\n\n    SECTION(\"Insertion at the tail\") {\n        LinkedList list;\n        list.insertAtTail(1);\n        list.insertAtTail(2);\n        list.insertAtTail(3);\n\n        std::ostringstream output;\n        list.printList(); // Expected: 1 -> 2 -> 3 -> nullptr\n        REQUIRE(list.search(1) == true);\n        REQUIRE(list.search(2) == true);\n        REQUIRE(list.search(3) == true);\n        REQUIRE(list.search(4) == false);\n    }\n\n    SECTION(\"Deletion of elements\") {\n        LinkedList list;\n        list.insertAtHead(5);\n        list.insertAtHead(10);\n        list.insertAtHead(15);\n\n        list.deleteValue(10);\n        std::ostringstream output;\n        list.printList(); // Expected: 15 -> 5 -> nullptr\n        REQUIRE(list.search(10) == false);\n        REQUIRE(list.search(15) == true);\n        REQUIRE(list.search(5) == true);\n\n        list.deleteValue(15);\n        list.printList(); // Expected: 5 -> nullptr\n        REQUIRE(list.search(15) == false);\n        REQUIRE(list.search(5) == true);\n\n        list.deleteValue(5);\n        list.printList(); // Expected: nullptr\n        REQUIRE(list.search(5) == false);\n    }\n\n    SECTION(\"Search functionality\") {\n        LinkedList list;\n        list.insertAtTail(100);\n        list.insertAtTail(200);\n        list.insertAtTail(300);\n\n        REQUIRE(list.search(100) == true);\n        REQUIRE(list.search(200) == true);\n        REQUIRE(list.search(300) == true);\n        REQUIRE(list.search(400) == false);\n    }\n\n    SECTION(\"Edge case: Empty list\") {\n        LinkedList list;\n\n        REQUIRE(list.search(1) == false);  // Searching in an empty list\n        list.deleteValue(1);               // Deleting from an empty list should not crash\n        std::ostringstream output;\n        list.printList();                  // Expected: nullptr (still empty)\n    }\n}", "prompt": "please write a cpp class , the class signature as below struct Node {\n    int data;       // Data held by the node\n    Node* next;     // Pointer to the next node in the list\n\n    // Constructor to initialize a new node with given data\n    Node(int value) : data(value), next(nullptr) {}\n};\n\n// LinkedList class definition\nclass LinkedList {\n    // Method to add a node at the beginning of the list\n    void insertAtHead(int value) {\n\n    }\n\n    // Method to add a node at the end of the list\n    void insertAtTail(int value) {\n\n    }\n\n    // Method to delete a node with a specific value\n    void deleteValue(int value) {\n\n    }\n\n    // Method to search for a value in the list\n    bool search(int value) {\n\n    }\n\n    // Method to print all elements in the list\n    void printList() {\n\n    }\n}\n", "addition_info": "struct Node {\n    int data;       // Data held by the node\n    Node* next;     // Pointer to the next node in the list\n\n    // Constructor to initialize a new node with given data\n    Node(int value) : data(value), next(nullptr) {}\n};\n"}, "java": {"code_signature": "package org.real.temp;\n\npublic class Answer{\n    /**\n * Node structure for the linked list.\n */\nstatic class Node {\n    int data;       // Data held by the node\n    Node next;     // Pointer to the next node in the list\n\n    /**\n     * Constructor to initialize a new node with given data.\n     *\n     * @param value the data value for the node\n     */\n    Node(int value) {\n        this.data = value;\n        this.next = null;\n    }\n}\n/**\n * LinkedList class definition.\n */\nstatic class LinkedList {\n    /**\n     * Method to add a node at the beginning of the list.\n     *\n     * @param value the data value for the new node\n     */\n    void insertAtHead(int value) {\n        // Implementation goes here\n    }\n\n    /**\n     * Method to add a node at the end of the list.\n     *\n     * @param value the data value for the new node\n     */\n    void insertAtTail(int value) {\n        // Implementation goes here\n    }\n\n    /**\n     * Method to delete a node with a specific value.\n     *\n     * @param value the data value of the node to delete\n     */\n    void deleteValue(int value) {\n        // Implementation goes here\n    }\n\n    /**\n     * Method to search for a value in the list.\n     *\n     * @param value the data value to search for\n     * @return true if the value is found, false otherwise\n     */\n    boolean search(int value) {\n        // Implementation goes here\n        return false;\n    }\n\n    /**\n     * Method to print all elements in the list.\n     */\n    void printList() {\n        // Implementation goes here\n    }\n}\n}\n\n\n\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testInsertionAtHead() {\n        LinkedList list = new LinkedList();\n        list.insertAtHead(10);\n        list.insertAtHead(20);\n        list.insertAtHead(30);\n\n        // Expected: 30 -> 20 -> 10 -> null\n        assertTrue(list.search(10));\n        assertTrue(list.search(20));\n        assertTrue(list.search(30));\n        assertFalse(list.search(40));\n    }\n\n    @Test\n    public void testInsertionAtTail() {\n        LinkedList list = new LinkedList();\n        list.insertAtTail(1);\n        list.insertAtTail(2);\n        list.insertAtTail(3);\n\n        // Expected: 1 -> 2 -> 3 -> null\n        assertTrue(list.search(1));\n        assertTrue(list.search(2));\n        assertTrue(list.search(3));\n        assertFalse(list.search(4));\n    }\n\n    @Test\n    public void testDeletionOfElements() {\n        LinkedList list = new LinkedList();\n        list.insertAtHead(5);\n        list.insertAtHead(10);\n        list.insertAtHead(15);\n\n        list.deleteValue(10);\n        // Expected: 15 -> 5 -> null\n        assertFalse(list.search(10));\n        assertTrue(list.search(15));\n        assertTrue(list.search(5));\n\n        list.deleteValue(15);\n        // Expected: 5 -> null\n        assertFalse(list.search(15));\n        assertTrue(list.search(5));\n\n        list.deleteValue(5);\n        // Expected: null\n        assertFalse(list.search(5));\n    }\n\n    @Test\n    public void testSearchFunctionality() {\n        LinkedList list = new LinkedList();\n        list.insertAtTail(100);\n        list.insertAtTail(200);\n        list.insertAtTail(300);\n\n        assertTrue(list.search(100));\n        assertTrue(list.search(200));\n        assertTrue(list.search(300));\n        assertFalse(list.search(400));\n    }\n\n    @Test\n    public void testEdgeCaseEmptyList() {\n        LinkedList list = new LinkedList();\n\n        assertFalse(list.search(1));  // Searching in an empty list\n        list.deleteValue(1);          // Deleting from an empty list should not crash\n        // Expected: still empty\n    }\n}", "prompt": "please write a java class , the function signature as below package org.real.temp;\n\npublic class Answer{\n    /**\n * Node structure for the linked list.\n */\nstatic class Node {\n    int data;       // Data held by the node\n    Node next;     // Pointer to the next node in the list\n\n    /**\n     * Constructor to initialize a new node with given data.\n     *\n     * @param value the data value for the node\n     */\n    Node(int value) {\n        this.data = value;\n        this.next = null;\n    }\n}\n/**\n * LinkedList class definition.\n */\nstatic class LinkedList {\n    /**\n     * Method to add a node at the beginning of the list.\n     *\n     * @param value the data value for the new node\n     */\n    void insertAtHead(int value) {\n        // Implementation goes here\n    }\n\n    /**\n     * Method to add a node at the end of the list.\n     *\n     * @param value the data value for the new node\n     */\n    void insertAtTail(int value) {\n        // Implementation goes here\n    }\n\n    /**\n     * Method to delete a node with a specific value.\n     *\n     * @param value the data value of the node to delete\n     */\n    void deleteValue(int value) {\n        // Implementation goes here\n    }\n\n    /**\n     * Method to search for a value in the list.\n     *\n     * @param value the data value to search for\n     * @return true if the value is found, false otherwise\n     */\n    boolean search(int value) {\n        // Implementation goes here\n        return false;\n    }\n\n    /**\n     * Method to print all elements in the list.\n     */\n    void printList() {\n        // Implementation goes here\n    }\n}\n}\n\n\n\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 210, "code_type": "method", "original_language": "c&cpp", "file_path": "crimes\\8ae66212f64db45501a8f2e9d68d37411bf4ddc4\\tests\\c-sources\\fib.c", "question_type": "Algorithm and data structure", "summary": "Implement the Fibonacci sequence", "language_version_list": {"python": {"code_signature": "def fibonacci_recursive(n: int) -> int:\n    \"\"\"\n    Implement the Fibonacci sequence.\n    Args:\n        n (int): Which Fibonacci number to calculate.\n\n    Returns:\n        int: fibonacci result\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFibonacci(unittest.TestCase):\n    def test_fibonacci_0(self):\n        \"\"\"Test Case 1: Fibonacci of 0 should be 0\"\"\"\n        self.assertEqual(fibonacci_recursive(0), 0)\n\n    def test_fibonacci_1(self):\n        \"\"\"Test Case 2: Fibonacci of 1 should be 1\"\"\"\n        self.assertEqual(fibonacci_recursive(1), 1)\n\n    def test_fibonacci_5(self):\n        \"\"\"Test Case 3: Fibonacci of 5 should be 5\"\"\"\n        self.assertEqual(fibonacci_recursive(5), 5)\n\n    def test_fibonacci_10(self):\n        \"\"\"Test Case 4: Fibonacci of 10 should be 55\"\"\"\n        self.assertEqual(fibonacci_recursive(10), 55)\n\n    def test_fibonacci_20(self):\n        \"\"\"Test Case 5: Fibonacci of 20 should be 6765\"\"\"\n        self.assertEqual(fibonacci_recursive(20), 6765)\n", "prompt": "please write a python function , the function signature as below def fibonacci_recursive(n: int) -> int:\n    \"\"\"\n    Implement the Fibonacci sequence.\n    Args:\n        n (int): Which Fibonacci number to calculate.\n\n    Returns:\n        int: fibonacci result\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Implement the Fibonacci sequence\n *\n * @param n Which Fibonacci number to calculate.\n * @return int\n */\nint fibonacciRecursive(int n) {}", "test_code": "// Test function for iterative, recursive, and memoization Fibonacci\nTEST_CASE(\"Fibonacci sequence\", \"[fibonacci]\") {\n    // Test Case 1: Fibonacci of 0\n    SECTION(\"Fibonacci(0) should be 0\") {\n        REQUIRE(fibonacciRecursive(0) == 0);\n    }\n\n    // Test Case 2: Fibonacci of 1\n    SECTION(\"Fibonacci(1) should be 1\") {\n        REQUIRE(fibonacciRecursive(1) == 1);\n    }\n\n    // Test Case 3: Fibonacci of 5\n    SECTION(\"Fibonacci(5) should be 5\") {\n        REQUIRE(fibonacciRecursive(5) == 5);\n    }\n\n    // Test Case 4: Fibonacci of 10\n    SECTION(\"Fibonacci(10) should be 55\") {\n        REQUIRE(fibonacciRecursive(10) == 55);\n    }\n\n    // Test Case 5: Fibonacci of 20\n    SECTION(\"Fibonacci(20) should be 6765\") {\n        REQUIRE(fibonacciRecursive(20) == 6765);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Implement the Fibonacci sequence\n *\n * @param n Which Fibonacci number to calculate.\n * @return int\n */\nint fibonacciRecursive(int n) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Implement the Fibonacci sequence\n *\n * @param n Which Fibonacci number to calculate.\n * @return int\n */\npublic static int fibonacciRecursive(int n) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    // Test Case 1: Fibonacci of 0\n    @Test\n    public void testFibonacciZero() {\n        assertEquals(0, fibonacciRecursive(0));\n    }\n\n    // Test Case 2: Fibonacci of 1\n    @Test\n    public void testFibonacciOne() {\n        assertEquals(1, fibonacciRecursive(1));\n    }\n\n    // Test Case 3: Fibonacci of 5\n    @Test\n    public void testFibonacciFive() {\n        assertEquals(5, fibonacciRecursive(5));\n    }\n\n    // Test Case 4: Fibonacci of 10\n    @Test\n    public void testFibonacciTen() {\n        assertEquals(55, fibonacciRecursive(10));\n    }\n\n    // Test Case 5: Fibonacci of 20\n    @Test\n    public void testFibonacciTwenty() {\n        assertEquals(6765, fibonacciRecursive(20));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Implement the Fibonacci sequence\n *\n * @param n Which Fibonacci number to calculate.\n * @return int\n */\npublic static int fibonacciRecursive(int n) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 354, "code_type": "method", "original_language": "c&cpp", "file_path": "Raygun\\ff6c4d048ad83867b5397352599c2edcdb49ba5d\\src\\renderer\\math.h", "question_type": "Algorithm and data structure", "summary": "Calculates the Gaussian weight based on the difference in intensity and a color standard deviation. * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))", "language_version_list": {"python": {"code_signature": "def gaussian_weight(intensity_diff: float, sigma_color: float) -> float:\n    \"\"\"\n    Calculate the Gaussian weight based on the difference in intensity and a color standard deviation.\n\n    The Gaussian weight is calculated using the formula:\n    weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))\n\n    Args:\n        intensity_diff (float): The difference in intensity, which is used to compute the weight.\n        sigma_color (float): The standard deviation for the color, affecting the spread of the weight.\n\n    Returns:\n        float: The Gaussian weight.\n    \"\"\"\n", "test_code": "import math\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_zero_intensity_difference(self):\n        # When intensity difference is zero, weight should be 1\n        intensity_diff = 0.0\n        sigma_color = 1.0  # arbitrary sigma value\n        self.assertAlmostEqual(gaussian_weight(intensity_diff, sigma_color), 1.0, delta=0.001)\n\n    def test_positive_intensity_difference(self):\n        # A positive intensity difference with a reasonable sigma\n        intensity_diff = 2.0\n        sigma_color = 2.0\n        expected_weight = math.exp(-(intensity_diff ** 2) / (2 * sigma_color ** 2))\n        self.assertAlmostEqual(gaussian_weight(intensity_diff, sigma_color), expected_weight, delta=0.001)\n\n    def test_negative_intensity_difference(self):\n        # A negative intensity difference should yield the same weight as positive\n        intensity_diff = -2.0\n        sigma_color = 2.0\n        expected_weight = math.exp(-(intensity_diff ** 2) / (2 * sigma_color ** 2))\n        self.assertAlmostEqual(gaussian_weight(intensity_diff, sigma_color), expected_weight, delta=0.001)\n\n    def test_small_sigma_color(self):\n        # Test with a small sigma value\n        intensity_diff = 1.0\n        sigma_color = 0.1\n        expected_weight = math.exp(-(intensity_diff ** 2) / (2 * sigma_color ** 2))\n        self.assertAlmostEqual(gaussian_weight(intensity_diff, sigma_color), expected_weight, delta=0.001)\n\n    def test_large_sigma_color(self):\n        # Test with a large sigma value\n        intensity_diff = 1.0\n        sigma_color = 100.0\n        expected_weight = math.exp(-(intensity_diff ** 2) / (2 * sigma_color ** 2))\n        self.assertAlmostEqual(gaussian_weight(intensity_diff, sigma_color), expected_weight, delta=0.001)\n", "prompt": "please write a python function , the function signature as below def gaussian_weight(intensity_diff: float, sigma_color: float) -> float:\n    \"\"\"\n    Calculate the Gaussian weight based on the difference in intensity and a color standard deviation.\n\n    The Gaussian weight is calculated using the formula:\n    weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))\n\n    Args:\n        intensity_diff (float): The difference in intensity, which is used to compute the weight.\n        sigma_color (float): The standard deviation for the color, affecting the spread of the weight.\n\n    Returns:\n        float: The Gaussian weight.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <cmath> // Include the cmath library for the exp function\n\n/**\n * @brief Calculates the Gaussian weight based on the difference in intensity and a color standard deviation.\n *\n * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))\n *\n * @param intensity_diff The difference in intensity, which is used to compute the weight.\n * @param sigma_color The standard deviation for the color, affecting the spread of the weight.\n * @return The Gaussian weight as a float.\n */\ninline float gaussianWeight(float intensity_diff, float sigma_color) {}", "test_code": "// Test cases for gaussianWeight function\nTEST_CASE(\"Gaussian Weight Calculation Tests\") {\n\n    SECTION(\"Zero Intensity Difference\") {\n        // When intensity difference is zero, weight should be 1\n        float intensity_diff = 0.0f;\n        float sigma_color = 1.0f; // arbitrary sigma value\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(1.0f).epsilon(0.001));\n    }\n\n    SECTION(\"Positive Intensity Difference\") {\n        // A positive intensity difference with a reasonable sigma\n        float intensity_diff = 2.0f;\n        float sigma_color = 2.0f;\n        float expected_weight = exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Negative Intensity Difference\") {\n        // A negative intensity difference should yield the same weight as positive\n        float intensity_diff = -2.0f;\n        float sigma_color = 2.0f;\n        float expected_weight = exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Small Sigma Color\") {\n        // Test with a small sigma value\n        float intensity_diff = 1.0f;\n        float sigma_color = 0.1f;\n        float expected_weight = exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Large Sigma Color\") {\n        // Test with a large sigma value\n        float intensity_diff = 1.0f;\n        float sigma_color = 100.0f;\n        float expected_weight = exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(expected_weight).epsilon(0.001));\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <cmath> // Include the cmath library for the exp function\n\n/**\n * @brief Calculates the Gaussian weight based on the difference in intensity and a color standard deviation.\n *\n * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))\n *\n * @param intensity_diff The difference in intensity, which is used to compute the weight.\n * @param sigma_color The standard deviation for the color, affecting the spread of the weight.\n * @return The Gaussian weight as a float.\n */\ninline float gaussianWeight(float intensity_diff, float sigma_color) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * @brief Calculates the Gaussian weight based on the difference in intensity and a color standard deviation.\n *\n * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))\n *\n * @param intensity_diff The difference in intensity, which is used to compute the weight.\n * @param sigma_color The standard deviation for the color, affecting the spread of the weight.\n * @return The Gaussian weight as a float.\n */\npublic static float gaussianWeight(float intensity_diff, float sigma_color) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testZeroIntensityDifference() {\n        // When intensity difference is zero, weight should be 1\n        float intensity_diff = 0.0f;\n        float sigma_color = 1.0f; // arbitrary sigma value\n        assertEquals(1.0f, Answer.gaussianWeight(intensity_diff, sigma_color), 0.001);\n    }\n\n    @Test\n    public void testPositiveIntensityDifference() {\n        // A positive intensity difference with a reasonable sigma\n        float intensity_diff = 2.0f;\n        float sigma_color = 2.0f;\n        float expected_weight = (float) Math.exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        assertEquals(expected_weight, Answer.gaussianWeight(intensity_diff, sigma_color), 0.001);\n    }\n\n    @Test\n    public void testNegativeIntensityDifference() {\n        // A negative intensity difference should yield the same weight as positive\n        float intensity_diff = -2.0f;\n        float sigma_color = 2.0f;\n        float expected_weight = (float) Math.exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        assertEquals(expected_weight, Answer.gaussianWeight(intensity_diff, sigma_color), 0.001);\n    }\n\n    @Test\n    public void testSmallSigmaColor() {\n        // Test with a small sigma value\n        float intensity_diff = 1.0f;\n        float sigma_color = 0.1f;\n        float expected_weight = (float) Math.exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        assertEquals(expected_weight, Answer.gaussianWeight(intensity_diff, sigma_color), 0.001);\n    }\n\n    @Test\n    public void testLargeSigmaColor() {\n        // Test with a large sigma value\n        float intensity_diff = 1.0f;\n        float sigma_color = 100.0f;\n        float expected_weight = (float) Math.exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        assertEquals(expected_weight, Answer.gaussianWeight(intensity_diff, sigma_color), 0.001);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * @brief Calculates the Gaussian weight based on the difference in intensity and a color standard deviation.\n *\n * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))\n *\n * @param intensity_diff The difference in intensity, which is used to compute the weight.\n * @param sigma_color The standard deviation for the color, affecting the spread of the weight.\n * @return The Gaussian weight as a float.\n */\npublic static float gaussianWeight(float intensity_diff, float sigma_color) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 355, "code_type": "method", "original_language": "c&cpp", "file_path": "Raygun\\ff6c4d048ad83867b5397352599c2edcdb49ba5d\\src\\renderer\\math.h", "question_type": "Algorithm and data structure", "summary": "Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation. * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))", "language_version_list": {"python": {"code_signature": "def spatial_weight(spatial_diff: float, sigma_space: float) -> float:\n    \"\"\"\n    Calculate the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n\n    The spatial weight is calculated using the formula:\n    weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n\n    Args:\n        spatial_diff (float): The difference in spatial coordinates, which is used to compute the weight.\n        sigma_space (float): The standard deviation for spatial distance, affecting the spread of the weight.\n\n    Returns:\n        float: The spatial weight.\n    \"\"\"\n", "test_code": "import math\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_zero_spatial_difference(self):\n        # When spatial difference is zero, weight should be 1\n        spatial_diff = 0.0\n        sigma_space = 1.0  # arbitrary sigma value\n        self.assertAlmostEqual(spatial_weight(spatial_diff, sigma_space), 1.0, delta=0.001)\n\n    def test_positive_spatial_difference(self):\n        # A positive spatial difference with a reasonable sigma\n        spatial_diff = 2.0\n        sigma_space = 2.0\n        expected_weight = math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space))\n        self.assertAlmostEqual(spatial_weight(spatial_diff, sigma_space), expected_weight, delta=0.001)\n\n    def test_negative_spatial_difference(self):\n        # A negative spatial difference should yield the same weight as positive\n        spatial_diff = -2.0\n        sigma_space = 2.0\n        expected_weight = math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space))\n        self.assertAlmostEqual(spatial_weight(spatial_diff, sigma_space), expected_weight, delta=0.001)\n\n    def test_small_sigma_space(self):\n        # Test with a small sigma value\n        spatial_diff = 1.0\n        sigma_space = 0.1\n        expected_weight = math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space))\n        self.assertAlmostEqual(spatial_weight(spatial_diff, sigma_space), expected_weight, delta=0.001)\n\n    def test_large_sigma_space(self):\n        # Test with a large sigma value\n        spatial_diff = 1.0\n        sigma_space = 100.0\n        expected_weight = math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space))\n        self.assertAlmostEqual(spatial_weight(spatial_diff, sigma_space), expected_weight, delta=0.001)\n", "prompt": "please write a python function , the function signature as below def spatial_weight(spatial_diff: float, sigma_space: float) -> float:\n    \"\"\"\n    Calculate the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n\n    The spatial weight is calculated using the formula:\n    weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n\n    Args:\n        spatial_diff (float): The difference in spatial coordinates, which is used to compute the weight.\n        sigma_space (float): The standard deviation for spatial distance, affecting the spread of the weight.\n\n    Returns:\n        float: The spatial weight.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <cmath> // Include cmath for the exp function\n\n/**\n * @brief Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n *\n * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n *\n * @param spatial_diff The difference in spatial coordinates, which is used to compute the weight.\n * @param sigma_space The standard deviation for spatial distance, affecting the spread of the weight.\n * @return The spatial weight as a float.\n *\n */\ninline float spatialWeight(float spatial_diff, float sigma_space) {}", "test_code": "TEST_CASE(\"Spatial Weight Calculation Tests\") {\n\n    SECTION(\"Zero Spatial Difference\") {\n        // When spatial difference is zero, weight should be 1\n        float spatial_diff = 0.0f;\n        float sigma_space = 1.0f; // arbitrary sigma value\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(1.0f).epsilon(0.001));\n    }\n\n    SECTION(\"Positive Spatial Difference\") {\n        // A positive spatial difference with a reasonable sigma\n        float spatial_diff = 2.0f;\n        float sigma_space = 2.0f;\n        float expected_weight = exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Negative Spatial Difference\") {\n        // A negative spatial difference should yield the same weight as positive\n        float spatial_diff = -2.0f;\n        float sigma_space = 2.0f;\n        float expected_weight = exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Small Sigma Space\") {\n        // Test with a small sigma value\n        float spatial_diff = 1.0f;\n        float sigma_space = 0.1f;\n        float expected_weight = exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Large Sigma Space\") {\n        // Test with a large sigma value\n        float spatial_diff = 1.0f;\n        float sigma_space = 100.0f;\n        float expected_weight = exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(expected_weight).epsilon(0.001));\n    }\n\n}", "prompt": "please write a cpp function , the function signature as below #include <cmath> // Include cmath for the exp function\n\n/**\n * @brief Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n *\n * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n *\n * @param spatial_diff The difference in spatial coordinates, which is used to compute the weight.\n * @param sigma_space The standard deviation for spatial distance, affecting the spread of the weight.\n * @return The spatial weight as a float.\n *\n */\ninline float spatialWeight(float spatial_diff, float sigma_space) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n *\n * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n *\n * @param spatial_diff The difference in spatial coordinates, which is used to compute the weight.\n * @param sigma_space The standard deviation for spatial distance, affecting the spread of the weight.\n * @return The spatial weight as a float.\n * @throws IllegalArgumentException if sigma_space is less than or equal to zero.\n */\n\npublic static float spatialWeight(float spatial_diff, float sigma_space) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testZeroSpatialDifference() {\n        // When spatial difference is zero, weight should be 1\n        float spatial_diff = 0.0f;\n        float sigma_space = 1.0f; // arbitrary sigma value\n        assertEquals(1.0f, Answer.spatialWeight(spatial_diff, sigma_space), 0.001);\n    }\n\n    @Test\n    public void testPositiveSpatialDifference() {\n        // A positive spatial difference with a reasonable sigma\n        float spatial_diff = 2.0f;\n        float sigma_space = 2.0f;\n        float expected_weight = (float) Math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        assertEquals(expected_weight, Answer.spatialWeight(spatial_diff, sigma_space), 0.001);\n    }\n\n    @Test\n    public void testNegativeSpatialDifference() {\n        // A negative spatial difference should yield the same weight as positive\n        float spatial_diff = -2.0f;\n        float sigma_space = 2.0f;\n        float expected_weight = (float) Math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        assertEquals(expected_weight, Answer.spatialWeight(spatial_diff, sigma_space), 0.001);\n    }\n\n    @Test\n    public void testSmallSigmaSpace() {\n        // Test with a small sigma value\n        float spatial_diff = 1.0f;\n        float sigma_space = 0.1f;\n        float expected_weight = (float) Math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        assertEquals(expected_weight, Answer.spatialWeight(spatial_diff, sigma_space), 0.001);\n    }\n\n    @Test\n    public void testLargeSigmaSpace() {\n        // Test with a large sigma value\n        float spatial_diff = 1.0f;\n        float sigma_space = 100.0f;\n        float expected_weight = (float) Math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        assertEquals(expected_weight, Answer.spatialWeight(spatial_diff, sigma_space), 0.001);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n *\n * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n *\n * @param spatial_diff The difference in spatial coordinates, which is used to compute the weight.\n * @param sigma_space The standard deviation for spatial distance, affecting the spread of the weight.\n * @return The spatial weight as a float.\n * @throws IllegalArgumentException if sigma_space is less than or equal to zero.\n */\n\npublic static float spatialWeight(float spatial_diff, float sigma_space) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 356, "code_type": "method", "original_language": "c&cpp", "file_path": "EpicPitfall\\d1587187ba41a5b64636bbe4b0de3832145a97d9\\src\\Core\\Rendering\\Renderer.cpp", "question_type": "Algorithm and data structure", "summary": "Implement bubble sort algorithm", "language_version_list": {"python": {"code_signature": "def bubble_sort(arr:list):\n    \"\"\"\n    Implements the Bubble Sort algorithm.\n\n    Args:\n        arr (list): A list of integers to be sorted.\n\n    Returns:\n\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_sorted_array(self):\n        \"\"\"Test Case 1: Sorting an already sorted array\"\"\"\n        arr1 = [1, 2, 3, 4, 5]\n        bubble_sort(arr1)\n        self.assertEqual(arr1, [1, 2, 3, 4, 5])\n\n    def test_reverse_sorted_array(self):\n        \"\"\"Test Case 2: Sorting a reverse sorted array\"\"\"\n        arr2 = [5, 4, 3, 2, 1]\n        bubble_sort(arr2)\n        self.assertEqual(arr2, [1, 2, 3, 4, 5])\n\n    def test_array_with_duplicates(self):\n        \"\"\"Test Case 3: Sorting an array with duplicate elements\"\"\"\n        arr3 = [3, 1, 2, 3, 2]\n        bubble_sort(arr3)\n        self.assertEqual(arr3, [1, 2, 2, 3, 3])\n\n    def test_single_element_array(self):\n        \"\"\"Test Case 4: Sorting an array with a single element\"\"\"\n        arr4 = [1]\n        bubble_sort(arr4)\n        self.assertEqual(arr4, [1])\n\n    def test_empty_array(self):\n        \"\"\"Test Case 5: Sorting an empty array\"\"\"\n        arr5 = []\n        bubble_sort(arr5)\n        self.assertEqual(arr5, [])\n", "prompt": "please write a python function , the function signature as below def bubble_sort(arr:list):\n    \"\"\"\n    Implements the Bubble Sort algorithm.\n\n    Args:\n        arr (list): A list of integers to be sorted.\n\n    Returns:\n\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Implements the Bubble Sort algorithm.\n *\n * @param arr A reference to a vector of integers to be sorted.\n */\nvoid bubbleSort(std::vector<int>& arr) {\n\t\n}", "test_code": "TEST_CASE(\"BubbleSort Test Cases\", \"[bubbleSort]\") {\n    // Test Case 1: Sorting an already sorted array\n    std::vector<int> arr1 = {1, 2, 3, 4, 5};\n    bubbleSort(arr1);\n    REQUIRE(arr1 == std::vector<int>{1, 2, 3, 4, 5});\n\n    // Test Case 2: Sorting a reverse sorted array\n    std::vector<int> arr2 = {5, 4, 3, 2, 1};\n    bubbleSort(arr2);\n    REQUIRE(arr2 == std::vector<int>{1, 2, 3, 4, 5});\n\n    // Test Case 3: Sorting an array with duplicate elements\n    std::vector<int> arr3 = {3, 1, 2, 3, 2};\n    bubbleSort(arr3);\n    REQUIRE(arr3 == std::vector<int>{1, 2, 2, 3, 3});\n\n    // Test Case 4: Sorting an array with a single element\n    std::vector<int> arr4 = {1};\n    bubbleSort(arr4);\n    REQUIRE(arr4 == std::vector<int>{1});\n\n    // Test Case 5: Sorting an empty array\n    std::vector<int> arr5 = {};\n    bubbleSort(arr5);\n    REQUIRE(arr5 == std::vector<int>{});\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Implements the Bubble Sort algorithm.\n *\n * @param arr A reference to a vector of integers to be sorted.\n */\nvoid bubbleSort(std::vector<int>& arr) {\n\t\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Sorts the given list of integers using the Bubble Sort algorithm.\n *\n * @param arr A list of integers to be sorted.\n */\npublic static void bubbleSort(List<Integer> arr) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testBubbleSort() {\n        // Test Case 1: Sorting an already sorted array\n        List<Integer> arr1 = Arrays.asList(1, 2, 3, 4, 5);\n        Answer.bubbleSort(arr1);\n        assertEquals(Arrays.asList(1, 2, 3, 4, 5), arr1);\n\n        // Test Case 2: Sorting a reverse sorted array\n        List<Integer> arr2 = Arrays.asList(5, 4, 3, 2, 1);\n        Answer.bubbleSort(arr2);\n        assertEquals(Arrays.asList(1, 2, 3, 4, 5), arr2);\n\n        // Test Case 3: Sorting an array with duplicate elements\n        List<Integer> arr3 = Arrays.asList(3, 1, 2, 3, 2);\n        Answer.bubbleSort(arr3);\n        assertEquals(Arrays.asList(1, 2, 2, 3, 3), arr3);\n\n        // Test Case 4: Sorting an array with a single element\n        List<Integer> arr4 = Arrays.asList(1);\n        Answer.bubbleSort(arr4);\n        assertEquals(Arrays.asList(1), arr4);\n\n        // Test Case 5: Sorting an empty array\n        List<Integer> arr5 = Arrays.asList();\n        Answer.bubbleSort(arr5);\n        assertEquals(Arrays.asList(), arr5);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Sorts the given list of integers using the Bubble Sort algorithm.\n *\n * @param arr A list of integers to be sorted.\n */\npublic static void bubbleSort(List<Integer> arr) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 357, "code_type": "method", "original_language": "c&cpp", "file_path": "Algorithmen_und_Datenstrukturen\\60a962dd2f20252bbaaf03809bf8cca9be29cbe1\\ex_03\\searches\\main.cpp", "question_type": "Algorithm and data structure", "summary": "Implement hill sort", "language_version_list": {"python": {"code_signature": "def hill_sort(arr:list):\n    \"\"\"\n    Sorts a list of integers using the Hill Sort (Shell Sort) algorithm.\n\n    Args:\n        arr (list of int): A list of integers that will be sorted in-place.\n    \"\"\"\n", "test_code": "import unittest\n\nfrom more_itertools import is_sorted\n\n\nclass Tester(unittest.TestCase):\n    def test_hill_sort(self):\n        # Test case: Sort an already sorted array\n        arr = [1, 2, 3, 4, 5]\n        hill_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n        # Test case: Sort an array in reverse order\n        arr = [5, 4, 3, 2, 1]\n        hill_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n        # Test case: Sort an array with duplicate values\n        arr = [3, 1, 2, 3, 2]\n        hill_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n        # Test case: Sort an array with all identical values\n        arr = [1, 1, 1, 1, 1]\n        hill_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n        # Test case: Sort an empty array\n        arr = []\n        hill_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n        # Test case: Sort an array with one element\n        arr = [42]\n        hill_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n        # Test case: Sort a large random array\n        arr = [3, 7, 2, 5, 1, 4, 6, 0, 9, 8]\n        hill_sort(arr)\n        self.assertTrue(is_sorted(arr))\n", "prompt": "please write a python function , the function signature as below def hill_sort(arr:list):\n    \"\"\"\n    Sorts a list of integers using the Hill Sort (Shell Sort) algorithm.\n\n    Args:\n        arr (list of int): A list of integers that will be sorted in-place.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Sorts a vector of integers using the Hill Sort (Shell Sort) algorithm.\n *\n * @param arr A reference to a vector of integers that will be sorted in-place.\n *\n */\nvoid hillSort(std::vector<int>& arr) {}", "test_code": "// Helper function to check if the array is sorted\nbool isSorted(const std::vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Test cases\nTEST_CASE(\"Hill Sort\") {\n    SECTION(\"Sort an already sorted array\") {\n        std::vector<int> arr = {1, 2, 3, 4, 5};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an array in reverse order\") {\n        std::vector<int> arr = {5, 4, 3, 2, 1};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an array with duplicate values\") {\n        std::vector<int> arr = {3, 1, 2, 3, 2};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an array with all identical values\") {\n        std::vector<int> arr = {1, 1, 1, 1, 1};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an empty array\") {\n        std::vector<int> arr = {};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an array with one element\") {\n        std::vector<int> arr = {42};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort a large random array\") {\n        std::vector<int> arr = {3, 7, 2, 5, 1, 4, 6, 0, 9, 8};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Sorts a vector of integers using the Hill Sort (Shell Sort) algorithm.\n *\n * @param arr A reference to a vector of integers that will be sorted in-place.\n *\n */\nvoid hillSort(std::vector<int>& arr) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Sorts a list of integers using the Hill Sort (Shell Sort) algorithm.\n *\n * @param arr A reference to a list of integers that will be sorted in-place.\n *\n * @return void\n */\npublic static void hillSort(List<Integer> arr) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    // Helper function to check if the array is sorted\n    private boolean isSorted(List<Integer> arr) {\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testHillSort() {\n        // Test case: Sort an already sorted array\n        List<Integer> arr1 = Arrays.asList(1, 2, 3, 4, 5);\n        hillSort(arr1);\n        assertTrue(isSorted(arr1));\n\n        // Test case: Sort an array in reverse order\n        List<Integer> arr2 = Arrays.asList(5, 4, 3, 2, 1);\n        hillSort(arr2);\n        assertTrue(isSorted(arr2));\n\n        // Test case: Sort an array with duplicate values\n        List<Integer> arr3 = Arrays.asList(3, 1, 2, 3, 2);\n        hillSort(arr3);\n        assertTrue(isSorted(arr3));\n\n        // Test case: Sort an array with all identical values\n        List<Integer> arr4 = Arrays.asList(1, 1, 1, 1, 1);\n        hillSort(arr4);\n        assertTrue(isSorted(arr4));\n\n        // Test case: Sort an empty array\n        List<Integer> arr5 = Arrays.asList();\n        hillSort(arr5);\n        assertTrue(isSorted(arr5));\n\n        // Test case: Sort an array with one element\n        List<Integer> arr6 = Arrays.asList(42);\n        hillSort(arr6);\n        assertTrue(isSorted(arr6));\n\n        // Test case: Sort a large random array\n        List<Integer> arr7 = Arrays.asList(3, 7, 2, 5, 1, 4, 6, 0, 9, 8);\n        hillSort(arr7);\n        assertTrue(isSorted(arr7));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Sorts a list of integers using the Hill Sort (Shell Sort) algorithm.\n *\n * @param arr A reference to a list of integers that will be sorted in-place.\n *\n * @return void\n */\npublic static void hillSort(List<Integer> arr) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 358, "code_type": "method", "original_language": "c&cpp", "file_path": "cpp-challenges\\9bd4a353ca153e7eeb3effda1fd866574d044ed4\\cpp-challenges\\1-test-driven-development\\1-test-driven-development.cpp", "question_type": "Algorithm and data structure", "summary": "Sort the string array with the shape of \"name + number\" in ascending order. If the numbers are the same, sort by name in ascending order, and return the sorted array", "language_version_list": {"python": {"code_signature": "from rpds import List\n\n\ndef sort_names(arr: List[str]) -> List[str]:\n    \"\"\"\n    Sort a list of strings with the format \"name + number\" in ascending order.\n\n    If the numbers are the same, the strings are sorted by name in ascending order.\n\n    Args:\n        arr (list of str): A reference to the list of strings to be sorted.\n\n    Returns:\n        list of str: A list of strings sorted according to the rules described above.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    def test_sort_names(self):\n        # Test Case 2: Same numbers, different names\n        arr2 = [\"Alice10\", \"Charlie10\", \"Bob10\"]\n        expected2 = [\"Alice10\", \"Bob10\", \"Charlie10\"]\n        self.assertEqual(sort_names(arr2), expected2)\n\n        # Test Case 3: Mixed case with different names and numbers\n        arr3 = [\"Alice3\", \"Bob2\", \"Charlie3\", \"Bob1\"]\n        expected3 = [\"Bob1\", \"Bob2\", \"Alice3\", \"Charlie3\"]\n        self.assertEqual(sort_names(arr3), expected3)\n\n        # Test Case 4: Single element\n        arr4 = [\"Alice5\"]\n        expected4 = [\"Alice5\"]\n        self.assertEqual(sort_names(arr4), expected4)\n\n        # Test Case 5: Empty array\n        arr5 = []\n        expected5 = []\n        self.assertEqual(sort_names(arr5), expected5)\n", "prompt": "please write a python function , the function signature as below from rpds import List\n\n\ndef sort_names(arr: List[str]) -> List[str]:\n    \"\"\"\n    Sort a list of strings with the format \"name + number\" in ascending order.\n\n    If the numbers are the same, the strings are sorted by name in ascending order.\n\n    Args:\n        arr (list of str): A reference to the list of strings to be sorted.\n\n    Returns:\n        list of str: A list of strings sorted according to the rules described above.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Sort the string array with the shape of \"name + number\" in ascending order. If the numbers are the same, sort by name in ascending order, and return the sorted array\n *\n * @param arr A reference to the vector of strings to be sorted.\n * @return A vector of strings sorted according to the rules described above.\n */\nvector<string> sortNames(vector<string> arr) {\n\t\n}", "test_code": "TEST_CASE(\"sortNames Test Cases\", \"[sortNames]\") {\n    // Test Case 2: Same numbers, different names\n    vector<string> arr2 = {\"Alice10\", \"Charlie10\", \"Bob10\"};\n    vector<string> expected2 = {\"Alice10\", \"Bob10\", \"Charlie10\"};\n    REQUIRE(sortNames(arr2) == expected2);\n\n    // Test Case 3: Mixed case with different names and numbers\n    vector<string> arr3 = {\"Alice3\", \"Bob2\", \"Charlie3\", \"Bob1\"};\n    vector<string> expected3 = {\"Bob1\", \"Bob2\", \"Alice3\", \"Charlie3\"};\n    REQUIRE(sortNames(arr3) == expected3);\n\n    // Test Case 4: Single element\n    vector<string> arr4 = {\"Alice5\"};\n    vector<string> expected4 = {\"Alice5\"};\n    REQUIRE(sortNames(arr4) == expected4);\n\n    // Test Case 5: Empty array\n    vector<string> arr5 = {};\n    vector<string> expected5 = {};\n    REQUIRE(sortNames(arr5) == expected5);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Sort the string array with the shape of \"name + number\" in ascending order. If the numbers are the same, sort by name in ascending order, and return the sorted array\n *\n * @param arr A reference to the vector of strings to be sorted.\n * @return A vector of strings sorted according to the rules described above.\n */\nvector<string> sortNames(vector<string> arr) {\n\t\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Sort the string array with the shape of \"name + number\" in ascending order.\n * If the numbers are the same, sort by name in ascending order, and return the sorted array.\n *\n * @param arr An array of strings to be sorted.\n * @return An array of strings sorted according to the rules described above.\n */\npublic static String[] sortNames(String[] arr) {}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\n\npublic class Tester {\n\n    @Test\n    public void testSortNames() {\n        // Test Case 2: Same numbers, different names\n        String[] arr2 = {\"Alice10\", \"Charlie10\", \"Bob10\"};\n        String[] expected2 = {\"Alice10\", \"Bob10\", \"Charlie10\"};\n        assertArrayEquals(expected2, Answer.sortNames(arr2));\n\n        // Test Case 3: Mixed case with different names and numbers\n        String[] arr3 = {\"Alice3\", \"Bob2\", \"Charlie3\", \"Bob1\"};\n        String[] expected3 = {\"Bob1\", \"Bob2\", \"Alice3\", \"Charlie3\"};\n        assertArrayEquals(expected3, Answer.sortNames(arr3));\n\n        // Test Case 4: Single element\n        String[] arr4 = {\"Alice5\"};\n        String[] expected4 = {\"Alice5\"};\n        assertArrayEquals(expected4, Answer.sortNames(arr4));\n\n        // Test Case 5: Empty array\n        String[] arr5 = {};\n        String[] expected5 = {};\n        assertArrayEquals(expected5, Answer.sortNames(arr5));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Sort the string array with the shape of \"name + number\" in ascending order.\n * If the numbers are the same, sort by name in ascending order, and return the sorted array.\n *\n * @param arr An array of strings to be sorted.\n * @return An array of strings sorted according to the rules described above.\n */\npublic static String[] sortNames(String[] arr) {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 359, "code_type": "method", "original_language": "c&cpp", "file_path": "parallel_repo\\527b162e693205f7bd7c8a680113cc71eb49d984\\r3\\code\\hello_integrators\\hello_trapezoidal.cpp", "question_type": "Algorithm and data structure", "summary": "Calculate the integral approximation of a given function on a given interval [a,b] using the trapezoidal rule of numerical integration", "language_version_list": {"python": {"code_signature": "def trapezoidal_rule(func, a: float, b: float, n: int) -> float:\n    \"\"\"\n    Calculate the integral approximation of a given function on the interval [a, b] using the trapezoidal rule.\n\n    Args:\n        func (callable): The function to integrate, which takes a float and returns a float.\n        a (float): The lower bound of the integration interval.\n        b (float): The upper bound of the integration interval.\n        n (int): The number of subintervals to use in the approximation (more intervals yield higher accuracy).\n\n    Returns:\n        float: The approximate value of the integral over the interval [a, b].\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    def test_constant_function(self):\n        \"\"\" Test Case 1: Integration of a constant function (f(x) = 1) over [0, 1] \"\"\"\n        self.assertAlmostEqual(trapezoidal_rule(lambda x: 1.0, 0.0, 1.0, 100), 1.0, delta=1e-6)\n\n    def test_linear_function(self):\n        \"\"\" Test Case 2: Integration of a linear function (f(x) = x) over [0, 1] \"\"\"\n        self.assertAlmostEqual(trapezoidal_rule(lambda x: x, 0.0, 1.0, 100), 0.5, delta=1e-6)\n\n    def test_quadratic_function(self):\n        \"\"\" Test Case 3: Integration of a quadratic function (f(x) = x^2) over [0, 1] \"\"\"\n        self.assertAlmostEqual(trapezoidal_rule(lambda x: x * x, 0.0, 1.0, 1000), 1.0 / 3.0, delta=1e-6)\n\n    def test_sine_function(self):\n        \"\"\" Test Case 4: Integration of the sine function (f(x) = sin(x)) over [0, \u03c0] \"\"\"\n        self.assertAlmostEqual(trapezoidal_rule(lambda x: math.sin(x), 0.0, math.pi, 1000), 2.0, delta=1e-6)\n\n    def test_exponential_function(self):\n        \"\"\" Test Case 5: Integration of an exponential function (f(x) = exp(x)) over [0, 1] \"\"\"\n        self.assertAlmostEqual(trapezoidal_rule(lambda x: math.exp(x), 0.0, 1.0, 1000), math.exp(1.0) - 1.0, delta=1e-6)\n", "prompt": "please write a python function , the function signature as below def trapezoidal_rule(func, a: float, b: float, n: int) -> float:\n    \"\"\"\n    Calculate the integral approximation of a given function on the interval [a, b] using the trapezoidal rule.\n\n    Args:\n        func (callable): The function to integrate, which takes a float and returns a float.\n        a (float): The lower bound of the integration interval.\n        b (float): The upper bound of the integration interval.\n        n (int): The number of subintervals to use in the approximation (more intervals yield higher accuracy).\n\n    Returns:\n        float: The approximate value of the integral over the interval [a, b].\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the integral approximation of a given function on a given interval [a,b] using the trapezoidal rule of numerical integration\n *\n * @param func The function to integrate, represented as a std::function<double(double)>.\n * @param a The lower bound of the integration interval.\n * @param b The upper bound of the integration interval.\n * @param n The number of subintervals to use in the approximation (more intervals yield higher accuracy).\n * @return The approximate value of the integral over the interval [a, b].\n */\ndouble trapezoidal_rule(const std::function<double(double)>& func, double a, double b, int n) {\n\t\n}", "test_code": "TEST_CASE(\"TrapezoidalRule Test Cases\", \"[trapezoidal_rule]\") {\n    // Test Case 1: Integration of a constant function (f(x) = 1) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return 1.0; }, 0.0, 1.0, 100) == Approx(1.0).epsilon(1e-6));\n\n    // Test Case 2: Integration of a linear function (f(x) = x) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return x; }, 0.0, 1.0, 100) == Approx(0.5).epsilon(1e-6));\n\n    // Test Case 3: Integration of a quadratic function (f(x) = x^2) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return x * x; }, 0.0, 1.0, 1000) == Approx(1.0 / 3.0).epsilon(1e-6));\n\n    // Test Case 4: Integration of the sine function (f(x) = sin(x)) over [0, \u03c0]\n    REQUIRE(trapezoidal_rule([](double x) { return std::sin(x); }, 0.0, M_PI, 1000) == Approx(2.0).epsilon(1e-6));\n\n    // Test Case 5: Integration of an exponential function (f(x) = exp(x)) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return std::exp(x); }, 0.0, 1.0, 1000) == Approx(std::exp(1.0) - 1.0).epsilon(1e-6));\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the integral approximation of a given function on a given interval [a,b] using the trapezoidal rule of numerical integration\n *\n * @param func The function to integrate, represented as a std::function<double(double)>.\n * @param a The lower bound of the integration interval.\n * @param b The upper bound of the integration interval.\n * @param n The number of subintervals to use in the approximation (more intervals yield higher accuracy).\n * @return The approximate value of the integral over the interval [a, b].\n */\ndouble trapezoidal_rule(const std::function<double(double)>& func, double a, double b, int n) {\n\t\n}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 360, "code_type": "method", "original_language": "c&cpp", "file_path": "GraST\\524b8e82169dedbefd0646cb56f1e26d434cfb68\\src\\Utility.cc", "question_type": "Data processing and transformation", "summary": "Extracts the last part of a complete file path with the help of a path separator and returns it, or the original string if no separator is found", "language_version_list": {"python": {"code_signature": "def get_last_part_of_filepath(file_path: str) -> str:\n    \"\"\"\n    Extract the last part of a complete file path using a separator.\n\n    If no separator is found, the original string is returned.\n\n    Args:\n        file_path (str): The complete file path as a string.\n\n    Returns:\n        str: The last part of the file path after the last separator, or the original string if no separator is found.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    def test_get_last_part_of_filepath(self):\n        # Test Case 1: Unix-style path with '/'\n        self.assertEqual(get_last_part_of_filepath(\"/home/user/documents/file.txt\"), \"file.txt\")\n\n        # Test Case 2: Windows-style path with '\\\\'\n        self.assertEqual(get_last_part_of_filepath(\"C:\\\\Users\\\\JohnDoe\\\\Documents\\\\file.txt\"), \"file.txt\")\n\n        # Test Case 3: Path without any separators (should return the original string)\n        self.assertEqual(get_last_part_of_filepath(\"file.txt\"), \"file.txt\")\n\n        # Test Case 4: Path ending with a separator (should return an empty string)\n        self.assertEqual(get_last_part_of_filepath(\"/home/user/documents/\"), \"\")\n\n        # Test Case 5: Path with mixed separators (should return the last part after the last separator)\n        self.assertEqual(get_last_part_of_filepath(\"C:/Users\\\\JohnDoe/Documents/file.txt\"), \"file.txt\")\n", "prompt": "please write a python function , the function signature as below def get_last_part_of_filepath(file_path: str) -> str:\n    \"\"\"\n    Extract the last part of a complete file path using a separator.\n\n    If no separator is found, the original string is returned.\n\n    Args:\n        file_path (str): The complete file path as a string.\n\n    Returns:\n        str: The last part of the file path after the last separator, or the original string if no separator is found.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extracts the last part of a complete file path with the help of a separator and returns it, or the original string if no separator is found\n *\n * @param filePath The complete file path as a string.\n * @return The last part of the file path after the last separator, or the original string if no separator is found.\n */\nstd::string getLastPartOfFilepath(const std::string& filePath) {\n\t\n}", "test_code": "TEST_CASE(\"getLastPartOfFilepath Test Cases\", \"[getLastPartOfFilepath]\") {\n    // Test Case 1: Unix-style path with '/'\n    REQUIRE(getLastPartOfFilepath(\"/home/user/documents/file.txt\") == \"file.txt\");\n\n    // Test Case 2: Windows-style path with '\\\\'\n    REQUIRE(getLastPartOfFilepath(\"C:\\\\Users\\\\JohnDoe\\\\Documents\\\\file.txt\") == \"file.txt\");\n\n    // Test Case 3: Path without any separators (should return the original string)\n    REQUIRE(getLastPartOfFilepath(\"file.txt\") == \"file.txt\");\n\n    // Test Case 4: Path ending with a separator (should return an empty string)\n    REQUIRE(getLastPartOfFilepath(\"/home/user/documents/\") == \"\");\n\n    // Test Case 5: Path with mixed separators (should return the last part after the last separator)\n    REQUIRE(getLastPartOfFilepath(\"C:/Users\\\\JohnDoe/Documents/file.txt\") == \"file.txt\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts the last part of a complete file path with the help of a separator and returns it, or the original string if no separator is found\n *\n * @param filePath The complete file path as a string.\n * @return The last part of the file path after the last separator, or the original string if no separator is found.\n */\nstd::string getLastPartOfFilepath(const std::string& filePath) {\n\t\n}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 361, "code_type": "method", "original_language": "c&cpp", "file_path": "parallel_repo\\527b162e693205f7bd7c8a680113cc71eb49d984\\r3\\code\\hello_integrators\\hello_simpson.cpp", "question_type": "Scientific computation and numerical analysis", "summary": "Computes the approximate integral of a function using Simpson's Rule.", "language_version_list": {"python": {"code_signature": "def simpsons_rule(a: float, b: float, n: int) -> float:\n    \"\"\"\n    Computes the approximate integral of a function using Simpson's Rule.\n\n    Simpson's Rule is a method for numerical integration that approximates the integral of a function\n    over an interval by fitting parabolas. This function divides the interval [a, b] into n subintervals\n    and calculates the weighted sum of the function values at specific points.\n\n    Args:\n        a (float): The lower limit of integration.\n        b (float): The upper limit of integration.\n        n (int): The number of subintervals (must be even).\n\n    Returns:\n        float: The approximate value of the integral.\n\n    Raises:\n        ValueError: If n is not positive or if it is not even.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    \"\"\"Tests for Simpson's Rule implementation.\"\"\"\n\n    def test_basic_integral_0_to_1(self):\n        \"\"\"Test the integral of f(x) = x^2 from 0 to 1.\"\"\"\n        # The exact integral of f(x) = x^2 from 0 to 1 is 1/3\n        result = simpsons_rule(0.0, 1.0, 10)\n        self.assertAlmostEqual(result, 1.0 / 3.0, delta=0.01)\n\n    def test_basic_integral_0_to_2(self):\n        \"\"\"Test the integral of f(x) = x^2 from 0 to 2.\"\"\"\n        # The exact integral of f(x) = x^2 from 0 to 2 is 8/3\n        result = simpsons_rule(0.0, 2.0, 10)\n        self.assertAlmostEqual(result, 8.0 / 3.0, delta=0.01)\n\n    def test_negative_integral_minus1_to_0(self):\n        \"\"\"Test the integral of f(x) = x^2 from -1 to 0.\"\"\"\n        # The exact integral of f(x) = x^2 from -1 to 0 is 1/3\n        result = simpsons_rule(-1.0, 0.0, 10)\n        self.assertAlmostEqual(result, 1.0 / 3.0, delta=0.01)\n\n    def test_large_interval_0_to_10(self):\n        \"\"\"Test the integral of f(x) = x^2 from 0 to 10.\"\"\"\n        # The exact integral from 0 to 10 of f(x) = x^2 is (10^3)/3 = 1000/3\n        result = simpsons_rule(0.0, 10.0, 20)\n        self.assertAlmostEqual(result, 1000.0 / 3.0, delta=0.01)\n", "prompt": "please write a python function , the function signature as below def simpsons_rule(a: float, b: float, n: int) -> float:\n    \"\"\"\n    Computes the approximate integral of a function using Simpson's Rule.\n\n    Simpson's Rule is a method for numerical integration that approximates the integral of a function\n    over an interval by fitting parabolas. This function divides the interval [a, b] into n subintervals\n    and calculates the weighted sum of the function values at specific points.\n\n    Args:\n        a (float): The lower limit of integration.\n        b (float): The upper limit of integration.\n        n (int): The number of subintervals (must be even).\n\n    Returns:\n        float: The approximate value of the integral.\n\n    Raises:\n        ValueError: If n is not positive or if it is not even.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <stdexcept> // For std::invalid_argument\n/**\n * @brief Computes the approximate integral of a function using Simpson's Rule.\n *\n * Simpson's Rule is a method for numerical integration that approximates the integral of a function\n * over an interval by fitting parabolas. This function divides the interval [a, b] into n subintervals\n * and calculates the weighted sum of the function values at specific points.\n *\n * @param a The lower limit of integration.\n * @param b The upper limit of integration.\n * @param n The number of subintervals (must be even).\n * @return The approximate value of the integral.\n *\n * @throws std::invalid_argument If n is not positive or if it is not even.\n */\ndouble simpsons_rule(double a, double b, int n) {}", "test_code": "TEST_CASE(\"Simpson's Rule Tests\") {\n\n    SECTION(\"Basic Integral of x^2 from 0 to 1\") {\n        // The exact integral of f(x) = x^2 from 0 to 1 is 1/3\n        double result = simpsons_rule(0.0, 1.0, 10);\n        REQUIRE(result == Approx(1.0 / 3.0).epsilon(0.01));\n    }\n\n    SECTION(\"Basic Integral of x^2 from 0 to 2\") {\n        // The exact integral of f(x) = x^2 from 0 to 2 is 8/3\n        double result = simpsons_rule(0.0, 2.0, 10);\n        REQUIRE(result == Approx(8.0 / 3.0).epsilon(0.01));\n    }\n\n    SECTION(\"Negative Integral of x^2 from -1 to 0\") {\n        // The exact integral of f(x) = x^2 from -1 to 0 is 1/3\n        double result = simpsons_rule(-1.0, 0.0, 10);\n        REQUIRE(result == Approx(1.0 / 3.0).epsilon(0.01));\n    }\n\n    SECTION(\"Large Interval\") {\n        // Test with a larger interval from 0 to 10\n        double result = simpsons_rule(0.0, 10.0, 20);\n        // The exact integral from 0 to 10 of f(x) = x^2 is (10^3)/3 = 1000/3\n        REQUIRE(result == Approx(1000.0 / 3.0).epsilon(0.01));\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <stdexcept> // For std::invalid_argument\n/**\n * @brief Computes the approximate integral of a function using Simpson's Rule.\n *\n * Simpson's Rule is a method for numerical integration that approximates the integral of a function\n * over an interval by fitting parabolas. This function divides the interval [a, b] into n subintervals\n * and calculates the weighted sum of the function values at specific points.\n *\n * @param a The lower limit of integration.\n * @param b The upper limit of integration.\n * @param n The number of subintervals (must be even).\n * @return The approximate value of the integral.\n *\n * @throws std::invalid_argument If n is not positive or if it is not even.\n */\ndouble simpsons_rule(double a, double b, int n) {}", "addition_info": "double f(double x) {\n    return x * x;\n}"}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 365, "code_type": "method", "original_language": "c&cpp", "file_path": "c-armyknife-lib\\5b1e037ea7625bf56f84c709e54089b33637d16b\\examples\\travel-mixed.c\n", "question_type": "Data processing and transformation", "summary": "calculate the day of the week the given date (year, month, day) is (Monday is represented by 1, Tuesday is represented by 2, and so on)\n", "language_version_list": {"python": {"code_signature": "def day_of_week(year: int, month: int, day: int) -> int:\n    \"\"\"\n    Calculates the day of the week for a given date.\n\n    Args:\n        year (int): The year of the date (e.g., 2024).\n        month (int): The month of the date (1 = January, 2 = February, ..., 12 = December).\n        day (int): The day of the month (1 to 31, depending on the month).\n\n    Returns:\n        int: An integer representing the day of the week:\n            - 1 for Monday\n            - 2 for Tuesday\n            - 3 for Wednesday\n            - 4 for Thursday\n            - 5 for Friday\n            - 6 for Saturday\n            - 7 for Sunday\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    \"\"\"Unit tests for the day_of_week function.\"\"\"\n\n    def test_day_of_week_calculation(self):\n        \"\"\"Test cases for day_of_week function.\"\"\"\n        self.assertEqual(day_of_week(2024, 1, 1), 1)  # January 1, 2024 is a Monday\n        self.assertEqual(day_of_week(2023, 8, 29), 2)  # August 29, 2023 is a Tuesday\n        self.assertEqual(day_of_week(2022, 12, 25), 7) # December 25, 2022 is a Sunday\n        self.assertEqual(day_of_week(1989, 11, 9), 4)  # November 9, 1989 is a Thursday\n        self.assertEqual(day_of_week(2000, 2, 29), 2)  # February 29, 2000 is a Tuesday", "prompt": "please write a python function , the function signature as below def day_of_week(year: int, month: int, day: int) -> int:\n    \"\"\"\n    Calculates the day of the week for a given date.\n\n    Args:\n        year (int): The year of the date (e.g., 2024).\n        month (int): The month of the date (1 = January, 2 = February, ..., 12 = December).\n        day (int): The day of the month (1 to 31, depending on the month).\n\n    Returns:\n        int: An integer representing the day of the week:\n            - 1 for Monday\n            - 2 for Tuesday\n            - 3 for Wednesday\n            - 4 for Thursday\n            - 5 for Friday\n            - 6 for Saturday\n            - 7 for Sunday\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculates the day of the week for a given date.\n *\n * @param year The year of the date (e.g., 2024).\n * @param month The month of the date (1 = January, 2 = February, ..., 12 = December).\n * @param day The day of the month (1 to 31, depending on the month).\n * \n * @return An integer representing the day of the week:\n *         - 1 for Monday\n *         - 2 for Tuesday\n *         - 3 for Wednesday\n *         - 4 for Thursday\n *         - 5 for Friday\n *         - 6 for Saturday\n *         - 7 for Sunday\n */\nint day_of_week(int year, int month, int day) {}", "test_code": "TEST_CASE(\"Day of Week Calculation\", \"[day_of_week]\") {\n    REQUIRE(day_of_week(2024, 1, 1) == 1);  // January 1, 2024 is a Monday\n    REQUIRE(day_of_week(2023, 8, 29) == 2);  // August 29, 2023 is a Tuesday\n    REQUIRE(day_of_week(2022, 12, 25) == 7); // December 25, 2022 is a Sunday\n    REQUIRE(day_of_week(1989, 11, 9) == 4);  // November 9, 1989 is a Thursday\n    REQUIRE(day_of_week(2000, 2, 29) == 2);  // February 29, 2000 is a Tuesday\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculates the day of the week for a given date.\n *\n * @param year The year of the date (e.g., 2024).\n * @param month The month of the date (1 = January, 2 = February, ..., 12 = December).\n * @param day The day of the month (1 to 31, depending on the month).\n * \n * @return An integer representing the day of the week:\n *         - 1 for Monday\n *         - 2 for Tuesday\n *         - 3 for Wednesday\n *         - 4 for Thursday\n *         - 5 for Friday\n *         - 6 for Saturday\n *         - 7 for Sunday\n */\nint day_of_week(int year, int month, int day) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the day of the week for a given date.\n *\n * @param year The year of the date (e.g., 2024).\n * @param month The month of the date (1 = January, 2 = February, ..., 12 = December).\n * @param day The day of the month (1 to 31, depending on the month).\n * \n * @return An integer representing the day of the week:\n *         - 1 for Monday\n *         - 2 for Tuesday\n *         - 3 for Wednesday\n *         - 4 for Thursday\n *         - 5 for Friday\n *         - 6 for Saturday\n *         - 7 for Sunday\n */\npublic static int dayOfWeek(int year, int month, int day) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testDayOfWeekCalculation() {\n        // January 1, 2024 is a Monday\n        assertEquals(1, Answer.dayOfWeek(2024, 1, 1));\n        \n        // August 29, 2023 is a Tuesday\n        assertEquals(2, Answer.dayOfWeek(2023, 8, 29));\n        \n        // December 25, 2022 is a Sunday\n        assertEquals(7, Answer.dayOfWeek(2022, 12, 25));\n        \n        // November 9, 1989 is a Thursday\n        assertEquals(4, Answer.dayOfWeek(1989, 11, 9));\n        \n        // February 29, 2000 is a Tuesday\n        assertEquals(2, Answer.dayOfWeek(2000, 2, 29));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the day of the week for a given date.\n *\n * @param year The year of the date (e.g., 2024).\n * @param month The month of the date (1 = January, 2 = February, ..., 12 = December).\n * @param day The day of the month (1 to 31, depending on the month).\n * \n * @return An integer representing the day of the week:\n *         - 1 for Monday\n *         - 2 for Tuesday\n *         - 3 for Wednesday\n *         - 4 for Thursday\n *         - 5 for Friday\n *         - 6 for Saturday\n *         - 7 for Sunday\n */\npublic static int dayOfWeek(int year, int month, int day) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 481, "code_type": "method", "original_language": "c&cpp", "file_path": "Cursos-DIO\\0fe8eb13955636e6d31750db30554fc94f48eef1\\ChatGPT Jogo da velha.cpp\n", "question_type": "User interface", "summary": "Prints a 3x3 game board to the console.", "language_version_list": {"python": {"code_signature": "def print_board(board):\n    \"\"\"Prints a 3x3 game board to the console.\n\n    This function takes a 2D list representing a game board and prints\n    it in a formatted manner, displaying the contents of each cell.\n    The board is assumed to be a square of size 3x3, and each cell can\n    contain either a character representing a player's move ('X' or 'O')\n    or an empty space (' ').\n\n    The output format includes a row of dashes to separate the rows of\n    the board, and each cell is enclosed within vertical bars.\n    The function does not return any value.\n\n    Args:\n        board (list[list[str]]): A 2D list of characters, where each character represents\n                                  the state of a cell in the game board. The board must be\n                                  of size 3x3, and each character can be 'X', 'O', or ' '.\n                                  For example:\n                                  input: [['X', 'O', 'X'],\n                                          [' ', 'X', 'O'],\n                                          ['O', ' ', ' ']]\n                                  output: -------------\n                                          | X | O | X |\n                                          -------------\n                                          |   | X | O |\n                                          -------------\n                                          | O |   |   |\n                                          -------------\n    \"\"\"", "test_code": "import io\nimport sys\nimport unittest\n\n\nclass TestPrintBoard(unittest.TestCase):\n    def setUp(self):\n        # Prepare the board data for the test cases\n        self.board1 = [['X', 'O', 'X'], [' ', 'X', 'O'], ['O', ' ', ' ']]\n        self.board2 = [[' ', ' ', ' '], [' ', ' ', ' '], [' ', ' ', ' ']]\n        self.board3 = [['X', 'X', 'X'], ['O', 'O', ' '], [' ', ' ', ' ']]\n        self.board4 = [['O', 'O', 'O'], ['X', 'X', 'X'], ['X', 'O', ' ']]\n        self.board5 = [['X', ' ', ' '], [' ', 'X', ' '], [' ', ' ', 'X']]\n        self.board6 = [[' ', 'O', ' '], ['O', ' ', 'O'], [' ', 'O', ' ']]\n\n    def test_case_1(self):\n        expected_output = (\"-------------\\n\"\n                           \"| X | O | X | \\n\"\n                           \"-------------\\n\"\n                           \"|   | X | O | \\n\"\n                           \"-------------\\n\"\n                           \"| O |   |   | \\n\"\n                           \"-------------\\n\")\n        output = self._capture_print_output(print_board, self.board1)\n        self.assertEqual(output, expected_output)\n\n    def test_case_2(self):\n        expected_output = (\"-------------\\n\"\n                           \"|   |   |   | \\n\"\n                           \"-------------\\n\"\n                           \"|   |   |   | \\n\"\n                           \"-------------\\n\"\n                           \"|   |   |   | \\n\"\n                           \"-------------\\n\")\n        output = self._capture_print_output(print_board, self.board2)\n        self.assertEqual(output, expected_output)\n\n    def test_case_3(self):\n        expected_output = (\"-------------\\n\"\n                           \"| X | X | X | \\n\"\n                           \"-------------\\n\"\n                           \"| O | O |   | \\n\"\n                           \"-------------\\n\"\n                           \"|   |   |   | \\n\"\n                           \"-------------\\n\")\n        output = self._capture_print_output(print_board, self.board3)\n        self.assertEqual(output, expected_output)\n\n    def test_case_4(self):\n        expected_output = (\"-------------\\n\"\n                           \"| O | O | O | \\n\"\n                           \"-------------\\n\"\n                           \"| X | X | X | \\n\"\n                           \"-------------\\n\"\n                           \"| X | O |   | \\n\"\n                           \"-------------\\n\")\n        output = self._capture_print_output(print_board, self.board4)\n        self.assertEqual(output, expected_output)\n\n    def test_case_5(self):\n        expected_output = (\"-------------\\n\"\n                           \"| X |   |   | \\n\"\n                           \"-------------\\n\"\n                           \"|   | X |   | \\n\"\n                           \"-------------\\n\"\n                           \"|   |   | X | \\n\"\n                           \"-------------\\n\")\n        output = self._capture_print_output(print_board, self.board5)\n        self.assertEqual(output, expected_output)\n\n    def test_case_6(self):\n        expected_output = (\"-------------\\n\"\n                           \"|   | O |   | \\n\"\n                           \"-------------\\n\"\n                           \"| O |   | O | \\n\"\n                           \"-------------\\n\"\n                           \"|   | O |   | \\n\"\n                           \"-------------\\n\")\n        output = self._capture_print_output(print_board, self.board6)\n        self.assertEqual(output, expected_output)\n\n    def _capture_print_output(self, func, *args, **kwargs):\n        \"\"\"\n        Helper function to capture print output from a function.\n        \"\"\"\n        captured_output = io.StringIO()          # Create StringIO object\n        sys.stdout = captured_output             # Redirect stdout\n        func(*args, **kwargs)                    # Call the function\n        sys.stdout = sys.__stdout__              # Reset redirect\n        return captured_output.getvalue()        # Get the output as a string", "prompt": "please write a python function , the function signature as below def print_board(board):\n    \"\"\"Prints a 3x3 game board to the console.\n\n    This function takes a 2D list representing a game board and prints\n    it in a formatted manner, displaying the contents of each cell.\n    The board is assumed to be a square of size 3x3, and each cell can\n    contain either a character representing a player's move ('X' or 'O')\n    or an empty space (' ').\n\n    The output format includes a row of dashes to separate the rows of\n    the board, and each cell is enclosed within vertical bars.\n    The function does not return any value.\n\n    Args:\n        board (list[list[str]]): A 2D list of characters, where each character represents\n                                  the state of a cell in the game board. The board must be\n                                  of size 3x3, and each character can be 'X', 'O', or ' '.\n                                  For example:\n                                  input: [['X', 'O', 'X'],\n                                          [' ', 'X', 'O'],\n                                          ['O', ' ', ' ']]\n                                  output: -------------\n                                          | X | O | X |\n                                          -------------\n                                          |   | X | O |\n                                          -------------\n                                          | O |   |   |\n                                          -------------\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Prints a 3x3 game board to the console.\n *\n * This function takes a 2D vector representing a game board and prints\n * it in a formatted manner, displaying the contents of each cell.\n * The board is assumed to be a square of size 3x3, and each cell can\n * contain either a character representing a player's move ('X' or 'O')\n * or an empty space (' ').\n *\n * The output format includes a row of dashes to separate the rows of\n * the board, and each cell is enclosed within vertical bars.\n * The function does not return any value.\n *\n * @param board A 2D vector of characters, where each character represents\n *              the state of a cell in the game board. The board must be\n *              of size 3x3, and each character can be 'X', 'O', or ' '.\n * For example:\n *      input: [['X', 'O', 'X'],\n *              [' ', 'X', 'O'],\n *              ['O', ' ', ' ']]\n *      output: -------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\n */\nvoid printBoard(const vector<vector<char>>& board) {}", "test_code": "TEST_CASE(\"printBoard outputs correct format\", \"[printBoard]\") {\n    vector<vector<char>> board1 = {\n        {'X', 'O', 'X'},\n        {' ', 'X', 'O'},\n        {'O', ' ', ' '}\n    };\n\n    vector<vector<char>> board2 = {\n        {' ', ' ', ' '},\n        {' ', ' ', ' '},\n        {' ', ' ', ' '}\n    };\n\n    vector<vector<char>> board3 = {\n        {'X', 'X', 'X'},\n        {'O', 'O', ' '},\n        {' ', ' ', ' '}\n    };\n\n    vector<vector<char>> board4 = {\n        {'O', 'O', 'O'},\n        {'X', 'X', 'X'},\n        {'X', 'O', ' '}\n    };\n\n    vector<vector<char>> board5 = {\n        {'X', ' ', ' '},\n        {' ', 'X', ' '},\n        {' ', ' ', 'X'}\n    };\n\n    vector<vector<char>> board6 = {\n        {' ', 'O', ' '},\n        {'O', ' ', 'O'},\n        {' ', 'O', ' '}\n    };\n\n    // Test case 1\n    SECTION(\"Test case 1\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf()); // Redirect cout to ostringstream\n\n        printBoard(board1);\n\n        cout.rdbuf(oldCoutBuffer); // Restore original cout\n        string expectedOutput = \"-------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 2\n    SECTION(\"Test case 2\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board2);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n|   |   |   | \\n-------------\\n|   |   |   | \\n-------------\\n|   |   |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 3\n    SECTION(\"Test case 3\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board3);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n| X | X | X | \\n-------------\\n| O | O |   | \\n-------------\\n|   |   |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 4\n    SECTION(\"Test case 4\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board4);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n| O | O | O | \\n-------------\\n| X | X | X | \\n-------------\\n| X | O |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 5\n    SECTION(\"Test case 5\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board5);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n| X |   |   | \\n-------------\\n|   | X |   | \\n-------------\\n|   |   | X | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 6\n    SECTION(\"Test case 6\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board6);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n|   | O |   | \\n-------------\\n| O |   | O | \\n-------------\\n|   | O |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Prints a 3x3 game board to the console.\n *\n * This function takes a 2D vector representing a game board and prints\n * it in a formatted manner, displaying the contents of each cell.\n * The board is assumed to be a square of size 3x3, and each cell can\n * contain either a character representing a player's move ('X' or 'O')\n * or an empty space (' ').\n *\n * The output format includes a row of dashes to separate the rows of\n * the board, and each cell is enclosed within vertical bars.\n * The function does not return any value.\n *\n * @param board A 2D vector of characters, where each character represents\n *              the state of a cell in the game board. The board must be\n *              of size 3x3, and each character can be 'X', 'O', or ' '.\n * For example:\n *      input: [['X', 'O', 'X'],\n *              [' ', 'X', 'O'],\n *              ['O', ' ', ' ']]\n *      output: -------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\n */\nvoid printBoard(const vector<vector<char>>& board) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * @brief Prints a 3x3 game board to the console.\n *\n * This method takes a 2D array representing a game board and prints\n * it in a formatted manner, displaying the contents of each cell.\n * The board is assumed to be a square of size 3x3, and each cell can\n * contain either a character representing a player's move ('X' or 'O')\n * or an empty space (' ').\n *\n * The output format includes a row of dashes to separate the rows of\n * the board, and each cell is enclosed within vertical bars.\n * This method does not return any value.\n *\n * @param board A 2D array of characters, where each character represents\n *              the state of a cell in the game board. The board must be\n *              of size 3x3, and each character can be 'X', 'O', or ' '.\n * For example:\n *      input: [['X', 'O', 'X'],\n *              [' ', 'X', 'O'],\n *              ['O', ' ', ' ']]\n *      output: -------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\n */\npublic static void printBoard(char[][] board) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\npublic class Tester {\n\n    @Test\n    public void testPrintBoard() {\n        char[][] board1 = {\n            {'X', 'O', 'X'},\n            {' ', 'X', 'O'},\n            {'O', ' ', ' '}\n        };\n\n        char[][] board2 = {\n            {' ', ' ', ' '},\n            {' ', ' ', ' '},\n            {' ', ' ', ' '}\n        };\n\n        char[][] board3 = {\n            {'X', 'X', 'X'},\n            {'O', 'O', ' '},\n            {' ', ' ', ' '}\n        };\n\n        char[][] board4 = {\n            {'O', 'O', 'O'},\n            {'X', 'X', 'X'},\n            {'X', 'O', ' '}\n        };\n\n        char[][] board5 = {\n            {'X', ' ', ' '},\n            {' ', 'X', ' '},\n            {' ', ' ', 'X'}\n        };\n\n        char[][] board6 = {\n            {' ', 'O', ' '},\n            {'O', ' ', 'O'},\n            {' ', 'O', ' '}\n        };\n\n        // Test case 1\n        assertPrintBoardOutput(board1, \"-------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\");\n        \n        // Test case 2\n        assertPrintBoardOutput(board2, \"-------------\\n|   |   |   | \\n-------------\\n|   |   |   | \\n-------------\\n|   |   |   | \\n-------------\\n\");\n\n        // Test case 3\n        assertPrintBoardOutput(board3, \"-------------\\n| X | X | X | \\n-------------\\n| O | O |   | \\n-------------\\n|   |   |   | \\n-------------\\n\");\n        \n        // Test case 4\n        assertPrintBoardOutput(board4, \"-------------\\n| O | O | O | \\n-------------\\n| X | X | X | \\n-------------\\n| X | O |   | \\n-------------\\n\");\n        \n        // Test case 5\n        assertPrintBoardOutput(board5, \"-------------\\n| X |   |   | \\n-------------\\n|   | X |   | \\n-------------\\n|   |   | X | \\n-------------\\n\");\n        \n        // Test case 6\n        assertPrintBoardOutput(board6, \"-------------\\n|   | O |   | \\n-------------\\n| O |   | O | \\n-------------\\n|   | O |   | \\n-------------\\n\");\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * @brief Prints a 3x3 game board to the console.\n *\n * This method takes a 2D array representing a game board and prints\n * it in a formatted manner, displaying the contents of each cell.\n * The board is assumed to be a square of size 3x3, and each cell can\n * contain either a character representing a player's move ('X' or 'O')\n * or an empty space (' ').\n *\n * The output format includes a row of dashes to separate the rows of\n * the board, and each cell is enclosed within vertical bars.\n * This method does not return any value.\n *\n * @param board A 2D array of characters, where each character represents\n *              the state of a cell in the game board. The board must be\n *              of size 3x3, and each character can be 'X', 'O', or ' '.\n * For example:\n *      input: [['X', 'O', 'X'],\n *              [' ', 'X', 'O'],\n *              ['O', ' ', ' ']]\n *      output: -------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\n */\npublic static void printBoard(char[][] board) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 589, "code_type": "method", "original_language": "c&cpp", "file_path": "wake_word\\d1495aa2811e7aae771cdff2fc4c63e14fc4a8ab\\firmware\\wake_word\\src\\utils\\response_parser.cpp\n", "question_type": "Data processing and transformation", "summary": "Extracts the first complete JSON object from the given string\n", "language_version_list": {"python": {"code_signature": "def extract_json(response: str) -> str:\n    \"\"\"\n    Extracts the first complete JSON object from a given string.\n\n    The function looks for the first occurrence of an opening curly brace '{'\n    and searches for the corresponding closing curly brace '}'. It tracks\n    the balance of braces to ensure that the JSON object is complete.\n\n    If a complete JSON object is found, it returns the substring that\n    represents that object. If no opening brace is found or if the braces\n    are unbalanced (i.e., incomplete), it returns an empty string.\n\n    Args:\n        response: The input string from which to extract the JSON object.\n\n    Returns:\n        A string containing the first complete JSON object, or an\n        empty string if no complete object is found.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestExtractJson(unittest.TestCase):\n\n    def test_extract_json_returns_empty_string_for_input_without_braces(self):\n        input_str = \"No braces here\"\n        self.assertEqual(extract_json(input_str), \"\")\n\n    def test_extract_json_extracts_single_json_object(self):\n        input_str = \"Here is some text before { \\\"key\\\": \\\"value\\\" } and some text after.\"\n        self.assertEqual(extract_json(input_str), \"{ \\\"key\\\": \\\"value\\\" }\")\n\n    def test_extract_json_handles_nested_json_objects(self):\n        input_str = \"Some text { \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } } more text.\"\n        self.assertEqual(extract_json(input_str), \"{ \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } }\")\n\n    def test_extract_json_returns_empty_string_for_unmatched_braces(self):\n        input_str = \"Here is an incomplete JSON { \\\"key\\\": \\\"value\\\" \"\n        self.assertEqual(extract_json(input_str), \"\")\n\n    def test_extract_json_returns_correct_json_when_multiple_braces_are_present(self):\n        input_str = \"Start { { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }} end.\"\n        self.assertEqual(extract_json(input_str),\n                         \"{ { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }}\")\n\n    def test_extract_json_extracts_first_json_object_when_multiple_are_present(self):\n        input_str = \"Text before { \\\"first\\\": \\\"value1\\\" } text in between { \\\"second\\\": \\\"value2\\\" }\"\n        self.assertEqual(extract_json(input_str), \"{ \\\"first\\\": \\\"value1\\\" }\")", "prompt": "please write a python function , the function signature as below def extract_json(response: str) -> str:\n    \"\"\"\n    Extracts the first complete JSON object from a given string.\n\n    The function looks for the first occurrence of an opening curly brace '{'\n    and searches for the corresponding closing curly brace '}'. It tracks\n    the balance of braces to ensure that the JSON object is complete.\n\n    If a complete JSON object is found, it returns the substring that\n    represents that object. If no opening brace is found or if the braces\n    are unbalanced (i.e., incomplete), it returns an empty string.\n\n    Args:\n        response: The input string from which to extract the JSON object.\n\n    Returns:\n        A string containing the first complete JSON object, or an\n        empty string if no complete object is found.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <string>\n\n/**\n * Extracts the first complete JSON object from a given string.\n *\n * The function looks for the first occurrence of an opening curly brace '{'\n * and searches for the corresponding closing curly brace '}'. It tracks\n * the balance of braces to ensure that the JSON object is complete.\n *\n * If a complete JSON object is found, it returns the substring that\n * represents that object. If no opening brace is found or if the braces\n * are unbalanced (i.e., incomplete), it returns an empty string.\n *\n * @param response The input string from which to extract the JSON object.\n * @return A string containing the first complete JSON object, or an\n *         empty string if no complete object is found.\n */\nstd::string extract_json(const std::string& response) {}", "test_code": "TEST_CASE(\"extract_json returns an empty string for input without '{'\") {\n    std::string input = \"No braces here\";\n    REQUIRE(extract_json(input) == \"\");\n}\n\nTEST_CASE(\"extract_json extracts a single JSON object\") {\n    std::string input = \"Here is some text before { \\\"key\\\": \\\"value\\\" } and some text after.\";\n    REQUIRE(extract_json(input) == \"{ \\\"key\\\": \\\"value\\\" }\");\n}\n\nTEST_CASE(\"extract_json handles nested JSON objects\") {\n    std::string input = \"Some text { \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } } more text.\";\n    REQUIRE(extract_json(input) == \"{ \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } }\");\n}\n\nTEST_CASE(\"extract_json returns an empty string for unmatched braces\") {\n    std::string input = \"Here is an incomplete JSON { \\\"key\\\": \\\"value\\\" \";\n    REQUIRE(extract_json(input) == \"\");\n}\n\nTEST_CASE(\"extract_json returns the correct JSON when multiple braces are present\") {\n    std::string input = \"Start { { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }} end.\";\n    REQUIRE(extract_json(input) == \"{ { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }}\");\n}\n\nTEST_CASE(\"extract_json extracts the first JSON object when multiple are present\") {\n    std::string input = \"Text before { \\\"first\\\": \\\"value1\\\" } text in between { \\\"second\\\": \\\"value2\\\" }\";\n    REQUIRE(extract_json(input) == \"{ \\\"first\\\": \\\"value1\\\" }\");\n}", "prompt": "please write a cpp function , the function signature as below #include <string>\n\n/**\n * Extracts the first complete JSON object from a given string.\n *\n * The function looks for the first occurrence of an opening curly brace '{'\n * and searches for the corresponding closing curly brace '}'. It tracks\n * the balance of braces to ensure that the JSON object is complete.\n *\n * If a complete JSON object is found, it returns the substring that\n * represents that object. If no opening brace is found or if the braces\n * are unbalanced (i.e., incomplete), it returns an empty string.\n *\n * @param response The input string from which to extract the JSON object.\n * @return A string containing the first complete JSON object, or an\n *         empty string if no complete object is found.\n */\nstd::string extract_json(const std::string& response) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Extracts the first complete JSON object from a given string.\n *\n * The method looks for the first occurrence of an opening curly brace '{'\n * and searches for the corresponding closing curly brace '}'. It tracks\n * the balance of braces to ensure that the JSON object is complete.\n *\n * If a complete JSON object is found, it returns the substring that\n * represents that object. If no opening brace is found or if the braces\n * are unbalanced (i.e., incomplete), it returns an empty string.\n *\n * @param response The input string from which to extract the JSON object.\n * @return A string containing the first complete JSON object, or an\n *         empty string if no complete object is found.\n */\npublic static String extractJson(String response) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testExtractJsonReturnsEmptyStringForInputWithoutBrace() {\n        String input = \"No braces here\";\n        assertEquals(\"\", Answer.extractJson(input));\n    }\n\n    @Test\n    public void testExtractJsonExtractsSingleJsonObject() {\n        String input = \"Here is some text before { \\\"key\\\": \\\"value\\\" } and some text after.\";\n        assertEquals(\"{ \\\"key\\\": \\\"value\\\" }\", Answer.extractJson(input));\n    }\n\n    @Test\n    public void testExtractJsonHandlesNestedJsonObjects() {\n        String input = \"Some text { \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } } more text.\";\n        assertEquals(\"{ \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } }\", Answer.extractJson(input));\n    }\n\n    @Test\n    public void testExtractJsonReturnsEmptyStringForUnmatchedBraces() {\n        String input = \"Here is an incomplete JSON { \\\"key\\\": \\\"value\\\" \";\n        assertEquals(\"\", Answer.extractJson(input));\n    }\n\n    @Test\n    public void testExtractJsonReturnsCorrectJsonWhenMultipleBracesPresent() {\n        String input = \"Start { { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }} end.\";\n        assertEquals(\"{ { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }}\", Answer.extractJson(input));\n    }\n\n    @Test\n    public void testExtractJsonExtractsFirstJsonObjectWhenMultiplePresent() {\n        String input = \"Text before { \\\"first\\\": \\\"value1\\\" } text in between { \\\"second\\\": \\\"value2\\\" }\";\n        assertEquals(\"{ \\\"first\\\": \\\"value1\\\" }\", Answer.extractJson(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts the first complete JSON object from a given string.\n *\n * The method looks for the first occurrence of an opening curly brace '{'\n * and searches for the corresponding closing curly brace '}'. It tracks\n * the balance of braces to ensure that the JSON object is complete.\n *\n * If a complete JSON object is found, it returns the substring that\n * represents that object. If no opening brace is found or if the braces\n * are unbalanced (i.e., incomplete), it returns an empty string.\n *\n * @param response The input string from which to extract the JSON object.\n * @return A string containing the first complete JSON object, or an\n *         empty string if no complete object is found.\n */\npublic static String extractJson(String response) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 590, "code_type": "method", "original_language": "c&cpp", "file_path": "wake_word\\d1495aa2811e7aae771cdff2fc4c63e14fc4a8ab\\firmware\\wake_word\\src\\utils\\response_parser.cpp\n", "question_type": "Data processing and transformation", "summary": "Parse the HTTP response string, obtain the request method, URL, and HTTP version number, store the information in a map and return it\n", "language_version_list": {"python": {"code_signature": "def parse_http_request_line(response: str) -> dict:\n    \"\"\"\n    Parses the first line of an HTTP request.\n\n    Args:\n        response (str): The raw HTTP request string.\n\n    Returns:\n        dict: A dictionary containing the method, URL, and HTTP version.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_valid_post_request_line(self):\n        response = \"POST /api/data HTTP/1.1\\r\\n\"\n        parsed_info = parse_http_request_line(response)\n        self.assertEqual(parsed_info[\"method\"], \"POST\")\n        self.assertEqual(parsed_info[\"url\"], \"/api/data\")\n        self.assertEqual(parsed_info[\"http_version\"], \"HTTP/1.1\")\n\n    def test_put_request_line(self):\n        response = \"PUT /api/update HTTP/2.0\\r\\n\"\n        parsed_info = parse_http_request_line(response)\n        self.assertEqual(parsed_info[\"method\"], \"PUT\")\n        self.assertEqual(parsed_info[\"url\"], \"/api/update\")\n        self.assertEqual(parsed_info[\"http_version\"], \"HTTP/2.0\")\n\n    def test_delete_request_line(self):\n        response = \"DELETE /api/delete HTTP/1.1\\r\\n\"\n        parsed_info = parse_http_request_line(response)\n        self.assertEqual(parsed_info[\"method\"], \"DELETE\")\n        self.assertEqual(parsed_info[\"url\"], \"/api/delete\")\n        self.assertEqual(parsed_info[\"http_version\"], \"HTTP/1.1\")\n\n    def test_malformed_request_line(self):\n        response = \"INVALID REQUEST LINE\\r\\n\"\n        parsed_info = parse_http_request_line(response)\n        self.assertEqual(parsed_info, {})  # Expect empty result for malformed request", "prompt": "please write a python function , the function signature as below def parse_http_request_line(response: str) -> dict:\n    \"\"\"\n    Parses the first line of an HTTP request.\n\n    Args:\n        response (str): The raw HTTP request string.\n\n    Returns:\n        dict: A dictionary containing the method, URL, and HTTP version.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <string>\n#include <map>\n#include <sstream>\n\n/**\n * @brief Parses the first line of an HTTP request response string.\n *\n * This function extracts the HTTP method, request URL, and HTTP version\n * from the given response string. The first line of the response should\n * be formatted as \"METHOD URL HTTP/VERSION\", followed by a CRLF sequence\n * (carriage return and line feed). If the first line does not conform\n * to this format, the function will return an empty map.\n *\n * @param response A string containing the HTTP response. It is expected\n *                 to start with a request line that includes the method,\n *                 URL, and HTTP version, ending with CRLF (\"\\r\\n\").\n *\n * @return A map containing three key-value pairs:\n *         - \"method\": The HTTP method (e.g., GET, POST).\n *         - \"url\": The requested URL (e.g., /index.html).\n *         - \"http_version\": The HTTP version (e.g., HTTP/1.1).\n *         If the request line is malformed or empty, the map may contain\n *         empty strings or be empty.\n *\n * @note The function does not validate the correctness of the HTTP method,\n *       URL, or version; it only parses the input string.\n */\nstd::map<std::string, std::string> parse_http_request_line(const std::string& response){}", "test_code": "TEST_CASE(\"Valid POST request line\", \"[parse_http_request_line]\") {\n    std::string response = \"POST /api/data HTTP/1.1\\r\\n\";\n    auto parsed_info = parse_http_request_line(response);\n\n    REQUIRE(parsed_info[\"method\"] == \"POST\");\n    REQUIRE(parsed_info[\"url\"] == \"/api/data\");\n    REQUIRE(parsed_info[\"http_version\"] == \"HTTP/1.1\");\n}\n\nTEST_CASE(\"PUT request line\", \"[parse_http_request_line]\") {\n    std::string response = \"PUT /api/update HTTP/2.0\\r\\n\";\n    auto parsed_info = parse_http_request_line(response);\n\n    REQUIRE(parsed_info[\"method\"] == \"PUT\");\n    REQUIRE(parsed_info[\"url\"] == \"/api/update\");\n    REQUIRE(parsed_info[\"http_version\"] == \"HTTP/2.0\");\n}\n\nTEST_CASE(\"DELETE request line\", \"[parse_http_request_line]\") {\n    std::string response = \"DELETE /api/delete HTTP/1.1\\r\\n\";\n    auto parsed_info = parse_http_request_line(response);\n\n    REQUIRE(parsed_info[\"method\"] == \"DELETE\");\n    REQUIRE(parsed_info[\"url\"] == \"/api/delete\");\n    REQUIRE(parsed_info[\"http_version\"] == \"HTTP/1.1\");\n}\n\nTEST_CASE(\"Malformed request line\", \"[parse_http_request_line]\") {\n    std::string response = \"INVALID REQUEST LINE\\r\\n\";\n    auto parsed_info = parse_http_request_line(response);\n\n    REQUIRE(parsed_info.empty());  // Expect empty result for malformed request\n}", "prompt": "please write a cpp function , the function signature as below #include <string>\n#include <map>\n#include <sstream>\n\n/**\n * @brief Parses the first line of an HTTP request response string.\n *\n * This function extracts the HTTP method, request URL, and HTTP version\n * from the given response string. The first line of the response should\n * be formatted as \"METHOD URL HTTP/VERSION\", followed by a CRLF sequence\n * (carriage return and line feed). If the first line does not conform\n * to this format, the function will return an empty map.\n *\n * @param response A string containing the HTTP response. It is expected\n *                 to start with a request line that includes the method,\n *                 URL, and HTTP version, ending with CRLF (\"\\r\\n\").\n *\n * @return A map containing three key-value pairs:\n *         - \"method\": The HTTP method (e.g., GET, POST).\n *         - \"url\": The requested URL (e.g., /index.html).\n *         - \"http_version\": The HTTP version (e.g., HTTP/1.1).\n *         If the request line is malformed or empty, the map may contain\n *         empty strings or be empty.\n *\n * @note The function does not validate the correctness of the HTTP method,\n *       URL, or version; it only parses the input string.\n */\nstd::map<std::string, std::string> parse_http_request_line(const std::string& response){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Parses the first line of an HTTP request response string.\n *\n * This method extracts the HTTP method, request URL, and HTTP version\n * from the given response string. The first line of the response should\n * be formatted as \"METHOD URL HTTP/VERSION\", followed by a CRLF sequence\n * (carriage return and line feed). If the first line does not conform\n * to this format, the method will return an empty map.\n *\n * @param response A string containing the HTTP response. It is expected\n *                 to start with a request line that includes the method,\n *                 URL, and HTTP version, ending with CRLF (\"\\r\\n\").\n *\n * @return A map containing three key-value pairs:\n *         - \"method\": The HTTP method (e.g., GET, POST).\n *         - \"url\": The requested URL (e.g., /index.html).\n *         - \"http_version\": The HTTP version (e.g., HTTP/1.1).\n *         If the request line is malformed or empty, the map may contain\n *         empty strings or be empty.\n *\n * @note The method does not validate the correctness of the HTTP method,\n *       URL, or version; it only parses the input string.\n */\npublic static Map<String, String> parseHttpRequestLine(String response) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport java.util.Map;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\npublic class Tester {\n\n    @Test\n    public void testValidPostRequestLine() {\n        String response = \"POST /api/data HTTP/1.1\\r\\n\";\n        Map<String, String> parsedInfo = Answer.parseHttpRequestLine(response);\n\n        assertEquals(\"POST\", parsedInfo.get(\"method\"));\n        assertEquals(\"/api/data\", parsedInfo.get(\"url\"));\n        assertEquals(\"HTTP/1.1\", parsedInfo.get(\"http_version\"));\n    }\n\n    @Test\n    public void testPutRequestLine() {\n        String response = \"PUT /api/update HTTP/2.0\\r\\n\";\n        Map<String, String> parsedInfo = Answer.parseHttpRequestLine(response);\n\n        assertEquals(\"PUT\", parsedInfo.get(\"method\"));\n        assertEquals(\"/api/update\", parsedInfo.get(\"url\"));\n        assertEquals(\"HTTP/2.0\", parsedInfo.get(\"http_version\"));\n    }\n\n    @Test\n    public void testDeleteRequestLine() {\n        String response = \"DELETE /api/delete HTTP/1.1\\r\\n\";\n        Map<String, String> parsedInfo = Answer.parseHttpRequestLine(response);\n\n        assertEquals(\"DELETE\", parsedInfo.get(\"method\"));\n        assertEquals(\"/api/delete\", parsedInfo.get(\"url\"));\n        assertEquals(\"HTTP/1.1\", parsedInfo.get(\"http_version\"));\n    }\n\n    @Test\n    public void testMalformedRequestLine() {\n        String response = \"INVALID REQUEST LINE\\r\\n\";\n        Map<String, String> parsedInfo = Answer.parseHttpRequestLine(response);\n\n        assertTrue(parsedInfo.isEmpty());  // Expect empty result for malformed request\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Parses the first line of an HTTP request response string.\n *\n * This method extracts the HTTP method, request URL, and HTTP version\n * from the given response string. The first line of the response should\n * be formatted as \"METHOD URL HTTP/VERSION\", followed by a CRLF sequence\n * (carriage return and line feed). If the first line does not conform\n * to this format, the method will return an empty map.\n *\n * @param response A string containing the HTTP response. It is expected\n *                 to start with a request line that includes the method,\n *                 URL, and HTTP version, ending with CRLF (\"\\r\\n\").\n *\n * @return A map containing three key-value pairs:\n *         - \"method\": The HTTP method (e.g., GET, POST).\n *         - \"url\": The requested URL (e.g., /index.html).\n *         - \"http_version\": The HTTP version (e.g., HTTP/1.1).\n *         If the request line is malformed or empty, the map may contain\n *         empty strings or be empty.\n *\n * @note The method does not validate the correctness of the HTTP method,\n *       URL, or version; it only parses the input string.\n */\npublic static Map<String, String> parseHttpRequestLine(String response) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 591, "code_type": "class", "original_language": "c&cpp", "file_path": "stm32-pet-project\\747c4b041fd4cad83a66dde56c50128afa6c8392\\Core\\Inc\\colors.h\n", "question_type": "Program input code", "summary": "Please write a class that contains RGB representations of, RED, GREEN, BLUE, YELLOW, MAGENTA, CYAN, WHITE, BLACK, ORANGE, PURPLE, PINK, BROWN, which can be obtained directly by the function", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <string>\n#include <unordered_map>\n\n/**\n* Please write a class that contains RGB representations of, RED, GREEN, BLUE, YELLOW, MAGENTA, CYAN, WHITE, BLACK, ORANGE, PURPLE, PINK, BROWN, which can be obtained directly by the function\n/\nclass Color {\npublic:\n    enum ColorName {\n        RED,\n        GREEN,\n        BLUE,\n        YELLOW,\n        MAGENTA,\n        CYAN,\n        WHITE,\n        BLACK,\n        ORANGE,\n        PURPLE,\n        PINK,\n        BROWN\n    };\n\n    // Constructor\n    Color() {\n        initializeColors();\n    }\n\n    // Function to get the RGB value of a color by its name\n    std::tuple<int, int, int> getColor(ColorName colorName) {}\n\n    // Function to get the color name as a string\n    std::string getColorName(ColorName colorName) {}\n\nprivate:\n    // A map to store the RGB values of the colors\n    std::unordered_map<ColorName, std::tuple<int, int, int>> colors;\n\n    // Function to initialize the colors\n    void initializeColors() {}\n};\n", "test_code": "TEST_CASE(\"Color RGB Values\", \"[Color]\") {\n    Color color;\n\n    SECTION(\"Verify RGB values for Red\") {\n        auto rgb = color.getColor(Color::RED);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Green\") {\n        auto rgb = color.getColor(Color::GREEN);\n        REQUIRE(std::get<0>(rgb) == 0);\n        REQUIRE(std::get<1>(rgb) == 255);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Blue\") {\n        auto rgb = color.getColor(Color::BLUE);\n        REQUIRE(std::get<0>(rgb) == 0);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 255);\n    }\n\n    SECTION(\"Verify RGB values for Yellow\") {\n        auto rgb = color.getColor(Color::YELLOW);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 255);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Magenta\") {\n        auto rgb = color.getColor(Color::MAGENTA);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 255);\n    }\n\n    SECTION(\"Verify RGB values for Cyan\") {\n        auto rgb = color.getColor(Color::CYAN);\n        REQUIRE(std::get<0>(rgb) == 0);\n        REQUIRE(std::get<1>(rgb) == 255);\n        REQUIRE(std::get<2>(rgb) == 255);\n    }\n\n    SECTION(\"Verify RGB values for White\") {\n        auto rgb = color.getColor(Color::WHITE);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 255);\n        REQUIRE(std::get<2>(rgb) == 255);\n    }\n\n    SECTION(\"Verify RGB values for Black\") {\n        auto rgb = color.getColor(Color::BLACK);\n        REQUIRE(std::get<0>(rgb) == 0);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Orange\") {\n        auto rgb = color.getColor(Color::ORANGE);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 165);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Purple\") {\n        auto rgb = color.getColor(Color::PURPLE);\n        REQUIRE(std::get<0>(rgb) == 128);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 128);\n    }\n\n    SECTION(\"Verify RGB values for Pink\") {\n        auto rgb = color.getColor(Color::PINK);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 192);\n        REQUIRE(std::get<2>(rgb) == 203);\n    }\n\n    SECTION(\"Verify RGB values for Brown\") {\n        auto rgb = color.getColor(Color::BROWN);\n        REQUIRE(std::get<0>(rgb) == 165);\n        REQUIRE(std::get<1>(rgb) == 42);\n        REQUIRE(std::get<2>(rgb) == 42);\n    }\n}", "prompt": "please write a cpp class , the class signature as below #include <iostream>\n#include <string>\n#include <unordered_map>\n\n/**\n* Please write a class that contains RGB representations of, RED, GREEN, BLUE, YELLOW, MAGENTA, CYAN, WHITE, BLACK, ORANGE, PURPLE, PINK, BROWN, which can be obtained directly by the function\n/\nclass Color {\npublic:\n    enum ColorName {\n        RED,\n        GREEN,\n        BLUE,\n        YELLOW,\n        MAGENTA,\n        CYAN,\n        WHITE,\n        BLACK,\n        ORANGE,\n        PURPLE,\n        PINK,\n        BROWN\n    };\n\n    // Constructor\n    Color() {\n        initializeColors();\n    }\n\n    // Function to get the RGB value of a color by its name\n    std::tuple<int, int, int> getColor(ColorName colorName) {}\n\n    // Function to get the color name as a string\n    std::string getColorName(ColorName colorName) {}\n\nprivate:\n    // A map to store the RGB values of the colors\n    std::unordered_map<ColorName, std::tuple<int, int, int>> colors;\n\n    // Function to initialize the colors\n    void initializeColors() {}\n};\n", "addition_info": "#include <unordered_map>\n"}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}, {"task_id": 592, "code_type": "method", "original_language": "c&cpp", "file_path": "NumericParser\\f35a211e3621db8db305869abfc527cb77acf66f\\NumericParser\\NumericParser.cpp\n", "question_type": "Algorithm and data structure", "summary": "Implement a simple mathematical operation function\n", "language_version_list": {"python": {"code_signature": "def perform_operation(a: float, b: float, op: str) -> float:\n    \"\"\"Performs a mathematical operation on two operands.\n\n    This function takes two float values and an operator character, and performs\n    the specified arithmetic operation. Supported operations include addition,\n    subtraction, multiplication, division, and exponentiation.\n\n    Args:\n        a (float): The first operand.\n        b (float): The second operand.\n        op (str): A character representing the operation to perform:\n                  '+' for addition,\n                  '-' for subtraction,\n                  '*' for multiplication,\n                  '/' for division,\n                  '^' for exponentiation.\n\n    Returns:\n        float: The result of the operation.\n\n    Raises:\n        ValueError: If the operator is not recognized or if\n                    there is an attempt to divide by zero.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_addition(self):\n        self.assertEqual(apply_op(3, 4, '+'), 7)\n        self.assertEqual(apply_op(-1, -1, '+'), -2)\n\n    def test_subtraction(self):\n        self.assertEqual(apply_op(10, 5, '-'), 5)\n        self.assertEqual(apply_op(5, 10, '-'), -5)\n\n    def test_multiplication(self):\n        self.assertEqual(apply_op(3, 4, '*'), 12)\n        self.assertEqual(apply_op(-2, 5, '*'), -10)\n\n    def test_division(self):\n        self.assertEqual(apply_op(8, 4, '/'), 2)\n        self.assertEqual(apply_op(5, 2, '/'), 2.5)\n        with self.assertRaises(Exception):  # Change to ValueError for Python\n            apply_op(5, 0, '/')\n\n    def test_exponentiation(self):\n        self.assertEqual(apply_op(2, 3, '^'), 8)\n        self.assertEqual(apply_op(9, 0.5, '^'), 3)  # Square root of 9\n", "prompt": "please write a python function , the function signature as below def perform_operation(a: float, b: float, op: str) -> float:\n    \"\"\"Performs a mathematical operation on two operands.\n\n    This function takes two float values and an operator character, and performs\n    the specified arithmetic operation. Supported operations include addition,\n    subtraction, multiplication, division, and exponentiation.\n\n    Args:\n        a (float): The first operand.\n        b (float): The second operand.\n        op (str): A character representing the operation to perform:\n                  '+' for addition,\n                  '-' for subtraction,\n                  '*' for multiplication,\n                  '/' for division,\n                  '^' for exponentiation.\n\n    Returns:\n        float: The result of the operation.\n\n    Raises:\n        ValueError: If the operator is not recognized or if\n                    there is an attempt to divide by zero.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <cmath>\n#include <stdexcept>\n\n/**\n * @brief Performs a mathematical operation on two operands.\n *\n * This function takes two double values and an operator character, and performs\n * the specified arithmetic operation. Supported operations include addition,\n * subtraction, multiplication, division, and exponentiation.\n *\n * @param a The first operand (double).\n * @param b The second operand (double).\n * @param op A character representing the operation to perform:\n *            '+' for addition,\n *            '-' for subtraction,\n *            '*' for multiplication,\n *            '/' for division,\n *            '^' for exponentiation.\n *\n * @return The result of the operation as a double.\n *\n * @throws std::invalid_argument if the operator is not recognized or if\n *         there is an attempt to divide by zero.\n */\ndouble applyOp(double a, double b, char op) {}", "test_code": "TEST_CASE(\"applyOp function tests\") {\n    SECTION(\"Addition\") {\n        REQUIRE(applyOp(3, 4, '+') == 7);\n        REQUIRE(applyOp(-1, -1, '+') == -2);\n    }\n\n    SECTION(\"Subtraction\") {\n        REQUIRE(applyOp(10, 5, '-') == 5);\n        REQUIRE(applyOp(5, 10, '-') == -5);\n    }\n\n    SECTION(\"Multiplication\") {\n        REQUIRE(applyOp(3, 4, '*') == 12);\n        REQUIRE(applyOp(-2, 5, '*') == -10);\n    }\n\n    SECTION(\"Division\") {\n        REQUIRE(applyOp(8, 4, '/') == 2);\n        REQUIRE(applyOp(5, 2, '/') == 2.5);\n        REQUIRE_THROWS_AS(applyOp(5, 0, '/'), std::invalid_argument);\n    }\n\n    SECTION(\"Exponentiation\") {\n        REQUIRE(applyOp(2, 3, '^') == 8);\n        REQUIRE(applyOp(9, 0.5, '^') == 3); // Square root of 9\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <cmath>\n#include <stdexcept>\n\n/**\n * @brief Performs a mathematical operation on two operands.\n *\n * This function takes two double values and an operator character, and performs\n * the specified arithmetic operation. Supported operations include addition,\n * subtraction, multiplication, division, and exponentiation.\n *\n * @param a The first operand (double).\n * @param b The second operand (double).\n * @param op A character representing the operation to perform:\n *            '+' for addition,\n *            '-' for subtraction,\n *            '*' for multiplication,\n *            '/' for division,\n *            '^' for exponentiation.\n *\n * @return The result of the operation as a double.\n *\n * @throws std::invalid_argument if the operator is not recognized or if\n *         there is an attempt to divide by zero.\n */\ndouble applyOp(double a, double b, char op) {}", "addition_info": ""}, "java": {"code_signature": "\n/**\n * Performs a mathematical operation on two operands.\n *\n * @param a The first operand (double).\n * @param b The second operand (double).\n * @param op A character representing the operation to perform:\n *           '+' for addition,\n *           '-' for subtraction,\n *           '*' for multiplication,\n *           '/' for division,\n *           '^' for exponentiation.\n * @return The result of the operation as a double.\n * @throws IllegalArgumentException if the operator is not recognized or if\n *                                  there is an attempt to divide by zero.\n */\npublic static double applyOp(double a, double b, char op) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void testAddition() {\n        assertEquals(7, Answer.applyOp(3, 4, '+'), 0);\n        assertEquals(-2, Answer.applyOp(-1, -1, '+'), 0);\n    }\n\n    @Test\n    public void testSubtraction() {\n        assertEquals(5, Answer.applyOp(10, 5, '-'), 0);\n        assertEquals(-5, Answer.applyOp(5, 10, '-'), 0);\n    }\n\n    @Test\n    public void testMultiplication() {\n        assertEquals(12, Answer.applyOp(3, 4, '*'), 0);\n        assertEquals(-10, Answer.applyOp(-2, 5, '*'), 0);\n    }\n\n    @Test\n    public void testDivision() {\n        assertEquals(2, Answer.applyOp(8, 4, '/'), 0);\n        assertEquals(2.5, Answer.applyOp(5, 2, '/'), 0);\n        try {\n            Answer.applyOp(5, 0, '/');\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // Expected exception\n        }\n    }\n\n    @Test\n    public void testExponentiation() {\n        assertEquals(8, Answer.applyOp(2, 3, '^'), 0);\n        assertEquals(3, Answer.applyOp(9, 0.5, '^'), 0);\n    }\n}", "prompt": "please write a java function , the function signature as below \n/**\n * Performs a mathematical operation on two operands.\n *\n * @param a The first operand (double).\n * @param b The second operand (double).\n * @param op A character representing the operation to perform:\n *           '+' for addition,\n *           '-' for subtraction,\n *           '*' for multiplication,\n *           '/' for division,\n *           '^' for exponentiation.\n * @return The result of the operation as a double.\n * @throws IllegalArgumentException if the operator is not recognized or if\n *                                  there is an attempt to divide by zero.\n */\npublic static double applyOp(double a, double b, char op) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 594, "code_type": "method", "original_language": "c&cpp", "file_path": "SchedulingApp\\7f9d94ec8f967f0ff876ea589be8e63abc378212\\model\\src\\Project.cpp\n", "question_type": "Data processing and transformation", "summary": "Splits a comma-separated string into individual tokens.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef split_comma(s: str) -> List[str]:\n    \"\"\"\n    Splits a comma-separated string into individual tokens.\n    This function takes a string containing comma-separated values, trims\n    leading and trailing whitespace from each token, and stores the non-empty\n    tokens in the provided list.\n\n    Args:\n        s (str): The input string to be split, which may contain leading and trailing whitespace around the tokens.\n\n    Returns:\n        List[str]: A list where the resulting tokens will be stored. The list will be cleared before storing the new tokens.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_basic_comma_separated_values(self):\n        result = split_comma(\"apple,banana,orange\")\n        self.assertEqual(len(result), 3)\n        self.assertEqual(result[0], \"apple\")\n        self.assertEqual(result[1], \"banana\")\n        self.assertEqual(result[2], \"orange\")\n\n    def test_leading_and_trailing_whitespace(self):\n        result = split_comma(\"  apple , banana , orange  \")\n        self.assertEqual(len(result), 3)\n        self.assertEqual(result[0], \"apple\")\n        self.assertEqual(result[1], \"banana\")\n        self.assertEqual(result[2], \"orange\")\n\n    def test_multiple_consecutive_commas(self):\n        result = split_comma(\"apple,,banana,,,orange\")\n        self.assertEqual(len(result), 3)\n        self.assertEqual(result[0], \"apple\")\n        self.assertEqual(result[1], \"banana\")\n        self.assertEqual(result[2], \"orange\")\n\n    def test_empty_input_string(self):\n        result = split_comma(\"\")\n        self.assertEqual(len(result), 0)\n\n    def test_only_whitespace_input(self):\n        result = split_comma(\"   \")\n        self.assertEqual(len(result), 0)\n\n    def test_trailing_commas(self):\n        result = split_comma(\"apple,banana,orange,\")\n        self.assertEqual(len(result), 3)\n        self.assertEqual(result[0], \"apple\")\n        self.assertEqual(result[1], \"banana\")\n        self.assertEqual(result[2], \"orange\")\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef split_comma(s: str) -> List[str]:\n    \"\"\"\n    Splits a comma-separated string into individual tokens.\n    This function takes a string containing comma-separated values, trims\n    leading and trailing whitespace from each token, and stores the non-empty\n    tokens in the provided list.\n\n    Args:\n        s (str): The input string to be split, which may contain leading and trailing whitespace around the tokens.\n\n    Returns:\n        List[str]: A list where the resulting tokens will be stored. The list will be cleared before storing the new tokens.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm> // for std::remove_if\n/**\n * @brief Splits a comma-separated string into individual tokens.\n *\n * This function takes a string containing comma-separated values, trims\n * leading and trailing whitespace from each token, and stores the non-empty\n * tokens in the provided vector.\n *\n * @param str The input string to be split, which may contain leading and\n *            trailing whitespace around the tokens.\n * @param vect A reference to a vector of strings where the resulting tokens\n *             will be stored. The vector will be cleared before storing\n *             the new tokens.\n */\nvoid splitComma(const std::string& str, std::vector<std::string>& vect) {}", "test_code": "TEST_CASE(\"splitComma function tests\") {\n    std::vector<std::string> result;\n\n    SECTION(\"Basic comma-separated values\") {\n        splitComma(\"apple,banana,orange\", result);\n        REQUIRE(result.size() == 3);\n        REQUIRE(result[0] == \"apple\");\n        REQUIRE(result[1] == \"banana\");\n        REQUIRE(result[2] == \"orange\");\n    }\n\n    SECTION(\"Leading and trailing whitespace\") {\n        splitComma(\"  apple , banana , orange  \", result);\n        REQUIRE(result.size() == 3);\n        REQUIRE(result[0] == \"apple\");\n        REQUIRE(result[1] == \"banana\");\n        REQUIRE(result[2] == \"orange\");\n    }\n\n    SECTION(\"Multiple consecutive commas\") {\n        splitComma(\"apple,,banana,,,orange\", result);\n        REQUIRE(result.size() == 3);\n        REQUIRE(result[0] == \"apple\");\n        REQUIRE(result[1] == \"banana\");\n        REQUIRE(result[2] == \"orange\");\n    }\n\n    SECTION(\"Empty input string\") {\n        splitComma(\"\", result);\n        REQUIRE(result.size() == 0);\n    }\n\n    SECTION(\"Only whitespace input\") {\n        splitComma(\"   \", result);\n        REQUIRE(result.size() == 0);\n    }\n\n    SECTION(\"Trailing commas\") {\n        splitComma(\"apple,banana,orange,\", result);\n        REQUIRE(result.size() == 3);\n        REQUIRE(result[0] == \"apple\");\n        REQUIRE(result[1] == \"banana\");\n        REQUIRE(result[2] == \"orange\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm> // for std::remove_if\n/**\n * @brief Splits a comma-separated string into individual tokens.\n *\n * This function takes a string containing comma-separated values, trims\n * leading and trailing whitespace from each token, and stores the non-empty\n * tokens in the provided vector.\n *\n * @param str The input string to be split, which may contain leading and\n *            trailing whitespace around the tokens.\n * @param vect A reference to a vector of strings where the resulting tokens\n *             will be stored. The vector will be cleared before storing\n *             the new tokens.\n */\nvoid splitComma(const std::string& str, std::vector<std::string>& vect) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Splits a comma-separated string into individual tokens.\n *\n * This method takes a string containing comma-separated values, trims\n * leading and trailing whitespace from each token, and stores the non-empty\n * tokens in the provided list.\n *\n * @param str The input string to be split, which may contain leading and\n *            trailing whitespace around the tokens.\n * @param vect A list of strings where the resulting tokens\n *             will be stored. The list will be cleared before storing\n *             the new tokens.\n */\npublic static void splitComma(String str, List<String> vect) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    private List<String> result;\n\n    @Before\n    public void setUp() {\n        result = new ArrayList<>();\n    }\n\n    @Test\n    public void testBasicCommaSeparatedValues() {\n        Answer.splitComma(\"apple,banana,orange\", result);\n        assertEquals(3, result.size());\n        assertEquals(\"apple\", result.get(0));\n        assertEquals(\"banana\", result.get(1));\n        assertEquals(\"orange\", result.get(2));\n    }\n\n    @Test\n    public void testLeadingAndTrailingWhitespace() {\n        Answer.splitComma(\"  apple , banana , orange  \", result);\n        assertEquals(3, result.size());\n        assertEquals(\"apple\", result.get(0));\n        assertEquals(\"banana\", result.get(1));\n        assertEquals(\"orange\", result.get(2));\n    }\n\n    @Test\n    public void testMultipleConsecutiveCommas() {\n        Answer.splitComma(\"apple,,banana,,,orange\", result);\n        assertEquals(3, result.size());\n        assertEquals(\"apple\", result.get(0));\n        assertEquals(\"banana\", result.get(1));\n        assertEquals(\"orange\", result.get(2));\n    }\n\n    @Test\n    public void testEmptyInputString() {\n        Answer.splitComma(\"\", result);\n        assertEquals(0, result.size());\n    }\n\n    @Test\n    public void testOnlyWhitespaceInput() {\n        Answer.splitComma(\"   \", result);\n        assertEquals(0, result.size());\n    }\n\n    @Test\n    public void testTrailingCommas() {\n        Answer.splitComma(\"apple,banana,orange,\", result);\n        assertEquals(3, result.size());\n        assertEquals(\"apple\", result.get(0));\n        assertEquals(\"banana\", result.get(1));\n        assertEquals(\"orange\", result.get(2));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Splits a comma-separated string into individual tokens.\n *\n * This method takes a string containing comma-separated values, trims\n * leading and trailing whitespace from each token, and stores the non-empty\n * tokens in the provided list.\n *\n * @param str The input string to be split, which may contain leading and\n *            trailing whitespace around the tokens.\n * @param vect A list of strings where the resulting tokens\n *             will be stored. The list will be cleared before storing\n *             the new tokens.\n */\npublic static void splitComma(String str, List<String> vect) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 595, "code_type": "method", "original_language": "c&cpp", "file_path": "RCMS\\334326745eb8419775c4a37cd6094e022768c703\\appendices\\sales and costs and ratings generation\\generateSalesCosts.h\n", "question_type": "Data processing and transformation", "summary": "Returns the number of days in a given month of a given year.", "language_version_list": {"python": {"code_signature": "def get_days_in_month(year: int, month: int) -> int:\n    \"\"\"\n    Returns the number of days in a given month of a given year.\n    This function accounts for leap years when determining the number of\n    days in February. It raises a ValueError if the month is invalid.\n\n    Args:\n        year (int): The year to check (should be a positive integer).\n        month (int): The month to check (1 for January, 12 for December).\n\n    Returns:\n        int: The number of days in the specified month of the specified year.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_get_days_in_month(self):\n        # Regular months\n        self.assertEqual(get_days_in_month(2023, 1), 31)  # January\n        self.assertEqual(get_days_in_month(2023, 3), 31)  # March\n        self.assertEqual(get_days_in_month(2023, 4), 30)  # April\n        self.assertEqual(get_days_in_month(2023, 5), 31)  # May\n        self.assertEqual(get_days_in_month(2023, 6), 30)  # June\n        self.assertEqual(get_days_in_month(2023, 7), 31)  # July\n        self.assertEqual(get_days_in_month(2023, 8), 31)  # August\n        self.assertEqual(get_days_in_month(2023, 9), 30)  # September\n        self.assertEqual(get_days_in_month(2023, 10), 31) # October\n        self.assertEqual(get_days_in_month(2023, 11), 30) # November\n        self.assertEqual(get_days_in_month(2023, 12), 31) # December\n\n        # February in leap year\n        self.assertEqual(get_days_in_month(2024, 2), 29)  # Leap year\n\n        # February in non-leap year\n        self.assertEqual(get_days_in_month(2023, 2), 28)  # Non-leap year", "prompt": "please write a python function , the function signature as below def get_days_in_month(year: int, month: int) -> int:\n    \"\"\"\n    Returns the number of days in a given month of a given year.\n    This function accounts for leap years when determining the number of\n    days in February. It raises a ValueError if the month is invalid.\n\n    Args:\n        year (int): The year to check (should be a positive integer).\n        month (int): The month to check (1 for January, 12 for December).\n\n    Returns:\n        int: The number of days in the specified month of the specified year.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Returns the number of days in a given month of a given year.\n *\n * This function accounts for leap years when determining the number of\n * days in February. It throws an exception if the month is invalid.\n *\n * @param year The year to check (should be a positive integer).\n * @param month The month to check (1 for January, 12 for December).\n * @return int The number of days in the specified month of the specified year.\n * @throws std::invalid_argument If the month is not between 1 and 12.\n */\nint getDaysInMonth(int year, int month) {}", "test_code": "TEST_CASE(\"Test getDaysInMonth function\") {\n    SECTION(\"Regular months\") {\n        REQUIRE(getDaysInMonth(2023, 1) == 31); // January\n        REQUIRE(getDaysInMonth(2023, 3) == 31); // March\n        REQUIRE(getDaysInMonth(2023, 4) == 30); // April\n        REQUIRE(getDaysInMonth(2023, 5) == 31); // May\n        REQUIRE(getDaysInMonth(2023, 6) == 30); // June\n        REQUIRE(getDaysInMonth(2023, 7) == 31); // July\n        REQUIRE(getDaysInMonth(2023, 8) == 31); // August\n        REQUIRE(getDaysInMonth(2023, 9) == 30); // September\n        REQUIRE(getDaysInMonth(2023, 10) == 31); // October\n        REQUIRE(getDaysInMonth(2023, 11) == 30); // November\n        REQUIRE(getDaysInMonth(2023, 12) == 31); // December\n    }\n\n    SECTION(\"February in leap year\") {\n        REQUIRE(getDaysInMonth(2024, 2) == 29); // Leap year\n    }\n\n    SECTION(\"February in non-leap year\") {\n        REQUIRE(getDaysInMonth(2023, 2) == 28); // Non-leap year\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Returns the number of days in a given month of a given year.\n *\n * This function accounts for leap years when determining the number of\n * days in February. It throws an exception if the month is invalid.\n *\n * @param year The year to check (should be a positive integer).\n * @param month The month to check (1 for January, 12 for December).\n * @return int The number of days in the specified month of the specified year.\n * @throws std::invalid_argument If the month is not between 1 and 12.\n */\nint getDaysInMonth(int year, int month) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Returns the number of days in a given month of a given year.\n *\n * This method accounts for leap years when determining the number of\n * days in February. It throws an exception if the month is invalid.\n *\n * @param year The year to check (should be a positive integer).\n * @param month The month to check (1 for January, 12 for December).\n * @return int The number of days in the specified month of the specified year.\n * @throws IllegalArgumentException If the month is not between 1 and 12.\n */\npublic static int getDaysInMonth(int year, int month) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testGetDaysInMonthRegularMonths() {\n        assertEquals(31, getDaysInMonth(2023, 1)); // January\n        assertEquals(31, getDaysInMonth(2023, 3)); // March\n        assertEquals(30, getDaysInMonth(2023, 4)); // April\n        assertEquals(31, getDaysInMonth(2023, 5)); // May\n        assertEquals(30, getDaysInMonth(2023, 6)); // June\n        assertEquals(31, getDaysInMonth(2023, 7)); // July\n        assertEquals(31, getDaysInMonth(2023, 8)); // August\n        assertEquals(30, getDaysInMonth(2023, 9)); // September\n        assertEquals(31, getDaysInMonth(2023, 10)); // October\n        assertEquals(30, getDaysInMonth(2023, 11)); // November\n        assertEquals(31, getDaysInMonth(2023, 12)); // December\n    }\n\n    @Test\n    public void testGetDaysInMonthFebruaryLeapYear() {\n        assertEquals(29, getDaysInMonth(2024, 2)); // Leap year\n    }\n\n    @Test\n    public void testGetDaysInMonthFebruaryNonLeapYear() {\n        assertEquals(28, getDaysInMonth(2023, 2)); // Non-leap year\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Returns the number of days in a given month of a given year.\n *\n * This method accounts for leap years when determining the number of\n * days in February. It throws an exception if the month is invalid.\n *\n * @param year The year to check (should be a positive integer).\n * @param month The month to check (1 for January, 12 for December).\n * @return int The number of days in the specified month of the specified year.\n * @throws IllegalArgumentException If the month is not between 1 and 12.\n */\npublic static int getDaysInMonth(int year, int month) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 597, "code_type": "method", "original_language": "c&cpp", "file_path": "DERCOASTER\\0d84c3aba95774285b343b1293d7f2239854789d\\rgb_effects.c\n", "question_type": "Algorithm and data structure", "summary": "According to the input hue value (hue), calculate the corresponding RGB color value (red, green, blue\uff09\n", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef hue_to_rgb(hue: float) -> Tuple[int, int, int]:\n    \"\"\"\n    Converts a hue value to its corresponding RGB color values.\n\n    Args:\n        hue (float): A float representing the hue angle in degrees,expected to be in the range [0, 360).\n\n    Returns:\n        Tuple[int, int, int]: A tuple containing three integers representing the RGB color components in the range [0, 255]. The first element is the red component, the second element is the green component, and the third element is the blue component.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_hue_0_red(self):\n        r, g, b = hue_to_rgb(0)\n        self.assertEqual(r, 255)\n        self.assertEqual(g, 0)\n        self.assertEqual(b, 0)\n\n    def test_hue_120_green(self):\n        r, g, b = hue_to_rgb(120)\n        self.assertEqual(r, 0)\n        self.assertEqual(g, 255)\n        self.assertEqual(b, 0)\n\n    def test_hue_240_blue(self):\n        r, g, b = hue_to_rgb(240)\n        self.assertEqual(r, 0)\n        self.assertEqual(g, 0)\n        self.assertEqual(b, 255)\n\n    def test_hue_60_yellow(self):\n        r, g, b = hue_to_rgb(60)\n        self.assertEqual(r, 255)\n        self.assertEqual(g, 255)\n        self.assertEqual(b, 0)\n\n    def test_hue_180_cyan(self):\n        r, g, b = hue_to_rgb(180)\n        self.assertEqual(r, 0)\n        self.assertEqual(g, 255)\n        self.assertEqual(b, 255)\n\n    def test_hue_300_magenta(self):\n        r, g, b = hue_to_rgb(300)\n        self.assertEqual(r, 255)\n        self.assertEqual(g, 0)\n        self.assertEqual(b, 255)\n", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef hue_to_rgb(hue: float) -> Tuple[int, int, int]:\n    \"\"\"\n    Converts a hue value to its corresponding RGB color values.\n\n    Args:\n        hue (float): A float representing the hue angle in degrees,expected to be in the range [0, 360).\n\n    Returns:\n        Tuple[int, int, int]: A tuple containing three integers representing the RGB color components in the range [0, 255]. The first element is the red component, the second element is the green component, and the third element is the blue component.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <tuple>\n#include <cmath>\n\n/**\n * Converts a hue value to its corresponding RGB color values.\n *\n * @param hue A float representing the hue angle in degrees,\n *            expected to be in the range [0, 360).\n *\n * @return A tuple containing three integers representing the\n *         RGB color components in the range [0, 255]. The\n *         first element is the red component, the second\n *         element is the green component, and the third element\n *         is the blue component.\n */\nstd::tuple<int, int, int> hueToRGB(float hue) {}", "test_code": "TEST_CASE(\"Hue to RGB Conversion Tests\") {\n    SECTION(\"Hue 0 (Red)\") {\n        auto [r, g, b] = hueToRGB(0);\n        REQUIRE(r == 255);\n        REQUIRE(g == 0);\n        REQUIRE(b == 0);\n    }\n\n    SECTION(\"Hue 120 (Green)\") {\n        auto [r, g, b] = hueToRGB(120);\n        REQUIRE(r == 0);\n        REQUIRE(g == 255);\n        REQUIRE(b == 0);\n    }\n\n    SECTION(\"Hue 240 (Blue)\") {\n        auto [r, g, b] = hueToRGB(240);\n        REQUIRE(r == 0);\n        REQUIRE(g == 0);\n        REQUIRE(b == 255);\n    }\n\n    SECTION(\"Hue 60 (Yellow)\") {\n        auto [r, g, b] = hueToRGB(60);\n        REQUIRE(r == 255);\n        REQUIRE(g == 255);\n        REQUIRE(b == 0);\n    }\n\n    SECTION(\"Hue 180 (Cyan)\") {\n        auto [r, g, b] = hueToRGB(180);\n        REQUIRE(r == 0);\n        REQUIRE(g == 255);\n        REQUIRE(b == 255);\n    }\n\n    SECTION(\"Hue 300 (Magenta)\") {\n        auto [r, g, b] = hueToRGB(300);\n        REQUIRE(r == 255);\n        REQUIRE(g == 0);\n        REQUIRE(b == 255);\n    }\n\n}", "prompt": "please write a cpp function , the function signature as below #include <tuple>\n#include <cmath>\n\n/**\n * Converts a hue value to its corresponding RGB color values.\n *\n * @param hue A float representing the hue angle in degrees,\n *            expected to be in the range [0, 360).\n *\n * @return A tuple containing three integers representing the\n *         RGB color components in the range [0, 255]. The\n *         first element is the red component, the second\n *         element is the green component, and the third element\n *         is the blue component.\n */\nstd::tuple<int, int, int> hueToRGB(float hue) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a hue value to its corresponding RGB color values.\n *\n * @param hue A float representing the hue angle in degrees,\n *            expected to be in the range [0, 360).\n *\n * @return An array containing three integers representing the\n *         RGB color components in the range [0, 255]. The\n *         first element is the red component, the second\n *         element is the green component, and the third element\n *         is the blue component.\n */\npublic static int[] hueToRGB(float hue) {}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\n\npublic class Tester {\n\n    @Test\n    public void testHueToRGB_Hue0_Red() {\n        int[] rgb = Answer.hueToRGB(0);\n        assertArrayEquals(new int[] {255, 0, 0}, rgb);\n    }\n\n    @Test\n    public void testHueToRGB_Hue120_Green() {\n        int[] rgb = Answer.hueToRGB(120);\n        assertArrayEquals(new int[] {0, 255, 0}, rgb);\n    }\n\n    @Test\n    public void testHueToRGB_Hue240_Blue() {\n        int[] rgb = Answer.hueToRGB(240);\n        assertArrayEquals(new int[] {0, 0, 255}, rgb);\n    }\n\n    @Test\n    public void testHueToRGB_Hue60_Yellow() {\n        int[] rgb = Answer.hueToRGB(60);\n        assertArrayEquals(new int[] {255, 255, 0}, rgb);\n    }\n\n    @Test\n    public void testHueToRGB_Hue180_Cyan() {\n        int[] rgb = Answer.hueToRGB(180);\n        assertArrayEquals(new int[] {0, 255, 255}, rgb);\n    }\n\n    @Test\n    public void testHueToRGB_Hue300_Magenta() {\n        int[] rgb = Answer.hueToRGB(300);\n        assertArrayEquals(new int[] {255, 0, 255}, rgb);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a hue value to its corresponding RGB color values.\n *\n * @param hue A float representing the hue angle in degrees,\n *            expected to be in the range [0, 360).\n *\n * @return An array containing three integers representing the\n *         RGB color components in the range [0, 255]. The\n *         first element is the red component, the second\n *         element is the green component, and the third element\n *         is the blue component.\n */\npublic static int[] hueToRGB(float hue) {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 598, "code_type": "class", "original_language": "c&cpp", "file_path": "DS_and_A\\69073cb2fcf6d9282896a4586c435685edf96754\\queues\\queue.c\n", "question_type": "Algorithm and data structure", "summary": "Using linked list to realize the queue of head and tail Pointers", "language_version_list": {"python": {"code_signature": "class Node:\n    def __init__(self, val):\n        self.data = val  # Data value of the node\n        self.next = None  # Pointer to the next node in the linked list\n\n# Queue class\nclass Queue:\n    def __init__(self):\n        self.head = None  # Pointer to the front of the queue\n        self.tail = None  # Pointer to the end of the queue\n\n    # Destructor to clean up the queue\n    def __del__(self):\n        while not self.is_empty():\n            self.dequeue()\n\n    # Function to check if the queue is empty\n    def is_empty(self):\n        pass\n\n    # Function to add an element to the end of the queue\n    def enqueue(self, value):\n        pass\n\n    # Function to remove and return the front element of the queue\n    def dequeue(self):\n        pass\n\n    # Function to get the front element without removing it\n    def front(self):\n        pass", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_queue_operations(self):\n        queue = Queue()\n\n        # Queue should be empty initially\n        self.assertTrue(queue.isEmpty(), \"Queue should be empty initially\")\n\n        # Enqueue elements\n        queue.enqueue(10)\n        queue.enqueue(20)\n        queue.enqueue(30)\n        self.assertFalse(queue.isEmpty(), \"Queue should not be empty after enqueuing elements\")\n        self.assertEqual(queue.front(), 10, \"Front element should be 10\")\n\n        # Dequeue elements\n        value = queue.dequeue()\n        self.assertEqual(value, 10, \"First dequeued element should be 10\")\n        self.assertEqual(queue.front(), 20, \"Now front should be 20\")\n\n        # Dequeue from an empty queue\n        queue.dequeue()  # Remove 20\n        queue.dequeue()  # Remove 30\n        value = queue.dequeue()\n        self.assertEqual(value, -1, \"Should indicate that the queue is empty\")\n\n        # Front element of an empty queue\n        frontValue = queue.front()\n        self.assertEqual(frontValue, -1, \"Should indicate that the queue is empty\")\n\n        # Queue should become empty after dequeuing all elements\n        queue.enqueue(10)\n        queue.enqueue(20)\n        queue.dequeue()  # Remove 10\n        queue.dequeue()  # Remove 20\n        self.assertTrue(queue.isEmpty(), \"Queue should be empty after dequeuing all elements\")", "prompt": "please write a python class , the class signature as below class Node:\n    def __init__(self, val):\n        self.data = val  # Data value of the node\n        self.next = None  # Pointer to the next node in the linked list\n\n# Queue class\nclass Queue:\n    def __init__(self):\n        self.head = None  # Pointer to the front of the queue\n        self.tail = None  # Pointer to the end of the queue\n\n    # Destructor to clean up the queue\n    def __del__(self):\n        while not self.is_empty():\n            self.dequeue()\n\n    # Function to check if the queue is empty\n    def is_empty(self):\n        pass\n\n    # Function to add an element to the end of the queue\n    def enqueue(self, value):\n        pass\n\n    # Function to remove and return the front element of the queue\n    def dequeue(self):\n        pass\n\n    # Function to get the front element without removing it\n    def front(self):\n        pass", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n\n// Node structure for linked list\nstruct Node {\n    int data;      // Data value of the node\n    Node* next;    // Pointer to the next node in the linked list\n\n    Node(int val) : data(val), next(nullptr) {} // Constructor to initialize the node\n};\n\n// Queue class\nclass Queue {\nprivate:\n    Node* head; // Pointer to the front of the queue\n    Node* tail; // Pointer to the end of the queue\n\npublic:\n    // Constructor to initialize the queue\n    Queue() : head(nullptr), tail(nullptr) {}\n\n    // Destructor to clean up the queue\n    ~Queue() {\n        while (!isEmpty()) {\n            dequeue();\n        }\n    }\n\n    // Function to check if the queue is empty\n    bool isEmpty() const {}\n\n    // Function to add an element to the end of the queue\n    void enqueue(int value) {}\n\n    // Function to remove and return the front element of the queue\n    int dequeue() {}\n\n    // Function to get the front element without removing it\n    int front() const {}\n};", "test_code": "// Test cases for the Queue class\nTEST_CASE(\"Queue Operations\", \"[Queue]\") {\n    Queue queue;\n\n    SECTION(\"Queue should be empty initially\") {\n        REQUIRE(queue.isEmpty() == true);\n    }\n\n    SECTION(\"Enqueue elements\") {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n\n        REQUIRE(queue.isEmpty() == false);\n        REQUIRE(queue.front() == 10); // Front element should be 10\n    }\n\n    SECTION(\"Dequeue elements\") {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n\n        int value = queue.dequeue();\n        REQUIRE(value == 10); // First dequeued element should be 10\n        REQUIRE(queue.front() == 20); // Now front should be 20\n    }\n\n    SECTION(\"Dequeue from an empty queue\") {\n        int value = queue.dequeue();\n        REQUIRE(value == -1); // Should indicate that the queue is empty\n    }\n\n    SECTION(\"Front element of an empty queue\") {\n        int frontValue = queue.front();\n        REQUIRE(frontValue == -1); // Should indicate that the queue is empty\n    }\n\n    SECTION(\"Queue should become empty after dequeuing all elements\") {\n        queue.enqueue(10);\n        queue.enqueue(20);\n\n        queue.dequeue(); // Remove 10\n        queue.dequeue(); // Remove 20\n\n        REQUIRE(queue.isEmpty() == true); // Queue should be empty\n    }\n}", "prompt": "please write a cpp class , the class signature as below #include <iostream>\n\n// Node structure for linked list\nstruct Node {\n    int data;      // Data value of the node\n    Node* next;    // Pointer to the next node in the linked list\n\n    Node(int val) : data(val), next(nullptr) {} // Constructor to initialize the node\n};\n\n// Queue class\nclass Queue {\nprivate:\n    Node* head; // Pointer to the front of the queue\n    Node* tail; // Pointer to the end of the queue\n\npublic:\n    // Constructor to initialize the queue\n    Queue() : head(nullptr), tail(nullptr) {}\n\n    // Destructor to clean up the queue\n    ~Queue() {\n        while (!isEmpty()) {\n            dequeue();\n        }\n    }\n\n    // Function to check if the queue is empty\n    bool isEmpty() const {}\n\n    // Function to add an element to the end of the queue\n    void enqueue(int value) {}\n\n    // Function to remove and return the front element of the queue\n    int dequeue() {}\n\n    // Function to get the front element without removing it\n    int front() const {}\n};", "addition_info": "struct Node {\n    int data;      // Data value of the node\n    Node* next;    // Pointer to the next node in the linked list\n\n    Node(int val) : data(val), next(nullptr) {} // Constructor to initialize the node\n};"}, "java": {"code_signature": "/**\n * Node class for linked list.\n */\nclass Node {\n    int data;      // Data value of the node\n    Node next;     // Reference to the next node in the linked list\n\n    /**\n     * Constructor to initialize the node.\n     *\n     * @param val the value to initialize the node with\n     */\n    Node(int val) {\n        this.data = val;\n        this.next = null;\n    }\n}\n\n/**\n * Queue class.\n */\npublic class Queue {\n    private Node head; // Reference to the front of the queue\n    private Node tail; // Reference to the end of the queue\n\n    /**\n     * Constructor to initialize the queue.\n     */\n    public Queue() {\n        this.head = null;\n        this.tail = null;\n    }\n\n    /**\n     * Destructor to clean up the queue.\n     * (Note: Not needed in Java due to garbage collection)\n     */\n    // Java does not have destructors, so this part is omitted.\n\n    /**\n     * Function to check if the queue is empty.\n     *\n     * @return true if the queue is empty, false otherwise\n     */\n    public boolean isEmpty() {\n    }\n\n    /**\n     * Function to add an element to the end of the queue.\n     *\n     * @param value the value to add to the queue\n     */\n    public void enqueue(int value) {}\n\n    /**\n     * Function to remove and return the front element of the queue.\n     *\n     * @return the dequeued value\n     */\n    public int dequeue() {}\n\n    /**\n     * Function to get the front element without removing it.\n     *\n     * @return the front value\n     */\n    public int front() {}\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\npublic class Tester {\n    private Queue queue;\n\n    @Before\n    public void setUp() {\n        queue = new Queue(); // Initialize the queue before each test\n    }\n\n    @Test\n    public void testInitialQueueIsEmpty() {\n        assertTrue(\"Queue should be empty initially\", queue.isEmpty());\n    }\n\n    @Test\n    public void testEnqueueElements() {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n\n        assertFalse(\"Queue should not be empty after enqueue\", queue.isEmpty());\n        assertEquals(\"Front element should be 10\", 10, queue.front());\n    }\n\n    @Test\n    public void testDequeueElements() {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n\n        int value = queue.dequeue();\n        assertEquals(\"First dequeued element should be 10\", 10, value);\n        assertEquals(\"Now front should be 20\", 20, queue.front());\n    }\n\n    @Test\n    public void testDequeueFromEmptyQueue() {\n        int value = queue.dequeue();\n        assertEquals(\"Should indicate that the queue is empty\", -1, value);\n    }\n\n    @Test\n    public void testFrontElementOfEmptyQueue() {\n        int frontValue = queue.front();\n        assertEquals(\"Should indicate that the queue is empty\", -1, frontValue);\n    }\n\n    @Test\n    public void testQueueBecomesEmptyAfterDequeueingAllElements() {\n        queue.enqueue(10);\n        queue.enqueue(20);\n\n        queue.dequeue(); // Remove 10\n        queue.dequeue(); // Remove 20\n\n        assertTrue(\"Queue should be empty after dequeuing all elements\", queue.isEmpty());\n    }\n}", "prompt": "please write a java class , the function signature as below /**\n * Node class for linked list.\n */\nclass Node {\n    int data;      // Data value of the node\n    Node next;     // Reference to the next node in the linked list\n\n    /**\n     * Constructor to initialize the node.\n     *\n     * @param val the value to initialize the node with\n     */\n    Node(int val) {\n        this.data = val;\n        this.next = null;\n    }\n}\n\n/**\n * Queue class.\n */\npublic class Queue {\n    private Node head; // Reference to the front of the queue\n    private Node tail; // Reference to the end of the queue\n\n    /**\n     * Constructor to initialize the queue.\n     */\n    public Queue() {\n        this.head = null;\n        this.tail = null;\n    }\n\n    /**\n     * Destructor to clean up the queue.\n     * (Note: Not needed in Java due to garbage collection)\n     */\n    // Java does not have destructors, so this part is omitted.\n\n    /**\n     * Function to check if the queue is empty.\n     *\n     * @return true if the queue is empty, false otherwise\n     */\n    public boolean isEmpty() {\n    }\n\n    /**\n     * Function to add an element to the end of the queue.\n     *\n     * @param value the value to add to the queue\n     */\n    public void enqueue(int value) {}\n\n    /**\n     * Function to remove and return the front element of the queue.\n     *\n     * @return the dequeued value\n     */\n    public int dequeue() {}\n\n    /**\n     * Function to get the front element without removing it.\n     *\n     * @return the front value\n     */\n    public int front() {}\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 599, "code_type": "class", "original_language": "c&cpp", "file_path": "DS_and_A\\22c1517527aeaa06e6a2d5925dfd9ff93aa83a7c\\heap\\max_heap.c\n", "question_type": "Algorithm and data structure", "summary": "Implement large root heap", "language_version_list": {"python": {"code_signature": "class MaxHeap:\n    def __init__(self):\n        self.heap = []  # List to store heap elements\n\n    # Helper function to maintain the max heap property\n    def heapify_up(self, index):\n        pass\n\n    # Helper function to maintain the max heap property after deletion\n    def heapify_down(self, index):\n        pass\n\n    # Insert a new element into the heap\n    def insert(self, value):\n        pass\n\n    # Remove and return the maximum element from the heap\n    def extract_max(self):\n        pass\n\n    # Get the maximum element without removing it\n    def get_max(self):\n        pass\n\n    # Check if the heap is empty\n    def is_empty(self):\n        pass\n\n    # Get the size of the heap\n    def size(self):\n        pass", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create a new instance of MaxHeap before each test.\"\"\"\n        self.maxHeap = MaxHeap()\n\n    def test_initial_state_of_the_heap(self):\n        \"\"\"Test the initial state of the heap.\"\"\"\n        self.assertTrue(self.maxHeap.isEmpty())\n        self.assertEqual(self.maxHeap.size(), 0)\n\n    def test_insert_elements_into_the_heap(self):\n        \"\"\"Test inserting elements into the heap.\"\"\"\n        self.maxHeap.insert(10)\n        self.maxHeap.insert(20)\n        self.maxHeap.insert(5)\n        self.assertFalse(self.maxHeap.isEmpty())\n        self.assertEqual(self.maxHeap.size(), 3)\n        self.assertEqual(self.maxHeap.getMax(), 20)  # The maximum should be 20\n\n    def test_extract_maximum_element_from_the_heap(self):\n        \"\"\"Test extracting the maximum element from the heap.\"\"\"\n        self.maxHeap.insert(10)\n        self.maxHeap.insert(30)\n        self.maxHeap.insert(20)\n\n        maxElement = self.maxHeap.extractMax()\n        self.assertEqual(maxElement, 30)  # The maximum extracted should be 30\n        self.assertEqual(self.maxHeap.getMax(), 20)  # The next maximum should be 20\n        self.assertEqual(self.maxHeap.size(), 2)  # Size should be 2 after extraction\n\n    def test_heap_property_after_multiple_operations(self):\n        \"\"\"Test that the heap maintains max heap property after multiple operations.\"\"\"\n        self.maxHeap.insert(15)\n        self.maxHeap.insert(10)\n        self.maxHeap.insert(30)\n        self.maxHeap.insert(20)\n        self.maxHeap.insert(25)\n\n        # Current max should be 30\n        self.assertEqual(self.maxHeap.getMax(), 30)\n        self.maxHeap.extractMax()  # Remove 30\n\n        # After removal, the new max should be 25\n        self.assertEqual(self.maxHeap.getMax(), 25)\n        self.maxHeap.extractMax()  # Remove 25\n\n        # After removal, the new max should be 20\n        self.assertEqual(self.maxHeap.getMax(), 20)\n\n        # The size of the heap should be 3 now\n        self.assertEqual(self.maxHeap.size(), 3)\n", "prompt": "please write a python class , the class signature as below class MaxHeap:\n    def __init__(self):\n        self.heap = []  # List to store heap elements\n\n    # Helper function to maintain the max heap property\n    def heapify_up(self, index):\n        pass\n\n    # Helper function to maintain the max heap property after deletion\n    def heapify_down(self, index):\n        pass\n\n    # Insert a new element into the heap\n    def insert(self, value):\n        pass\n\n    # Remove and return the maximum element from the heap\n    def extract_max(self):\n        pass\n\n    # Get the maximum element without removing it\n    def get_max(self):\n        pass\n\n    # Check if the heap is empty\n    def is_empty(self):\n        pass\n\n    # Get the size of the heap\n    def size(self):\n        pass", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass MaxHeap {\nprivate:\n    std::vector<int> heap; // Vector to store heap elements\n\n    // Helper function to maintain the max heap property\n    void heapifyUp(int index) {}\n\n    // Helper function to maintain the max heap property after deletion\n    void heapifyDown(int index) {}\n\npublic:\n    // Insert a new element into the heap\n    void insert(int value) {}\n\n    // Remove and return the maximum element from the heap\n    int extractMax() {}\n\n    // Get the maximum element without removing it\n    int getMax() const {}\n\n    // Check if the heap is empty\n    bool isEmpty() const {}\n\n    // Get the size of the heap\n    size_t size() const {}\n\n}", "test_code": "TEST_CASE(\"MaxHeap Operations\", \"[MaxHeap]\") {\n    MaxHeap maxHeap;\n\n    SECTION(\"Initial state of the heap\") {\n        REQUIRE(maxHeap.isEmpty() == true);\n        REQUIRE(maxHeap.size() == 0);\n    }\n\n    SECTION(\"Insert elements into the heap\") {\n        maxHeap.insert(10);\n        maxHeap.insert(20);\n        maxHeap.insert(5);\n\n        REQUIRE(maxHeap.isEmpty() == false);\n        REQUIRE(maxHeap.size() == 3);\n        REQUIRE(maxHeap.getMax() == 20); // The maximum should be 20\n    }\n\n    SECTION(\"Extract maximum element from the heap\") {\n        maxHeap.insert(10);\n        maxHeap.insert(30);\n        maxHeap.insert(20);\n\n        int maxElement = maxHeap.extractMax();\n        REQUIRE(maxElement == 30); // The maximum extracted should be 30\n        REQUIRE(maxHeap.getMax() == 20); // The next maximum should be 20\n        REQUIRE(maxHeap.size() == 2); // Size should be 2 after extraction\n    }\n\n    SECTION(\"Heap should maintain max heap property after multiple operations\") {\n        maxHeap.insert(15);\n        maxHeap.insert(10);\n        maxHeap.insert(30);\n        maxHeap.insert(20);\n        maxHeap.insert(25);\n\n        // Current max should be 30\n        REQUIRE(maxHeap.getMax() == 30);\n\n        maxHeap.extractMax(); // Remove 30\n        // After removal, the new max should be 25\n        REQUIRE(maxHeap.getMax() == 25);\n\n        maxHeap.extractMax(); // Remove 25\n        // After removal, the new max should be 20\n        REQUIRE(maxHeap.getMax() == 20);\n\n        // The size of the heap should be 3 now\n        REQUIRE(maxHeap.size() == 3);\n    }\n}", "prompt": "please write a cpp class , the class signature as below #include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass MaxHeap {\nprivate:\n    std::vector<int> heap; // Vector to store heap elements\n\n    // Helper function to maintain the max heap property\n    void heapifyUp(int index) {}\n\n    // Helper function to maintain the max heap property after deletion\n    void heapifyDown(int index) {}\n\npublic:\n    // Insert a new element into the heap\n    void insert(int value) {}\n\n    // Remove and return the maximum element from the heap\n    int extractMax() {}\n\n    // Get the maximum element without removing it\n    int getMax() const {}\n\n    // Check if the heap is empty\n    bool isEmpty() const {}\n\n    // Get the size of the heap\n    size_t size() const {}\n\n}", "addition_info": ""}, "java": {"code_signature": "public class MaxHeap {\n    private List<Integer> heap;\n\n    /**\n     * Constructor to initialize the heap.\n     */\n    public MaxHeap() {\n        heap = new ArrayList<>();\n    }\n\n    /**\n     * Helper function to maintain the max heap property.\n     *\n     * @param index The index of the element to heapify up.\n     */\n    private void heapifyUp(int index) {\n    }\n\n    /**\n     * Helper function to maintain the max heap property after deletion.\n     *\n     * @param index The index of the element to heapify down.\n     */\n    private void heapifyDown(int index) {\n    }\n\n    /**\n     * Inserts a new element into the heap.\n     *\n     * @param value The value to be inserted.\n     */\n    public void insert(int value) {\n\n    }\n\n    /**\n     * Removes and returns the maximum element from the heap.\n     *\n     * @return The maximum element in the heap.\n     * @throws IllegalStateException if the heap is empty.\n     */\n    public int extractMax() {\n    }\n\n    /**\n     * Gets the maximum element without removing it.\n     *\n     * @return The maximum element in the heap.\n     * @throws IllegalStateException if the heap is empty.\n     */\n    public int getMax() {\n\n    }\n\n    /**\n     * Checks if the heap is empty.\n     *\n     * @return true if the heap is empty, false otherwise.\n     */\n    public boolean isEmpty() {\n    }\n\n    /**\n     * Gets the size of the heap.\n     *\n     * @return The number of elements in the heap.\n     */\n    public int size() {\n    }\n\n    /**\n     * Swaps two elements in the heap.\n     *\n     * @param index1 The index of the first element.\n     * @param index2 The index of the second element.\n     */\n    private void swap(int index1, int index2) {\n\n    }\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Tester class to validate the functionality of MaxHeap.\n */\npublic class Tester {\n    private MaxHeap maxHeap;\n\n    /**\n     * Set up a new MaxHeap instance before each test.\n     */\n    @Before\n    public void setUp() {\n        maxHeap = new MaxHeap();\n    }\n\n    /**\n     * Test the initial state of the heap.\n     */\n    @Test\n    public void testInitialState() {\n        assertTrue(maxHeap.isEmpty());\n        assertEquals(0, maxHeap.size());\n    }\n\n    /**\n     * Test inserting elements into the heap.\n     */\n    @Test\n    public void testInsertElements() {\n        maxHeap.insert(10);\n        maxHeap.insert(20);\n        maxHeap.insert(5);\n\n        assertFalse(maxHeap.isEmpty());\n        assertEquals(3, maxHeap.size());\n        assertEquals(20, maxHeap.getMax()); // The maximum should be 20\n    }\n\n    /**\n     * Test extracting the maximum element from the heap.\n     */\n    @Test\n    public void testExtractMax() {\n        maxHeap.insert(10);\n        maxHeap.insert(30);\n        maxHeap.insert(20);\n\n        int maxElement = maxHeap.extractMax();\n        assertEquals(30, maxElement); // The maximum extracted should be 30\n        assertEquals(20, maxHeap.getMax()); // The next maximum should be 20\n        assertEquals(2, maxHeap.size()); // Size should be 2 after extraction\n    }\n\n    /**\n     * Test that the heap maintains the max heap property after multiple operations.\n     */\n    @Test\n    public void testMaxHeapProperty() {\n        maxHeap.insert(15);\n        maxHeap.insert(10);\n        maxHeap.insert(30);\n        maxHeap.insert(20);\n        maxHeap.insert(25);\n\n        // Current max should be 30\n        assertEquals(30, maxHeap.getMax());\n\n        maxHeap.extractMax(); // Remove 30\n        // After removal, the new max should be 25\n        assertEquals(25, maxHeap.getMax());\n\n        maxHeap.extractMax(); // Remove 25\n        // After removal, the new max should be 20\n        assertEquals(20, maxHeap.getMax());\n\n        // The size of the heap should be 3 now\n        assertEquals(3, maxHeap.size());\n    }\n}", "prompt": "please write a java class , the function signature as below public class MaxHeap {\n    private List<Integer> heap;\n\n    /**\n     * Constructor to initialize the heap.\n     */\n    public MaxHeap() {\n        heap = new ArrayList<>();\n    }\n\n    /**\n     * Helper function to maintain the max heap property.\n     *\n     * @param index The index of the element to heapify up.\n     */\n    private void heapifyUp(int index) {\n    }\n\n    /**\n     * Helper function to maintain the max heap property after deletion.\n     *\n     * @param index The index of the element to heapify down.\n     */\n    private void heapifyDown(int index) {\n    }\n\n    /**\n     * Inserts a new element into the heap.\n     *\n     * @param value The value to be inserted.\n     */\n    public void insert(int value) {\n\n    }\n\n    /**\n     * Removes and returns the maximum element from the heap.\n     *\n     * @return The maximum element in the heap.\n     * @throws IllegalStateException if the heap is empty.\n     */\n    public int extractMax() {\n    }\n\n    /**\n     * Gets the maximum element without removing it.\n     *\n     * @return The maximum element in the heap.\n     * @throws IllegalStateException if the heap is empty.\n     */\n    public int getMax() {\n\n    }\n\n    /**\n     * Checks if the heap is empty.\n     *\n     * @return true if the heap is empty, false otherwise.\n     */\n    public boolean isEmpty() {\n    }\n\n    /**\n     * Gets the size of the heap.\n     *\n     * @return The number of elements in the heap.\n     */\n    public int size() {\n    }\n\n    /**\n     * Swaps two elements in the heap.\n     *\n     * @param index1 The index of the first element.\n     * @param index2 The index of the second element.\n     */\n    private void swap(int index1, int index2) {\n\n    }\n},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 601, "code_type": "method", "original_language": "c&cpp", "file_path": "CS360-F23-ClassRepo\\9c9817fa040663280681503557ea09e578b97b85\\c-lang\\wordcount.c", "question_type": "Data processing and transformation", "summary": "Count the number of words in a string", "language_version_list": {"python": {"code_signature": "def count_words(s: str) -> int:\n    \"\"\"\n    Count the number of words in a given string.\n\n    A word is defined as a sequence of characters separated by whitespace.\n    This function handles leading and trailing whitespace, as well as\n    multiple spaces between words.\n\n    Args:\n        s (str): The input string in which words are to be counted.\n\n    Returns:\n        int: The count of words in the input string.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestWordCount(unittest.TestCase):\n    def test_count_words(self):\n        # Test cases for count_words\n        self.assertEqual(tester.count_words(\"\"), 0)  # Empty string\n        self.assertEqual(tester.count_words(\"     \"), 0)  # String with only spaces\n        self.assertEqual(tester.count_words(\"Hello\"), 1)  # Single word\n        self.assertEqual(tester.count_words(\"This is a test string\"), 5)  # Multiple words with single spaces\n        self.assertEqual(tester.count_words(\"This    is   a   test   string\"), 5)  # Multiple spaces between words\n        self.assertEqual(tester.count_words(\"   Hello world!   \"), 2)  # Leading and trailing spaces\n", "prompt": "please write a python function , the function signature as below def count_words(s: str) -> int:\n    \"\"\"\n    Count the number of words in a given string.\n\n    A word is defined as a sequence of characters separated by whitespace.\n    This function handles leading and trailing whitespace, as well as\n    multiple spaces between words.\n\n    Args:\n        s (str): The input string in which words are to be counted.\n\n    Returns:\n        int: The count of words in the input string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <sstream>\n#include <string>\n\n/**\n * @brief Counts the number of words in a given string.\n *\n * A word is defined as a sequence of characters separated by whitespace.\n * This function handles leading and trailing whitespace, as well as\n * multiple spaces between words.\n *\n * @param str The input string in which words are to be counted.\n * @return int The count of words in the input string.\n */\nint countWords(const std::string &str) {}", "test_code": "// Test cases\nTEST_CASE(\"Count words in various strings\") {\n    SECTION(\"Empty string\") {\n        REQUIRE(countWords(\"\") == 0);\n    }\n\n    SECTION(\"String with only spaces\") {\n        REQUIRE(countWords(\"     \") == 0);\n    }\n\n    SECTION(\"Single word\") {\n        REQUIRE(countWords(\"Hello\") == 1);\n    }\n\n    SECTION(\"Multiple words with single spaces\") {\n        REQUIRE(countWords(\"This is a test string\") == 5);\n    }\n\n    SECTION(\"Multiple spaces between words\") {\n        REQUIRE(countWords(\"This    is   a   test   string\") == 5);\n    }\n\n    SECTION(\"Leading and trailing spaces\") {\n        REQUIRE(countWords(\"   Hello world!   \") == 2);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <sstream>\n#include <string>\n\n/**\n * @brief Counts the number of words in a given string.\n *\n * A word is defined as a sequence of characters separated by whitespace.\n * This function handles leading and trailing whitespace, as well as\n * multiple spaces between words.\n *\n * @param str The input string in which words are to be counted.\n * @return int The count of words in the input string.\n */\nint countWords(const std::string &str) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Counts the number of words in a given string.\n *\n * A word is defined as a sequence of characters separated by whitespace.\n * This method handles leading and trailing whitespace, as well as\n * multiple spaces between words.\n *\n * @param str The input string in which words are to be counted.\n * @return int The count of words in the input string.\n */\npublic static int countWords(String str) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testCountWordsInVariousStrings() {\n        // Empty string\n        assertEquals(0, Answer.countWords(\"\"));\n\n        // String with only spaces\n        assertEquals(0, Answer.countWords(\"     \"));\n\n        // Single word\n        assertEquals(1, Answer.countWords(\"Hello\"));\n\n        // Multiple words with single spaces\n        assertEquals(5, Answer.countWords(\"This is a test string\"));\n\n        // Multiple spaces between words\n        assertEquals(5, Answer.countWords(\"This    is   a   test   string\"));\n\n        // Leading and trailing spaces\n        assertEquals(2, Answer.countWords(\"   Hello world!   \"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Counts the number of words in a given string.\n *\n * A word is defined as a sequence of characters separated by whitespace.\n * This method handles leading and trailing whitespace, as well as\n * multiple spaces between words.\n *\n * @param str The input string in which words are to be counted.\n * @return int The count of words in the input string.\n */\npublic static int countWords(String str) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 603, "code_type": "method", "original_language": "c&cpp", "file_path": "c4yourself\\83ed77d1bcc0073d3a2f9e686af54cc19acef054\\GCC\\leapyear.c\n", "question_type": "Scientific computation and numerical analysis", "summary": "Test whether a year is a leap year or a normal year\n", "language_version_list": {"python": {"code_signature": "def is_leap_year(year: int) -> bool:\n    \"\"\"\n    Check if a given year is a leap year.\n\n    A year is a leap year if:\n    1. It is divisible by 4 AND\n    2. It is NOT divisible by 100, OR it is divisible by 400.\n\n    Args:\n        year (int): The year to check.\n\n    Returns:\n        bool: True if the year is a leap year, False otherwise.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    \"\"\" Test cases for the leap year function. \"\"\"\n\n    def test_divisible_by_4_but_not_by_100(self):\n        \"\"\" Years that are leap years. \"\"\"\n        self.assertTrue(is_leap_year(2024))  # 2024 is a leap year\n        self.assertTrue(is_leap_year(2000))  # 2000 is a leap year (divisible by 400)\n        self.assertTrue(is_leap_year(1996))  # 1996 is a leap year\n        self.assertTrue(is_leap_year(2004))  # 2004 is a leap year\n\n    def test_divisible_by_100_but_not_by_400(self):\n        \"\"\" Years that are not leap years. \"\"\"\n        self.assertFalse(is_leap_year(1900))  # 1900 is not a leap year\n        self.assertFalse(is_leap_year(2100))  # 2100 is not a leap year\n        self.assertFalse(is_leap_year(1800))  # 1800 is not a leap year\n\n    def test_divisible_by_400(self):\n        \"\"\" Years that are leap years. \"\"\"\n        self.assertTrue(is_leap_year(2400))  # 2400 is a leap year\n        self.assertTrue(is_leap_year(1600))  # 1600 is a leap year\n\n    def test_normal_years(self):\n        \"\"\" Years that are normal years. \"\"\"\n        self.assertFalse(is_leap_year(1997))  # 1997 is not a leap year\n        self.assertFalse(is_leap_year(1998))  # 1998 is not a leap year\n        self.assertFalse(is_leap_year(1999))  # 1999 is not a leap year\n", "prompt": "please write a python function , the function signature as below def is_leap_year(year: int) -> bool:\n    \"\"\"\n    Check if a given year is a leap year.\n\n    A year is a leap year if:\n    1. It is divisible by 4 AND\n    2. It is NOT divisible by 100, OR it is divisible by 400.\n\n    Args:\n        year (int): The year to check.\n\n    Returns:\n        bool: True if the year is a leap year, False otherwise.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n\n/**\n * @brief Checks if a given year is a leap year.\n *\n * @param year The year to check.\n * @return True if the year is a leap year, false otherwise.\n */\nbool isLeapYear(int year) {}", "test_code": "TEST_CASE(\"Leap Year Test Cases\") {\n    SECTION(\"Divisible by 4 but not by 100\") {\n        // Years that are leap years\n        REQUIRE(isLeapYear(2024) == true); // 2024 is a leap year\n        REQUIRE(isLeapYear(2000) == true); // 2000 is a leap year (divisible by 400)\n        REQUIRE(isLeapYear(1996) == true); // 1996 is a leap year\n        REQUIRE(isLeapYear(2004) == true); // 2004 is a leap year\n    }\n\n    SECTION(\"Divisible by 100 but not by 400\") {\n        // Years that are not leap years\n        REQUIRE(isLeapYear(1900) == false); // 1900 is not a leap year\n        REQUIRE(isLeapYear(2100) == false); // 2100 is not a leap year\n        REQUIRE(isLeapYear(1800) == false); // 1800 is not a leap year\n    }\n\n    SECTION(\"Divisible by 400\") {\n        // Years that are leap years\n        REQUIRE(isLeapYear(2400) == true); // 2400 is a leap year\n        REQUIRE(isLeapYear(1600) == true); // 1600 is a leap year\n    }\n\n    SECTION(\"Normal years\") {\n        // Years that are normal years\n        REQUIRE(isLeapYear(1997) == false); // 1997 is not a leap year\n        REQUIRE(isLeapYear(1998) == false); // 1998 is not a leap year\n        REQUIRE(isLeapYear(1999) == false); // 1999 is not a leap year\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n\n/**\n * @brief Checks if a given year is a leap year.\n *\n * @param year The year to check.\n * @return True if the year is a leap year, false otherwise.\n */\nbool isLeapYear(int year) {}", "addition_info": ""}, "java": {"code_signature": "\n/**\n * Checks if a given year is a leap year.\n *\n * @param year The year to check.\n * @return True if the year is a leap year, false otherwise.\n */\n\npublic static boolean isLeapYear(int year) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testLeapYearDivisibleBy4NotBy100() {\n        // Years that are leap years\n        assertTrue(isLeapYear(2024)); // 2024 is a leap year\n        assertTrue(isLeapYear(2000)); // 2000 is a leap year (divisible by 400)\n        assertTrue(isLeapYear(1996)); // 1996 is a leap year\n        assertTrue(isLeapYear(2004)); // 2004 is a leap year\n    }\n\n    @Test\n    public void testLeapYearDivisibleBy100NotBy400() {\n        // Years that are not leap years\n        assertFalse(isLeapYear(1900)); // 1900 is not a leap year\n        assertFalse(isLeapYear(2100)); // 2100 is not a leap year\n        assertFalse(isLeapYear(1800)); // 1800 is not a leap year\n    }\n\n    @Test\n    public void testLeapYearDivisibleBy400() {\n        // Years that are leap years\n        assertTrue(isLeapYear(2400)); // 2400 is a leap year\n        assertTrue(isLeapYear(1600)); // 1600 is a leap year\n    }\n\n    @Test\n    public void testNormalYears() {\n        // Years that are normal years\n        assertFalse(isLeapYear(1997)); // 1997 is not a leap year\n        assertFalse(isLeapYear(1998)); // 1998 is not a leap year\n        assertFalse(isLeapYear(1999)); // 1999 is not a leap year\n    }\n}", "prompt": "please write a java function , the function signature as below \n/**\n * Checks if a given year is a leap year.\n *\n * @param year The year to check.\n * @return True if the year is a leap year, false otherwise.\n */\n\npublic static boolean isLeapYear(int year) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 604, "code_type": "method", "original_language": "c&cpp", "file_path": "Duke-ECE-551\\a8f52255e06d04d606aab7af4de5642a6592e5fc\\ece551\\029_power_rec\\power.c\n", "question_type": "Scientific computation and numerical analysis", "summary": "Tail-recursive function to calculate x raised to the power y.", "language_version_list": {"python": {"code_signature": "def power_tail(x: int, y: int, acc: int = 1) -> int:\n    \"\"\"\n    Tail-recursive function to calculate x raised to the power y.\n\n    Args:\n        x (int): The base, a non-negative integer.\n        y (int): The exponent, a non-negative integer.\n        acc (int): The accumulator to hold the intermediate result.\n\n    Returns:\n        int: The result of x raised to the power of y.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    def test_base_cases(self):\n        # Test 0^0, should return 1 (by convention)\n        self.assertEqual(power_tail(0, 0), 1)\n        # Test x^0 for any x, should return 1\n        self.assertEqual(power_tail(5, 0), 1)\n        self.assertEqual(power_tail(12345, 0), 1)\n\n    def test_power_of_one(self):\n        # Test 1^y for any y, should return 1\n        self.assertEqual(power_tail(1, 5), 1)\n        self.assertEqual(power_tail(1, 123), 1)\n\n    def test_power_of_zero(self):\n        # Test 0^y for any y > 0, should return 0\n        self.assertEqual(power_tail(0, 5), 0)\n        self.assertEqual(power_tail(0, 100), 0)\n\n    def test_positive_powers(self):\n        # Test some positive powers\n        self.assertEqual(power_tail(2, 3), 8)   # 2^3 = 8\n        self.assertEqual(power_tail(3, 4), 81)  # 3^4 = 81\n        self.assertEqual(power_tail(5, 2), 25)  # 5^2 = 25\n", "prompt": "please write a python function , the function signature as below def power_tail(x: int, y: int, acc: int = 1) -> int:\n    \"\"\"\n    Tail-recursive function to calculate x raised to the power y.\n\n    Args:\n        x (int): The base, a non-negative integer.\n        y (int): The exponent, a non-negative integer.\n        acc (int): The accumulator to hold the intermediate result.\n\n    Returns:\n        int: The result of x raised to the power of y.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n\n/**\n * @brief Tail-recursive function to calculate x raised to the power y.\n *\n * This function uses tail recursion to compute x^y.\n *\n * @param x The base, a non-negative integer.\n * @param y The exponent, a non-negative integer.\n * @param acc The accumulator to hold the intermediate result.\n *\n * @return The result of x raised to the power of y.\n */\nunsigned power_tail(unsigned x, unsigned y, unsigned acc = 1) {}", "test_code": "\nTEST_CASE(\"Power function test cases\") {\n    SECTION(\"Base cases\") {\n        // Test 0^0, should return 1 (by convention)\n        REQUIRE(power_tail(0, 0) == 1);\n\n        // Test x^0 for any x, should return 1\n        REQUIRE(power_tail(5, 0) == 1);\n        REQUIRE(power_tail(12345, 0) == 1);\n    }\n\n    SECTION(\"Power of one\") {\n        // Test 1^y for any y, should return 1\n        REQUIRE(power_tail(1, 5) == 1);\n        REQUIRE(power_tail(1, 123) == 1);\n    }\n\n    SECTION(\"Power of zero\") {\n        // Test 0^y for any y > 0, should return 0\n        REQUIRE(power_tail(0, 5) == 0);\n        REQUIRE(power_tail(0, 100) == 0);\n    }\n\n    SECTION(\"Positive powers\") {\n        // Test some positive powers\n        REQUIRE(power_tail(2, 3) == 8);     // 2^3 = 8\n        REQUIRE(power_tail(3, 4) == 81);    // 3^4 = 81\n        REQUIRE(power_tail(5, 2) == 25);     // 5^2 = 25\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n\n/**\n * @brief Tail-recursive function to calculate x raised to the power y.\n *\n * This function uses tail recursion to compute x^y.\n *\n * @param x The base, a non-negative integer.\n * @param y The exponent, a non-negative integer.\n * @param acc The accumulator to hold the intermediate result.\n *\n * @return The result of x raised to the power of y.\n */\nunsigned power_tail(unsigned x, unsigned y, unsigned acc = 1) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Tail-recursive function to calculate x raised to the power y.\n *\n * This function uses tail recursion to compute x^y.\n *\n * @param x The base, a non-negative integer.\n * @param y The exponent, a non-negative integer.\n * @param acc The accumulator to hold the intermediate result.\n *\n * @return The result of x raised to the power of y.\n */\npublic static long powerTail(long x, long y, long acc) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\n/**\n * Power function test cases.\n */\npublic class Tester {\n\n    @Test\n    public void testBaseCases() {\n        // Test 0^0, should return 1 (by convention)\n        assertEquals(1, Answer.powerTail(0, 0, 1));\n\n        // Test x^0 for any x, should return 1\n        assertEquals(1, Answer.powerTail(5, 0, 1));\n        assertEquals(1, Answer.powerTail(12345, 0, 1));\n    }\n\n    @Test\n    public void testPowerOfOne() {\n        // Test 1^y for any y, should return 1\n        assertEquals(1, Answer.powerTail(1, 5, 1));\n        assertEquals(1, Answer.powerTail(1, 123, 1));\n    }\n\n    @Test\n    public void testPowerOfZero() {\n        // Test 0^y for any y > 0, should return 0\n        assertEquals(0, Answer.powerTail(0, 5, 1));\n        assertEquals(0, Answer.powerTail(0, 100, 1));\n    }\n\n    @Test\n    public void testPositivePowers() {\n        // Test some positive powers\n        assertEquals(8, Answer.powerTail(2, 3, 1));     // 2^3 = 8\n        assertEquals(81, Answer.powerTail(3, 4, 1));    // 3^4 = 81\n        assertEquals(25, Answer.powerTail(5, 2, 1));     // 5^2 = 25\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Tail-recursive function to calculate x raised to the power y.\n *\n * This function uses tail recursion to compute x^y.\n *\n * @param x The base, a non-negative integer.\n * @param y The exponent, a non-negative integer.\n * @param acc The accumulator to hold the intermediate result.\n *\n * @return The result of x raised to the power of y.\n */\npublic static long powerTail(long x, long y, long acc) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 605, "code_type": "method", "original_language": "c&cpp", "file_path": "Proyecto_Menu\\5372f90d1dd4ea6ca571346d75a1aebc92d24685\\Usuario.h\n", "question_type": "Scientific computation and numerical analysis", "summary": "calculate BMI\n", "language_version_list": {"python": {"code_signature": "def calculate_bmi(weight: float, height: float) -> float:\n    \"\"\"\n    Calculates the Body Mass Index (BMI) based on weight and height.\n    Args:\n        weight (float): The weight of the individual in kilograms.\n        height (float): The height of the individual in meters.\n\n    Returns:\n        float: The calculated BMI value as a float.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    # Test case for valid inputs with expected BMI value\n    def test_valid_bmi_calculations(self):\n        # Normal weight\n        self.assertAlmostEqual(calculate_bmi(70, 1.75), 22.86, delta=0.01)  # 70 kg, 1.75 m\n\n        # Underweight\n        self.assertAlmostEqual(calculate_bmi(50, 1.75), 16.33, delta=0.01)  # 50 kg, 1.75 m\n\n        # Overweight\n        self.assertAlmostEqual(calculate_bmi(80, 1.75), 26.12, delta=0.01)  # 80 kg, 1.75 m\n\n        # Obesity\n        self.assertAlmostEqual(calculate_bmi(100, 1.75), 32.65, delta=0.01)  # 100 kg, 1.75 m\n\n    # Test case for invalid inputs\n    def test_invalid_bmi_calculations(self):\n        # Negative weight\n        with self.assertRaises(Exception) as context:\n            calculate_bmi(-70, 1.75)\n\n        # Zero height\n        with self.assertRaises(Exception) as context:\n            calculate_bmi(70, 0)\n\n        # Negative height\n        with self.assertRaises(Exception) as context:\n            calculate_bmi(70, -1.75)\n", "prompt": "please write a python function , the function signature as below def calculate_bmi(weight: float, height: float) -> float:\n    \"\"\"\n    Calculates the Body Mass Index (BMI) based on weight and height.\n    Args:\n        weight (float): The weight of the individual in kilograms.\n        height (float): The height of the individual in meters.\n\n    Returns:\n        float: The calculated BMI value as a float.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <stdexcept>\n\n/**\n * @brief Calculates the Body Mass Index (BMI) based on weight and height.\n *\n * The BMI is calculated using the formula:\n *\n *      BMI = weight (kg) / (height (m) * height (m))\n *\n * @param weight The weight of the individual in kilograms.\n * @param height The height of the individual in meters.\n *\n * @return The calculated BMI value as a double.\n *\n * @throws std::invalid_argument if weight or height is less than or equal to zero,\n *                                since these values must be positive.\n */\ndouble calculateBMI(double weight, double height) {}", "test_code": "// Test case for valid inputs with expected BMI value\nTEST_CASE(\"Valid BMI calculations\") {\n    SECTION(\"Normal weight\") {\n        REQUIRE(calculateBMI(70, 1.75) == Approx(22.86).epsilon(0.01)); // 70 kg, 1.75 m\n    }\n\n    SECTION(\"Underweight\") {\n        REQUIRE(calculateBMI(50, 1.75) == Approx(16.33).epsilon(0.01)); // 50 kg, 1.75 m\n    }\n\n    SECTION(\"Overweight\") {\n        REQUIRE(calculateBMI(80, 1.75) == Approx(26.12).epsilon(0.01)); // 80 kg, 1.75 m\n    }\n\n    SECTION(\"Obesity\") {\n        REQUIRE(calculateBMI(100, 1.75) == Approx(32.65).epsilon(0.01)); // 100 kg, 1.75 m\n    }\n}\n\n// Test case for invalid inputs\nTEST_CASE(\"Invalid BMI calculations\") {\n    SECTION(\"Negative weight\") {\n        REQUIRE_THROWS_AS(calculateBMI(-70, 1.75), std::invalid_argument); // Negative weight\n    }\n\n    SECTION(\"Zero height\") {\n        REQUIRE_THROWS_AS(calculateBMI(70, 0), std::invalid_argument); // Zero height\n    }\n\n    SECTION(\"Negative height\") {\n        REQUIRE_THROWS_AS(calculateBMI(70, -1.75), std::invalid_argument); // Negative height\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <stdexcept>\n\n/**\n * @brief Calculates the Body Mass Index (BMI) based on weight and height.\n *\n * The BMI is calculated using the formula:\n *\n *      BMI = weight (kg) / (height (m) * height (m))\n *\n * @param weight The weight of the individual in kilograms.\n * @param height The height of the individual in meters.\n *\n * @return The calculated BMI value as a double.\n *\n * @throws std::invalid_argument if weight or height is less than or equal to zero,\n *                                since these values must be positive.\n */\ndouble calculateBMI(double weight, double height) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the Body Mass Index (BMI) based on weight and height.\n *\n * The BMI is calculated using the formula:\n *\n *      BMI = weight (kg) / (height (m) * height (m))\n *\n * @param weight The weight of the individual in kilograms.\n * @param height The height of the individual in meters.\n * @return The calculated BMI value as a double.\n * @throws IllegalArgumentException if weight or height is less than or equal to zero,\n *                                  since these values must be positive.\n */\npublic static double calculateBMI(double weight, double height) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.junit.Assert.assertThrows;\n\n/**\n * Test class for BMI calculations.\n */\npublic class Tester {\n\n    // Test case for valid inputs with expected BMI value\n    @Test\n    public void testValidBMICalculations() {\n        // Normal weight\n        assertEquals(22.86, Answer.calculateBMI(70, 1.75), 0.01); // 70 kg, 1.75 m\n\n        // Underweight\n        assertEquals(16.33, Answer.calculateBMI(50, 1.75), 0.01); // 50 kg, 1.75 m\n\n        // Overweight\n        assertEquals(26.12, Answer.calculateBMI(80, 1.75), 0.01); // 80 kg, 1.75 m\n\n        // Obesity\n        assertEquals(32.65, Answer.calculateBMI(100, 1.75), 0.01); // 100 kg, 1.75 m\n    }\n\n    // Test case for invalid inputs\n    @Test\n    public void testInvalidBMICalculations() {\n        // Negative weight\n        assertThrows(IllegalArgumentException.class, () -> {\n            Answer.calculateBMI(-70, 1.75);\n        });\n\n        // Zero height\n        assertThrows(IllegalArgumentException.class, () -> {\n            Answer.calculateBMI(70, 0);\n        });\n\n        // Negative height\n        assertThrows(IllegalArgumentException.class, () -> {\n            Answer.calculateBMI(70, -1.75);\n        });\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the Body Mass Index (BMI) based on weight and height.\n *\n * The BMI is calculated using the formula:\n *\n *      BMI = weight (kg) / (height (m) * height (m))\n *\n * @param weight The weight of the individual in kilograms.\n * @param height The height of the individual in meters.\n * @return The calculated BMI value as a double.\n * @throws IllegalArgumentException if weight or height is less than or equal to zero,\n *                                  since these values must be positive.\n */\npublic static double calculateBMI(double weight, double height) {},package is org.real.temp, class is Answer", "addition_info": ""}}}, {"task_id": 606, "code_type": "method", "original_language": "c&cpp", "file_path": "dit639_cyber_physical_systems_and_sytems_of_systems\\e113255e5a4ec2d23af399253a3e78e0e8636d15\\src\\AngularVelocityAngleCalculator.cpp\n", "question_type": "Scientific computation and numerical analysis", "summary": "Calculate the corresponding steering angle based on the given angular velocity\n", "language_version_list": {"python": {"code_signature": "import math\n\n\ndef calculate_steering_angle(angular_velocity: float, speed: float, wheelbase: float) -> float:\n    \"\"\"\n    Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n\n    The function uses the relationship between angular velocity, speed, and the steering angle\n    to determine the appropriate steering angle required for the vehicle to achieve the desired\n    angular velocity. The formula used is:\n\n         \u03c9 = (v / L) * tan(\u03b4)\n\n    Rearranging gives us:\n\n         \u03b4 = atan((\u03c9 * L) / v)\n\n    Parameters:\n    angular_velocity (float): The angular velocity of the vehicle in radians per second.\n    speed (float): The forward speed of the vehicle in meters per second.\n    wheelbase (float): The distance between the front and rear axles of the vehicle in meters.\n\n    Returns:\n    float: The steering angle in radians.\n\n    Raises:\n    ValueError: If speed is less than or equal to zero,\n                since the vehicle cannot move at zero or negative speed.\n    \"\"\"\n", "test_code": "import math\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n    wheelbase = 2.5  # Setting wheelbase constant for all tests\n\n    def test_normal_case(self):\n        angular_velocity = 1.0  # radians/second\n        speed = 10.0  # meters/second\n        expected_angle = math.atan((angular_velocity * self.wheelbase) / speed)\n        self.assertAlmostEqual(calculate_steering_angle(angular_velocity, speed, self.wheelbase), expected_angle)\n\n    def test_zero_speed(self):\n        angular_velocity = 1.0  # radians/second\n        speed = 0.0  # meters/second\n        with self.assertRaises(ValueError):\n            calculate_steering_angle(angular_velocity, speed, self.wheelbase)\n\n    def test_negative_speed(self):\n        angular_velocity = 1.0  # radians/second\n        speed = -5.0  # meters/second\n        with self.assertRaises(Exception):\n            calculate_steering_angle(angular_velocity, speed, self.wheelbase)\n\n    def test_zero_angular_velocity(self):\n        angular_velocity = 0.0  # radians/second\n        speed = 10.0  # meters/second\n        expected_angle = 0.0  # Steering angle should be zero\n        self.assertAlmostEqual(calculate_steering_angle(angular_velocity, speed, self.wheelbase), expected_angle)\n\n    def test_large_values(self):\n        angular_velocity = 100.0  # radians/second\n        speed = 1000.0  # meters/second\n        expected_angle = math.atan((angular_velocity * self.wheelbase) / speed)\n        self.assertAlmostEqual(calculate_steering_angle(angular_velocity, speed, self.wheelbase), expected_angle)\n\n    def test_high_angular_velocity(self):\n        angular_velocity = 10.0  # radians/second\n        speed = 1.0  # meters/second\n        expected_angle = math.atan((angular_velocity * self.wheelbase) / speed)\n        self.assertAlmostEqual(calculate_steering_angle(angular_velocity, speed, self.wheelbase), expected_angle)\n", "prompt": "please write a python function , the function signature as below import math\n\n\ndef calculate_steering_angle(angular_velocity: float, speed: float, wheelbase: float) -> float:\n    \"\"\"\n    Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n\n    The function uses the relationship between angular velocity, speed, and the steering angle\n    to determine the appropriate steering angle required for the vehicle to achieve the desired\n    angular velocity. The formula used is:\n\n         \u03c9 = (v / L) * tan(\u03b4)\n\n    Rearranging gives us:\n\n         \u03b4 = atan((\u03c9 * L) / v)\n\n    Parameters:\n    angular_velocity (float): The angular velocity of the vehicle in radians per second.\n    speed (float): The forward speed of the vehicle in meters per second.\n    wheelbase (float): The distance between the front and rear axles of the vehicle in meters.\n\n    Returns:\n    float: The steering angle in radians.\n\n    Raises:\n    ValueError: If speed is less than or equal to zero,\n                since the vehicle cannot move at zero or negative speed.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <cmath>\n#include <stdexcept>\n\n/**\n * @brief Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n *\n * The function uses the relationship between angular velocity, speed, and the steering angle\n * to determine the appropriate steering angle required for the vehicle to achieve the desired\n * angular velocity. The formula used is:\n *\n *      \u03c9 = (v / L) * tan(\u03b4)\n *\n * Rearranging gives us:\n *\n *      \u03b4 = atan((\u03c9 * L) / v)\n *\n * @param angularVelocity The angular velocity of the vehicle in radians per second.\n * @param speed The forward speed of the vehicle in meters per second.\n * @param wheelbase The distance between the front and rear axles of the vehicle in meters.\n *\n * @return The steering angle in radians.\n *\n * @throws std::invalid_argument if speed is less than or equal to zero,\n *                                since the vehicle cannot move at zero or negative speed.\n */\ndouble calculateSteeringAngle(double angularVelocity, double speed, double wheelbase) {}", "test_code": "TEST_CASE(\"Calculate Steering Angle Tests\") {\n    const double wheelbase = 2.5; // Setting wheelbase constant for all tests\n\n    SECTION(\"Normal case\") {\n        double angularVelocity = 1.0; // radians/second\n        double speed = 10.0;          // meters/second\n        double expectedAngle = atan((angularVelocity * wheelbase) / speed);\n        REQUIRE(calculateSteeringAngle(angularVelocity, speed, wheelbase) == Approx(expectedAngle));\n    }\n\n    SECTION(\"Zero speed\") {\n        double angularVelocity = 1.0; // radians/second\n        double speed = 0.0;           // meters/second\n        REQUIRE_THROWS_AS(calculateSteeringAngle(angularVelocity, speed, wheelbase), std::invalid_argument);\n    }\n\n    SECTION(\"Negative speed\") {\n        double angularVelocity = 1.0; // radians/second\n        double speed = -5.0;          // meters/second\n        REQUIRE_THROWS_AS(calculateSteeringAngle(angularVelocity, speed, wheelbase), std::invalid_argument);\n    }\n\n    SECTION(\"Zero angular velocity\") {\n        double angularVelocity = 0.0; // radians/second\n        double speed = 10.0;          // meters/second\n        double expectedAngle = 0.0;   // Steering angle should be zero\n        REQUIRE(calculateSteeringAngle(angularVelocity, speed, wheelbase) == Approx(expectedAngle));\n    }\n\n    SECTION(\"Large values\") {\n        double angularVelocity = 100.0; // radians/second\n        double speed = 1000.0;          // meters/second\n        double expectedAngle = atan((angularVelocity * wheelbase) / speed);\n        REQUIRE(calculateSteeringAngle(angularVelocity, speed, wheelbase) == Approx(expectedAngle));\n    }\n\n    SECTION(\"High angular velocity\") {\n        double angularVelocity = 10.0; // radians/second\n        double speed = 1.0;             // meters/second\n        double expectedAngle = atan((angularVelocity * wheelbase) / speed);\n        REQUIRE(calculateSteeringAngle(angularVelocity, speed, wheelbase) == Approx(expectedAngle));\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <cmath>\n#include <stdexcept>\n\n/**\n * @brief Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n *\n * The function uses the relationship between angular velocity, speed, and the steering angle\n * to determine the appropriate steering angle required for the vehicle to achieve the desired\n * angular velocity. The formula used is:\n *\n *      \u03c9 = (v / L) * tan(\u03b4)\n *\n * Rearranging gives us:\n *\n *      \u03b4 = atan((\u03c9 * L) / v)\n *\n * @param angularVelocity The angular velocity of the vehicle in radians per second.\n * @param speed The forward speed of the vehicle in meters per second.\n * @param wheelbase The distance between the front and rear axles of the vehicle in meters.\n *\n * @return The steering angle in radians.\n *\n * @throws std::invalid_argument if speed is less than or equal to zero,\n *                                since the vehicle cannot move at zero or negative speed.\n */\ndouble calculateSteeringAngle(double angularVelocity, double speed, double wheelbase) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n *\n * The method uses the relationship between angular velocity, speed, and the steering angle\n * to determine the appropriate steering angle required for the vehicle to achieve the desired\n * angular velocity. The formula used is:\n *\n *      \u03c9 = (v / L) * tan(\u03b4)\n *\n * Rearranging gives us:\n *\n *      \u03b4 = atan((\u03c9 * L) / v)\n *\n * @param angularVelocity The angular velocity of the vehicle in radians per second.\n * @param speed The forward speed of the vehicle in meters per second.\n * @param wheelbase The distance between the front and rear axles of the vehicle in meters.\n *\n * @return The steering angle in radians.\n *\n * @throws IllegalArgumentException if speed is less than or equal to zero,\n *                                   since the vehicle cannot move at zero or negative speed.\n */\npublic static double calculateSteeringAngle(double angularVelocity, double speed, double wheelbase) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\npublic class Tester {\n\n    private static final double WHEELBASE = 2.5; // Setting wheelbase constant for all tests\n\n    @Test\n    public void testNormalCase() {\n        double angularVelocity = 1.0; // radians/second\n        double speed = 10.0;          // meters/second\n        double expectedAngle = Math.atan((angularVelocity * WHEELBASE) / speed);\n        assertEquals(expectedAngle, Answer.calculateSteeringAngle(angularVelocity, speed, WHEELBASE), 1e-9);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testZeroSpeed() {\n        double angularVelocity = 1.0; // radians/second\n        double speed = 0.0;           // meters/second\n        Answer.calculateSteeringAngle(angularVelocity, speed, WHEELBASE);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testNegativeSpeed() {\n        double angularVelocity = 1.0; // radians/second\n        double speed = -5.0;          // meters/second\n        Answer.calculateSteeringAngle(angularVelocity, speed, WHEELBASE);\n    }\n\n    @Test\n    public void testZeroAngularVelocity() {\n        double angularVelocity = 0.0; // radians/second\n        double speed = 10.0;          // meters/second\n        double expectedAngle = 0.0;   // Steering angle should be zero\n        assertEquals(expectedAngle, Answer.calculateSteeringAngle(angularVelocity, speed, WHEELBASE), 1e-9);\n    }\n\n    @Test\n    public void testLargeValues() {\n        double angularVelocity = 100.0; // radians/second\n        double speed = 1000.0;          // meters/second\n        double expectedAngle = Math.atan((angularVelocity * WHEELBASE) / speed);\n        assertEquals(expectedAngle, Answer.calculateSteeringAngle(angularVelocity, speed, WHEELBASE), 1e-9);\n    }\n\n    @Test\n    public void testHighAngularVelocity() {\n        double angularVelocity = 10.0; // radians/second\n        double speed = 1.0;             // meters/second\n        double expectedAngle = Math.atan((angularVelocity * WHEELBASE) / speed);\n        assertEquals(expectedAngle, Answer.calculateSteeringAngle(angularVelocity, speed, WHEELBASE), 1e-9);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n *\n * The method uses the relationship between angular velocity, speed, and the steering angle\n * to determine the appropriate steering angle required for the vehicle to achieve the desired\n * angular velocity. The formula used is:\n *\n *      \u03c9 = (v / L) * tan(\u03b4)\n *\n * Rearranging gives us:\n *\n *      \u03b4 = atan((\u03c9 * L) / v)\n *\n * @param angularVelocity The angular velocity of the vehicle in radians per second.\n * @param speed The forward speed of the vehicle in meters per second.\n * @param wheelbase The distance between the front and rear axles of the vehicle in meters.\n *\n * @return The steering angle in radians.\n *\n * @throws IllegalArgumentException if speed is less than or equal to zero,\n *                                   since the vehicle cannot move at zero or negative speed.\n */\npublic static double calculateSteeringAngle(double angularVelocity, double speed, double wheelbase) {},package is org.real.temp, class is Answer", "addition_info": ""}}}]