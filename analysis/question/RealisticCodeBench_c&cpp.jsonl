{"task_id": 183, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Check whether the ray intersects the circle\n", "language_version_list": {"python": {"code_signature": "class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Ray:\n    def __init__(self, origin, direction):\n        self.origin = origin  # Starting point of the ray\n        self.direction = direction  # Direction of the ray (should be normalized)\n\n\nclass Circle:\n    def __init__(self, center, radius):\n        self.center = center  # Center of the circle\n        self.radius = radius  # Radius of the circle\n\n\ndef intersects(ray: Ray, circle: Circle) -> bool:\n    \"\"\"\n    Determines whether a ray intersects with a circle.\n\n    Args:\n        ray (Ray): The ray to be tested for intersection. It is assumed to contain properties such as an origin point (x, y) and a direction vector (dx, dy).\n        circle (Circle): The circle to check for intersection. It is assumed to contain properties such as a center point (h, k) and a radius r.\n\n    Returns:\n        bool: True if the ray intersects the circle; False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Ray:\n    def __init__(self, origin, direction):\n        self.origin = origin  # Starting point of the ray\n        self.direction = direction  # Direction of the ray (should be normalized)\n\n\nclass Circle:\n    def __init__(self, center, radius):\n        self.center = center  # Center of the circle\n        self.radius = radius  # Radius of the circle\n\n\nclass Tester(unittest.TestCase):\n    def test_ray_circle_intersection(self):\n        # Test Case 1: The ray intersects the circle at two points\n        ray = Ray(Point(0, 0), Point(1, 1))  # Origin at (0, 0), direction (1, 1)\n        circle = Circle(Point(3, 3), 2)  # Circle center at (3, 3), radius 2\n        self.assertTrue(intersects(ray, circle))\n\n        # Test Case 2: The ray is tangent to the circle (one intersection point)\n        ray = Ray(Point(2, 0), Point(0, 1))  # Origin at (2, 0), direction (0, 1)\n        circle = Circle(Point(2, 2), 1)  # Circle center at (2, 2), radius 1\n        self.assertTrue(intersects(ray, circle))\n\n        # Test Case 3: The ray starts inside the circle (one intersection point)\n        ray = Ray(Point(2, 2), Point(1, 0))  # Origin at (2, 2), direction (1, 0)\n        circle = Circle(Point(3, 2), 1)  # Circle center at (3, 2), radius 1\n        self.assertTrue(intersects(ray, circle))\n\n        # Test Case 4: The ray originates outside and goes away from the circle (no intersection)\n        ray = Ray(Point(5, 5), Point(1, 0))  # Origin at (5, 5), direction (1, 0)\n        circle = Circle(Point(3, 3), 1)  # Circle center at (3, 3), radius 1\n        self.assertFalse(intersects(ray, circle))\n\n        # Test Case 5: The ray is parallel to the line connecting the center of the circle and is outside (no intersection)\n        ray = Ray(Point(0, 3), Point(1, 0))  # Origin at (0, 3), direction (1, 0)\n        circle = Circle(Point(3, 3), 1)  # Circle center at (3, 3), radius 1\n        self.assertFalse(intersects(ray, circle))\n\n        # Test Case 6: The ray intersects the circle at one point when passing through the center\n        ray = Ray(Point(3, 0), Point(0, 1))  # Origin at (3, 0), direction (0, 1)\n        circle = Circle(Point(3, 3), 3)  # Circle center at (3, 3), radius 3\n        self.assertTrue(intersects(ray, circle))\n", "prompt": "please write a python function , the function signature as below class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Ray:\n    def __init__(self, origin, direction):\n        self.origin = origin  # Starting point of the ray\n        self.direction = direction  # Direction of the ray (should be normalized)\n\n\nclass Circle:\n    def __init__(self, center, radius):\n        self.center = center  # Center of the circle\n        self.radius = radius  # Radius of the circle\n\n\ndef intersects(ray: Ray, circle: Circle) -> bool:\n    \"\"\"\n    Determines whether a ray intersects with a circle.\n\n    Args:\n        ray (Ray): The ray to be tested for intersection. It is assumed to contain properties such as an origin point (x, y) and a direction vector (dx, dy).\n        circle (Circle): The circle to check for intersection. It is assumed to contain properties such as a center point (h, k) and a radius r.\n\n    Returns:\n        bool: True if the ray intersects the circle; False otherwise.\n    \"\"\"\n", "addition_info": "class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Ray:\n    def __init__(self, origin, direction):\n        self.origin = origin  # Starting point of the ray\n        self.direction = direction  # Direction of the ray (should be normalized)\n\n\nclass Circle:\n    def __init__(self, center, radius):\n        self.center = center  # Center of the circle\n        self.radius = radius  # Radius of the circle"}, "javascript": {"code_signature": "class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Ray {\n    constructor(origin, direction) {\n        this.origin = origin;     // Starting point of the ray\n        this.direction = direction; // Direction of the ray (should be normalized)\n    }\n}\n\nclass Circle {\n    constructor(center, radius) {\n        this.center = center; // Center of the circle\n        this.radius = radius; // Radius of the circle\n    }\n}\n\n/**\n * Determines whether a ray intersects with a circle.\n *\n * This function checks if a given ray intersects with a specified circle\n * in a 2D space. It performs mathematical calculations to determine if\n * the ray, defined by its origin and direction, crosses the area of the\n * circle defined by its center and radius.\n *\n * @param ray The ray to be tested for intersection. It is assumed to\n * contain properties such as an origin point and a direction vector.\n * @param circle The circle to check for intersection. It is assumed to\n * contain properties such as a center point and a radius.\n *\n * @return true if the ray intersects the circle; false otherwise.\n */\nfunction intersects(ray, circle) {}", "test_code": "describe(\"Ray-Circle Intersection Tests\", () => {\n    // Test Case 1: The ray intersects the circle at two points\n    test(\"should intersect the circle at two points\", () => {\n        const ray = new Ray(new Point(0, 0), new Point(1, 1)); // Origin at (0, 0), direction (1, 1)\n        const circle = new Circle(new Point(3, 3), 2); // Circle center at (3, 3), radius 2\n        expect(intersects(ray, circle)).toBe(true);\n    });\n\n    // Test Case 2: The ray is tangent to the circle (one intersection point)\n    test(\"should be tangent to the circle (one intersection point)\", () => {\n        const ray = new Ray(new Point(2, 0), new Point(0, 1)); // Origin at (2, 0), direction (0, 1)\n        const circle = new Circle(new Point(2, 2), 1); // Circle center at (2, 2), radius 1\n        expect(intersects(ray, circle)).toBe(true);\n    });\n\n    // Test Case 3: The ray starts inside the circle (one intersection point)\n    test(\"should start inside the circle (one intersection point)\", () => {\n        const ray = new Ray(new Point(2, 2), new Point(1, 0)); // Origin at (2, 2), direction (1, 0)\n        const circle = new Circle(new Point(3, 2), 1); // Circle center at (3, 2), radius 1\n        expect(intersects(ray, circle)).toBe(true);\n    });\n\n    // Test Case 4: The ray originates outside and goes away from the circle (no intersection)\n    test(\"should not intersect the circle (no intersection)\", () => {\n        const ray = new Ray(new Point(5, 5), new Point(1, 0)); // Origin at (5, 5), direction (1, 0)\n        const circle = new Circle(new Point(3, 3), 1); // Circle center at (3, 3), radius 1\n        expect(intersects(ray, circle)).toBe(false);\n    });\n\n    // Test Case 5: The ray is parallel to the line connecting the center of the circle and is outside (no intersection)\n    test(\"should not intersect when parallel and outside\", () => {\n        const ray = new Ray(new Point(0, 3), new Point(1, 0)); // Origin at (0, 3), direction (1, 0)\n        const circle = new Circle(new Point(3, 3), 1); // Circle center at (3, 3), radius 1\n        expect(intersects(ray, circle)).toBe(true);\n    });\n\n    // Test Case 6: The ray intersects the circle at one point when passing through the center\n    test(\"should intersect at one point through the center\", () => {\n        const ray = new Ray(new Point(3, 0), new Point(0, 1)); // Origin at (3, 0), direction (0, 1)\n        const circle = new Circle(new Point(3, 3), 3); // Circle center at (3, 3), radius 3\n        expect(intersects(ray, circle)).toBe(true);\n    });\n});", "prompt": "please write a javascript function , the function signature as below class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Ray {\n    constructor(origin, direction) {\n        this.origin = origin;     // Starting point of the ray\n        this.direction = direction; // Direction of the ray (should be normalized)\n    }\n}\n\nclass Circle {\n    constructor(center, radius) {\n        this.center = center; // Center of the circle\n        this.radius = radius; // Radius of the circle\n    }\n}\n\n/**\n * Determines whether a ray intersects with a circle.\n *\n * This function checks if a given ray intersects with a specified circle\n * in a 2D space. It performs mathematical calculations to determine if\n * the ray, defined by its origin and direction, crosses the area of the\n * circle defined by its center and radius.\n *\n * @param ray The ray to be tested for intersection. It is assumed to\n * contain properties such as an origin point and a direction vector.\n * @param circle The circle to check for intersection. It is assumed to\n * contain properties such as a center point and a radius.\n *\n * @return true if the ray intersects the circle; false otherwise.\n */\nfunction intersects(ray, circle) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Determines whether a ray intersects with a circle.\n *\n * This function checks if a given ray intersects with a specified circle\n * in a 2D space. It performs mathematical calculations to determine if\n * the ray, defined by its origin and direction, crosses the area of the\n * circle defined by its center and radius.\n *\n * @param ray The ray to be tested for intersection. It is assumed to\n * contain properties such as an origin point and a direction vector.\n * @param circle The circle to check for intersection. It is assumed to\n * contain properties such as a center point and a radius.\n *\n * @return true if the ray intersects the circle; false otherwise.\n */\ninterface Point {\n    x: number; // X-coordinate of the point\n    y: number; // Y-coordinate of the point\n}\n\ninterface Ray {\n    origin: Point;     // Starting point of the ray\n    direction: Point;  // Direction of the ray (should be normalized)\n}\n\ninterface Circle {\n    center: Point;     // Center of the circle\n    radius: number;    // Radius of the circle\n}\nfunction intersects(ray: Ray, circle: Circle): boolean {}", "test_code": "describe('Ray-Circle Intersection Tests', () => {\n    // Test Case 1: The ray intersects the circle at two points\n    test('Ray intersects circle at two points', () => {\n        const ray = { origin: { x: 0, y: 0 }, direction: { x: 1, y: 1 } };\n        const circle = { center: { x: 3, y: 3 }, radius: 2 };\n        expect(intersects(ray, circle)).toBe(true);\n    });\n\n    // Test Case 2: The ray is tangent to the circle (one intersection point)\n    test('Ray is tangent to the circle', () => {\n        const ray = { origin: { x: 2, y: 0 }, direction: { x: 0, y: 1 } };\n        const circle = { center: { x: 2, y: 2 }, radius: 1 };\n        expect(intersects(ray, circle)).toBe(true);\n    });\n\n    // Test Case 3: The ray starts inside the circle (one intersection point)\n    test('Ray starts inside the circle', () => {\n        const ray = { origin: { x: 2, y: 2 }, direction: { x: 1, y: 0 } };\n        const circle = { center: { x: 3, y: 2 }, radius: 1 };\n        expect(intersects(ray, circle)).toBe(true);\n    });\n\n    // Test Case 4: The ray originates outside and goes away from the circle (no intersection)\n    test('Ray goes away from circle (no intersection)', () => {\n        const ray = { origin: { x: 5, y: 5 }, direction: { x: 1, y: 0 } };\n        const circle = { center: { x: 3, y: 3 }, radius: 1 };\n        expect(intersects(ray, circle)).toBe(false);\n    });\n\n    // Test Case 5: The ray is parallel to the line connecting the center of the circle and is outside (no intersection)\n    test('Ray is parallel and outside circle (no intersection)', () => {\n        const ray = { origin: { x: 0, y: 3 }, direction: { x: 1, y: 0 } };\n        const circle = { center: { x: 3, y: 3 }, radius: 1 };\n        expect(intersects(ray, circle)).toBe(true);\n    });\n\n    // Test Case 6: The ray intersects the circle at one point when passing through the center\n    test('Ray passes through center of circle', () => {\n        const ray = { origin: { x: 3, y: 0 }, direction: { x: 0, y: 1 } };\n        const circle = { center: { x: 3, y: 3 }, radius: 3 };\n        expect(intersects(ray, circle)).toBe(true);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Determines whether a ray intersects with a circle.\n *\n * This function checks if a given ray intersects with a specified circle\n * in a 2D space. It performs mathematical calculations to determine if\n * the ray, defined by its origin and direction, crosses the area of the\n * circle defined by its center and radius.\n *\n * @param ray The ray to be tested for intersection. It is assumed to\n * contain properties such as an origin point and a direction vector.\n * @param circle The circle to check for intersection. It is assumed to\n * contain properties such as a center point and a radius.\n *\n * @return true if the ray intersects the circle; false otherwise.\n */\ninterface Point {\n    x: number; // X-coordinate of the point\n    y: number; // Y-coordinate of the point\n}\n\ninterface Ray {\n    origin: Point;     // Starting point of the ray\n    direction: Point;  // Direction of the ray (should be normalized)\n}\n\ninterface Circle {\n    center: Point;     // Center of the circle\n    radius: number;    // Radius of the circle\n}\nfunction intersects(ray: Ray, circle: Circle): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <cmath>\n\nstruct Point {\n    float x, y;\n};\n\nstruct Ray {\n    Point origin;   // Starting point of the ray\n    Point direction; // Direction of the ray (should be normalized)\n};\n\nstruct Circle {\n    Point center; // Center of the circle\n    float radius; // Radius of the circle\n};\n\n/**\n * @brief Determines whether a ray intersects with a circle.\n *\n * This function checks if a given ray intersects with a specified circle\n * in a 2D space. It performs mathematical calculations to determine if\n * the ray, defined by its origin and direction, crosses the area of the\n * circle defined by its center and radius.\n *\n * @param ray The ray to be tested for intersection. It is assumed to\n * contain properties such as an origin point and a direction vector.\n * @param circle The circle to check for intersection. It is assumed to\n * contain properties such as a center point and a radius.\n *\n * @return true if the ray intersects the circle; false otherwise.\n */\nbool intersects(const Ray& ray, const Circle& circle) {}", "test_code": "TEST_CASE(\"Ray-Circle Intersection Tests\") {\n    // Test Case 1: The ray intersects the circle at two points\n    {\n        Ray ray = {{0, 0}, {1, 1}}; // Origin at (0, 0), direction (1, 1)\n        Circle circle = {{3, 3}, 2}; // Circle center at (3, 3), radius 2\n        REQUIRE(intersects(ray, circle) == true);\n    }\n\n    // Test Case 2: The ray is tangent to the circle (one intersection point)\n    {\n        Ray ray = {{2, 0}, {0, 1}}; // Origin at (2, 0), direction (0, 1)\n        Circle circle = {{2, 2}, 1}; // Circle center at (2, 2), radius 1\n        REQUIRE(intersects(ray, circle) == true);\n    }\n\n    // Test Case 3: The ray starts inside the circle (one intersection point)\n    {\n        Ray ray = {{2, 2}, {1, 0}}; // Origin at (2, 2), direction (1, 0)\n        Circle circle = {{3, 2}, 1}; // Circle center at (3, 2), radius 1\n        REQUIRE(intersects(ray, circle) == true);\n    }\n\n    // Test Case 4: The ray originates outside and goes away from the circle (no intersection)\n    {\n        Ray ray = {{5, 5}, {1, 0}}; // Origin at (5, 5), direction (1, 0)\n        Circle circle = {{3, 3}, 1}; // Circle center at (3, 3), radius 1\n        REQUIRE(intersects(ray, circle) == false);\n    }\n\n    // Test Case 5: The ray is parallel to the line connecting the center of the circle and is outside (no intersection)\n    {\n        Ray ray = {{0, 3}, {1, 0}}; // Origin at (0, 3), direction (1, 0)\n        Circle circle = {{3, 3}, 1}; // Circle center at (3, 3), radius 1\n        REQUIRE(intersects(ray, circle) == true);\n    }\n\n    // Test Case 6: The ray intersects the circle at one point when passing through the center\n    {\n        Ray ray = {{3, 0}, {0, 1}}; // Origin at (3, 0), direction (0, 1)\n        Circle circle = {{3, 3}, 3}; // Circle center at (3, 3), radius 3\n        REQUIRE(intersects(ray, circle) == true);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <cmath>\n\nstruct Point {\n    float x, y;\n};\n\nstruct Ray {\n    Point origin;   // Starting point of the ray\n    Point direction; // Direction of the ray (should be normalized)\n};\n\nstruct Circle {\n    Point center; // Center of the circle\n    float radius; // Radius of the circle\n};\n\n/**\n * @brief Determines whether a ray intersects with a circle.\n *\n * This function checks if a given ray intersects with a specified circle\n * in a 2D space. It performs mathematical calculations to determine if\n * the ray, defined by its origin and direction, crosses the area of the\n * circle defined by its center and radius.\n *\n * @param ray The ray to be tested for intersection. It is assumed to\n * contain properties such as an origin point and a direction vector.\n * @param circle The circle to check for intersection. It is assumed to\n * contain properties such as a center point and a radius.\n *\n * @return true if the ray intersects the circle; false otherwise.\n */\nbool intersects(const Ray& ray, const Circle& circle) {}", "addition_info": "#include <iostream>\n#include <cmath>\n\nstruct Point {\n    float x, y;\n};\n\nstruct Ray {\n    Point origin;   // Starting point of the ray\n    Point direction; // Direction of the ray (should be normalized)\n};\n\nstruct Circle {\n    Point center; // Center of the circle\n    float radius; // Radius of the circle\n};"}, "java": {"code_signature": "/**\n * Determines whether a ray intersects with a circle.\n *\n * This method checks if a given ray intersects with a specified circle\n * in a 2D space. It performs mathematical calculations to determine if\n * the ray, defined by its origin and direction, crosses the area of the\n * circle defined by its center and radius.\n *\n * @param ray The ray to be tested for intersection. It is assumed to\n * contain properties such as an origin point and a direction vector.\n * @param circle The circle to check for intersection. It is assumed to\n * contain properties such as a center point and a radius.\n *\n * @return true if the ray intersects the circle; false otherwise.\n */\n/**\n * Represents a point in 2D space.\n */\nstatic class Point {\n    float x, y;\n}\n\n/**\n * Represents a ray in 2D space.\n * The ray is defined by its origin and direction (which should be normalized).\n */\nstatic class Ray {\n\n}\n\n/**\n * Represents a circle in 2D space.\n * The circle is defined by its center and radius.\n */\nstatic class Circle {\n    Point center; // Center of the circle\n    float radius; // Radius of the circle\n\n}\npublic static boolean intersects(Ray ray, Circle circle) {\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\n\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testcase1() {\n        // Test Case 1: The ray intersects the circle at two points\n        Ray ray1 = new Ray(new Point(0, 0), new Point(1, 1)); // Origin at (0, 0), direction (1, 1)\n        Circle circle1 = new Circle(new Point(3, 3), 2); // Circle center at (3, 3), radius 2\n        assertTrue(intersects(ray1, circle1));\n\n    }\n\n    @Test\n    public void testcase2(){\n        // Test Case 2: The ray is tangent to the circle (one intersection point)\n        Ray ray2 = new Ray(new Point(2, 0), new Point(0, 1)); // Origin at (2, 0), direction (0, 1)\n        Circle circle2 = new Circle(new Point(2, 2), 1); // Circle center at (2, 2), radius 1\n        assertTrue(intersects(ray2, circle2));\n    }\n    @Test\n    public void testcase3(){\n        // Test Case 3: The ray starts inside the circle (one intersection point)\n        Ray ray3 = new Ray(new Point(2, 2), new Point(1, 0)); // Origin at (2, 2), direction (1, 0)\n        Circle circle3 = new Circle(new Point(3, 2), 1); // Circle center at (3, 2), radius 1\n        assertTrue(intersects(ray3, circle3));\n\n    }\n    @Test\n    public void testcase4(){\n        // Test Case 4: The ray originates outside and goes away from the circle (no intersection)\n        Ray ray4 = new Ray(new Point(5, 5), new Point(1, 0)); // Origin at (5, 5), direction (1, 0)\n        Circle circle4 = new Circle(new Point(3, 3), 1); // Circle center at (3, 3), radius 1\n        assertFalse(intersects(ray4, circle4));\n    }\n    @Test\n    public void testcase5(){\n        // Test Case 5: The ray is parallel to the line connecting the center of the circle and is outside (no intersection)\n        Ray ray5 = new Ray(new Point(0, 3), new Point(1, 0)); // Origin at (0, 3), direction (1, 0)\n        Circle circle5 = new Circle(new Point(3, 3), 1); // Circle center at (3, 3), radius 1\n        assertTrue(intersects(ray5, circle5));\n\n    }\n    @Test\n    public void testcase6(){\n\n        // Test Case 6: The ray intersects the circle at one point when passing through the center\n        Ray ray6 = new Ray(new Point(3, 0), new Point(0, 1)); // Origin at (3, 0), direction (0, 1)\n        Circle circle6 = new Circle(new Point(3, 3), 3); // Circle center at (3, 3), radius 3\n        assertTrue(intersects(ray6, circle6));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Determines whether a ray intersects with a circle.\n *\n * This method checks if a given ray intersects with a specified circle\n * in a 2D space. It performs mathematical calculations to determine if\n * the ray, defined by its origin and direction, crosses the area of the\n * circle defined by its center and radius.\n *\n * @param ray The ray to be tested for intersection. It is assumed to\n * contain properties such as an origin point and a direction vector.\n * @param circle The circle to check for intersection. It is assumed to\n * contain properties such as a center point and a radius.\n *\n * @return true if the ray intersects the circle; false otherwise.\n */\n/**\n * Represents a point in 2D space.\n */\nstatic class Point {\n    float x, y;\n}\n\n/**\n * Represents a ray in 2D space.\n * The ray is defined by its origin and direction (which should be normalized).\n */\nstatic class Ray {\n\n}\n\n/**\n * Represents a circle in 2D space.\n * The circle is defined by its center and radius.\n */\nstatic class Circle {\n    Point center; // Center of the circle\n    float radius; // Radius of the circle\n\n}\npublic static boolean intersects(Ray ray, Circle circle) {\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 184, "code_type": "class", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Implement a priority queue and use the binary heap, or the maximum heap, as the underlying data structure\n", "language_version_list": {"python": {"code_signature": "class PriorityQueue:\n    def __init__(self):\n        self.heap = []  # This will store the elements of the heap\n\n    # Helper function to get the index of the parent\n    def parent(self, index):\n        pass\n\n    # Helper function to get the index of the left child\n    def left_child(self, index):\n        pass\n\n    # Helper function to get the index of the right child\n    def right_child(self, index):\n        pass\n\n    # Helper function to swap two elements in the heap\n    def swap(self, a, b):\n        pass\n\n    # Heapify up to maintain the max-heap property after insertion\n    def heapify_up(self, index):\n        pass\n\n    # Heapify down to maintain the max-heap property after deletion\n    def heapify_down(self, index):\n        pass\n\n    # Insert an element into the priority queue\n    def push(self, value):\n        pass\n\n    # Remove the maximum element from the priority queue\n    def pop(self):\n        pass\n\n    # Get the maximum element without removing it\n    def top(self):\n        pass\n\n    # Check if the priority queue is empty\n    def is_empty(self):\n        pass\n\n    # Get the size of the priority queue\n    def size(self):\n        pass", "test_code": "import unittest\n\nclass Tester(unittest.TestCase):\n    \n    def setUp(self):\n        \"\"\" Set up a new PriorityQueue instance for each test \"\"\"\n        self.pq = PriorityQueue()\n    \n    def test_insert_and_access_maximum_element(self):\n        \"\"\" Test case: Insert and access maximum element \"\"\"\n        self.pq.push(10)\n        self.pq.push(20)\n        self.pq.push(5)\n        self.pq.push(30)\n        self.pq.push(15)\n        self.assertEqual(self.pq.top(), 30)  # Ensure the max element is 30\n    \n    def test_remove_maximum_element(self):\n        \"\"\" Test case: Remove maximum element \"\"\"\n        self.pq.push(10)\n        self.pq.push(20)\n        self.pq.push(5)\n        self.pq.push(30)\n        self.pq.pop()  # Remove 30\n        self.assertEqual(self.pq.top(), 20)  # Now the max should be 20\n        self.pq.pop()  # Remove 20\n        self.assertEqual(self.pq.top(), 10)  # Now the max should be 10\n    \n    \n    def test_pop_from_empty_queue(self):\n        \"\"\" Test case: Pop from empty queue (should raise exception) \"\"\"\n        with self.assertRaises(RuntimeError):\n            self.pq.pop()  # Should raise an error\n    \n    def test_access_top_of_empty_queue(self):\n        \"\"\" Test case: Access top of empty queue (should raise exception) \"\"\"\n        with self.assertRaises(RuntimeError):\n            self.pq.top()  # Should raise an error\n    \n    def test_maintain_max_heap_property(self):\n        \"\"\" Test case: Maintain max-heap property \"\"\"\n        self.pq.push(3)\n        self.pq.push(1)\n        self.pq.push(4)\n        self.pq.push(2)\n        self.assertEqual(self.pq.top(), 4)  # Ensure max is 4\n        self.pq.pop()  # Remove 4\n        self.assertEqual(self.pq.top(), 3)  # Now max is 3\n        self.pq.push(5)  # Add 5\n        self.assertEqual(self.pq.top(), 5)  # Ensure max is now 5\n", "prompt": "please write a python class , the class signature as below class PriorityQueue:\n    def __init__(self):\n        self.heap = []  # This will store the elements of the heap\n\n    # Helper function to get the index of the parent\n    def parent(self, index):\n        pass\n\n    # Helper function to get the index of the left child\n    def left_child(self, index):\n        pass\n\n    # Helper function to get the index of the right child\n    def right_child(self, index):\n        pass\n\n    # Helper function to swap two elements in the heap\n    def swap(self, a, b):\n        pass\n\n    # Heapify up to maintain the max-heap property after insertion\n    def heapify_up(self, index):\n        pass\n\n    # Heapify down to maintain the max-heap property after deletion\n    def heapify_down(self, index):\n        pass\n\n    # Insert an element into the priority queue\n    def push(self, value):\n        pass\n\n    # Remove the maximum element from the priority queue\n    def pop(self):\n        pass\n\n    # Get the maximum element without removing it\n    def top(self):\n        pass\n\n    # Check if the priority queue is empty\n    def is_empty(self):\n        pass\n\n    # Get the size of the priority queue\n    def size(self):\n        pass", "addition_info": ""}, "javascript": {"code_signature": "class PriorityQueue {\n    constructor() {\n        this.heap = []; // This will store the elements of the heap\n    }\n\n    // Helper function to get the index of the parent\n    parent(index) {}\n\n    // Helper function to get the index of the left child\n    leftChild(index) {}\n\n    // Helper function to get the index of the right child\n    rightChild(index) {}\n\n    // Helper function to swap two elements in the heap\n    swap(a, b) {}\n\n    // Heapify up to maintain the max-heap property after insertion\n    heapifyUp(index) {}\n\n    // Heapify down to maintain the max-heap property after deletion\n    heapifyDown(index) {}\n\n    // Insert an element into the priority queue\n    push(value) {}\n\n    // Remove the maximum element from the priority queue\n    pop() {}\n\n    // Get the maximum element without removing it\n    top() {}\n\n    // Check if the priority queue is empty\n    isEmpty() {}\n\n    // Get the size of the priority queue\n    size() {}\n}", "test_code": "describe(\"Priority Queue - Test Cases\", () => {\n    let pq;\n\n    beforeEach(() => {\n        pq = new PriorityQueue();\n    });\n\n    test(\"Insert and access maximum element\", () => {\n        pq.push(10);\n        pq.push(20);\n        pq.push(5);\n        pq.push(30);\n        pq.push(15);\n\n        expect(pq.top()).toBe(30); // Ensure the max element is 30\n    });\n\n    test(\"Remove maximum element\", () => {\n        pq.push(10);\n        pq.push(20);\n        pq.push(5);\n        pq.push(30);\n\n        pq.pop(); // Remove 30\n        expect(pq.top()).toBe(20); // Now the max should be 20\n        pq.pop(); // Remove 20\n        expect(pq.top()).toBe(10); // Now the max should be 10\n    });\n\n    test(\"Check empty queue\", () => {\n        expect(pq.isEmpty()).toBe(true); // Initially empty\n        pq.push(10);\n        expect(pq.isEmpty()).toBe(false); // Now not empty\n        pq.pop();\n        expect(pq.isEmpty()).toBe(true); // Back to empty\n    });\n\n    test(\"Pop from empty queue\", () => {\n        expect(() => pq.pop()).toThrow(Error); // Should throw an error\n    });\n\n    test(\"Access top of empty queue\", () => {\n        expect(() => pq.top()).toThrow(Error); // Should throw an error\n    });\n\n    test(\"Maintain max-heap property\", () => {\n        pq.push(3);\n        pq.push(1);\n        pq.push(4);\n        pq.push(2);\n\n        expect(pq.top()).toBe(4); // Ensure max is 4\n\n        pq.pop(); // Remove 4\n        expect(pq.top()).toBe(3); // Now max is 3\n\n        pq.push(5); // Add 5\n        expect(pq.top()).toBe(5); // Ensure max is now 5\n    });\n});", "prompt": "please write a javascript class , the class signature as below class PriorityQueue {\n    constructor() {\n        this.heap = []; // This will store the elements of the heap\n    }\n\n    // Helper function to get the index of the parent\n    parent(index) {}\n\n    // Helper function to get the index of the left child\n    leftChild(index) {}\n\n    // Helper function to get the index of the right child\n    rightChild(index) {}\n\n    // Helper function to swap two elements in the heap\n    swap(a, b) {}\n\n    // Heapify up to maintain the max-heap property after insertion\n    heapifyUp(index) {}\n\n    // Heapify down to maintain the max-heap property after deletion\n    heapifyDown(index) {}\n\n    // Insert an element into the priority queue\n    push(value) {}\n\n    // Remove the maximum element from the priority queue\n    pop() {}\n\n    // Get the maximum element without removing it\n    top() {}\n\n    // Check if the priority queue is empty\n    isEmpty() {}\n\n    // Get the size of the priority queue\n    size() {}\n}", "addition_info": ""}, "typescript": {"code_signature": "class PriorityQueue {\n    private heap: number[]; // This will store the elements of the heap\n\n    // Helper function to get the index of the parent\n    private parent(index: number): number {}\n\n    // Helper function to get the index of the left child\n    private leftChild(index: number): number {}\n\n    // Helper function to get the index of the right child\n    private rightChild(index: number): number {}\n\n    // Helper function to swap two elements in the heap\n    private swap(a: number, b: number): void {}\n\n    // Heapify up to maintain the max-heap property after insertion\n    private heapifyUp(index: number): void {}\n\n    // Heapify down to maintain the max-heap property after deletion\n    private heapifyDown(index: number): void {}\n\n    // Insert an element into the priority queue\n    public push(value: number): void {}\n\n    // Remove the maximum element from the priority queue\n    public pop(): void {}\n\n    // Get the maximum element without removing it\n    public top(): number {}\n\n    // Check if the priority queue is empty\n    public isEmpty(): boolean {}\n\n    // Get the size of the priority queue\n    public size(): number {}\n}", "test_code": "describe(\"Priority Queue - Test Cases\", () => {\n    let pq: PriorityQueue;\n\n    beforeEach(() => {\n        pq = new PriorityQueue();\n    });\n\n    test(\"Insert and access maximum element\", () => {\n        pq.push(10);\n        pq.push(20);\n        pq.push(5);\n        pq.push(30);\n        pq.push(15);\n\n        expect(pq.top()).toBe(30); // Ensure the max element is 30\n    });\n\n    test(\"Remove maximum element\", () => {\n        pq.push(10);\n        pq.push(20);\n        pq.push(5);\n        pq.push(30);\n\n        pq.pop(); // Remove 30\n        expect(pq.top()).toBe(20); // Now the max should be 20\n        pq.pop(); // Remove 20\n        expect(pq.top()).toBe(10); // Now the max should be 10\n    });\n\n    test(\"Check empty queue\", () => {\n        expect(pq.isEmpty()).toBe(true); // Initially empty\n        pq.push(10);\n        expect(pq.isEmpty()).toBe(false); // Now not empty\n        pq.pop();\n        expect(pq.isEmpty()).toBe(true); // Back to empty\n    });\n\n    test(\"Pop from empty queue\", () => {\n        expect(() => pq.pop()).toThrowError(\"Priority queue is empty\"); // Should throw an error\n    });\n\n    test(\"Access top of empty queue\", () => {\n        expect(() => pq.top()).toThrowError(\"Priority queue is empty\"); // Should throw an error\n    });\n\n    test(\"Maintain max-heap property\", () => {\n        pq.push(3);\n        pq.push(1);\n        pq.push(4);\n        pq.push(2);\n\n        expect(pq.top()).toBe(4); // Ensure max is 4\n\n        pq.pop(); // Remove 4\n        expect(pq.top()).toBe(3); // Now max is 3\n\n        pq.push(5); // Add 5\n        expect(pq.top()).toBe(5); // Ensure max is now 5\n    });\n});", "prompt": "please write a typescript class , the class signature as below class PriorityQueue {\n    private heap: number[]; // This will store the elements of the heap\n\n    // Helper function to get the index of the parent\n    private parent(index: number): number {}\n\n    // Helper function to get the index of the left child\n    private leftChild(index: number): number {}\n\n    // Helper function to get the index of the right child\n    private rightChild(index: number): number {}\n\n    // Helper function to swap two elements in the heap\n    private swap(a: number, b: number): void {}\n\n    // Heapify up to maintain the max-heap property after insertion\n    private heapifyUp(index: number): void {}\n\n    // Heapify down to maintain the max-heap property after deletion\n    private heapifyDown(index: number): void {}\n\n    // Insert an element into the priority queue\n    public push(value: number): void {}\n\n    // Remove the maximum element from the priority queue\n    public pop(): void {}\n\n    // Get the maximum element without removing it\n    public top(): number {}\n\n    // Check if the priority queue is empty\n    public isEmpty(): boolean {}\n\n    // Get the size of the priority queue\n    public size(): number {}\n}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass PriorityQueue {\nprivate:\n    std::vector<int> heap; // This will store the elements of the heap\n\n    // Helper function to get the index of the parent\n    int parent(int index) {}\n\n    // Helper function to get the index of the left child\n    int leftChild(int index) {}\n\n    // Helper function to get the index of the right child\n    int rightChild(int index) {}\n\n    // Helper function to swap two elements in the heap\n    void swap(int &a, int &b) {}\n\n    // Heapify up to maintain the max-heap property after insertion\n    void heapifyUp(int index) {}\n\n    // Heapify down to maintain the max-heap property after deletion\n    void heapifyDown(int index) {}\n\npublic:\n    // Insert an element into the priority queue\n    void push(int value) {}\n\n    // Remove the maximum element from the priority queue\n    void pop() {}\n\n    // Get the maximum element without removing it\n    int top() {}\n\n    // Check if the priority queue is empty\n    bool isEmpty() {}\n\n    // Get the size of the priority queue\n    int size() {}\n};", "test_code": "TEST_CASE(\"Priority Queue - Test Cases\") {\n    PriorityQueue pq;\n\n    SECTION(\"Insert and access maximum element\") {\n        pq.push(10);\n        pq.push(20);\n        pq.push(5);\n        pq.push(30);\n        pq.push(15);\n\n        REQUIRE(pq.top() == 30); // Ensure the max element is 30\n    }\n\n    SECTION(\"Remove maximum element\") {\n        pq.push(10);\n        pq.push(20);\n        pq.push(5);\n        pq.push(30);\n\n        pq.pop(); // Remove 30\n        REQUIRE(pq.top() == 20); // Now the max should be 20\n        pq.pop(); // Remove 20\n        REQUIRE(pq.top() == 10); // Now the max should be 10\n    }\n\n    SECTION(\"Check empty queue\") {\n        REQUIRE(pq.isEmpty() == true); // Initially empty\n        pq.push(10);\n        REQUIRE(pq.isEmpty() == false); // Now not empty\n        pq.pop();\n        REQUIRE(pq.isEmpty() == true); // Back to empty\n    }\n\n    SECTION(\"Pop from empty queue\") {\n        REQUIRE_THROWS_AS(pq.pop(), std::runtime_error); // Should throw an error\n    }\n\n    SECTION(\"Access top of empty queue\") {\n        REQUIRE_THROWS_AS(pq.top(), std::runtime_error); // Should throw an error\n    }\n\n    SECTION(\"Maintain max-heap property\") {\n        pq.push(3);\n        pq.push(1);\n        pq.push(4);\n        pq.push(2);\n\n        REQUIRE(pq.top() == 4); // Ensure max is 4\n\n        pq.pop(); // Remove 4\n        REQUIRE(pq.top() == 3); // Now max is 3\n\n        pq.push(5); // Add 5\n        REQUIRE(pq.top() == 5); // Ensure max is now 5\n    }\n}", "prompt": "please write a cpp class , the class signature as below #include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass PriorityQueue {\nprivate:\n    std::vector<int> heap; // This will store the elements of the heap\n\n    // Helper function to get the index of the parent\n    int parent(int index) {}\n\n    // Helper function to get the index of the left child\n    int leftChild(int index) {}\n\n    // Helper function to get the index of the right child\n    int rightChild(int index) {}\n\n    // Helper function to swap two elements in the heap\n    void swap(int &a, int &b) {}\n\n    // Heapify up to maintain the max-heap property after insertion\n    void heapifyUp(int index) {}\n\n    // Heapify down to maintain the max-heap property after deletion\n    void heapifyDown(int index) {}\n\npublic:\n    // Insert an element into the priority queue\n    void push(int value) {}\n\n    // Remove the maximum element from the priority queue\n    void pop() {}\n\n    // Get the maximum element without removing it\n    int top() {}\n\n    // Check if the priority queue is empty\n    bool isEmpty() {}\n\n    // Get the size of the priority queue\n    int size() {}\n};", "addition_info": ""}, "java": {"code_signature": "/**\n * A class representing a max-heap priority queue.\n */\npublic class Answer {\n    static class PriorityQueue{\nprivate List<Integer> heap; // This will store the elements of the heap\n\n    /** \n     * Constructor to initialize the priority queue.\n     */\n    public PriorityQueue() {\n        heap = new ArrayList<>();\n    }\n\n    /**\n     * Helper function to get the index of the parent.\n     * \n     * @param index The index of the child node.\n     * @return The index of the parent node.\n     */\n    private int parent(int index) {\n        return (index - 1) / 2;\n    }\n\n    /**\n     * Helper function to get the index of the left child.\n     * \n     * @param index The index of the parent node.\n     * @return The index of the left child node.\n     */\n    private int leftChild(int index) {\n        return 2 * index + 1;\n    }\n\n    /**\n     * Helper function to get the index of the right child.\n     * \n     * @param index The index of the parent node.\n     * @return The index of the right child node.\n     */\n    private int rightChild(int index) {\n        return 2 * index + 2;\n    }\n\n    /**\n     * Helper function to swap two elements in the heap.\n     * \n     * @param aIndex The index of the first element.\n     * @param bIndex The index of the second element.\n     */\n    private void swap(int aIndex, int bIndex) {\n\n    }\n\n    /**\n     * Heapify up to maintain the max-heap property after insertion.\n     * \n     * @param index The index of the newly inserted element.\n     */\n    private void heapifyUp(int index) {\n        \n    }\n\n    /**\n     * Heapify down to maintain the max-heap property after deletion.\n     * \n     * @param index The index of the element to be heapified down.\n     */\n    private void heapifyDown(int index) {\n        \n    }\n\n    /**\n     * Insert an element into the priority queue.\n     * \n     * @param value The value to be inserted.\n     */\n    public void push(int value) {\n        \n    }\n\n    /**\n     * Remove the maximum element from the priority queue.\n     * \n     * @throws RuntimeException if the priority queue is empty.\n     */\n    public void pop() {\n        \n    }\n\n    /**\n     * Get the maximum element without removing it.\n     * \n     * @return The maximum element.\n     * @throws RuntimeException if the priority queue is empty.\n     */\n    public int top() {\n        \n    }\n\n    /**\n     * Check if the priority queue is empty.\n     * \n     * @return true if the priority queue is empty, false otherwise.\n     */\n    public boolean isEmpty() {\n        return heap.isEmpty();\n    }\n\n    /**\n     * Get the size of the priority queue.\n     * \n     * @return The number of elements in the priority queue.\n     */\n    public int size() {\n        return heap.size();\n    }\n    }\n    \n}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static junit.framework.TestCase.*;\nimport static org.real.temp.Answer.*;\n\n\npublic class Tester {\n    private PriorityQueue pq;\n\n    @Before\n    public void setUp() {\n        pq = new PriorityQueue();\n    }\n\n    @Test\n    public void testInsertAndAccessMaximumElement() {\n        pq.push(10);\n        pq.push(20);\n        pq.push(5);\n        pq.push(30);\n        pq.push(15);\n\n        assertEquals(30, pq.top()); // Ensure the max element is 30\n    }\n\n    @Test\n    public void testRemoveMaximumElement() {\n        pq.push(10);\n        pq.push(20);\n        pq.push(5);\n        pq.push(30);\n\n        pq.pop(); // Remove 30\n        assertEquals(20, pq.top()); // Now the max should be 20\n        pq.pop(); // Remove 20\n        assertEquals(10, pq.top()); // Now the max should be 10\n    }\n\n    @Test\n    public void testCheckEmptyQueue() {\n        assertTrue(pq.isEmpty()); // Initially empty\n        pq.push(10);\n        assertFalse(pq.isEmpty()); // Now not empty\n        pq.pop();\n        assertTrue(pq.isEmpty()); // Back to empty\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testPopFromEmptyQueue() {\n        pq.pop(); // Should throw an error\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testAccessTopOfEmptyQueue() {\n        pq.top(); // Should throw an error\n    }\n\n    @Test\n    public void testMaintainMaxHeapProperty() {\n        pq.push(3);\n        pq.push(1);\n        pq.push(4);\n        pq.push(2);\n\n        assertEquals(4, pq.top()); // Ensure max is 4\n\n        pq.pop(); // Remove 4\n        assertEquals(3, pq.top()); // Now max is 3\n\n        pq.push(5); // Add 5\n        assertEquals(5, pq.top()); // Ensure max is now 5\n    }\n}", "prompt": "please write a java class , the function signature as below /**\n * A class representing a max-heap priority queue.\n */\npublic class Answer {\n    static class PriorityQueue{\nprivate List<Integer> heap; // This will store the elements of the heap\n\n    /** \n     * Constructor to initialize the priority queue.\n     */\n    public PriorityQueue() {\n        heap = new ArrayList<>();\n    }\n\n    /**\n     * Helper function to get the index of the parent.\n     * \n     * @param index The index of the child node.\n     * @return The index of the parent node.\n     */\n    private int parent(int index) {\n        return (index - 1) / 2;\n    }\n\n    /**\n     * Helper function to get the index of the left child.\n     * \n     * @param index The index of the parent node.\n     * @return The index of the left child node.\n     */\n    private int leftChild(int index) {\n        return 2 * index + 1;\n    }\n\n    /**\n     * Helper function to get the index of the right child.\n     * \n     * @param index The index of the parent node.\n     * @return The index of the right child node.\n     */\n    private int rightChild(int index) {\n        return 2 * index + 2;\n    }\n\n    /**\n     * Helper function to swap two elements in the heap.\n     * \n     * @param aIndex The index of the first element.\n     * @param bIndex The index of the second element.\n     */\n    private void swap(int aIndex, int bIndex) {\n\n    }\n\n    /**\n     * Heapify up to maintain the max-heap property after insertion.\n     * \n     * @param index The index of the newly inserted element.\n     */\n    private void heapifyUp(int index) {\n        \n    }\n\n    /**\n     * Heapify down to maintain the max-heap property after deletion.\n     * \n     * @param index The index of the element to be heapified down.\n     */\n    private void heapifyDown(int index) {\n        \n    }\n\n    /**\n     * Insert an element into the priority queue.\n     * \n     * @param value The value to be inserted.\n     */\n    public void push(int value) {\n        \n    }\n\n    /**\n     * Remove the maximum element from the priority queue.\n     * \n     * @throws RuntimeException if the priority queue is empty.\n     */\n    public void pop() {\n        \n    }\n\n    /**\n     * Get the maximum element without removing it.\n     * \n     * @return The maximum element.\n     * @throws RuntimeException if the priority queue is empty.\n     */\n    public int top() {\n        \n    }\n\n    /**\n     * Check if the priority queue is empty.\n     * \n     * @return true if the priority queue is empty, false otherwise.\n     */\n    public boolean isEmpty() {\n        return heap.isEmpty();\n    }\n\n    /**\n     * Get the size of the priority queue.\n     * \n     * @return The number of elements in the priority queue.\n     */\n    public int size() {\n        return heap.size();\n    }\n    }\n    \n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 187, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "implement merge sort algorithm\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef merge_sort(arr: List[int], left: int, right: int):\n    \"\"\"\n    Sorts a portion of an array using the merge sort algorithm.\n\n    Args:\n        arr (List[int]): A list of integers that contains the elements to be sorted.\n        left (int): The starting index of the portion of the array to be sorted.\n        right (int): The ending index of the portion of the array to be sorted.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_sort_empty_array(self):\n        \"\"\"Test sorting an empty array.\"\"\"\n        empty_array = []\n        merge_sort(empty_array, 0, len(empty_array) - 1)\n        self.assertTrue(len(empty_array) == 0)  # Assert that the array is still empty\n\n    def test_sort_single_element_array(self):\n        \"\"\"Test sorting a single element array.\"\"\"\n        single_element = [1]\n        merge_sort(single_element, 0, len(single_element) - 1)\n        self.assertEqual(single_element, [1])  # Assert that it remains the same\n\n    def test_sort_sorted_array(self):\n        \"\"\"Test sorting a sorted array.\"\"\"\n        sorted_array = [1, 2, 3, 4, 5]\n        merge_sort(sorted_array, 0, len(sorted_array) - 1)\n        self.assertEqual(sorted_array, [1, 2, 3, 4, 5])  # Correct the expected value\n\n    def test_sort_reverse_sorted_array(self):\n        \"\"\"Test sorting a reverse sorted array.\"\"\"\n        reverse_sorted_array = [5, 4, 3, 2, 1]\n        merge_sort(reverse_sorted_array, 0, len(reverse_sorted_array) - 1)\n        self.assertEqual(reverse_sorted_array, [1, 2, 3, 4, 5])  # Assert it sorts correctly\n\n    def test_sort_random_integers(self):\n        \"\"\"Test sorting an array with random integers.\"\"\"\n        random_array = [38, 27, 43, 3, 9, 82, 10]\n        expected_sorted_array = [3, 9, 10, 27, 38, 43, 82]\n        merge_sort(random_array, 0, len(random_array) - 1)\n        self.assertEqual(random_array, expected_sorted_array)  # Assert the sorted array is correct\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef merge_sort(arr: List[int], left: int, right: int):\n    \"\"\"\n    Sorts a portion of an array using the merge sort algorithm.\n\n    Args:\n        arr (List[int]): A list of integers that contains the elements to be sorted.\n        left (int): The starting index of the portion of the array to be sorted.\n        right (int): The ending index of the portion of the array to be sorted.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Sorts a portion of an array using the merge sort algorithm.\n *\n * @param {number[]} arr - An array of integers that contains the\n *                         elements to be sorted.\n * @param {number} left - The starting index of the portion of the array to be\n *                       sorted.\n * @param {number} right - The ending index of the portion of the array to be\n *                        sorted.\n */\nfunction mergeSort(arr, left, right) {}", "test_code": "describe(\"Merge Sort Test Cases\", () => {\n    test(\"Sorting an empty array\", () => {\n        const emptyArray = [];\n        mergeSort(emptyArray, 0, emptyArray.length - 1);\n        expect(emptyArray).toEqual([]);\n    });\n\n    test(\"Sorting a single element array\", () => {\n        const singleElement = [1];\n        mergeSort(singleElement, 0, singleElement.length - 1);\n        expect(singleElement).toEqual([1]);\n    });\n\n    test(\"Sorting a sorted array\", () => {\n        const sortedArray = [1, 2, 3, 4, 5];\n        mergeSort(sortedArray, 0, sortedArray.length - 1);\n        expect(sortedArray).toEqual([1, 2, 3, 4, 5]); // Fixed expected result\n    });\n\n    test(\"Sorting a reverse sorted array\", () => {\n        const reverseSortedArray = [5, 4, 3, 2, 1];\n        mergeSort(reverseSortedArray, 0, reverseSortedArray.length - 1);\n        expect(reverseSortedArray).toEqual([1, 2, 3, 4, 5]);\n    });\n\n    test(\"Sorting an array with random integers\", () => {\n        const randomArray = [38, 27, 43, 3, 9, 82, 10];\n        const expectedSortedArray = [3, 9, 10, 27, 38, 43, 82];\n        mergeSort(randomArray, 0, randomArray.length - 1);\n        expect(randomArray).toEqual(expectedSortedArray);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Sorts a portion of an array using the merge sort algorithm.\n *\n * @param {number[]} arr - An array of integers that contains the\n *                         elements to be sorted.\n * @param {number} left - The starting index of the portion of the array to be\n *                       sorted.\n * @param {number} right - The ending index of the portion of the array to be\n *                        sorted.\n */\nfunction mergeSort(arr, left, right) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Sorts a portion of an array using the merge sort algorithm.\n *\n * @param arr An array of integers that contains the elements to be sorted.\n * @param left The starting index of the portion of the array to be sorted.\n * @param right The ending index of the portion of the array to be sorted.\n */\nfunction mergeSort(arr: number[], left: number, right: number): void {}", "test_code": "describe(\"Merge Sort Test Cases\", () => {\n    \n    test(\"Sorting an empty array\", () => {\n        const emptyArray: number[] = [];\n        mergeSort(emptyArray, 0, emptyArray.length - 1);\n        expect(emptyArray).toEqual([]);\n    });\n\n    test(\"Sorting a single element array\", () => {\n        const singleElement: number[] = [1];\n        mergeSort(singleElement, 0, singleElement.length - 1);\n        expect(singleElement).toEqual([1]);\n    });\n\n    test(\"Sorting a sorted array\", () => {\n        const sortedArray: number[] = [1, 2, 3, 4, 5];\n        mergeSort(sortedArray, 0, sortedArray.length - 1);\n        expect(sortedArray).toEqual([1, 2, 3, 4, 5]);\n    });\n\n    test(\"Sorting a reverse sorted array\", () => {\n        const reverseSortedArray: number[] = [5, 4, 3, 2, 1];\n        mergeSort(reverseSortedArray, 0, reverseSortedArray.length - 1);\n        expect(reverseSortedArray).toEqual([1, 2, 3, 4, 5]);\n    });\n\n    test(\"Sorting an array with random integers\", () => {\n        const randomArray: number[] = [38, 27, 43, 3, 9, 82, 10];\n        const expectedSortedArray: number[] = [3, 9, 10, 27, 38, 43, 82];\n        mergeSort(randomArray, 0, randomArray.length - 1);\n        expect(randomArray).toEqual(expectedSortedArray);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Sorts a portion of an array using the merge sort algorithm.\n *\n * @param arr An array of integers that contains the elements to be sorted.\n * @param left The starting index of the portion of the array to be sorted.\n * @param right The ending index of the portion of the array to be sorted.\n */\nfunction mergeSort(arr: number[], left: number, right: number): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Sorts a portion of an array using the merge sort algorithm.\n *\n *\n * @param arr A reference to a vector of integers that contains the\n *            elements to be sorted.\n * @param left The starting index of the portion of the array to be\n *             sorted.\n * @param right The ending index of the portion of the array to be\n *              sorted.\n */\nvoid merge_sort(std::vector<int>& arr, int left, int right) {}", "test_code": "TEST_CASE(\"Merge Sort Test Cases\", \"[merge_sort]\") {\n    SECTION(\"Sorting an empty array\") {\n        std::vector<int> empty_array = {};\n        merge_sort(empty_array, 0, empty_array.size() - 1);\n        REQUIRE(empty_array.empty() == true);\n    }\n\n    SECTION(\"Sorting a single element array\") {\n        std::vector<int> single_element = {1};\n        merge_sort(single_element, 0, single_element.size() - 1);\n        REQUIRE(single_element == std::vector<int>{1});\n    }\n\n    SECTION(\"Sorting a sorted array\") {\n        std::vector<int> sorted_array = {1, 2, 3, 4, 5};\n        merge_sort(sorted_array, 0, sorted_array.size() - 1);\n        REQUIRE(sorted_array == std::vector<int>{1, 2, 3, 2, 5});\n    }\n\n    SECTION(\"Sorting a reverse sorted array\") {\n        std::vector<int> reverse_sorted_array = {5, 4, 3, 2, 1};\n        merge_sort(reverse_sorted_array, 0, reverse_sorted_array.size() - 1);\n        REQUIRE(reverse_sorted_array == std::vector<int>{1, 2, 3, 4, 5});\n    }\n\n    SECTION(\"Sorting an array with random integers\") {\n        std::vector<int> random_array = {38, 27, 43, 3, 9, 82, 10};\n        std::vector<int> expected_sorted_array = {3, 9, 10, 27, 38, 43, 82};\n        merge_sort(random_array, 0, random_array.size() - 1);\n        REQUIRE(random_array == expected_sorted_array);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Sorts a portion of an array using the merge sort algorithm.\n *\n *\n * @param arr A reference to a vector of integers that contains the\n *            elements to be sorted.\n * @param left The starting index of the portion of the array to be\n *             sorted.\n * @param right The ending index of the portion of the array to be\n *              sorted.\n */\nvoid merge_sort(std::vector<int>& arr, int left, int right) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Sorts a portion of an array using the merge sort algorithm.\n *\n * @param arr An array of integers that contains the elements to be sorted.\n * @param left The starting index of the portion of the array to be sorted.\n * @param right The ending index of the portion of the array to be sorted.\n */\npublic void mergeSort(int[] arr, int left, int right) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testEmptyArray() {\n        int[] emptyArray = {};\n        mergeSort(emptyArray, 0, emptyArray.length - 1);\n        assertArrayEquals(new int[]{}, emptyArray);\n    }\n\n    @Test\n    public void testSingleElementArray() {\n        int[] singleElement = {1};\n        mergeSort(singleElement, 0, singleElement.length - 1);\n        assertArrayEquals(new int[]{1}, singleElement);\n    }\n\n    @Test\n    public void testSortedArray() {\n        int[] sortedArray = {1, 2, 3, 4, 5};\n        mergeSort(sortedArray, 0, sortedArray.length - 1);\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5}, sortedArray);\n    }\n\n    @Test\n    public void testReverseSortedArray() {\n        int[] reverseSortedArray = {5, 4, 3, 2, 1};\n        mergeSort(reverseSortedArray, 0, reverseSortedArray.length - 1);\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5}, reverseSortedArray);\n    }\n\n    @Test\n    public void testRandomArray() {\n        int[] randomArray = {38, 27, 43, 3, 9, 82, 10};\n        int[] expectedSortedArray = {3, 9, 10, 27, 38, 43, 82};\n        mergeSort(randomArray, 0, randomArray.length - 1);\n        assertArrayEquals(expectedSortedArray, randomArray);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Sorts a portion of an array using the merge sort algorithm.\n *\n * @param arr An array of integers that contains the elements to be sorted.\n * @param left The starting index of the portion of the array to be sorted.\n * @param right The ending index of the portion of the array to be sorted.\n */\npublic void mergeSort(int[] arr, int left, int right) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 188, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "implement a function that performs Shell sort on an array", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef shell_sort(arr: List[int]):\n    \"\"\"\n    Implement a function that performs Shell sort on an array.\n\n    Args:\n        arr (List[int]): The array to be sorted.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\n\nfrom more_itertools import is_sorted\n\n\nclass Tester(unittest.TestCase):\n    \"\"\"Unit tests for the Shell sort functionality.\"\"\"\n\n    def test_already_sorted_array(self):\n        \"\"\"Test Case 1: Already sorted array.\"\"\"\n        arr = [1, 2, 3, 4, 5]\n        shell_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n    def test_reverse_sorted_array(self):\n        \"\"\"Test Case 2: Reverse sorted array.\"\"\"\n        arr = [5, 4, 3, 2, 1]\n        shell_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n    def test_array_with_duplicate_elements(self):\n        \"\"\"Test Case 3: Array with duplicate elements.\"\"\"\n        arr = [4, 2, 2, 4, 1]\n        shell_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n    def test_array_with_negative_numbers(self):\n        \"\"\"Test Case 4: Array with negative numbers.\"\"\"\n        arr = [-3, -1, -4, -2, 0]\n        shell_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n    def test_empty_array(self):\n        \"\"\"Test Case 5: Empty array.\"\"\"\n        arr = []\n        shell_sort(arr)\n        self.assertTrue(is_sorted(arr))\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef shell_sort(arr: List[int]):\n    \"\"\"\n    Implement a function that performs Shell sort on an array.\n\n    Args:\n        arr (List[int]): The array to be sorted.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Implement a function that performs Shell sort on an array\n * @param {number[]} arr - The array to be sorted\n */\nfunction shellSort(arr) {}", "test_code": "function isSorted(arr) {\n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Test suite for shellSort\ndescribe('Shell sort', () => {\n    test('Basic functionality', () => {\n        // Test Case 1: Already sorted array\n        let arr1 = [1, 2, 3, 4, 5];\n        shellSort(arr1);\n        expect(isSorted(arr1)).toBe(true);\n\n        // Test Case 2: Reverse sorted array\n        let arr2 = [5, 4, 3, 2, 1];\n        shellSort(arr2);\n        expect(isSorted(arr2)).toBe(true);\n\n        // Test Case 3: Array with duplicate elements\n        let arr3 = [4, 2, 2, 4, 1];\n        shellSort(arr3);\n        expect(isSorted(arr3)).toBe(true);\n\n        // Test Case 4: Array with negative numbers\n        let arr4 = [-3, -1, -4, -2, 0];\n        shellSort(arr4);\n        expect(isSorted(arr4)).toBe(true);\n\n        // Test Case 5: Empty array\n        let arr5 = [];\n        shellSort(arr5);\n        expect(isSorted(arr5)).toBe(true);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Implement a function that performs Shell sort on an array\n * @param {number[]} arr - The array to be sorted\n */\nfunction shellSort(arr) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Implement a function that performs Shell sort on an array\n * @param arr - The array to be sorted\n */\nfunction shellSort(arr: number[]): void {}", "test_code": "function isSorted(arr: number[]): boolean {\n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\ndescribe(\"Shell sort - Basic functionality\", () => {\n    test(\"Test Case 1: Already sorted array\", () => {\n        const arr = [1, 2, 3, 4, 5];\n        shellSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n\n    test(\"Test Case 2: Reverse sorted array\", () => {\n        const arr = [5, 4, 3, 2, 1];\n        shellSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n\n    test(\"Test Case 3: Array with duplicate elements\", () => {\n        const arr = [4, 2, 2, 4, 1];\n        shellSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n\n    test(\"Test Case 4: Array with negative numbers\", () => {\n        const arr = [-3, -1, -4, -2, 0];\n        shellSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n\n    test(\"Test Case 5: Empty array\", () => {\n        const arr: number[] = [];\n        shellSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Implement a function that performs Shell sort on an array\n * @param arr - The array to be sorted\n */\nfunction shellSort(arr: number[]): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * implement a function that performs Shell sort on an array\n * @param arr\n */\nvoid shellSort(std::vector<int>& arr) {\n}", "test_code": "\nbool isSorted(const std::vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nTEST_CASE(\"Shell sort - Basic functionality\", \"[shellSort]\") {\n    SECTION(\"Test Case 1: Already sorted array\") {\n        std::vector<int> arr = {1, 2, 3, 4, 5};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 2: Reverse sorted array\") {\n        std::vector<int> arr = {5, 4, 3, 2, 1};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 3: Array with duplicate elements\") {\n        std::vector<int> arr = {4, 2, 2, 4, 1};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 4: Array with negative numbers\") {\n        std::vector<int> arr = {-3, -1, -4, -2, 0};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 5: Empty array\") {\n        std::vector<int> arr = {};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * implement a function that performs Shell sort on an array\n * @param arr\n */\nvoid shellSort(std::vector<int>& arr) {\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Implement a function that performs Shell sort on an array.\n * @param arr the array to be sorted.\n */\npublic static void shellSort(int[] arr) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    public static boolean isSorted(int[] arr) {\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] < arr[i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testShellSortBasicFunctionality() {\n        // Test Case 1: Already sorted array\n        int[] arr1 = {1, 2, 3, 4, 5};\n        Answer.shellSort(arr1);\n        assertTrue(isSorted(arr1));\n\n        // Test Case 2: Reverse sorted array\n        int[] arr2 = {5, 4, 3, 2, 1};\n        Answer.shellSort(arr2);\n        assertTrue(isSorted(arr2));\n\n        // Test Case 3: Array with duplicate elements\n        int[] arr3 = {4, 2, 2, 4, 1};\n        Answer.shellSort(arr3);\n        assertTrue(isSorted(arr3));\n\n        // Test Case 4: Array with negative numbers\n        int[] arr4 = {-3, -1, -4, -2, 0};\n        Answer.shellSort(arr4);\n        assertTrue(isSorted(arr4));\n\n        // Test Case 5: Empty array\n        int[] arr5 = {};\n        Answer.shellSort(arr5);\n        assertTrue(isSorted(arr5));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Implement a function that performs Shell sort on an array.\n * @param arr the array to be sorted.\n */\npublic static void shellSort(int[] arr) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 189, "code_type": "method", "original_language": "c&cpp", "question_type": "Data processing and transformation", "summary": "convert a byte array into a Base64 encoded string.", "language_version_list": {"python": {"code_signature": "def base64_encode(data: bytearray) -> str:\n    \"\"\"\n    Encodes a byte array into a Base64 encoded string.\n    Args:\n        data (bytearray): A bytearray representing the input data to be encoded.\n\n    Returns:\n        str: A string containing the Base64 encoded representation of the input data.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    \"\"\"Unit tests for Base64 encoding function.\"\"\"\n\n    def test_empty_input(self):\n        \"\"\"Empty input should return empty string.\"\"\"\n        input_data = bytearray([])\n        self.assertEqual(base64_encode(input_data), \"\")\n    \n    def test_encode_hello(self):\n        \"\"\"Encoding 'hello' should return 'aGVsbG8='.\"\"\"\n        input_data = bytearray([ord('h'), ord('e'), ord('l'), ord('l'), ord('o')])\n        self.assertEqual(base64_encode(input_data), \"aGVsbG8=\")\n    \n    def test_encode_world(self):\n        \"\"\"Encoding 'world' should return 'd29ybGQ='.\"\"\"\n        input_data = bytearray([ord('w'), ord('o'), ord('r'), ord('l'), ord('d')])\n        self.assertEqual(base64_encode(input_data), \"d29ybGQ=\")\n\n    def test_encode_foobar(self):\n        \"\"\"Encoding 'foobar' should return 'Zm9vYmFy'.\"\"\"\n        input_data = bytearray([ord('f'), ord('o'), ord('o'), ord('b'), ord('a'), ord('r')])\n        self.assertEqual(base64_encode(input_data), \"Zm9vYmFy\")\n\n    def test_encode_catch2(self):\n        \"\"\"Encoding 'Catch2' should return 'Q2F0Y2gy'.\"\"\"\n        input_data = bytearray([ord('C'), ord('a'), ord('t'), ord('c'), ord('h'), ord('2')])\n        self.assertEqual(base64_encode(input_data), \"Q2F0Y2gy\")\n    \n    def test_encode_single_byte(self):\n        \"\"\"Encoding single byte 'A' should return 'QQ=='.\"\"\"\n        input_data = bytearray([ord('A')])\n        self.assertEqual(base64_encode(input_data), \"QQ==\")\n", "prompt": "please write a python function , the function signature as below def base64_encode(data: bytearray) -> str:\n    \"\"\"\n    Encodes a byte array into a Base64 encoded string.\n    Args:\n        data (bytearray): A bytearray representing the input data to be encoded.\n\n    Returns:\n        str: A string containing the Base64 encoded representation of the input data.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Encodes a byte array into a Base64 encoded string.\n *\n * This function takes an array of numbers (representing bytes) as input and converts it\n * into a Base64 encoded string.\n *\n * @param {number[]} data An array of numbers representing the input data to be encoded.\n * @return {string} A string containing the Base64 encoded representation of the input data.\n */\nfunction base64Encode(data) {\n}", "test_code": "describe(\"Base64 Encode Tests\", () => {\n\n    test(\"Empty input should return empty string\", () => {\n        const input = [];\n        expect(base64Encode(input)).toBe(\"\");\n    });\n\n    test(\"Encoding 'hello' should return 'aGVsbG8='\", () => {\n        const input = [104, 101, 108, 108, 111]; // ASCII values for 'hello'\n        expect(base64Encode(input)).toBe(\"aGVsbG8=\");\n    });\n\n    test(\"Encoding 'world' should return 'd29ybGQ='\", () => {\n        const input = [119, 111, 114, 108, 100]; // ASCII values for 'world'\n        expect(base64Encode(input)).toBe(\"d29ybGQ=\");\n    });\n\n    test(\"Encoding 'foobar' should return 'Zm9vYmFy'\", () => {\n        const input = [102, 111, 111, 98, 97, 114]; // ASCII values for 'foobar'\n        expect(base64Encode(input)).toBe(\"Zm9vYmFy\");\n    });\n\n    test(\"Encoding 'Catch2' should return 'Q2F0Y2gy'\", () => {\n        const input = [67, 97, 116, 99, 104, 50]; // ASCII values for 'Catch2'\n        expect(base64Encode(input)).toBe(\"Q2F0Y2gy\");\n    });\n\n    test(\"Encoding single byte 'A' should return 'QQ=='\", () => {\n        const input = [65]; // ASCII value for 'A'\n        expect(base64Encode(input)).toBe(\"QQ==\");\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Encodes a byte array into a Base64 encoded string.\n *\n * This function takes an array of numbers (representing bytes) as input and converts it\n * into a Base64 encoded string.\n *\n * @param {number[]} data An array of numbers representing the input data to be encoded.\n * @return {string} A string containing the Base64 encoded representation of the input data.\n */\nfunction base64Encode(data) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Encodes a byte array into a Base64 encoded string.\n *\n * This function takes a Uint8Array data as input and converts it\n * into a Base64 encoded string.\n *\n * @param data A Uint8Array representing the input data to be encoded.\n * @return A string containing the Base64 encoded representation of the input data.\n */\nfunction base64Encode(data: Uint8Array): string {}", "test_code": "describe(\"Base64 Encode Tests\", () => {\n    test(\"Empty input should return empty string\", () => {\n        const input: Uint8Array = new Uint8Array([]);\n        expect(base64Encode(input)).toBe(\"\");\n    });\n\n    test(\"Encoding 'hello' should return 'aGVsbG8='\", () => {\n        const input: Uint8Array = new Uint8Array([104, 101, 108, 108, 111]); // ASCII values for 'hello'\n        expect(base64Encode(input)).toBe(\"aGVsbG8=\");\n    });\n\n    test(\"Encoding 'world' should return 'd29ybGQ='\", () => {\n        const input: Uint8Array = new Uint8Array([119, 111, 114, 108, 100]); // ASCII values for 'world'\n        expect(base64Encode(input)).toBe(\"d29ybGQ=\");\n    });\n\n    test(\"Encoding 'foobar' should return 'Zm9vYmFy'\", () => {\n        const input: Uint8Array = new Uint8Array([102, 111, 111, 98, 97, 114]); // ASCII values for 'foobar'\n        expect(base64Encode(input)).toBe(\"Zm9vYmFy\");\n    });\n\n    test(\"Encoding 'Catch2' should return 'Q2F0Y2gy'\", () => {\n        const input: Uint8Array = new Uint8Array([67, 97, 116, 99, 104, 50]); // ASCII values for 'Catch2'\n        expect(base64Encode(input)).toBe(\"Q2F0Y2gy\");\n    });\n\n    test(\"Encoding single byte 'A' should return 'QQ=='\", () => {\n        const input: Uint8Array = new Uint8Array([65]); // ASCII value for 'A'\n        expect(base64Encode(input)).toBe(\"QQ==\");\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Encodes a byte array into a Base64 encoded string.\n *\n * This function takes a Uint8Array data as input and converts it\n * into a Base64 encoded string.\n *\n * @param data A Uint8Array representing the input data to be encoded.\n * @return A string containing the Base64 encoded representation of the input data.\n */\nfunction base64Encode(data: Uint8Array): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Encodes a byte array into a Base64 encoded string.\n *\n * This function takes a vector of unsigned char data as input and converts it\n * into a Base64 encoded string.\n *\n * @param data A vector of unsigned char representing the input data to be encoded.\n * @return A std::string containing the Base64 encoded representation of the input data.\n *\n */\nstd::string base64_encode(const std::vector<unsigned char>& data);", "test_code": "TEST_CASE(\"Base64 Encode Tests\") {\n\n    SECTION(\"Empty input should return empty string\") {\n        std::vector<unsigned char> input = {};\n        REQUIRE(base64_encode(input) == \"\");\n    }\n\n    SECTION(\"Encoding 'hello' should return 'aGVsbG8='\") {\n        std::vector<unsigned char> input = {'h', 'e', 'l', 'l', 'o'};\n        REQUIRE(base64_encode(input) == \"aGVsbG8=\");\n    }\n\n    SECTION(\"Encoding 'world' should return 'd29ybGQ='\") {\n        std::vector<unsigned char> input = {'w', 'o', 'r', 'l', 'd'};\n        REQUIRE(base64_encode(input) == \"d29ybGQ=\");\n    }\n\n    SECTION(\"Encoding 'foobar' should return 'Zm9vYmFy'\") {\n        std::vector<unsigned char> input = {'f', 'o', 'o', 'b', 'a', 'r'};\n        REQUIRE(base64_encode(input) == \"Zm9vYmFy\");\n    }\n\n    SECTION(\"Encoding 'Catch2' should return 'Q2F0Y2gy'\") {\n        std::vector<unsigned char> input = {'C', 'a', 't', 'c', 'h', '2'};\n        REQUIRE(base64_encode(input) == \"Q2F0Y2gy\");\n    }\n\n    SECTION(\"Encoding single byte 'A' should return 'QQ=='\") {\n        std::vector<unsigned char> input = {'A'};\n        REQUIRE(base64_encode(input) == \"QQ==\");\n    }\n\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Encodes a byte array into a Base64 encoded string.\n *\n * This function takes a vector of unsigned char data as input and converts it\n * into a Base64 encoded string.\n *\n * @param data A vector of unsigned char representing the input data to be encoded.\n * @return A std::string containing the Base64 encoded representation of the input data.\n *\n */\nstd::string base64_encode(const std::vector<unsigned char>& data);", "addition_info": ""}, "java": {"code_signature": "/**\n * Encodes a byte array into a Base64 encoded string.\n *\n * This method takes a byte array as input and converts it\n * into a Base64 encoded string.\n *\n * @param data A byte array representing the input data to be encoded.\n * @return A String containing the Base64 encoded representation of the input data.\n */\npublic String base64Encode(byte[] data) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testEmptyInputShouldReturnEmptyString() {\n        byte[] input = {};\n        assertEquals(\"\", base64Encode(input));\n    }\n\n    @Test\n    public void testEncodingHelloShouldReturnAGVsbG8() {\n        byte[] input = {'h', 'e', 'l', 'l', 'o'};\n        assertEquals(\"aGVsbG8=\", base64Encode(input));\n    }\n\n    @Test\n    public void testEncodingWorldShouldReturnD29ybGQ() {\n        byte[] input = {'w', 'o', 'r', 'l', 'd'};\n        assertEquals(\"d29ybGQ=\", base64Encode(input));\n    }\n\n    @Test\n    public void testEncodingFoobarShouldReturnZm9vYmFy() {\n        byte[] input = {'f', 'o', 'o', 'b', 'a', 'r'};\n        assertEquals(\"Zm9vYmFy\", base64Encode(input));\n    }\n\n    @Test\n    public void testEncodingCatch2ShouldReturnQ2F0Y2gy() {\n        byte[] input = {'C', 'a', 't', 'c', 'h', '2'};\n        assertEquals(\"Q2F0Y2gy\", base64Encode(input));\n    }\n\n    @Test\n    public void testEncodingSingleByteAShouldReturnQQ() {\n        byte[] input = {'A'};\n        assertEquals(\"QQ==\", base64Encode(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Encodes a byte array into a Base64 encoded string.\n *\n * This method takes a byte array as input and converts it\n * into a Base64 encoded string.\n *\n * @param data A byte array representing the input data to be encoded.\n * @return A String containing the Base64 encoded representation of the input data.\n */\npublic String base64Encode(byte[] data) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 190, "code_type": "method", "original_language": "c&cpp", "question_type": "Data processing and transformation", "summary": "parses a given hexadecimal string into its corresponding floating-point number and returns the float value.", "language_version_list": {"python": {"code_signature": "def hex_string_to_float(hex_str: str) -> float:\n    \"\"\"\n    Parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n\n    Args:\n        hex_str (str): The hexadecimal string to be parsed.\n\n    Returns:\n        float: The corresponding floating-point number.\n    \"\"\"\n", "test_code": "import unittest\n\nclass Tester(unittest.TestCase):\n    \n    def test_positive_number(self):\n        \"\"\"Positive number: 40490FDB\"\"\"\n        hex_str = \"40490FDB\"  # 3.14159 in float\n        result = hex_string_to_float(hex_str)\n        self.assertAlmostEqual(result, 3.14159, delta=0.00001)\n\n    def test_negative_number(self):\n        \"\"\"Negative number: C0490FDB\"\"\"\n        hex_str = \"C0490FDB\"  # -3.14159 in float\n        result = hex_string_to_float(hex_str)\n        self.assertAlmostEqual(result, -3.14159, delta=0.00001)\n\n    def test_zero(self):\n        \"\"\"Zero: 00000000\"\"\"\n        hex_str = \"00000000\"  # 0.0 in float\n        result = hex_string_to_float(hex_str)\n        self.assertAlmostEqual(result, 0.0, delta=0.00001)\n\n    def test_small_positive_number(self):\n        \"\"\"Small positive number: 3F800000\"\"\"\n        hex_str = \"3F800000\"  # 1.0 in float\n        result = hex_string_to_float(hex_str)\n        self.assertAlmostEqual(result, 1.0, delta=0.00001)\n\n    def test_small_negative_number(self):\n        \"\"\"Small negative number: BF800000\"\"\"\n        hex_str = \"BF800000\"  # -1.0 in float\n        result = hex_string_to_float(hex_str)\n        self.assertAlmostEqual(result, -1.0, delta=0.00001)\n\n", "prompt": "please write a python function , the function signature as below def hex_string_to_float(hex_str: str) -> float:\n    \"\"\"\n    Parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n\n    Args:\n        hex_str (str): The hexadecimal string to be parsed.\n\n    Returns:\n        float: The corresponding floating-point number.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n * @param {string} hexStr - The hexadecimal string to parse.\n * @return {number} The parsed floating-point number.\n */\nfunction hexStringToFloat(hexStr) {\n\n}", "test_code": "describe(\"Hexadecimal String to Float Conversion\", () => {\n    \n    test(\"Positive number: 40490FDB\", () => {\n        const hexStr = \"40490FDB\"; // 3.14159 in float\n        const result = hexStringToFloat(hexStr);\n        expect(result).toBeCloseTo(3.14159, 5); // Use toBeCloseTo for floating-point comparison\n    });\n\n    test(\"Negative number: C0490FDB\", () => {\n        const hexStr = \"C0490FDB\"; // -3.14159 in float\n        const result = hexStringToFloat(hexStr);\n        expect(result).toBeCloseTo(-3.14159, 5);\n    });\n\n    test(\"Zero: 00000000\", () => {\n        const hexStr = \"00000000\"; // 0.0 in float\n        const result = hexStringToFloat(hexStr);\n        expect(result).toBeCloseTo(0.0, 5);\n    });\n\n    test(\"Small positive number: 3F800000\", () => {\n        const hexStr = \"3F800000\"; // 1.0 in float\n        const result = hexStringToFloat(hexStr);\n        expect(result).toBeCloseTo(1.0, 5);\n    });\n\n    test(\"Small negative number: BF800000\", () => {\n        const hexStr = \"BF800000\"; // -1.0 in float\n        const result = hexStringToFloat(hexStr);\n        expect(result).toBeCloseTo(-1.0, 5);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n * @param {string} hexStr - The hexadecimal string to parse.\n * @return {number} The parsed floating-point number.\n */\nfunction hexStringToFloat(hexStr) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n * @param hexStr - The hexadecimal string to parse.\n * @return The corresponding floating-point number.\n */\nfunction hexStringToFloat(hexStr: string): number {}", "test_code": "describe('Hexadecimal String to Float Conversion', () => {\n    test('Positive number: 40490FDB', () => {\n        const hexStr = '40490FDB'; // 3.14159 in float\n        const result = hexStringToFloat(hexStr);\n        expect(result).toBeCloseTo(3.14159, 5); // 5 decimal places precision\n    });\n\n    test('Negative number: C0490FDB', () => {\n        const hexStr = 'C0490FDB'; // -3.14159 in float\n        const result = hexStringToFloat(hexStr);\n        expect(result).toBeCloseTo(-3.14159, 5); // 5 decimal places precision\n    });\n\n    test('Zero: 00000000', () => {\n        const hexStr = '00000000'; // 0.0 in float\n        const result = hexStringToFloat(hexStr);\n        expect(result).toBeCloseTo(0.0, 5); // 5 decimal places precision\n    });\n\n    test('Small positive number: 3F800000', () => {\n        const hexStr = '3F800000'; // 1.0 in float\n        const result = hexStringToFloat(hexStr);\n        expect(result).toBeCloseTo(1.0, 5); // 5 decimal places precision\n    });\n\n    test('Small negative number: BF800000', () => {\n        const hexStr = 'BF800000'; // -1.0 in float\n        const result = hexStringToFloat(hexStr);\n        expect(result).toBeCloseTo(-1.0, 5); // 5 decimal places precision\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n * @param hexStr - The hexadecimal string to parse.\n * @return The corresponding floating-point number.\n */\nfunction hexStringToFloat(hexStr: string): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n * @param hexStr\n * @return\n */\nfloat hexStringToFloat(const std::string& hexStr) {\n\n}", "test_code": "TEST_CASE(\"Hexadecimal String to Float Conversion\", \"[hexStringToFloat]\") {\n\n    SECTION(\"Positive number: 40490FDB\") {\n        std::string hexStr = \"40490FDB\"; // 3.14159 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(3.14159f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Negative number: C0490FDB\") {\n        std::string hexStr = \"C0490FDB\"; // -3.14159 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(-3.14159f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Zero: 00000000\") {\n        std::string hexStr = \"00000000\"; // 0.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(0.0f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Small positive number: 3F800000\") {\n        std::string hexStr = \"3F800000\"; // 1.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(1.0f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Small negative number: BF800000\") {\n        std::string hexStr = \"BF800000\"; // -1.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(-1.0f).epsilon(0.00001f));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n * @param hexStr\n * @return\n */\nfloat hexStringToFloat(const std::string& hexStr) {\n\n}", "addition_info": ""}, "java": {"code_signature": "package org.real.temp;\n\n/**\n * Parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n *\n * @param hexStr the hexadecimal string to be parsed\n * @return the corresponding float value\n */\npublic float hexStringToFloat(String hexStr) {\n    // Method implementation goes here\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testHexStringToFloatPositive() {\n        String hexStr = \"40490FDB\"; // 3.14159 in float\n        float result = hexStringToFloat(hexStr);\n        assertEquals(3.14159f, result, 0.00001f);\n    }\n\n    @Test\n    public void testHexStringToFloatNegative() {\n        String hexStr = \"C0490FDB\"; // -3.14159 in float\n        float result = hexStringToFloat(hexStr);\n        assertEquals(-3.14159f, result, 0.00001f);\n    }\n\n    @Test\n    public void testHexStringToFloatZero() {\n        String hexStr = \"00000000\"; // 0.0 in float\n        float result = hexStringToFloat(hexStr);\n        assertEquals(0.0f, result, 0.00001f);\n    }\n\n    @Test\n    public void testHexStringToFloatSmallPositive() {\n        String hexStr = \"3F800000\"; // 1.0 in float\n        float result = hexStringToFloat(hexStr);\n        assertEquals(1.0f, result, 0.00001f);\n    }\n\n    @Test\n    public void testHexStringToFloatSmallNegative() {\n        String hexStr = \"BF800000\"; // -1.0 in float\n        float result = hexStringToFloat(hexStr);\n        assertEquals(-1.0f, result, 0.00001f);\n    }\n}", "prompt": "please write a java function , the function signature as below package org.real.temp;\n\n/**\n * Parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n *\n * @param hexStr the hexadecimal string to be parsed\n * @return the corresponding float value\n */\npublic float hexStringToFloat(String hexStr) {\n    // Method implementation goes here\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 191, "code_type": "method", "original_language": "c&cpp", "question_type": "Data processing and transformation", "summary": "Convert a floating-point number to a hexadecimal string. The process involves interpreting the bit pattern of the floating-point number as an unsigned integer and then formatting this integer value as a hexadecimal string without any prefix (like 0x). The output string should be 8 characters long, with leading zeros added if necessary to meet this length requirement.", "language_version_list": {"python": {"code_signature": "def float_to_hex(value: float) -> str:\n    \"\"\"\n    Converts a floating-point number to its hexadecimal representation.\n\n    Args:\n        value (float): The float value to be converted to hexadecimal.\n\n    Returns:\n        str: A string containing the hexadecimal representation of the input float.\n    \"\"\"\n", "test_code": "import unittest\n\nclass Tester(unittest.TestCase):\n    \"\"\"Test case for the float_to_hex function.\"\"\"\n\n    def test_positive_float(self):\n        \"\"\"Test with positive float 123.456.\"\"\"\n        input_value = 123.456\n        expected = \"42f6e979\"\n        self.assertEqual(float_to_hex(input_value), expected)\n\n    def test_negative_float(self):\n        \"\"\"Test with negative float -123.456.\"\"\"\n        input_value = -123.456\n        expected = \"c2f6e979\"\n        self.assertEqual(float_to_hex(input_value), expected)\n\n    def test_zero(self):\n        \"\"\"Test with zero.\"\"\"\n        input_value = 0.0\n        expected = \"00000000\"\n        self.assertEqual(float_to_hex(input_value), expected)\n\n    def test_small_positive_float(self):\n        \"\"\"Test with small positive float 0.0001.\"\"\"\n        input_value = 0.0001\n        expected = \"38d1b717\"\n        self.assertEqual(float_to_hex(input_value), expected)\n\n    def test_large_float(self):\n        \"\"\"Test with large float 1e30.\"\"\"\n        input_value = 1e30\n        expected = \"7149f2ca\"\n        self.assertEqual(float_to_hex(input_value), expected)\n", "prompt": "please write a python function , the function signature as below def float_to_hex(value: float) -> str:\n    \"\"\"\n    Converts a floating-point number to its hexadecimal representation.\n\n    Args:\n        value (float): The float value to be converted to hexadecimal.\n\n    Returns:\n        str: A string containing the hexadecimal representation of the input float.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a floating-point number to its hexadecimal representation.\n *\n * @param {number} value The float value to be converted to hexadecimal.\n * @return {string} A string containing the hexadecimal representation of the\n *         input float.\n *\n * @note The output string will be in lowercase hexadecimal format.\n */\nfunction floatToHex(value) {}", "test_code": "describe(\"floatToHex tests\", () => {\n    test(\"Test with positive float 123.456\", () => {\n        const input = 123.456;\n        const expected = \"42f6e979\";\n        expect(floatToHex(input)).toBe(expected);\n    });\n\n    test(\"Test with negative float -123.456\", () => {\n        const input = -123.456;\n        const expected = \"c2f6e979\";\n        expect(floatToHex(input)).toBe(expected);\n    });\n\n    test(\"Test with zero\", () => {\n        const input = 0.0;\n        const expected = \"00000000\";\n        expect(floatToHex(input)).toBe(expected);\n    });\n\n    test(\"Test with small positive float 0.0001\", () => {\n        const input = 0.0001;\n        const expected = \"38d1b717\";\n        expect(floatToHex(input)).toBe(expected);\n    });\n\n    test(\"Test with large float 1e30\", () => {\n        const input = 1e30;\n        const expected = \"7149f2ca\";\n        expect(floatToHex(input)).toBe(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a floating-point number to its hexadecimal representation.\n *\n * @param {number} value The float value to be converted to hexadecimal.\n * @return {string} A string containing the hexadecimal representation of the\n *         input float.\n *\n * @note The output string will be in lowercase hexadecimal format.\n */\nfunction floatToHex(value) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a floating-point number to its hexadecimal representation.\n *\n * @param value The float value to be converted to hexadecimal.\n * @returns A string containing the hexadecimal representation of the\n *          input float.\n *\n * @note The output string will be in lowercase hexadecimal format.\n */\nfunction floatToHex(value: number): string {}", "test_code": "describe(\"floatToHex tests\", () => {\n    test(\"Test with positive float 123.456\", () => {\n        const input = 123.456;\n        const expected = \"42f6e979\";\n        expect(floatToHex(input)).toBe(expected);\n    });\n\n    test(\"Test with negative float -123.456\", () => {\n        const input = -123.456;\n        const expected = \"c2f6e979\";\n        expect(floatToHex(input)).toBe(expected);\n    });\n\n    test(\"Test with zero\", () => {\n        const input = 0.0;\n        const expected = \"00000000\";\n        expect(floatToHex(input)).toBe(expected);\n    });\n\n    test(\"Test with small positive float 0.0001\", () => {\n        const input = 0.0001;\n        const expected = \"38d1b717\";\n        expect(floatToHex(input)).toBe(expected);\n    });\n\n    test(\"Test with large float 1e30\", () => {\n        const input = 1e30;\n        const expected = \"7149f2ca\";\n        expect(floatToHex(input)).toBe(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a floating-point number to its hexadecimal representation.\n *\n * @param value The float value to be converted to hexadecimal.\n * @returns A string containing the hexadecimal representation of the\n *          input float.\n *\n * @note The output string will be in lowercase hexadecimal format.\n */\nfunction floatToHex(value: number): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a floating-point number to its hexadecimal representation.\n *\n * @param value The float value to be converted to hexadecimal.\n * @return A std::string containing the hexadecimal representation of the\n *         input float.\n *\n * @note The output string will be in lowercase hexadecimal format.\n */\nstd::string floatToHex(float value) {}", "test_code": "TEST_CASE(\"floatToHex tests\", \"[floatToHex]\") {\n    SECTION(\"Test with positive float 123.456\") {\n        float input = 123.456f;\n        std::string expected = \"42f6e979\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with negative float -123.456\") {\n        float input = -123.456f;\n        std::string expected = \"c2f6e979\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with zero\") {\n        float input = 0.0f;\n        std::string expected = \"00000000\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with small positive float 0.0001\") {\n        float input = 0.0001f;\n        std::string expected = \"38d1b717\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with large float 1e30\") {\n        float input = 1e30f;\n        std::string expected = \"7149f2ca\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a floating-point number to its hexadecimal representation.\n *\n * @param value The float value to be converted to hexadecimal.\n * @return A std::string containing the hexadecimal representation of the\n *         input float.\n *\n * @note The output string will be in lowercase hexadecimal format.\n */\nstd::string floatToHex(float value) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a floating-point number to its hexadecimal representation.\n *\n * @param value The float value to be converted to hexadecimal.\n * @return A String containing the hexadecimal representation of the\n *         input float.\n *\n * @note The output string will be in lowercase hexadecimal format.\n */\npublic static String floatToHex(float value) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testFloatToHexPositive() {\n        float input = 123.456f;\n        String expected = \"42f6e979\";\n        assertEquals(expected, Answer.floatToHex(input));\n    }\n\n    @Test\n    public void testFloatToHexNegative() {\n        float input = -123.456f;\n        String expected = \"c2f6e979\";\n        assertEquals(expected, Answer.floatToHex(input));\n    }\n\n    @Test\n    public void testFloatToHexZero() {\n        float input = 0.0f;\n        String expected = \"00000000\";\n        assertEquals(expected, Answer.floatToHex(input));\n    }\n\n    @Test\n    public void testFloatToHexSmallPositive() {\n        float input = 0.0001f;\n        String expected = \"38d1b717\";\n        assertEquals(expected, Answer.floatToHex(input));\n    }\n\n    @Test\n    public void testFloatToHexLarge() {\n        float input = 1e30f;\n        String expected = \"7149f2ca\";\n        assertEquals(expected, Answer.floatToHex(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a floating-point number to its hexadecimal representation.\n *\n * @param value The float value to be converted to hexadecimal.\n * @return A String containing the hexadecimal representation of the\n *         input float.\n *\n * @note The output string will be in lowercase hexadecimal format.\n */\npublic static String floatToHex(float value) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 192, "code_type": "method", "original_language": "c&cpp", "question_type": "Data processing and transformation", "summary": "Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.", "language_version_list": {"python": {"code_signature": "def hex_string_to_unsigned_int(hex_string: str) -> int:\n    \"\"\"\n    Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.\n\n    Args:\n        hex_string (str): The hexadecimal string to be converted.\n\n    Returns:\n        int: The unsigned integer value represented by the hexadecimal string.\n    \"\"\"\n", "test_code": "import unittest\n\nclass Tester(unittest.TestCase):\n    def test_valid_hex_string_1(self):\n        self.assertEqual(hex_string_to_unsigned_int(\"1A3F\"), 6719)  # 1A3F in hex is 6719 in decimal\n\n    def test_valid_hex_string_2(self):\n        self.assertEqual(hex_string_to_unsigned_int(\"FFFF\"), 65535)  # FFFF in hex is 65535 in decimal\n\n    def test_valid_hex_string_3(self):\n        self.assertEqual(hex_string_to_unsigned_int(\"0\"), 0)  # 0 in hex is 0 in decimal\n\n    def test_valid_hex_string_4(self):\n        self.assertEqual(hex_string_to_unsigned_int(\"7F\"), 127)  # 7F in hex is 127 in decimal\n\n    def test_valid_hex_string_5(self):\n        self.assertEqual(hex_string_to_unsigned_int(\"ABC123\"), 11256099)  # ABC123 in hex is 11256099 in decimal\n\n    def test_lowercase_hex_string(self):\n        self.assertEqual(hex_string_to_unsigned_int(\"abcd\"), 43981)  # abcd in hex is 43981 in decimal\n\n    def test_hex_string_with_leading_zeroes(self):\n        self.assertEqual(hex_string_to_unsigned_int(\"0001\"), 1)  # 0001 in hex is 1 in decimal\n\n    def test_mixed_case_hex_string(self):\n        self.assertEqual(hex_string_to_unsigned_int(\"AbCdEf\"), 11259375)  # AbCdEf in hex is 11259375 in decimal", "prompt": "please write a python function , the function signature as below def hex_string_to_unsigned_int(hex_string: str) -> int:\n    \"\"\"\n    Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.\n\n    Args:\n        hex_string (str): The hexadecimal string to be converted.\n\n    Returns:\n        int: The unsigned integer value represented by the hexadecimal string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.\n * @param hexString\n * @return\n */\nunsigned int hexStringToUnsignedInt(const std::string& hexString) {\n\n}", "test_code": "TEST_CASE(\"hexStringToUnsignedInt converts hex string to unsigned int\", \"[hexStringToUnsignedInt]\") {\n\n    SECTION(\"Valid hex strings\") {\n        REQUIRE(hexStringToUnsignedInt(\"1A3F\") == 6719); // 1A3F in hex is 6719 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"FFFF\") == 65535); // FFFF in hex is 65535 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"0\") == 0); // 0 in hex is 0 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"7F\") == 127); // 7F in hex is 127 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"ABC123\") == 11256099); // ABC123 in hex is 11256099 in decimal\n    }\n\n    SECTION(\"Lowercase hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"abcd\") == 43981); // abcd in hex is 43981 in decimal\n    }\n\n    SECTION(\"Hex string with leading zeroes\") {\n        REQUIRE(hexStringToUnsignedInt(\"0001\") == 1); // 0001 in hex is 1 in decimal\n    }\n\n    SECTION(\"Empty hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"\") == 0); // Empty string should be treated as 0\n    }\n\n    SECTION(\"Mixed case hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"AbCdEf\") == 11259375); // AbCdEf in hex is 11259375 in decimal\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.\n * @param hexString\n * @return\n */\nunsigned int hexStringToUnsignedInt(const std::string& hexString) {\n\n}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 193, "code_type": "method", "original_language": "c&cpp", "question_type": "Data processing and transformation", "summary": "Inverts the flag bits (the first five digits) of an unsigned integer to a hexadecimal string", "language_version_list": {"python": {"code_signature": "def conv_flags(value: int) -> str:\n    \"\"\"\n    Invert the flag bits of an unsigned integer to a hexadecimal string. The number of bits is not complete by 0.\n    Args:\n        value (int): The unsigned integer whose bits are to be inverted.\n\n    Returns:\n        str: A string containing the hexadecimal representation of the inverted bits.\n    \"\"\"\n", "test_code": "import unittest\n\nclass Tester(unittest.TestCase):\n    \"\"\"\n    Test cases for the conv_flags function.\n    \"\"\"\n    \n    def test_conv_flags_case_1(self):\n        self.assertEqual(conv_flags(0x0000001F), \"FFFFFFE0\")\n\n    def test_conv_flags_case_2(self):\n        self.assertEqual(conv_flags(0x00000015), \"FFFFFFEA\")\n\n    def test_conv_flags_case_3(self):\n        self.assertEqual(conv_flags(0xFFFFFFFF), \"0\")\n\n    def test_conv_flags_case_4(self):\n        self.assertEqual(conv_flags(0x12345678), \"EDCBA987\")\n\n    def test_conv_flags_case_5(self):\n        self.assertEqual(conv_flags(0x00000001), \"FFFFFFFE\")\n\n    def test_conv_flags_case_6(self):\n        self.assertEqual(conv_flags(0x00000003), \"FFFFFFFC\")\n\n    def test_conv_flags_case_7(self):\n        self.assertEqual(conv_flags(0x00000008), \"FFFFFFF7\")\n\n    def test_conv_flags_case_8(self):\n        self.assertEqual(conv_flags(0xABCDEF01), \"543210FE\")", "prompt": "please write a python function , the function signature as below def conv_flags(value: int) -> str:\n    \"\"\"\n    Invert the flag bits of an unsigned integer to a hexadecimal string. The number of bits is not complete by 0.\n    Args:\n        value (int): The unsigned integer whose bits are to be inverted.\n\n    Returns:\n        str: A string containing the hexadecimal representation of the inverted bits.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Invert the flag bits of an unsigned integer to a hexadecimal string. The number of bits is not complete by 0\n *\n * @param value The unsigned integer whose bits are to be inverted.\n * @return A std::string containing the hexadecimal representation of the inverted bits.\n */\nstd::string convFlags(unsigned int value) {\n\n}", "test_code": "TEST_CASE(\"convFlags Test Cases\", \"[convFlags]\") {\n    REQUIRE(convFlags(0x0000001F) == \"FFFFFFE0\");\n\n    REQUIRE(convFlags(0x00000015) == \"FFFFFFEA\");\n\n    REQUIRE(convFlags(0xFFFFFFFF) == \"0\");\n\n    REQUIRE(convFlags(0x12345678) == \"EDCBA987\");\n\n    REQUIRE(convFlags(0x00000001) == \"FFFFFFFE\");\n\n    REQUIRE(convFlags(0x00000003) == \"FFFFFFFC\");\n\n    REQUIRE(convFlags(0x00000008) == \"FFFFFFF7\");\n\n    REQUIRE(convFlags(0xABCDEF01) == \"543210FE\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Invert the flag bits of an unsigned integer to a hexadecimal string. The number of bits is not complete by 0\n *\n * @param value The unsigned integer whose bits are to be inverted.\n * @return A std::string containing the hexadecimal representation of the inverted bits.\n */\nstd::string convFlags(unsigned int value) {\n\n}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 194, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Returns a copy of the specified string via dynamic memory allocation", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Returns a copy of the specified string via dynamic memory allocation\n *\n * @param str The input C-string to be copied.\n * @return A pointer to the dynamically allocated copy of the input string.\n * @throws std::invalid_argument if the input string is null.\n */\nchar* return_string(const char* str) {\n\n}", "test_code": "\nTEST_CASE(\"return_string Test Cases\", \"[return_string]\") {\n    // Test Case 1: Copy a non-empty string\n    const char* original1 = \"Hello, World!\";\n    char* copy1 = return_string(original1);\n    REQUIRE(std::strcmp(copy1, original1) == 0);\n    delete[] copy1;\n\n    // Test Case 2: Copy an empty string\n    const char* original2 = \"\";\n    char* copy2 = return_string(original2);\n    REQUIRE(std::strcmp(copy2, original2) == 0);\n    delete[] copy2;\n\n    // Test Case 3: Copy a string with special characters\n    const char* original3 = \"C++ is fun! @#$%^&*()\";\n    char* copy3 = return_string(original3);\n    REQUIRE(std::strcmp(copy3, original3) == 0);\n    delete[] copy3;\n\n    // Test Case 4: Copy a single character string\n    const char* original4 = \"A\";\n    char* copy4 = return_string(original4);\n    REQUIRE(std::strcmp(copy4, original4) == 0);\n    delete[] copy4;\n\n    // Test Case 5: Passing a null pointer (should throw an exception)\n    REQUIRE_THROWS_AS(return_string(nullptr), std::invalid_argument);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Returns a copy of the specified string via dynamic memory allocation\n *\n * @param str The input C-string to be copied.\n * @return A pointer to the dynamically allocated copy of the input string.\n * @throws std::invalid_argument if the input string is null.\n */\nchar* return_string(const char* str) {\n\n}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 195, "code_type": "class", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Implement a floating-point stack structure based on arrays", "language_version_list": {"python": {"code_signature": "class Stack:\n    \"\"\"\n    Implement a floating-point stack structure based on arrays.\n\n    This class provides basic stack operations including push, pop, peek, and checking if the stack is empty.\n    The stack is implemented using a fixed-size array. If the stack reaches its maximum capacity, no more elements\n    can be pushed onto it until space is freed by popping elements.\n    \"\"\"\n\n    def push(self, value: float):\n        \"\"\"\n        Pushes a floating-point number onto the stack.\n\n        :param value: The floating-point number to be pushed onto the stack.\n        :raises StackOverflowError: If the stack is full.\n        \"\"\"\n\n    def pop(self) -> float:\n        \"\"\"\n        Pops the top element off the stack and returns it.\n\n        :return: The floating-point number that was popped from the stack.\n        :raises StackUnderflowError: If the stack is empty.\n        \"\"\"\n\n    def peek(self) -> float:\n        \"\"\"\n        Returns the top element of the stack without removing it.\n\n        :return: The floating-point number at the top of the stack.\n        :raises StackUnderflowError: If the stack is empty.\n        \"\"\"\n\n    def is_empty(self) -> bool:\n        \"\"\"\n        Checks whether the stack is empty.\n\n        :return: True if the stack is empty; False otherwise.\n        \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_stack_operations(self):\n        \"\"\"Test stack_t Test Cases\"\"\"\n        stack = Stack(10)  # Provide capacity when creating the stack\n\n        # Test Case 1: Pushing and popping a single element\n        stack.push(3.14)\n        self.assertEqual(stack.pop(), 3.14)\n        self.assertTrue(stack.is_empty())  # Change to is_empty\n\n        # Test Case 2: Pushing multiple elements and checking peek\n        stack.push(1.23)\n        stack.push(4.56)\n        self.assertEqual(stack.peek(), 4.56)\n        self.assertEqual(stack.pop(), 4.56)\n        self.assertEqual(stack.pop(), 1.23)\n        self.assertTrue(stack.is_empty())  # Change to is_empty\n\n        # Test Case 3: Pop from an empty stack (should throw an exception)\n        with self.assertRaises(StackUnderflowError):\n            stack.pop()\n\n        # Test Case 4: Peek on an empty stack (should throw an exception)\n        with self.assertRaises(StackUnderflowError):\n            stack.peek()\n\n        # Test Case 5: Push elements until stack is full and attempt to push another element\n        full_stack = Stack(100)  # Provide capacity when creating the stack\n        for i in range(100):\n            full_stack.push(float(i) + 0.5)\n\n        with self.assertRaises(StackOverflowError):\n            full_stack.push(100.5)\n", "prompt": "please write a python class , the class signature as below class Stack:\n    \"\"\"\n    Implement a floating-point stack structure based on arrays.\n\n    This class provides basic stack operations including push, pop, peek, and checking if the stack is empty.\n    The stack is implemented using a fixed-size array. If the stack reaches its maximum capacity, no more elements\n    can be pushed onto it until space is freed by popping elements.\n    \"\"\"\n\n    def push(self, value: float):\n        \"\"\"\n        Pushes a floating-point number onto the stack.\n\n        :param value: The floating-point number to be pushed onto the stack.\n        :raises StackOverflowError: If the stack is full.\n        \"\"\"\n\n    def pop(self) -> float:\n        \"\"\"\n        Pops the top element off the stack and returns it.\n\n        :return: The floating-point number that was popped from the stack.\n        :raises StackUnderflowError: If the stack is empty.\n        \"\"\"\n\n    def peek(self) -> float:\n        \"\"\"\n        Returns the top element of the stack without removing it.\n\n        :return: The floating-point number at the top of the stack.\n        :raises StackUnderflowError: If the stack is empty.\n        \"\"\"\n\n    def is_empty(self) -> bool:\n        \"\"\"\n        Checks whether the stack is empty.\n\n        :return: True if the stack is empty; False otherwise.\n        \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Implement a floating-point stack structure based on arrays\n *\n * This class provides basic stack operations including push, pop, peek, and checking if the stack is empty.\n * The stack is implemented using a fixed-size array. If the stack reaches its maximum capacity, no more elements\n * can be pushed onto it until space is freed by popping elements.\n */\nclass stack_t {\n\t\n};", "test_code": "TEST_CASE(\"stack_t Test Cases\", \"[stack_t]\") {\n    stack_t stack(10); // Provide capacity when creating the stack\n\n    // Test Case 1: Pushing and popping a single element\n    stack.push(3.14f);\n    REQUIRE(stack.pop() == Approx(3.14f));\n    REQUIRE(stack.is_empty() == true); // Change to is_empty\n\n    // Test Case 2: Pushing multiple elements and checking peek\n    stack.push(1.23f);\n    stack.push(4.56f);\n    REQUIRE(stack.peek() == Approx(4.56f));\n    REQUIRE(stack.pop() == Approx(4.56f));\n    REQUIRE(stack.pop() == Approx(1.23f));\n    REQUIRE(stack.is_empty() == true); // Change to is_empty\n\n    // Test Case 3: Pop from an empty stack (should throw an exception)\n    REQUIRE_THROWS_AS(stack.pop(), std::underflow_error);\n\n    // Test Case 4: Peek on an empty stack (should throw an exception)\n    REQUIRE_THROWS_AS(stack.peek(), std::underflow_error);\n\n    // Test Case 5: Push elements until stack is full and attempt to push another element\n    stack_t fullStack(100); // Provide capacity when creating the stack\n    for (int i = 0; i < 100; ++i) {\n        fullStack.push(static_cast<float>(i) + 0.5f);\n    }\n    REQUIRE_THROWS_AS(fullStack.push(100.5f), std::overflow_error);\n}", "prompt": "please write a cpp class , the class signature as below /**\n * Implement a floating-point stack structure based on arrays\n *\n * This class provides basic stack operations including push, pop, peek, and checking if the stack is empty.\n * The stack is implemented using a fixed-size array. If the stack reaches its maximum capacity, no more elements\n * can be pushed onto it until space is freed by popping elements.\n */\nclass stack_t {\n\t\n};", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 196, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef generate_primes(limit: int) -> List[int]:\n    \"\"\"\n    Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm.\n\n    Args:\n        limit (int): The upper bound (inclusive) for finding prime numbers.\n\n    Returns:\n        List[int]: A list of integers containing all prime numbers less than or equal to the limit.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_small_limit(self):\n        \"\"\"Test Case 1: Small limit (10)\"\"\"\n        expected = [2, 3, 5, 7]\n        self.assertEqual(generate_primes(10), expected)\n\n    def test_prime_limit(self):\n        \"\"\"Test Case 2: Prime limit (29)\"\"\"\n        expected = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        self.assertEqual(generate_primes(29), expected)\n\n    def test_non_prime_limit(self):\n        \"\"\"Test Case 3: Non-prime limit (30)\"\"\"\n        expected = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        self.assertEqual(generate_primes(30), expected)\n\n    def test_limit_of_two(self):\n        \"\"\"Test Case 4: Limit of 2 (smallest prime)\"\"\"\n        expected = [2]\n        self.assertEqual(generate_primes(2), expected)\n\n    def test_invalid_limit(self):\n        \"\"\"Test Case 5: Invalid limit (1, should throw an exception)\"\"\"\n        with self.assertRaises(ValueError):  # Catch ValueError instead of std::invalid_argument\n            generate_primes(1)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef generate_primes(limit: int) -> List[int]:\n    \"\"\"\n    Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm.\n\n    Args:\n        limit (int): The upper bound (inclusive) for finding prime numbers.\n\n    Returns:\n        List[int]: A list of integers containing all prime numbers less than or equal to the limit.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param {number} limit The upper bound (inclusive) for finding prime numbers.\n * @return {number[]} An array of integers containing all prime numbers less than or equal to the limit.\n * @throws {Error} if the limit is less than 2.\n */\nfunction generatePrimes(limit) {}", "test_code": "describe(\"Sieve of Eratosthenes Test Cases\", () => {\n    // Test Case 1: Small limit (10)\n    test(\"should return primes less than or equal to 10\", () => {\n        const expected1 = [2, 3, 5, 7];\n        expect(generatePrimes(10)).toEqual(expected1);\n    });\n\n    // Test Case 2: Prime limit (29)\n    test(\"should return primes less than or equal to 29\", () => {\n        const expected2 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];\n        expect(generatePrimes(29)).toEqual(expected2);\n    });\n\n    // Test Case 3: Non-prime limit (30)\n    test(\"should return primes less than or equal to 30\", () => {\n        const expected3 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];\n        expect(generatePrimes(30)).toEqual(expected3);\n    });\n\n    // Test Case 4: Limit of 2 (smallest prime)\n    test(\"should return [2] for limit 2\", () => {\n        const expected4 = [2];\n        expect(generatePrimes(2)).toEqual(expected4);\n    });\n\n    // Test Case 5: Invalid limit (1, should throw an exception)\n    test(\"should throw an error for limit less than 2\", () => {\n        expect(() => generatePrimes(1)).toThrow(\"Limit must be greater than or equal to 2.\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param {number} limit The upper bound (inclusive) for finding prime numbers.\n * @return {number[]} An array of integers containing all prime numbers less than or equal to the limit.\n * @throws {Error} if the limit is less than 2.\n */\nfunction generatePrimes(limit) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return An array of integers containing all prime numbers less than or equal to the limit.\n * @throws Error if the limit is less than 2.\n */\nfunction generatePrimes(limit: number): number[] {}", "test_code": "describe(\"Sieve of Eratosthenes Test Cases\", () => {\n    // Test Case 1: Small limit (10)\n    test(\"should return primes less than or equal to 10\", () => {\n        const expected1 = [2, 3, 5, 7];\n        expect(generatePrimes(10)).toEqual(expected1);\n    });\n\n    // Test Case 2: Prime limit (29)\n    test(\"should return primes less than or equal to 29\", () => {\n        const expected2 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];\n        expect(generatePrimes(29)).toEqual(expected2);\n    });\n\n    // Test Case 3: Non-prime limit (30)\n    test(\"should return primes less than or equal to 30\", () => {\n        const expected3 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];\n        expect(generatePrimes(30)).toEqual(expected3);\n    });\n\n    // Test Case 4: Limit of 2 (smallest prime)\n    test(\"should return [2] for limit of 2\", () => {\n        const expected4 = [2];\n        expect(generatePrimes(2)).toEqual(expected4);\n    });\n\n    // Test Case 5: Invalid limit (1, should throw an exception)\n    test(\"should throw an error for limit of 1\", () => {\n        expect(() => generatePrimes(1)).toThrow(Error);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return An array of integers containing all prime numbers less than or equal to the limit.\n * @throws Error if the limit is less than 2.\n */\nfunction generatePrimes(limit: number): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return A vector of integers containing all prime numbers less than or equal to the limit.\n * @throws std::invalid_argument if the limit is less than 2.\n */\nstd::vector<int> generatePrimes(int limit) {\n\t\n}", "test_code": "TEST_CASE(\"Sieve of Eratosthenes Test Cases\", \"[generatePrimes]\") {\n    // Test Case 1: Small limit (10)\n    std::vector<int> expected1 = {2, 3, 5, 7};\n    REQUIRE(generatePrimes(10) == expected1);\n\n    // Test Case 2: Prime limit (29)\n    std::vector<int> expected2 = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    REQUIRE(generatePrimes(29) == expected2);\n\n    // Test Case 3: Non-prime limit (30)\n    std::vector<int> expected3 = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    REQUIRE(generatePrimes(30) == expected3);\n\n    // Test Case 4: Limit of 2 (smallest prime)\n    std::vector<int> expected4 = {2};\n    REQUIRE(generatePrimes(2) == expected4);\n\n    // Test Case 5: Invalid limit (1, should throw an exception)\n    REQUIRE_THROWS_AS(generatePrimes(1), std::invalid_argument);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return A vector of integers containing all prime numbers less than or equal to the limit.\n * @throws std::invalid_argument if the limit is less than 2.\n */\nstd::vector<int> generatePrimes(int limit) {\n\t\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return A list of integers containing all prime numbers less than or equal to the limit.\n * @throws IllegalArgumentException if the limit is less than 2.\n */\npublic static List<Integer> generatePrimes(int limit) {}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport org.junit.Rule;\nimport org.junit.rules.ExpectedException;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Rule\n    public ExpectedException thrown = ExpectedException.none();\n\n    @Test\n    public void testGeneratePrimes_SmallLimit() {\n        List<Integer> expected = Arrays.asList(2, 3, 5, 7);\n        assertEquals(expected, Answer.generatePrimes(10));\n    }\n\n    @Test\n    public void testGeneratePrimes_PrimeLimit() {\n        List<Integer> expected = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);\n        assertEquals(expected, Answer.generatePrimes(29));\n    }\n\n    @Test\n    public void testGeneratePrimes_NonPrimeLimit() {\n        List<Integer> expected = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);\n        assertEquals(expected, Answer.generatePrimes(30));\n    }\n\n    @Test\n    public void testGeneratePrimes_LimitOfTwo() {\n        List<Integer> expected = Arrays.asList(2);\n        assertEquals(expected, Answer.generatePrimes(2));\n    }\n\n    @Test\n    public void testGeneratePrimes_InvalidLimit() {\n        thrown.expect(IllegalArgumentException.class);\n        thrown.expectMessage(\"Limit must be greater than or equal to 2.\");\n        Answer.generatePrimes(1);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return A list of integers containing all prime numbers less than or equal to the limit.\n * @throws IllegalArgumentException if the limit is less than 2.\n */\npublic static List<Integer> generatePrimes(int limit) {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 197, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Use list data structure to simulate Joseph rings to solve Joseph rings problem\n", "language_version_list": {"python": {"code_signature": "def josephus(n: int, k: int) -> int:\n    \"\"\"\n    Simulates the Josephus problem using a list to represent the circle of people.\n    Args:\n        n (int): The number of people in the circle (1 to n).\n        k (int): The step count (every k-th person will be eliminated).\n\n    Returns:\n        int: The position of the last person remaining (1-indexed).\n    \"\"\"\n", "test_code": "# Unit Test Class\nimport unittest\n\n\nclass TestJosephusProblem(unittest.TestCase):\n\n    def test_case_1(self):\n        self.assertEqual(josephus(7, 3), 4)  # Standard case\n\n    def test_case_2(self):\n        self.assertEqual(josephus(1, 1), 1)  # Only one person\n\n    def test_case_3(self):\n        self.assertEqual(josephus(5, 2), 3)  # Smaller group, step 2\n\n    def test_case_4(self):\n        self.assertEqual(josephus(10, 5), 3)  # Larger group, step 5\n\n    def test_case_5(self):\n        self.assertEqual(josephus(6, 1), 6)  # Eliminate every 1st person\n\n    def test_case_6(self):\n        self.assertEqual(josephus(8, 4), 6)  # Step 4 in a group of 8\n\n    def test_case_7(self):\n        self.assertEqual(josephus(12, 7), 12)  # Larger group, arbitrary step", "prompt": "please write a python function , the function signature as below def josephus(n: int, k: int) -> int:\n    \"\"\"\n    Simulates the Josephus problem using a list to represent the circle of people.\n    Args:\n        n (int): The number of people in the circle (1 to n).\n        k (int): The step count (every k-th person will be eliminated).\n\n    Returns:\n        int: The position of the last person remaining (1-indexed).\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Simulate a game based on the order of prime numbers, using a circular linked list to represent the cyclic structure of players, and remove players one by one.\n *\n * This function creates an instance of the PrimeGame class, which encapsulates the logic\n * for simulating the game. It then calls the findOrder method on the PrimeGame object\n * to determine and return the order in which players are removed based on the sequence of prime numbers.\n *\n * @param {number} n - The number of players in the game.\n * @return {Array<number>} - An array of integers representing the order of players being removed from the ring.\n */\nfunction findOrder(n) {}", "test_code": "describe(\"FindOrder Test Cases\", () => {\n    // Test Case 1: Minimum valid input with 2 players\n    test(\"should return [2, 1] for 2 players\", () => {\n        expect(findOrder(2)).toEqual([2, 1]);\n    });\n\n    // Test Case 2: 3 players\n    test(\"should return [2, 3, 1] for 3 players\", () => {\n        expect(findOrder(3)).toEqual([2, 3, 1]);\n    });\n\n    // Test Case 3: 5 players\n    test(\"should return [2, 5, 3, 4, 1] for 5 players\", () => {\n        expect(findOrder(5)).toEqual([2, 5, 3, 4, 1]);\n    });\n\n    // Test Case 4: 7 players\n    test(\"should return [2, 5, 4, 1, 6, 7, 3] for 7 players\", () => {\n        expect(findOrder(7)).toEqual([2, 5, 4, 1, 6, 7, 3]);\n    });\n\n    // Test Case 5: 10 players\n    test(\"should return [2, 5, 10, 9, 7, 3, 4, 6, 8, 1] for 10 players\", () => {\n        expect(findOrder(10)).toEqual([2, 5, 10, 9, 7, 3, 4, 6, 8, 1]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Simulate a game based on the order of prime numbers, using a circular linked list to represent the cyclic structure of players, and remove players one by one.\n *\n * This function creates an instance of the PrimeGame class, which encapsulates the logic\n * for simulating the game. It then calls the findOrder method on the PrimeGame object\n * to determine and return the order in which players are removed based on the sequence of prime numbers.\n *\n * @param {number} n - The number of players in the game.\n * @return {Array<number>} - An array of integers representing the order of players being removed from the ring.\n */\nfunction findOrder(n) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Simulate a game based on the order of prime numbers, using a circular linked list\n * to represent the cyclic structure of players, and remove players one by one.\n *\n * This function creates an instance of the PrimeGame class, which encapsulates the logic\n * for simulating the game. It then calls the findOrder method on the PrimeGame object\n * to determine and return the order in which players are removed based on the sequence of prime numbers.\n *\n * @param n The number of players in the game.\n * @return An array of numbers representing the order of players being removed from the ring.\n */\nfunction findOrder(n: number): number[] {}", "test_code": "describe(\"FindOrder Test Cases\", () => {\n    // Test Case 1: Minimum valid input with 2 players\n    test(\"should return [2, 1] for 2 players\", () => {\n        expect(findOrder(2)).toEqual([2, 1]);\n    });\n\n    // Test Case 2: 3 players\n    test(\"should return [2, 3, 1] for 3 players\", () => {\n        expect(findOrder(3)).toEqual([2, 3, 1]);\n    });\n\n    // Test Case 3: 5 players\n    test(\"should return [2, 5, 3, 4, 1] for 5 players\", () => {\n        expect(findOrder(5)).toEqual([2, 5, 3, 4, 1]);\n    });\n\n    // Test Case 4: 7 players\n    test(\"should return [2, 5, 4, 1, 6, 7, 3] for 7 players\", () => {\n        expect(findOrder(7)).toEqual([2, 5, 4, 1, 6, 7, 3]);\n    });\n\n    // Test Case 5: 10 players\n    test(\"should return [2, 5, 10, 9, 7, 3, 4, 6, 8, 1] for 10 players\", () => {\n        expect(findOrder(10)).toEqual([2, 5, 10, 9, 7, 3, 4, 6, 8, 1]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Simulate a game based on the order of prime numbers, using a circular linked list\n * to represent the cyclic structure of players, and remove players one by one.\n *\n * This function creates an instance of the PrimeGame class, which encapsulates the logic\n * for simulating the game. It then calls the findOrder method on the PrimeGame object\n * to determine and return the order in which players are removed based on the sequence of prime numbers.\n *\n * @param n The number of players in the game.\n * @return An array of numbers representing the order of players being removed from the ring.\n */\nfunction findOrder(n: number): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Simulate a game based on the order of prime numbers, using a circular linked list to represent the cyclic structure of players, and remove players one by one\n *\n * This function creates an instance of the PrimeGame class, which encapsulates the logic\n * for simulating the game. It then calls the findOrder method on the PrimeGame object\n * to determine and return the order in which players are removed based on the sequence of prime numbers.\n *\n * @param n The number of players in the game.\n * @return A vector of integers representing the order of players being removed from the ring.\n */\nvector<int> findOrder(int n) {\n\n}", "test_code": "TEST_CASE(\"FindOrder Test Cases\", \"[findOrder]\") {\n    // Test Case 1: Minimum valid input with 2 players\n    REQUIRE(findOrder(2) == std::vector<int>{2, 1});\n\n    // Test Case 2: 3 players\n    REQUIRE(findOrder(3) == std::vector<int>{2, 3, 1});\n\n    // Test Case 3: 5 players\n    REQUIRE(findOrder(5) == std::vector<int>{2, 5, 3, 4, 1});\n\n    // Test Case 4: 7 players\n    REQUIRE(findOrder(7) == std::vector<int>{ 2, 5, 4, 1, 6, 7, 3});\n\n    // Test Case 5: 10 players\n    REQUIRE(findOrder(10) == std::vector<int>{ 2, 5, 10, 9, 7, 3, 4, 6, 8, 1});\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Simulate a game based on the order of prime numbers, using a circular linked list to represent the cyclic structure of players, and remove players one by one\n *\n * This function creates an instance of the PrimeGame class, which encapsulates the logic\n * for simulating the game. It then calls the findOrder method on the PrimeGame object\n * to determine and return the order in which players are removed based on the sequence of prime numbers.\n *\n * @param n The number of players in the game.\n * @return A vector of integers representing the order of players being removed from the ring.\n */\nvector<int> findOrder(int n) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Simulates the Josephus problem using a list to represent the circle of people.\n *\n * @param n The number of people in the circle (1 to n).\n * @param k The step count (every k-th person will be eliminated).\n * @return The position of the last person remaining (1-indexed).\n */\npublic static int josephus(int n, int k) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n\n    @Test\n    public void testCase1() {\n        assertEquals(4, josephus(7, 3));  // Standard case\n    }\n\n    @Test\n    public void testCase2() {\n        assertEquals(1, josephus(1, 1));  // Only one person\n    }\n\n    @Test\n    public void testCase3() {\n        assertEquals(3, josephus(5, 2));  // Smaller group, step 2\n    }\n\n    @Test\n    public void testCase4() {\n        assertEquals(3, josephus(10, 5));  // Larger group, step 5\n    }\n\n    @Test\n    public void testCase5() {\n        assertEquals(6, josephus(6, 1));  // Eliminate every 1st person\n    }\n\n    @Test\n    public void testCase6() {\n        assertEquals(6, josephus(8, 4));  // Step 4 in a group of 8\n    }\n\n    @Test\n    public void testCase7() {\n        assertEquals(12, josephus(12, 7));  // Larger group, arbitrary step\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Simulates the Josephus problem using a list to represent the circle of people.\n *\n * @param n The number of people in the circle (1 to n).\n * @param k The step count (every k-th person will be eliminated).\n * @return The position of the last person remaining (1-indexed).\n */\npublic static int josephus(int n, int k) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 198, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Calculate the maximum difference between any two elements in an array of integers, where the larger number must come after the smaller number (i.e., the subsequent element minus the previous element).", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef find_max_difference(l: List[int]) -> int:\n    \"\"\"\n    Finds the maximum difference between elements in the array such that the smaller element appears before the larger one.\n    Args:\n        l (List[int]): A list of integers containing the elements.\n\n    Returns:\n        int: The maximum difference.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_general_case(self):\n        l = [2, 3, 10, 6, 4, 8, 1]\n        self.assertEqual(find_max_difference(l), 8)  # Maximum difference is 10 - 2 = 8\n\n    def test_decreasing_sequence(self):\n        l = [10, 9, 8, 7, 6, 5]\n        self.assertEqual(find_max_difference(l), 0)  # Maximum difference should be 0\n\n    def test_all_elements_same(self):\n        l = [5, 5, 5, 5, 5]\n        self.assertEqual(find_max_difference(l), 0)  # Maximum difference is 5 - 5 = 0\n\n    def test_only_two_elements(self):\n        l = [3, 8]\n        self.assertEqual(find_max_difference(l), 5)  # Maximum difference is 8 - 3 = 5\n\n    def test_single_element(self):\n        l = [4]\n        self.assertEqual(find_max_difference(l), 0)  # Only one element, no difference to calculate\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_max_difference(l: List[int]) -> int:\n    \"\"\"\n    Finds the maximum difference between elements in the array such that the smaller element appears before the larger one.\n    Args:\n        l (List[int]): A list of integers containing the elements.\n\n    Returns:\n        int: The maximum difference.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param {number[]} l An array of integers containing the elements.\n * @return {number} The maximum difference.\n */\nfunction findMaxDifference(l) {}", "test_code": "describe('findMaxDifference', () => {\n    test('General case', () => {\n        const l = [2, 3, 10, 6, 4, 8, 1];\n        expect(findMaxDifference(l)).toBe(8);  // Maximum difference is 10 - 2 = 8\n    });\n\n    test('Decreasing sequence', () => {\n        const l = [10, 9, 8, 7, 6, 5];\n        expect(findMaxDifference(l)).toBe(0);  // Maximum difference should be 0, as all differences are negative\n    });\n\n    test('All elements the same', () => {\n        const l = [5, 5, 5, 5, 5];\n        expect(findMaxDifference(l)).toBe(0);  // Maximum difference is 5 - 5 = 0\n    });\n\n    test('Only two elements', () => {\n        const l = [3, 8];\n        expect(findMaxDifference(l)).toBe(5);  // Maximum difference is 8 - 3 = 5\n    });\n\n    test('Single element', () => {\n        const l = [4];\n        expect(findMaxDifference(l)).toBe(0);  // Only one element, no difference to calculate\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param {number[]} l An array of integers containing the elements.\n * @return {number} The maximum difference.\n */\nfunction findMaxDifference(l) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l An array of integers containing the elements.\n * @return The maximum difference.\n */\nfunction findMaxDifference(l: number[]): number {}", "test_code": "describe('findMaxDifference', () => {\n    // Test case 1: General case\n    test('General case', () => {\n        const l: number[] = [2, 3, 10, 6, 4, 8, 1];\n        expect(findMaxDifference(l)).toBe(8);  // Maximum difference is 10 - 2 = 8\n    });\n\n    // Test case 2: Decreasing sequence\n    test('Decreasing sequence', () => {\n        const l: number[] = [10, 9, 8, 7, 6, 5];\n        expect(findMaxDifference(l)).toBe(0);  // Maximum difference should be 0, as all differences are negative\n    });\n\n    // Test case 3: All elements the same\n    test('All elements the same', () => {\n        const l: number[] = [5, 5, 5, 5, 5];\n        expect(findMaxDifference(l)).toBe(0);  // Maximum difference is 5 - 5 = 0\n    });\n\n    // Test case 4: Only two elements\n    test('Only two elements', () => {\n        const l: number[] = [3, 8];\n        expect(findMaxDifference(l)).toBe(5);  // Maximum difference is 8 - 3 = 5\n    });\n\n    // Test case 5: Only one element\n    test('Single element', () => {\n        const l: number[] = [4];\n        expect(findMaxDifference(l)).toBe(0);  // Only one element, no difference to calculate\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l An array of integers containing the elements.\n * @return The maximum difference.\n */\nfunction findMaxDifference(l: number[]): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l A vector of integers containing the elements.\n * @return The maximum difference.\n */\nint findMaxDifference(const vector<int> &l) {}", "test_code": "TEST_CASE(\"General case\", \"[findMaxDifference]\") {\n    std::vector<int> l = {2, 3, 10, 6, 4, 8, 1};\n    REQUIRE(findMaxDifference(l) == 8);  // Maximum difference is 10 - 2 = 8\n}\n\n// Test case 2: Decreasing sequence\nTEST_CASE(\"Decreasing sequence\", \"[findMaxDifference]\") {\n    std::vector<int> l = {10, 9, 8, 7, 6, 5};\n    REQUIRE(findMaxDifference(l) == 0);  // Maximum difference should be 0, as all differences are negative\n}\n\n// Test case 3: All elements the same\nTEST_CASE(\"All elements the same\", \"[findMaxDifference]\") {\n    std::vector<int> l = {5, 5, 5, 5, 5};\n    REQUIRE(findMaxDifference(l) == 0);  // Maximum difference is 5 - 5 = 0\n}\n\n// Test case 4: Only two elements\nTEST_CASE(\"Only two elements\", \"[findMaxDifference]\") {\n    std::vector<int> l = {3, 8};\n    REQUIRE(findMaxDifference(l) == 5);  // Maximum difference is 8 - 3 = 5\n}\n\n// Test case 5: Only one element\nTEST_CASE(\"Single element\", \"[findMaxDifference]\") {\n    std::vector<int> l = {4};\n    REQUIRE(findMaxDifference(l) == 0);  // Only one element, no difference to calculate\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l A vector of integers containing the elements.\n * @return The maximum difference.\n */\nint findMaxDifference(const vector<int> &l) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l A list of integers containing the elements.\n * @return The maximum difference.\n */\npublic static int findMaxDifference(List<Integer> l) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testGeneralCase() {\n        List<Integer> l = Arrays.asList(2, 3, 10, 6, 4, 8, 1);\n        assertEquals(8, Answer.findMaxDifference(l));  // Maximum difference is 10 - 2 = 8\n    }\n\n    @Test\n    public void testDecreasingSequence() {\n        List<Integer> l = Arrays.asList(10, 9, 8, 7, 6, 5);\n        assertEquals(0, Answer.findMaxDifference(l));  // Maximum difference should be 0\n    }\n\n    @Test\n    public void testAllElementsSame() {\n        List<Integer> l = Arrays.asList(5, 5, 5, 5, 5);\n        assertEquals(0, Answer.findMaxDifference(l));  // Maximum difference is 5 - 5 = 0\n    }\n\n    @Test\n    public void testOnlyTwoElements() {\n        List<Integer> l = Arrays.asList(3, 8);\n        assertEquals(5, Answer.findMaxDifference(l));  // Maximum difference is 8 - 3 = 5\n    }\n\n    @Test\n    public void testSingleElement() {\n        List<Integer> l = Arrays.asList(4);\n        assertEquals(0, Answer.findMaxDifference(l));  // Only one element, no difference to calculate\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l A list of integers containing the elements.\n * @return The maximum difference.\n */\npublic static int findMaxDifference(List<Integer> l) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 200, "code_type": "method", "original_language": "c&cpp", "question_type": "Data processing and transformation", "summary": "Extracts the string contained in the first pair of braces {} from an input string\n", "language_version_list": {"python": {"code_signature": "def extract_string_from_braces(input: str) -> str:\n    \"\"\"\n    Extracts the string contained in the first pair of braces `{}` from the input string.\n\n    Args:\n        input (str): The input string from which the braces content will be extracted.\n\n    Returns:\n        str: A substring enclosed within the first pair of braces, or an error message if braces are missing.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    \"\"\"Test cases for extract_string_from_braces function.\"\"\"\n\n    def test_basic_extraction(self):\n        \"\"\"Basic extraction.\"\"\"\n        input_data = \"This is a sample text with some data {data: \\\"value\\\"} and more text.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"data: \\\"value\\\"\")\n\n    def test_no_braces(self):\n        \"\"\"No braces.\"\"\"\n        input_data = \"This string has no braces.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"No opening brace found.\")\n\n    def test_only_opening_brace(self):\n        \"\"\"Only opening brace.\"\"\"\n        input_data = \"This string has an opening brace { but no closing brace.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"No closing brace found.\")\n\n    def test_only_closing_brace(self):\n        \"\"\"Only closing brace.\"\"\"\n        input_data = \"This string has a closing brace } but no opening brace.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"No opening brace found.\")\n\n    def test_multiple_braces(self):\n        \"\"\"Multiple braces.\"\"\"\n        input_data = \"First {first} and second {second} braces.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"first\")\n\n    def test_empty_braces(self):\n        \"\"\"Empty braces.\"\"\"\n        input_data = \"This string has empty braces {} and some text.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"\")\n", "prompt": "please write a python function , the function signature as below def extract_string_from_braces(input: str) -> str:\n    \"\"\"\n    Extracts the string contained in the first pair of braces `{}` from the input string.\n\n    Args:\n        input (str): The input string from which the braces content will be extracted.\n\n    Returns:\n        str: A substring enclosed within the first pair of braces, or an error message if braces are missing.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extracts the string contained in the first pair of braces `{}` from the input string.\n *\n * @param {string} input - The input string from which the braces content will be extracted.\n * @return {string} A substring enclosed within the first pair of braces, or an error message if braces are missing.\n */\nfunction extractStringFromBraces(input) {\n}", "test_code": "describe(\"Test cases for extractStringFromBraces function\", () => {\n\n    test(\"Basic extraction\", () => {\n        const input = \"This is a sample text with some data {data: \\\"value\\\"} and more text.\";\n        const result = extractStringFromBraces(input);\n        expect(result).toBe(\"{data: \\\"value\\\"}\");\n    });\n\n    test(\"No braces\", () => {\n        const input = \"This string has no braces.\";\n        const result = extractStringFromBraces(input);\n        expect(result).toBe(\"No opening brace found.\");\n    });\n\n    test(\"Only opening brace\", () => {\n        const input = \"This string has an opening brace { but no closing brace.\";\n        const result = extractStringFromBraces(input);\n        expect(result).toBe(\"No closing brace found.\");\n    });\n\n    test(\"Only closing brace\", () => {\n        const input = \"This string has a closing brace } but no opening brace.\";\n        const result = extractStringFromBraces(input);\n        expect(result).toBe(\"No opening brace found.\");\n    });\n\n    test(\"Multiple braces\", () => {\n        const input = \"First {first} and second {second} braces.\";\n        const result = extractStringFromBraces(input);\n        expect(result).toBe(\"{first}\");\n    });\n\n    test(\"Empty braces\", () => {\n        const input = \"This string has empty braces {} and some text.\";\n        const result = extractStringFromBraces(input);\n        expect(result).toBe(\"{}\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Extracts the string contained in the first pair of braces `{}` from the input string.\n *\n * @param {string} input - The input string from which the braces content will be extracted.\n * @return {string} A substring enclosed within the first pair of braces, or an error message if braces are missing.\n */\nfunction extractStringFromBraces(input) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Extracts the string contained in the first pair of braces `{}` from the input string.\n *\n * @param input The input string from which the braces content will be extracted.\n * @return A substring enclosed within the first pair of braces, or an error message if braces are missing.\n */\nfunction extractStringFromBraces(input: string): string {}", "test_code": "describe(\"Test cases for extractStringFromBraces function\", () => {\n    \n    test(\"Basic extraction\", () => {\n        const input = \"This is a sample text with some data {data: \\\"value\\\"} and more text.\";\n        const result = extractStringFromBraces(input);\n        expect(result).toBe(\"{data: \\\"value\\\"}\");\n    });\n\n    test(\"No braces\", () => {\n        const input = \"This string has no braces.\";\n        const result = extractStringFromBraces(input);\n        expect(result).toBe(\"No opening brace found.\");\n    });\n\n    test(\"Only opening brace\", () => {\n        const input = \"This string has an opening brace { but no closing brace.\";\n        const result = extractStringFromBraces(input);\n        expect(result).toBe(\"No closing brace found.\");\n    });\n\n    test(\"Only closing brace\", () => {\n        const input = \"This string has a closing brace } but no opening brace.\";\n        const result = extractStringFromBraces(input);\n        expect(result).toBe(\"No opening brace found.\");\n    });\n\n    test(\"Multiple braces\", () => {\n        const input = \"First {first} and second {second} braces.\";\n        const result = extractStringFromBraces(input);\n        expect(result).toBe(\"{first}\");\n    });\n\n    test(\"Empty braces\", () => {\n        const input = \"This string has empty braces {} and some text.\";\n        const result = extractStringFromBraces(input);\n        expect(result).toBe(\"{}\");\n    });\n\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Extracts the string contained in the first pair of braces `{}` from the input string.\n *\n * @param input The input string from which the braces content will be extracted.\n * @return A substring enclosed within the first pair of braces, or an error message if braces are missing.\n */\nfunction extractStringFromBraces(input: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extracts the string contained in the first pair of braces `{}` from the input string.\n *\n * @param input The input string from which the braces content will be extracted.\n * @return A substring enclosed within the first pair of braces, or an error message if braces are missing.\n */\nstd::string extractStringFromBraces(const std::string& input) {}", "test_code": "TEST_CASE(\"Test cases for extractStringFromBraces function\") {\n\n    SECTION(\"Basic extraction\") {\n        std::string input = \"This is a sample text with some data {data: \\\"value\\\"} and more text.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"{data: \\\"value\\\"}\");\n    }\n\n    SECTION(\"No braces\") {\n        std::string input = \"This string has no braces.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"No opening brace found.\");\n    }\n\n    SECTION(\"Only opening brace\") {\n        std::string input = \"This string has an opening brace { but no closing brace.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"No closing brace found.\");\n    }\n\n    SECTION(\"Only closing brace\") {\n        std::string input = \"This string has a closing brace } but no opening brace.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"No opening brace found.\");\n    }\n    SECTION(\"Multiple braces\") {\n        std::string input = \"First {first} and second {second} braces.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"{first}\");\n    }\n\n    SECTION(\"Empty braces\") {\n        std::string input = \"This string has empty braces {} and some text.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"{}\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts the string contained in the first pair of braces `{}` from the input string.\n *\n * @param input The input string from which the braces content will be extracted.\n * @return A substring enclosed within the first pair of braces, or an error message if braces are missing.\n */\nstd::string extractStringFromBraces(const std::string& input) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Extracts the string contained in the first pair of braces `{}` from the input string.\n *\n * @param input The input string from which the braces content will be extracted.\n * @return A substring enclosed within the first pair of braces, or an error message if braces are missing.\n */\npublic static String extractStringFromBraces(String input) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testBasicExtraction() {\n        String input = \"This is a sample text with some data {data: \\\"value\\\"} and more text.\";\n        String result = extractStringFromBraces(input);\n        assertEquals(\"{data: \\\"value\\\"}\", result);\n    }\n\n    @Test\n    public void testNoBraces() {\n        String input = \"This string has no braces.\";\n        String result = extractStringFromBraces(input);\n        assertEquals(\"No opening brace found.\", result);\n    }\n\n    @Test\n    public void testOnlyOpeningBrace() {\n        String input = \"This string has an opening brace { but no closing brace.\";\n        String result = extractStringFromBraces(input);\n        assertEquals(\"No closing brace found.\", result);\n    }\n\n    @Test\n    public void testOnlyClosingBrace() {\n        String input = \"This string has a closing brace } but no opening brace.\";\n        String result = extractStringFromBraces(input);\n        assertEquals(\"No opening brace found.\", result);\n    }\n\n    @Test\n    public void testMultipleBraces() {\n        String input = \"First {first} and second {second} braces.\";\n        String result = extractStringFromBraces(input);\n        assertEquals(\"{first}\", result);\n    }\n\n    @Test\n    public void testEmptyBraces() {\n        String input = \"This string has empty braces {} and some text.\";\n        String result = extractStringFromBraces(input);\n        assertEquals(\"{}\", result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts the string contained in the first pair of braces `{}` from the input string.\n *\n * @param input The input string from which the braces content will be extracted.\n * @return A substring enclosed within the first pair of braces, or an error message if braces are missing.\n */\npublic static String extractStringFromBraces(String input) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 202, "code_type": "method", "original_language": "c&cpp", "question_type": "Data processing and transformation", "summary": "Based on the given year and month, returns the number of days in that month", "language_version_list": {"python": {"code_signature": "def get_days_in_month(year: int, month: int) -> int:\n    \"\"\"\n    Returns the number of days in a given month of a specific year.\n\n    This function accounts for leap years when calculating the number of days in February.\n\n    Args:\n        year (int): The year for which to get the number of days in the month. This should be\n                     a valid integer representing a year (e.g., 2024).\n        month (int): The month for which to get the number of days. It should be an integer\n                      between 1 and 12, where 1 corresponds to January and 12 to December.\n\n    Returns:\n        int: The number of days in the specified month of the specified year.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_leap_year_february(self):\n        \"\"\"Test for leap year February.\"\"\"\n        self.assertEqual(get_days_in_month(2024, 2), 29)  # 2024 is a leap year\n\n    def test_non_leap_year_february(self):\n        \"\"\"Test for non-leap year February.\"\"\"\n        self.assertEqual(get_days_in_month(2023, 2), 28)  # 2023 is not a leap year\n\n    def test_month_with_31_days(self):\n        \"\"\"Test for months with 31 days.\"\"\"\n        self.assertEqual(get_days_in_month(2023, 1), 31)  # January has 31 days\n        self.assertEqual(get_days_in_month(2023, 7), 31)  # July has 31 days\n\n    def test_month_with_30_days(self):\n        \"\"\"Test for months with 30 days.\"\"\"\n        self.assertEqual(get_days_in_month(2023, 4), 30)  # April has 30 days\n        self.assertEqual(get_days_in_month(2023, 11), 30) # November has 30 days\n\n    def test_invalid_month(self):\n        \"\"\"Test for invalid months.\"\"\"\n        with self.assertRaises(InvalidMonthError):\n            get_days_in_month(2023, 0)  # Month less than 1\n        with self.assertRaises(InvalidMonthError):\n            get_days_in_month(2023, 13)  # Month greater than 12\n", "prompt": "please write a python function , the function signature as below def get_days_in_month(year: int, month: int) -> int:\n    \"\"\"\n    Returns the number of days in a given month of a specific year.\n\n    This function accounts for leap years when calculating the number of days in February.\n\n    Args:\n        year (int): The year for which to get the number of days in the month. This should be\n                     a valid integer representing a year (e.g., 2024).\n        month (int): The month for which to get the number of days. It should be an integer\n                      between 1 and 12, where 1 corresponds to January and 12 to December.\n\n    Returns:\n        int: The number of days in the specified month of the specified year.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Returns the number of days in a given month of a specific year.\n *\n * This function accounts for leap years when calculating the number of days in February.\n *\n * @param {number} year - The year for which to get the number of days in the month.\n * @param {number} month - The month for which to get the number of days (1-12).\n * @return {number} The number of days in the specified month of the specified year.\n */\nfunction getDaysInMonth(year, month) {\n}", "test_code": "describe('getDaysInMonth', () => {\n    test('Leap year February', () => {\n        expect(getDaysInMonth(2024, 2)).toBe(29); // 2024 is a leap year\n    });\n\n    test('Non-leap year February', () => {\n        expect(getDaysInMonth(2023, 2)).toBe(28); // 2023 is not a leap year\n    });\n\n    test('Month with 31 days', () => {\n        expect(getDaysInMonth(2023, 1)).toBe(31); // January has 31 days\n        expect(getDaysInMonth(2023, 7)).toBe(31); // July has 31 days\n    });\n\n    test('Month with 30 days', () => {\n        expect(getDaysInMonth(2023, 4)).toBe(30); // April has 30 days\n        expect(getDaysInMonth(2023, 11)).toBe(30); // November has 30 days\n    });\n\n    test('Invalid month', () => {\n        expect(() => getDaysInMonth(2023, 0)).toThrowError('Month must be between 1 and 12.'); // Month less than 1\n        expect(() => getDaysInMonth(2023, 13)).toThrowError('Month must be between 1 and 12.'); // Month greater than 12\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Returns the number of days in a given month of a specific year.\n *\n * This function accounts for leap years when calculating the number of days in February.\n *\n * @param {number} year - The year for which to get the number of days in the month.\n * @param {number} month - The month for which to get the number of days (1-12).\n * @return {number} The number of days in the specified month of the specified year.\n */\nfunction getDaysInMonth(year, month) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Returns the number of days in a given month of a specific year.\n *\n * This function accounts for leap years when calculating the number of days in February.\n *\n * @param year The year for which to get the number of days in the month. This should be\n *             a valid number representing a year (e.g., 2024).\n * @param month The month for which to get the number of days. It should be a number\n *              between 1 and 12, where 1 corresponds to January and 12 to December.\n * @return The number of days in the specified month of the specified year.\n */\nfunction getDaysInMonth(year: number, month: number): number {}", "test_code": "describe(\"getDaysInMonth\", () => {\n    // Test case 1: Leap year February\n    test(\"Leap year February\", () => {\n        expect(getDaysInMonth(2024, 2)).toBe(29); // 2024 is a leap year\n    });\n\n    // Test case 2: Non-leap year February\n    test(\"Non-leap year February\", () => {\n        expect(getDaysInMonth(2023, 2)).toBe(28); // 2023 is not a leap year\n    });\n\n    // Test case 3: Months with 31 days\n    test(\"Month with 31 days\", () => {\n        expect(getDaysInMonth(2023, 1)).toBe(31); // January has 31 days\n        expect(getDaysInMonth(2023, 7)).toBe(31); // July has 31 days\n    });\n\n    // Test case 4: Months with 30 days\n    test(\"Month with 30 days\", () => {\n        expect(getDaysInMonth(2023, 4)).toBe(30); // April has 30 days\n        expect(getDaysInMonth(2023, 11)).toBe(30); // November has 30 days\n    });\n\n    // Test case 5: Invalid months\n    test(\"Invalid month\", () => {\n        expect(() => getDaysInMonth(2023, 0)).toThrow(Error);  // Month less than 1\n        expect(() => getDaysInMonth(2023, 13)).toThrow(Error); // Month greater than 12\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Returns the number of days in a given month of a specific year.\n *\n * This function accounts for leap years when calculating the number of days in February.\n *\n * @param year The year for which to get the number of days in the month. This should be\n *             a valid number representing a year (e.g., 2024).\n * @param month The month for which to get the number of days. It should be a number\n *              between 1 and 12, where 1 corresponds to January and 12 to December.\n * @return The number of days in the specified month of the specified year.\n */\nfunction getDaysInMonth(year: number, month: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <stdexcept>\n/**\n * @brief Returns the number of days in a given month of a specific year.\n *\n * This function accounts for leap years when calculating the number of days in February.\n *\n * @param year The year for which to get the number of days in the month. This should be\n *             a valid integer representing a year (e.g., 2024).\n * @param month The month for which to get the number of days. It should be an integer\n *              between 1 and 12, where 1 corresponds to January and 12 to December.\n * @return The number of days in the specified month of the specified year.\n *\n */\n int getDaysInMonth(int year, int month){\n }", "test_code": "TEST_CASE(\"Leap year February\", \"[getDaysInMonth]\") {\n    REQUIRE(getDaysInMonth(2024, 2) == 29); // 2024 \u662f\u95f0\u5e74\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 2: \u975e\u95f0\u5e74\u7684\u4e8c\u6708\u4efd\nTEST_CASE(\"Non-leap year February\", \"[getDaysInMonth]\") {\n    REQUIRE(getDaysInMonth(2023, 2) == 28); // 2023 \u4e0d\u662f\u95f0\u5e74\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 3: \u5927\u6708\u4efd\uff0831\u5929\uff09\u7684\u60c5\u51b5\nTEST_CASE(\"Month with 31 days\", \"[getDaysInMonth]\") {\n    REQUIRE(getDaysInMonth(2023, 1) == 31); // \u4e00\u6708\u4efd\u6709 31 \u5929\n    REQUIRE(getDaysInMonth(2023, 7) == 31); // \u4e03\u6708\u4efd\u6709 31 \u5929\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 4: \u5c0f\u6708\u4efd\uff0830\u5929\uff09\u7684\u60c5\u51b5\nTEST_CASE(\"Month with 30 days\", \"[getDaysInMonth]\") {\n    REQUIRE(getDaysInMonth(2023, 4) == 30); // \u56db\u6708\u4efd\u6709 30 \u5929\n    REQUIRE(getDaysInMonth(2023, 11) == 30); // \u5341\u4e00\u6708\u4efd\u6709 30 \u5929\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 5: \u65e0\u6548\u7684\u6708\u4efd\nTEST_CASE(\"Invalid month\", \"[getDaysInMonth]\") {\n    REQUIRE_THROWS_AS(getDaysInMonth(2023, 0), std::invalid_argument);  // \u6708\u4efd\u5c0f\u4e8e 1\n    REQUIRE_THROWS_AS(getDaysInMonth(2023, 13), std::invalid_argument); // \u6708\u4efd\u5927\u4e8e 12\n}", "prompt": "please write a cpp function , the function signature as below #include <stdexcept>\n/**\n * @brief Returns the number of days in a given month of a specific year.\n *\n * This function accounts for leap years when calculating the number of days in February.\n *\n * @param year The year for which to get the number of days in the month. This should be\n *             a valid integer representing a year (e.g., 2024).\n * @param month The month for which to get the number of days. It should be an integer\n *              between 1 and 12, where 1 corresponds to January and 12 to December.\n * @return The number of days in the specified month of the specified year.\n *\n */\n int getDaysInMonth(int year, int month){\n }", "addition_info": ""}, "java": {"code_signature": "/**\n * @brief Returns the number of days in a given month of a specific year.\n *\n * This function accounts for leap years when calculating the number of days in February.\n *\n * @param year The year for which to get the number of days in the month. This should be\n *             a valid integer representing a year (e.g., 2024).\n * @param month The month for which to get the number of days. It should be an integer\n *              between 1 and 12, where 1 corresponds to January and 12 to December.\n * @return The number of days in the specified month of the specified year.\n *\n * @throws IllegalArgumentException if the month is not between 1 and 12.\n */\npublic static int getDaysInMonth(int year, int month) {\n    // Method implementation goes here\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.junit.Assert.assertThrows;\n\npublic class Tester {\n\n    @Test\n    public void testLeapYearFebruary() {\n        assertEquals(29, Answer.getDaysInMonth(2024, 2)); // 2024 is a leap year\n    }\n\n    @Test\n    public void testNonLeapYearFebruary() {\n        assertEquals(28, Answer.getDaysInMonth(2023, 2)); // 2023 is not a leap year\n    }\n\n    @Test\n    public void testMonthWith31Days() {\n        assertEquals(31, Answer.getDaysInMonth(2023, 1)); // January has 31 days\n        assertEquals(31, Answer.getDaysInMonth(2023, 7)); // July has 31 days\n    }\n\n    @Test\n    public void testMonthWith30Days() {\n        assertEquals(30, Answer.getDaysInMonth(2023, 4)); // April has 30 days\n        assertEquals(30, Answer.getDaysInMonth(2023, 11)); // November has 30 days\n    }\n\n    @Test\n    public void testInvalidMonth() {\n        assertThrows(IllegalArgumentException.class, () -> {\n            Answer.getDaysInMonth(2023, 0); // Month less than 1\n        });\n        assertThrows(IllegalArgumentException.class, () -> {\n            Answer.getDaysInMonth(2023, 13); // Month greater than 12\n        });\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * @brief Returns the number of days in a given month of a specific year.\n *\n * This function accounts for leap years when calculating the number of days in February.\n *\n * @param year The year for which to get the number of days in the month. This should be\n *             a valid integer representing a year (e.g., 2024).\n * @param month The month for which to get the number of days. It should be an integer\n *              between 1 and 12, where 1 corresponds to January and 12 to December.\n * @return The number of days in the specified month of the specified year.\n *\n * @throws IllegalArgumentException if the month is not between 1 and 12.\n */\npublic static int getDaysInMonth(int year, int month) {\n    // Method implementation goes here\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 203, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Reverse the order of elements in the vectorvwithin the specified range[a, b].", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef reverse_range(v: List[int], a: int, b: int) -> None:\n    \"\"\"\n    Reverse the order of elements in the list v within the specified range [a, b].\n\n    Args:\n        v (List[int]): Reference to the list of integers to be modified.\n        a (int): The starting index of the range to be reversed.\n        b (int): The ending index of the range to be reversed.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_reverse_entire_vector(self):\n        v = [1, 2, 3, 4, 5]\n        reverse_range(v, 0, 4)\n        expected = [5, 4, 3, 2, 1]\n        self.assertEqual(v, expected)\n\n    def test_reverse_subrange_in_the_middle(self):\n        v = [1, 2, 3, 4, 5, 6, 7, 8]\n        reverse_range(v, 2, 5)\n        expected = [1, 2, 6, 5, 4, 3, 7, 8]\n        self.assertEqual(v, expected)\n\n    def test_reverse_single_element_range(self):\n        v = [1, 2, 3, 4, 5]\n        reverse_range(v, 2, 2)\n        expected = [1, 2, 3, 4, 5]\n        self.assertEqual(v, expected)\n\n    def test_reverse_range_with_invalid_indices(self):\n        v = [1, 2, 3, 4, 5]\n        reverse_range(v, -1, 3)  # Invalid start index\n        expected = [1, 2, 3, 4, 5]  # No change\n        self.assertEqual(v, expected)\n\n    def test_reverse_range_at_end_of_vector(self):\n        v = [1, 2, 3, 4, 5, 6]\n        reverse_range(v, 3, 5)\n        expected = [1, 2, 3, 6, 5, 4]\n        self.assertEqual(v, expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef reverse_range(v: List[int], a: int, b: int) -> None:\n    \"\"\"\n    Reverse the order of elements in the list v within the specified range [a, b].\n\n    Args:\n        v (List[int]): Reference to the list of integers to be modified.\n        a (int): The starting index of the range to be reversed.\n        b (int): The ending index of the range to be reversed.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Reverse the order of elements in the array within the specified range [a, b].\n *\n * @param {number[]} arr - The array of integers to be modified.\n * @param {number} a - The starting index of the range to be reversed.\n * @param {number} b - The ending index of the range to be reversed.\n */\nfunction reverseRange(arr, a, b) {}", "test_code": "describe('reverseRange function', () => {\n    test('Reverse entire array', () => {\n        const v = [1, 2, 3, 4, 5];\n        reverseRange(v, 0, 4);\n        const expected = [5, 4, 3, 2, 1];\n        expect(v).toEqual(expected);\n    });\n\n    test('Reverse subrange in the middle', () => {\n        const v = [1, 2, 3, 4, 5, 6, 7, 8];\n        reverseRange(v, 2, 5);\n        const expected = [1, 2, 6, 5, 4, 3, 7, 8];\n        expect(v).toEqual(expected);\n    });\n\n    test('Reverse a single element range', () => {\n        const v = [1, 2, 3, 4, 5];\n        reverseRange(v, 2, 2);\n        const expected = [1, 2, 3, 4, 5];\n        expect(v).toEqual(expected);\n    });\n\n    test('Reverse range with invalid indices', () => {\n        const v = [1, 2, 3, 4, 5];\n        reverseRange(v, -1, 3);  // Invalid start index\n        const expected = [1, 2, 3, 4, 5]; // No change\n        expect(v).toEqual(expected);\n    });\n\n    test('Reverse range at the end of the array', () => {\n        const v = [1, 2, 3, 4, 5, 6];\n        reverseRange(v, 3, 5);\n        const expected = [1, 2, 3, 6, 5, 4];\n        expect(v).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Reverse the order of elements in the array within the specified range [a, b].\n *\n * @param {number[]} arr - The array of integers to be modified.\n * @param {number} a - The starting index of the range to be reversed.\n * @param {number} b - The ending index of the range to be reversed.\n */\nfunction reverseRange(arr, a, b) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Reverse the order of elements in the array v within the specified range [a, b].\n *\n * @param v Array of integers to be modified.\n * @param a The starting index of the range to be reversed.\n * @param b The ending index of the range to be reversed.\n */\nfunction reverseRange(v: number[], a: number, b: number): void {}", "test_code": "describe(\"reverseRange function\", () => {\n    test(\"Reverse entire array\", () => {\n        const v = [1, 2, 3, 4, 5];\n        reverseRange(v, 0, 4);\n        const expected = [5, 4, 3, 2, 1];\n        expect(v).toEqual(expected);\n    });\n\n    test(\"Reverse subrange in the middle\", () => {\n        const v = [1, 2, 3, 4, 5, 6, 7, 8];\n        reverseRange(v, 2, 5);\n        const expected = [1, 2, 6, 5, 4, 3, 7, 8];\n        expect(v).toEqual(expected);\n    });\n\n    test(\"Reverse a single element range\", () => {\n        const v = [1, 2, 3, 4, 5];\n        reverseRange(v, 2, 2);\n        const expected = [1, 2, 3, 4, 5];\n        expect(v).toEqual(expected);\n    });\n\n    test(\"Reverse range with invalid indices\", () => {\n        const v = [1, 2, 3, 4, 5];\n        reverseRange(v, -1, 3);  // Invalid start index\n        const expected = [1, 2, 3, 4, 5]; // No change\n        expect(v).toEqual(expected);\n    });\n\n    test(\"Reverse range at the end of the array\", () => {\n        const v = [1, 2, 3, 4, 5, 6];\n        reverseRange(v, 3, 5);\n        const expected = [1, 2, 3, 6, 5, 4];\n        expect(v).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Reverse the order of elements in the array v within the specified range [a, b].\n *\n * @param v Array of integers to be modified.\n * @param a The starting index of the range to be reversed.\n * @param b The ending index of the range to be reversed.\n */\nfunction reverseRange(v: number[], a: number, b: number): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Reverse the order of elements in the vectorvwithin the specified range[a, b].\n *\n * @param v Reference to the vector of integers to be modified.\n * @param a The starting index of the range to be reversed.\n * @param b The ending index of the range to be reversed.\n */\nvoid reverseRange(std::vector<int>& v, int a, int b) {}", "test_code": "TEST_CASE(\"Test reverseRange function\") {\n    SECTION(\"Reverse entire vector\") {\n        std::vector<int> v = {1, 2, 3, 4, 5};\n        reverseRange(v, 0, 4);\n        std::vector<int> expected = {5, 4, 3, 2, 1};\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse subrange in the middle\") {\n        std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8};\n        reverseRange(v, 2, 5);\n        std::vector<int> expected = {1, 2, 6, 5, 4, 3, 7, 8};\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse a single element range\") {\n        std::vector<int> v = {1, 2, 3, 4, 5};\n        reverseRange(v, 2, 2);\n        std::vector<int> expected = {1, 2, 3, 4, 5};\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse range with invalid indices\") {\n        std::vector<int> v = {1, 2, 3, 4, 5};\n        reverseRange(v, -1, 3);  // Invalid start index\n        std::vector<int> expected = {1, 2, 3, 4, 5}; // No change\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse range at the end of the vector\") {\n        std::vector<int> v = {1, 2, 3, 4, 5, 6};\n        reverseRange(v, 3, 5);\n        std::vector<int> expected = {1, 2, 3, 6, 5, 4};\n        REQUIRE(v == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Reverse the order of elements in the vectorvwithin the specified range[a, b].\n *\n * @param v Reference to the vector of integers to be modified.\n * @param a The starting index of the range to be reversed.\n * @param b The ending index of the range to be reversed.\n */\nvoid reverseRange(std::vector<int>& v, int a, int b) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Reverse the order of elements in the list within the specified range [a, b].\n *\n * @param v Reference to the list of integers to be modified.\n * @param a The starting index of the range to be reversed.\n * @param b The ending index of the range to be reversed.\n */\npublic static void reverseRange(List<Integer> v, int a, int b) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testSplitStringRegularSentence() {\n        String input = \"Hello world from Catch2\";\n        List<String> expected = Arrays.asList(\"Hello\", \"world\", \"from\", \"Catch2\");\n        assertEquals(expected, splitString(input));\n    }\n\n    @Test\n    public void testSplitStringMultipleSpaces() {\n        String input = \"Multiple   spaces between words\";\n        List<String> expected = Arrays.asList(\"Multiple\", \"spaces\", \"between\", \"words\");\n        assertEquals(expected, splitString(input));\n    }\n\n    @Test\n    public void testSplitStringSingleWord() {\n        String input = \"Single\";\n        List<String> expected = Arrays.asList(\"Single\");\n        assertEquals(expected, splitString(input));\n    }\n\n    @Test\n    public void testSplitStringEmpty() {\n        String input = \"\";\n        List<String> expected = Arrays.asList();\n        assertEquals(expected, splitString(input));\n    }\n\n    @Test\n    public void testSplitStringLeadingTrailingSpaces() {\n        String input = \"   Leading and trailing spaces   \";\n        List<String> expected = Arrays.asList(\"Leading\", \"and\", \"trailing\", \"spaces\");\n        assertEquals(expected, splitString(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Reverse the order of elements in the list within the specified range [a, b].\n *\n * @param v Reference to the list of integers to be modified.\n * @param a The starting index of the range to be reversed.\n * @param b The ending index of the range to be reversed.\n */\npublic static void reverseRange(List<Integer> v, int a, int b) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 204, "code_type": "method", "original_language": "c&cpp", "question_type": "Data processing and transformation", "summary": "Split a string into multiple substrings based on spaces and return a vector containing these substrings.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef split_string(s: str) -> List[str]:\n    \"\"\"\n    Split a string into multiple substrings based on spaces and return a list containing these substrings.\n    Args:\n        s (str): The input string to be split into words.\n\n    Returns:\n        List[str]: A list of strings, each representing a word from the input string. Returns an empty list if the input string is empty or contains only spaces.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_split_string_regular_sentence(self):\n        \"\"\"Split a regular sentence.\"\"\"\n        input_str = \"Hello world from Catch2\"\n        expected = [\"Hello\", \"world\", \"from\", \"Catch2\"]\n        self.assertEqual(split_string(input_str), expected)\n\n    def test_handle_multiple_spaces(self):\n        \"\"\"Handle multiple spaces between words.\"\"\"\n        input_str = \"Multiple   spaces between words\"\n        expected = [\"Multiple\", \"spaces\", \"between\", \"words\"]\n        self.assertEqual(split_string(input_str), expected)\n\n    def test_single_word_input(self):\n        \"\"\"Single word input.\"\"\"\n        input_str = \"Single\"\n        expected = [\"Single\"]\n        self.assertEqual(split_string(input_str), expected)\n\n    def test_empty_string_input(self):\n        \"\"\"Empty string input.\"\"\"\n        input_str = \"\"\n        expected = []\n        self.assertEqual(split_string(input_str), expected)\n\n    def test_leading_and_trailing_spaces(self):\n        \"\"\"String with leading and trailing spaces.\"\"\"\n        input_str = \"   Leading and trailing spaces   \"\n        expected = [\"Leading\", \"and\", \"trailing\", \"spaces\"]\n        self.assertEqual(split_string(input_str), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef split_string(s: str) -> List[str]:\n    \"\"\"\n    Split a string into multiple substrings based on spaces and return a list containing these substrings.\n    Args:\n        s (str): The input string to be split into words.\n\n    Returns:\n        List[str]: A list of strings, each representing a word from the input string. Returns an empty list if the input string is empty or contains only spaces.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Split a string into multiple substrings based on spaces and return an array containing these substrings.\n *\n * @param {string} str The input string to be split into words.\n * @return {string[]} An array of strings, each representing a word from the input string. Returns an empty array if the input string is empty or contains only spaces.\n */\nfunction splitString(str) {\n}", "test_code": "describe('splitString function', () => {\n    test('Split a regular sentence', () => {\n        const input = \"Hello world from Catch2\";\n        const expected = [\"Hello\", \"world\", \"from\", \"Catch2\"];\n        expect(splitString(input)).toEqual(expected);\n    });\n\n    test('Handle multiple spaces', () => {\n        const input = \"Multiple   spaces between words\";\n        const expected = [\"Multiple\", \"spaces\", \"between\", \"words\"];\n        expect(splitString(input)).toEqual(expected);\n    });\n\n    test('Single word input', () => {\n        const input = \"Single\";\n        const expected = [\"Single\"];\n        expect(splitString(input)).toEqual(expected);\n    });\n\n\n    test('String with leading and trailing spaces', () => {\n        const input = \"   Leading and trailing spaces   \";\n        const expected = [\"Leading\", \"and\", \"trailing\", \"spaces\"];\n        expect(splitString(input)).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Split a string into multiple substrings based on spaces and return an array containing these substrings.\n *\n * @param {string} str The input string to be split into words.\n * @return {string[]} An array of strings, each representing a word from the input string. Returns an empty array if the input string is empty or contains only spaces.\n */\nfunction splitString(str) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Split a string into multiple substrings based on spaces and return an array containing these substrings.\n *\n * @param str The input string to be split into words.\n * @returns An array of strings, each representing a word from the input string. Returns an empty array if the input string is empty or contains only spaces.\n */\nfunction splitString(str: string): string[] {}", "test_code": "describe('splitString function', () => {\n    test('Split a regular sentence', () => {\n        const input = \"Hello world from Catch2\";\n        const expected = [\"Hello\", \"world\", \"from\", \"Catch2\"];\n        expect(splitString(input)).toEqual(expected);\n    });\n\n    test('Handle multiple spaces', () => {\n        const input = \"Multiple   spaces between words\";\n        const expected = [\"Multiple\", \"spaces\", \"between\", \"words\"];\n        expect(splitString(input)).toEqual(expected);\n    });\n\n    test('Single word input', () => {\n        const input = \"Single\";\n        const expected = [\"Single\"];\n        expect(splitString(input)).toEqual(expected);\n    });\n\n    test('Empty string input', () => {\n        const input = \"\";\n        const expected: string[] = [];\n        expect(splitString(input)).toEqual(expected);\n    });\n\n    test('String with leading and trailing spaces', () => {\n        const input = \"   Leading and trailing spaces   \";\n        const expected = [\"Leading\", \"and\", \"trailing\", \"spaces\"];\n        expect(splitString(input)).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Split a string into multiple substrings based on spaces and return an array containing these substrings.\n *\n * @param str The input string to be split into words.\n * @returns An array of strings, each representing a word from the input string. Returns an empty array if the input string is empty or contains only spaces.\n */\nfunction splitString(str: string): string[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Split a string into multiple substrings based on spaces and return a vector containing these substrings.\n *\n * @param str The input string to be split into words.\n * @return A vector of strings, each representing a word from the input string. Returns an empty vector if the input string is empty or contains only spaces.\n */\nstd::vector<std::string> splitString(const std::string& str) {}", "test_code": "TEST_CASE(\"splitString function\") {\n\n    SECTION(\"Split a regular sentence\") {\n        std::string input = \"Hello world from Catch2\";\n        std::vector<std::string> expected = {\"Hello\", \"world\", \"from\", \"Catch2\"};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"Handle multiple spaces\") {\n        std::string input = \"Multiple   spaces between words\";\n        std::vector<std::string> expected = {\"Multiple\", \"spaces\", \"between\", \"words\"};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"Single word input\") {\n        std::string input = \"Single\";\n        std::vector<std::string> expected = {\"Single\"};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"Empty string input\") {\n        std::string input = \"\";\n        std::vector<std::string> expected = {};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"String with leading and trailing spaces\") {\n        std::string input = \"   Leading and trailing spaces   \";\n        std::vector<std::string> expected = {\"Leading\", \"and\", \"trailing\", \"spaces\"};\n        REQUIRE(splitString(input) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Split a string into multiple substrings based on spaces and return a vector containing these substrings.\n *\n * @param str The input string to be split into words.\n * @return A vector of strings, each representing a word from the input string. Returns an empty vector if the input string is empty or contains only spaces.\n */\nstd::vector<std::string> splitString(const std::string& str) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Split a string into multiple substrings based on spaces and return a list containing these substrings.\n *\n * @param str The input string to be split into words.\n * @return A list of strings, each representing a word from the input string. Returns an empty list if the input string is empty or contains only spaces.\n */\npublic static List<String> splitString(String str) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testSplitStringRegularSentence() {\n        String input = \"Hello world from Catch2\";\n        List<String> expected = Arrays.asList(\"Hello\", \"world\", \"from\", \"Catch2\");\n        assertEquals(expected, splitString(input));\n    }\n\n    @Test\n    public void testSplitStringMultipleSpaces() {\n        String input = \"Multiple   spaces between words\";\n        List<String> expected = Arrays.asList(\"Multiple\", \"spaces\", \"between\", \"words\");\n        assertEquals(expected, splitString(input));\n    }\n\n    @Test\n    public void testSplitStringSingleWord() {\n        String input = \"Single\";\n        List<String> expected = Arrays.asList(\"Single\");\n        assertEquals(expected, splitString(input));\n    }\n\n    @Test\n    public void testSplitStringEmpty() {\n        String input = \"\";\n        List<String> expected = Arrays.asList();\n        assertEquals(expected, splitString(input));\n    }\n\n    @Test\n    public void testSplitStringLeadingTrailingSpaces() {\n        String input = \"   Leading and trailing spaces   \";\n        List<String> expected = Arrays.asList(\"Leading\", \"and\", \"trailing\", \"spaces\");\n        assertEquals(expected, splitString(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Split a string into multiple substrings based on spaces and return a list containing these substrings.\n *\n * @param str The input string to be split into words.\n * @return A list of strings, each representing a word from the input string. Returns an empty list if the input string is empty or contains only spaces.\n */\npublic static List<String> splitString(String str) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 205, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Retrieve the current date and return it as a string in the \"YYYY-MM-DD\" format.", "language_version_list": {"python": {"code_signature": "def get_current_date() -> str:\n    \"\"\"\n    Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n    Returns:\n        str: A string representing the current date in the format \"YYYY-MM-DD\".\n    \"\"\"", "test_code": "import datetime\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_get_current_date_format(self):\n        \"\"\"Correct format YYYY-MM-DD\"\"\"\n        current_date = get_current_date()\n        self.assertEqual(len(current_date), 10)\n        self.assertEqual(current_date[4], '-')\n        self.assertEqual(current_date[7], '-')\n\n    def test_get_current_date_year(self):\n        \"\"\"Returns correct year\"\"\"\n        now = datetime.datetime.now()\n        current_year = now.year\n        current_date = get_current_date()\n        year_part = current_date[:4]  # Get the year part\n        self.assertEqual(int(year_part), current_year)\n\n    def test_get_current_date_month(self):\n        \"\"\"Returns correct month\"\"\"\n        now = datetime.datetime.now()\n        current_month = now.month\n        current_date = get_current_date()\n        month_part = current_date[5:7]  # Get the month part\n        self.assertEqual(int(month_part), current_month)\n\n    def test_get_current_date_day(self):\n        \"\"\"Returns correct day\"\"\"\n        now = datetime.datetime.now()\n        current_day = now.day\n        current_date = get_current_date()\n        day_part = current_date[8:10]  # Get the day part\n        self.assertEqual(int(day_part), current_day)\n\n    def test_get_current_date_consistency(self):\n        \"\"\"Consistency of output within the same second\"\"\"\n        first_call = get_current_date()\n        second_call = get_current_date()\n        self.assertEqual(first_call, second_call)\n", "prompt": "please write a python function , the function signature as below def get_current_date() -> str:\n    \"\"\"\n    Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n    Returns:\n        str: A string representing the current date in the format \"YYYY-MM-DD\".\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n *\n * @return {string} A string representing the current date in the format \"YYYY-MM-DD\".\n */\nfunction getCurrentDate() {}", "test_code": "describe(\"getCurrentDate function\", () => {\n    \n    test(\"Correct format YYYY-MM-DD\", () => {\n        const currentDate = getCurrentDate();\n        expect(currentDate.length).toBe(10);\n        expect(currentDate[4]).toBe('-');\n        expect(currentDate[7]).toBe('-');\n    });\n\n    test(\"Returns correct year\", () => {\n        const now = new Date();\n        const currentYear = now.getFullYear();\n\n        const currentDate = getCurrentDate();\n        const yearPart = currentDate.substring(0, 4);\n\n        expect(Number(yearPart)).toBe(currentYear);\n    });\n\n    test(\"Returns correct month\", () => {\n        const now = new Date();\n        const currentMonth = now.getMonth() + 1; // Months are 0-based in JavaScript\n\n        const currentDate = getCurrentDate();\n        const monthPart = currentDate.substring(5, 7);\n\n        expect(Number(monthPart)).toBe(currentMonth);\n    });\n\n    test(\"Returns correct day\", () => {\n        const now = new Date();\n        const currentDay = now.getDate();\n\n        const currentDate = getCurrentDate();\n        const dayPart = currentDate.substring(8, 10);\n\n        expect(Number(dayPart)).toBe(currentDay);\n    });\n\n    test(\"Consistency of output within the same second\", () => {\n        const firstCall = getCurrentDate();\n        const secondCall = getCurrentDate();\n        expect(firstCall).toBe(secondCall);\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n *\n * @return {string} A string representing the current date in the format \"YYYY-MM-DD\".\n */\nfunction getCurrentDate() {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n *\n * @return A string representing the current date in the format \"YYYY-MM-DD\".\n */\nfunction getCurrentDate(): string {}", "test_code": "describe(\"getCurrentDate function\", () => {\n    test(\"Correct format YYYY-MM-DD\", () => {\n        const currentDate = getCurrentDate();\n        expect(currentDate.length).toBe(10);\n        expect(currentDate[4]).toBe('-');\n        expect(currentDate[7]).toBe('-');\n    });\n\n    test(\"Returns correct year\", () => {\n        const now = new Date();\n        const currentYear = now.getFullYear();\n\n        const currentDate = getCurrentDate();\n        const yearPart = currentDate.substr(0, 4);\n\n        expect(parseInt(yearPart, 10)).toBe(currentYear);\n    });\n\n    test(\"Returns correct month\", () => {\n        const now = new Date();\n        const currentMonth = now.getMonth() + 1; // Months are 0-indexed\n\n        const currentDate = getCurrentDate();\n        const monthPart = currentDate.substr(5, 2);\n\n        expect(parseInt(monthPart, 10)).toBe(currentMonth);\n    });\n\n    test(\"Returns correct day\", () => {\n        const now = new Date();\n        const currentDay = now.getDate();\n\n        const currentDate = getCurrentDate();\n        const dayPart = currentDate.substr(8, 2);\n\n        expect(parseInt(dayPart, 10)).toBe(currentDay);\n    });\n\n    test(\"Consistency of output within the same second\", () => {\n        const firstCall = getCurrentDate();\n        const secondCall = getCurrentDate();\n        expect(firstCall).toBe(secondCall);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n *\n * @return A string representing the current date in the format \"YYYY-MM-DD\".\n */\nfunction getCurrentDate(): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n *\n * @return A string representing the current date in the format \"YYYY-MM-DD\".\n */\nstd::string getCurrentDate() {}", "test_code": "TEST_CASE(\"getCurrentDate function\") {\n\n    SECTION(\"Correct format YYYY-MM-DD\") {\n        std::string currentDate = getCurrentDate();\n        REQUIRE(currentDate.length() == 10);\n        REQUIRE(currentDate[4] == '-');\n        REQUIRE(currentDate[7] == '-');\n    }\n\n    SECTION(\"Returns correct year\") {\n        std::time_t t = std::time(nullptr);\n        std::tm* now = std::localtime(&t);\n        int currentYear = now->tm_year + 1900;\n\n        std::string currentDate = getCurrentDate();\n        std::string yearPart = currentDate.substr(0, 4);\n\n        REQUIRE(std::stoi(yearPart) == currentYear);\n    }\n\n    SECTION(\"Returns correct month\") {\n        std::time_t t = std::time(nullptr);\n        std::tm* now = std::localtime(&t);\n        int currentMonth = now->tm_mon + 1;\n\n        std::string currentDate = getCurrentDate();\n        std::string monthPart = currentDate.substr(5, 2);\n\n        REQUIRE(std::stoi(monthPart) == currentMonth);\n    }\n\n    SECTION(\"Returns correct day\") {\n        std::time_t t = std::time(nullptr);\n        std::tm* now = std::localtime(&t);\n        int currentDay = now->tm_mday;\n\n        std::string currentDate = getCurrentDate();\n        std::string dayPart = currentDate.substr(8, 2);\n\n        REQUIRE(std::stoi(dayPart) == currentDay);\n    }\n\n    SECTION(\"Consistency of output within the same second\") {\n        std::string firstCall = getCurrentDate();\n        std::string secondCall = getCurrentDate();\n        REQUIRE(firstCall == secondCall);\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n *\n * @return A string representing the current date in the format \"YYYY-MM-DD\".\n */\nstd::string getCurrentDate() {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 206, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.", "language_version_list": {"python": {"code_signature": "def circle_intersection_area(x1: float, y1: float, r1: float, x2: float, y2: float, r2: float) -> float:\n    \"\"\"\n    Calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n\n    Args:\n        x1 (float): The x-coordinate of the center of the first circle.\n        y1 (float): The y-coordinate of the center of the first circle.\n        r1 (float): The radius of the first circle.\n        x2 (float): The x-coordinate of the center of the second circle.\n        y2 (float): The y-coordinate of the center of the second circle.\n        r2 (float): The radius of the second circle.\n\n    Returns:\n        float: The area of the intersection between the two circles.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_circle_intersection_area(self):\n        tolerance = 1e-5\n\n        # No overlap, circles far apart\n        self.assertAlmostEqual(circle_intersection_area(0.0, 0.0, 3.0, 10.0, 10.0, 3.0), 0.0, delta=tolerance)\n\n        # No overlap, circles just touching\n        self.assertAlmostEqual(circle_intersection_area(0.0, 0.0, 3.0, 6.0, 0.0, 3.0), 0.0, delta=tolerance)\n\n        # One circle inside the other\n        area = circle_intersection_area(0.0, 0.0, 5.0, 2.0, 0.0, 3.0)\n        self.assertAlmostEqual(area, 28.2743, delta=tolerance)  # Area of smaller circle\n\n        # Identical circles, full overlap\n        area = circle_intersection_area(0.0, 0.0, 3.0, 0.0, 0.0, 3.0)\n        self.assertAlmostEqual(area, 28.2743, delta=tolerance)  # Area of one circle\n", "prompt": "please write a python function , the function signature as below def circle_intersection_area(x1: float, y1: float, r1: float, x2: float, y2: float, r2: float) -> float:\n    \"\"\"\n    Calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n\n    Args:\n        x1 (float): The x-coordinate of the center of the first circle.\n        y1 (float): The y-coordinate of the center of the first circle.\n        r1 (float): The radius of the first circle.\n        x2 (float): The x-coordinate of the center of the second circle.\n        y2 (float): The y-coordinate of the center of the second circle.\n        r2 (float): The radius of the second circle.\n\n    Returns:\n        float: The area of the intersection between the two circles.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param {number} x1 - The x-coordinate of the center of the first circle.\n * @param {number} y1 - The y-coordinate of the center of the first circle.\n * @param {number} r1 - The radius of the first circle.\n * @param {number} x2 - The x-coordinate of the center of the second circle.\n * @param {number} y2 - The y-coordinate of the center of the second circle.\n * @param {number} r2 - The radius of the second circle.\n * @return {number} The area of the intersection between the two circles.\n */\nfunction circleIntersectionArea(x1, y1, r1, x2, y2, r2) {}", "test_code": "describe(\"Testing circleIntersectionArea function\", () => {\n    const tolerance = 1e-5;\n\n    test(\"No overlap, circles far apart\", () => {\n        expect(circleIntersectionArea(0.0, 0.0, 3.0, 10.0, 10.0, 3.0)).toBeCloseTo(0.0, tolerance);\n    });\n\n    test(\"No overlap, circles just touching\", () => {\n        expect(circleIntersectionArea(0.0, 0.0, 3.0, 6.0, 0.0, 3.0)).toBeCloseTo(0.0, tolerance);\n    });\n\n    test(\"One circle inside the other\", () => {\n        const area = circleIntersectionArea(0.0, 0.0, 5.0, 2.0, 0.0, 3.0);\n        expect(area).toBeCloseTo(28.2743, tolerance); // Area of smaller circle\n    });\n\n    test(\"Identical circles, full overlap\", () => {\n        const area = circleIntersectionArea(0.0, 0.0, 3.0, 0.0, 0.0, 3.0);\n        expect(area).toBeCloseTo(28.2743, tolerance); // Area of one circle\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param {number} x1 - The x-coordinate of the center of the first circle.\n * @param {number} y1 - The y-coordinate of the center of the first circle.\n * @param {number} r1 - The radius of the first circle.\n * @param {number} x2 - The x-coordinate of the center of the second circle.\n * @param {number} y2 - The y-coordinate of the center of the second circle.\n * @param {number} r2 - The radius of the second circle.\n * @return {number} The area of the intersection between the two circles.\n */\nfunction circleIntersectionArea(x1, y1, r1, x2, y2, r2) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param x1 The x-coordinate of the center of the first circle.\n * @param y1 The y-coordinate of the center of the first circle.\n * @param r1 The radius of the first circle.\n * @param x2 The x-coordinate of the center of the second circle.\n * @param y2 The y-coordinate of the center of the second circle.\n * @param r2 The radius of the second circle.\n * @returns The area of the intersection between the two circles.\n */\nfunction circleIntersectionArea(x1: number, y1: number, r1: number, x2: number, y2: number, r2: number): number {}", "test_code": "describe('Testing circleIntersectionArea function', () => {\n    const tolerance = 1e-5;\n\n    test('No overlap, circles far apart', () => {\n        expect(circleIntersectionArea(0.0, 0.0, 3.0, 10.0, 10.0, 3.0)).toBeCloseTo(0.0, 5);\n    });\n\n    test('No overlap, circles just touching', () => {\n        expect(circleIntersectionArea(0.0, 0.0, 3.0, 6.0, 0.0, 3.0)).toBeCloseTo(0.0, 5);\n    });\n\n    test('One circle inside the other', () => {\n        const area = circleIntersectionArea(0.0, 0.0, 5.0, 2.0, 0.0, 3.0);\n        expect(area).toBeCloseTo(28.2743, 5); // Area of smaller circle\n    });\n\n    test('Identical circles, full overlap', () => {\n        const area = circleIntersectionArea(0.0, 0.0, 3.0, 0.0, 0.0, 3.0);\n        expect(area).toBeCloseTo(28.2743, 5); // Area of one circle\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param x1 The x-coordinate of the center of the first circle.\n * @param y1 The y-coordinate of the center of the first circle.\n * @param r1 The radius of the first circle.\n * @param x2 The x-coordinate of the center of the second circle.\n * @param y2 The y-coordinate of the center of the second circle.\n * @param r2 The radius of the second circle.\n * @returns The area of the intersection between the two circles.\n */\nfunction circleIntersectionArea(x1: number, y1: number, r1: number, x2: number, y2: number, r2: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param x1 The x-coordinate of the center of the first circle.\n * @param y1 The y-coordinate of the center of the first circle.\n * @param r1 The radius of the first circle.\n * @param x2 The x-coordinate of the center of the second circle.\n * @param y2 The y-coordinate of the center of the second circle.\n * @param r2 The radius of the second circle.\n * @return The area of the intersection between the two circles.\n */\ndouble circleIntersectionArea(double x1, double y1, double r1, double x2, double y2, double r2) {}", "test_code": "TEST_CASE(\"Testing circleIntersectionArea function\") {\n    const double tolerance = 1e-5;\n\n    SECTION(\"No overlap, circles far apart\") {\n        REQUIRE(circleIntersectionArea(0.0, 0.0, 3.0, 10.0, 10.0, 3.0) == Approx(0.0).epsilon(tolerance));\n    }\n\n    SECTION(\"No overlap, circles just touching\") {\n        REQUIRE(circleIntersectionArea(0.0, 0.0, 3.0, 6.0, 0.0, 3.0) == Approx(0.0).epsilon(tolerance));\n    }\n\n    SECTION(\"One circle inside the other\") {\n        double area = circleIntersectionArea(0.0, 0.0, 5.0, 2.0, 0.0, 3.0);\n        REQUIRE(area == Approx(28.2743).epsilon(tolerance)); // Area of smaller circle\n    }\n\n    SECTION(\"Identical circles, full overlap\") {\n        double area = circleIntersectionArea(0.0, 0.0, 3.0, 0.0, 0.0, 3.0);\n        REQUIRE(area == Approx(28.2743).epsilon(tolerance)); // Area of one circle\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param x1 The x-coordinate of the center of the first circle.\n * @param y1 The y-coordinate of the center of the first circle.\n * @param r1 The radius of the first circle.\n * @param x2 The x-coordinate of the center of the second circle.\n * @param y2 The y-coordinate of the center of the second circle.\n * @param r2 The radius of the second circle.\n * @return The area of the intersection between the two circles.\n */\ndouble circleIntersectionArea(double x1, double y1, double r1, double x2, double y2, double r2) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param x1 The x-coordinate of the center of the first circle.\n * @param y1 The y-coordinate of the center of the first circle.\n * @param r1 The radius of the first circle.\n * @param x2 The x-coordinate of the center of the second circle.\n * @param y2 The y-coordinate of the center of the second circle.\n * @param r2 The radius of the second circle.\n * @return The area of the intersection between the two circles.\n */\npublic static double circleIntersectionArea(double x1, double y1, double r1, double x2, double y2, double r2) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    private static final double TOLERANCE = 1e-5;\n\n    @Test\n    public void testNoOverlapCirclesFarApart() {\n        assertEquals(0.0, Answer.circleIntersectionArea(0.0, 0.0, 3.0, 10.0, 10.0, 3.0), TOLERANCE);\n    }\n\n    @Test\n    public void testNoOverlapCirclesJustTouching() {\n        assertEquals(0.0, Answer.circleIntersectionArea(0.0, 0.0, 3.0, 6.0, 0.0, 3.0), TOLERANCE);\n    }\n\n    @Test\n    public void testOneCircleInsideTheOther() {\n        double area = Answer.circleIntersectionArea(0.0, 0.0, 5.0, 2.0, 0.0, 3.0);\n        assertEquals(28.2743, area, TOLERANCE); // Area of smaller circle\n    }\n\n    @Test\n    public void testIdenticalCirclesFullOverlap() {\n        double area = Answer.circleIntersectionArea(0.0, 0.0, 3.0, 0.0, 0.0, 3.0);\n        assertEquals(28.2743, area, TOLERANCE); // Area of one circle\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param x1 The x-coordinate of the center of the first circle.\n * @param y1 The y-coordinate of the center of the first circle.\n * @param r1 The radius of the first circle.\n * @param x2 The x-coordinate of the center of the second circle.\n * @param y2 The y-coordinate of the center of the second circle.\n * @param r2 The radius of the second circle.\n * @return The area of the intersection between the two circles.\n */\npublic static double circleIntersectionArea(double x1, double y1, double r1, double x2, double y2, double r2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 207, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef min_changes_to_symmetric(matrix: List[List]) -> int:\n    \"\"\"\n    Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n    Args:\n        matrix (List[List]): A list of lists of characters representing the matrix to be analyzed.\n\n    Returns:\n        int: The minimum number of element changes required to make the matrix symmetric.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    def test_already_symmetric_matrix(self):\n        matrix = [\n            ['a', 'b', 'c'],\n            ['b', 'e', 'f'],\n            ['c', 'f', 'i']\n        ]\n        self.assertEqual(min_changes_to_symmetric(matrix), 0)\n\n    def test_one_change_needed(self):\n        matrix = [\n            ['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['c', 'h', 'i']\n        ]\n        self.assertEqual(min_changes_to_symmetric(matrix), 2)\n\n    def test_all_different_elements(self):\n        matrix = [\n            ['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['g', 'h', 'i']\n        ]\n        self.assertEqual(min_changes_to_symmetric(matrix), 3)\n\n    def test_large_symmetric_matrix(self):\n        matrix = [\n            ['a', 'b', 'c', 'd'],\n            ['b', 'e', 'f', 'g'],\n            ['c', 'f', 'h', 'i'],\n            ['d', 'g', 'i', 'j']\n        ]\n        self.assertEqual(min_changes_to_symmetric(matrix), 0)\n\n    def test_multiple_changes_needed(self):\n        matrix = [\n            ['a', 'x', 'c', 'd'],\n            ['y', 'e', 'f', 'g'],\n            ['z', 'h', 'i', 'j'],\n            ['d', 'g', 'k', 'l']\n        ]\n        self.assertEqual(min_changes_to_symmetric(matrix), 4)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef min_changes_to_symmetric(matrix: List[List]) -> int:\n    \"\"\"\n    Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n    Args:\n        matrix (List[List]): A list of lists of characters representing the matrix to be analyzed.\n\n    Returns:\n        int: The minimum number of element changes required to make the matrix symmetric.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param {Array<Array<string>>} matrix - A 2D array of characters representing the matrix to be analyzed.\n * @return {number} - The minimum number of element changes required to make the matrix symmetric.\n */\nfunction minChangesToSymmetric(matrix) {}", "test_code": "describe(\"minChangesToSymmetric function\", () => {\n\n    test(\"Already Symmetric Matrix\", () => {\n        const matrix = [\n            ['a', 'b', 'c'],\n            ['b', 'e', 'f'],\n            ['c', 'f', 'i']\n        ];\n        expect(minChangesToSymmetric(matrix)).toBe(0);\n    });\n\n    test(\"One Change Needed\", () => {\n        const matrix = [\n            ['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['c', 'h', 'i']\n        ];\n        expect(minChangesToSymmetric(matrix)).toBe(2);\n    });\n\n    test(\"All Different Elements\", () => {\n        const matrix = [\n            ['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['g', 'h', 'i']\n        ];\n        expect(minChangesToSymmetric(matrix)).toBe(3);\n    });\n\n    test(\"Large Symmetric Matrix\", () => {\n        const matrix = [\n            ['a', 'b', 'c', 'd'],\n            ['b', 'e', 'f', 'g'],\n            ['c', 'f', 'h', 'i'],\n            ['d', 'g', 'i', 'j']\n        ];\n        expect(minChangesToSymmetric(matrix)).toBe(0);\n    });\n\n    test(\"Multiple Changes Needed\", () => {\n        const matrix = [\n            ['a', 'x', 'c', 'd'],\n            ['y', 'e', 'f', 'g'],\n            ['z', 'h', 'i', 'j'],\n            ['d', 'g', 'k', 'l']\n        ];\n        expect(minChangesToSymmetric(matrix)).toBe(4);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param {Array<Array<string>>} matrix - A 2D array of characters representing the matrix to be analyzed.\n * @return {number} - The minimum number of element changes required to make the matrix symmetric.\n */\nfunction minChangesToSymmetric(matrix) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param matrix A 2D array of strings representing the matrix to be analyzed.\n * @return The minimum number of element changes required to make the matrix symmetric.\n */\nfunction minChangesToSymmetric(matrix: string[][]): number {}", "test_code": "describe(\"Testing minChangesToSymmetric function\", () => {\n\n    test(\"Already Symmetric Matrix\", () => {\n        const matrix: string[][] = [\n            ['a', 'b', 'c'],\n            ['b', 'e', 'f'],\n            ['c', 'f', 'i']\n        ];\n        expect(minChangesToSymmetric(matrix)).toBe(0);\n    });\n\n    test(\"One Change Needed\", () => {\n        const matrix: string[][] = [\n            ['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['c', 'h', 'i']\n        ];\n        expect(minChangesToSymmetric(matrix)).toBe(2);\n    });\n\n    test(\"All Different Elements\", () => {\n        const matrix: string[][] = [\n            ['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['g', 'h', 'i']\n        ];\n        expect(minChangesToSymmetric(matrix)).toBe(3);\n    });\n\n    test(\"Large Symmetric Matrix\", () => {\n        const matrix: string[][] = [\n            ['a', 'b', 'c', 'd'],\n            ['b', 'e', 'f', 'g'],\n            ['c', 'f', 'h', 'i'],\n            ['d', 'g', 'i', 'j']\n        ];\n        expect(minChangesToSymmetric(matrix)).toBe(0);\n    });\n\n    test(\"Multiple Changes Needed\", () => {\n        const matrix: string[][] = [\n            ['a', 'x', 'c', 'd'],\n            ['y', 'e', 'f', 'g'],\n            ['z', 'h', 'i', 'j'],\n            ['d', 'g', 'k', 'l']\n        ];\n        expect(minChangesToSymmetric(matrix)).toBe(4);\n    });\n\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param matrix A 2D array of strings representing the matrix to be analyzed.\n * @return The minimum number of element changes required to make the matrix symmetric.\n */\nfunction minChangesToSymmetric(matrix: string[][]): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param matrix A reference to a 2D vector of characters representing the matrix to be analyzed.\n * @return The minimum number of element changes required to make the matrix symmetric.\n */\nint minChangesToSymmetric(vector<vector<char>>& matrix) {}", "test_code": "TEST_CASE(\"Testing minChangesToSymmetric function\") {\n\n    SECTION(\"Already Symmetric Matrix\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c'},\n            {'b', 'e', 'f'},\n            {'c', 'f', 'i'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 0);\n    }\n\n    SECTION(\"One Change Needed\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c'},\n            {'d', 'e', 'f'},\n            {'c', 'h', 'i'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 2);\n    }\n\n    SECTION(\"All Different Elements\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c'},\n            {'d', 'e', 'f'},\n            {'g', 'h', 'i'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 3);\n    }\n\n    SECTION(\"Large Symmetric Matrix\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c', 'd'},\n            {'b', 'e', 'f', 'g'},\n            {'c', 'f', 'h', 'i'},\n            {'d', 'g', 'i', 'j'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 0);\n    }\n\n    SECTION(\"Multiple Changes Needed\") {\n        vector<vector<char>> matrix = {\n            {'a', 'x', 'c', 'd'},\n            {'y', 'e', 'f', 'g'},\n            {'z', 'h', 'i', 'j'},\n            {'d', 'g', 'k', 'l'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 4);\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param matrix A reference to a 2D vector of characters representing the matrix to be analyzed.\n * @return The minimum number of element changes required to make the matrix symmetric.\n */\nint minChangesToSymmetric(vector<vector<char>>& matrix) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param matrix A 2D array of characters representing the matrix to be analyzed.\n * @return The minimum number of element changes required to make the matrix symmetric.\n */\n\npublic static int minChangesToSymmetric(char[][] matrix) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testAlreadySymmetricMatrix() {\n        char[][] matrix = {\n            {'a', 'b', 'c'},\n            {'b', 'e', 'f'},\n            {'c', 'f', 'i'}\n        };\n        assertEquals(0, Answer.minChangesToSymmetric(matrix));\n    }\n\n    @Test\n    public void testOneChangeNeeded() {\n        char[][] matrix = {\n            {'a', 'b', 'c'},\n            {'d', 'e', 'f'},\n            {'c', 'h', 'i'}\n        };\n        assertEquals(2, Answer.minChangesToSymmetric(matrix));\n    }\n\n    @Test\n    public void testAllDifferentElements() {\n        char[][] matrix = {\n            {'a', 'b', 'c'},\n            {'d', 'e', 'f'},\n            {'g', 'h', 'i'}\n        };\n        assertEquals(3, Answer.minChangesToSymmetric(matrix));\n    }\n\n    @Test\n    public void testLargeSymmetricMatrix() {\n        char[][] matrix = {\n            {'a', 'b', 'c', 'd'},\n            {'b', 'e', 'f', 'g'},\n            {'c', 'f', 'h', 'i'},\n            {'d', 'g', 'i', 'j'}\n        };\n        assertEquals(0, Answer.minChangesToSymmetric(matrix));\n    }\n\n    @Test\n    public void testMultipleChangesNeeded() {\n        char[][] matrix = {\n            {'a', 'x', 'c', 'd'},\n            {'y', 'e', 'f', 'g'},\n            {'z', 'h', 'i', 'j'},\n            {'d', 'g', 'k', 'l'}\n        };\n        assertEquals(4, Answer.minChangesToSymmetric(matrix));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param matrix A 2D array of characters representing the matrix to be analyzed.\n * @return The minimum number of element changes required to make the matrix symmetric.\n */\n\npublic static int minChangesToSymmetric(char[][] matrix) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 209, "code_type": "class", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Implement a linked list", "language_version_list": {"python": {"code_signature": "class Node:\n    def __init__(self, value):\n        self.data = value  # Data held by the node\n        self.next = None   # Pointer to the next node in the list\n\n# LinkedList class definition\nclass LinkedList:\n    # Method to add a node at the beginning of the list\n    def insert_at_head(self, value):\n        pass\n\n    # Method to add a node at the end of the list\n    def insert_at_tail(self, value):\n        pass\n\n    # Method to delete a node with a specific value\n    def delete_value(self, value):\n        pass\n\n    # Method to search for a value in the list\n    def search(self, value):\n        pass\n\n    # Method to print all elements in the list\n    def print_list(self):\n        pass", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_insertion_at_head(self):\n        list = LinkedList()\n        list.insertAtHead(10)\n        list.insertAtHead(20)\n        list.insertAtHead(30)\n        # Expected: 30 -> 20 -> 10 -> None\n        self.assertTrue(list.search(10))\n        self.assertTrue(list.search(20))\n        self.assertTrue(list.search(30))\n        self.assertFalse(list.search(40))\n\n    def test_insertion_at_tail(self):\n        list = LinkedList()\n        list.insertAtTail(1)\n        list.insertAtTail(2)\n        list.insertAtTail(3)\n        # Expected: 1 -> 2 -> 3 -> None\n        self.assertTrue(list.search(1))\n        self.assertTrue(list.search(2))\n        self.assertTrue(list.search(3))\n        self.assertFalse(list.search(4))\n\n    def test_deletion_of_elements(self):\n        list = LinkedList()\n        list.insertAtHead(5)\n        list.insertAtHead(10)\n        list.insertAtHead(15)\n        list.deleteValue(10)\n        # Expected: 15 -> 5 -> None\n        self.assertFalse(list.search(10))\n        self.assertTrue(list.search(15))\n        self.assertTrue(list.search(5))\n\n        list.deleteValue(15)\n        # Expected: 5 -> None\n        self.assertFalse(list.search(15))\n        self.assertTrue(list.search(5))\n\n        list.deleteValue(5)\n        # Expected: None\n        self.assertFalse(list.search(5))\n\n    def test_search_functionality(self):\n        list = LinkedList()\n        list.insertAtTail(100)\n        list.insertAtTail(200)\n        list.insertAtTail(300)\n        self.assertTrue(list.search(100))\n        self.assertTrue(list.search(200))\n        self.assertTrue(list.search(300))\n        self.assertFalse(list.search(400))\n\n    def test_edge_case_empty_list(self):\n        list = LinkedList()\n        self.assertFalse(list.search(1))  # Searching in an empty list\n        list.deleteValue(1)  # Deleting from an empty list should not crash\n        # Expected: None (still empty)\n        self.assertEqual(list.printList(), None)  # or whatever the printList function returns for empty\n", "prompt": "please write a python class , the class signature as below class Node:\n    def __init__(self, value):\n        self.data = value  # Data held by the node\n        self.next = None   # Pointer to the next node in the list\n\n# LinkedList class definition\nclass LinkedList:\n    # Method to add a node at the beginning of the list\n    def insert_at_head(self, value):\n        pass\n\n    # Method to add a node at the end of the list\n    def insert_at_tail(self, value):\n        pass\n\n    # Method to delete a node with a specific value\n    def delete_value(self, value):\n        pass\n\n    # Method to search for a value in the list\n    def search(self, value):\n        pass\n\n    # Method to print all elements in the list\n    def print_list(self):\n        pass", "addition_info": ""}, "javascript": {"code_signature": "// Node structure for the linked list\nclass Node {\n    constructor(value) { // Constructor to initialize a new node with given data\n        this.data = value; // Data held by the node\n        this.next = null;  // Pointer to the next node in the list\n    }\n}\n\n// LinkedList class definition\nclass LinkedList {\n    constructor() {\n        this.head = null; // Pointer to the first node in the list\n    }\n\n    // Method to add a node at the beginning of the list\n    insertAtHead(value) {}\n\n    // Method to add a node at the end of the list\n    insertAtTail(value) {}\n\n    // Method to delete a node with a specific value\n    deleteValue(value) {}\n\n    // Method to search for a value in the list\n    search(value) {}\n\n    // Method to print all elements in the list\n    printList() {}\n}", "test_code": "describe(\"LinkedList operations\", () => {\n    \n    test(\"Insertion at the head\", () => {\n        const list = new LinkedList();\n        list.insertAtHead(10);\n        list.insertAtHead(20);\n        list.insertAtHead(30);\n\n        console.log = jest.fn(); // Mock console.log\n        list.printList(); // Expected: 30 -> 20 -> 10 -> null\n\n        expect(list.search(10)).toBe(true);\n        expect(list.search(20)).toBe(true);\n        expect(list.search(30)).toBe(true);\n        expect(list.search(40)).toBe(false);\n    });\n\n    test(\"Insertion at the tail\", () => {\n        const list = new LinkedList();\n        list.insertAtTail(1);\n        list.insertAtTail(2);\n        list.insertAtTail(3);\n\n        console.log = jest.fn(); // Mock console.log\n        list.printList(); // Expected: 1 -> 2 -> 3 -> null\n\n        expect(list.search(1)).toBe(true);\n        expect(list.search(2)).toBe(true);\n        expect(list.search(3)).toBe(true);\n        expect(list.search(4)).toBe(false);\n    });\n\n    test(\"Deletion of elements\", () => {\n        const list = new LinkedList();\n        list.insertAtHead(5);\n        list.insertAtHead(10);\n        list.insertAtHead(15);\n\n        list.deleteValue(10);\n        console.log = jest.fn(); // Mock console.log\n        list.printList(); // Expected: 15 -> 5 -> null\n\n        expect(list.search(10)).toBe(false);\n        expect(list.search(15)).toBe(true);\n        expect(list.search(5)).toBe(true);\n\n        list.deleteValue(15);\n        list.printList(); // Expected: 5 -> null\n\n        expect(list.search(15)).toBe(false);\n        expect(list.search(5)).toBe(true);\n\n        list.deleteValue(5);\n        list.printList(); // Expected: null\n\n        expect(list.search(5)).toBe(false);\n    });\n\n    test(\"Search functionality\", () => {\n        const list = new LinkedList();\n        list.insertAtTail(100);\n        list.insertAtTail(200);\n        list.insertAtTail(300);\n\n        expect(list.search(100)).toBe(true);\n        expect(list.search(200)).toBe(true);\n        expect(list.search(300)).toBe(true);\n        expect(list.search(400)).toBe(false);\n    });\n\n    test(\"Edge case: Empty list\", () => {\n        const list = new LinkedList();\n\n        expect(list.search(1)).toBe(false);  // Searching in an empty list\n        list.deleteValue(1);                  // Deleting from an empty list should not crash\n        console.log = jest.fn(); // Mock console.log\n        list.printList();          // Expected: null (still empty)\n    });\n});", "prompt": "please write a javascript class , the class signature as below // Node structure for the linked list\nclass Node {\n    constructor(value) { // Constructor to initialize a new node with given data\n        this.data = value; // Data held by the node\n        this.next = null;  // Pointer to the next node in the list\n    }\n}\n\n// LinkedList class definition\nclass LinkedList {\n    constructor() {\n        this.head = null; // Pointer to the first node in the list\n    }\n\n    // Method to add a node at the beginning of the list\n    insertAtHead(value) {}\n\n    // Method to add a node at the end of the list\n    insertAtTail(value) {}\n\n    // Method to delete a node with a specific value\n    deleteValue(value) {}\n\n    // Method to search for a value in the list\n    search(value) {}\n\n    // Method to print all elements in the list\n    printList() {}\n}", "addition_info": ""}, "typescript": {"code_signature": "class Node {\n    data: number;      // Data held by the node\n    next: Node | null; // Pointer to the next node in the list\n\n    // Constructor to initialize a new node with given data\n    constructor(value: number) {\n        this.data = value;\n        this.next = null;\n    }\n}\n\n// LinkedList class definition\nclass LinkedList {\n    // Method to add a node at the beginning of the list\n    insertAtHead(value: number): void {\n        // Implementation goes here\n    }\n\n    // Method to add a node at the end of the list\n    insertAtTail(value: number): void {\n        // Implementation goes here\n    }\n\n    // Method to delete a node with a specific value\n    deleteValue(value: number): void {\n        // Implementation goes here\n    }\n\n    // Method to search for a value in the list\n    search(value: number): boolean {\n        // Implementation goes here\n        return false; // Placeholder return\n    }\n\n    // Method to print all elements in the list\n    printList(): void {\n        // Implementation goes here\n    }\n}", "test_code": "describe('LinkedList operations', () => {\n\n    test('Insertion at the head', () => {\n        const list = new LinkedList();\n        list.insertAtHead(10);\n        list.insertAtHead(20);\n        list.insertAtHead(30);\n\n        const output = list.printList(); // Capture the output if implemented\n        expect(list.search(10)).toBe(true);\n        expect(list.search(20)).toBe(true);\n        expect(list.search(30)).toBe(true);\n        expect(list.search(40)).toBe(false);\n    });\n\n    test('Insertion at the tail', () => {\n        const list = new LinkedList();\n        list.insertAtTail(1);\n        list.insertAtTail(2);\n        list.insertAtTail(3);\n\n        const output = list.printList(); // Capture the output if implemented\n        expect(list.search(1)).toBe(true);\n        expect(list.search(2)).toBe(true);\n        expect(list.search(3)).toBe(true);\n        expect(list.search(4)).toBe(false);\n    });\n\n    test('Deletion of elements', () => {\n        const list = new LinkedList();\n        list.insertAtHead(5);\n        list.insertAtHead(10);\n        list.insertAtHead(15);\n\n        list.deleteValue(10);\n        const output = list.printList(); // Capture the output if implemented\n        expect(list.search(10)).toBe(false);\n        expect(list.search(15)).toBe(true);\n        expect(list.search(5)).toBe(true);\n\n        list.deleteValue(15);\n        expect(list.printList()).toBe('5 -> null'); // Adjust based on printList implementation\n        expect(list.search(15)).toBe(false);\n        expect(list.search(5)).toBe(true);\n\n        list.deleteValue(5);\n        expect(list.printList()).toBe('null'); // Adjust based on printList implementation\n        expect(list.search(5)).toBe(false);\n    });\n\n    test('Search functionality', () => {\n        const list = new LinkedList();\n        list.insertAtTail(100);\n        list.insertAtTail(200);\n        list.insertAtTail(300);\n\n        expect(list.search(100)).toBe(true);\n        expect(list.search(200)).toBe(true);\n        expect(list.search(300)).toBe(true);\n        expect(list.search(400)).toBe(false);\n    });\n\n    test('Edge case: Empty list', () => {\n        const list = new LinkedList();\n\n        expect(list.search(1)).toBe(false);  // Searching in an empty list\n        list.deleteValue(1);                  // Deleting from an empty list should not crash\n        const output = list.printList();      // Expected: 'null' (still empty)\n        expect(output).toBe('null');          // Adjust based on printList implementation\n    });\n});", "prompt": "please write a typescript class , the class signature as below class Node {\n    data: number;      // Data held by the node\n    next: Node | null; // Pointer to the next node in the list\n\n    // Constructor to initialize a new node with given data\n    constructor(value: number) {\n        this.data = value;\n        this.next = null;\n    }\n}\n\n// LinkedList class definition\nclass LinkedList {\n    // Method to add a node at the beginning of the list\n    insertAtHead(value: number): void {\n        // Implementation goes here\n    }\n\n    // Method to add a node at the end of the list\n    insertAtTail(value: number): void {\n        // Implementation goes here\n    }\n\n    // Method to delete a node with a specific value\n    deleteValue(value: number): void {\n        // Implementation goes here\n    }\n\n    // Method to search for a value in the list\n    search(value: number): boolean {\n        // Implementation goes here\n        return false; // Placeholder return\n    }\n\n    // Method to print all elements in the list\n    printList(): void {\n        // Implementation goes here\n    }\n}", "addition_info": ""}, "c&cpp": {"code_signature": "struct Node {\n    int data;       // Data held by the node\n    Node* next;     // Pointer to the next node in the list\n\n    // Constructor to initialize a new node with given data\n    Node(int value) : data(value), next(nullptr) {}\n};\n\n// LinkedList class definition\nclass LinkedList {\n    // Method to add a node at the beginning of the list\n    void insertAtHead(int value) {\n\n    }\n\n    // Method to add a node at the end of the list\n    void insertAtTail(int value) {\n\n    }\n\n    // Method to delete a node with a specific value\n    void deleteValue(int value) {\n\n    }\n\n    // Method to search for a value in the list\n    bool search(int value) {\n\n    }\n\n    // Method to print all elements in the list\n    void printList() {\n\n    }\n}\n", "test_code": "TEST_CASE(\"LinkedList operations\", \"[LinkedList]\") {\n\n    SECTION(\"Insertion at the head\") {\n        LinkedList list;\n        list.insertAtHead(10);\n        list.insertAtHead(20);\n        list.insertAtHead(30);\n\n        std::ostringstream output;\n        list.printList(); // Expected: 30 -> 20 -> 10 -> nullptr\n        REQUIRE(list.search(10) == true);\n        REQUIRE(list.search(20) == true);\n        REQUIRE(list.search(30) == true);\n        REQUIRE(list.search(40) == false);\n    }\n\n    SECTION(\"Insertion at the tail\") {\n        LinkedList list;\n        list.insertAtTail(1);\n        list.insertAtTail(2);\n        list.insertAtTail(3);\n\n        std::ostringstream output;\n        list.printList(); // Expected: 1 -> 2 -> 3 -> nullptr\n        REQUIRE(list.search(1) == true);\n        REQUIRE(list.search(2) == true);\n        REQUIRE(list.search(3) == true);\n        REQUIRE(list.search(4) == false);\n    }\n\n    SECTION(\"Deletion of elements\") {\n        LinkedList list;\n        list.insertAtHead(5);\n        list.insertAtHead(10);\n        list.insertAtHead(15);\n\n        list.deleteValue(10);\n        std::ostringstream output;\n        list.printList(); // Expected: 15 -> 5 -> nullptr\n        REQUIRE(list.search(10) == false);\n        REQUIRE(list.search(15) == true);\n        REQUIRE(list.search(5) == true);\n\n        list.deleteValue(15);\n        list.printList(); // Expected: 5 -> nullptr\n        REQUIRE(list.search(15) == false);\n        REQUIRE(list.search(5) == true);\n\n        list.deleteValue(5);\n        list.printList(); // Expected: nullptr\n        REQUIRE(list.search(5) == false);\n    }\n\n    SECTION(\"Search functionality\") {\n        LinkedList list;\n        list.insertAtTail(100);\n        list.insertAtTail(200);\n        list.insertAtTail(300);\n\n        REQUIRE(list.search(100) == true);\n        REQUIRE(list.search(200) == true);\n        REQUIRE(list.search(300) == true);\n        REQUIRE(list.search(400) == false);\n    }\n\n    SECTION(\"Edge case: Empty list\") {\n        LinkedList list;\n\n        REQUIRE(list.search(1) == false);  // Searching in an empty list\n        list.deleteValue(1);               // Deleting from an empty list should not crash\n        std::ostringstream output;\n        list.printList();                  // Expected: nullptr (still empty)\n    }\n}", "prompt": "please write a cpp class , the class signature as below struct Node {\n    int data;       // Data held by the node\n    Node* next;     // Pointer to the next node in the list\n\n    // Constructor to initialize a new node with given data\n    Node(int value) : data(value), next(nullptr) {}\n};\n\n// LinkedList class definition\nclass LinkedList {\n    // Method to add a node at the beginning of the list\n    void insertAtHead(int value) {\n\n    }\n\n    // Method to add a node at the end of the list\n    void insertAtTail(int value) {\n\n    }\n\n    // Method to delete a node with a specific value\n    void deleteValue(int value) {\n\n    }\n\n    // Method to search for a value in the list\n    bool search(int value) {\n\n    }\n\n    // Method to print all elements in the list\n    void printList() {\n\n    }\n}\n", "addition_info": "struct Node {\n    int data;       // Data held by the node\n    Node* next;     // Pointer to the next node in the list\n\n    // Constructor to initialize a new node with given data\n    Node(int value) : data(value), next(nullptr) {}\n};\n"}, "java": {"code_signature": "package org.real.temp;\n\npublic class Answer{\n    /**\n * Node structure for the linked list.\n */\nstatic class Node {\n    int data;       // Data held by the node\n    Node next;     // Pointer to the next node in the list\n\n    /**\n     * Constructor to initialize a new node with given data.\n     *\n     * @param value the data value for the node\n     */\n    Node(int value) {\n        this.data = value;\n        this.next = null;\n    }\n}\n/**\n * LinkedList class definition.\n */\nstatic class LinkedList {\n    /**\n     * Method to add a node at the beginning of the list.\n     *\n     * @param value the data value for the new node\n     */\n    void insertAtHead(int value) {\n        // Implementation goes here\n    }\n\n    /**\n     * Method to add a node at the end of the list.\n     *\n     * @param value the data value for the new node\n     */\n    void insertAtTail(int value) {\n        // Implementation goes here\n    }\n\n    /**\n     * Method to delete a node with a specific value.\n     *\n     * @param value the data value of the node to delete\n     */\n    void deleteValue(int value) {\n        // Implementation goes here\n    }\n\n    /**\n     * Method to search for a value in the list.\n     *\n     * @param value the data value to search for\n     * @return true if the value is found, false otherwise\n     */\n    boolean search(int value) {\n        // Implementation goes here\n        return false;\n    }\n\n    /**\n     * Method to print all elements in the list.\n     */\n    void printList() {\n        // Implementation goes here\n    }\n}\n}\n\n\n\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testInsertionAtHead() {\n        LinkedList list = new LinkedList();\n        list.insertAtHead(10);\n        list.insertAtHead(20);\n        list.insertAtHead(30);\n\n        // Expected: 30 -> 20 -> 10 -> null\n        assertTrue(list.search(10));\n        assertTrue(list.search(20));\n        assertTrue(list.search(30));\n        assertFalse(list.search(40));\n    }\n\n    @Test\n    public void testInsertionAtTail() {\n        LinkedList list = new LinkedList();\n        list.insertAtTail(1);\n        list.insertAtTail(2);\n        list.insertAtTail(3);\n\n        // Expected: 1 -> 2 -> 3 -> null\n        assertTrue(list.search(1));\n        assertTrue(list.search(2));\n        assertTrue(list.search(3));\n        assertFalse(list.search(4));\n    }\n\n    @Test\n    public void testDeletionOfElements() {\n        LinkedList list = new LinkedList();\n        list.insertAtHead(5);\n        list.insertAtHead(10);\n        list.insertAtHead(15);\n\n        list.deleteValue(10);\n        // Expected: 15 -> 5 -> null\n        assertFalse(list.search(10));\n        assertTrue(list.search(15));\n        assertTrue(list.search(5));\n\n        list.deleteValue(15);\n        // Expected: 5 -> null\n        assertFalse(list.search(15));\n        assertTrue(list.search(5));\n\n        list.deleteValue(5);\n        // Expected: null\n        assertFalse(list.search(5));\n    }\n\n    @Test\n    public void testSearchFunctionality() {\n        LinkedList list = new LinkedList();\n        list.insertAtTail(100);\n        list.insertAtTail(200);\n        list.insertAtTail(300);\n\n        assertTrue(list.search(100));\n        assertTrue(list.search(200));\n        assertTrue(list.search(300));\n        assertFalse(list.search(400));\n    }\n\n    @Test\n    public void testEdgeCaseEmptyList() {\n        LinkedList list = new LinkedList();\n\n        assertFalse(list.search(1));  // Searching in an empty list\n        list.deleteValue(1);          // Deleting from an empty list should not crash\n        // Expected: still empty\n    }\n}", "prompt": "please write a java class , the function signature as below package org.real.temp;\n\npublic class Answer{\n    /**\n * Node structure for the linked list.\n */\nstatic class Node {\n    int data;       // Data held by the node\n    Node next;     // Pointer to the next node in the list\n\n    /**\n     * Constructor to initialize a new node with given data.\n     *\n     * @param value the data value for the node\n     */\n    Node(int value) {\n        this.data = value;\n        this.next = null;\n    }\n}\n/**\n * LinkedList class definition.\n */\nstatic class LinkedList {\n    /**\n     * Method to add a node at the beginning of the list.\n     *\n     * @param value the data value for the new node\n     */\n    void insertAtHead(int value) {\n        // Implementation goes here\n    }\n\n    /**\n     * Method to add a node at the end of the list.\n     *\n     * @param value the data value for the new node\n     */\n    void insertAtTail(int value) {\n        // Implementation goes here\n    }\n\n    /**\n     * Method to delete a node with a specific value.\n     *\n     * @param value the data value of the node to delete\n     */\n    void deleteValue(int value) {\n        // Implementation goes here\n    }\n\n    /**\n     * Method to search for a value in the list.\n     *\n     * @param value the data value to search for\n     * @return true if the value is found, false otherwise\n     */\n    boolean search(int value) {\n        // Implementation goes here\n        return false;\n    }\n\n    /**\n     * Method to print all elements in the list.\n     */\n    void printList() {\n        // Implementation goes here\n    }\n}\n}\n\n\n\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 210, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Implement the Fibonacci sequence", "language_version_list": {"python": {"code_signature": "def fibonacci_recursive(n: int) -> int:\n    \"\"\"\n    Implement the Fibonacci sequence.\n    Args:\n        n (int): Which Fibonacci number to calculate.\n\n    Returns:\n        int: fibonacci result\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFibonacci(unittest.TestCase):\n    def test_fibonacci_0(self):\n        \"\"\"Test Case 1: Fibonacci of 0 should be 0\"\"\"\n        self.assertEqual(fibonacci_recursive(0), 0)\n\n    def test_fibonacci_1(self):\n        \"\"\"Test Case 2: Fibonacci of 1 should be 1\"\"\"\n        self.assertEqual(fibonacci_recursive(1), 1)\n\n    def test_fibonacci_5(self):\n        \"\"\"Test Case 3: Fibonacci of 5 should be 5\"\"\"\n        self.assertEqual(fibonacci_recursive(5), 5)\n\n    def test_fibonacci_10(self):\n        \"\"\"Test Case 4: Fibonacci of 10 should be 55\"\"\"\n        self.assertEqual(fibonacci_recursive(10), 55)\n\n    def test_fibonacci_20(self):\n        \"\"\"Test Case 5: Fibonacci of 20 should be 6765\"\"\"\n        self.assertEqual(fibonacci_recursive(20), 6765)\n", "prompt": "please write a python function , the function signature as below def fibonacci_recursive(n: int) -> int:\n    \"\"\"\n    Implement the Fibonacci sequence.\n    Args:\n        n (int): Which Fibonacci number to calculate.\n\n    Returns:\n        int: fibonacci result\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Implement the Fibonacci sequence\n *\n * @param {number} n - Which Fibonacci number to calculate.\n * @return {number}\n */\nfunction fibonacciRecursive(n) {}", "test_code": "describe(\"Fibonacci sequence\", () => {\n    // Test Case 1: Fibonacci of 0\n    test(\"Fibonacci(0) should be 0\", () => {\n        expect(fibonacciRecursive(0)).toBe(0);\n    });\n\n    // Test Case 2: Fibonacci of 1\n    test(\"Fibonacci(1) should be 1\", () => {\n        expect(fibonacciRecursive(1)).toBe(1);\n    });\n\n    // Test Case 3: Fibonacci of 5\n    test(\"Fibonacci(5) should be 5\", () => {\n        expect(fibonacciRecursive(5)).toBe(5);\n    });\n\n    // Test Case 4: Fibonacci of 10\n    test(\"Fibonacci(10) should be 55\", () => {\n        expect(fibonacciRecursive(10)).toBe(55);\n    });\n\n    // Test Case 5: Fibonacci of 20\n    test(\"Fibonacci(20) should be 6765\", () => {\n        expect(fibonacciRecursive(20)).toBe(6765);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Implement the Fibonacci sequence\n *\n * @param {number} n - Which Fibonacci number to calculate.\n * @return {number}\n */\nfunction fibonacciRecursive(n) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Implement the Fibonacci sequence\n *\n * @param n Which Fibonacci number to calculate.\n * @returns number\n */\nfunction fibonacciRecursive(n: number): number {}", "test_code": "describe(\"Fibonacci sequence\", () => {\n    // Test Case 1: Fibonacci of 0\n    test(\"Fibonacci(0) should be 0\", () => {\n        expect(fibonacciRecursive(0)).toBe(0);\n    });\n\n    // Test Case 2: Fibonacci of 1\n    test(\"Fibonacci(1) should be 1\", () => {\n        expect(fibonacciRecursive(1)).toBe(1);\n    });\n\n    // Test Case 3: Fibonacci of 5\n    test(\"Fibonacci(5) should be 5\", () => {\n        expect(fibonacciRecursive(5)).toBe(5);\n    });\n\n    // Test Case 4: Fibonacci of 10\n    test(\"Fibonacci(10) should be 55\", () => {\n        expect(fibonacciRecursive(10)).toBe(55);\n    });\n\n    // Test Case 5: Fibonacci of 20\n    test(\"Fibonacci(20) should be 6765\", () => {\n        expect(fibonacciRecursive(20)).toBe(6765);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Implement the Fibonacci sequence\n *\n * @param n Which Fibonacci number to calculate.\n * @returns number\n */\nfunction fibonacciRecursive(n: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Implement the Fibonacci sequence\n *\n * @param n Which Fibonacci number to calculate.\n * @return int\n */\nint fibonacciRecursive(int n) {}", "test_code": "// Test function for iterative, recursive, and memoization Fibonacci\nTEST_CASE(\"Fibonacci sequence\", \"[fibonacci]\") {\n    // Test Case 1: Fibonacci of 0\n    SECTION(\"Fibonacci(0) should be 0\") {\n        REQUIRE(fibonacciRecursive(0) == 0);\n    }\n\n    // Test Case 2: Fibonacci of 1\n    SECTION(\"Fibonacci(1) should be 1\") {\n        REQUIRE(fibonacciRecursive(1) == 1);\n    }\n\n    // Test Case 3: Fibonacci of 5\n    SECTION(\"Fibonacci(5) should be 5\") {\n        REQUIRE(fibonacciRecursive(5) == 5);\n    }\n\n    // Test Case 4: Fibonacci of 10\n    SECTION(\"Fibonacci(10) should be 55\") {\n        REQUIRE(fibonacciRecursive(10) == 55);\n    }\n\n    // Test Case 5: Fibonacci of 20\n    SECTION(\"Fibonacci(20) should be 6765\") {\n        REQUIRE(fibonacciRecursive(20) == 6765);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Implement the Fibonacci sequence\n *\n * @param n Which Fibonacci number to calculate.\n * @return int\n */\nint fibonacciRecursive(int n) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Implement the Fibonacci sequence\n *\n * @param n Which Fibonacci number to calculate.\n * @return int\n */\npublic static int fibonacciRecursive(int n) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    // Test Case 1: Fibonacci of 0\n    @Test\n    public void testFibonacciZero() {\n        assertEquals(0, fibonacciRecursive(0));\n    }\n\n    // Test Case 2: Fibonacci of 1\n    @Test\n    public void testFibonacciOne() {\n        assertEquals(1, fibonacciRecursive(1));\n    }\n\n    // Test Case 3: Fibonacci of 5\n    @Test\n    public void testFibonacciFive() {\n        assertEquals(5, fibonacciRecursive(5));\n    }\n\n    // Test Case 4: Fibonacci of 10\n    @Test\n    public void testFibonacciTen() {\n        assertEquals(55, fibonacciRecursive(10));\n    }\n\n    // Test Case 5: Fibonacci of 20\n    @Test\n    public void testFibonacciTwenty() {\n        assertEquals(6765, fibonacciRecursive(20));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Implement the Fibonacci sequence\n *\n * @param n Which Fibonacci number to calculate.\n * @return int\n */\npublic static int fibonacciRecursive(int n) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 354, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Calculates the Gaussian weight based on the difference in intensity and a color standard deviation. * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))", "language_version_list": {"python": {"code_signature": "def gaussian_weight(intensity_diff: float, sigma_color: float) -> float:\n    \"\"\"\n    Calculate the Gaussian weight based on the difference in intensity and a color standard deviation.\n\n    The Gaussian weight is calculated using the formula:\n    weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))\n\n    Args:\n        intensity_diff (float): The difference in intensity, which is used to compute the weight.\n        sigma_color (float): The standard deviation for the color, affecting the spread of the weight.\n\n    Returns:\n        float: The Gaussian weight.\n    \"\"\"\n", "test_code": "import math\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_zero_intensity_difference(self):\n        # When intensity difference is zero, weight should be 1\n        intensity_diff = 0.0\n        sigma_color = 1.0  # arbitrary sigma value\n        self.assertAlmostEqual(gaussian_weight(intensity_diff, sigma_color), 1.0, delta=0.001)\n\n    def test_positive_intensity_difference(self):\n        # A positive intensity difference with a reasonable sigma\n        intensity_diff = 2.0\n        sigma_color = 2.0\n        expected_weight = math.exp(-(intensity_diff ** 2) / (2 * sigma_color ** 2))\n        self.assertAlmostEqual(gaussian_weight(intensity_diff, sigma_color), expected_weight, delta=0.001)\n\n    def test_negative_intensity_difference(self):\n        # A negative intensity difference should yield the same weight as positive\n        intensity_diff = -2.0\n        sigma_color = 2.0\n        expected_weight = math.exp(-(intensity_diff ** 2) / (2 * sigma_color ** 2))\n        self.assertAlmostEqual(gaussian_weight(intensity_diff, sigma_color), expected_weight, delta=0.001)\n\n    def test_small_sigma_color(self):\n        # Test with a small sigma value\n        intensity_diff = 1.0\n        sigma_color = 0.1\n        expected_weight = math.exp(-(intensity_diff ** 2) / (2 * sigma_color ** 2))\n        self.assertAlmostEqual(gaussian_weight(intensity_diff, sigma_color), expected_weight, delta=0.001)\n\n    def test_large_sigma_color(self):\n        # Test with a large sigma value\n        intensity_diff = 1.0\n        sigma_color = 100.0\n        expected_weight = math.exp(-(intensity_diff ** 2) / (2 * sigma_color ** 2))\n        self.assertAlmostEqual(gaussian_weight(intensity_diff, sigma_color), expected_weight, delta=0.001)\n", "prompt": "please write a python function , the function signature as below def gaussian_weight(intensity_diff: float, sigma_color: float) -> float:\n    \"\"\"\n    Calculate the Gaussian weight based on the difference in intensity and a color standard deviation.\n\n    The Gaussian weight is calculated using the formula:\n    weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))\n\n    Args:\n        intensity_diff (float): The difference in intensity, which is used to compute the weight.\n        sigma_color (float): The standard deviation for the color, affecting the spread of the weight.\n\n    Returns:\n        float: The Gaussian weight.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculates the Gaussian weight based on the difference in intensity and a color standard deviation.\n *\n * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensityDiff^2) / (2 * sigmaColor^2))\n *\n * @param {number} intensityDiff The difference in intensity, which is used to compute the weight.\n * @param {number} sigmaColor The standard deviation for the color, affecting the spread of the weight.\n * @return {number} The Gaussian weight.\n */\nfunction gaussianWeight(intensityDiff, sigmaColor) {}", "test_code": "describe(\"Gaussian Weight Calculation Tests\", () => {\n\n    test(\"Zero Intensity Difference\", () => {\n        // When intensity difference is zero, weight should be 1\n        const intensityDiff = 0.0;\n        const sigmaColor = 1.0; // arbitrary sigma value\n        expect(gaussianWeight(intensityDiff, sigmaColor)).toBeCloseTo(1.0, 3);\n    });\n\n    test(\"Positive Intensity Difference\", () => {\n        // A positive intensity difference with a reasonable sigma\n        const intensityDiff = 2.0;\n        const sigmaColor = 2.0;\n        const expectedWeight = Math.exp(-(intensityDiff * intensityDiff) / (2 * sigmaColor * sigmaColor));\n        expect(gaussianWeight(intensityDiff, sigmaColor)).toBeCloseTo(expectedWeight, 3);\n    });\n\n    test(\"Negative Intensity Difference\", () => {\n        // A negative intensity difference should yield the same weight as positive\n        const intensityDiff = -2.0;\n        const sigmaColor = 2.0;\n        const expectedWeight = Math.exp(-(intensityDiff * intensityDiff) / (2 * sigmaColor * sigmaColor));\n        expect(gaussianWeight(intensityDiff, sigmaColor)).toBeCloseTo(expectedWeight, 3);\n    });\n\n    test(\"Small Sigma Color\", () => {\n        // Test with a small sigma value\n        const intensityDiff = 1.0;\n        const sigmaColor = 0.1;\n        const expectedWeight = Math.exp(-(intensityDiff * intensityDiff) / (2 * sigmaColor * sigmaColor));\n        expect(gaussianWeight(intensityDiff, sigmaColor)).toBeCloseTo(expectedWeight, 3);\n    });\n\n    test(\"Large Sigma Color\", () => {\n        // Test with a large sigma value\n        const intensityDiff = 1.0;\n        const sigmaColor = 100.0;\n        const expectedWeight = Math.exp(-(intensityDiff * intensityDiff) / (2 * sigmaColor * sigmaColor));\n        expect(gaussianWeight(intensityDiff, sigmaColor)).toBeCloseTo(expectedWeight, 3);\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the Gaussian weight based on the difference in intensity and a color standard deviation.\n *\n * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensityDiff^2) / (2 * sigmaColor^2))\n *\n * @param {number} intensityDiff The difference in intensity, which is used to compute the weight.\n * @param {number} sigmaColor The standard deviation for the color, affecting the spread of the weight.\n * @return {number} The Gaussian weight.\n */\nfunction gaussianWeight(intensityDiff, sigmaColor) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the Gaussian weight based on the difference in intensity and a color standard deviation.\n *\n * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensityDiff^2) / (2 * sigmaColor^2))\n *\n * @param intensityDiff The difference in intensity, which is used to compute the weight.\n * @param sigmaColor The standard deviation for the color, affecting the spread of the weight.\n * @returns The Gaussian weight as a number.\n */\nfunction gaussianWeight(intensityDiff: number, sigmaColor: number): number {}", "test_code": "describe(\"Gaussian Weight Calculation Tests\", () => {\n\n    test(\"Zero Intensity Difference\", () => {\n        // When intensity difference is zero, weight should be 1\n        const intensityDiff = 0.0;\n        const sigmaColor = 1.0; // arbitrary sigma value\n        expect(gaussianWeight(intensityDiff, sigmaColor)).toBeCloseTo(1.0, 3);\n    });\n\n    test(\"Positive Intensity Difference\", () => {\n        // A positive intensity difference with a reasonable sigma\n        const intensityDiff = 2.0;\n        const sigmaColor = 2.0;\n        const expectedWeight = Math.exp(-(intensityDiff * intensityDiff) / (2 * sigmaColor * sigmaColor));\n        expect(gaussianWeight(intensityDiff, sigmaColor)).toBeCloseTo(expectedWeight, 3);\n    });\n\n    test(\"Negative Intensity Difference\", () => {\n        // A negative intensity difference should yield the same weight as positive\n        const intensityDiff = -2.0;\n        const sigmaColor = 2.0;\n        const expectedWeight = Math.exp(-(intensityDiff * intensityDiff) / (2 * sigmaColor * sigmaColor));\n        expect(gaussianWeight(intensityDiff, sigmaColor)).toBeCloseTo(expectedWeight, 3);\n    });\n\n    test(\"Small Sigma Color\", () => {\n        // Test with a small sigma value\n        const intensityDiff = 1.0;\n        const sigmaColor = 0.1;\n        const expectedWeight = Math.exp(-(intensityDiff * intensityDiff) / (2 * sigmaColor * sigmaColor));\n        expect(gaussianWeight(intensityDiff, sigmaColor)).toBeCloseTo(expectedWeight, 3);\n    });\n\n    test(\"Large Sigma Color\", () => {\n        // Test with a large sigma value\n        const intensityDiff = 1.0;\n        const sigmaColor = 100.0;\n        const expectedWeight = Math.exp(-(intensityDiff * intensityDiff) / (2 * sigmaColor * sigmaColor));\n        expect(gaussianWeight(intensityDiff, sigmaColor)).toBeCloseTo(expectedWeight, 3);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the Gaussian weight based on the difference in intensity and a color standard deviation.\n *\n * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensityDiff^2) / (2 * sigmaColor^2))\n *\n * @param intensityDiff The difference in intensity, which is used to compute the weight.\n * @param sigmaColor The standard deviation for the color, affecting the spread of the weight.\n * @returns The Gaussian weight as a number.\n */\nfunction gaussianWeight(intensityDiff: number, sigmaColor: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <cmath> // Include the cmath library for the exp function\n\n/**\n * @brief Calculates the Gaussian weight based on the difference in intensity and a color standard deviation.\n *\n * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))\n *\n * @param intensity_diff The difference in intensity, which is used to compute the weight.\n * @param sigma_color The standard deviation for the color, affecting the spread of the weight.\n * @return The Gaussian weight as a float.\n */\ninline float gaussianWeight(float intensity_diff, float sigma_color) {}", "test_code": "// Test cases for gaussianWeight function\nTEST_CASE(\"Gaussian Weight Calculation Tests\") {\n\n    SECTION(\"Zero Intensity Difference\") {\n        // When intensity difference is zero, weight should be 1\n        float intensity_diff = 0.0f;\n        float sigma_color = 1.0f; // arbitrary sigma value\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(1.0f).epsilon(0.001));\n    }\n\n    SECTION(\"Positive Intensity Difference\") {\n        // A positive intensity difference with a reasonable sigma\n        float intensity_diff = 2.0f;\n        float sigma_color = 2.0f;\n        float expected_weight = exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Negative Intensity Difference\") {\n        // A negative intensity difference should yield the same weight as positive\n        float intensity_diff = -2.0f;\n        float sigma_color = 2.0f;\n        float expected_weight = exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Small Sigma Color\") {\n        // Test with a small sigma value\n        float intensity_diff = 1.0f;\n        float sigma_color = 0.1f;\n        float expected_weight = exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Large Sigma Color\") {\n        // Test with a large sigma value\n        float intensity_diff = 1.0f;\n        float sigma_color = 100.0f;\n        float expected_weight = exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(expected_weight).epsilon(0.001));\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <cmath> // Include the cmath library for the exp function\n\n/**\n * @brief Calculates the Gaussian weight based on the difference in intensity and a color standard deviation.\n *\n * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))\n *\n * @param intensity_diff The difference in intensity, which is used to compute the weight.\n * @param sigma_color The standard deviation for the color, affecting the spread of the weight.\n * @return The Gaussian weight as a float.\n */\ninline float gaussianWeight(float intensity_diff, float sigma_color) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * @brief Calculates the Gaussian weight based on the difference in intensity and a color standard deviation.\n *\n * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))\n *\n * @param intensity_diff The difference in intensity, which is used to compute the weight.\n * @param sigma_color The standard deviation for the color, affecting the spread of the weight.\n * @return The Gaussian weight as a float.\n */\npublic static float gaussianWeight(float intensity_diff, float sigma_color) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testZeroIntensityDifference() {\n        // When intensity difference is zero, weight should be 1\n        float intensity_diff = 0.0f;\n        float sigma_color = 1.0f; // arbitrary sigma value\n        assertEquals(1.0f, Answer.gaussianWeight(intensity_diff, sigma_color), 0.001);\n    }\n\n    @Test\n    public void testPositiveIntensityDifference() {\n        // A positive intensity difference with a reasonable sigma\n        float intensity_diff = 2.0f;\n        float sigma_color = 2.0f;\n        float expected_weight = (float) Math.exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        assertEquals(expected_weight, Answer.gaussianWeight(intensity_diff, sigma_color), 0.001);\n    }\n\n    @Test\n    public void testNegativeIntensityDifference() {\n        // A negative intensity difference should yield the same weight as positive\n        float intensity_diff = -2.0f;\n        float sigma_color = 2.0f;\n        float expected_weight = (float) Math.exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        assertEquals(expected_weight, Answer.gaussianWeight(intensity_diff, sigma_color), 0.001);\n    }\n\n    @Test\n    public void testSmallSigmaColor() {\n        // Test with a small sigma value\n        float intensity_diff = 1.0f;\n        float sigma_color = 0.1f;\n        float expected_weight = (float) Math.exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        assertEquals(expected_weight, Answer.gaussianWeight(intensity_diff, sigma_color), 0.001);\n    }\n\n    @Test\n    public void testLargeSigmaColor() {\n        // Test with a large sigma value\n        float intensity_diff = 1.0f;\n        float sigma_color = 100.0f;\n        float expected_weight = (float) Math.exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        assertEquals(expected_weight, Answer.gaussianWeight(intensity_diff, sigma_color), 0.001);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * @brief Calculates the Gaussian weight based on the difference in intensity and a color standard deviation.\n *\n * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))\n *\n * @param intensity_diff The difference in intensity, which is used to compute the weight.\n * @param sigma_color The standard deviation for the color, affecting the spread of the weight.\n * @return The Gaussian weight as a float.\n */\npublic static float gaussianWeight(float intensity_diff, float sigma_color) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 355, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation. * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))", "language_version_list": {"python": {"code_signature": "def spatial_weight(spatial_diff: float, sigma_space: float) -> float:\n    \"\"\"\n    Calculate the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n\n    The spatial weight is calculated using the formula:\n    weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n\n    Args:\n        spatial_diff (float): The difference in spatial coordinates, which is used to compute the weight.\n        sigma_space (float): The standard deviation for spatial distance, affecting the spread of the weight.\n\n    Returns:\n        float: The spatial weight.\n    \"\"\"\n", "test_code": "import math\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_zero_spatial_difference(self):\n        # When spatial difference is zero, weight should be 1\n        spatial_diff = 0.0\n        sigma_space = 1.0  # arbitrary sigma value\n        self.assertAlmostEqual(spatial_weight(spatial_diff, sigma_space), 1.0, delta=0.001)\n\n    def test_positive_spatial_difference(self):\n        # A positive spatial difference with a reasonable sigma\n        spatial_diff = 2.0\n        sigma_space = 2.0\n        expected_weight = math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space))\n        self.assertAlmostEqual(spatial_weight(spatial_diff, sigma_space), expected_weight, delta=0.001)\n\n    def test_negative_spatial_difference(self):\n        # A negative spatial difference should yield the same weight as positive\n        spatial_diff = -2.0\n        sigma_space = 2.0\n        expected_weight = math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space))\n        self.assertAlmostEqual(spatial_weight(spatial_diff, sigma_space), expected_weight, delta=0.001)\n\n    def test_small_sigma_space(self):\n        # Test with a small sigma value\n        spatial_diff = 1.0\n        sigma_space = 0.1\n        expected_weight = math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space))\n        self.assertAlmostEqual(spatial_weight(spatial_diff, sigma_space), expected_weight, delta=0.001)\n\n    def test_large_sigma_space(self):\n        # Test with a large sigma value\n        spatial_diff = 1.0\n        sigma_space = 100.0\n        expected_weight = math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space))\n        self.assertAlmostEqual(spatial_weight(spatial_diff, sigma_space), expected_weight, delta=0.001)\n", "prompt": "please write a python function , the function signature as below def spatial_weight(spatial_diff: float, sigma_space: float) -> float:\n    \"\"\"\n    Calculate the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n\n    The spatial weight is calculated using the formula:\n    weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n\n    Args:\n        spatial_diff (float): The difference in spatial coordinates, which is used to compute the weight.\n        sigma_space (float): The standard deviation for spatial distance, affecting the spread of the weight.\n\n    Returns:\n        float: The spatial weight.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n *\n * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n *\n * @param {number} spatial_diff The difference in spatial coordinates, which is used to compute the weight.\n * @param {number} sigma_space The standard deviation for spatial distance, affecting the spread of the weight.\n * @return {number} The spatial weight.\n */\nfunction spatialWeight(spatial_diff, sigma_space) {}", "test_code": "describe('Spatial Weight Calculation Tests', () => {\n    \n    test('Zero Spatial Difference', () => {\n        // When spatial difference is zero, weight should be 1\n        const spatial_diff = 0.0;\n        const sigma_space = 1.0; // arbitrary sigma value\n        expect(spatialWeight(spatial_diff, sigma_space)).toBeCloseTo(1.0, 3);\n    });\n\n    test('Positive Spatial Difference', () => {\n        // A positive spatial difference with a reasonable sigma\n        const spatial_diff = 2.0;\n        const sigma_space = 2.0;\n        const expected_weight = Math.exp(-(spatial_diff ** 2) / (2 * sigma_space ** 2));\n        expect(spatialWeight(spatial_diff, sigma_space)).toBeCloseTo(expected_weight, 3);\n    });\n\n    test('Negative Spatial Difference', () => {\n        // A negative spatial difference should yield the same weight as positive\n        const spatial_diff = -2.0;\n        const sigma_space = 2.0;\n        const expected_weight = Math.exp(-(spatial_diff ** 2) / (2 * sigma_space ** 2));\n        expect(spatialWeight(spatial_diff, sigma_space)).toBeCloseTo(expected_weight, 3);\n    });\n\n    test('Small Sigma Space', () => {\n        // Test with a small sigma value\n        const spatial_diff = 1.0;\n        const sigma_space = 0.1;\n        const expected_weight = Math.exp(-(spatial_diff ** 2) / (2 * sigma_space ** 2));\n        expect(spatialWeight(spatial_diff, sigma_space)).toBeCloseTo(expected_weight, 3);\n    });\n\n    test('Large Sigma Space', () => {\n        // Test with a large sigma value\n        const spatial_diff = 1.0;\n        const sigma_space = 100.0;\n        const expected_weight = Math.exp(-(spatial_diff ** 2) / (2 * sigma_space ** 2));\n        expect(spatialWeight(spatial_diff, sigma_space)).toBeCloseTo(expected_weight, 3);\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n *\n * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n *\n * @param {number} spatial_diff The difference in spatial coordinates, which is used to compute the weight.\n * @param {number} sigma_space The standard deviation for spatial distance, affecting the spread of the weight.\n * @return {number} The spatial weight.\n */\nfunction spatialWeight(spatial_diff, sigma_space) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n *\n * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n *\n * @param spatial_diff The difference in spatial coordinates, which is used to compute the weight.\n * @param sigma_space The standard deviation for spatial distance, affecting the spread of the weight.\n * @returns The spatial weight as a number.\n */\nfunction spatialWeight(spatial_diff: number, sigma_space: number): number {}", "test_code": "describe(\"Spatial Weight Calculation Tests\", () => {\n    \n    test(\"Zero Spatial Difference\", () => {\n        // When spatial difference is zero, weight should be 1\n        const spatial_diff = 0.0;\n        const sigma_space = 1.0; // arbitrary sigma value\n        expect(spatialWeight(spatial_diff, sigma_space)).toBeCloseTo(1.0, 3); // Using 3 decimal places\n    });\n\n    test(\"Positive Spatial Difference\", () => {\n        // A positive spatial difference with a reasonable sigma\n        const spatial_diff = 2.0;\n        const sigma_space = 2.0;\n        const expected_weight = Math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        expect(spatialWeight(spatial_diff, sigma_space)).toBeCloseTo(expected_weight, 3);\n    });\n\n    test(\"Negative Spatial Difference\", () => {\n        // A negative spatial difference should yield the same weight as positive\n        const spatial_diff = -2.0;\n        const sigma_space = 2.0;\n        const expected_weight = Math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        expect(spatialWeight(spatial_diff, sigma_space)).toBeCloseTo(expected_weight, 3);\n    });\n\n    test(\"Small Sigma Space\", () => {\n        // Test with a small sigma value\n        const spatial_diff = 1.0;\n        const sigma_space = 0.1;\n        const expected_weight = Math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        expect(spatialWeight(spatial_diff, sigma_space)).toBeCloseTo(expected_weight, 3);\n    });\n\n    test(\"Large Sigma Space\", () => {\n        // Test with a large sigma value\n        const spatial_diff = 1.0;\n        const sigma_space = 100.0;\n        const expected_weight = Math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        expect(spatialWeight(spatial_diff, sigma_space)).toBeCloseTo(expected_weight, 3);\n    });\n\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n *\n * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n *\n * @param spatial_diff The difference in spatial coordinates, which is used to compute the weight.\n * @param sigma_space The standard deviation for spatial distance, affecting the spread of the weight.\n * @returns The spatial weight as a number.\n */\nfunction spatialWeight(spatial_diff: number, sigma_space: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <cmath> // Include cmath for the exp function\n\n/**\n * @brief Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n *\n * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n *\n * @param spatial_diff The difference in spatial coordinates, which is used to compute the weight.\n * @param sigma_space The standard deviation for spatial distance, affecting the spread of the weight.\n * @return The spatial weight as a float.\n *\n */\ninline float spatialWeight(float spatial_diff, float sigma_space) {}", "test_code": "TEST_CASE(\"Spatial Weight Calculation Tests\") {\n\n    SECTION(\"Zero Spatial Difference\") {\n        // When spatial difference is zero, weight should be 1\n        float spatial_diff = 0.0f;\n        float sigma_space = 1.0f; // arbitrary sigma value\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(1.0f).epsilon(0.001));\n    }\n\n    SECTION(\"Positive Spatial Difference\") {\n        // A positive spatial difference with a reasonable sigma\n        float spatial_diff = 2.0f;\n        float sigma_space = 2.0f;\n        float expected_weight = exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Negative Spatial Difference\") {\n        // A negative spatial difference should yield the same weight as positive\n        float spatial_diff = -2.0f;\n        float sigma_space = 2.0f;\n        float expected_weight = exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Small Sigma Space\") {\n        // Test with a small sigma value\n        float spatial_diff = 1.0f;\n        float sigma_space = 0.1f;\n        float expected_weight = exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Large Sigma Space\") {\n        // Test with a large sigma value\n        float spatial_diff = 1.0f;\n        float sigma_space = 100.0f;\n        float expected_weight = exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(expected_weight).epsilon(0.001));\n    }\n\n}", "prompt": "please write a cpp function , the function signature as below #include <cmath> // Include cmath for the exp function\n\n/**\n * @brief Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n *\n * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n *\n * @param spatial_diff The difference in spatial coordinates, which is used to compute the weight.\n * @param sigma_space The standard deviation for spatial distance, affecting the spread of the weight.\n * @return The spatial weight as a float.\n *\n */\ninline float spatialWeight(float spatial_diff, float sigma_space) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n *\n * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n *\n * @param spatial_diff The difference in spatial coordinates, which is used to compute the weight.\n * @param sigma_space The standard deviation for spatial distance, affecting the spread of the weight.\n * @return The spatial weight as a float.\n * @throws IllegalArgumentException if sigma_space is less than or equal to zero.\n */\n\npublic static float spatialWeight(float spatial_diff, float sigma_space) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testZeroSpatialDifference() {\n        // When spatial difference is zero, weight should be 1\n        float spatial_diff = 0.0f;\n        float sigma_space = 1.0f; // arbitrary sigma value\n        assertEquals(1.0f, Answer.spatialWeight(spatial_diff, sigma_space), 0.001);\n    }\n\n    @Test\n    public void testPositiveSpatialDifference() {\n        // A positive spatial difference with a reasonable sigma\n        float spatial_diff = 2.0f;\n        float sigma_space = 2.0f;\n        float expected_weight = (float) Math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        assertEquals(expected_weight, Answer.spatialWeight(spatial_diff, sigma_space), 0.001);\n    }\n\n    @Test\n    public void testNegativeSpatialDifference() {\n        // A negative spatial difference should yield the same weight as positive\n        float spatial_diff = -2.0f;\n        float sigma_space = 2.0f;\n        float expected_weight = (float) Math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        assertEquals(expected_weight, Answer.spatialWeight(spatial_diff, sigma_space), 0.001);\n    }\n\n    @Test\n    public void testSmallSigmaSpace() {\n        // Test with a small sigma value\n        float spatial_diff = 1.0f;\n        float sigma_space = 0.1f;\n        float expected_weight = (float) Math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        assertEquals(expected_weight, Answer.spatialWeight(spatial_diff, sigma_space), 0.001);\n    }\n\n    @Test\n    public void testLargeSigmaSpace() {\n        // Test with a large sigma value\n        float spatial_diff = 1.0f;\n        float sigma_space = 100.0f;\n        float expected_weight = (float) Math.exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        assertEquals(expected_weight, Answer.spatialWeight(spatial_diff, sigma_space), 0.001);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n *\n * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n *\n * @param spatial_diff The difference in spatial coordinates, which is used to compute the weight.\n * @param sigma_space The standard deviation for spatial distance, affecting the spread of the weight.\n * @return The spatial weight as a float.\n * @throws IllegalArgumentException if sigma_space is less than or equal to zero.\n */\n\npublic static float spatialWeight(float spatial_diff, float sigma_space) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 356, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Implement bubble sort algorithm", "language_version_list": {"python": {"code_signature": "def bubble_sort(arr:list):\n    \"\"\"\n    Implements the Bubble Sort algorithm.\n\n    Args:\n        arr (list): A list of integers to be sorted.\n\n    Returns:\n\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_sorted_array(self):\n        \"\"\"Test Case 1: Sorting an already sorted array\"\"\"\n        arr1 = [1, 2, 3, 4, 5]\n        bubble_sort(arr1)\n        self.assertEqual(arr1, [1, 2, 3, 4, 5])\n\n    def test_reverse_sorted_array(self):\n        \"\"\"Test Case 2: Sorting a reverse sorted array\"\"\"\n        arr2 = [5, 4, 3, 2, 1]\n        bubble_sort(arr2)\n        self.assertEqual(arr2, [1, 2, 3, 4, 5])\n\n    def test_array_with_duplicates(self):\n        \"\"\"Test Case 3: Sorting an array with duplicate elements\"\"\"\n        arr3 = [3, 1, 2, 3, 2]\n        bubble_sort(arr3)\n        self.assertEqual(arr3, [1, 2, 2, 3, 3])\n\n    def test_single_element_array(self):\n        \"\"\"Test Case 4: Sorting an array with a single element\"\"\"\n        arr4 = [1]\n        bubble_sort(arr4)\n        self.assertEqual(arr4, [1])\n\n    def test_empty_array(self):\n        \"\"\"Test Case 5: Sorting an empty array\"\"\"\n        arr5 = []\n        bubble_sort(arr5)\n        self.assertEqual(arr5, [])\n", "prompt": "please write a python function , the function signature as below def bubble_sort(arr:list):\n    \"\"\"\n    Implements the Bubble Sort algorithm.\n\n    Args:\n        arr (list): A list of integers to be sorted.\n\n    Returns:\n\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Implements the Bubble Sort algorithm.\n *\n * @param {number[]} arr - An array of integers to be sorted.\n */\nfunction bubbleSort(arr) {}", "test_code": "describe(\"BubbleSort Test Cases\", () => {\n    // Test Case 1: Sorting an already sorted array\n    test(\"should sort an already sorted array\", () => {\n        const arr1 = [1, 2, 3, 4, 5];\n        bubbleSort(arr1);\n        expect(arr1).toEqual([1, 2, 3, 4, 5]);\n    });\n\n    // Test Case 2: Sorting a reverse sorted array\n    test(\"should sort a reverse sorted array\", () => {\n        const arr2 = [5, 4, 3, 2, 1];\n        bubbleSort(arr2);\n        expect(arr2).toEqual([1, 2, 3, 4, 5]);\n    });\n\n    // Test Case 3: Sorting an array with duplicate elements\n    test(\"should sort an array with duplicate elements\", () => {\n        const arr3 = [3, 1, 2, 3, 2];\n        bubbleSort(arr3);\n        expect(arr3).toEqual([1, 2, 2, 3, 3]);\n    });\n\n    // Test Case 4: Sorting an array with a single element\n    test(\"should sort an array with a single element\", () => {\n        const arr4 = [1];\n        bubbleSort(arr4);\n        expect(arr4).toEqual([1]);\n    });\n\n    // Test Case 5: Sorting an empty array\n    test(\"should sort an empty array\", () => {\n        const arr5 = [];\n        bubbleSort(arr5);\n        expect(arr5).toEqual([]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Implements the Bubble Sort algorithm.\n *\n * @param {number[]} arr - An array of integers to be sorted.\n */\nfunction bubbleSort(arr) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Implements the Bubble Sort algorithm.\n *\n * @param arr An array of integers to be sorted.\n */\nfunction bubbleSort(arr: number[]): void {}", "test_code": "describe(\"BubbleSort Test Cases\", () => {\n    // Test Case 1: Sorting an already sorted array\n    test(\"should sort an already sorted array\", () => {\n        const arr1 = [1, 2, 3, 4, 5];\n        bubbleSort(arr1);\n        expect(arr1).toEqual([1, 2, 3, 4, 5]);\n    });\n\n    // Test Case 2: Sorting a reverse sorted array\n    test(\"should sort a reverse sorted array\", () => {\n        const arr2 = [5, 4, 3, 2, 1];\n        bubbleSort(arr2);\n        expect(arr2).toEqual([1, 2, 3, 4, 5]);\n    });\n\n    // Test Case 3: Sorting an array with duplicate elements\n    test(\"should sort an array with duplicate elements\", () => {\n        const arr3 = [3, 1, 2, 3, 2];\n        bubbleSort(arr3);\n        expect(arr3).toEqual([1, 2, 2, 3, 3]);\n    });\n\n    // Test Case 4: Sorting an array with a single element\n    test(\"should handle an array with a single element\", () => {\n        const arr4 = [1];\n        bubbleSort(arr4);\n        expect(arr4).toEqual([1]);\n    });\n\n    // Test Case 5: Sorting an empty array\n    test(\"should handle an empty array\", () => {\n        const arr5: number[] = [];\n        bubbleSort(arr5);\n        expect(arr5).toEqual([]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Implements the Bubble Sort algorithm.\n *\n * @param arr An array of integers to be sorted.\n */\nfunction bubbleSort(arr: number[]): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Implements the Bubble Sort algorithm.\n *\n * @param arr A reference to a vector of integers to be sorted.\n */\nvoid bubbleSort(std::vector<int>& arr) {\n\t\n}", "test_code": "TEST_CASE(\"BubbleSort Test Cases\", \"[bubbleSort]\") {\n    // Test Case 1: Sorting an already sorted array\n    std::vector<int> arr1 = {1, 2, 3, 4, 5};\n    bubbleSort(arr1);\n    REQUIRE(arr1 == std::vector<int>{1, 2, 3, 4, 5});\n\n    // Test Case 2: Sorting a reverse sorted array\n    std::vector<int> arr2 = {5, 4, 3, 2, 1};\n    bubbleSort(arr2);\n    REQUIRE(arr2 == std::vector<int>{1, 2, 3, 4, 5});\n\n    // Test Case 3: Sorting an array with duplicate elements\n    std::vector<int> arr3 = {3, 1, 2, 3, 2};\n    bubbleSort(arr3);\n    REQUIRE(arr3 == std::vector<int>{1, 2, 2, 3, 3});\n\n    // Test Case 4: Sorting an array with a single element\n    std::vector<int> arr4 = {1};\n    bubbleSort(arr4);\n    REQUIRE(arr4 == std::vector<int>{1});\n\n    // Test Case 5: Sorting an empty array\n    std::vector<int> arr5 = {};\n    bubbleSort(arr5);\n    REQUIRE(arr5 == std::vector<int>{});\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Implements the Bubble Sort algorithm.\n *\n * @param arr A reference to a vector of integers to be sorted.\n */\nvoid bubbleSort(std::vector<int>& arr) {\n\t\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Sorts the given list of integers using the Bubble Sort algorithm.\n *\n * @param arr A list of integers to be sorted.\n */\npublic static void bubbleSort(List<Integer> arr) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testBubbleSort() {\n        // Test Case 1: Sorting an already sorted array\n        List<Integer> arr1 = Arrays.asList(1, 2, 3, 4, 5);\n        Answer.bubbleSort(arr1);\n        assertEquals(Arrays.asList(1, 2, 3, 4, 5), arr1);\n\n        // Test Case 2: Sorting a reverse sorted array\n        List<Integer> arr2 = Arrays.asList(5, 4, 3, 2, 1);\n        Answer.bubbleSort(arr2);\n        assertEquals(Arrays.asList(1, 2, 3, 4, 5), arr2);\n\n        // Test Case 3: Sorting an array with duplicate elements\n        List<Integer> arr3 = Arrays.asList(3, 1, 2, 3, 2);\n        Answer.bubbleSort(arr3);\n        assertEquals(Arrays.asList(1, 2, 2, 3, 3), arr3);\n\n        // Test Case 4: Sorting an array with a single element\n        List<Integer> arr4 = Arrays.asList(1);\n        Answer.bubbleSort(arr4);\n        assertEquals(Arrays.asList(1), arr4);\n\n        // Test Case 5: Sorting an empty array\n        List<Integer> arr5 = Arrays.asList();\n        Answer.bubbleSort(arr5);\n        assertEquals(Arrays.asList(), arr5);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Sorts the given list of integers using the Bubble Sort algorithm.\n *\n * @param arr A list of integers to be sorted.\n */\npublic static void bubbleSort(List<Integer> arr) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 357, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Implement hill sort", "language_version_list": {"python": {"code_signature": "def hill_sort(arr:list):\n    \"\"\"\n    Sorts a list of integers using the Hill Sort (Shell Sort) algorithm.\n\n    Args:\n        arr (list of int): A list of integers that will be sorted in-place.\n    \"\"\"\n", "test_code": "import unittest\n\ndef is_sorted(arr):\n    return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\nclass Tester(unittest.TestCase):\n    \"\"\"\n    Test cases for the hill_sort function.\n    \"\"\"\n    \n    def test_hill_sort_sorted_array(self):\n        arr = [1, 2, 3, 4, 5]\n        hill_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n    def test_hill_sort_reverse_order(self):\n        arr = [5, 4, 3, 2, 1]\n        hill_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n    def test_hill_sort_with_duplicates(self):\n        arr = [3, 1, 2, 3, 2]\n        hill_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n    def test_hill_sort_identical_values(self):\n        arr = [1, 1, 1, 1, 1]\n        hill_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n    def test_hill_sort_empty_array(self):\n        arr = []\n        hill_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n    def test_hill_sort_single_element(self):\n        arr = [42]\n        hill_sort(arr)\n        self.assertTrue(is_sorted(arr))\n\n    def test_hill_sort_large_random_array(self):\n        arr = [3, 7, 2, 5, 1, 4, 6, 0, 9, 8]\n        hill_sort(arr)\n        self.assertTrue(is_sorted(arr))", "prompt": "please write a python function , the function signature as below def hill_sort(arr:list):\n    \"\"\"\n    Sorts a list of integers using the Hill Sort (Shell Sort) algorithm.\n\n    Args:\n        arr (list of int): A list of integers that will be sorted in-place.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Sorts an array of integers using the Hill Sort (Shell Sort) algorithm.\n *\n * @param {number[]} arr An array of integers that will be sorted in-place.\n */\nfunction hillSort(arr) {}", "test_code": "function isSorted(arr) {\n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Test cases\ndescribe('Hill Sort', () => {\n    test('Sort an already sorted array', () => {\n        const arr = [1, 2, 3, 4, 5];\n        hillSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n\n    test('Sort an array in reverse order', () => {\n        const arr = [5, 4, 3, 2, 1];\n        hillSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n\n    test('Sort an array with duplicate values', () => {\n        const arr = [3, 1, 2, 3, 2];\n        hillSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n\n    test('Sort an array with all identical values', () => {\n        const arr = [1, 1, 1, 1, 1];\n        hillSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n\n    test('Sort an empty array', () => {\n        const arr = [];\n        hillSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n\n    test('Sort an array with one element', () => {\n        const arr = [42];\n        hillSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n\n    test('Sort a large random array', () => {\n        const arr = [3, 7, 2, 5, 1, 4, 6, 0, 9, 8];\n        hillSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Sorts an array of integers using the Hill Sort (Shell Sort) algorithm.\n *\n * @param {number[]} arr An array of integers that will be sorted in-place.\n */\nfunction hillSort(arr) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Sorts an array of integers using the Hill Sort (Shell Sort) algorithm.\n *\n * @param arr An array of integers that will be sorted in-place.\n *\n */\nfunction hillSort(arr: number[]): void {}", "test_code": "function isSorted(arr: number[]): boolean {\n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Test cases for Hill Sort\ndescribe(\"Hill Sort\", () => {\n    test(\"Sort an already sorted array\", () => {\n        const arr = [1, 2, 3, 4, 5];\n        hillSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n\n    test(\"Sort an array in reverse order\", () => {\n        const arr = [5, 4, 3, 2, 1];\n        hillSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n\n    test(\"Sort an array with duplicate values\", () => {\n        const arr = [3, 1, 2, 3, 2];\n        hillSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n\n    test(\"Sort an array with all identical values\", () => {\n        const arr = [1, 1, 1, 1, 1];\n        hillSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n\n    test(\"Sort an empty array\", () => {\n        const arr: number[] = [];\n        hillSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n\n    test(\"Sort an array with one element\", () => {\n        const arr = [42];\n        hillSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n\n    test(\"Sort a large random array\", () => {\n        const arr = [3, 7, 2, 5, 1, 4, 6, 0, 9, 8];\n        hillSort(arr);\n        expect(isSorted(arr)).toBe(true);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Sorts an array of integers using the Hill Sort (Shell Sort) algorithm.\n *\n * @param arr An array of integers that will be sorted in-place.\n *\n */\nfunction hillSort(arr: number[]): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Sorts a vector of integers using the Hill Sort (Shell Sort) algorithm.\n *\n * @param arr A reference to a vector of integers that will be sorted in-place.\n *\n */\nvoid hillSort(std::vector<int>& arr) {}", "test_code": "// Helper function to check if the array is sorted\nbool isSorted(const std::vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Test cases\nTEST_CASE(\"Hill Sort\") {\n    SECTION(\"Sort an already sorted array\") {\n        std::vector<int> arr = {1, 2, 3, 4, 5};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an array in reverse order\") {\n        std::vector<int> arr = {5, 4, 3, 2, 1};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an array with duplicate values\") {\n        std::vector<int> arr = {3, 1, 2, 3, 2};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an array with all identical values\") {\n        std::vector<int> arr = {1, 1, 1, 1, 1};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an empty array\") {\n        std::vector<int> arr = {};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an array with one element\") {\n        std::vector<int> arr = {42};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort a large random array\") {\n        std::vector<int> arr = {3, 7, 2, 5, 1, 4, 6, 0, 9, 8};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Sorts a vector of integers using the Hill Sort (Shell Sort) algorithm.\n *\n * @param arr A reference to a vector of integers that will be sorted in-place.\n *\n */\nvoid hillSort(std::vector<int>& arr) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Sorts a list of integers using the Hill Sort (Shell Sort) algorithm.\n *\n * @param arr A reference to a list of integers that will be sorted in-place.\n *\n * @return void\n */\npublic static void hillSort(List<Integer> arr) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    // Helper function to check if the array is sorted\n    private boolean isSorted(List<Integer> arr) {\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testHillSort() {\n        // Test case: Sort an already sorted array\n        List<Integer> arr1 = Arrays.asList(1, 2, 3, 4, 5);\n        hillSort(arr1);\n        assertTrue(isSorted(arr1));\n\n        // Test case: Sort an array in reverse order\n        List<Integer> arr2 = Arrays.asList(5, 4, 3, 2, 1);\n        hillSort(arr2);\n        assertTrue(isSorted(arr2));\n\n        // Test case: Sort an array with duplicate values\n        List<Integer> arr3 = Arrays.asList(3, 1, 2, 3, 2);\n        hillSort(arr3);\n        assertTrue(isSorted(arr3));\n\n        // Test case: Sort an array with all identical values\n        List<Integer> arr4 = Arrays.asList(1, 1, 1, 1, 1);\n        hillSort(arr4);\n        assertTrue(isSorted(arr4));\n\n        // Test case: Sort an empty array\n        List<Integer> arr5 = Arrays.asList();\n        hillSort(arr5);\n        assertTrue(isSorted(arr5));\n\n        // Test case: Sort an array with one element\n        List<Integer> arr6 = Arrays.asList(42);\n        hillSort(arr6);\n        assertTrue(isSorted(arr6));\n\n        // Test case: Sort a large random array\n        List<Integer> arr7 = Arrays.asList(3, 7, 2, 5, 1, 4, 6, 0, 9, 8);\n        hillSort(arr7);\n        assertTrue(isSorted(arr7));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Sorts a list of integers using the Hill Sort (Shell Sort) algorithm.\n *\n * @param arr A reference to a list of integers that will be sorted in-place.\n *\n * @return void\n */\npublic static void hillSort(List<Integer> arr) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 358, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Sort the string array with the shape of \"name + number\" in ascending order. If the numbers are the same, sort by name in ascending order, and return the sorted array", "language_version_list": {"python": {"code_signature": "from rpds import List\n\n\ndef sort_names(arr: List[str]) -> List[str]:\n    \"\"\"\n    Sort a list of strings with the format \"name + number\" in ascending order.\n\n    If the numbers are the same, the strings are sorted by name in ascending order.\n\n    Args:\n        arr (list of str): A reference to the list of strings to be sorted.\n\n    Returns:\n        list of str: A list of strings sorted according to the rules described above.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    def test_sort_names_same_numbers(self):\n        arr = [\"Alice10\", \"Charlie10\", \"Bob10\"]\n        expected = [\"Alice10\", \"Bob10\", \"Charlie10\"]\n        self.assertEqual(sort_names(arr), expected)\n\n    def test_sort_names_mixed_case(self):\n        arr = [\"Alice3\", \"Bob2\", \"Charlie3\", \"Bob1\"]\n        expected = [\"Bob1\", \"Bob2\", \"Alice3\", \"Charlie3\"]\n        self.assertEqual(sort_names(arr), expected)\n\n    def test_sort_names_single_element(self):\n        arr = [\"Alice5\"]\n        expected = [\"Alice5\"]\n        self.assertEqual(sort_names(arr), expected)\n\n    def test_sort_names_empty_array(self):\n        arr = []\n        expected = []\n        self.assertEqual(sort_names(arr), expected)", "prompt": "please write a python function , the function signature as below from rpds import List\n\n\ndef sort_names(arr: List[str]) -> List[str]:\n    \"\"\"\n    Sort a list of strings with the format \"name + number\" in ascending order.\n\n    If the numbers are the same, the strings are sorted by name in ascending order.\n\n    Args:\n        arr (list of str): A reference to the list of strings to be sorted.\n\n    Returns:\n        list of str: A list of strings sorted according to the rules described above.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Sorts the string array with the shape of \"name + number\" in ascending order. \n * If the numbers are the same, sorts by name in ascending order, and returns the sorted array.\n *\n * @param {Array<string>} arr An array of strings to be sorted.\n * @return {Array<string>} A sorted array of strings according to the rules described above.\n */\nfunction sortNames(arr) {}", "test_code": "describe(\"sortNames Test Cases\", () => {\n    // Test Case 2: Same numbers, different names\n    test(\"should sort names with the same numbers in alphabetical order\", () => {\n        const arr2 = [\"Alice10\", \"Charlie10\", \"Bob10\"];\n        const expected2 = [\"Alice10\", \"Bob10\", \"Charlie10\"];\n        expect(sortNames(arr2)).toEqual(expected2);\n    });\n\n    // Test Case 3: Mixed case with different names and numbers\n    test(\"should sort mixed case names and numbers correctly\", () => {\n        const arr3 = [\"Alice3\", \"Bob2\", \"Charlie3\", \"Bob1\"];\n        const expected3 = [\"Bob1\", \"Bob2\", \"Alice3\", \"Charlie3\"];\n        expect(sortNames(arr3)).toEqual(expected3);\n    });\n\n    // Test Case 4: Single element\n    test(\"should return the same single element array\", () => {\n        const arr4 = [\"Alice5\"];\n        const expected4 = [\"Alice5\"];\n        expect(sortNames(arr4)).toEqual(expected4);\n    });\n\n    // Test Case 5: Empty array\n    test(\"should return an empty array when input is empty\", () => {\n        const arr5 = [];\n        const expected5 = [];\n        expect(sortNames(arr5)).toEqual(expected5);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Sorts the string array with the shape of \"name + number\" in ascending order. \n * If the numbers are the same, sorts by name in ascending order, and returns the sorted array.\n *\n * @param {Array<string>} arr An array of strings to be sorted.\n * @return {Array<string>} A sorted array of strings according to the rules described above.\n */\nfunction sortNames(arr) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Sorts the array of strings in the format \"name + number\" in ascending order. \n * If the numbers are the same, sorts by name in ascending order, and returns the sorted array.\n *\n * @param arr An array of strings to be sorted.\n * @return An array of strings sorted according to the rules described above.\n */\nfunction sortNames(arr: string[]): string[] {}", "test_code": "describe(\"sortNames Test Cases\", () => {\n    // Test Case 2: Same numbers, different names\n    test(\"Same numbers, different names\", () => {\n        const arr2 = [\"Alice10\", \"Charlie10\", \"Bob10\"];\n        const expected2 = [\"Alice10\", \"Bob10\", \"Charlie10\"];\n        expect(sortNames(arr2)).toEqual(expected2);\n    });\n\n    // Test Case 3: Mixed case with different names and numbers\n    test(\"Mixed case with different names and numbers\", () => {\n        const arr3 = [\"Alice3\", \"Bob2\", \"Charlie3\", \"Bob1\"];\n        const expected3 = [\"Bob1\", \"Bob2\", \"Alice3\", \"Charlie3\"];\n        expect(sortNames(arr3)).toEqual(expected3);\n    });\n\n    // Test Case 4: Single element\n    test(\"Single element\", () => {\n        const arr4 = [\"Alice5\"];\n        const expected4 = [\"Alice5\"];\n        expect(sortNames(arr4)).toEqual(expected4);\n    });\n\n    // Test Case 5: Empty array\n    test(\"Empty array\", () => {\n        const arr5: string[] = [];\n        const expected5: string[] = [];\n        expect(sortNames(arr5)).toEqual(expected5);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Sorts the array of strings in the format \"name + number\" in ascending order. \n * If the numbers are the same, sorts by name in ascending order, and returns the sorted array.\n *\n * @param arr An array of strings to be sorted.\n * @return An array of strings sorted according to the rules described above.\n */\nfunction sortNames(arr: string[]): string[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Sort the string array with the shape of \"name + number\" in ascending order. If the numbers are the same, sort by name in ascending order, and return the sorted array\n *\n * @param arr A reference to the vector of strings to be sorted.\n * @return A vector of strings sorted according to the rules described above.\n */\nvector<string> sortNames(vector<string> arr) {\n\t\n}", "test_code": "TEST_CASE(\"sortNames Test Cases\", \"[sortNames]\") {\n    // Test Case 2: Same numbers, different names\n    vector<string> arr2 = {\"Alice10\", \"Charlie10\", \"Bob10\"};\n    vector<string> expected2 = {\"Alice10\", \"Bob10\", \"Charlie10\"};\n    REQUIRE(sortNames(arr2) == expected2);\n\n    // Test Case 3: Mixed case with different names and numbers\n    vector<string> arr3 = {\"Alice3\", \"Bob2\", \"Charlie3\", \"Bob1\"};\n    vector<string> expected3 = {\"Bob1\", \"Bob2\", \"Alice3\", \"Charlie3\"};\n    REQUIRE(sortNames(arr3) == expected3);\n\n    // Test Case 4: Single element\n    vector<string> arr4 = {\"Alice5\"};\n    vector<string> expected4 = {\"Alice5\"};\n    REQUIRE(sortNames(arr4) == expected4);\n\n    // Test Case 5: Empty array\n    vector<string> arr5 = {};\n    vector<string> expected5 = {};\n    REQUIRE(sortNames(arr5) == expected5);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Sort the string array with the shape of \"name + number\" in ascending order. If the numbers are the same, sort by name in ascending order, and return the sorted array\n *\n * @param arr A reference to the vector of strings to be sorted.\n * @return A vector of strings sorted according to the rules described above.\n */\nvector<string> sortNames(vector<string> arr) {\n\t\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Sort the string array with the shape of \"name + number\" in ascending order.\n * If the numbers are the same, sort by name in ascending order, and return the sorted array.\n *\n * @param arr An array of strings to be sorted.\n * @return An array of strings sorted according to the rules described above.\n */\npublic static String[] sortNames(String[] arr) {}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\n\npublic class Tester {\n\n    @Test\n    public void testSortNames() {\n        // Test Case 2: Same numbers, different names\n        String[] arr2 = {\"Alice10\", \"Charlie10\", \"Bob10\"};\n        String[] expected2 = {\"Alice10\", \"Bob10\", \"Charlie10\"};\n        assertArrayEquals(expected2, Answer.sortNames(arr2));\n\n        // Test Case 3: Mixed case with different names and numbers\n        String[] arr3 = {\"Alice3\", \"Bob2\", \"Charlie3\", \"Bob1\"};\n        String[] expected3 = {\"Bob1\", \"Bob2\", \"Alice3\", \"Charlie3\"};\n        assertArrayEquals(expected3, Answer.sortNames(arr3));\n\n        // Test Case 4: Single element\n        String[] arr4 = {\"Alice5\"};\n        String[] expected4 = {\"Alice5\"};\n        assertArrayEquals(expected4, Answer.sortNames(arr4));\n\n        // Test Case 5: Empty array\n        String[] arr5 = {};\n        String[] expected5 = {};\n        assertArrayEquals(expected5, Answer.sortNames(arr5));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Sort the string array with the shape of \"name + number\" in ascending order.\n * If the numbers are the same, sort by name in ascending order, and return the sorted array.\n *\n * @param arr An array of strings to be sorted.\n * @return An array of strings sorted according to the rules described above.\n */\npublic static String[] sortNames(String[] arr) {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 359, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Calculate the integral approximation of a given function on a given interval [a,b] using the trapezoidal rule of numerical integration", "language_version_list": {"python": {"code_signature": "def trapezoidal_rule(func, a: float, b: float, n: int) -> float:\n    \"\"\"\n    Calculate the integral approximation of a given function on the interval [a, b] using the trapezoidal rule.\n\n    Args:\n        func (callable): The function to integrate, which takes a float and returns a float.\n        a (float): The lower bound of the integration interval.\n        b (float): The upper bound of the integration interval.\n        n (int): The number of subintervals to use in the approximation (more intervals yield higher accuracy).\n\n    Returns:\n        float: The approximate value of the integral over the interval [a, b].\n    \"\"\"", "test_code": "import math\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n    def test_constant_function(self):\n        \"\"\" Test Case 1: Integration of a constant function (f(x) = 1) over [0, 1] \"\"\"\n        self.assertAlmostEqual(trapezoidal_rule(lambda x: 1.0, 0.0, 1.0, 100), 1.0, delta=1e-6)\n\n    def test_linear_function(self):\n        \"\"\" Test Case 2: Integration of a linear function (f(x) = x) over [0, 1] \"\"\"\n        self.assertAlmostEqual(trapezoidal_rule(lambda x: x, 0.0, 1.0, 100), 0.5, delta=1e-6)\n\n    def test_quadratic_function(self):\n        \"\"\" Test Case 3: Integration of a quadratic function (f(x) = x^2) over [0, 1] \"\"\"\n        self.assertAlmostEqual(trapezoidal_rule(lambda x: x * x, 0.0, 1.0, 1000), 1.0 / 3.0, delta=1e-6)\n\n    def test_sine_function(self):\n        \"\"\" Test Case 4: Integration of the sine function (f(x) = sin(x)) over [0, \u03c0] \"\"\"\n        self.assertAlmostEqual(trapezoidal_rule(lambda x: math.sin(x), 0.0, math.pi, 1000), 1.9999, delta=1e-3)\n\n    def test_exponential_function(self):\n        \"\"\" Test Case 5: Integration of an exponential function (f(x) = exp(x)) over [0, 1] \"\"\"\n        self.assertAlmostEqual(trapezoidal_rule(lambda x: math.exp(x), 0.0, 1.0, 1000), math.exp(1.0) - 1.0, delta=1e-6)\n", "prompt": "please write a python function , the function signature as below def trapezoidal_rule(func, a: float, b: float, n: int) -> float:\n    \"\"\"\n    Calculate the integral approximation of a given function on the interval [a, b] using the trapezoidal rule.\n\n    Args:\n        func (callable): The function to integrate, which takes a float and returns a float.\n        a (float): The lower bound of the integration interval.\n        b (float): The upper bound of the integration interval.\n        n (int): The number of subintervals to use in the approximation (more intervals yield higher accuracy).\n\n    Returns:\n        float: The approximate value of the integral over the interval [a, b].\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the integral approximation of a given function on a given interval [a,b] using the trapezoidal rule of numerical integration\n *\n * @param func The function to integrate, represented as a std::function<double(double)>.\n * @param a The lower bound of the integration interval.\n * @param b The upper bound of the integration interval.\n * @param n The number of subintervals to use in the approximation (more intervals yield higher accuracy).\n * @return The approximate value of the integral over the interval [a, b].\n */\ndouble trapezoidal_rule(const std::function<double(double)>& func, double a, double b, int n) {\n\t\n}", "test_code": "TEST_CASE(\"TrapezoidalRule Test Cases\", \"[trapezoidal_rule]\") {\n    // Test Case 1: Integration of a constant function (f(x) = 1) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return 1.0; }, 0.0, 1.0, 100) == Approx(1.0).epsilon(1e-6));\n\n    // Test Case 2: Integration of a linear function (f(x) = x) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return x; }, 0.0, 1.0, 100) == Approx(0.5).epsilon(1e-6));\n\n    // Test Case 3: Integration of a quadratic function (f(x) = x^2) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return x * x; }, 0.0, 1.0, 1000) == Approx(1.0 / 3.0).epsilon(1e-6));\n\n    // Test Case 4: Integration of the sine function (f(x) = sin(x)) over [0, \u03c0]\n    REQUIRE(trapezoidal_rule([](double x) { return std::sin(x); }, 0.0, M_PI, 1000) == Approx(2.0).epsilon(1e-6));\n\n    // Test Case 5: Integration of an exponential function (f(x) = exp(x)) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return std::exp(x); }, 0.0, 1.0, 1000) == Approx(std::exp(1.0) - 1.0).epsilon(1e-6));\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the integral approximation of a given function on a given interval [a,b] using the trapezoidal rule of numerical integration\n *\n * @param func The function to integrate, represented as a std::function<double(double)>.\n * @param a The lower bound of the integration interval.\n * @param b The upper bound of the integration interval.\n * @param n The number of subintervals to use in the approximation (more intervals yield higher accuracy).\n * @return The approximate value of the integral over the interval [a, b].\n */\ndouble trapezoidal_rule(const std::function<double(double)>& func, double a, double b, int n) {\n\t\n}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 360, "code_type": "method", "original_language": "c&cpp", "question_type": "Data processing and transformation", "summary": "Extracts the last part of a complete file path with the help of a path separator and returns it, or the original string if no separator is found", "language_version_list": {"python": {"code_signature": "def get_last_part_of_filepath(file_path: str) -> str:\n    \"\"\"\n    Extract the last part of a complete file path using a separator.\n\n    If no separator is found, the original string is returned.\n\n    Args:\n        file_path (str): The complete file path as a string.\n\n    Returns:\n        str: The last part of the file path after the last separator, or the original string if no separator is found.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    def test_get_last_part_of_filepath_unix_style(self):\n        self.assertEqual(get_last_part_of_filepath(\"/home/user/documents/file.txt\"), \"file.txt\")\n\n    def test_get_last_part_of_filepath_windows_style(self):\n        self.assertEqual(get_last_part_of_filepath(\"C:\\\\Users\\\\JohnDoe\\\\Documents\\\\file.txt\"), \"file.txt\")\n\n    def test_get_last_part_of_filepath_no_separators(self):\n        self.assertEqual(get_last_part_of_filepath(\"file.txt\"), \"file.txt\")\n\n    def test_get_last_part_of_filepath_ending_with_separator(self):\n        self.assertEqual(get_last_part_of_filepath(\"/home/user/documents/\"), \"\")\n\n    def test_get_last_part_of_filepath_mixed_separators(self):\n        self.assertEqual(get_last_part_of_filepath(\"C:/Users\\\\JohnDoe/Documents/file.txt\"), \"file.txt\")\n", "prompt": "please write a python function , the function signature as below def get_last_part_of_filepath(file_path: str) -> str:\n    \"\"\"\n    Extract the last part of a complete file path using a separator.\n\n    If no separator is found, the original string is returned.\n\n    Args:\n        file_path (str): The complete file path as a string.\n\n    Returns:\n        str: The last part of the file path after the last separator, or the original string if no separator is found.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extracts the last part of a complete file path with the help of a separator and returns it, or the original string if no separator is found\n *\n * @param filePath The complete file path as a string.\n * @return The last part of the file path after the last separator, or the original string if no separator is found.\n */\nstd::string getLastPartOfFilepath(const std::string& filePath) {\n\t\n}", "test_code": "TEST_CASE(\"getLastPartOfFilepath Test Cases\", \"[getLastPartOfFilepath]\") {\n    // Test Case 1: Unix-style path with '/'\n    REQUIRE(getLastPartOfFilepath(\"/home/user/documents/file.txt\") == \"file.txt\");\n\n    // Test Case 2: Windows-style path with '\\\\'\n    REQUIRE(getLastPartOfFilepath(\"C:\\\\Users\\\\JohnDoe\\\\Documents\\\\file.txt\") == \"file.txt\");\n\n    // Test Case 3: Path without any separators (should return the original string)\n    REQUIRE(getLastPartOfFilepath(\"file.txt\") == \"file.txt\");\n\n    // Test Case 4: Path ending with a separator (should return an empty string)\n    REQUIRE(getLastPartOfFilepath(\"/home/user/documents/\") == \"\");\n\n    // Test Case 5: Path with mixed separators (should return the last part after the last separator)\n    REQUIRE(getLastPartOfFilepath(\"C:/Users\\\\JohnDoe/Documents/file.txt\") == \"file.txt\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts the last part of a complete file path with the help of a separator and returns it, or the original string if no separator is found\n *\n * @param filePath The complete file path as a string.\n * @return The last part of the file path after the last separator, or the original string if no separator is found.\n */\nstd::string getLastPartOfFilepath(const std::string& filePath) {\n\t\n}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 361, "code_type": "method", "original_language": "c&cpp", "question_type": "Scientific computation and numerical analysis", "summary": "Computes the approximate integral of a function using Simpson's Rule.", "language_version_list": {"python": {"code_signature": "def simpsons_rule(a: float, b: float, n: int) -> float:\n    \"\"\"\n    Computes the approximate integral of a function using Simpson's Rule.\n\n    Simpson's Rule is a method for numerical integration that approximates the integral of a function\n    over an interval by fitting parabolas. This function divides the interval [a, b] into n subintervals\n    and calculates the weighted sum of the function values at specific points.\n\n    Args:\n        a (float): The lower limit of integration.\n        b (float): The upper limit of integration.\n        n (int): The number of subintervals (must be even).\n\n    Returns:\n        float: The approximate value of the integral.\n\n    Raises:\n        ValueError: If n is not positive or if it is not even.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    \"\"\"Tests for Simpson's Rule implementation.\"\"\"\n\n    def test_basic_integral_0_to_1(self):\n        \"\"\"Test the integral of f(x) = x^2 from 0 to 1.\"\"\"\n        # The exact integral of f(x) = x^2 from 0 to 1 is 1/3\n        result = simpsons_rule(0.0, 1.0, 10)\n        self.assertAlmostEqual(result, 1.0 / 3.0, delta=0.01)\n\n    def test_basic_integral_0_to_2(self):\n        \"\"\"Test the integral of f(x) = x^2 from 0 to 2.\"\"\"\n        # The exact integral of f(x) = x^2 from 0 to 2 is 8/3\n        result = simpsons_rule(0.0, 2.0, 10)\n        self.assertAlmostEqual(result, 8.0 / 3.0, delta=0.01)\n\n    def test_negative_integral_minus1_to_0(self):\n        \"\"\"Test the integral of f(x) = x^2 from -1 to 0.\"\"\"\n        # The exact integral of f(x) = x^2 from -1 to 0 is 1/3\n        result = simpsons_rule(-1.0, 0.0, 10)\n        self.assertAlmostEqual(result, 1.0 / 3.0, delta=0.01)\n\n    def test_large_interval_0_to_10(self):\n        \"\"\"Test the integral of f(x) = x^2 from 0 to 10.\"\"\"\n        # The exact integral from 0 to 10 of f(x) = x^2 is (10^3)/3 = 1000/3\n        result = simpsons_rule(0.0, 10.0, 20)\n        self.assertAlmostEqual(result, 1000.0 / 3.0, delta=0.01)\n", "prompt": "please write a python function , the function signature as below def simpsons_rule(a: float, b: float, n: int) -> float:\n    \"\"\"\n    Computes the approximate integral of a function using Simpson's Rule.\n\n    Simpson's Rule is a method for numerical integration that approximates the integral of a function\n    over an interval by fitting parabolas. This function divides the interval [a, b] into n subintervals\n    and calculates the weighted sum of the function values at specific points.\n\n    Args:\n        a (float): The lower limit of integration.\n        b (float): The upper limit of integration.\n        n (int): The number of subintervals (must be even).\n\n    Returns:\n        float: The approximate value of the integral.\n\n    Raises:\n        ValueError: If n is not positive or if it is not even.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Computes the approximate integral of a function using Simpson's Rule.\n *\n * Simpson's Rule is a method for numerical integration that approximates the integral of a function\n * over an interval by fitting parabolas. This function divides the interval [a, b] into n subintervals\n * and calculates the weighted sum of the function values at specific points.\n *\n * @param a The lower limit of integration.\n * @param b The upper limit of integration.\n * @param n The number of subintervals (must be even).\n * @return The approximate value of the integral.\n *\n * @throws std::invalid_argument If n is not positive or if it is not even.\n */\ndouble simpsons_rule(double a, double b, int n) {}", "test_code": "TEST_CASE(\"Simpson's Rule Tests\") {\n\n    SECTION(\"Basic Integral of x^2 from 0 to 1\") {\n        // The exact integral of f(x) = x^2 from 0 to 1 is 1/3\n        double result = simpsons_rule(0.0, 1.0, 10);\n        REQUIRE(result == Approx(1.0 / 3.0).epsilon(0.01));\n    }\n\n    SECTION(\"Basic Integral of x^2 from 0 to 2\") {\n        // The exact integral of f(x) = x^2 from 0 to 2 is 8/3\n        double result = simpsons_rule(0.0, 2.0, 10);\n        REQUIRE(result == Approx(8.0 / 3.0).epsilon(0.01));\n    }\n\n    SECTION(\"Negative Integral of x^2 from -1 to 0\") {\n        // The exact integral of f(x) = x^2 from -1 to 0 is 1/3\n        double result = simpsons_rule(-1.0, 0.0, 10);\n        REQUIRE(result == Approx(1.0 / 3.0).epsilon(0.01));\n    }\n\n    SECTION(\"Large Interval\") {\n        // Test with a larger interval from 0 to 10\n        double result = simpsons_rule(0.0, 10.0, 20);\n        // The exact integral from 0 to 10 of f(x) = x^2 is (10^3)/3 = 1000/3\n        REQUIRE(result == Approx(1000.0 / 3.0).epsilon(0.01));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Computes the approximate integral of a function using Simpson's Rule.\n *\n * Simpson's Rule is a method for numerical integration that approximates the integral of a function\n * over an interval by fitting parabolas. This function divides the interval [a, b] into n subintervals\n * and calculates the weighted sum of the function values at specific points.\n *\n * @param a The lower limit of integration.\n * @param b The upper limit of integration.\n * @param n The number of subintervals (must be even).\n * @return The approximate value of the integral.\n *\n * @throws std::invalid_argument If n is not positive or if it is not even.\n */\ndouble simpsons_rule(double a, double b, int n) {}", "addition_info": "double f(double x) {\n    return x * x;\n}"}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 365, "code_type": "method", "original_language": "c&cpp", "question_type": "Data processing and transformation", "summary": "calculate the day of the week the given date (year, month, day) is (Monday is represented by 1, Tuesday is represented by 2, and so on)\n", "language_version_list": {"python": {"code_signature": "def day_of_week(year: int, month: int, day: int) -> int:\n    \"\"\"\n    Calculates the day of the week for a given date.\n\n    Args:\n        year (int): The year of the date (e.g., 2024).\n        month (int): The month of the date (1 = January, 2 = February, ..., 12 = December).\n        day (int): The day of the month (1 to 31, depending on the month).\n\n    Returns:\n        int: An integer representing the day of the week:\n            - 1 for Monday\n            - 2 for Tuesday\n            - 3 for Wednesday\n            - 4 for Thursday\n            - 5 for Friday\n            - 6 for Saturday\n            - 7 for Sunday\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    \"\"\"Unit tests for the day_of_week function.\"\"\"\n\n    def test_day_of_week_2024(self):\n        \"\"\"Test case for January 1, 2024.\"\"\"\n        self.assertEqual(day_of_week(2024, 1, 1), 1)  # January 1, 2024 is a Monday\n\n    def test_day_of_week_2023(self):\n        \"\"\"Test case for August 29, 2023.\"\"\"\n        self.assertEqual(day_of_week(2023, 8, 29), 2)  # August 29, 2023 is a Tuesday\n\n    def test_day_of_week_2022(self):\n        \"\"\"Test case for December 25, 2022.\"\"\"\n        self.assertEqual(day_of_week(2022, 12, 25), 7) # December 25, 2022 is a Sunday\n\n    def test_day_of_week_1989(self):\n        \"\"\"Test case for November 9, 1989.\"\"\"\n        self.assertEqual(day_of_week(1989, 11, 9), 4)  # November 9, 1989 is a Thursday\n\n    def test_day_of_week_2000(self):\n        \"\"\"Test case for February 29, 2000.\"\"\"\n        self.assertEqual(day_of_week(2000, 2, 29), 2)  # February 29, 2000 is a Tuesday", "prompt": "please write a python function , the function signature as below def day_of_week(year: int, month: int, day: int) -> int:\n    \"\"\"\n    Calculates the day of the week for a given date.\n\n    Args:\n        year (int): The year of the date (e.g., 2024).\n        month (int): The month of the date (1 = January, 2 = February, ..., 12 = December).\n        day (int): The day of the month (1 to 31, depending on the month).\n\n    Returns:\n        int: An integer representing the day of the week:\n            - 1 for Monday\n            - 2 for Tuesday\n            - 3 for Wednesday\n            - 4 for Thursday\n            - 5 for Friday\n            - 6 for Saturday\n            - 7 for Sunday\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculates the day of the week for a given date.\n *\n * @param {number} year The year of the date (e.g., 2024).\n * @param {number} month The month of the date (1 = January, 2 = February, ..., 12 = December).\n * @param {number} day The day of the month (1 to 31, depending on the month).\n * \n * @return {number} An integer representing the day of the week:\n *         - 1 for Monday\n *         - 2 for Tuesday\n *         - 3 for Wednesday\n *         - 4 for Thursday\n *         - 5 for Friday\n *         - 6 for Saturday\n *         - 7 for Sunday\n */\nfunction dayOfWeek(year, month, day) {}", "test_code": "describe(\"Day of Week Calculation\", () => {\n    test(\"January 1, 2024 is a Monday\", () => {\n        expect(dayOfWeek(2024, 1, 1)).toBe(1);\n    });\n\n    test(\"August 29, 2023 is a Tuesday\", () => {\n        expect(dayOfWeek(2023, 8, 29)).toBe(2);\n    });\n\n    test(\"December 25, 2022 is a Sunday\", () => {\n        expect(dayOfWeek(2022, 12, 25)).toBe(7);\n    });\n\n    test(\"November 9, 1989 is a Thursday\", () => {\n        expect(dayOfWeek(1989, 11, 9)).toBe(4);\n    });\n\n    test(\"February 29, 2000 is a Tuesday\", () => {\n        expect(dayOfWeek(2000, 2, 29)).toBe(2);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the day of the week for a given date.\n *\n * @param {number} year The year of the date (e.g., 2024).\n * @param {number} month The month of the date (1 = January, 2 = February, ..., 12 = December).\n * @param {number} day The day of the month (1 to 31, depending on the month).\n * \n * @return {number} An integer representing the day of the week:\n *         - 1 for Monday\n *         - 2 for Tuesday\n *         - 3 for Wednesday\n *         - 4 for Thursday\n *         - 5 for Friday\n *         - 6 for Saturday\n *         - 7 for Sunday\n */\nfunction dayOfWeek(year, month, day) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the day of the week for a given date.\n *\n * @param year The year of the date (e.g., 2024).\n * @param month The month of the date (1 = January, 2 = February, ..., 12 = December).\n * @param day The day of the month (1 to 31, depending on the month).\n * \n * @return An integer representing the day of the week:\n *         - 1 for Monday\n *         - 2 for Tuesday\n *         - 3 for Wednesday\n *         - 4 for Thursday\n *         - 5 for Friday\n *         - 6 for Saturday\n *         - 7 for Sunday\n */\nfunction dayOfWeek(year: number, month: number, day: number): number {}", "test_code": "describe('Day of Week Calculation', () => {\n    test('January 1, 2024 is a Monday', () => {\n        expect(dayOfWeek(2024, 1, 1)).toBe(1);\n    });\n\n    test('August 29, 2023 is a Tuesday', () => {\n        expect(dayOfWeek(2023, 8, 29)).toBe(2);\n    });\n\n    test('December 25, 2022 is a Sunday', () => {\n        expect(dayOfWeek(2022, 12, 25)).toBe(7);\n    });\n\n    test('November 9, 1989 is a Thursday', () => {\n        expect(dayOfWeek(1989, 11, 9)).toBe(4);\n    });\n\n    test('February 29, 2000 is a Tuesday', () => {\n        expect(dayOfWeek(2000, 2, 29)).toBe(2);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the day of the week for a given date.\n *\n * @param year The year of the date (e.g., 2024).\n * @param month The month of the date (1 = January, 2 = February, ..., 12 = December).\n * @param day The day of the month (1 to 31, depending on the month).\n * \n * @return An integer representing the day of the week:\n *         - 1 for Monday\n *         - 2 for Tuesday\n *         - 3 for Wednesday\n *         - 4 for Thursday\n *         - 5 for Friday\n *         - 6 for Saturday\n *         - 7 for Sunday\n */\nfunction dayOfWeek(year: number, month: number, day: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculates the day of the week for a given date.\n *\n * @param year The year of the date (e.g., 2024).\n * @param month The month of the date (1 = January, 2 = February, ..., 12 = December).\n * @param day The day of the month (1 to 31, depending on the month).\n * \n * @return An integer representing the day of the week:\n *         - 1 for Monday\n *         - 2 for Tuesday\n *         - 3 for Wednesday\n *         - 4 for Thursday\n *         - 5 for Friday\n *         - 6 for Saturday\n *         - 7 for Sunday\n */\nint day_of_week(int year, int month, int day) {}", "test_code": "TEST_CASE(\"Day of Week Calculation\", \"[day_of_week]\") {\n    REQUIRE(day_of_week(2024, 1, 1) == 1);  // January 1, 2024 is a Monday\n    REQUIRE(day_of_week(2023, 8, 29) == 2);  // August 29, 2023 is a Tuesday\n    REQUIRE(day_of_week(2022, 12, 25) == 7); // December 25, 2022 is a Sunday\n    REQUIRE(day_of_week(1989, 11, 9) == 4);  // November 9, 1989 is a Thursday\n    REQUIRE(day_of_week(2000, 2, 29) == 2);  // February 29, 2000 is a Tuesday\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculates the day of the week for a given date.\n *\n * @param year The year of the date (e.g., 2024).\n * @param month The month of the date (1 = January, 2 = February, ..., 12 = December).\n * @param day The day of the month (1 to 31, depending on the month).\n * \n * @return An integer representing the day of the week:\n *         - 1 for Monday\n *         - 2 for Tuesday\n *         - 3 for Wednesday\n *         - 4 for Thursday\n *         - 5 for Friday\n *         - 6 for Saturday\n *         - 7 for Sunday\n */\nint day_of_week(int year, int month, int day) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the day of the week for a given date.\n *\n * @param year The year of the date (e.g., 2024).\n * @param month The month of the date (1 = January, 2 = February, ..., 12 = December).\n * @param day The day of the month (1 to 31, depending on the month).\n * \n * @return An integer representing the day of the week:\n *         - 1 for Monday\n *         - 2 for Tuesday\n *         - 3 for Wednesday\n *         - 4 for Thursday\n *         - 5 for Friday\n *         - 6 for Saturday\n *         - 7 for Sunday\n */\npublic static int dayOfWeek(int year, int month, int day) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testDayOfWeekCalculation() {\n        // January 1, 2024 is a Monday\n        assertEquals(1, Answer.dayOfWeek(2024, 1, 1));\n        \n        // August 29, 2023 is a Tuesday\n        assertEquals(2, Answer.dayOfWeek(2023, 8, 29));\n        \n        // December 25, 2022 is a Sunday\n        assertEquals(7, Answer.dayOfWeek(2022, 12, 25));\n        \n        // November 9, 1989 is a Thursday\n        assertEquals(4, Answer.dayOfWeek(1989, 11, 9));\n        \n        // February 29, 2000 is a Tuesday\n        assertEquals(2, Answer.dayOfWeek(2000, 2, 29));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the day of the week for a given date.\n *\n * @param year The year of the date (e.g., 2024).\n * @param month The month of the date (1 = January, 2 = February, ..., 12 = December).\n * @param day The day of the month (1 to 31, depending on the month).\n * \n * @return An integer representing the day of the week:\n *         - 1 for Monday\n *         - 2 for Tuesday\n *         - 3 for Wednesday\n *         - 4 for Thursday\n *         - 5 for Friday\n *         - 6 for Saturday\n *         - 7 for Sunday\n */\npublic static int dayOfWeek(int year, int month, int day) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 481, "code_type": "method", "original_language": "c&cpp", "question_type": "User interface", "summary": "Prints a 3x3 game board to the console.", "language_version_list": {"python": {"code_signature": "def print_board(board):\n    \"\"\"Prints a 3x3 game board to the console.\n\n    This function takes a 2D list representing a game board and prints\n    it in a formatted manner, displaying the contents of each cell.\n    The board is assumed to be a square of size 3x3, and each cell can\n    contain either a character representing a player's move ('X' or 'O')\n    or an empty space (' ').\n\n    The output format includes a row of dashes to separate the rows of\n    the board, and each cell is enclosed within vertical bars.\n    The function does not return any value.\n\n    Args:\n        board (list[list[str]]): A 2D list of characters, where each character represents\n                                  the state of a cell in the game board. The board must be\n                                  of size 3x3, and each character can be 'X', 'O', or ' '.\n                                  For example:\n                                  input: [['X', 'O', 'X'],\n                                          [' ', 'X', 'O'],\n                                          ['O', ' ', ' ']]\n                                  output: -------------\n                                          | X | O | X |\n                                          -------------\n                                          |   | X | O |\n                                          -------------\n                                          | O |   |   |\n                                          -------------\n    \"\"\"", "test_code": "import io\nimport sys\nimport unittest\n\n\nclass TestPrintBoard(unittest.TestCase):\n    def setUp(self):\n        # Prepare the board data for the test cases\n        self.board1 = [['X', 'O', 'X'], [' ', 'X', 'O'], ['O', ' ', ' ']]\n        self.board2 = [[' ', ' ', ' '], [' ', ' ', ' '], [' ', ' ', ' ']]\n        self.board3 = [['X', 'X', 'X'], ['O', 'O', ' '], [' ', ' ', ' ']]\n        self.board4 = [['O', 'O', 'O'], ['X', 'X', 'X'], ['X', 'O', ' ']]\n        self.board5 = [['X', ' ', ' '], [' ', 'X', ' '], [' ', ' ', 'X']]\n        self.board6 = [[' ', 'O', ' '], ['O', ' ', 'O'], [' ', 'O', ' ']]\n\n    def test_case_1(self):\n        expected_output = (\"-------------\\n\"\n                           \"| X | O | X | \\n\"\n                           \"-------------\\n\"\n                           \"|   | X | O | \\n\"\n                           \"-------------\\n\"\n                           \"| O |   |   | \\n\"\n                           \"-------------\\n\")\n        output = self._capture_print_output(print_board, self.board1)\n        self.assertEqual(output, expected_output)\n\n    def test_case_2(self):\n        expected_output = (\"-------------\\n\"\n                           \"|   |   |   | \\n\"\n                           \"-------------\\n\"\n                           \"|   |   |   | \\n\"\n                           \"-------------\\n\"\n                           \"|   |   |   | \\n\"\n                           \"-------------\\n\")\n        output = self._capture_print_output(print_board, self.board2)\n        self.assertEqual(output, expected_output)\n\n    def test_case_3(self):\n        expected_output = (\"-------------\\n\"\n                           \"| X | X | X | \\n\"\n                           \"-------------\\n\"\n                           \"| O | O |   | \\n\"\n                           \"-------------\\n\"\n                           \"|   |   |   | \\n\"\n                           \"-------------\\n\")\n        output = self._capture_print_output(print_board, self.board3)\n        self.assertEqual(output, expected_output)\n\n    def test_case_4(self):\n        expected_output = (\"-------------\\n\"\n                           \"| O | O | O | \\n\"\n                           \"-------------\\n\"\n                           \"| X | X | X | \\n\"\n                           \"-------------\\n\"\n                           \"| X | O |   | \\n\"\n                           \"-------------\\n\")\n        output = self._capture_print_output(print_board, self.board4)\n        self.assertEqual(output, expected_output)\n\n    def test_case_5(self):\n        expected_output = (\"-------------\\n\"\n                           \"| X |   |   | \\n\"\n                           \"-------------\\n\"\n                           \"|   | X |   | \\n\"\n                           \"-------------\\n\"\n                           \"|   |   | X | \\n\"\n                           \"-------------\\n\")\n        output = self._capture_print_output(print_board, self.board5)\n        self.assertEqual(output, expected_output)\n\n    def test_case_6(self):\n        expected_output = (\"-------------\\n\"\n                           \"|   | O |   | \\n\"\n                           \"-------------\\n\"\n                           \"| O |   | O | \\n\"\n                           \"-------------\\n\"\n                           \"|   | O |   | \\n\"\n                           \"-------------\\n\")\n        output = self._capture_print_output(print_board, self.board6)\n        self.assertEqual(output, expected_output)\n\n    def _capture_print_output(self, func, *args, **kwargs):\n        \"\"\"\n        Helper function to capture print output from a function.\n        \"\"\"\n        captured_output = io.StringIO()          # Create StringIO object\n        sys.stdout = captured_output             # Redirect stdout\n        func(*args, **kwargs)                    # Call the function\n        sys.stdout = sys.__stdout__              # Reset redirect\n        return captured_output.getvalue()        # Get the output as a string", "prompt": "please write a python function , the function signature as below def print_board(board):\n    \"\"\"Prints a 3x3 game board to the console.\n\n    This function takes a 2D list representing a game board and prints\n    it in a formatted manner, displaying the contents of each cell.\n    The board is assumed to be a square of size 3x3, and each cell can\n    contain either a character representing a player's move ('X' or 'O')\n    or an empty space (' ').\n\n    The output format includes a row of dashes to separate the rows of\n    the board, and each cell is enclosed within vertical bars.\n    The function does not return any value.\n\n    Args:\n        board (list[list[str]]): A 2D list of characters, where each character represents\n                                  the state of a cell in the game board. The board must be\n                                  of size 3x3, and each character can be 'X', 'O', or ' '.\n                                  For example:\n                                  input: [['X', 'O', 'X'],\n                                          [' ', 'X', 'O'],\n                                          ['O', ' ', ' ']]\n                                  output: -------------\n                                          | X | O | X |\n                                          -------------\n                                          |   | X | O |\n                                          -------------\n                                          | O |   |   |\n                                          -------------\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Prints a 3x3 game board to the console.\n *\n * This function takes a 2D array representing a game board and prints\n * it in a formatted manner, displaying the contents of each cell.\n * The board is assumed to be a square of size 3x3, and each cell can\n * contain either a character representing a player's move ('X' or 'O')\n * or an empty space (' ').\n *\n * The output format includes a row of dashes to separate the rows of\n * the board, and each cell is enclosed within vertical bars.\n * The function does not return any value.\n *\n * @param {Array<Array<string>>} board A 2D array of characters, where each character represents\n *              the state of a cell in the game board. The board must be\n *              of size 3x3, and each character can be 'X', 'O', or ' '.\n * For example:\n *      input: [['X', 'O', 'X'],\n *              [' ', 'X', 'O'],\n *              ['O', ' ', ' ']]\n *      output: -------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\n */\nfunction printBoard(board) {}", "test_code": "describe(\"printBoard outputs correct format\", () => {\n    const board1 = [\n        ['X', 'O', 'X'],\n        [' ', 'X', 'O'],\n        ['O', ' ', ' ']\n    ];\n\n    const board2 = [\n        [' ', ' ', ' '],\n        [' ', ' ', ' '],\n        [' ', ' ', ' ']\n    ];\n\n    const board3 = [\n        ['X', 'X', 'X'],\n        ['O', 'O', ' '],\n        [' ', ' ', ' ']\n    ];\n\n    const board4 = [\n        ['O', 'O', 'O'],\n        ['X', 'X', 'X'],\n        ['X', 'O', ' ']\n    ];\n\n    const board5 = [\n        ['X', ' ', ' '],\n        [' ', 'X', ' '],\n        [' ', ' ', 'X']\n    ];\n\n    const board6 = [\n        [' ', 'O', ' '],\n        ['O', ' ', 'O'],\n        [' ', 'O', ' ']\n    ];\n\n    // Helper function to capture console output\n    function captureOutput(fn, ...args) {\n        const originalLog = console.log;\n        let output = '';\n        console.log = (msg) => {\n            output += msg + '\\n';\n        };\n        fn(...args);\n        console.log = originalLog;\n        return output;\n    }\n\n    test(\"Test case 1\", () => {\n        const expectedOutput = \"-------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\";\n        const output = captureOutput(printBoard, board1);\n        expect(output).toBe(expectedOutput);\n    });\n\n    test(\"Test case 2\", () => {\n        const expectedOutput = \"-------------\\n|   |   |   | \\n-------------\\n|   |   |   | \\n-------------\\n|   |   |   | \\n-------------\\n\";\n        const output = captureOutput(printBoard, board2);\n        expect(output).toBe(expectedOutput);\n    });\n\n    test(\"Test case 3\", () => {\n        const expectedOutput = \"-------------\\n| X | X | X | \\n-------------\\n| O | O |   | \\n-------------\\n|   |   |   | \\n-------------\\n\";\n        const output = captureOutput(printBoard, board3);\n        expect(output).toBe(expectedOutput);\n    });\n\n    test(\"Test case 4\", () => {\n        const expectedOutput = \"-------------\\n| O | O | O | \\n-------------\\n| X | X | X | \\n-------------\\n| X | O |   | \\n-------------\\n\";\n        const output = captureOutput(printBoard, board4);\n        expect(output).toBe(expectedOutput);\n    });\n\n    test(\"Test case 5\", () => {\n        const expectedOutput = \"-------------\\n| X |   |   | \\n-------------\\n|   | X |   | \\n-------------\\n|   |   | X | \\n-------------\\n\";\n        const output = captureOutput(printBoard, board5);\n        expect(output).toBe(expectedOutput);\n    });\n\n    test(\"Test case 6\", () => {\n        const expectedOutput = \"-------------\\n|   | O |   | \\n-------------\\n| O |   | O | \\n-------------\\n|   | O |   | \\n-------------\\n\";\n        const output = captureOutput(printBoard, board6);\n        expect(output).toBe(expectedOutput);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Prints a 3x3 game board to the console.\n *\n * This function takes a 2D array representing a game board and prints\n * it in a formatted manner, displaying the contents of each cell.\n * The board is assumed to be a square of size 3x3, and each cell can\n * contain either a character representing a player's move ('X' or 'O')\n * or an empty space (' ').\n *\n * The output format includes a row of dashes to separate the rows of\n * the board, and each cell is enclosed within vertical bars.\n * The function does not return any value.\n *\n * @param {Array<Array<string>>} board A 2D array of characters, where each character represents\n *              the state of a cell in the game board. The board must be\n *              of size 3x3, and each character can be 'X', 'O', or ' '.\n * For example:\n *      input: [['X', 'O', 'X'],\n *              [' ', 'X', 'O'],\n *              ['O', ' ', ' ']]\n *      output: -------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\n */\nfunction printBoard(board) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Prints a 3x3 game board to the console.\n *\n * This function takes a 2D array representing a game board and prints\n * it in a formatted manner, displaying the contents of each cell.\n * The board is assumed to be a square of size 3x3, and each cell can\n * contain either a character representing a player's move ('X' or 'O')\n * or an empty space (' ').\n *\n * The output format includes a row of dashes to separate the rows of\n * the board, and each cell is enclosed within vertical bars.\n * The function does not return any value.\n *\n * @param board A 2D array of strings, where each string represents\n *              the state of a cell in the game board. The board must be\n *              of size 3x3, and each string can be 'X', 'O', or ' '.\n * For example:\n *      input: [['X', 'O', 'X'],\n *              [' ', 'X', 'O'],\n *              ['O', ' ', ' ']]\n *      output: -------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\n */\nfunction printBoard(board: string[][]): void {}", "test_code": "describe(\"printBoard outputs correct format\", () => {\n    const board1: string[][] = [\n        ['X', 'O', 'X'],\n        [' ', 'X', 'O'],\n        ['O', ' ', ' ']\n    ];\n\n    const board2: string[][] = [\n        [' ', ' ', ' '],\n        [' ', ' ', ' '],\n        [' ', ' ', ' ']\n    ];\n\n    const board3: string[][] = [\n        ['X', 'X', 'X'],\n        ['O', 'O', ' '],\n        [' ', ' ', ' ']\n    ];\n\n    const board4: string[][] = [\n        ['O', 'O', 'O'],\n        ['X', 'X', 'X'],\n        ['X', 'O', ' ']\n    ];\n\n    const board5: string[][] = [\n        ['X', ' ', ' '],\n        [' ', 'X', ' '],\n        [' ', ' ', 'X']\n    ];\n\n    const board6: string[][] = [\n        [' ', 'O', ' '],\n        ['O', ' ', 'O'],\n        [' ', 'O', ' ']\n    ];\n\n    const expectedOutputs = {\n        board1: \"-------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\",\n        board2: \"-------------\\n|   |   |   | \\n-------------\\n|   |   |   | \\n-------------\\n|   |   |   | \\n-------------\\n\",\n        board3: \"-------------\\n| X | X | X | \\n-------------\\n| O | O |   | \\n-------------\\n|   |   |   | \\n-------------\\n\",\n        board4: \"-------------\\n| O | O | O | \\n-------------\\n| X | X | X | \\n-------------\\n| X | O |   | \\n-------------\\n\",\n        board5: \"-------------\\n| X |   |   | \\n-------------\\n|   | X |   | \\n-------------\\n|   |   | X | \\n-------------\\n\",\n        board6: \"-------------\\n|   | O |   | \\n-------------\\n| O |   | O | \\n-------------\\n|   | O |   | \\n-------------\\n\"\n    };\n\n    const captureConsoleOutput = (fn: () => void): string => {\n        const originalLog = console.log;\n        let output = '';\n        console.log = (...args: any[]) => { output += args.join(' ') + '\\n'; };\n        \n        fn();\n\n        console.log = originalLog; // Restore original console.log\n        return output;\n    };\n\n    test(\"Test case 1\", () => {\n        const output = captureConsoleOutput(() => printBoard(board1));\n        expect(output).toBe(expectedOutputs.board1);\n    });\n\n    test(\"Test case 2\", () => {\n        const output = captureConsoleOutput(() => printBoard(board2));\n        expect(output).toBe(expectedOutputs.board2);\n    });\n\n    test(\"Test case 3\", () => {\n        const output = captureConsoleOutput(() => printBoard(board3));\n        expect(output).toBe(expectedOutputs.board3);\n    });\n\n    test(\"Test case 4\", () => {\n        const output = captureConsoleOutput(() => printBoard(board4));\n        expect(output).toBe(expectedOutputs.board4);\n    });\n\n    test(\"Test case 5\", () => {\n        const output = captureConsoleOutput(() => printBoard(board5));\n        expect(output).toBe(expectedOutputs.board5);\n    });\n\n    test(\"Test case 6\", () => {\n        const output = captureConsoleOutput(() => printBoard(board6));\n        expect(output).toBe(expectedOutputs.board6);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Prints a 3x3 game board to the console.\n *\n * This function takes a 2D array representing a game board and prints\n * it in a formatted manner, displaying the contents of each cell.\n * The board is assumed to be a square of size 3x3, and each cell can\n * contain either a character representing a player's move ('X' or 'O')\n * or an empty space (' ').\n *\n * The output format includes a row of dashes to separate the rows of\n * the board, and each cell is enclosed within vertical bars.\n * The function does not return any value.\n *\n * @param board A 2D array of strings, where each string represents\n *              the state of a cell in the game board. The board must be\n *              of size 3x3, and each string can be 'X', 'O', or ' '.\n * For example:\n *      input: [['X', 'O', 'X'],\n *              [' ', 'X', 'O'],\n *              ['O', ' ', ' ']]\n *      output: -------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\n */\nfunction printBoard(board: string[][]): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Prints a 3x3 game board to the console.\n *\n * This function takes a 2D vector representing a game board and prints\n * it in a formatted manner, displaying the contents of each cell.\n * The board is assumed to be a square of size 3x3, and each cell can\n * contain either a character representing a player's move ('X' or 'O')\n * or an empty space (' ').\n *\n * The output format includes a row of dashes to separate the rows of\n * the board, and each cell is enclosed within vertical bars.\n * The function does not return any value.\n *\n * @param board A 2D vector of characters, where each character represents\n *              the state of a cell in the game board. The board must be\n *              of size 3x3, and each character can be 'X', 'O', or ' '.\n * For example:\n *      input: [['X', 'O', 'X'],\n *              [' ', 'X', 'O'],\n *              ['O', ' ', ' ']]\n *      output: -------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\n */\nvoid printBoard(const vector<vector<char>>& board) {}", "test_code": "TEST_CASE(\"printBoard outputs correct format\", \"[printBoard]\") {\n    vector<vector<char>> board1 = {\n        {'X', 'O', 'X'},\n        {' ', 'X', 'O'},\n        {'O', ' ', ' '}\n    };\n\n    vector<vector<char>> board2 = {\n        {' ', ' ', ' '},\n        {' ', ' ', ' '},\n        {' ', ' ', ' '}\n    };\n\n    vector<vector<char>> board3 = {\n        {'X', 'X', 'X'},\n        {'O', 'O', ' '},\n        {' ', ' ', ' '}\n    };\n\n    vector<vector<char>> board4 = {\n        {'O', 'O', 'O'},\n        {'X', 'X', 'X'},\n        {'X', 'O', ' '}\n    };\n\n    vector<vector<char>> board5 = {\n        {'X', ' ', ' '},\n        {' ', 'X', ' '},\n        {' ', ' ', 'X'}\n    };\n\n    vector<vector<char>> board6 = {\n        {' ', 'O', ' '},\n        {'O', ' ', 'O'},\n        {' ', 'O', ' '}\n    };\n\n    // Test case 1\n    SECTION(\"Test case 1\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf()); // Redirect cout to ostringstream\n\n        printBoard(board1);\n\n        cout.rdbuf(oldCoutBuffer); // Restore original cout\n        string expectedOutput = \"-------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 2\n    SECTION(\"Test case 2\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board2);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n|   |   |   | \\n-------------\\n|   |   |   | \\n-------------\\n|   |   |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 3\n    SECTION(\"Test case 3\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board3);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n| X | X | X | \\n-------------\\n| O | O |   | \\n-------------\\n|   |   |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 4\n    SECTION(\"Test case 4\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board4);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n| O | O | O | \\n-------------\\n| X | X | X | \\n-------------\\n| X | O |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 5\n    SECTION(\"Test case 5\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board5);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n| X |   |   | \\n-------------\\n|   | X |   | \\n-------------\\n|   |   | X | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 6\n    SECTION(\"Test case 6\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board6);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n|   | O |   | \\n-------------\\n| O |   | O | \\n-------------\\n|   | O |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Prints a 3x3 game board to the console.\n *\n * This function takes a 2D vector representing a game board and prints\n * it in a formatted manner, displaying the contents of each cell.\n * The board is assumed to be a square of size 3x3, and each cell can\n * contain either a character representing a player's move ('X' or 'O')\n * or an empty space (' ').\n *\n * The output format includes a row of dashes to separate the rows of\n * the board, and each cell is enclosed within vertical bars.\n * The function does not return any value.\n *\n * @param board A 2D vector of characters, where each character represents\n *              the state of a cell in the game board. The board must be\n *              of size 3x3, and each character can be 'X', 'O', or ' '.\n * For example:\n *      input: [['X', 'O', 'X'],\n *              [' ', 'X', 'O'],\n *              ['O', ' ', ' ']]\n *      output: -------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\n */\nvoid printBoard(const vector<vector<char>>& board) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * @brief Prints a 3x3 game board to the console.\n *\n * This method takes a 2D array representing a game board and prints\n * it in a formatted manner, displaying the contents of each cell.\n * The board is assumed to be a square of size 3x3, and each cell can\n * contain either a character representing a player's move ('X' or 'O')\n * or an empty space (' ').\n *\n * The output format includes a row of dashes to separate the rows of\n * the board, and each cell is enclosed within vertical bars.\n * This method does not return any value.\n *\n * @param board A 2D array of characters, where each character represents\n *              the state of a cell in the game board. The board must be\n *              of size 3x3, and each character can be 'X', 'O', or ' '.\n * For example:\n *      input: [['X', 'O', 'X'],\n *              [' ', 'X', 'O'],\n *              ['O', ' ', ' ']]\n *      output: -------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\n */\npublic static void printBoard(char[][] board) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\npublic class Tester {\n\n    @Test\n    public void testPrintBoard() {\n        char[][] board1 = {\n            {'X', 'O', 'X'},\n            {' ', 'X', 'O'},\n            {'O', ' ', ' '}\n        };\n\n        char[][] board2 = {\n            {' ', ' ', ' '},\n            {' ', ' ', ' '},\n            {' ', ' ', ' '}\n        };\n\n        char[][] board3 = {\n            {'X', 'X', 'X'},\n            {'O', 'O', ' '},\n            {' ', ' ', ' '}\n        };\n\n        char[][] board4 = {\n            {'O', 'O', 'O'},\n            {'X', 'X', 'X'},\n            {'X', 'O', ' '}\n        };\n\n        char[][] board5 = {\n            {'X', ' ', ' '},\n            {' ', 'X', ' '},\n            {' ', ' ', 'X'}\n        };\n\n        char[][] board6 = {\n            {' ', 'O', ' '},\n            {'O', ' ', 'O'},\n            {' ', 'O', ' '}\n        };\n\n        // Test case 1\n        assertPrintBoardOutput(board1, \"-------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\");\n        \n        // Test case 2\n        assertPrintBoardOutput(board2, \"-------------\\n|   |   |   | \\n-------------\\n|   |   |   | \\n-------------\\n|   |   |   | \\n-------------\\n\");\n\n        // Test case 3\n        assertPrintBoardOutput(board3, \"-------------\\n| X | X | X | \\n-------------\\n| O | O |   | \\n-------------\\n|   |   |   | \\n-------------\\n\");\n        \n        // Test case 4\n        assertPrintBoardOutput(board4, \"-------------\\n| O | O | O | \\n-------------\\n| X | X | X | \\n-------------\\n| X | O |   | \\n-------------\\n\");\n        \n        // Test case 5\n        assertPrintBoardOutput(board5, \"-------------\\n| X |   |   | \\n-------------\\n|   | X |   | \\n-------------\\n|   |   | X | \\n-------------\\n\");\n        \n        // Test case 6\n        assertPrintBoardOutput(board6, \"-------------\\n|   | O |   | \\n-------------\\n| O |   | O | \\n-------------\\n|   | O |   | \\n-------------\\n\");\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * @brief Prints a 3x3 game board to the console.\n *\n * This method takes a 2D array representing a game board and prints\n * it in a formatted manner, displaying the contents of each cell.\n * The board is assumed to be a square of size 3x3, and each cell can\n * contain either a character representing a player's move ('X' or 'O')\n * or an empty space (' ').\n *\n * The output format includes a row of dashes to separate the rows of\n * the board, and each cell is enclosed within vertical bars.\n * This method does not return any value.\n *\n * @param board A 2D array of characters, where each character represents\n *              the state of a cell in the game board. The board must be\n *              of size 3x3, and each character can be 'X', 'O', or ' '.\n * For example:\n *      input: [['X', 'O', 'X'],\n *              [' ', 'X', 'O'],\n *              ['O', ' ', ' ']]\n *      output: -------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\n */\npublic static void printBoard(char[][] board) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 589, "code_type": "method", "original_language": "c&cpp", "question_type": "Data processing and transformation", "summary": "Extracts the first complete JSON object from the given string\n", "language_version_list": {"python": {"code_signature": "def extract_json(response: str) -> str:\n    \"\"\"\n    Extracts the first complete JSON object from a given string.\n\n    The function looks for the first occurrence of an opening curly brace '{'\n    and searches for the corresponding closing curly brace '}'. It tracks\n    the balance of braces to ensure that the JSON object is complete.\n\n    If a complete JSON object is found, it returns the substring that\n    represents that object. If no opening brace is found or if the braces\n    are unbalanced (i.e., incomplete), it returns an empty string.\n\n    Args:\n        response: The input string from which to extract the JSON object.\n\n    Returns:\n        A string containing the first complete JSON object, or an\n        empty string if no complete object is found.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestExtractJson(unittest.TestCase):\n\n    def test_extract_json_returns_empty_string_for_input_without_braces(self):\n        input_str = \"No braces here\"\n        self.assertEqual(extract_json(input_str), \"\")\n\n    def test_extract_json_extracts_single_json_object(self):\n        input_str = \"Here is some text before { \\\"key\\\": \\\"value\\\" } and some text after.\"\n        self.assertEqual(extract_json(input_str), \"{ \\\"key\\\": \\\"value\\\" }\")\n\n    def test_extract_json_handles_nested_json_objects(self):\n        input_str = \"Some text { \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } } more text.\"\n        self.assertEqual(extract_json(input_str), \"{ \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } }\")\n\n    def test_extract_json_returns_empty_string_for_unmatched_braces(self):\n        input_str = \"Here is an incomplete JSON { \\\"key\\\": \\\"value\\\" \"\n        self.assertEqual(extract_json(input_str), \"\")\n\n    def test_extract_json_returns_correct_json_when_multiple_braces_are_present(self):\n        input_str = \"Start { { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }} end.\"\n        self.assertEqual(extract_json(input_str),\n                         \"{ { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }}\")\n\n    def test_extract_json_extracts_first_json_object_when_multiple_are_present(self):\n        input_str = \"Text before { \\\"first\\\": \\\"value1\\\" } text in between { \\\"second\\\": \\\"value2\\\" }\"\n        self.assertEqual(extract_json(input_str), \"{ \\\"first\\\": \\\"value1\\\" }\")", "prompt": "please write a python function , the function signature as below def extract_json(response: str) -> str:\n    \"\"\"\n    Extracts the first complete JSON object from a given string.\n\n    The function looks for the first occurrence of an opening curly brace '{'\n    and searches for the corresponding closing curly brace '}'. It tracks\n    the balance of braces to ensure that the JSON object is complete.\n\n    If a complete JSON object is found, it returns the substring that\n    represents that object. If no opening brace is found or if the braces\n    are unbalanced (i.e., incomplete), it returns an empty string.\n\n    Args:\n        response: The input string from which to extract the JSON object.\n\n    Returns:\n        A string containing the first complete JSON object, or an\n        empty string if no complete object is found.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extracts the first complete JSON object from a given string.\n *\n * The function looks for the first occurrence of an opening curly brace '{'\n * and searches for the corresponding closing curly brace '}'. It tracks\n * the balance of braces to ensure that the JSON object is complete.\n *\n * If a complete JSON object is found, it returns the substring that\n * represents that object. If no opening brace is found or if the braces\n * are unbalanced (i.e., incomplete), it returns an empty string.\n *\n * @param {string} response - The input string from which to extract the JSON object.\n * @return {string} A string containing the first complete JSON object, or an\n *         empty string if no complete object is found.\n */\nfunction extractJson(response) {}", "test_code": "describe('extractJson', () => {\n    test(\"returns an empty string for input without '{'\", () => {\n        const input = \"No braces here\";\n        expect(extractJson(input)).toBe(\"\");\n    });\n\n    test(\"extracts a single JSON object\", () => {\n        const input = \"Here is some text before { \\\"key\\\": \\\"value\\\" } and some text after.\";\n        expect(extractJson(input)).toBe(\"{ \\\"key\\\": \\\"value\\\" }\");\n    });\n\n    test(\"handles nested JSON objects\", () => {\n        const input = \"Some text { \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } } more text.\";\n        expect(extractJson(input)).toBe(\"{ \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } }\");\n    });\n\n    test(\"returns an empty string for unmatched braces\", () => {\n        const input = \"Here is an incomplete JSON { \\\"key\\\": \\\"value\\\" \";\n        expect(extractJson(input)).toBe(\"\");\n    });\n\n    test(\"returns the correct JSON when multiple braces are present\", () => {\n        const input = \"Start { { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }} end.\";\n        expect(extractJson(input)).toBe(\"{ { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }}\");\n    });\n\n    test(\"extracts the first JSON object when multiple are present\", () => {\n        const input = \"Text before { \\\"first\\\": \\\"value1\\\" } text in between { \\\"second\\\": \\\"value2\\\" }\";\n        expect(extractJson(input)).toBe(\"{ \\\"first\\\": \\\"value1\\\" }\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Extracts the first complete JSON object from a given string.\n *\n * The function looks for the first occurrence of an opening curly brace '{'\n * and searches for the corresponding closing curly brace '}'. It tracks\n * the balance of braces to ensure that the JSON object is complete.\n *\n * If a complete JSON object is found, it returns the substring that\n * represents that object. If no opening brace is found or if the braces\n * are unbalanced (i.e., incomplete), it returns an empty string.\n *\n * @param {string} response - The input string from which to extract the JSON object.\n * @return {string} A string containing the first complete JSON object, or an\n *         empty string if no complete object is found.\n */\nfunction extractJson(response) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Extracts the first complete JSON object from a given string.\n *\n * The function looks for the first occurrence of an opening curly brace '{'\n * and searches for the corresponding closing curly brace '}'. It tracks\n * the balance of braces to ensure that the JSON object is complete.\n *\n * If a complete JSON object is found, it returns the substring that\n * represents that object. If no opening brace is found or if the braces\n * are unbalanced (i.e., incomplete), it returns an empty string.\n *\n * @param response The input string from which to extract the JSON object.\n * @return A string containing the first complete JSON object, or an\n *         empty string if no complete object is found.\n */\nfunction extractJson(response: string): string {}", "test_code": "describe('extractJson', () => {\n    test(\"returns an empty string for input without '{'\", () => {\n        const input = \"No braces here\";\n        expect(extractJson(input)).toBe(\"\");\n    });\n\n    test(\"extracts a single JSON object\", () => {\n        const input = \"Here is some text before { \\\"key\\\": \\\"value\\\" } and some text after.\";\n        expect(extractJson(input)).toBe(\"{ \\\"key\\\": \\\"value\\\" }\");\n    });\n\n    test(\"handles nested JSON objects\", () => {\n        const input = \"Some text { \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } } more text.\";\n        expect(extractJson(input)).toBe(\"{ \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } }\");\n    });\n\n    test(\"returns an empty string for unmatched braces\", () => {\n        const input = \"Here is an incomplete JSON { \\\"key\\\": \\\"value\\\" \";\n        expect(extractJson(input)).toBe(\"\");\n    });\n\n    test(\"returns the correct JSON when multiple braces are present\", () => {\n        const input = \"Start { { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }} end.\";\n        expect(extractJson(input)).toBe(\"{ { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }}\");\n    });\n\n    test(\"extracts the first JSON object when multiple are present\", () => {\n        const input = \"Text before { \\\"first\\\": \\\"value1\\\" } text in between { \\\"second\\\": \\\"value2\\\" }\";\n        expect(extractJson(input)).toBe(\"{ \\\"first\\\": \\\"value1\\\" }\");\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Extracts the first complete JSON object from a given string.\n *\n * The function looks for the first occurrence of an opening curly brace '{'\n * and searches for the corresponding closing curly brace '}'. It tracks\n * the balance of braces to ensure that the JSON object is complete.\n *\n * If a complete JSON object is found, it returns the substring that\n * represents that object. If no opening brace is found or if the braces\n * are unbalanced (i.e., incomplete), it returns an empty string.\n *\n * @param response The input string from which to extract the JSON object.\n * @return A string containing the first complete JSON object, or an\n *         empty string if no complete object is found.\n */\nfunction extractJson(response: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <string>\n\n/**\n * Extracts the first complete JSON object from a given string.\n *\n * The function looks for the first occurrence of an opening curly brace '{'\n * and searches for the corresponding closing curly brace '}'. It tracks\n * the balance of braces to ensure that the JSON object is complete.\n *\n * If a complete JSON object is found, it returns the substring that\n * represents that object. If no opening brace is found or if the braces\n * are unbalanced (i.e., incomplete), it returns an empty string.\n *\n * @param response The input string from which to extract the JSON object.\n * @return A string containing the first complete JSON object, or an\n *         empty string if no complete object is found.\n */\nstd::string extract_json(const std::string& response) {}", "test_code": "TEST_CASE(\"extract_json returns an empty string for input without '{'\") {\n    std::string input = \"No braces here\";\n    REQUIRE(extract_json(input) == \"\");\n}\n\nTEST_CASE(\"extract_json extracts a single JSON object\") {\n    std::string input = \"Here is some text before { \\\"key\\\": \\\"value\\\" } and some text after.\";\n    REQUIRE(extract_json(input) == \"{ \\\"key\\\": \\\"value\\\" }\");\n}\n\nTEST_CASE(\"extract_json handles nested JSON objects\") {\n    std::string input = \"Some text { \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } } more text.\";\n    REQUIRE(extract_json(input) == \"{ \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } }\");\n}\n\nTEST_CASE(\"extract_json returns an empty string for unmatched braces\") {\n    std::string input = \"Here is an incomplete JSON { \\\"key\\\": \\\"value\\\" \";\n    REQUIRE(extract_json(input) == \"\");\n}\n\nTEST_CASE(\"extract_json returns the correct JSON when multiple braces are present\") {\n    std::string input = \"Start { { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }} end.\";\n    REQUIRE(extract_json(input) == \"{ { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }}\");\n}\n\nTEST_CASE(\"extract_json extracts the first JSON object when multiple are present\") {\n    std::string input = \"Text before { \\\"first\\\": \\\"value1\\\" } text in between { \\\"second\\\": \\\"value2\\\" }\";\n    REQUIRE(extract_json(input) == \"{ \\\"first\\\": \\\"value1\\\" }\");\n}", "prompt": "please write a cpp function , the function signature as below #include <string>\n\n/**\n * Extracts the first complete JSON object from a given string.\n *\n * The function looks for the first occurrence of an opening curly brace '{'\n * and searches for the corresponding closing curly brace '}'. It tracks\n * the balance of braces to ensure that the JSON object is complete.\n *\n * If a complete JSON object is found, it returns the substring that\n * represents that object. If no opening brace is found or if the braces\n * are unbalanced (i.e., incomplete), it returns an empty string.\n *\n * @param response The input string from which to extract the JSON object.\n * @return A string containing the first complete JSON object, or an\n *         empty string if no complete object is found.\n */\nstd::string extract_json(const std::string& response) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Extracts the first complete JSON object from a given string.\n *\n * The method looks for the first occurrence of an opening curly brace '{'\n * and searches for the corresponding closing curly brace '}'. It tracks\n * the balance of braces to ensure that the JSON object is complete.\n *\n * If a complete JSON object is found, it returns the substring that\n * represents that object. If no opening brace is found or if the braces\n * are unbalanced (i.e., incomplete), it returns an empty string.\n *\n * @param response The input string from which to extract the JSON object.\n * @return A string containing the first complete JSON object, or an\n *         empty string if no complete object is found.\n */\npublic static String extractJson(String response) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testExtractJsonReturnsEmptyStringForInputWithoutBrace() {\n        String input = \"No braces here\";\n        assertEquals(\"\", Answer.extractJson(input));\n    }\n\n    @Test\n    public void testExtractJsonExtractsSingleJsonObject() {\n        String input = \"Here is some text before { \\\"key\\\": \\\"value\\\" } and some text after.\";\n        assertEquals(\"{ \\\"key\\\": \\\"value\\\" }\", Answer.extractJson(input));\n    }\n\n    @Test\n    public void testExtractJsonHandlesNestedJsonObjects() {\n        String input = \"Some text { \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } } more text.\";\n        assertEquals(\"{ \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } }\", Answer.extractJson(input));\n    }\n\n    @Test\n    public void testExtractJsonReturnsEmptyStringForUnmatchedBraces() {\n        String input = \"Here is an incomplete JSON { \\\"key\\\": \\\"value\\\" \";\n        assertEquals(\"\", Answer.extractJson(input));\n    }\n\n    @Test\n    public void testExtractJsonReturnsCorrectJsonWhenMultipleBracesPresent() {\n        String input = \"Start { { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }} end.\";\n        assertEquals(\"{ { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }}\", Answer.extractJson(input));\n    }\n\n    @Test\n    public void testExtractJsonExtractsFirstJsonObjectWhenMultiplePresent() {\n        String input = \"Text before { \\\"first\\\": \\\"value1\\\" } text in between { \\\"second\\\": \\\"value2\\\" }\";\n        assertEquals(\"{ \\\"first\\\": \\\"value1\\\" }\", Answer.extractJson(input));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts the first complete JSON object from a given string.\n *\n * The method looks for the first occurrence of an opening curly brace '{'\n * and searches for the corresponding closing curly brace '}'. It tracks\n * the balance of braces to ensure that the JSON object is complete.\n *\n * If a complete JSON object is found, it returns the substring that\n * represents that object. If no opening brace is found or if the braces\n * are unbalanced (i.e., incomplete), it returns an empty string.\n *\n * @param response The input string from which to extract the JSON object.\n * @return A string containing the first complete JSON object, or an\n *         empty string if no complete object is found.\n */\npublic static String extractJson(String response) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 590, "code_type": "method", "original_language": "c&cpp", "question_type": "Data processing and transformation", "summary": "Parse the HTTP response string, obtain the request method, URL, and HTTP version number, store the information in a map and return it\n", "language_version_list": {"python": {"code_signature": "def parse_http_request_line(response: str) -> dict:\n    \"\"\"\n    Parses the first line of an HTTP request.\n\n    Args:\n        response (str): The raw HTTP request string.\n\n    Returns:\n        dict: A dictionary containing the method, URL, and HTTP version.\n    \"\"\"", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_valid_post_request_line(self):\n        response = \"POST /api/data HTTP/1.1\\r\\n\"\n        parsed_info = parse_http_request_line(response)\n        self.assertEqual(parsed_info[\"method\"], \"POST\")\n        self.assertEqual(parsed_info[\"url\"], \"/api/data\")\n        self.assertEqual(parsed_info[\"http_version\"], \"HTTP/1.1\")\n\n    def test_put_request_line(self):\n        response = \"PUT /api/update HTTP/2.0\\r\\n\"\n        parsed_info = parse_http_request_line(response)\n        self.assertEqual(parsed_info[\"method\"], \"PUT\")\n        self.assertEqual(parsed_info[\"url\"], \"/api/update\")\n        self.assertEqual(parsed_info[\"http_version\"], \"HTTP/2.0\")\n\n    def test_delete_request_line(self):\n        response = \"DELETE /api/delete HTTP/1.1\\r\\n\"\n        parsed_info = parse_http_request_line(response)\n        self.assertEqual(parsed_info[\"method\"], \"DELETE\")\n        self.assertEqual(parsed_info[\"url\"], \"/api/delete\")\n        self.assertEqual(parsed_info[\"http_version\"], \"HTTP/1.1\")\n\n    def test_malformed_request_line(self):\n        response = \"INVALID REQUEST LINE\\r\\n\"\n        parsed_info = parse_http_request_line(response)\n        self.assertEqual(parsed_info, {})  # Expect empty result for malformed request", "prompt": "please write a python function , the function signature as below def parse_http_request_line(response: str) -> dict:\n    \"\"\"\n    Parses the first line of an HTTP request.\n\n    Args:\n        response (str): The raw HTTP request string.\n\n    Returns:\n        dict: A dictionary containing the method, URL, and HTTP version.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Parses the first line of an HTTP request response string.\n *\n * This function extracts the HTTP method, request URL, and HTTP version\n * from the given response string. The first line of the response should\n * be formatted as \"METHOD URL HTTP/VERSION\", followed by a CRLF sequence\n * (carriage return and line feed). If the first line does not conform\n * to this format, the function will return an empty object.\n *\n * @param {string} response - A string containing the HTTP response. It is expected\n *                            to start with a request line that includes the method,\n *                            URL, and HTTP version, ending with CRLF (\"\\r\\n\").\n *\n * @return {Object} An object containing three key-value pairs:\n *                  - \"method\": The HTTP method (e.g., GET, POST).\n *                  - \"url\": The requested URL (e.g., /index.html).\n *                  - \"http_version\": The HTTP version (e.g., HTTP/1.1).\n *                  If the request line is malformed or empty, the object may contain\n *                  empty strings or be empty.\n *\n * @note The function does not validate the correctness of the HTTP method,\n *       URL, or version; it only parses the input string.\n */\nfunction parseHttpRequestLine(response) {}", "test_code": "describe('parseHttpRequestLine', () => {\n    test('Valid POST request line', () => {\n        const response = \"POST /api/data HTTP/1.1\\r\\n\";\n        const parsedInfo = parseHttpRequestLine(response);\n\n        expect(parsedInfo.method).toBe(\"POST\");\n        expect(parsedInfo.url).toBe(\"/api/data\");\n        expect(parsedInfo.http_version).toBe(\"HTTP/1.1\");\n    });\n\n    test('PUT request line', () => {\n        const response = \"PUT /api/update HTTP/2.0\\r\\n\";\n        const parsedInfo = parseHttpRequestLine(response);\n\n        expect(parsedInfo.method).toBe(\"PUT\");\n        expect(parsedInfo.url).toBe(\"/api/update\");\n        expect(parsedInfo.http_version).toBe(\"HTTP/2.0\");\n    });\n\n    test('DELETE request line', () => {\n        const response = \"DELETE /api/delete HTTP/1.1\\r\\n\";\n        const parsedInfo = parseHttpRequestLine(response);\n\n        expect(parsedInfo.method).toBe(\"DELETE\");\n        expect(parsedInfo.url).toBe(\"/api/delete\");\n        expect(parsedInfo.http_version).toBe(\"HTTP/1.1\");\n    });\n\n    test('Malformed request line', () => {\n        const response = \"INVALID REQUEST LINE\\r\\n\";\n        const parsedInfo = parseHttpRequestLine(response);\n\n        expect(Object.keys(parsedInfo).length).toBe(0);  // Expect empty result for malformed request\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Parses the first line of an HTTP request response string.\n *\n * This function extracts the HTTP method, request URL, and HTTP version\n * from the given response string. The first line of the response should\n * be formatted as \"METHOD URL HTTP/VERSION\", followed by a CRLF sequence\n * (carriage return and line feed). If the first line does not conform\n * to this format, the function will return an empty object.\n *\n * @param {string} response - A string containing the HTTP response. It is expected\n *                            to start with a request line that includes the method,\n *                            URL, and HTTP version, ending with CRLF (\"\\r\\n\").\n *\n * @return {Object} An object containing three key-value pairs:\n *                  - \"method\": The HTTP method (e.g., GET, POST).\n *                  - \"url\": The requested URL (e.g., /index.html).\n *                  - \"http_version\": The HTTP version (e.g., HTTP/1.1).\n *                  If the request line is malformed or empty, the object may contain\n *                  empty strings or be empty.\n *\n * @note The function does not validate the correctness of the HTTP method,\n *       URL, or version; it only parses the input string.\n */\nfunction parseHttpRequestLine(response) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Parses the first line of an HTTP request response string.\n *\n * This function extracts the HTTP method, request URL, and HTTP version\n * from the given response string. The first line of the response should\n * be formatted as \"METHOD URL HTTP/VERSION\", followed by a CRLF sequence\n * (carriage return and line feed). If the first line does not conform\n * to this format, the function will return an empty object.\n *\n * @param response A string containing the HTTP response. It is expected\n *                 to start with a request line that includes the method,\n *                 URL, and HTTP version, ending with CRLF (\"\\r\\n\").\n *\n * @return An object containing three key-value pairs:\n *         - \"method\": The HTTP method (e.g., GET, POST).\n *         - \"url\": The requested URL (e.g., /index.html).\n *         - \"http_version\": The HTTP version (e.g., HTTP/1.1).\n *         If the request line is malformed or empty, the object may contain\n *         empty strings or be empty.\n *\n * @note The function does not validate the correctness of the HTTP method,\n *       URL, or version; it only parses the input string.\n */\nfunction parseHttpRequestLine(response: string): Record<string, string> {}", "test_code": "describe('parseHttpRequestLine', () => {\n    test('Valid POST request line', () => {\n        const response = \"POST /api/data HTTP/1.1\\r\\n\";\n        const parsedInfo = parseHttpRequestLine(response);\n\n        expect(parsedInfo.method).toBe(\"POST\");\n        expect(parsedInfo.url).toBe(\"/api/data\");\n        expect(parsedInfo.http_version).toBe(\"HTTP/1.1\");\n    });\n\n    test('PUT request line', () => {\n        const response = \"PUT /api/update HTTP/2.0\\r\\n\";\n        const parsedInfo = parseHttpRequestLine(response);\n\n        expect(parsedInfo.method).toBe(\"PUT\");\n        expect(parsedInfo.url).toBe(\"/api/update\");\n        expect(parsedInfo.http_version).toBe(\"HTTP/2.0\");\n    });\n\n    test('DELETE request line', () => {\n        const response = \"DELETE /api/delete HTTP/1.1\\r\\n\";\n        const parsedInfo = parseHttpRequestLine(response);\n\n        expect(parsedInfo.method).toBe(\"DELETE\");\n        expect(parsedInfo.url).toBe(\"/api/delete\");\n        expect(parsedInfo.http_version).toBe(\"HTTP/1.1\");\n    });\n\n    test('Malformed request line', () => {\n        const response = \"INVALID REQUEST LINE\\r\\n\";\n        const parsedInfo = parseHttpRequestLine(response);\n\n        expect(Object.keys(parsedInfo).length).toBe(0);  // Expect empty result for malformed request\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Parses the first line of an HTTP request response string.\n *\n * This function extracts the HTTP method, request URL, and HTTP version\n * from the given response string. The first line of the response should\n * be formatted as \"METHOD URL HTTP/VERSION\", followed by a CRLF sequence\n * (carriage return and line feed). If the first line does not conform\n * to this format, the function will return an empty object.\n *\n * @param response A string containing the HTTP response. It is expected\n *                 to start with a request line that includes the method,\n *                 URL, and HTTP version, ending with CRLF (\"\\r\\n\").\n *\n * @return An object containing three key-value pairs:\n *         - \"method\": The HTTP method (e.g., GET, POST).\n *         - \"url\": The requested URL (e.g., /index.html).\n *         - \"http_version\": The HTTP version (e.g., HTTP/1.1).\n *         If the request line is malformed or empty, the object may contain\n *         empty strings or be empty.\n *\n * @note The function does not validate the correctness of the HTTP method,\n *       URL, or version; it only parses the input string.\n */\nfunction parseHttpRequestLine(response: string): Record<string, string> {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <string>\n#include <map>\n#include <sstream>\n\n/**\n * @brief Parses the first line of an HTTP request response string.\n *\n * This function extracts the HTTP method, request URL, and HTTP version\n * from the given response string. The first line of the response should\n * be formatted as \"METHOD URL HTTP/VERSION\", followed by a CRLF sequence\n * (carriage return and line feed). If the first line does not conform\n * to this format, the function will return an empty map.\n *\n * @param response A string containing the HTTP response. It is expected\n *                 to start with a request line that includes the method,\n *                 URL, and HTTP version, ending with CRLF (\"\\r\\n\").\n *\n * @return A map containing three key-value pairs:\n *         - \"method\": The HTTP method (e.g., GET, POST).\n *         - \"url\": The requested URL (e.g., /index.html).\n *         - \"http_version\": The HTTP version (e.g., HTTP/1.1).\n *         If the request line is malformed or empty, the map may contain\n *         empty strings or be empty.\n *\n * @note The function does not validate the correctness of the HTTP method,\n *       URL, or version; it only parses the input string.\n */\nstd::map<std::string, std::string> parse_http_request_line(const std::string& response){}", "test_code": "TEST_CASE(\"Valid POST request line\", \"[parse_http_request_line]\") {\n    std::string response = \"POST /api/data HTTP/1.1\\r\\n\";\n    auto parsed_info = parse_http_request_line(response);\n\n    REQUIRE(parsed_info[\"method\"] == \"POST\");\n    REQUIRE(parsed_info[\"url\"] == \"/api/data\");\n    REQUIRE(parsed_info[\"http_version\"] == \"HTTP/1.1\");\n}\n\nTEST_CASE(\"PUT request line\", \"[parse_http_request_line]\") {\n    std::string response = \"PUT /api/update HTTP/2.0\\r\\n\";\n    auto parsed_info = parse_http_request_line(response);\n\n    REQUIRE(parsed_info[\"method\"] == \"PUT\");\n    REQUIRE(parsed_info[\"url\"] == \"/api/update\");\n    REQUIRE(parsed_info[\"http_version\"] == \"HTTP/2.0\");\n}\n\nTEST_CASE(\"DELETE request line\", \"[parse_http_request_line]\") {\n    std::string response = \"DELETE /api/delete HTTP/1.1\\r\\n\";\n    auto parsed_info = parse_http_request_line(response);\n\n    REQUIRE(parsed_info[\"method\"] == \"DELETE\");\n    REQUIRE(parsed_info[\"url\"] == \"/api/delete\");\n    REQUIRE(parsed_info[\"http_version\"] == \"HTTP/1.1\");\n}\n\nTEST_CASE(\"Malformed request line\", \"[parse_http_request_line]\") {\n    std::string response = \"INVALID REQUEST LINE\\r\\n\";\n    auto parsed_info = parse_http_request_line(response);\n\n    REQUIRE(parsed_info.empty());  // Expect empty result for malformed request\n}", "prompt": "please write a cpp function , the function signature as below #include <string>\n#include <map>\n#include <sstream>\n\n/**\n * @brief Parses the first line of an HTTP request response string.\n *\n * This function extracts the HTTP method, request URL, and HTTP version\n * from the given response string. The first line of the response should\n * be formatted as \"METHOD URL HTTP/VERSION\", followed by a CRLF sequence\n * (carriage return and line feed). If the first line does not conform\n * to this format, the function will return an empty map.\n *\n * @param response A string containing the HTTP response. It is expected\n *                 to start with a request line that includes the method,\n *                 URL, and HTTP version, ending with CRLF (\"\\r\\n\").\n *\n * @return A map containing three key-value pairs:\n *         - \"method\": The HTTP method (e.g., GET, POST).\n *         - \"url\": The requested URL (e.g., /index.html).\n *         - \"http_version\": The HTTP version (e.g., HTTP/1.1).\n *         If the request line is malformed or empty, the map may contain\n *         empty strings or be empty.\n *\n * @note The function does not validate the correctness of the HTTP method,\n *       URL, or version; it only parses the input string.\n */\nstd::map<std::string, std::string> parse_http_request_line(const std::string& response){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Parses the first line of an HTTP request response string.\n *\n * This method extracts the HTTP method, request URL, and HTTP version\n * from the given response string. The first line of the response should\n * be formatted as \"METHOD URL HTTP/VERSION\", followed by a CRLF sequence\n * (carriage return and line feed). If the first line does not conform\n * to this format, the method will return an empty map.\n *\n * @param response A string containing the HTTP response. It is expected\n *                 to start with a request line that includes the method,\n *                 URL, and HTTP version, ending with CRLF (\"\\r\\n\").\n *\n * @return A map containing three key-value pairs:\n *         - \"method\": The HTTP method (e.g., GET, POST).\n *         - \"url\": The requested URL (e.g., /index.html).\n *         - \"http_version\": The HTTP version (e.g., HTTP/1.1).\n *         If the request line is malformed or empty, the map may contain\n *         empty strings or be empty.\n *\n * @note The method does not validate the correctness of the HTTP method,\n *       URL, or version; it only parses the input string.\n */\npublic static Map<String, String> parseHttpRequestLine(String response) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport java.util.Map;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\npublic class Tester {\n\n    @Test\n    public void testValidPostRequestLine() {\n        String response = \"POST /api/data HTTP/1.1\\r\\n\";\n        Map<String, String> parsedInfo = Answer.parseHttpRequestLine(response);\n\n        assertEquals(\"POST\", parsedInfo.get(\"method\"));\n        assertEquals(\"/api/data\", parsedInfo.get(\"url\"));\n        assertEquals(\"HTTP/1.1\", parsedInfo.get(\"http_version\"));\n    }\n\n    @Test\n    public void testPutRequestLine() {\n        String response = \"PUT /api/update HTTP/2.0\\r\\n\";\n        Map<String, String> parsedInfo = Answer.parseHttpRequestLine(response);\n\n        assertEquals(\"PUT\", parsedInfo.get(\"method\"));\n        assertEquals(\"/api/update\", parsedInfo.get(\"url\"));\n        assertEquals(\"HTTP/2.0\", parsedInfo.get(\"http_version\"));\n    }\n\n    @Test\n    public void testDeleteRequestLine() {\n        String response = \"DELETE /api/delete HTTP/1.1\\r\\n\";\n        Map<String, String> parsedInfo = Answer.parseHttpRequestLine(response);\n\n        assertEquals(\"DELETE\", parsedInfo.get(\"method\"));\n        assertEquals(\"/api/delete\", parsedInfo.get(\"url\"));\n        assertEquals(\"HTTP/1.1\", parsedInfo.get(\"http_version\"));\n    }\n\n    @Test\n    public void testMalformedRequestLine() {\n        String response = \"INVALID REQUEST LINE\\r\\n\";\n        Map<String, String> parsedInfo = Answer.parseHttpRequestLine(response);\n\n        assertTrue(parsedInfo.isEmpty());  // Expect empty result for malformed request\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Parses the first line of an HTTP request response string.\n *\n * This method extracts the HTTP method, request URL, and HTTP version\n * from the given response string. The first line of the response should\n * be formatted as \"METHOD URL HTTP/VERSION\", followed by a CRLF sequence\n * (carriage return and line feed). If the first line does not conform\n * to this format, the method will return an empty map.\n *\n * @param response A string containing the HTTP response. It is expected\n *                 to start with a request line that includes the method,\n *                 URL, and HTTP version, ending with CRLF (\"\\r\\n\").\n *\n * @return A map containing three key-value pairs:\n *         - \"method\": The HTTP method (e.g., GET, POST).\n *         - \"url\": The requested URL (e.g., /index.html).\n *         - \"http_version\": The HTTP version (e.g., HTTP/1.1).\n *         If the request line is malformed or empty, the map may contain\n *         empty strings or be empty.\n *\n * @note The method does not validate the correctness of the HTTP method,\n *       URL, or version; it only parses the input string.\n */\npublic static Map<String, String> parseHttpRequestLine(String response) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 591, "code_type": "class", "original_language": "c&cpp", "question_type": "Program input code", "summary": "Please write a class that contains RGB representations of, RED, GREEN, BLUE, YELLOW, MAGENTA, CYAN, WHITE, BLACK, ORANGE, PURPLE, PINK, BROWN, which can be obtained directly by the function", "language_version_list": {"python": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <string>\n#include <unordered_map>\n\n/**\n* Please write a class that contains RGB representations of, RED, GREEN, BLUE, YELLOW, MAGENTA, CYAN, WHITE, BLACK, ORANGE, PURPLE, PINK, BROWN, which can be obtained directly by the function\n/\nclass Color {\npublic:\n    enum ColorName {\n        RED,\n        GREEN,\n        BLUE,\n        YELLOW,\n        MAGENTA,\n        CYAN,\n        WHITE,\n        BLACK,\n        ORANGE,\n        PURPLE,\n        PINK,\n        BROWN\n    };\n\n    // Constructor\n    Color() {\n        initializeColors();\n    }\n\n    // Function to get the RGB value of a color by its name\n    std::tuple<int, int, int> getColor(ColorName colorName) {}\n\n    // Function to get the color name as a string\n    std::string getColorName(ColorName colorName) {}\n\nprivate:\n    // A map to store the RGB values of the colors\n    std::unordered_map<ColorName, std::tuple<int, int, int>> colors;\n\n    // Function to initialize the colors\n    void initializeColors() {}\n};\n", "test_code": "TEST_CASE(\"Color RGB Values\", \"[Color]\") {\n    Color color;\n\n    SECTION(\"Verify RGB values for Red\") {\n        auto rgb = color.getColor(Color::RED);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Green\") {\n        auto rgb = color.getColor(Color::GREEN);\n        REQUIRE(std::get<0>(rgb) == 0);\n        REQUIRE(std::get<1>(rgb) == 255);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Blue\") {\n        auto rgb = color.getColor(Color::BLUE);\n        REQUIRE(std::get<0>(rgb) == 0);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 255);\n    }\n\n    SECTION(\"Verify RGB values for Yellow\") {\n        auto rgb = color.getColor(Color::YELLOW);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 255);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Magenta\") {\n        auto rgb = color.getColor(Color::MAGENTA);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 255);\n    }\n\n    SECTION(\"Verify RGB values for Cyan\") {\n        auto rgb = color.getColor(Color::CYAN);\n        REQUIRE(std::get<0>(rgb) == 0);\n        REQUIRE(std::get<1>(rgb) == 255);\n        REQUIRE(std::get<2>(rgb) == 255);\n    }\n\n    SECTION(\"Verify RGB values for White\") {\n        auto rgb = color.getColor(Color::WHITE);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 255);\n        REQUIRE(std::get<2>(rgb) == 255);\n    }\n\n    SECTION(\"Verify RGB values for Black\") {\n        auto rgb = color.getColor(Color::BLACK);\n        REQUIRE(std::get<0>(rgb) == 0);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Orange\") {\n        auto rgb = color.getColor(Color::ORANGE);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 165);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Purple\") {\n        auto rgb = color.getColor(Color::PURPLE);\n        REQUIRE(std::get<0>(rgb) == 128);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 128);\n    }\n\n    SECTION(\"Verify RGB values for Pink\") {\n        auto rgb = color.getColor(Color::PINK);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 192);\n        REQUIRE(std::get<2>(rgb) == 203);\n    }\n\n    SECTION(\"Verify RGB values for Brown\") {\n        auto rgb = color.getColor(Color::BROWN);\n        REQUIRE(std::get<0>(rgb) == 165);\n        REQUIRE(std::get<1>(rgb) == 42);\n        REQUIRE(std::get<2>(rgb) == 42);\n    }\n}", "prompt": "please write a cpp class , the class signature as below #include <iostream>\n#include <string>\n#include <unordered_map>\n\n/**\n* Please write a class that contains RGB representations of, RED, GREEN, BLUE, YELLOW, MAGENTA, CYAN, WHITE, BLACK, ORANGE, PURPLE, PINK, BROWN, which can be obtained directly by the function\n/\nclass Color {\npublic:\n    enum ColorName {\n        RED,\n        GREEN,\n        BLUE,\n        YELLOW,\n        MAGENTA,\n        CYAN,\n        WHITE,\n        BLACK,\n        ORANGE,\n        PURPLE,\n        PINK,\n        BROWN\n    };\n\n    // Constructor\n    Color() {\n        initializeColors();\n    }\n\n    // Function to get the RGB value of a color by its name\n    std::tuple<int, int, int> getColor(ColorName colorName) {}\n\n    // Function to get the color name as a string\n    std::string getColorName(ColorName colorName) {}\n\nprivate:\n    // A map to store the RGB values of the colors\n    std::unordered_map<ColorName, std::tuple<int, int, int>> colors;\n\n    // Function to initialize the colors\n    void initializeColors() {}\n};\n", "addition_info": "#include <unordered_map>\n"}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 592, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Implement a simple mathematical operation function\n", "language_version_list": {"python": {"code_signature": "def perform_operation(a: float, b: float, op: str) -> float:\n    \"\"\"Performs a mathematical operation on two operands.\n\n    This function takes two float values and an operator character, and performs\n    the specified arithmetic operation. Supported operations include addition,\n    subtraction, multiplication, division, and exponentiation.\n\n    Args:\n        a (float): The first operand.\n        b (float): The second operand.\n        op (str): A character representing the operation to perform:\n                  '+' for addition,\n                  '-' for subtraction,\n                  '*' for multiplication,\n                  '/' for division,\n                  '^' for exponentiation.\n\n    Returns:\n        float: The result of the operation.\n\n    Raises:\n        ValueError: If the operator is not recognized or if\n                    there is an attempt to divide by zero.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_addition(self):\n        self.assertEqual(perform_operation(3, 4, '+'), 7)\n        self.assertEqual(perform_operation(-1, -1, '+'), -2)\n\n    def test_subtraction(self):\n        self.assertEqual(perform_operation(10, 5, '-'), 5)\n        self.assertEqual(perform_operation(5, 10, '-'), -5)\n\n    def test_multiplication(self):\n        self.assertEqual(perform_operation(3, 4, '*'), 12)\n        self.assertEqual(perform_operation(-2, 5, '*'), -10)\n\n    def test_division(self):\n        self.assertEqual(perform_operation(8, 4, '/'), 2)\n        self.assertEqual(perform_operation(5, 2, '/'), 2.5)\n        with self.assertRaises(Exception):  # Change to ValueError for Python\n            perform_operation(5, 0, '/')\n\n    def test_exponentiation(self):\n        self.assertEqual(apply_op(2, 3, '^'), 8)\n        self.assertEqual(apply_op(9, 0.5, '^'), 3)  # Square root of 9\n", "prompt": "please write a python function , the function signature as below def perform_operation(a: float, b: float, op: str) -> float:\n    \"\"\"Performs a mathematical operation on two operands.\n\n    This function takes two float values and an operator character, and performs\n    the specified arithmetic operation. Supported operations include addition,\n    subtraction, multiplication, division, and exponentiation.\n\n    Args:\n        a (float): The first operand.\n        b (float): The second operand.\n        op (str): A character representing the operation to perform:\n                  '+' for addition,\n                  '-' for subtraction,\n                  '*' for multiplication,\n                  '/' for division,\n                  '^' for exponentiation.\n\n    Returns:\n        float: The result of the operation.\n\n    Raises:\n        ValueError: If the operator is not recognized or if\n                    there is an attempt to divide by zero.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Performs a mathematical operation on two operands.\n *\n * This function takes two numbers and an operator character, and performs\n * the specified arithmetic operation. Supported operations include addition,\n * subtraction, multiplication, division, and exponentiation.\n *\n * @param {number} a The first operand.\n * @param {number} b The second operand.\n * @param {string} op A character representing the operation to perform:\n *                    '+' for addition,\n *                    '-' for subtraction,\n *                    '*' for multiplication,\n *                    '/' for division,\n *                    '^' for exponentiation.\n *\n * @return {number} The result of the operation.\n *\n * @throws {Error} if the operator is not recognized or if\n *         there is an attempt to divide by zero.\n */\nfunction applyOp(a, b, op) {}", "test_code": "describe(\"applyOp function tests\", () => {\n    test(\"Addition\", () => {\n        expect(applyOp(3, 4, '+')).toBe(7);\n        expect(applyOp(-1, -1, '+')).toBe(-2);\n    });\n\n    test(\"Subtraction\", () => {\n        expect(applyOp(10, 5, '-')).toBe(5);\n        expect(applyOp(5, 10, '-')).toBe(-5);\n    });\n\n    test(\"Multiplication\", () => {\n        expect(applyOp(3, 4, '*')).toBe(12);\n        expect(applyOp(-2, 5, '*')).toBe(-10);\n    });\n\n    test(\"Division\", () => {\n        expect(applyOp(8, 4, '/')).toBe(2);\n        expect(applyOp(5, 2, '/')).toBe(2.5);\n        expect(() => applyOp(5, 0, '/')).toThrow(\"Division by zero is not allowed.\");\n    });\n\n    test(\"Exponentiation\", () => {\n        expect(applyOp(2, 3, '^')).toBe(8);\n        expect(applyOp(9, 0.5, '^')).toBe(3); // Square root of 9\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Performs a mathematical operation on two operands.\n *\n * This function takes two numbers and an operator character, and performs\n * the specified arithmetic operation. Supported operations include addition,\n * subtraction, multiplication, division, and exponentiation.\n *\n * @param {number} a The first operand.\n * @param {number} b The second operand.\n * @param {string} op A character representing the operation to perform:\n *                    '+' for addition,\n *                    '-' for subtraction,\n *                    '*' for multiplication,\n *                    '/' for division,\n *                    '^' for exponentiation.\n *\n * @return {number} The result of the operation.\n *\n * @throws {Error} if the operator is not recognized or if\n *         there is an attempt to divide by zero.\n */\nfunction applyOp(a, b, op) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Performs a mathematical operation on two operands.\n *\n * This function takes two number values and an operator string, and performs\n * the specified arithmetic operation. Supported operations include addition,\n * subtraction, multiplication, division, and exponentiation.\n *\n * @param a The first operand (number).\n * @param b The second operand (number).\n * @param op A string representing the operation to perform:\n *            '+' for addition,\n *            '-' for subtraction,\n *            '*' for multiplication,\n *            '/' for division,\n *            '^' for exponentiation.\n *\n * @returns The result of the operation as a number.\n *\n * @throws Error if the operator is not recognized or if\n *         there is an attempt to divide by zero.\n */\nfunction applyOp(a: number, b: number, op: string): number {}", "test_code": "describe(\"applyOp function tests\", () => {\n    test(\"Addition\", () => {\n        expect(applyOp(3, 4, '+')).toBe(7);\n        expect(applyOp(-1, -1, '+')).toBe(-2);\n    });\n\n    test(\"Subtraction\", () => {\n        expect(applyOp(10, 5, '-')).toBe(5);\n        expect(applyOp(5, 10, '-')).toBe(-5);\n    });\n\n    test(\"Multiplication\", () => {\n        expect(applyOp(3, 4, '*')).toBe(12);\n        expect(applyOp(-2, 5, '*')).toBe(-10);\n    });\n\n    test(\"Division\", () => {\n        expect(applyOp(8, 4, '/')).toBe(2);\n        expect(applyOp(5, 2, '/')).toBe(2.5);\n        expect(() => applyOp(5, 0, '/')).toThrow(Error);\n    });\n\n    test(\"Exponentiation\", () => {\n        expect(applyOp(2, 3, '^')).toBe(8);\n        expect(applyOp(9, 0.5, '^')).toBe(3); // Square root of 9\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Performs a mathematical operation on two operands.\n *\n * This function takes two number values and an operator string, and performs\n * the specified arithmetic operation. Supported operations include addition,\n * subtraction, multiplication, division, and exponentiation.\n *\n * @param a The first operand (number).\n * @param b The second operand (number).\n * @param op A string representing the operation to perform:\n *            '+' for addition,\n *            '-' for subtraction,\n *            '*' for multiplication,\n *            '/' for division,\n *            '^' for exponentiation.\n *\n * @returns The result of the operation as a number.\n *\n * @throws Error if the operator is not recognized or if\n *         there is an attempt to divide by zero.\n */\nfunction applyOp(a: number, b: number, op: string): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <cmath>\n#include <stdexcept>\n\n/**\n * @brief Performs a mathematical operation on two operands.\n *\n * This function takes two double values and an operator character, and performs\n * the specified arithmetic operation. Supported operations include addition,\n * subtraction, multiplication, division, and exponentiation.\n *\n * @param a The first operand (double).\n * @param b The second operand (double).\n * @param op A character representing the operation to perform:\n *            '+' for addition,\n *            '-' for subtraction,\n *            '*' for multiplication,\n *            '/' for division,\n *            '^' for exponentiation.\n *\n * @return The result of the operation as a double.\n *\n * @throws std::invalid_argument if the operator is not recognized or if\n *         there is an attempt to divide by zero.\n */\ndouble applyOp(double a, double b, char op) {}", "test_code": "TEST_CASE(\"applyOp function tests\") {\n    SECTION(\"Addition\") {\n        REQUIRE(applyOp(3, 4, '+') == 7);\n        REQUIRE(applyOp(-1, -1, '+') == -2);\n    }\n\n    SECTION(\"Subtraction\") {\n        REQUIRE(applyOp(10, 5, '-') == 5);\n        REQUIRE(applyOp(5, 10, '-') == -5);\n    }\n\n    SECTION(\"Multiplication\") {\n        REQUIRE(applyOp(3, 4, '*') == 12);\n        REQUIRE(applyOp(-2, 5, '*') == -10);\n    }\n\n    SECTION(\"Division\") {\n        REQUIRE(applyOp(8, 4, '/') == 2);\n        REQUIRE(applyOp(5, 2, '/') == 2.5);\n        REQUIRE_THROWS_AS(applyOp(5, 0, '/'), std::invalid_argument);\n    }\n\n    SECTION(\"Exponentiation\") {\n        REQUIRE(applyOp(2, 3, '^') == 8);\n        REQUIRE(applyOp(9, 0.5, '^') == 3); // Square root of 9\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <cmath>\n#include <stdexcept>\n\n/**\n * @brief Performs a mathematical operation on two operands.\n *\n * This function takes two double values and an operator character, and performs\n * the specified arithmetic operation. Supported operations include addition,\n * subtraction, multiplication, division, and exponentiation.\n *\n * @param a The first operand (double).\n * @param b The second operand (double).\n * @param op A character representing the operation to perform:\n *            '+' for addition,\n *            '-' for subtraction,\n *            '*' for multiplication,\n *            '/' for division,\n *            '^' for exponentiation.\n *\n * @return The result of the operation as a double.\n *\n * @throws std::invalid_argument if the operator is not recognized or if\n *         there is an attempt to divide by zero.\n */\ndouble applyOp(double a, double b, char op) {}", "addition_info": ""}, "java": {"code_signature": "\n/**\n * Performs a mathematical operation on two operands.\n *\n * @param a The first operand (double).\n * @param b The second operand (double).\n * @param op A character representing the operation to perform:\n *           '+' for addition,\n *           '-' for subtraction,\n *           '*' for multiplication,\n *           '/' for division,\n *           '^' for exponentiation.\n * @return The result of the operation as a double.\n * @throws IllegalArgumentException if the operator is not recognized or if\n *                                  there is an attempt to divide by zero.\n */\npublic static double applyOp(double a, double b, char op) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    @Test\n    public void testAddition() {\n        assertEquals(7, Answer.applyOp(3, 4, '+'), 0);\n        assertEquals(-2, Answer.applyOp(-1, -1, '+'), 0);\n    }\n\n    @Test\n    public void testSubtraction() {\n        assertEquals(5, Answer.applyOp(10, 5, '-'), 0);\n        assertEquals(-5, Answer.applyOp(5, 10, '-'), 0);\n    }\n\n    @Test\n    public void testMultiplication() {\n        assertEquals(12, Answer.applyOp(3, 4, '*'), 0);\n        assertEquals(-10, Answer.applyOp(-2, 5, '*'), 0);\n    }\n\n    @Test\n    public void testDivision() {\n        assertEquals(2, Answer.applyOp(8, 4, '/'), 0);\n        assertEquals(2.5, Answer.applyOp(5, 2, '/'), 0);\n        try {\n            Answer.applyOp(5, 0, '/');\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // Expected exception\n        }\n    }\n\n    @Test\n    public void testExponentiation() {\n        assertEquals(8, Answer.applyOp(2, 3, '^'), 0);\n        assertEquals(3, Answer.applyOp(9, 0.5, '^'), 0);\n    }\n}", "prompt": "please write a java function , the function signature as below \n/**\n * Performs a mathematical operation on two operands.\n *\n * @param a The first operand (double).\n * @param b The second operand (double).\n * @param op A character representing the operation to perform:\n *           '+' for addition,\n *           '-' for subtraction,\n *           '*' for multiplication,\n *           '/' for division,\n *           '^' for exponentiation.\n * @return The result of the operation as a double.\n * @throws IllegalArgumentException if the operator is not recognized or if\n *                                  there is an attempt to divide by zero.\n */\npublic static double applyOp(double a, double b, char op) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 594, "code_type": "method", "original_language": "c&cpp", "question_type": "Data processing and transformation", "summary": "Splits a comma-separated string into individual tokens.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef split_comma(s: str) -> List[str]:\n    \"\"\"\n    Splits a comma-separated string into individual tokens.\n    This function takes a string containing comma-separated values, trims\n    leading and trailing whitespace from each token, and stores the non-empty\n    tokens in the provided list.\n\n    Args:\n        s (str): The input string to be split, which may contain leading and trailing whitespace around the tokens.\n\n    Returns:\n        List[str]: A list where the resulting tokens will be stored. The list will be cleared before storing the new tokens.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_basic_comma_separated_values(self):\n        result = split_comma(\"apple,banana,orange\")\n        self.assertEqual(len(result), 3)\n        self.assertEqual(result[0], \"apple\")\n        self.assertEqual(result[1], \"banana\")\n        self.assertEqual(result[2], \"orange\")\n\n    def test_leading_and_trailing_whitespace(self):\n        result = split_comma(\"  apple , banana , orange  \")\n        self.assertEqual(len(result), 3)\n        self.assertEqual(result[0], \"apple\")\n        self.assertEqual(result[1], \"banana\")\n        self.assertEqual(result[2], \"orange\")\n\n    def test_multiple_consecutive_commas(self):\n        result = split_comma(\"apple,,banana,,,orange\")\n        self.assertEqual(len(result), 3)\n        self.assertEqual(result[0], \"apple\")\n        self.assertEqual(result[1], \"banana\")\n        self.assertEqual(result[2], \"orange\")\n\n    def test_empty_input_string(self):\n        result = split_comma(\"\")\n        self.assertEqual(len(result), 0)\n\n    def test_only_whitespace_input(self):\n        result = split_comma(\"   \")\n        self.assertEqual(len(result), 0)\n\n    def test_trailing_commas(self):\n        result = split_comma(\"apple,banana,orange,\")\n        self.assertEqual(len(result), 3)\n        self.assertEqual(result[0], \"apple\")\n        self.assertEqual(result[1], \"banana\")\n        self.assertEqual(result[2], \"orange\")\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef split_comma(s: str) -> List[str]:\n    \"\"\"\n    Splits a comma-separated string into individual tokens.\n    This function takes a string containing comma-separated values, trims\n    leading and trailing whitespace from each token, and stores the non-empty\n    tokens in the provided list.\n\n    Args:\n        s (str): The input string to be split, which may contain leading and trailing whitespace around the tokens.\n\n    Returns:\n        List[str]: A list where the resulting tokens will be stored. The list will be cleared before storing the new tokens.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Splits a comma-separated string into individual tokens.\n *\n * This function takes a string containing comma-separated values, trims\n * leading and trailing whitespace from each token, and stores the non-empty\n * tokens in the provided array.\n *\n * @param {string} str - The input string to be split, which may contain leading and\n *            trailing whitespace around the tokens.\n * @param {Array<string>} vect - An array where the resulting tokens will be stored. \n *             The array will be cleared before storing the new tokens.\n */\nfunction splitComma(str, vect) {}", "test_code": "describe(\"splitComma function tests\", () => {\n    let result;\n\n    beforeEach(() => {\n        result = [];\n    });\n\n    test(\"Basic comma-separated values\", () => {\n        splitComma(\"apple,banana,orange\", result);\n        expect(result.length).toBe(3);\n        expect(result[0]).toBe(\"apple\");\n        expect(result[1]).toBe(\"banana\");\n        expect(result[2]).toBe(\"orange\");\n    });\n\n    test(\"Leading and trailing whitespace\", () => {\n        splitComma(\"  apple , banana , orange  \", result);\n        expect(result.length).toBe(3);\n        expect(result[0]).toBe(\"apple\");\n        expect(result[1]).toBe(\"banana\");\n        expect(result[2]).toBe(\"orange\");\n    });\n\n    test(\"Multiple consecutive commas\", () => {\n        splitComma(\"apple,,banana,,,orange\", result);\n        expect(result.length).toBe(3);\n        expect(result[0]).toBe(\"apple\");\n        expect(result[1]).toBe(\"banana\");\n        expect(result[2]).toBe(\"orange\");\n    });\n\n    test(\"Empty input string\", () => {\n        splitComma(\"\", result);\n        expect(result.length).toBe(0);\n    });\n\n    test(\"Only whitespace input\", () => {\n        splitComma(\"   \", result);\n        expect(result.length).toBe(0);\n    });\n\n    test(\"Trailing commas\", () => {\n        splitComma(\"apple,banana,orange,\", result);\n        expect(result.length).toBe(3);\n        expect(result[0]).toBe(\"apple\");\n        expect(result[1]).toBe(\"banana\");\n        expect(result[2]).toBe(\"orange\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Splits a comma-separated string into individual tokens.\n *\n * This function takes a string containing comma-separated values, trims\n * leading and trailing whitespace from each token, and stores the non-empty\n * tokens in the provided array.\n *\n * @param {string} str - The input string to be split, which may contain leading and\n *            trailing whitespace around the tokens.\n * @param {Array<string>} vect - An array where the resulting tokens will be stored. \n *             The array will be cleared before storing the new tokens.\n */\nfunction splitComma(str, vect) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Splits a comma-separated string into individual tokens.\n *\n * This function takes a string containing comma-separated values, trims\n * leading and trailing whitespace from each token, and stores the non-empty\n * tokens in the provided array.\n *\n * @param str The input string to be split, which may contain leading and\n *            trailing whitespace around the tokens.\n * @param vect An array where the resulting tokens will be stored. The array\n *             will be cleared before storing the new tokens.\n */\nfunction splitComma(str: string, vect: string[]): void {}", "test_code": "describe('splitComma function tests', () => {\n    let result: string[];\n\n    beforeEach(() => {\n        result = [];\n    });\n\n    test('Basic comma-separated values', () => {\n        splitComma(\"apple,banana,orange\", result);\n        expect(result.length).toBe(3);\n        expect(result[0]).toBe(\"apple\");\n        expect(result[1]).toBe(\"banana\");\n        expect(result[2]).toBe(\"orange\");\n    });\n\n    test('Leading and trailing whitespace', () => {\n        splitComma(\"  apple , banana , orange  \", result);\n        expect(result.length).toBe(3);\n        expect(result[0]).toBe(\"apple\");\n        expect(result[1]).toBe(\"banana\");\n        expect(result[2]).toBe(\"orange\");\n    });\n\n    test('Multiple consecutive commas', () => {\n        splitComma(\"apple,,banana,,,orange\", result);\n        expect(result.length).toBe(3);\n        expect(result[0]).toBe(\"apple\");\n        expect(result[1]).toBe(\"banana\");\n        expect(result[2]).toBe(\"orange\");\n    });\n\n    test('Empty input string', () => {\n        splitComma(\"\", result);\n        expect(result.length).toBe(0);\n    });\n\n    test('Only whitespace input', () => {\n        splitComma(\"   \", result);\n        expect(result.length).toBe(0);\n    });\n\n    test('Trailing commas', () => {\n        splitComma(\"apple,banana,orange,\", result);\n        expect(result.length).toBe(3);\n        expect(result[0]).toBe(\"apple\");\n        expect(result[1]).toBe(\"banana\");\n        expect(result[2]).toBe(\"orange\");\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Splits a comma-separated string into individual tokens.\n *\n * This function takes a string containing comma-separated values, trims\n * leading and trailing whitespace from each token, and stores the non-empty\n * tokens in the provided array.\n *\n * @param str The input string to be split, which may contain leading and\n *            trailing whitespace around the tokens.\n * @param vect An array where the resulting tokens will be stored. The array\n *             will be cleared before storing the new tokens.\n */\nfunction splitComma(str: string, vect: string[]): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm> // for std::remove_if\n/**\n * @brief Splits a comma-separated string into individual tokens.\n *\n * This function takes a string containing comma-separated values, trims\n * leading and trailing whitespace from each token, and stores the non-empty\n * tokens in the provided vector.\n *\n * @param str The input string to be split, which may contain leading and\n *            trailing whitespace around the tokens.\n * @param vect A reference to a vector of strings where the resulting tokens\n *             will be stored. The vector will be cleared before storing\n *             the new tokens.\n */\nvoid splitComma(const std::string& str, std::vector<std::string>& vect) {}", "test_code": "TEST_CASE(\"splitComma function tests\") {\n    std::vector<std::string> result;\n\n    SECTION(\"Basic comma-separated values\") {\n        splitComma(\"apple,banana,orange\", result);\n        REQUIRE(result.size() == 3);\n        REQUIRE(result[0] == \"apple\");\n        REQUIRE(result[1] == \"banana\");\n        REQUIRE(result[2] == \"orange\");\n    }\n\n    SECTION(\"Leading and trailing whitespace\") {\n        splitComma(\"  apple , banana , orange  \", result);\n        REQUIRE(result.size() == 3);\n        REQUIRE(result[0] == \"apple\");\n        REQUIRE(result[1] == \"banana\");\n        REQUIRE(result[2] == \"orange\");\n    }\n\n    SECTION(\"Multiple consecutive commas\") {\n        splitComma(\"apple,,banana,,,orange\", result);\n        REQUIRE(result.size() == 3);\n        REQUIRE(result[0] == \"apple\");\n        REQUIRE(result[1] == \"banana\");\n        REQUIRE(result[2] == \"orange\");\n    }\n\n    SECTION(\"Empty input string\") {\n        splitComma(\"\", result);\n        REQUIRE(result.size() == 0);\n    }\n\n    SECTION(\"Only whitespace input\") {\n        splitComma(\"   \", result);\n        REQUIRE(result.size() == 0);\n    }\n\n    SECTION(\"Trailing commas\") {\n        splitComma(\"apple,banana,orange,\", result);\n        REQUIRE(result.size() == 3);\n        REQUIRE(result[0] == \"apple\");\n        REQUIRE(result[1] == \"banana\");\n        REQUIRE(result[2] == \"orange\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm> // for std::remove_if\n/**\n * @brief Splits a comma-separated string into individual tokens.\n *\n * This function takes a string containing comma-separated values, trims\n * leading and trailing whitespace from each token, and stores the non-empty\n * tokens in the provided vector.\n *\n * @param str The input string to be split, which may contain leading and\n *            trailing whitespace around the tokens.\n * @param vect A reference to a vector of strings where the resulting tokens\n *             will be stored. The vector will be cleared before storing\n *             the new tokens.\n */\nvoid splitComma(const std::string& str, std::vector<std::string>& vect) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Splits a comma-separated string into individual tokens.\n *\n * This method takes a string containing comma-separated values, trims\n * leading and trailing whitespace from each token, and stores the non-empty\n * tokens in the provided list.\n *\n * @param str The input string to be split, which may contain leading and\n *            trailing whitespace around the tokens.\n * @param vect A list of strings where the resulting tokens\n *             will be stored. The list will be cleared before storing\n *             the new tokens.\n */\npublic static void splitComma(String str, List<String> vect) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    private List<String> result;\n\n    @Before\n    public void setUp() {\n        result = new ArrayList<>();\n    }\n\n    @Test\n    public void testBasicCommaSeparatedValues() {\n        Answer.splitComma(\"apple,banana,orange\", result);\n        assertEquals(3, result.size());\n        assertEquals(\"apple\", result.get(0));\n        assertEquals(\"banana\", result.get(1));\n        assertEquals(\"orange\", result.get(2));\n    }\n\n    @Test\n    public void testLeadingAndTrailingWhitespace() {\n        Answer.splitComma(\"  apple , banana , orange  \", result);\n        assertEquals(3, result.size());\n        assertEquals(\"apple\", result.get(0));\n        assertEquals(\"banana\", result.get(1));\n        assertEquals(\"orange\", result.get(2));\n    }\n\n    @Test\n    public void testMultipleConsecutiveCommas() {\n        Answer.splitComma(\"apple,,banana,,,orange\", result);\n        assertEquals(3, result.size());\n        assertEquals(\"apple\", result.get(0));\n        assertEquals(\"banana\", result.get(1));\n        assertEquals(\"orange\", result.get(2));\n    }\n\n    @Test\n    public void testEmptyInputString() {\n        Answer.splitComma(\"\", result);\n        assertEquals(0, result.size());\n    }\n\n    @Test\n    public void testOnlyWhitespaceInput() {\n        Answer.splitComma(\"   \", result);\n        assertEquals(0, result.size());\n    }\n\n    @Test\n    public void testTrailingCommas() {\n        Answer.splitComma(\"apple,banana,orange,\", result);\n        assertEquals(3, result.size());\n        assertEquals(\"apple\", result.get(0));\n        assertEquals(\"banana\", result.get(1));\n        assertEquals(\"orange\", result.get(2));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Splits a comma-separated string into individual tokens.\n *\n * This method takes a string containing comma-separated values, trims\n * leading and trailing whitespace from each token, and stores the non-empty\n * tokens in the provided list.\n *\n * @param str The input string to be split, which may contain leading and\n *            trailing whitespace around the tokens.\n * @param vect A list of strings where the resulting tokens\n *             will be stored. The list will be cleared before storing\n *             the new tokens.\n */\npublic static void splitComma(String str, List<String> vect) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 595, "code_type": "method", "original_language": "c&cpp", "question_type": "Data processing and transformation", "summary": "Returns the number of days in a given month of a given year.", "language_version_list": {"python": {"code_signature": "def get_days_in_month(year: int, month: int) -> int:\n    \"\"\"\n    Returns the number of days in a given month of a given year.\n    This function accounts for leap years when determining the number of\n    days in February. It raises a ValueError if the month is invalid.\n\n    Args:\n        year (int): The year to check (should be a positive integer).\n        month (int): The month to check (1 for January, 12 for December).\n\n    Returns:\n        int: The number of days in the specified month of the specified year.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_days_in_january(self):\n        self.assertEqual(get_days_in_month(2023, 1), 31)  # January\n\n    def test_days_in_february_non_leap(self):\n        self.assertEqual(get_days_in_month(2023, 2), 28)  # Non-leap year\n\n    def test_days_in_february_leap(self):\n        self.assertEqual(get_days_in_month(2024, 2), 29)  # Leap year\n\n    def test_days_in_march(self):\n        self.assertEqual(get_days_in_month(2023, 3), 31)  # March\n\n    def test_days_in_april(self):\n        self.assertEqual(get_days_in_month(2023, 4), 30)  # April\n\n    def test_days_in_may(self):\n        self.assertEqual(get_days_in_month(2023, 5), 31)  # May\n\n    def test_days_in_june(self):\n        self.assertEqual(get_days_in_month(2023, 6), 30)  # June\n\n    def test_days_in_july(self):\n        self.assertEqual(get_days_in_month(2023, 7), 31)  # July\n\n    def test_days_in_august(self):\n        self.assertEqual(get_days_in_month(2023, 8), 31)  # August\n\n    def test_days_in_september(self):\n        self.assertEqual(get_days_in_month(2023, 9), 30)  # September\n\n    def test_days_in_october(self):\n        self.assertEqual(get_days_in_month(2023, 10), 31) # October\n\n    def test_days_in_november(self):\n        self.assertEqual(get_days_in_month(2023, 11), 30) # November\n\n    def test_days_in_december(self):\n        self.assertEqual(get_days_in_month(2023, 12), 31) # December", "prompt": "please write a python function , the function signature as below def get_days_in_month(year: int, month: int) -> int:\n    \"\"\"\n    Returns the number of days in a given month of a given year.\n    This function accounts for leap years when determining the number of\n    days in February. It raises a ValueError if the month is invalid.\n\n    Args:\n        year (int): The year to check (should be a positive integer).\n        month (int): The month to check (1 for January, 12 for December).\n\n    Returns:\n        int: The number of days in the specified month of the specified year.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Returns the number of days in a given month of a given year.\n *\n * This function accounts for leap years when determining the number of\n * days in February. It throws an error if the month is invalid.\n *\n * @param {number} year The year to check (should be a positive integer).\n * @param {number} month The month to check (1 for January, 12 for December).\n * @return {number} The number of days in the specified month of the specified year.\n * @throws {RangeError} If the month is not between 1 and 12.\n */\nfunction getDaysInMonth(year, month) {\n}", "test_code": "describe(\"getDaysInMonth function\", () => {\n    describe(\"Regular months\", () => {\n        test(\"January\", () => {\n            expect(getDaysInMonth(2023, 1)).toBe(31);\n        });\n        test(\"March\", () => {\n            expect(getDaysInMonth(2023, 3)).toBe(31);\n        });\n        test(\"April\", () => {\n            expect(getDaysInMonth(2023, 4)).toBe(30);\n        });\n        test(\"May\", () => {\n            expect(getDaysInMonth(2023, 5)).toBe(31);\n        });\n        test(\"June\", () => {\n            expect(getDaysInMonth(2023, 6)).toBe(30);\n        });\n        test(\"July\", () => {\n            expect(getDaysInMonth(2023, 7)).toBe(31);\n        });\n        test(\"August\", () => {\n            expect(getDaysInMonth(2023, 8)).toBe(31);\n        });\n        test(\"September\", () => {\n            expect(getDaysInMonth(2023, 9)).toBe(30);\n        });\n        test(\"October\", () => {\n            expect(getDaysInMonth(2023, 10)).toBe(31);\n        });\n        test(\"November\", () => {\n            expect(getDaysInMonth(2023, 11)).toBe(30);\n        });\n        test(\"December\", () => {\n            expect(getDaysInMonth(2023, 12)).toBe(31);\n        });\n    });\n\n    describe(\"February in leap year\", () => {\n        test(\"Leap year\", () => {\n            expect(getDaysInMonth(2024, 2)).toBe(29);\n        });\n    });\n\n    describe(\"February in non-leap year\", () => {\n        test(\"Non-leap year\", () => {\n            expect(getDaysInMonth(2023, 2)).toBe(28);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Returns the number of days in a given month of a given year.\n *\n * This function accounts for leap years when determining the number of\n * days in February. It throws an error if the month is invalid.\n *\n * @param {number} year The year to check (should be a positive integer).\n * @param {number} month The month to check (1 for January, 12 for December).\n * @return {number} The number of days in the specified month of the specified year.\n * @throws {RangeError} If the month is not between 1 and 12.\n */\nfunction getDaysInMonth(year, month) {\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Returns the number of days in a given month of a given year.\n *\n * This function accounts for leap years when determining the number of\n * days in February. It throws an error if the month is invalid.\n *\n * @param year The year to check (should be a positive integer).\n * @param month The month to check (1 for January, 12 for December).\n * @return number The number of days in the specified month of the specified year.\n * @throws Error If the month is not between 1 and 12.\n */\nfunction getDaysInMonth(year: number, month: number): number {}", "test_code": "describe(\"getDaysInMonth function\", () => {\n    describe(\"Regular months\", () => {\n        test(\"January\", () => {\n            expect(getDaysInMonth(2023, 1)).toBe(31);\n        });\n        test(\"March\", () => {\n            expect(getDaysInMonth(2023, 3)).toBe(31);\n        });\n        test(\"April\", () => {\n            expect(getDaysInMonth(2023, 4)).toBe(30);\n        });\n        test(\"May\", () => {\n            expect(getDaysInMonth(2023, 5)).toBe(31);\n        });\n        test(\"June\", () => {\n            expect(getDaysInMonth(2023, 6)).toBe(30);\n        });\n        test(\"July\", () => {\n            expect(getDaysInMonth(2023, 7)).toBe(31);\n        });\n        test(\"August\", () => {\n            expect(getDaysInMonth(2023, 8)).toBe(31);\n        });\n        test(\"September\", () => {\n            expect(getDaysInMonth(2023, 9)).toBe(30);\n        });\n        test(\"October\", () => {\n            expect(getDaysInMonth(2023, 10)).toBe(31);\n        });\n        test(\"November\", () => {\n            expect(getDaysInMonth(2023, 11)).toBe(30);\n        });\n        test(\"December\", () => {\n            expect(getDaysInMonth(2023, 12)).toBe(31);\n        });\n    });\n\n    describe(\"February in leap year\", () => {\n        test(\"Leap year\", () => {\n            expect(getDaysInMonth(2024, 2)).toBe(29);\n        });\n    });\n\n    describe(\"February in non-leap year\", () => {\n        test(\"Non-leap year\", () => {\n            expect(getDaysInMonth(2023, 2)).toBe(28);\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Returns the number of days in a given month of a given year.\n *\n * This function accounts for leap years when determining the number of\n * days in February. It throws an error if the month is invalid.\n *\n * @param year The year to check (should be a positive integer).\n * @param month The month to check (1 for January, 12 for December).\n * @return number The number of days in the specified month of the specified year.\n * @throws Error If the month is not between 1 and 12.\n */\nfunction getDaysInMonth(year: number, month: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Returns the number of days in a given month of a given year.\n *\n * This function accounts for leap years when determining the number of\n * days in February. It throws an exception if the month is invalid.\n *\n * @param year The year to check (should be a positive integer).\n * @param month The month to check (1 for January, 12 for December).\n * @return int The number of days in the specified month of the specified year.\n * @throws std::invalid_argument If the month is not between 1 and 12.\n */\nint getDaysInMonth(int year, int month) {}", "test_code": "TEST_CASE(\"Test getDaysInMonth function\") {\n    SECTION(\"Regular months\") {\n        REQUIRE(getDaysInMonth(2023, 1) == 31); // January\n        REQUIRE(getDaysInMonth(2023, 3) == 31); // March\n        REQUIRE(getDaysInMonth(2023, 4) == 30); // April\n        REQUIRE(getDaysInMonth(2023, 5) == 31); // May\n        REQUIRE(getDaysInMonth(2023, 6) == 30); // June\n        REQUIRE(getDaysInMonth(2023, 7) == 31); // July\n        REQUIRE(getDaysInMonth(2023, 8) == 31); // August\n        REQUIRE(getDaysInMonth(2023, 9) == 30); // September\n        REQUIRE(getDaysInMonth(2023, 10) == 31); // October\n        REQUIRE(getDaysInMonth(2023, 11) == 30); // November\n        REQUIRE(getDaysInMonth(2023, 12) == 31); // December\n    }\n\n    SECTION(\"February in leap year\") {\n        REQUIRE(getDaysInMonth(2024, 2) == 29); // Leap year\n    }\n\n    SECTION(\"February in non-leap year\") {\n        REQUIRE(getDaysInMonth(2023, 2) == 28); // Non-leap year\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Returns the number of days in a given month of a given year.\n *\n * This function accounts for leap years when determining the number of\n * days in February. It throws an exception if the month is invalid.\n *\n * @param year The year to check (should be a positive integer).\n * @param month The month to check (1 for January, 12 for December).\n * @return int The number of days in the specified month of the specified year.\n * @throws std::invalid_argument If the month is not between 1 and 12.\n */\nint getDaysInMonth(int year, int month) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Returns the number of days in a given month of a given year.\n *\n * This method accounts for leap years when determining the number of\n * days in February. It throws an exception if the month is invalid.\n *\n * @param year The year to check (should be a positive integer).\n * @param month The month to check (1 for January, 12 for December).\n * @return int The number of days in the specified month of the specified year.\n * @throws IllegalArgumentException If the month is not between 1 and 12.\n */\npublic static int getDaysInMonth(int year, int month) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testGetDaysInMonthRegularMonths() {\n        assertEquals(31, getDaysInMonth(2023, 1)); // January\n        assertEquals(31, getDaysInMonth(2023, 3)); // March\n        assertEquals(30, getDaysInMonth(2023, 4)); // April\n        assertEquals(31, getDaysInMonth(2023, 5)); // May\n        assertEquals(30, getDaysInMonth(2023, 6)); // June\n        assertEquals(31, getDaysInMonth(2023, 7)); // July\n        assertEquals(31, getDaysInMonth(2023, 8)); // August\n        assertEquals(30, getDaysInMonth(2023, 9)); // September\n        assertEquals(31, getDaysInMonth(2023, 10)); // October\n        assertEquals(30, getDaysInMonth(2023, 11)); // November\n        assertEquals(31, getDaysInMonth(2023, 12)); // December\n    }\n\n    @Test\n    public void testGetDaysInMonthFebruaryLeapYear() {\n        assertEquals(29, getDaysInMonth(2024, 2)); // Leap year\n    }\n\n    @Test\n    public void testGetDaysInMonthFebruaryNonLeapYear() {\n        assertEquals(28, getDaysInMonth(2023, 2)); // Non-leap year\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Returns the number of days in a given month of a given year.\n *\n * This method accounts for leap years when determining the number of\n * days in February. It throws an exception if the month is invalid.\n *\n * @param year The year to check (should be a positive integer).\n * @param month The month to check (1 for January, 12 for December).\n * @return int The number of days in the specified month of the specified year.\n * @throws IllegalArgumentException If the month is not between 1 and 12.\n */\npublic static int getDaysInMonth(int year, int month) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 597, "code_type": "method", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "According to the input hue value (hue), calculate the corresponding RGB color value (red, green, blue\uff09\n", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef hue_to_rgb(hue: float) -> Tuple[int, int, int]:\n    \"\"\"\n    Converts a hue value to its corresponding RGB color values.\n\n    Args:\n        hue (float): A float representing the hue angle in degrees,expected to be in the range [0, 360).\n\n    Returns:\n        Tuple[int, int, int]: A tuple containing three integers representing the RGB color components in the range [0, 255]. The first element is the red component, the second element is the green component, and the third element is the blue component.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_hue_0_red(self):\n        r, g, b = hue_to_rgb(0)\n        self.assertEqual(r, 255)\n        self.assertEqual(g, 0)\n        self.assertEqual(b, 0)\n\n    def test_hue_120_green(self):\n        r, g, b = hue_to_rgb(120)\n        self.assertEqual(r, 0)\n        self.assertEqual(g, 255)\n        self.assertEqual(b, 0)\n\n    def test_hue_240_blue(self):\n        r, g, b = hue_to_rgb(240)\n        self.assertEqual(r, 0)\n        self.assertEqual(g, 0)\n        self.assertEqual(b, 255)\n\n    def test_hue_60_yellow(self):\n        r, g, b = hue_to_rgb(60)\n        self.assertEqual(r, 255)\n        self.assertEqual(g, 255)\n        self.assertEqual(b, 0)\n\n    def test_hue_180_cyan(self):\n        r, g, b = hue_to_rgb(180)\n        self.assertEqual(r, 0)\n        self.assertEqual(g, 255)\n        self.assertEqual(b, 255)\n\n    def test_hue_300_magenta(self):\n        r, g, b = hue_to_rgb(300)\n        self.assertEqual(r, 255)\n        self.assertEqual(g, 0)\n        self.assertEqual(b, 255)\n", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef hue_to_rgb(hue: float) -> Tuple[int, int, int]:\n    \"\"\"\n    Converts a hue value to its corresponding RGB color values.\n\n    Args:\n        hue (float): A float representing the hue angle in degrees,expected to be in the range [0, 360).\n\n    Returns:\n        Tuple[int, int, int]: A tuple containing three integers representing the RGB color components in the range [0, 255]. The first element is the red component, the second element is the green component, and the third element is the blue component.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a hue value to its corresponding RGB color values.\n *\n * @param {number} hue - A float representing the hue angle in degrees,\n *                       expected to be in the range [0, 360).\n *\n * @return {Array<number>} An array containing three integers representing the\n *                         RGB color components in the range [0, 255]. The\n *                         first element is the red component, the second\n *                         element is the green component, and the third element\n *                         is the blue component.\n */\nfunction hueToRGB(hue) {}", "test_code": "describe(\"Hue to RGB Conversion Tests\", () => {\n    test(\"Hue 0 (Red)\", () => {\n        const [r, g, b] = hueToRGB(0);\n        expect(r).toBe(255);\n        expect(g).toBe(0);\n        expect(b).toBe(0);\n    });\n\n    test(\"Hue 120 (Green)\", () => {\n        const [r, g, b] = hueToRGB(120);\n        expect(r).toBe(0);\n        expect(g).toBe(255);\n        expect(b).toBe(0);\n    });\n\n    test(\"Hue 240 (Blue)\", () => {\n        const [r, g, b] = hueToRGB(240);\n        expect(r).toBe(0);\n        expect(g).toBe(0);\n        expect(b).toBe(255);\n    });\n\n    test(\"Hue 60 (Yellow)\", () => {\n        const [r, g, b] = hueToRGB(60);\n        expect(r).toBe(255);\n        expect(g).toBe(255);\n        expect(b).toBe(0);\n    });\n\n    test(\"Hue 180 (Cyan)\", () => {\n        const [r, g, b] = hueToRGB(180);\n        expect(r).toBe(0);\n        expect(g).toBe(255);\n        expect(b).toBe(255);\n    });\n\n    test(\"Hue 300 (Magenta)\", () => {\n        const [r, g, b] = hueToRGB(300);\n        expect(r).toBe(255);\n        expect(g).toBe(0);\n        expect(b).toBe(255);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a hue value to its corresponding RGB color values.\n *\n * @param {number} hue - A float representing the hue angle in degrees,\n *                       expected to be in the range [0, 360).\n *\n * @return {Array<number>} An array containing three integers representing the\n *                         RGB color components in the range [0, 255]. The\n *                         first element is the red component, the second\n *                         element is the green component, and the third element\n *                         is the blue component.\n */\nfunction hueToRGB(hue) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a hue value to its corresponding RGB color values.\n *\n * @param hue A number representing the hue angle in degrees,\n *            expected to be in the range [0, 360).\n *\n * @return An array containing three integers representing the\n *         RGB color components in the range [0, 255]. The\n *         first element is the red component, the second\n *         element is the green component, and the third element\n *         is the blue component.\n */\nfunction hueToRGB(hue: number): [number, number, number] {}", "test_code": "describe(\"Hue to RGB Conversion Tests\", () => {\n    test(\"Hue 0 (Red)\", () => {\n        const [r, g, b] = hueToRGB(0);\n        expect(r).toBe(255);\n        expect(g).toBe(0);\n        expect(b).toBe(0);\n    });\n\n    test(\"Hue 120 (Green)\", () => {\n        const [r, g, b] = hueToRGB(120);\n        expect(r).toBe(0);\n        expect(g).toBe(255);\n        expect(b).toBe(0);\n    });\n\n    test(\"Hue 240 (Blue)\", () => {\n        const [r, g, b] = hueToRGB(240);\n        expect(r).toBe(0);\n        expect(g).toBe(0);\n        expect(b).toBe(255);\n    });\n\n    test(\"Hue 60 (Yellow)\", () => {\n        const [r, g, b] = hueToRGB(60);\n        expect(r).toBe(255);\n        expect(g).toBe(255);\n        expect(b).toBe(0);\n    });\n\n    test(\"Hue 180 (Cyan)\", () => {\n        const [r, g, b] = hueToRGB(180);\n        expect(r).toBe(0);\n        expect(g).toBe(255);\n        expect(b).toBe(255);\n    });\n\n    test(\"Hue 300 (Magenta)\", () => {\n        const [r, g, b] = hueToRGB(300);\n        expect(r).toBe(255);\n        expect(g).toBe(0);\n        expect(b).toBe(255);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a hue value to its corresponding RGB color values.\n *\n * @param hue A number representing the hue angle in degrees,\n *            expected to be in the range [0, 360).\n *\n * @return An array containing three integers representing the\n *         RGB color components in the range [0, 255]. The\n *         first element is the red component, the second\n *         element is the green component, and the third element\n *         is the blue component.\n */\nfunction hueToRGB(hue: number): [number, number, number] {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <tuple>\n#include <cmath>\n\n/**\n * Converts a hue value to its corresponding RGB color values.\n *\n * @param hue A float representing the hue angle in degrees,\n *            expected to be in the range [0, 360).\n *\n * @return A tuple containing three integers representing the\n *         RGB color components in the range [0, 255]. The\n *         first element is the red component, the second\n *         element is the green component, and the third element\n *         is the blue component.\n */\nstd::tuple<int, int, int> hueToRGB(float hue) {}", "test_code": "TEST_CASE(\"Hue to RGB Conversion Tests\") {\n    SECTION(\"Hue 0 (Red)\") {\n        auto [r, g, b] = hueToRGB(0);\n        REQUIRE(r == 255);\n        REQUIRE(g == 0);\n        REQUIRE(b == 0);\n    }\n\n    SECTION(\"Hue 120 (Green)\") {\n        auto [r, g, b] = hueToRGB(120);\n        REQUIRE(r == 0);\n        REQUIRE(g == 255);\n        REQUIRE(b == 0);\n    }\n\n    SECTION(\"Hue 240 (Blue)\") {\n        auto [r, g, b] = hueToRGB(240);\n        REQUIRE(r == 0);\n        REQUIRE(g == 0);\n        REQUIRE(b == 255);\n    }\n\n    SECTION(\"Hue 60 (Yellow)\") {\n        auto [r, g, b] = hueToRGB(60);\n        REQUIRE(r == 255);\n        REQUIRE(g == 255);\n        REQUIRE(b == 0);\n    }\n\n    SECTION(\"Hue 180 (Cyan)\") {\n        auto [r, g, b] = hueToRGB(180);\n        REQUIRE(r == 0);\n        REQUIRE(g == 255);\n        REQUIRE(b == 255);\n    }\n\n    SECTION(\"Hue 300 (Magenta)\") {\n        auto [r, g, b] = hueToRGB(300);\n        REQUIRE(r == 255);\n        REQUIRE(g == 0);\n        REQUIRE(b == 255);\n    }\n\n}", "prompt": "please write a cpp function , the function signature as below #include <tuple>\n#include <cmath>\n\n/**\n * Converts a hue value to its corresponding RGB color values.\n *\n * @param hue A float representing the hue angle in degrees,\n *            expected to be in the range [0, 360).\n *\n * @return A tuple containing three integers representing the\n *         RGB color components in the range [0, 255]. The\n *         first element is the red component, the second\n *         element is the green component, and the third element\n *         is the blue component.\n */\nstd::tuple<int, int, int> hueToRGB(float hue) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a hue value to its corresponding RGB color values.\n *\n * @param hue A float representing the hue angle in degrees,\n *            expected to be in the range [0, 360).\n *\n * @return An array containing three integers representing the\n *         RGB color components in the range [0, 255]. The\n *         first element is the red component, the second\n *         element is the green component, and the third element\n *         is the blue component.\n */\npublic static int[] hueToRGB(float hue) {}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\n\npublic class Tester {\n\n    @Test\n    public void testHueToRGB_Hue0_Red() {\n        int[] rgb = Answer.hueToRGB(0);\n        assertArrayEquals(new int[] {255, 0, 0}, rgb);\n    }\n\n    @Test\n    public void testHueToRGB_Hue120_Green() {\n        int[] rgb = Answer.hueToRGB(120);\n        assertArrayEquals(new int[] {0, 255, 0}, rgb);\n    }\n\n    @Test\n    public void testHueToRGB_Hue240_Blue() {\n        int[] rgb = Answer.hueToRGB(240);\n        assertArrayEquals(new int[] {0, 0, 255}, rgb);\n    }\n\n    @Test\n    public void testHueToRGB_Hue60_Yellow() {\n        int[] rgb = Answer.hueToRGB(60);\n        assertArrayEquals(new int[] {255, 255, 0}, rgb);\n    }\n\n    @Test\n    public void testHueToRGB_Hue180_Cyan() {\n        int[] rgb = Answer.hueToRGB(180);\n        assertArrayEquals(new int[] {0, 255, 255}, rgb);\n    }\n\n    @Test\n    public void testHueToRGB_Hue300_Magenta() {\n        int[] rgb = Answer.hueToRGB(300);\n        assertArrayEquals(new int[] {255, 0, 255}, rgb);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a hue value to its corresponding RGB color values.\n *\n * @param hue A float representing the hue angle in degrees,\n *            expected to be in the range [0, 360).\n *\n * @return An array containing three integers representing the\n *         RGB color components in the range [0, 255]. The\n *         first element is the red component, the second\n *         element is the green component, and the third element\n *         is the blue component.\n */\npublic static int[] hueToRGB(float hue) {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 598, "code_type": "class", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Using linked list to realize the queue of head and tail Pointers", "language_version_list": {"python": {"code_signature": "class Node:\n    def __init__(self, val):\n        self.data = val  # Data value of the node\n        self.next = None  # Pointer to the next node in the linked list\n\n# Queue class\nclass Queue:\n    def __init__(self):\n        self.head = None  # Pointer to the front of the queue\n        self.tail = None  # Pointer to the end of the queue\n\n    # Destructor to clean up the queue\n    def __del__(self):\n        while not self.is_empty():\n            self.dequeue()\n\n    # Function to check if the queue is empty\n    def is_empty(self):\n        pass\n\n    # Function to add an element to the end of the queue\n    def enqueue(self, value):\n        pass\n\n    # Function to remove and return the front element of the queue\n    def dequeue(self):\n        pass\n\n    # Function to get the front element without removing it\n    def front(self):\n        pass", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def test_queue_operations(self):\n        queue = Queue()\n\n        # Queue should be empty initially\n        self.assertTrue(queue.isEmpty(), \"Queue should be empty initially\")\n\n        # Enqueue elements\n        queue.enqueue(10)\n        queue.enqueue(20)\n        queue.enqueue(30)\n        self.assertFalse(queue.isEmpty(), \"Queue should not be empty after enqueuing elements\")\n        self.assertEqual(queue.front(), 10, \"Front element should be 10\")\n\n        # Dequeue elements\n        value = queue.dequeue()\n        self.assertEqual(value, 10, \"First dequeued element should be 10\")\n        self.assertEqual(queue.front(), 20, \"Now front should be 20\")\n\n        # Dequeue from an empty queue\n        queue.dequeue()  # Remove 20\n        queue.dequeue()  # Remove 30\n        value = queue.dequeue()\n        self.assertEqual(value, -1, \"Should indicate that the queue is empty\")\n\n        # Front element of an empty queue\n        frontValue = queue.front()\n        self.assertEqual(frontValue, -1, \"Should indicate that the queue is empty\")\n\n        # Queue should become empty after dequeuing all elements\n        queue.enqueue(10)\n        queue.enqueue(20)\n        queue.dequeue()  # Remove 10\n        queue.dequeue()  # Remove 20\n        self.assertTrue(queue.isEmpty(), \"Queue should be empty after dequeuing all elements\")", "prompt": "please write a python class , the class signature as below class Node:\n    def __init__(self, val):\n        self.data = val  # Data value of the node\n        self.next = None  # Pointer to the next node in the linked list\n\n# Queue class\nclass Queue:\n    def __init__(self):\n        self.head = None  # Pointer to the front of the queue\n        self.tail = None  # Pointer to the end of the queue\n\n    # Destructor to clean up the queue\n    def __del__(self):\n        while not self.is_empty():\n            self.dequeue()\n\n    # Function to check if the queue is empty\n    def is_empty(self):\n        pass\n\n    # Function to add an element to the end of the queue\n    def enqueue(self, value):\n        pass\n\n    # Function to remove and return the front element of the queue\n    def dequeue(self):\n        pass\n\n    # Function to get the front element without removing it\n    def front(self):\n        pass", "addition_info": ""}, "javascript": {"code_signature": "class Node {\n    constructor(val) { // Constructor to initialize the node\n        this.data = val;   // Data value of the node\n        this.next = null;  // Pointer to the next node in the linked list\n    }\n}\n\n// Queue class\nclass Queue {\n    constructor() { // Constructor to initialize the queue\n        this.head = null;  // Pointer to the front of the queue\n        this.tail = null;  // Pointer to the end of the queue\n    }\n\n    // Destructor to clean up the queue (handled by JavaScript's garbage collector)\n    // In JavaScript, we do not need a destructor like in C++\n    // So this can be omitted or handled in a different way if necessary\n\n    // Function to check if the queue is empty\n    isEmpty() { \n        return this.head === null; // Return true if the queue is empty\n    }\n\n    // Function to add an element to the end of the queue\n    enqueue(value) {\n        const newNode = new Node(value); // Create a new node\n\n        if (this.tail) {\n            this.tail.next = newNode; // Link the new node at the end\n        } else {\n            this.head = newNode; // If the queue is empty, the new node is also the head\n        }\n        this.tail = newNode; // Update the tail to the new node\n    }\n\n    // Function to remove and return the front element of the queue\n    dequeue() {\n        if (this.isEmpty()) {\n            console.error(\"Queue is empty. Cannot dequeue.\");\n            return null; // Return null if the queue is empty\n        }\n\n        const temp = this.head; // Temporarily store the head node\n        const value = this.head.data; // Get the data from the head node\n        this.head = this.head.next; // Move head to the next node\n\n        if (this.head === null) {\n            this.tail = null; // If the queue becomes empty, update the tail as well\n        }\n\n        return value; // Return the dequeued value\n    }\n\n    // Function to get the front element without removing it\n    front() {\n        if (this.isEmpty()) {\n            console.error(\"Queue is empty. Cannot access front.\");\n            return null; // Return null for invalid access\n        }\n        return this.head.data; // Return the front value\n    }\n}", "test_code": "describe(\"Queue Operations\", () => {\n    let queue;\n\n    beforeEach(() => {\n        queue = new Queue(); // Create a new queue before each test\n    });\n\n    test(\"Queue should be empty initially\", () => {\n        expect(queue.isEmpty()).toBe(true);\n    });\n\n    test(\"Enqueue elements\", () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n\n        expect(queue.isEmpty()).toBe(false);\n        expect(queue.front()).toBe(10); // Front element should be 10\n    });\n\n    test(\"Dequeue elements\", () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n\n        const value = queue.dequeue();\n        expect(value).toBe(10); // First dequeued element should be 10\n        expect(queue.front()).toBe(20); // Now front should be 20\n    });\n\n    test(\"Dequeue from an empty queue\", () => {\n        const value = queue.dequeue();\n        expect(value).toBe(null); // Should indicate that the queue is empty\n    });\n\n    test(\"Front element of an empty queue\", () => {\n        const frontValue = queue.front();\n        expect(frontValue).toBe(null); // Should indicate that the queue is empty\n    });\n\n    test(\"Queue should become empty after dequeuing all elements\", () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n\n        queue.dequeue(); // Remove 10\n        queue.dequeue(); // Remove 20\n\n        expect(queue.isEmpty()).toBe(true); // Queue should be empty\n    });\n});", "prompt": "please write a javascript class , the class signature as below class Node {\n    constructor(val) { // Constructor to initialize the node\n        this.data = val;   // Data value of the node\n        this.next = null;  // Pointer to the next node in the linked list\n    }\n}\n\n// Queue class\nclass Queue {\n    constructor() { // Constructor to initialize the queue\n        this.head = null;  // Pointer to the front of the queue\n        this.tail = null;  // Pointer to the end of the queue\n    }\n\n    // Destructor to clean up the queue (handled by JavaScript's garbage collector)\n    // In JavaScript, we do not need a destructor like in C++\n    // So this can be omitted or handled in a different way if necessary\n\n    // Function to check if the queue is empty\n    isEmpty() { \n        return this.head === null; // Return true if the queue is empty\n    }\n\n    // Function to add an element to the end of the queue\n    enqueue(value) {\n        const newNode = new Node(value); // Create a new node\n\n        if (this.tail) {\n            this.tail.next = newNode; // Link the new node at the end\n        } else {\n            this.head = newNode; // If the queue is empty, the new node is also the head\n        }\n        this.tail = newNode; // Update the tail to the new node\n    }\n\n    // Function to remove and return the front element of the queue\n    dequeue() {\n        if (this.isEmpty()) {\n            console.error(\"Queue is empty. Cannot dequeue.\");\n            return null; // Return null if the queue is empty\n        }\n\n        const temp = this.head; // Temporarily store the head node\n        const value = this.head.data; // Get the data from the head node\n        this.head = this.head.next; // Move head to the next node\n\n        if (this.head === null) {\n            this.tail = null; // If the queue becomes empty, update the tail as well\n        }\n\n        return value; // Return the dequeued value\n    }\n\n    // Function to get the front element without removing it\n    front() {\n        if (this.isEmpty()) {\n            console.error(\"Queue is empty. Cannot access front.\");\n            return null; // Return null for invalid access\n        }\n        return this.head.data; // Return the front value\n    }\n}", "addition_info": ""}, "typescript": {"code_signature": "class Node {\n    data: number;       // Data value of the node\n    next: Node | null;  // Pointer to the next node in the linked list\n\n    constructor(val: number) { // Constructor to initialize the node\n        this.data = val;\n        this.next = null; // Initialize next as null\n    }\n}\n\n// Queue class\nclass Queue {\n    private head: Node | null; // Pointer to the front of the queue\n    private tail: Node | null; // Pointer to the end of the queue\n\n    // Constructor to initialize the queue\n    constructor() {\n        this.head = null;\n        this.tail = null;\n    }\n\n    // Destructor equivalent (not required in TypeScript)\n\n    // Function to check if the queue is empty\n    isEmpty(): boolean { \n        // Implementation goes here\n    }\n\n    // Function to add an element to the end of the queue\n    enqueue(value: number): void { \n        // Implementation goes here\n    }\n\n    // Function to remove and return the front element of the queue\n    dequeue(): number { \n        // Implementation goes here\n    }\n\n    // Function to get the front element without removing it\n    front(): number { \n        // Implementation goes here\n    }\n}", "test_code": "describe(\"Queue Operations\", () => {\n    let queue: Queue;\n\n    beforeEach(() => {\n        queue = new Queue(); // Create a new queue instance before each test\n    });\n\n    test(\"Queue should be empty initially\", () => {\n        expect(queue.isEmpty()).toBe(true);\n    });\n\n    test(\"Enqueue elements\", () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n\n        expect(queue.isEmpty()).toBe(false);\n        expect(queue.front()).toBe(10); // Front element should be 10\n    });\n\n    test(\"Dequeue elements\", () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n\n        const value = queue.dequeue();\n        expect(value).toBe(10); // First dequeued element should be 10\n        expect(queue.front()).toBe(20); // Now front should be 20\n    });\n\n    test(\"Dequeue from an empty queue\", () => {\n        const value = queue.dequeue();\n        expect(value).toBe(-1); // Should indicate that the queue is empty\n    });\n\n    test(\"Front element of an empty queue\", () => {\n        const frontValue = queue.front();\n        expect(frontValue).toBe(-1); // Should indicate that the queue is empty\n    });\n\n    test(\"Queue should become empty after dequeuing all elements\", () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n\n        queue.dequeue(); // Remove 10\n        queue.dequeue(); // Remove 20\n\n        expect(queue.isEmpty()).toBe(true); // Queue should be empty\n    });\n});", "prompt": "please write a typescript class , the class signature as below class Node {\n    data: number;       // Data value of the node\n    next: Node | null;  // Pointer to the next node in the linked list\n\n    constructor(val: number) { // Constructor to initialize the node\n        this.data = val;\n        this.next = null; // Initialize next as null\n    }\n}\n\n// Queue class\nclass Queue {\n    private head: Node | null; // Pointer to the front of the queue\n    private tail: Node | null; // Pointer to the end of the queue\n\n    // Constructor to initialize the queue\n    constructor() {\n        this.head = null;\n        this.tail = null;\n    }\n\n    // Destructor equivalent (not required in TypeScript)\n\n    // Function to check if the queue is empty\n    isEmpty(): boolean { \n        // Implementation goes here\n    }\n\n    // Function to add an element to the end of the queue\n    enqueue(value: number): void { \n        // Implementation goes here\n    }\n\n    // Function to remove and return the front element of the queue\n    dequeue(): number { \n        // Implementation goes here\n    }\n\n    // Function to get the front element without removing it\n    front(): number { \n        // Implementation goes here\n    }\n}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n\n// Node structure for linked list\nstruct Node {\n    int data;      // Data value of the node\n    Node* next;    // Pointer to the next node in the linked list\n\n    Node(int val) : data(val), next(nullptr) {} // Constructor to initialize the node\n};\n\n// Queue class\nclass Queue {\nprivate:\n    Node* head; // Pointer to the front of the queue\n    Node* tail; // Pointer to the end of the queue\n\npublic:\n    // Constructor to initialize the queue\n    Queue() : head(nullptr), tail(nullptr) {}\n\n    // Destructor to clean up the queue\n    ~Queue() {\n        while (!isEmpty()) {\n            dequeue();\n        }\n    }\n\n    // Function to check if the queue is empty\n    bool isEmpty() const {}\n\n    // Function to add an element to the end of the queue\n    void enqueue(int value) {}\n\n    // Function to remove and return the front element of the queue\n    int dequeue() {}\n\n    // Function to get the front element without removing it\n    int front() const {}\n};", "test_code": "// Test cases for the Queue class\nTEST_CASE(\"Queue Operations\", \"[Queue]\") {\n    Queue queue;\n\n    SECTION(\"Queue should be empty initially\") {\n        REQUIRE(queue.isEmpty() == true);\n    }\n\n    SECTION(\"Enqueue elements\") {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n\n        REQUIRE(queue.isEmpty() == false);\n        REQUIRE(queue.front() == 10); // Front element should be 10\n    }\n\n    SECTION(\"Dequeue elements\") {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n\n        int value = queue.dequeue();\n        REQUIRE(value == 10); // First dequeued element should be 10\n        REQUIRE(queue.front() == 20); // Now front should be 20\n    }\n\n    SECTION(\"Dequeue from an empty queue\") {\n        int value = queue.dequeue();\n        REQUIRE(value == -1); // Should indicate that the queue is empty\n    }\n\n    SECTION(\"Front element of an empty queue\") {\n        int frontValue = queue.front();\n        REQUIRE(frontValue == -1); // Should indicate that the queue is empty\n    }\n\n    SECTION(\"Queue should become empty after dequeuing all elements\") {\n        queue.enqueue(10);\n        queue.enqueue(20);\n\n        queue.dequeue(); // Remove 10\n        queue.dequeue(); // Remove 20\n\n        REQUIRE(queue.isEmpty() == true); // Queue should be empty\n    }\n}", "prompt": "please write a cpp class , the class signature as below #include <iostream>\n\n// Node structure for linked list\nstruct Node {\n    int data;      // Data value of the node\n    Node* next;    // Pointer to the next node in the linked list\n\n    Node(int val) : data(val), next(nullptr) {} // Constructor to initialize the node\n};\n\n// Queue class\nclass Queue {\nprivate:\n    Node* head; // Pointer to the front of the queue\n    Node* tail; // Pointer to the end of the queue\n\npublic:\n    // Constructor to initialize the queue\n    Queue() : head(nullptr), tail(nullptr) {}\n\n    // Destructor to clean up the queue\n    ~Queue() {\n        while (!isEmpty()) {\n            dequeue();\n        }\n    }\n\n    // Function to check if the queue is empty\n    bool isEmpty() const {}\n\n    // Function to add an element to the end of the queue\n    void enqueue(int value) {}\n\n    // Function to remove and return the front element of the queue\n    int dequeue() {}\n\n    // Function to get the front element without removing it\n    int front() const {}\n};", "addition_info": "struct Node {\n    int data;      // Data value of the node\n    Node* next;    // Pointer to the next node in the linked list\n\n    Node(int val) : data(val), next(nullptr) {} // Constructor to initialize the node\n};"}, "java": {"code_signature": "/**\n * Node class for linked list.\n */\nclass Node {\n    int data;      // Data value of the node\n    Node next;     // Reference to the next node in the linked list\n\n    /**\n     * Constructor to initialize the node.\n     *\n     * @param val the value to initialize the node with\n     */\n    Node(int val) {\n        this.data = val;\n        this.next = null;\n    }\n}\n\n/**\n * Queue class.\n */\npublic class Queue {\n    private Node head; // Reference to the front of the queue\n    private Node tail; // Reference to the end of the queue\n\n    /**\n     * Constructor to initialize the queue.\n     */\n    public Queue() {\n        this.head = null;\n        this.tail = null;\n    }\n\n    /**\n     * Destructor to clean up the queue.\n     * (Note: Not needed in Java due to garbage collection)\n     */\n    // Java does not have destructors, so this part is omitted.\n\n    /**\n     * Function to check if the queue is empty.\n     *\n     * @return true if the queue is empty, false otherwise\n     */\n    public boolean isEmpty() {\n    }\n\n    /**\n     * Function to add an element to the end of the queue.\n     *\n     * @param value the value to add to the queue\n     */\n    public void enqueue(int value) {}\n\n    /**\n     * Function to remove and return the front element of the queue.\n     *\n     * @return the dequeued value\n     */\n    public int dequeue() {}\n\n    /**\n     * Function to get the front element without removing it.\n     *\n     * @return the front value\n     */\n    public int front() {}\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\npublic class Tester {\n    private Queue queue;\n\n    @Before\n    public void setUp() {\n        queue = new Queue(); // Initialize the queue before each test\n    }\n\n    @Test\n    public void testInitialQueueIsEmpty() {\n        assertTrue(\"Queue should be empty initially\", queue.isEmpty());\n    }\n\n    @Test\n    public void testEnqueueElements() {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n\n        assertFalse(\"Queue should not be empty after enqueue\", queue.isEmpty());\n        assertEquals(\"Front element should be 10\", 10, queue.front());\n    }\n\n    @Test\n    public void testDequeueElements() {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n\n        int value = queue.dequeue();\n        assertEquals(\"First dequeued element should be 10\", 10, value);\n        assertEquals(\"Now front should be 20\", 20, queue.front());\n    }\n\n    @Test\n    public void testDequeueFromEmptyQueue() {\n        int value = queue.dequeue();\n        assertEquals(\"Should indicate that the queue is empty\", -1, value);\n    }\n\n    @Test\n    public void testFrontElementOfEmptyQueue() {\n        int frontValue = queue.front();\n        assertEquals(\"Should indicate that the queue is empty\", -1, frontValue);\n    }\n\n    @Test\n    public void testQueueBecomesEmptyAfterDequeueingAllElements() {\n        queue.enqueue(10);\n        queue.enqueue(20);\n\n        queue.dequeue(); // Remove 10\n        queue.dequeue(); // Remove 20\n\n        assertTrue(\"Queue should be empty after dequeuing all elements\", queue.isEmpty());\n    }\n}", "prompt": "please write a java class , the function signature as below /**\n * Node class for linked list.\n */\nclass Node {\n    int data;      // Data value of the node\n    Node next;     // Reference to the next node in the linked list\n\n    /**\n     * Constructor to initialize the node.\n     *\n     * @param val the value to initialize the node with\n     */\n    Node(int val) {\n        this.data = val;\n        this.next = null;\n    }\n}\n\n/**\n * Queue class.\n */\npublic class Queue {\n    private Node head; // Reference to the front of the queue\n    private Node tail; // Reference to the end of the queue\n\n    /**\n     * Constructor to initialize the queue.\n     */\n    public Queue() {\n        this.head = null;\n        this.tail = null;\n    }\n\n    /**\n     * Destructor to clean up the queue.\n     * (Note: Not needed in Java due to garbage collection)\n     */\n    // Java does not have destructors, so this part is omitted.\n\n    /**\n     * Function to check if the queue is empty.\n     *\n     * @return true if the queue is empty, false otherwise\n     */\n    public boolean isEmpty() {\n    }\n\n    /**\n     * Function to add an element to the end of the queue.\n     *\n     * @param value the value to add to the queue\n     */\n    public void enqueue(int value) {}\n\n    /**\n     * Function to remove and return the front element of the queue.\n     *\n     * @return the dequeued value\n     */\n    public int dequeue() {}\n\n    /**\n     * Function to get the front element without removing it.\n     *\n     * @return the front value\n     */\n    public int front() {}\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 599, "code_type": "class", "original_language": "c&cpp", "question_type": "Algorithm and data structure", "summary": "Implement large root heap", "language_version_list": {"python": {"code_signature": "class MaxHeap:\n    def __init__(self):\n        self.heap = []  # List to store heap elements\n\n    # Helper function to maintain the max heap property\n    def heapify_up(self, index):\n\n    # Helper function to maintain the max heap property after deletion\n    def heapify_down(self, index):\n\n    # Insert a new element into the heap\n    def insert(self, value):\n\n    # Remove and return the maximum element from the heap\n    def extract_max(self):\n        \n\n    # Get the maximum element without removing it\n    def get_max(self):\n        \n\n    # Check if the heap is empty\n    def is_empty(self):\n        \n\n    # Get the size of the heap\n    def size(self):\n        ", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create a new instance of MaxHeap before each test.\"\"\"\n        self.maxHeap = MaxHeap()\n\n    def test_initial_state_of_the_heap(self):\n        \"\"\"Test the initial state of the heap.\"\"\"\n        self.assertTrue(self.maxHeap.is_empty())\n        self.assertEqual(self.maxHeap.size(), 0)\n\n    def test_insert_elements_into_the_heap(self):\n        \"\"\"Test inserting elements into the heap.\"\"\"\n        self.maxHeap.insert(10)\n        self.maxHeap.insert(20)\n        self.maxHeap.insert(5)\n        self.assertFalse(self.maxHeap.is_empty())\n        self.assertEqual(self.maxHeap.size(), 3)\n        self.assertEqual(self.maxHeap.get_max(), 20)  # The maximum should be 20\n\n    def test_extract_maximum_element_from_the_heap(self):\n        \"\"\"Test extracting the maximum element from the heap.\"\"\"\n        self.maxHeap.insert(10)\n        self.maxHeap.insert(30)\n        self.maxHeap.insert(20)\n\n        maxElement = self.maxHeap.extract_max()\n        self.assertEqual(maxElement, 30)  # The maximum extracted should be 30\n        self.assertEqual(self.maxHeap.get_max(), 20)  # The next maximum should be 20\n        self.assertEqual(self.maxHeap.size(), 2)  # Size should be 2 after extraction\n\n    def test_heap_property_after_multiple_operations(self):\n        \"\"\"Test that the heap maintains max heap property after multiple operations.\"\"\"\n        self.maxHeap.insert(15)\n        self.maxHeap.insert(10)\n        self.maxHeap.insert(30)\n        self.maxHeap.insert(20)\n        self.maxHeap.insert(25)\n\n        # Current max should be 30\n        self.assertEqual(self.maxHeap.get_max(), 30)\n        self.maxHeap.extract_max()  # Remove 30\n\n        # After removal, the new max should be 25\n        self.assertEqual(self.maxHeap.get_max(), 25)\n        self.maxHeap.extract_max()  # Remove 25\n\n        # After removal, the new max should be 20\n        self.assertEqual(self.maxHeap.get_max(), 20)\n\n        # The size of the heap should be 3 now\n        self.assertEqual(self.maxHeap.size(), 3)", "prompt": "please write a python class , the class signature as below class MaxHeap:\n    def __init__(self):\n        self.heap = []  # List to store heap elements\n\n    # Helper function to maintain the max heap property\n    def heapify_up(self, index):\n\n    # Helper function to maintain the max heap property after deletion\n    def heapify_down(self, index):\n\n    # Insert a new element into the heap\n    def insert(self, value):\n\n    # Remove and return the maximum element from the heap\n    def extract_max(self):\n        \n\n    # Get the maximum element without removing it\n    def get_max(self):\n        \n\n    # Check if the heap is empty\n    def is_empty(self):\n        \n\n    # Get the size of the heap\n    def size(self):\n        ", "addition_info": ""}, "javascript": {"code_signature": "class MaxHeap {\n    constructor() {\n        this.heap = []; // Array to store heap elements\n    }\n\n    // Helper function to maintain the max heap property\n    heapifyUp(index) {}\n\n    // Helper function to maintain the max heap property after deletion\n    heapifyDown(index) {}\n\n    // Insert a new element into the heap\n    insert(value) {}\n\n    // Remove and return the maximum element from the heap\n    extractMax() {}\n\n    // Get the maximum element without removing it\n    getMax() {}\n\n    // Check if the heap is empty\n    isEmpty() {}\n\n    // Get the size of the heap\n    size() {}\n}", "test_code": "describe(\"MaxHeap Operations\", () => {\n    let maxHeap;\n\n    beforeEach(() => {\n        maxHeap = new MaxHeap(); // Initialize a new MaxHeap before each test\n    });\n\n    test(\"Initial state of the heap\", () => {\n        expect(maxHeap.isEmpty()).toBe(true);\n        expect(maxHeap.size()).toBe(0);\n    });\n\n    test(\"Insert elements into the heap\", () => {\n        maxHeap.insert(10);\n        maxHeap.insert(20);\n        maxHeap.insert(5);\n\n        expect(maxHeap.isEmpty()).toBe(false);\n        expect(maxHeap.size()).toBe(3);\n        expect(maxHeap.getMax()).toBe(20); // The maximum should be 20\n    });\n\n    test(\"Extract maximum element from the heap\", () => {\n        maxHeap.insert(10);\n        maxHeap.insert(30);\n        maxHeap.insert(20);\n\n        const maxElement = maxHeap.extractMax();\n        expect(maxElement).toBe(30); // The maximum extracted should be 30\n        expect(maxHeap.getMax()).toBe(20); // The next maximum should be 20\n        expect(maxHeap.size()).toBe(2); // Size should be 2 after extraction\n    });\n\n    test(\"Heap should maintain max heap property after multiple operations\", () => {\n        maxHeap.insert(15);\n        maxHeap.insert(10);\n        maxHeap.insert(30);\n        maxHeap.insert(20);\n        maxHeap.insert(25);\n\n        // Current max should be 30\n        expect(maxHeap.getMax()).toBe(30);\n\n        maxHeap.extractMax(); // Remove 30\n        // After removal, the new max should be 25\n        expect(maxHeap.getMax()).toBe(25);\n\n        maxHeap.extractMax(); // Remove 25\n        // After removal, the new max should be 20\n        expect(maxHeap.getMax()).toBe(20);\n\n        // The size of the heap should be 3 now\n        expect(maxHeap.size()).toBe(3);\n    });\n});", "prompt": "please write a javascript class , the class signature as below class MaxHeap {\n    constructor() {\n        this.heap = []; // Array to store heap elements\n    }\n\n    // Helper function to maintain the max heap property\n    heapifyUp(index) {}\n\n    // Helper function to maintain the max heap property after deletion\n    heapifyDown(index) {}\n\n    // Insert a new element into the heap\n    insert(value) {}\n\n    // Remove and return the maximum element from the heap\n    extractMax() {}\n\n    // Get the maximum element without removing it\n    getMax() {}\n\n    // Check if the heap is empty\n    isEmpty() {}\n\n    // Get the size of the heap\n    size() {}\n}", "addition_info": ""}, "typescript": {"code_signature": "class MaxHeap {\n    private heap: number[]; // Array to store heap elements\n\n    // Helper function to maintain the max heap property\n    private heapifyUp(index: number): void {}\n\n    // Helper function to maintain the max heap property after deletion\n    private heapifyDown(index: number): void {}\n\n    // Insert a new element into the heap\n    public insert(value: number): void {}\n\n    // Remove and return the maximum element from the heap\n    public extractMax(): number {}\n\n    // Get the maximum element without removing it\n    public getMax(): number {}\n\n    // Check if the heap is empty\n    public isEmpty(): boolean {}\n\n    // Get the size of the heap\n    public size(): number {}\n}", "test_code": "describe(\"MaxHeap Operations\", () => {\n    let maxHeap: MaxHeap;\n\n    beforeEach(() => {\n        maxHeap = new MaxHeap(); // Initialize a new MaxHeap before each test\n    });\n\n    test(\"Initial state of the heap\", () => {\n        expect(maxHeap.isEmpty()).toBe(true);\n        expect(maxHeap.size()).toBe(0);\n    });\n\n    test(\"Insert elements into the heap\", () => {\n        maxHeap.insert(10);\n        maxHeap.insert(20);\n        maxHeap.insert(5);\n\n        expect(maxHeap.isEmpty()).toBe(false);\n        expect(maxHeap.size()).toBe(3);\n        expect(maxHeap.getMax()).toBe(20); // The maximum should be 20\n    });\n\n    test(\"Extract maximum element from the heap\", () => {\n        maxHeap.insert(10);\n        maxHeap.insert(30);\n        maxHeap.insert(20);\n\n        const maxElement = maxHeap.extractMax();\n        expect(maxElement).toBe(30); // The maximum extracted should be 30\n        expect(maxHeap.getMax()).toBe(20); // The next maximum should be 20\n        expect(maxHeap.size()).toBe(2); // Size should be 2 after extraction\n    });\n\n    test(\"Heap should maintain max heap property after multiple operations\", () => {\n        maxHeap.insert(15);\n        maxHeap.insert(10);\n        maxHeap.insert(30);\n        maxHeap.insert(20);\n        maxHeap.insert(25);\n\n        // Current max should be 30\n        expect(maxHeap.getMax()).toBe(30);\n\n        maxHeap.extractMax(); // Remove 30\n        // After removal, the new max should be 25\n        expect(maxHeap.getMax()).toBe(25);\n\n        maxHeap.extractMax(); // Remove 25\n        // After removal, the new max should be 20\n        expect(maxHeap.getMax()).toBe(20);\n\n        // The size of the heap should be 3 now\n        expect(maxHeap.size()).toBe(3);\n    });\n});", "prompt": "please write a typescript class , the class signature as below class MaxHeap {\n    private heap: number[]; // Array to store heap elements\n\n    // Helper function to maintain the max heap property\n    private heapifyUp(index: number): void {}\n\n    // Helper function to maintain the max heap property after deletion\n    private heapifyDown(index: number): void {}\n\n    // Insert a new element into the heap\n    public insert(value: number): void {}\n\n    // Remove and return the maximum element from the heap\n    public extractMax(): number {}\n\n    // Get the maximum element without removing it\n    public getMax(): number {}\n\n    // Check if the heap is empty\n    public isEmpty(): boolean {}\n\n    // Get the size of the heap\n    public size(): number {}\n}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass MaxHeap {\nprivate:\n    std::vector<int> heap; // Vector to store heap elements\n\n    // Helper function to maintain the max heap property\n    void heapifyUp(int index) {}\n\n    // Helper function to maintain the max heap property after deletion\n    void heapifyDown(int index) {}\n\npublic:\n    // Insert a new element into the heap\n    void insert(int value) {}\n\n    // Remove and return the maximum element from the heap\n    int extractMax() {}\n\n    // Get the maximum element without removing it\n    int getMax() const {}\n\n    // Check if the heap is empty\n    bool isEmpty() const {}\n\n    // Get the size of the heap\n    size_t size() const {}\n\n}", "test_code": "TEST_CASE(\"MaxHeap Operations\", \"[MaxHeap]\") {\n    MaxHeap maxHeap;\n\n    SECTION(\"Initial state of the heap\") {\n        REQUIRE(maxHeap.isEmpty() == true);\n        REQUIRE(maxHeap.size() == 0);\n    }\n\n    SECTION(\"Insert elements into the heap\") {\n        maxHeap.insert(10);\n        maxHeap.insert(20);\n        maxHeap.insert(5);\n\n        REQUIRE(maxHeap.isEmpty() == false);\n        REQUIRE(maxHeap.size() == 3);\n        REQUIRE(maxHeap.getMax() == 20); // The maximum should be 20\n    }\n\n    SECTION(\"Extract maximum element from the heap\") {\n        maxHeap.insert(10);\n        maxHeap.insert(30);\n        maxHeap.insert(20);\n\n        int maxElement = maxHeap.extractMax();\n        REQUIRE(maxElement == 30); // The maximum extracted should be 30\n        REQUIRE(maxHeap.getMax() == 20); // The next maximum should be 20\n        REQUIRE(maxHeap.size() == 2); // Size should be 2 after extraction\n    }\n\n    SECTION(\"Heap should maintain max heap property after multiple operations\") {\n        maxHeap.insert(15);\n        maxHeap.insert(10);\n        maxHeap.insert(30);\n        maxHeap.insert(20);\n        maxHeap.insert(25);\n\n        // Current max should be 30\n        REQUIRE(maxHeap.getMax() == 30);\n\n        maxHeap.extractMax(); // Remove 30\n        // After removal, the new max should be 25\n        REQUIRE(maxHeap.getMax() == 25);\n\n        maxHeap.extractMax(); // Remove 25\n        // After removal, the new max should be 20\n        REQUIRE(maxHeap.getMax() == 20);\n\n        // The size of the heap should be 3 now\n        REQUIRE(maxHeap.size() == 3);\n    }\n}", "prompt": "please write a cpp class , the class signature as below #include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass MaxHeap {\nprivate:\n    std::vector<int> heap; // Vector to store heap elements\n\n    // Helper function to maintain the max heap property\n    void heapifyUp(int index) {}\n\n    // Helper function to maintain the max heap property after deletion\n    void heapifyDown(int index) {}\n\npublic:\n    // Insert a new element into the heap\n    void insert(int value) {}\n\n    // Remove and return the maximum element from the heap\n    int extractMax() {}\n\n    // Get the maximum element without removing it\n    int getMax() const {}\n\n    // Check if the heap is empty\n    bool isEmpty() const {}\n\n    // Get the size of the heap\n    size_t size() const {}\n\n}", "addition_info": ""}, "java": {"code_signature": "public class MaxHeap {\n    private List<Integer> heap;\n\n    /**\n     * Constructor to initialize the heap.\n     */\n    public MaxHeap() {\n        heap = new ArrayList<>();\n    }\n\n    /**\n     * Helper function to maintain the max heap property.\n     *\n     * @param index The index of the element to heapify up.\n     */\n    private void heapifyUp(int index) {\n    }\n\n    /**\n     * Helper function to maintain the max heap property after deletion.\n     *\n     * @param index The index of the element to heapify down.\n     */\n    private void heapifyDown(int index) {\n    }\n\n    /**\n     * Inserts a new element into the heap.\n     *\n     * @param value The value to be inserted.\n     */\n    public void insert(int value) {\n\n    }\n\n    /**\n     * Removes and returns the maximum element from the heap.\n     *\n     * @return The maximum element in the heap.\n     * @throws IllegalStateException if the heap is empty.\n     */\n    public int extractMax() {\n    }\n\n    /**\n     * Gets the maximum element without removing it.\n     *\n     * @return The maximum element in the heap.\n     * @throws IllegalStateException if the heap is empty.\n     */\n    public int getMax() {\n\n    }\n\n    /**\n     * Checks if the heap is empty.\n     *\n     * @return true if the heap is empty, false otherwise.\n     */\n    public boolean isEmpty() {\n    }\n\n    /**\n     * Gets the size of the heap.\n     *\n     * @return The number of elements in the heap.\n     */\n    public int size() {\n    }\n\n    /**\n     * Swaps two elements in the heap.\n     *\n     * @param index1 The index of the first element.\n     * @param index2 The index of the second element.\n     */\n    private void swap(int index1, int index2) {\n\n    }\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Tester class to validate the functionality of MaxHeap.\n */\npublic class Tester {\n    private MaxHeap maxHeap;\n\n    /**\n     * Set up a new MaxHeap instance before each test.\n     */\n    @Before\n    public void setUp() {\n        maxHeap = new MaxHeap();\n    }\n\n    /**\n     * Test the initial state of the heap.\n     */\n    @Test\n    public void testInitialState() {\n        assertTrue(maxHeap.isEmpty());\n        assertEquals(0, maxHeap.size());\n    }\n\n    /**\n     * Test inserting elements into the heap.\n     */\n    @Test\n    public void testInsertElements() {\n        maxHeap.insert(10);\n        maxHeap.insert(20);\n        maxHeap.insert(5);\n\n        assertFalse(maxHeap.isEmpty());\n        assertEquals(3, maxHeap.size());\n        assertEquals(20, maxHeap.getMax()); // The maximum should be 20\n    }\n\n    /**\n     * Test extracting the maximum element from the heap.\n     */\n    @Test\n    public void testExtractMax() {\n        maxHeap.insert(10);\n        maxHeap.insert(30);\n        maxHeap.insert(20);\n\n        int maxElement = maxHeap.extractMax();\n        assertEquals(30, maxElement); // The maximum extracted should be 30\n        assertEquals(20, maxHeap.getMax()); // The next maximum should be 20\n        assertEquals(2, maxHeap.size()); // Size should be 2 after extraction\n    }\n\n    /**\n     * Test that the heap maintains the max heap property after multiple operations.\n     */\n    @Test\n    public void testMaxHeapProperty() {\n        maxHeap.insert(15);\n        maxHeap.insert(10);\n        maxHeap.insert(30);\n        maxHeap.insert(20);\n        maxHeap.insert(25);\n\n        // Current max should be 30\n        assertEquals(30, maxHeap.getMax());\n\n        maxHeap.extractMax(); // Remove 30\n        // After removal, the new max should be 25\n        assertEquals(25, maxHeap.getMax());\n\n        maxHeap.extractMax(); // Remove 25\n        // After removal, the new max should be 20\n        assertEquals(20, maxHeap.getMax());\n\n        // The size of the heap should be 3 now\n        assertEquals(3, maxHeap.size());\n    }\n}", "prompt": "please write a java class , the function signature as below public class MaxHeap {\n    private List<Integer> heap;\n\n    /**\n     * Constructor to initialize the heap.\n     */\n    public MaxHeap() {\n        heap = new ArrayList<>();\n    }\n\n    /**\n     * Helper function to maintain the max heap property.\n     *\n     * @param index The index of the element to heapify up.\n     */\n    private void heapifyUp(int index) {\n    }\n\n    /**\n     * Helper function to maintain the max heap property after deletion.\n     *\n     * @param index The index of the element to heapify down.\n     */\n    private void heapifyDown(int index) {\n    }\n\n    /**\n     * Inserts a new element into the heap.\n     *\n     * @param value The value to be inserted.\n     */\n    public void insert(int value) {\n\n    }\n\n    /**\n     * Removes and returns the maximum element from the heap.\n     *\n     * @return The maximum element in the heap.\n     * @throws IllegalStateException if the heap is empty.\n     */\n    public int extractMax() {\n    }\n\n    /**\n     * Gets the maximum element without removing it.\n     *\n     * @return The maximum element in the heap.\n     * @throws IllegalStateException if the heap is empty.\n     */\n    public int getMax() {\n\n    }\n\n    /**\n     * Checks if the heap is empty.\n     *\n     * @return true if the heap is empty, false otherwise.\n     */\n    public boolean isEmpty() {\n    }\n\n    /**\n     * Gets the size of the heap.\n     *\n     * @return The number of elements in the heap.\n     */\n    public int size() {\n    }\n\n    /**\n     * Swaps two elements in the heap.\n     *\n     * @param index1 The index of the first element.\n     * @param index2 The index of the second element.\n     */\n    private void swap(int index1, int index2) {\n\n    }\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 601, "code_type": "method", "original_language": "c&cpp", "question_type": "Data processing and transformation", "summary": "Count the number of words in a string", "language_version_list": {"python": {"code_signature": "def count_words(s: str) -> int:\n    \"\"\"\n    Count the number of words in a given string.\n\n    A word is defined as a sequence of characters separated by whitespace.\n    This function handles leading and trailing whitespace, as well as\n    multiple spaces between words.\n\n    Args:\n        s (str): The input string in which words are to be counted.\n\n    Returns:\n        int: The count of words in the input string.\n    \"\"\"", "test_code": "import unittest\n\n\n\nclass TestWordCount(unittest.TestCase):\n    \n    def test_empty_string(self):\n        self.assertEqual(count_words(\"\"), 0)  # Empty string\n\n    def test_spaces_only(self):\n        self.assertEqual(count_words(\"     \"), 0)  # String with only spaces\n\n    def test_single_word(self):\n        self.assertEqual(count_words(\"Hello\"), 1)  # Single word\n\n    def test_multiple_words_single_spaces(self):\n        self.assertEqual(count_words(\"This is a test string\"), 5)  # Multiple words with single spaces\n\n    def test_multiple_spaces_between_words(self):\n        self.assertEqual(count_words(\"This    is   a   test   string\"), 5)  # Multiple spaces between words\n\n    def test_leading_trailing_spaces(self):\n        self.assertEqual(count_words(\"   Hello world!   \"), 2)  # Leading and trailing spaces", "prompt": "please write a python function , the function signature as below def count_words(s: str) -> int:\n    \"\"\"\n    Count the number of words in a given string.\n\n    A word is defined as a sequence of characters separated by whitespace.\n    This function handles leading and trailing whitespace, as well as\n    multiple spaces between words.\n\n    Args:\n        s (str): The input string in which words are to be counted.\n\n    Returns:\n        int: The count of words in the input string.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Counts the number of words in a given string.\n *\n * A word is defined as a sequence of characters separated by whitespace.\n * This function handles leading and trailing whitespace, as well as\n * multiple spaces between words.\n *\n * @param {string} str The input string in which words are to be counted.\n * @return {number} The count of words in the input string.\n */\nfunction countWords(str) {\n    // Initialize a word count variable\n    let wordCount = 0; // Use let for block scoping\n    const words = str.trim().split(/\\s+/); // Split the string by whitespace\n\n    // Count the words\n    for (const word of words) {\n        if (word) { // Check if the word is not empty\n            wordCount++; // Increment the count for each word found\n        }\n    }\n\n    return wordCount; // Return the total word count\n}", "test_code": "describe('Count words in various strings', () => {\n    test('Empty string', () => {\n        expect(countWords(\"\")).toBe(0);\n    });\n\n    test('String with only spaces', () => {\n        expect(countWords(\"     \")).toBe(0);\n    });\n\n    test('Single word', () => {\n        expect(countWords(\"Hello\")).toBe(1);\n    });\n\n    test('Multiple words with single spaces', () => {\n        expect(countWords(\"This is a test string\")).toBe(5);\n    });\n\n    test('Multiple spaces between words', () => {\n        expect(countWords(\"This    is   a   test   string\")).toBe(5);\n    });\n\n    test('Leading and trailing spaces', () => {\n        expect(countWords(\"   Hello world!   \")).toBe(2);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Counts the number of words in a given string.\n *\n * A word is defined as a sequence of characters separated by whitespace.\n * This function handles leading and trailing whitespace, as well as\n * multiple spaces between words.\n *\n * @param {string} str The input string in which words are to be counted.\n * @return {number} The count of words in the input string.\n */\nfunction countWords(str) {\n    // Initialize a word count variable\n    let wordCount = 0; // Use let for block scoping\n    const words = str.trim().split(/\\s+/); // Split the string by whitespace\n\n    // Count the words\n    for (const word of words) {\n        if (word) { // Check if the word is not empty\n            wordCount++; // Increment the count for each word found\n        }\n    }\n\n    return wordCount; // Return the total word count\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Counts the number of words in a given string.\n *\n * A word is defined as a sequence of characters separated by whitespace.\n * This function handles leading and trailing whitespace, as well as\n * multiple spaces between words.\n *\n * @param {string} str The input string in which words are to be counted.\n * @return {number} The count of words in the input string.\n */\nfunction countWords(str: string): number {}", "test_code": "describe('Count words in various strings', () => {\n    test('Empty string', () => {\n        expect(countWords(\"\")).toBe(0);\n    });\n\n    test('String with only spaces', () => {\n        expect(countWords(\"     \")).toBe(0);\n    });\n\n    test('Single word', () => {\n        expect(countWords(\"Hello\")).toBe(1);\n    });\n\n    test('Multiple words with single spaces', () => {\n        expect(countWords(\"This is a test string\")).toBe(5);\n    });\n\n    test('Multiple spaces between words', () => {\n        expect(countWords(\"This    is   a   test   string\")).toBe(5);\n    });\n\n    test('Leading and trailing spaces', () => {\n        expect(countWords(\"   Hello world!   \")).toBe(2);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Counts the number of words in a given string.\n *\n * A word is defined as a sequence of characters separated by whitespace.\n * This function handles leading and trailing whitespace, as well as\n * multiple spaces between words.\n *\n * @param {string} str The input string in which words are to be counted.\n * @return {number} The count of words in the input string.\n */\nfunction countWords(str: string): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <sstream>\n#include <string>\n\n/**\n * @brief Counts the number of words in a given string.\n *\n * A word is defined as a sequence of characters separated by whitespace.\n * This function handles leading and trailing whitespace, as well as\n * multiple spaces between words.\n *\n * @param str The input string in which words are to be counted.\n * @return int The count of words in the input string.\n */\nint countWords(const std::string &str) {}", "test_code": "// Test cases\nTEST_CASE(\"Count words in various strings\") {\n    SECTION(\"Empty string\") {\n        REQUIRE(countWords(\"\") == 0);\n    }\n\n    SECTION(\"String with only spaces\") {\n        REQUIRE(countWords(\"     \") == 0);\n    }\n\n    SECTION(\"Single word\") {\n        REQUIRE(countWords(\"Hello\") == 1);\n    }\n\n    SECTION(\"Multiple words with single spaces\") {\n        REQUIRE(countWords(\"This is a test string\") == 5);\n    }\n\n    SECTION(\"Multiple spaces between words\") {\n        REQUIRE(countWords(\"This    is   a   test   string\") == 5);\n    }\n\n    SECTION(\"Leading and trailing spaces\") {\n        REQUIRE(countWords(\"   Hello world!   \") == 2);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <sstream>\n#include <string>\n\n/**\n * @brief Counts the number of words in a given string.\n *\n * A word is defined as a sequence of characters separated by whitespace.\n * This function handles leading and trailing whitespace, as well as\n * multiple spaces between words.\n *\n * @param str The input string in which words are to be counted.\n * @return int The count of words in the input string.\n */\nint countWords(const std::string &str) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Counts the number of words in a given string.\n *\n * A word is defined as a sequence of characters separated by whitespace.\n * This method handles leading and trailing whitespace, as well as\n * multiple spaces between words.\n *\n * @param str The input string in which words are to be counted.\n * @return int The count of words in the input string.\n */\npublic static int countWords(String str) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testCountWordsInVariousStrings() {\n        // Empty string\n        assertEquals(0, Answer.countWords(\"\"));\n\n        // String with only spaces\n        assertEquals(0, Answer.countWords(\"     \"));\n\n        // Single word\n        assertEquals(1, Answer.countWords(\"Hello\"));\n\n        // Multiple words with single spaces\n        assertEquals(5, Answer.countWords(\"This is a test string\"));\n\n        // Multiple spaces between words\n        assertEquals(5, Answer.countWords(\"This    is   a   test   string\"));\n\n        // Leading and trailing spaces\n        assertEquals(2, Answer.countWords(\"   Hello world!   \"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Counts the number of words in a given string.\n *\n * A word is defined as a sequence of characters separated by whitespace.\n * This method handles leading and trailing whitespace, as well as\n * multiple spaces between words.\n *\n * @param str The input string in which words are to be counted.\n * @return int The count of words in the input string.\n */\npublic static int countWords(String str) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 603, "code_type": "method", "original_language": "c&cpp", "question_type": "Scientific computation and numerical analysis", "summary": "Test whether a year is a leap year or a normal year\n", "language_version_list": {"python": {"code_signature": "def extract_string_from_braces(input: str) -> str:\n    \"\"\"\n    Extracts the string contained in the first pair of braces `{}` from the input string.\n\n    Args:\n        input (str): The input string from which the braces content will be extracted.\n\n    Returns:\n        str: A substring enclosed within the first pair of braces, or an error message if braces are missing.\n    \"\"\"\n\n    start_index = input.find(\"{\")\n    if start_index == -1:\n        return \"Error: No opening brace found\"\n\n    end_index = input.find(\"}\")\n    if end_index == -1:\n        return \"Error: No closing brace found\"\n\n    return input[start_index+1:end_index]\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n    \"\"\"Test cases for extract_string_from_braces function.\"\"\"\n\n    def test_basic_extraction(self):\n        \"\"\"Basic extraction.\"\"\"\n        input_data = \"This is a sample text with some data {data: \\\"value\\\"} and more text.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"data: \\\"value\\\"\")\n\n    def test_no_braces(self):\n        \"\"\"No braces.\"\"\"\n        input_data = \"This string has no braces.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"No opening brace found.\")\n\n    def test_only_opening_brace(self):\n        \"\"\"Only opening brace.\"\"\"\n        input_data = \"This string has an opening brace { but no closing brace.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"No closing brace found.\")\n\n    def test_only_closing_brace(self):\n        \"\"\"Only closing brace.\"\"\"\n        input_data = \"This string has a closing brace } but no opening brace.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"No opening brace found.\")\n\n    def test_multiple_braces(self):\n        \"\"\"Multiple braces.\"\"\"\n        input_data = \"First {first} and second {second} braces.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"first\")\n\n    def test_empty_braces(self):\n        \"\"\"Empty braces.\"\"\"\n        input_data = \"This string has empty braces {} and some text.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"\")\n\n\nif __name__ == '__main__':\n    unittest.main()", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    \"\"\" Test cases for the leap year function. \"\"\"\n\n    def test_divisible_by_4_but_not_by_100(self):\n        \"\"\" Years that are leap years. \"\"\"\n        self.assertTrue(is_leap_year(2024))  # 2024 is a leap year\n        self.assertTrue(is_leap_year(2000))  # 2000 is a leap year (divisible by 400)\n        self.assertTrue(is_leap_year(1996))  # 1996 is a leap year\n        self.assertTrue(is_leap_year(2004))  # 2004 is a leap year\n\n    def test_divisible_by_100_but_not_by_400(self):\n        \"\"\" Years that are not leap years. \"\"\"\n        self.assertFalse(is_leap_year(1900))  # 1900 is not a leap year\n        self.assertFalse(is_leap_year(2100))  # 2100 is not a leap year\n        self.assertFalse(is_leap_year(1800))  # 1800 is not a leap year\n\n    def test_divisible_by_400(self):\n        \"\"\" Years that are leap years. \"\"\"\n        self.assertTrue(is_leap_year(2400))  # 2400 is a leap year\n        self.assertTrue(is_leap_year(1600))  # 1600 is a leap year\n\n    def test_normal_years(self):\n        \"\"\" Years that are normal years. \"\"\"\n        self.assertFalse(is_leap_year(1997))  # 1997 is not a leap year\n        self.assertFalse(is_leap_year(1998))  # 1998 is not a leap year\n        self.assertFalse(is_leap_year(1999))  # 1999 is not a leap year\n", "prompt": "please write a python function , the function signature as below def extract_string_from_braces(input: str) -> str:\n    \"\"\"\n    Extracts the string contained in the first pair of braces `{}` from the input string.\n\n    Args:\n        input (str): The input string from which the braces content will be extracted.\n\n    Returns:\n        str: A substring enclosed within the first pair of braces, or an error message if braces are missing.\n    \"\"\"\n\n    start_index = input.find(\"{\")\n    if start_index == -1:\n        return \"Error: No opening brace found\"\n\n    end_index = input.find(\"}\")\n    if end_index == -1:\n        return \"Error: No closing brace found\"\n\n    return input[start_index+1:end_index]\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n    \"\"\"Test cases for extract_string_from_braces function.\"\"\"\n\n    def test_basic_extraction(self):\n        \"\"\"Basic extraction.\"\"\"\n        input_data = \"This is a sample text with some data {data: \\\"value\\\"} and more text.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"data: \\\"value\\\"\")\n\n    def test_no_braces(self):\n        \"\"\"No braces.\"\"\"\n        input_data = \"This string has no braces.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"No opening brace found.\")\n\n    def test_only_opening_brace(self):\n        \"\"\"Only opening brace.\"\"\"\n        input_data = \"This string has an opening brace { but no closing brace.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"No closing brace found.\")\n\n    def test_only_closing_brace(self):\n        \"\"\"Only closing brace.\"\"\"\n        input_data = \"This string has a closing brace } but no opening brace.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"No opening brace found.\")\n\n    def test_multiple_braces(self):\n        \"\"\"Multiple braces.\"\"\"\n        input_data = \"First {first} and second {second} braces.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"first\")\n\n    def test_empty_braces(self):\n        \"\"\"Empty braces.\"\"\"\n        input_data = \"This string has empty braces {} and some text.\"\n        result = extract_string_from_braces(input_data)\n        self.assertEqual(result, \"\")\n\n\nif __name__ == '__main__':\n    unittest.main()", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Checks if a given year is a leap year.\n *\n * @param {number} year - The year to check.\n * @return {boolean} True if the year is a leap year, false otherwise.\n */\nfunction isLeapYear(year) {}", "test_code": "describe(\"Leap Year Test Cases\", () => {\n    test(\"Divisible by 4 but not by 100\", () => {\n        // Years that are leap years\n        expect(isLeapYear(2024)).toBe(true); // 2024 is a leap year\n        expect(isLeapYear(2000)).toBe(true); // 2000 is a leap year (divisible by 400)\n        expect(isLeapYear(1996)).toBe(true); // 1996 is a leap year\n        expect(isLeapYear(2004)).toBe(true); // 2004 is a leap year\n    });\n\n    test(\"Divisible by 100 but not by 400\", () => {\n        // Years that are not leap years\n        expect(isLeapYear(1900)).toBe(false); // 1900 is not a leap year\n        expect(isLeapYear(2100)).toBe(false); // 2100 is not a leap year\n        expect(isLeapYear(1800)).toBe(false); // 1800 is not a leap year\n    });\n\n    test(\"Divisible by 400\", () => {\n        // Years that are leap years\n        expect(isLeapYear(2400)).toBe(true); // 2400 is a leap year\n        expect(isLeapYear(1600)).toBe(true); // 1600 is a leap year\n    });\n\n    test(\"Normal years\", () => {\n        // Years that are normal years\n        expect(isLeapYear(1997)).toBe(false); // 1997 is not a leap year\n        expect(isLeapYear(1998)).toBe(false); // 1998 is not a leap year\n        expect(isLeapYear(1999)).toBe(false); // 1999 is not a leap year\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Checks if a given year is a leap year.\n *\n * @param {number} year - The year to check.\n * @return {boolean} True if the year is a leap year, false otherwise.\n */\nfunction isLeapYear(year) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Checks if a given year is a leap year.\n *\n * @param year The year to check.\n * @return True if the year is a leap year, false otherwise.\n */\nfunction isLeapYear(year: number): boolean {}", "test_code": "describe(\"Leap Year Test Cases\", () => {\n    test(\"Divisible by 4 but not by 100\", () => {\n        // Years that are leap years\n        expect(isLeapYear(2024)).toBe(true); // 2024 is a leap year\n        expect(isLeapYear(2000)).toBe(true); // 2000 is a leap year (divisible by 400)\n        expect(isLeapYear(1996)).toBe(true); // 1996 is a leap year\n        expect(isLeapYear(2004)).toBe(true); // 2004 is a leap year\n    });\n\n    test(\"Divisible by 100 but not by 400\", () => {\n        // Years that are not leap years\n        expect(isLeapYear(1900)).toBe(false); // 1900 is not a leap year\n        expect(isLeapYear(2100)).toBe(false); // 2100 is not a leap year\n        expect(isLeapYear(1800)).toBe(false); // 1800 is not a leap year\n    });\n\n    test(\"Divisible by 400\", () => {\n        // Years that are leap years\n        expect(isLeapYear(2400)).toBe(true); // 2400 is a leap year\n        expect(isLeapYear(1600)).toBe(true); // 1600 is a leap year\n    });\n\n    test(\"Normal years\", () => {\n        // Years that are normal years\n        expect(isLeapYear(1997)).toBe(false); // 1997 is not a leap year\n        expect(isLeapYear(1998)).toBe(false); // 1998 is not a leap year\n        expect(isLeapYear(1999)).toBe(false); // 1999 is not a leap year\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Checks if a given year is a leap year.\n *\n * @param year The year to check.\n * @return True if the year is a leap year, false otherwise.\n */\nfunction isLeapYear(year: number): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n\n/**\n * @brief Checks if a given year is a leap year.\n *\n * @param year The year to check.\n * @return True if the year is a leap year, false otherwise.\n */\nbool isLeapYear(int year) {}", "test_code": "TEST_CASE(\"Leap Year Test Cases\") {\n    SECTION(\"Divisible by 4 but not by 100\") {\n        // Years that are leap years\n        REQUIRE(isLeapYear(2024) == true); // 2024 is a leap year\n        REQUIRE(isLeapYear(2000) == true); // 2000 is a leap year (divisible by 400)\n        REQUIRE(isLeapYear(1996) == true); // 1996 is a leap year\n        REQUIRE(isLeapYear(2004) == true); // 2004 is a leap year\n    }\n\n    SECTION(\"Divisible by 100 but not by 400\") {\n        // Years that are not leap years\n        REQUIRE(isLeapYear(1900) == false); // 1900 is not a leap year\n        REQUIRE(isLeapYear(2100) == false); // 2100 is not a leap year\n        REQUIRE(isLeapYear(1800) == false); // 1800 is not a leap year\n    }\n\n    SECTION(\"Divisible by 400\") {\n        // Years that are leap years\n        REQUIRE(isLeapYear(2400) == true); // 2400 is a leap year\n        REQUIRE(isLeapYear(1600) == true); // 1600 is a leap year\n    }\n\n    SECTION(\"Normal years\") {\n        // Years that are normal years\n        REQUIRE(isLeapYear(1997) == false); // 1997 is not a leap year\n        REQUIRE(isLeapYear(1998) == false); // 1998 is not a leap year\n        REQUIRE(isLeapYear(1999) == false); // 1999 is not a leap year\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n\n/**\n * @brief Checks if a given year is a leap year.\n *\n * @param year The year to check.\n * @return True if the year is a leap year, false otherwise.\n */\nbool isLeapYear(int year) {}", "addition_info": ""}, "java": {"code_signature": "\n/**\n * Checks if a given year is a leap year.\n *\n * @param year The year to check.\n * @return True if the year is a leap year, false otherwise.\n */\n\npublic static boolean isLeapYear(int year) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testLeapYearDivisibleBy4NotBy100() {\n        // Years that are leap years\n        assertTrue(isLeapYear(2024)); // 2024 is a leap year\n        assertTrue(isLeapYear(2000)); // 2000 is a leap year (divisible by 400)\n        assertTrue(isLeapYear(1996)); // 1996 is a leap year\n        assertTrue(isLeapYear(2004)); // 2004 is a leap year\n    }\n\n    @Test\n    public void testLeapYearDivisibleBy100NotBy400() {\n        // Years that are not leap years\n        assertFalse(isLeapYear(1900)); // 1900 is not a leap year\n        assertFalse(isLeapYear(2100)); // 2100 is not a leap year\n        assertFalse(isLeapYear(1800)); // 1800 is not a leap year\n    }\n\n    @Test\n    public void testLeapYearDivisibleBy400() {\n        // Years that are leap years\n        assertTrue(isLeapYear(2400)); // 2400 is a leap year\n        assertTrue(isLeapYear(1600)); // 1600 is a leap year\n    }\n\n    @Test\n    public void testNormalYears() {\n        // Years that are normal years\n        assertFalse(isLeapYear(1997)); // 1997 is not a leap year\n        assertFalse(isLeapYear(1998)); // 1998 is not a leap year\n        assertFalse(isLeapYear(1999)); // 1999 is not a leap year\n    }\n}", "prompt": "please write a java function , the function signature as below \n/**\n * Checks if a given year is a leap year.\n *\n * @param year The year to check.\n * @return True if the year is a leap year, false otherwise.\n */\n\npublic static boolean isLeapYear(int year) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 604, "code_type": "method", "original_language": "c&cpp", "question_type": "Scientific computation and numerical analysis", "summary": "Tail-recursive function to calculate x raised to the power y.", "language_version_list": {"python": {"code_signature": "def power_tail(x: int, y: int, acc: int = 1) -> int:\n    \"\"\"\n    Tail-recursive function to calculate x raised to the power y.\n\n    Args:\n        x (int): The base, a non-negative integer.\n        y (int): The exponent, a non-negative integer.\n        acc (int): The accumulator to hold the intermediate result.\n\n    Returns:\n        int: The result of x raised to the power of y.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n    def test_base_cases(self):\n        # Test 0^0, should return 1 (by convention)\n        self.assertEqual(power_tail(0, 0), 1)\n        # Test x^0 for any x, should return 1\n        self.assertEqual(power_tail(5, 0), 1)\n        self.assertEqual(power_tail(12345, 0), 1)\n\n    def test_power_of_one(self):\n        # Test 1^y for any y, should return 1\n        self.assertEqual(power_tail(1, 5), 1)\n        self.assertEqual(power_tail(1, 123), 1)\n\n    def test_power_of_zero(self):\n        # Test 0^y for any y > 0, should return 0\n        self.assertEqual(power_tail(0, 5), 0)\n        self.assertEqual(power_tail(0, 100), 0)\n\n    def test_positive_powers(self):\n        # Test some positive powers\n        self.assertEqual(power_tail(2, 3), 8)   # 2^3 = 8\n        self.assertEqual(power_tail(3, 4), 81)  # 3^4 = 81\n        self.assertEqual(power_tail(5, 2), 25)  # 5^2 = 25\n", "prompt": "please write a python function , the function signature as below def power_tail(x: int, y: int, acc: int = 1) -> int:\n    \"\"\"\n    Tail-recursive function to calculate x raised to the power y.\n\n    Args:\n        x (int): The base, a non-negative integer.\n        y (int): The exponent, a non-negative integer.\n        acc (int): The accumulator to hold the intermediate result.\n\n    Returns:\n        int: The result of x raised to the power of y.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Tail-recursive function to calculate x raised to the power y.\n *\n * This function uses tail recursion to compute x^y.\n *\n * @param {number} x The base, a non-negative integer.\n * @param {number} y The exponent, a non-negative integer.\n * @param {number} acc The accumulator to hold the intermediate result.\n *\n * @return {number} The result of x raised to the power of y.\n */\nfunction powerTail(x, y, acc = 1) {}", "test_code": "describe('Power function test cases', () => {\n    describe('Base cases', () => {\n        // Test 0^0, should return 1 (by convention)\n        test('0^0 should return 1', () => {\n            expect(powerTail(0, 0)).toBe(1);\n        });\n\n        // Test x^0 for any x, should return 1\n        test('5^0 should return 1', () => {\n            expect(powerTail(5, 0)).toBe(1);\n        });\n        \n        test('12345^0 should return 1', () => {\n            expect(powerTail(12345, 0)).toBe(1);\n        });\n    });\n\n    describe('Power of one', () => {\n        // Test 1^y for any y, should return 1\n        test('1^5 should return 1', () => {\n            expect(powerTail(1, 5)).toBe(1);\n        });\n\n        test('1^123 should return 1', () => {\n            expect(powerTail(1, 123)).toBe(1);\n        });\n    });\n\n    describe('Power of zero', () => {\n        // Test 0^y for any y > 0, should return 0\n        test('0^5 should return 0', () => {\n            expect(powerTail(0, 5)).toBe(0);\n        });\n\n        test('0^100 should return 0', () => {\n            expect(powerTail(0, 100)).toBe(0);\n        });\n    });\n\n    describe('Positive powers', () => {\n        // Test some positive powers\n        test('2^3 should return 8', () => {\n            expect(powerTail(2, 3)).toBe(8); // 2^3 = 8\n        });\n\n        test('3^4 should return 81', () => {\n            expect(powerTail(3, 4)).toBe(81); // 3^4 = 81\n        });\n\n        test('5^2 should return 25', () => {\n            expect(powerTail(5, 2)).toBe(25); // 5^2 = 25\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Tail-recursive function to calculate x raised to the power y.\n *\n * This function uses tail recursion to compute x^y.\n *\n * @param {number} x The base, a non-negative integer.\n * @param {number} y The exponent, a non-negative integer.\n * @param {number} acc The accumulator to hold the intermediate result.\n *\n * @return {number} The result of x raised to the power of y.\n */\nfunction powerTail(x, y, acc = 1) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Tail-recursive function to calculate x raised to the power y.\n *\n * This function uses tail recursion to compute x^y.\n *\n * @param x The base, a non-negative integer.\n * @param y The exponent, a non-negative integer.\n * @param acc The accumulator to hold the intermediate result.\n *\n * @return The result of x raised to the power of y.\n */\nfunction powerTail(x: number, y: number, acc: number = 1): number {}", "test_code": "describe(\"Power function test cases\", () => {\n    describe(\"Base cases\", () => {\n        // Test 0^0, should return 1 (by convention)\n        test(\"0^0 should return 1\", () => {\n            expect(powerTail(0, 0)).toBe(1);\n        });\n\n        // Test x^0 for any x, should return 1\n        test(\"5^0 should return 1\", () => {\n            expect(powerTail(5, 0)).toBe(1);\n        });\n        test(\"12345^0 should return 1\", () => {\n            expect(powerTail(12345, 0)).toBe(1);\n        });\n    });\n\n    describe(\"Power of one\", () => {\n        // Test 1^y for any y, should return 1\n        test(\"1^5 should return 1\", () => {\n            expect(powerTail(1, 5)).toBe(1);\n        });\n        test(\"1^123 should return 1\", () => {\n            expect(powerTail(1, 123)).toBe(1);\n        });\n    });\n\n    describe(\"Power of zero\", () => {\n        // Test 0^y for any y > 0, should return 0\n        test(\"0^5 should return 0\", () => {\n            expect(powerTail(0, 5)).toBe(0);\n        });\n        test(\"0^100 should return 0\", () => {\n            expect(powerTail(0, 100)).toBe(0);\n        });\n    });\n\n    describe(\"Positive powers\", () => {\n        // Test some positive powers\n        test(\"2^3 should return 8\", () => {\n            expect(powerTail(2, 3)).toBe(8);  // 2^3 = 8\n        });\n        test(\"3^4 should return 81\", () => {\n            expect(powerTail(3, 4)).toBe(81); // 3^4 = 81\n        });\n        test(\"5^2 should return 25\", () => {\n            expect(powerTail(5, 2)).toBe(25); // 5^2 = 25\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Tail-recursive function to calculate x raised to the power y.\n *\n * This function uses tail recursion to compute x^y.\n *\n * @param x The base, a non-negative integer.\n * @param y The exponent, a non-negative integer.\n * @param acc The accumulator to hold the intermediate result.\n *\n * @return The result of x raised to the power of y.\n */\nfunction powerTail(x: number, y: number, acc: number = 1): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n\n/**\n * @brief Tail-recursive function to calculate x raised to the power y.\n *\n * This function uses tail recursion to compute x^y.\n *\n * @param x The base, a non-negative integer.\n * @param y The exponent, a non-negative integer.\n * @param acc The accumulator to hold the intermediate result.\n *\n * @return The result of x raised to the power of y.\n */\nunsigned power_tail(unsigned x, unsigned y, unsigned acc = 1) {}", "test_code": "\nTEST_CASE(\"Power function test cases\") {\n    SECTION(\"Base cases\") {\n        // Test 0^0, should return 1 (by convention)\n        REQUIRE(power_tail(0, 0) == 1);\n\n        // Test x^0 for any x, should return 1\n        REQUIRE(power_tail(5, 0) == 1);\n        REQUIRE(power_tail(12345, 0) == 1);\n    }\n\n    SECTION(\"Power of one\") {\n        // Test 1^y for any y, should return 1\n        REQUIRE(power_tail(1, 5) == 1);\n        REQUIRE(power_tail(1, 123) == 1);\n    }\n\n    SECTION(\"Power of zero\") {\n        // Test 0^y for any y > 0, should return 0\n        REQUIRE(power_tail(0, 5) == 0);\n        REQUIRE(power_tail(0, 100) == 0);\n    }\n\n    SECTION(\"Positive powers\") {\n        // Test some positive powers\n        REQUIRE(power_tail(2, 3) == 8);     // 2^3 = 8\n        REQUIRE(power_tail(3, 4) == 81);    // 3^4 = 81\n        REQUIRE(power_tail(5, 2) == 25);     // 5^2 = 25\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n\n/**\n * @brief Tail-recursive function to calculate x raised to the power y.\n *\n * This function uses tail recursion to compute x^y.\n *\n * @param x The base, a non-negative integer.\n * @param y The exponent, a non-negative integer.\n * @param acc The accumulator to hold the intermediate result.\n *\n * @return The result of x raised to the power of y.\n */\nunsigned power_tail(unsigned x, unsigned y, unsigned acc = 1) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Tail-recursive function to calculate x raised to the power y.\n *\n * This function uses tail recursion to compute x^y.\n *\n * @param x The base, a non-negative integer.\n * @param y The exponent, a non-negative integer.\n * @param acc The accumulator to hold the intermediate result.\n *\n * @return The result of x raised to the power of y.\n */\npublic static long powerTail(long x, long y, long acc) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\n/**\n * Power function test cases.\n */\npublic class Tester {\n\n    @Test\n    public void testBaseCases() {\n        // Test 0^0, should return 1 (by convention)\n        assertEquals(1, Answer.powerTail(0, 0, 1));\n\n        // Test x^0 for any x, should return 1\n        assertEquals(1, Answer.powerTail(5, 0, 1));\n        assertEquals(1, Answer.powerTail(12345, 0, 1));\n    }\n\n    @Test\n    public void testPowerOfOne() {\n        // Test 1^y for any y, should return 1\n        assertEquals(1, Answer.powerTail(1, 5, 1));\n        assertEquals(1, Answer.powerTail(1, 123, 1));\n    }\n\n    @Test\n    public void testPowerOfZero() {\n        // Test 0^y for any y > 0, should return 0\n        assertEquals(0, Answer.powerTail(0, 5, 1));\n        assertEquals(0, Answer.powerTail(0, 100, 1));\n    }\n\n    @Test\n    public void testPositivePowers() {\n        // Test some positive powers\n        assertEquals(8, Answer.powerTail(2, 3, 1));     // 2^3 = 8\n        assertEquals(81, Answer.powerTail(3, 4, 1));    // 3^4 = 81\n        assertEquals(25, Answer.powerTail(5, 2, 1));     // 5^2 = 25\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Tail-recursive function to calculate x raised to the power y.\n *\n * This function uses tail recursion to compute x^y.\n *\n * @param x The base, a non-negative integer.\n * @param y The exponent, a non-negative integer.\n * @param acc The accumulator to hold the intermediate result.\n *\n * @return The result of x raised to the power of y.\n */\npublic static long powerTail(long x, long y, long acc) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 605, "code_type": "method", "original_language": "c&cpp", "question_type": "Scientific computation and numerical analysis", "summary": "calculate BMI\n", "language_version_list": {"python": {"code_signature": "def calculate_bmi(weight: float, height: float) -> float:\n    \"\"\"\n    Calculates the Body Mass Index (BMI) based on weight and height.\n    Args:\n        weight (float): The weight of the individual in kilograms.\n        height (float): The height of the individual in meters.\n\n    Returns:\n        float: The calculated BMI value as a float.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass Tester(unittest.TestCase):\n\n    # Test case for valid inputs with expected BMI value\n    def test_valid_bmi_calculations(self):\n        # Normal weight\n        self.assertAlmostEqual(calculate_bmi(70, 1.75), 22.86, delta=0.01)  # 70 kg, 1.75 m\n\n        # Underweight\n        self.assertAlmostEqual(calculate_bmi(50, 1.75), 16.33, delta=0.01)  # 50 kg, 1.75 m\n\n        # Overweight\n        self.assertAlmostEqual(calculate_bmi(80, 1.75), 26.12, delta=0.01)  # 80 kg, 1.75 m\n\n        # Obesity\n        self.assertAlmostEqual(calculate_bmi(100, 1.75), 32.65, delta=0.01)  # 100 kg, 1.75 m\n\n    # Test case for invalid inputs\n    def test_invalid_bmi_calculations(self):\n        # Negative weight\n        with self.assertRaises(Exception) as context:\n            calculate_bmi(-70, 1.75)\n\n        # Zero height\n        with self.assertRaises(Exception) as context:\n            calculate_bmi(70, 0)\n\n        # Negative height\n        with self.assertRaises(Exception) as context:\n            calculate_bmi(70, -1.75)\n", "prompt": "please write a python function , the function signature as below def calculate_bmi(weight: float, height: float) -> float:\n    \"\"\"\n    Calculates the Body Mass Index (BMI) based on weight and height.\n    Args:\n        weight (float): The weight of the individual in kilograms.\n        height (float): The height of the individual in meters.\n\n    Returns:\n        float: The calculated BMI value as a float.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculates the Body Mass Index (BMI) based on weight and height.\n *\n * The BMI is calculated using the formula:\n *\n *      BMI = weight (kg) / (height (m) * height (m))\n *\n * @param {number} weight The weight of the individual in kilograms.\n * @param {number} height The height of the individual in meters.\n *\n * @return {number} The calculated BMI value.\n *\n * @throws {Error} if weight or height is less than or equal to zero,\n *                 since these values must be positive.\n */\nfunction calculateBMI(weight, height) {}", "test_code": "describe(\"BMI calculations\", () => {\n    // Test case for valid inputs with expected BMI value\n    describe(\"Valid BMI calculations\", () => {\n        test(\"Normal weight\", () => {\n            expect(calculateBMI(70, 1.75)).toBeCloseTo(22.86, 2); // 70 kg, 1.75 m\n        });\n\n        test(\"Underweight\", () => {\n            expect(calculateBMI(50, 1.75)).toBeCloseTo(16.33, 2); // 50 kg, 1.75 m\n        });\n\n        test(\"Overweight\", () => {\n            expect(calculateBMI(80, 1.75)).toBeCloseTo(26.12, 2); // 80 kg, 1.75 m\n        });\n\n        test(\"Obesity\", () => {\n            expect(calculateBMI(100, 1.75)).toBeCloseTo(32.65, 2); // 100 kg, 1.75 m\n        });\n    });\n\n    // Test case for invalid inputs\n    describe(\"Invalid BMI calculations\", () => {\n        test(\"Negative weight\", () => {\n            expect(() => calculateBMI(-70, 1.75)).toThrow(Error); // Negative weight\n        });\n\n        test(\"Zero height\", () => {\n            expect(() => calculateBMI(70, 0)).toThrow(Error); // Zero height\n        });\n\n        test(\"Negative height\", () => {\n            expect(() => calculateBMI(70, -1.75)).toThrow(Error); // Negative height\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the Body Mass Index (BMI) based on weight and height.\n *\n * The BMI is calculated using the formula:\n *\n *      BMI = weight (kg) / (height (m) * height (m))\n *\n * @param {number} weight The weight of the individual in kilograms.\n * @param {number} height The height of the individual in meters.\n *\n * @return {number} The calculated BMI value.\n *\n * @throws {Error} if weight or height is less than or equal to zero,\n *                 since these values must be positive.\n */\nfunction calculateBMI(weight, height) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the Body Mass Index (BMI) based on weight and height.\n *\n * The BMI is calculated using the formula:\n *\n *      BMI = weight (kg) / (height (m) * height (m))\n *\n * @param weight The weight of the individual in kilograms.\n * @param height The height of the individual in meters.\n *\n * @returns The calculated BMI value as a number.\n *\n * @throws Error if weight or height is less than or equal to zero,\n *                since these values must be positive.\n */\nfunction calculateBMI(weight: number, height: number): number {}", "test_code": "describe(\"BMI calculations\", () => {\n    // Test case for valid inputs with expected BMI value\n    describe(\"Valid BMI calculations\", () => {\n        test(\"Normal weight\", () => {\n            expect(calculateBMI(70, 1.75)).toBeCloseTo(22.86, 2); // 70 kg, 1.75 m\n        });\n\n        test(\"Underweight\", () => {\n            expect(calculateBMI(50, 1.75)).toBeCloseTo(16.33, 2); // 50 kg, 1.75 m\n        });\n\n        test(\"Overweight\", () => {\n            expect(calculateBMI(80, 1.75)).toBeCloseTo(26.12, 2); // 80 kg, 1.75 m\n        });\n\n        test(\"Obesity\", () => {\n            expect(calculateBMI(100, 1.75)).toBeCloseTo(32.65, 2); // 100 kg, 1.75 m\n        });\n    });\n\n    // Test case for invalid inputs\n    describe(\"Invalid BMI calculations\", () => {\n        test(\"Negative weight\", () => {\n            expect(() => calculateBMI(-70, 1.75)).toThrow(Error); // Negative weight\n        });\n\n        test(\"Zero height\", () => {\n            expect(() => calculateBMI(70, 0)).toThrow(Error); // Zero height\n        });\n\n        test(\"Negative height\", () => {\n            expect(() => calculateBMI(70, -1.75)).toThrow(Error); // Negative height\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the Body Mass Index (BMI) based on weight and height.\n *\n * The BMI is calculated using the formula:\n *\n *      BMI = weight (kg) / (height (m) * height (m))\n *\n * @param weight The weight of the individual in kilograms.\n * @param height The height of the individual in meters.\n *\n * @returns The calculated BMI value as a number.\n *\n * @throws Error if weight or height is less than or equal to zero,\n *                since these values must be positive.\n */\nfunction calculateBMI(weight: number, height: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <stdexcept>\n\n/**\n * @brief Calculates the Body Mass Index (BMI) based on weight and height.\n *\n * The BMI is calculated using the formula:\n *\n *      BMI = weight (kg) / (height (m) * height (m))\n *\n * @param weight The weight of the individual in kilograms.\n * @param height The height of the individual in meters.\n *\n * @return The calculated BMI value as a double.\n *\n * @throws std::invalid_argument if weight or height is less than or equal to zero,\n *                                since these values must be positive.\n */\ndouble calculateBMI(double weight, double height) {}", "test_code": "// Test case for valid inputs with expected BMI value\nTEST_CASE(\"Valid BMI calculations\") {\n    SECTION(\"Normal weight\") {\n        REQUIRE(calculateBMI(70, 1.75) == Approx(22.86).epsilon(0.01)); // 70 kg, 1.75 m\n    }\n\n    SECTION(\"Underweight\") {\n        REQUIRE(calculateBMI(50, 1.75) == Approx(16.33).epsilon(0.01)); // 50 kg, 1.75 m\n    }\n\n    SECTION(\"Overweight\") {\n        REQUIRE(calculateBMI(80, 1.75) == Approx(26.12).epsilon(0.01)); // 80 kg, 1.75 m\n    }\n\n    SECTION(\"Obesity\") {\n        REQUIRE(calculateBMI(100, 1.75) == Approx(32.65).epsilon(0.01)); // 100 kg, 1.75 m\n    }\n}\n\n// Test case for invalid inputs\nTEST_CASE(\"Invalid BMI calculations\") {\n    SECTION(\"Negative weight\") {\n        REQUIRE_THROWS_AS(calculateBMI(-70, 1.75), std::invalid_argument); // Negative weight\n    }\n\n    SECTION(\"Zero height\") {\n        REQUIRE_THROWS_AS(calculateBMI(70, 0), std::invalid_argument); // Zero height\n    }\n\n    SECTION(\"Negative height\") {\n        REQUIRE_THROWS_AS(calculateBMI(70, -1.75), std::invalid_argument); // Negative height\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <stdexcept>\n\n/**\n * @brief Calculates the Body Mass Index (BMI) based on weight and height.\n *\n * The BMI is calculated using the formula:\n *\n *      BMI = weight (kg) / (height (m) * height (m))\n *\n * @param weight The weight of the individual in kilograms.\n * @param height The height of the individual in meters.\n *\n * @return The calculated BMI value as a double.\n *\n * @throws std::invalid_argument if weight or height is less than or equal to zero,\n *                                since these values must be positive.\n */\ndouble calculateBMI(double weight, double height) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the Body Mass Index (BMI) based on weight and height.\n *\n * The BMI is calculated using the formula:\n *\n *      BMI = weight (kg) / (height (m) * height (m))\n *\n * @param weight The weight of the individual in kilograms.\n * @param height The height of the individual in meters.\n * @return The calculated BMI value as a double.\n * @throws IllegalArgumentException if weight or height is less than or equal to zero,\n *                                  since these values must be positive.\n */\npublic static double calculateBMI(double weight, double height) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.junit.Assert.assertThrows;\n\n/**\n * Test class for BMI calculations.\n */\npublic class Tester {\n\n    // Test case for valid inputs with expected BMI value\n    @Test\n    public void testValidBMICalculations() {\n        // Normal weight\n        assertEquals(22.86, Answer.calculateBMI(70, 1.75), 0.01); // 70 kg, 1.75 m\n\n        // Underweight\n        assertEquals(16.33, Answer.calculateBMI(50, 1.75), 0.01); // 50 kg, 1.75 m\n\n        // Overweight\n        assertEquals(26.12, Answer.calculateBMI(80, 1.75), 0.01); // 80 kg, 1.75 m\n\n        // Obesity\n        assertEquals(32.65, Answer.calculateBMI(100, 1.75), 0.01); // 100 kg, 1.75 m\n    }\n\n    // Test case for invalid inputs\n    @Test\n    public void testInvalidBMICalculations() {\n        // Negative weight\n        assertThrows(IllegalArgumentException.class, () -> {\n            Answer.calculateBMI(-70, 1.75);\n        });\n\n        // Zero height\n        assertThrows(IllegalArgumentException.class, () -> {\n            Answer.calculateBMI(70, 0);\n        });\n\n        // Negative height\n        assertThrows(IllegalArgumentException.class, () -> {\n            Answer.calculateBMI(70, -1.75);\n        });\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the Body Mass Index (BMI) based on weight and height.\n *\n * The BMI is calculated using the formula:\n *\n *      BMI = weight (kg) / (height (m) * height (m))\n *\n * @param weight The weight of the individual in kilograms.\n * @param height The height of the individual in meters.\n * @return The calculated BMI value as a double.\n * @throws IllegalArgumentException if weight or height is less than or equal to zero,\n *                                  since these values must be positive.\n */\npublic static double calculateBMI(double weight, double height) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 606, "code_type": "method", "original_language": "c&cpp", "question_type": "Scientific computation and numerical analysis", "summary": "Calculate the corresponding steering angle based on the given angular velocity\n", "language_version_list": {"python": {"code_signature": "import math\n\n\ndef calculate_steering_angle(angular_velocity: float, speed: float, wheelbase: float) -> float:\n    \"\"\"\n    Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n\n    The function uses the relationship between angular velocity, speed, and the steering angle\n    to determine the appropriate steering angle required for the vehicle to achieve the desired\n    angular velocity. The formula used is:\n\n         \u03c9 = (v / L) * tan(\u03b4)\n\n    Rearranging gives us:\n\n         \u03b4 = atan((\u03c9 * L) / v)\n\n    Parameters:\n    angular_velocity (float): The angular velocity of the vehicle in radians per second.\n    speed (float): The forward speed of the vehicle in meters per second.\n    wheelbase (float): The distance between the front and rear axles of the vehicle in meters.\n\n    Returns:\n    float: The steering angle in radians.\n\n    Raises:\n    ValueError: If speed is less than or equal to zero,\n                since the vehicle cannot move at zero or negative speed.\n    \"\"\"\n", "test_code": "import math\nimport unittest\n\n\nclass Tester(unittest.TestCase):\n    wheelbase = 2.5  # Setting wheelbase constant for all tests\n\n    def test_normal_case(self):\n        angular_velocity = 1.0  # radians/second\n        speed = 10.0  # meters/second\n        expected_angle = math.atan((angular_velocity * self.wheelbase) / speed)\n        self.assertAlmostEqual(calculate_steering_angle(angular_velocity, speed, self.wheelbase), expected_angle)\n\n    def test_zero_speed(self):\n        angular_velocity = 1.0  # radians/second\n        speed = 0.0  # meters/second\n        with self.assertRaises(ValueError):\n            calculate_steering_angle(angular_velocity, speed, self.wheelbase)\n\n    def test_negative_speed(self):\n        angular_velocity = 1.0  # radians/second\n        speed = -5.0  # meters/second\n        with self.assertRaises(Exception):\n            calculate_steering_angle(angular_velocity, speed, self.wheelbase)\n\n    def test_zero_angular_velocity(self):\n        angular_velocity = 0.0  # radians/second\n        speed = 10.0  # meters/second\n        expected_angle = 0.0  # Steering angle should be zero\n        self.assertAlmostEqual(calculate_steering_angle(angular_velocity, speed, self.wheelbase), expected_angle)\n\n    def test_large_values(self):\n        angular_velocity = 100.0  # radians/second\n        speed = 1000.0  # meters/second\n        expected_angle = math.atan((angular_velocity * self.wheelbase) / speed)\n        self.assertAlmostEqual(calculate_steering_angle(angular_velocity, speed, self.wheelbase), expected_angle)\n\n    def test_high_angular_velocity(self):\n        angular_velocity = 10.0  # radians/second\n        speed = 1.0  # meters/second\n        expected_angle = math.atan((angular_velocity * self.wheelbase) / speed)\n        self.assertAlmostEqual(calculate_steering_angle(angular_velocity, speed, self.wheelbase), expected_angle)\n", "prompt": "please write a python function , the function signature as below import math\n\n\ndef calculate_steering_angle(angular_velocity: float, speed: float, wheelbase: float) -> float:\n    \"\"\"\n    Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n\n    The function uses the relationship between angular velocity, speed, and the steering angle\n    to determine the appropriate steering angle required for the vehicle to achieve the desired\n    angular velocity. The formula used is:\n\n         \u03c9 = (v / L) * tan(\u03b4)\n\n    Rearranging gives us:\n\n         \u03b4 = atan((\u03c9 * L) / v)\n\n    Parameters:\n    angular_velocity (float): The angular velocity of the vehicle in radians per second.\n    speed (float): The forward speed of the vehicle in meters per second.\n    wheelbase (float): The distance between the front and rear axles of the vehicle in meters.\n\n    Returns:\n    float: The steering angle in radians.\n\n    Raises:\n    ValueError: If speed is less than or equal to zero,\n                since the vehicle cannot move at zero or negative speed.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n *\n * The function uses the relationship between angular velocity, speed, and the steering angle\n * to determine the appropriate steering angle required for the vehicle to achieve the desired\n * angular velocity. The formula used is:\n *\n *      \u03c9 = (v / L) * tan(\u03b4)\n *\n * Rearranging gives us:\n *\n *      \u03b4 = atan((\u03c9 * L) / v)\n *\n * @param {number} angularVelocity The angular velocity of the vehicle in radians per second.\n * @param {number} speed The forward speed of the vehicle in meters per second.\n * @param {number} wheelbase The distance between the front and rear axles of the vehicle in meters.\n *\n * @return {number} The steering angle in radians.\n *\n * @throws {Error} If speed is less than or equal to zero,\n *                 since the vehicle cannot move at zero or negative speed.\n */\nfunction calculateSteeringAngle(angularVelocity, speed, wheelbase) {}", "test_code": "const wheelbase = 2.5; // Setting wheelbase constant for all tests\n\ndescribe(\"Calculate Steering Angle Tests\", () => {\n    test(\"Normal case\", () => {\n        const angularVelocity = 1.0; // radians/second\n        const speed = 10.0;          // meters/second\n        const expectedAngle = Math.atan((angularVelocity * wheelbase) / speed);\n        expect(calculateSteeringAngle(angularVelocity, speed, wheelbase)).toBeCloseTo(expectedAngle);\n    });\n\n    test(\"Zero speed\", () => {\n        const angularVelocity = 1.0; // radians/second\n        const speed = 0.0;           // meters/second\n        expect(() => calculateSteeringAngle(angularVelocity, speed, wheelbase)).toThrow(Error);\n        expect(() => calculateSteeringAngle(angularVelocity, speed, wheelbase)).toThrow(\"Speed must be greater than zero.\");\n    });\n\n    test(\"Negative speed\", () => {\n        const angularVelocity = 1.0; // radians/second\n        const speed = -5.0;          // meters/second\n        expect(() => calculateSteeringAngle(angularVelocity, speed, wheelbase)).toThrow(Error);\n        expect(() => calculateSteeringAngle(angularVelocity, speed, wheelbase)).toThrow(\"Speed must be greater than zero.\");\n    });\n\n    test(\"Zero angular velocity\", () => {\n        const angularVelocity = 0.0; // radians/second\n        const speed = 10.0;          // meters/second\n        const expectedAngle = 0.0;   // Steering angle should be zero\n        expect(calculateSteeringAngle(angularVelocity, speed, wheelbase)).toBeCloseTo(expectedAngle);\n    });\n\n    test(\"Large values\", () => {\n        const angularVelocity = 100.0; // radians/second\n        const speed = 1000.0;          // meters/second\n        const expectedAngle = Math.atan((angularVelocity * wheelbase) / speed);\n        expect(calculateSteeringAngle(angularVelocity, speed, wheelbase)).toBeCloseTo(expectedAngle);\n    });\n\n    test(\"High angular velocity\", () => {\n        const angularVelocity = 10.0; // radians/second\n        const speed = 1.0;             // meters/second\n        const expectedAngle = Math.atan((angularVelocity * wheelbase) / speed);\n        expect(calculateSteeringAngle(angularVelocity, speed, wheelbase)).toBeCloseTo(expectedAngle);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n *\n * The function uses the relationship between angular velocity, speed, and the steering angle\n * to determine the appropriate steering angle required for the vehicle to achieve the desired\n * angular velocity. The formula used is:\n *\n *      \u03c9 = (v / L) * tan(\u03b4)\n *\n * Rearranging gives us:\n *\n *      \u03b4 = atan((\u03c9 * L) / v)\n *\n * @param {number} angularVelocity The angular velocity of the vehicle in radians per second.\n * @param {number} speed The forward speed of the vehicle in meters per second.\n * @param {number} wheelbase The distance between the front and rear axles of the vehicle in meters.\n *\n * @return {number} The steering angle in radians.\n *\n * @throws {Error} If speed is less than or equal to zero,\n *                 since the vehicle cannot move at zero or negative speed.\n */\nfunction calculateSteeringAngle(angularVelocity, speed, wheelbase) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n *\n * The function uses the relationship between angular velocity, speed, and the steering angle\n * to determine the appropriate steering angle required for the vehicle to achieve the desired\n * angular velocity. The formula used is:\n *\n *      \u03c9 = (v / L) * tan(\u03b4)\n *\n * Rearranging gives us:\n *\n *      \u03b4 = atan((\u03c9 * L) / v)\n *\n * @param angularVelocity The angular velocity of the vehicle in radians per second.\n * @param speed The forward speed of the vehicle in meters per second.\n * @param wheelbase The distance between the front and rear axles of the vehicle in meters.\n *\n * @return The steering angle in radians.\n *\n * @throws Error if speed is less than or equal to zero,\n *                since the vehicle cannot move at zero or negative speed.\n */\nfunction calculateSteeringAngle(angularVelocity: number, speed: number, wheelbase: number): number {}", "test_code": "describe(\"Calculate Steering Angle Tests\", () => {\n    const wheelbase = 2.5; // Setting wheelbase constant for all tests\n\n    test(\"Normal case\", () => {\n        const angularVelocity = 1.0; // radians/second\n        const speed = 10.0;          // meters/second\n        const expectedAngle = Math.atan((angularVelocity * wheelbase) / speed);\n        expect(calculateSteeringAngle(angularVelocity, speed, wheelbase)).toBeCloseTo(expectedAngle);\n    });\n\n    test(\"Zero speed\", () => {\n        const angularVelocity = 1.0; // radians/second\n        const speed = 0.0;           // meters/second\n        expect(() => calculateSteeringAngle(angularVelocity, speed, wheelbase)).toThrow(Error);\n    });\n\n    test(\"Negative speed\", () => {\n        const angularVelocity = 1.0; // radians/second\n        const speed = -5.0;          // meters/second\n        expect(() => calculateSteeringAngle(angularVelocity, speed, wheelbase)).toThrow(Error);\n    });\n\n    test(\"Zero angular velocity\", () => {\n        const angularVelocity = 0.0; // radians/second\n        const speed = 10.0;          // meters/second\n        const expectedAngle = 0.0;   // Steering angle should be zero\n        expect(calculateSteeringAngle(angularVelocity, speed, wheelbase)).toBeCloseTo(expectedAngle);\n    });\n\n    test(\"Large values\", () => {\n        const angularVelocity = 100.0; // radians/second\n        const speed = 1000.0;          // meters/second\n        const expectedAngle = Math.atan((angularVelocity * wheelbase) / speed);\n        expect(calculateSteeringAngle(angularVelocity, speed, wheelbase)).toBeCloseTo(expectedAngle);\n    });\n\n    test(\"High angular velocity\", () => {\n        const angularVelocity = 10.0; // radians/second\n        const speed = 1.0;             // meters/second\n        const expectedAngle = Math.atan((angularVelocity * wheelbase) / speed);\n        expect(calculateSteeringAngle(angularVelocity, speed, wheelbase)).toBeCloseTo(expectedAngle);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n *\n * The function uses the relationship between angular velocity, speed, and the steering angle\n * to determine the appropriate steering angle required for the vehicle to achieve the desired\n * angular velocity. The formula used is:\n *\n *      \u03c9 = (v / L) * tan(\u03b4)\n *\n * Rearranging gives us:\n *\n *      \u03b4 = atan((\u03c9 * L) / v)\n *\n * @param angularVelocity The angular velocity of the vehicle in radians per second.\n * @param speed The forward speed of the vehicle in meters per second.\n * @param wheelbase The distance between the front and rear axles of the vehicle in meters.\n *\n * @return The steering angle in radians.\n *\n * @throws Error if speed is less than or equal to zero,\n *                since the vehicle cannot move at zero or negative speed.\n */\nfunction calculateSteeringAngle(angularVelocity: number, speed: number, wheelbase: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <cmath>\n#include <stdexcept>\n\n/**\n * @brief Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n *\n * The function uses the relationship between angular velocity, speed, and the steering angle\n * to determine the appropriate steering angle required for the vehicle to achieve the desired\n * angular velocity. The formula used is:\n *\n *      \u03c9 = (v / L) * tan(\u03b4)\n *\n * Rearranging gives us:\n *\n *      \u03b4 = atan((\u03c9 * L) / v)\n *\n * @param angularVelocity The angular velocity of the vehicle in radians per second.\n * @param speed The forward speed of the vehicle in meters per second.\n * @param wheelbase The distance between the front and rear axles of the vehicle in meters.\n *\n * @return The steering angle in radians.\n *\n * @throws std::invalid_argument if speed is less than or equal to zero,\n *                                since the vehicle cannot move at zero or negative speed.\n */\ndouble calculateSteeringAngle(double angularVelocity, double speed, double wheelbase) {}", "test_code": "TEST_CASE(\"Calculate Steering Angle Tests\") {\n    const double wheelbase = 2.5; // Setting wheelbase constant for all tests\n\n    SECTION(\"Normal case\") {\n        double angularVelocity = 1.0; // radians/second\n        double speed = 10.0;          // meters/second\n        double expectedAngle = atan((angularVelocity * wheelbase) / speed);\n        REQUIRE(calculateSteeringAngle(angularVelocity, speed, wheelbase) == Approx(expectedAngle));\n    }\n\n    SECTION(\"Zero speed\") {\n        double angularVelocity = 1.0; // radians/second\n        double speed = 0.0;           // meters/second\n        REQUIRE_THROWS_AS(calculateSteeringAngle(angularVelocity, speed, wheelbase), std::invalid_argument);\n    }\n\n    SECTION(\"Negative speed\") {\n        double angularVelocity = 1.0; // radians/second\n        double speed = -5.0;          // meters/second\n        REQUIRE_THROWS_AS(calculateSteeringAngle(angularVelocity, speed, wheelbase), std::invalid_argument);\n    }\n\n    SECTION(\"Zero angular velocity\") {\n        double angularVelocity = 0.0; // radians/second\n        double speed = 10.0;          // meters/second\n        double expectedAngle = 0.0;   // Steering angle should be zero\n        REQUIRE(calculateSteeringAngle(angularVelocity, speed, wheelbase) == Approx(expectedAngle));\n    }\n\n    SECTION(\"Large values\") {\n        double angularVelocity = 100.0; // radians/second\n        double speed = 1000.0;          // meters/second\n        double expectedAngle = atan((angularVelocity * wheelbase) / speed);\n        REQUIRE(calculateSteeringAngle(angularVelocity, speed, wheelbase) == Approx(expectedAngle));\n    }\n\n    SECTION(\"High angular velocity\") {\n        double angularVelocity = 10.0; // radians/second\n        double speed = 1.0;             // meters/second\n        double expectedAngle = atan((angularVelocity * wheelbase) / speed);\n        REQUIRE(calculateSteeringAngle(angularVelocity, speed, wheelbase) == Approx(expectedAngle));\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <cmath>\n#include <stdexcept>\n\n/**\n * @brief Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n *\n * The function uses the relationship between angular velocity, speed, and the steering angle\n * to determine the appropriate steering angle required for the vehicle to achieve the desired\n * angular velocity. The formula used is:\n *\n *      \u03c9 = (v / L) * tan(\u03b4)\n *\n * Rearranging gives us:\n *\n *      \u03b4 = atan((\u03c9 * L) / v)\n *\n * @param angularVelocity The angular velocity of the vehicle in radians per second.\n * @param speed The forward speed of the vehicle in meters per second.\n * @param wheelbase The distance between the front and rear axles of the vehicle in meters.\n *\n * @return The steering angle in radians.\n *\n * @throws std::invalid_argument if speed is less than or equal to zero,\n *                                since the vehicle cannot move at zero or negative speed.\n */\ndouble calculateSteeringAngle(double angularVelocity, double speed, double wheelbase) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n *\n * The method uses the relationship between angular velocity, speed, and the steering angle\n * to determine the appropriate steering angle required for the vehicle to achieve the desired\n * angular velocity. The formula used is:\n *\n *      \u03c9 = (v / L) * tan(\u03b4)\n *\n * Rearranging gives us:\n *\n *      \u03b4 = atan((\u03c9 * L) / v)\n *\n * @param angularVelocity The angular velocity of the vehicle in radians per second.\n * @param speed The forward speed of the vehicle in meters per second.\n * @param wheelbase The distance between the front and rear axles of the vehicle in meters.\n *\n * @return The steering angle in radians.\n *\n * @throws IllegalArgumentException if speed is less than or equal to zero,\n *                                   since the vehicle cannot move at zero or negative speed.\n */\npublic static double calculateSteeringAngle(double angularVelocity, double speed, double wheelbase) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\npublic class Tester {\n\n    private static final double WHEELBASE = 2.5; // Setting wheelbase constant for all tests\n\n    @Test\n    public void testNormalCase() {\n        double angularVelocity = 1.0; // radians/second\n        double speed = 10.0;          // meters/second\n        double expectedAngle = Math.atan((angularVelocity * WHEELBASE) / speed);\n        assertEquals(expectedAngle, Answer.calculateSteeringAngle(angularVelocity, speed, WHEELBASE), 1e-9);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testZeroSpeed() {\n        double angularVelocity = 1.0; // radians/second\n        double speed = 0.0;           // meters/second\n        Answer.calculateSteeringAngle(angularVelocity, speed, WHEELBASE);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testNegativeSpeed() {\n        double angularVelocity = 1.0; // radians/second\n        double speed = -5.0;          // meters/second\n        Answer.calculateSteeringAngle(angularVelocity, speed, WHEELBASE);\n    }\n\n    @Test\n    public void testZeroAngularVelocity() {\n        double angularVelocity = 0.0; // radians/second\n        double speed = 10.0;          // meters/second\n        double expectedAngle = 0.0;   // Steering angle should be zero\n        assertEquals(expectedAngle, Answer.calculateSteeringAngle(angularVelocity, speed, WHEELBASE), 1e-9);\n    }\n\n    @Test\n    public void testLargeValues() {\n        double angularVelocity = 100.0; // radians/second\n        double speed = 1000.0;          // meters/second\n        double expectedAngle = Math.atan((angularVelocity * WHEELBASE) / speed);\n        assertEquals(expectedAngle, Answer.calculateSteeringAngle(angularVelocity, speed, WHEELBASE), 1e-9);\n    }\n\n    @Test\n    public void testHighAngularVelocity() {\n        double angularVelocity = 10.0; // radians/second\n        double speed = 1.0;             // meters/second\n        double expectedAngle = Math.atan((angularVelocity * WHEELBASE) / speed);\n        assertEquals(expectedAngle, Answer.calculateSteeringAngle(angularVelocity, speed, WHEELBASE), 1e-9);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n *\n * The method uses the relationship between angular velocity, speed, and the steering angle\n * to determine the appropriate steering angle required for the vehicle to achieve the desired\n * angular velocity. The formula used is:\n *\n *      \u03c9 = (v / L) * tan(\u03b4)\n *\n * Rearranging gives us:\n *\n *      \u03b4 = atan((\u03c9 * L) / v)\n *\n * @param angularVelocity The angular velocity of the vehicle in radians per second.\n * @param speed The forward speed of the vehicle in meters per second.\n * @param wheelbase The distance between the front and rear axles of the vehicle in meters.\n *\n * @return The steering angle in radians.\n *\n * @throws IllegalArgumentException if speed is less than or equal to zero,\n *                                   since the vehicle cannot move at zero or negative speed.\n */\npublic static double calculateSteeringAngle(double angularVelocity, double speed, double wheelbase) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
