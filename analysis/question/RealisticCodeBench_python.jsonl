{"task_id": 1, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "convert the input string, first see if it is an integer, if it is converted to an integer, if it is not, see if it is a floating point number, if yes, convert to a floating point number, if neither, return the original string", "language_version_list": {"python": {"code_signature": "from typing import Union\n\n\ndef numerical_str_convert(value: str) -> Union[int, float, str]:\n    \"\"\"\n    convert the input string, first see if it is an integer, if it is converted to an integer, if it is not, see if it is a floating point number, if yes, convert to a floating point number, if neither, return the original string\n\n    Args:\n        value (str): input value str\n    Returns:\n       Union[int, float, str]: convert model_answer_result\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSmartConvert(unittest.TestCase):\n    def test_convert_integer(self):\n        self.assertEqual(numerical_str_convert(\"123\"), 123, \"Should convert to integer\")\n\n    def test_convert_float(self):\n        self.assertEqual(numerical_str_convert(\"123.45\"), 123.45, \"Should convert to float\")\n\n    def test_convert_non_numeric_string(self):\n        self.assertEqual(numerical_str_convert(\"abc\"), \"abc\", \"Should remain a string\")\n\n    def test_convert_negative_integer(self):\n        self.assertEqual(numerical_str_convert(\"-456\"), -456, \"Should convert to negative integer\")\n\n    def test_convert_negative_float(self):\n        self.assertEqual(numerical_str_convert(\"-456.78\"), -456.78, \"Should convert to negative float\")\n", "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef numerical_str_convert(value: str) -> Union[int, float, str]:\n    \"\"\"\n    convert the input string, first see if it is an integer, if it is converted to an integer, if it is not, see if it is a floating point number, if yes, convert to a floating point number, if neither, return the original string\n\n    Args:\n        value (str): input value str\n    Returns:\n       Union[int, float, str]: convert model_answer_result\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts the input string. First, checks if it is an integer. If it is, converts it to an integer.\n * If not, checks if it is a floating-point number. If it is, converts it to a floating-point number.\n * If it is neither, returns the original string.\n * \n * @param {string} value - The input value as a string.\n * @returns {(number|string)} - The converted value or the original string.\n */\nfunction numericalStrConvert(value) {}", "test_code": "describe('TestSmartConvert', () => {\n    it('should convert to integer', () => {\n        expect(numericalStrConvert(\"123\")).toBe(123);\n    });\n\n    it('should convert to float', () => {\n        expect(numericalStrConvert(\"123.45\")).toBe(123.45);\n    });\n\n    it('should remain a string for non-numeric input', () => {\n        expect(numericalStrConvert(\"abc\")).toBe(\"abc\");\n    });\n\n    it('should convert to negative integer', () => {\n        expect(numericalStrConvert(\"-456\")).toBe(-456);\n    });\n\n    it('should convert to negative float', () => {\n        expect(numericalStrConvert(\"-456.78\")).toBe(-456.78);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts the input string. First, checks if it is an integer. If it is, converts it to an integer.\n * If not, checks if it is a floating-point number. If it is, converts it to a floating-point number.\n * If it is neither, returns the original string.\n * \n * @param {string} value - The input value as a string.\n * @returns {(number|string)} - The converted value or the original string.\n */\nfunction numericalStrConvert(value) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts the input string to an integer or a floating-point number if possible.\n * If the string cannot be converted to a number, it returns the original string.\n *\n * @param value - The input string to convert.\n * @returns The converted integer, floating-point number, or the original string if conversion is not possible.\n */\nfunction numericalStrConvert(value: string): number | string {}\n", "test_code": "describe('TestSmartConvert', () => {\n  it('should convert to integer', () => {\n      expect(numericalStrConvert(\"123\")).toBe(123);\n  });\n\n  it('should convert to float', () => {\n      expect(numericalStrConvert(\"123.45\")).toBe(123.45);\n  });\n\n  it('should remain a string for non-numeric input', () => {\n      expect(numericalStrConvert(\"abc\")).toBe(\"abc\");\n  });\n\n  it('should convert to negative integer', () => {\n      expect(numericalStrConvert(\"-456\")).toBe(-456);\n  });\n\n  it('should convert to negative float', () => {\n      expect(numericalStrConvert(\"-456.78\")).toBe(-456.78);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts the input string to an integer or a floating-point number if possible.\n * If the string cannot be converted to a number, it returns the original string.\n *\n * @param value - The input string to convert.\n * @returns The converted integer, floating-point number, or the original string if conversion is not possible.\n */\nfunction numericalStrConvert(value: string): number | string {}\n", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a string to a numerical type (int or float) or returns the original string.\n *\n * @param value The string to be converted. It should represent a numerical value.\n * \n * @return std::variant<int, float, std::string>\n * - On success, returns an integer if the string represents an integer.\n * - Returns a float if the string represents a floating-point number.\n * - If the string cannot be converted to either type, returns the original string.\n * \n * @exception std::invalid_argument If the input string is not a valid representation of a number.\n * @exception std::out_of_range If the number represented by the string is out of the range of\n *         the target type (int or float).\n */\n std::variant<int, float, std::string> numerical_str_convert(const std::string& value) {}", "test_code": "TEST_CASE(\"SmartConvert Tests\", \"[numericalStrConvert]\") {\n    SECTION(\"Convert integer\") {\n        REQUIRE(numerical_str_convert(\"123\") == 123);\n    }\n\n    SECTION(\"Convert float\") {\n        REQUIRE(numerical_str_convert(\"123.45\") == 123.45f);\n    }\n\n    SECTION(\"Convert non-numeric string\") {\n        REQUIRE(numerical_str_convert(\"abc\") == \"abc\");\n    }\n\n    SECTION(\"Convert negative integer\") {\n        REQUIRE(numerical_str_convert(\"-456\") == -456);\n    }\n\n    SECTION(\"Convert negative float\") {\n        REQUIRE(numerical_str_convert(\"-456.78\") == -456.78f);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a string to a numerical type (int or float) or returns the original string.\n *\n * @param value The string to be converted. It should represent a numerical value.\n * \n * @return std::variant<int, float, std::string>\n * - On success, returns an integer if the string represents an integer.\n * - Returns a float if the string represents a floating-point number.\n * - If the string cannot be converted to either type, returns the original string.\n * \n * @exception std::invalid_argument If the input string is not a valid representation of a number.\n * @exception std::out_of_range If the number represented by the string is out of the range of\n *         the target type (int or float).\n */\n std::variant<int, float, std::string> numerical_str_convert(const std::string& value) {}", "addition_info": "union ConvertResult {\n    int intValue;\n    float floatValue;\n    std::string stringValue;\n\n    // Destructor to handle cleanup\n    ~ConvertResult() {\n        // Free memory if stringValue is used\n        if (stringValue.data() != nullptr) {\n            stringValue.~basic_string();\n        }\n    }\n\n    // Equality operator to compare union values\n    bool operator==(const int& other) const {\n        return intValue == other;\n    }\n\n    bool operator==(const float& other) const {\n        return floatValue == other;\n    }\n\n    bool operator==(const std::string& other) const {\n        return stringValue == other;\n    }\n};"}, "java": {"code_signature": "/**\n * Converts the input string to an integer or a float if possible.\n * If the string cannot be converted to a number, it returns the original string.\n *\n * @param value the input string to be converted\n * @return the converted value as an Integer, Float, or the original String\n */\npublic static Object numericalStrConvert(String value) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    /**\n     * Tests conversion of an integer string.\n     */\n    @Test\n    public void testConvertInteger() {\n        assertEquals(\"Should convert to integer\", 123, numericalStrConvert(\"123\"));\n    }\n\n    /**\n     * Tests conversion of a float string.\n     */\n    @Test\n    public void testConvertFloat() {\n        assertEquals(\"Should convert to float\", 123.45f, (Float) numericalStrConvert(\"123.45\"), 0.001f);\n    }\n\n    /**\n     * Tests conversion of a non-numeric string.\n     */\n    @Test\n    public void testConvertNonNumericString() {\n        assertEquals(\"Should remain a string\", \"abc\", numericalStrConvert(\"abc\"));\n    }\n\n    /**\n     * Tests conversion of a negative integer string.\n     */\n    @Test\n    public void testConvertNegativeInteger() {\n        assertEquals(\"Should convert to negative integer\", -456, numericalStrConvert(\"-456\"));\n    }\n\n    /**\n     * Tests conversion of a negative float string.\n     */\n    @Test\n    public void testConvertNegativeFloat() {\n        assertEquals(\"Should convert to negative float\", -456.78f, (Float) numericalStrConvert(\"-456.78\"), 0.001f);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts the input string to an integer or a float if possible.\n * If the string cannot be converted to a number, it returns the original string.\n *\n * @param value the input string to be converted\n * @return the converted value as an Integer, Float, or the original String\n */\npublic static Object numericalStrConvert(String value) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 5, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Implementing matrix multiplication\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef matrix_multiply(matrixA: List[List[int]], matrixB: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Implementing matrix multiplication\n\n    Args:\n        matrixA (List[List[int]]): matrix A\n        matrixB (List[List[int]]): matrix B\n\n    Returns:\n        List[List[int]]: matrixA matrixB multiplication model_answer_result\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestMatrixMultiplication(unittest.TestCase):\n    def test_standard_matrices(self):\n        mat1 = [[1, 2], [3, 4]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[19, 22], [43, 50]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected, \"Should correctly multiply standard matrices\")\n\n    def test_identity_matrix(self):\n        mat1 = [[1, 0], [0, 1]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[5, 6], [7, 8]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected,\n                         \"Multiplying by the identity matrix should yield the answer.py matrix\")\n\n    def test_zero_matrix(self):\n        mat1 = [[0, 0], [0, 0]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[0, 0], [0, 0]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected,\n                         \"Multiplying by the zero matrix should yield a zero matrix\")\n\n    def test_square_matrix_multiplication(self):\n        mat1 = [[1, 2], [3, 4]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[19, 22], [43, 50]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected,\n                         \"The multiplication of two square matrices should yield the correct product\")\n\n    def test_large_identity_matrix(self):\n        mat1 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n        mat2 = [[5, 6, 7], [8, 9, 10], [11, 12, 13]]\n        expected = [[5, 6, 7], [8, 9, 10], [11, 12, 13]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected,\n                         \"Multiplying by the larger identity matrix should yield the answer matrix\")\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef matrix_multiply(matrixA: List[List[int]], matrixB: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Implementing matrix multiplication\n\n    Args:\n        matrixA (List[List[int]]): matrix A\n        matrixB (List[List[int]]): matrix B\n\n    Returns:\n        List[List[int]]: matrixA matrixB multiplication model_answer_result\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Implements matrix multiplication.\n * \n * @param {Array<Array<number>>} matrixA - Matrix A\n * @param {Array<Array<number>>} matrixB - Matrix B\n * @returns {Array<Array<number>>} The result of multiplying matrixA by matrixB\n */\nfunction matrixMultiply(matrixA, matrixB) {}", "test_code": "describe('TestMatrixMultiplication', () => {\n    it('should correctly multiply standard matrices', () => {\n        const mat1 = [[1, 2], [3, 4]];\n        const mat2 = [[5, 6], [7, 8]];\n        const expected = [[19, 22], [43, 50]];\n        expect(matrixMultiply(mat1, mat2)).toEqual(expected);\n    });\n\n    it('multiplying by the identity matrix should yield the answer matrix', () => {\n        const mat1 = [[1, 0], [0, 1]];\n        const mat2 = [[5, 6], [7, 8]];\n        const expected = [[5, 6], [7, 8]];\n        expect(matrixMultiply(mat1, mat2)).toEqual(expected);\n    });\n\n    it('multiplying by the zero matrix should yield a zero matrix', () => {\n        const mat1 = [[0, 0], [0, 0]];\n        const mat2 = [[5, 6], [7, 8]];\n        const expected = [[0, 0], [0, 0]];\n        expect(matrixMultiply(mat1, mat2)).toEqual(expected);\n    });\n\n    it('the multiplication of two square matrices should yield the correct product', () => {\n        const mat1 = [[1, 2], [3, 4]];\n        const mat2 = [[5, 6], [7, 8]];\n        const expected = [[19, 22], [43, 50]];\n        expect(matrixMultiply(mat1, mat2)).toEqual(expected);\n    });\n\n    it('multiplying by the larger identity matrix should yield the answer matrix', () => {\n        const mat1 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\n        const mat2 = [[5, 6, 7], [8, 9, 10], [11, 12, 13]];\n        const expected = [[5, 6, 7], [8, 9, 10], [11, 12, 13]];\n        expect(matrixMultiply(mat1, mat2)).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Implements matrix multiplication.\n * \n * @param {Array<Array<number>>} matrixA - Matrix A\n * @param {Array<Array<number>>} matrixB - Matrix B\n * @returns {Array<Array<number>>} The result of multiplying matrixA by matrixB\n */\nfunction matrixMultiply(matrixA, matrixB) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Implements matrix multiplication.\n * \n * @param matrixA - The first matrix.\n * @param matrixB - The second matrix.\n * @returns The result of multiplying matrixA by matrixB.\n */\nfunction matrixMultiply(matrixA: number[][], matrixB: number[][]): number[][] {}", "test_code": "describe('TestMatrixMultiplication', () => {\n    test('should correctly multiply standard matrices', () => {\n        const mat1 = [[1, 2], [3, 4]];\n        const mat2 = [[5, 6], [7, 8]];\n        const expected = [[19, 22], [43, 50]];\n        expect(matrixMultiply(mat1, mat2)).toEqual(expected);\n    });\n\n    test('should yield the answer matrix when multiplying by the identity matrix', () => {\n        const mat1 = [[1, 0], [0, 1]];\n        const mat2 = [[5, 6], [7, 8]];\n        const expected = [[5, 6], [7, 8]];\n        expect(matrixMultiply(mat1, mat2)).toEqual(expected);\n    });\n\n    test('should yield a zero matrix when multiplying by the zero matrix', () => {\n        const mat1 = [[0, 0], [0, 0]];\n        const mat2 = [[5, 6], [7, 8]];\n        const expected = [[0, 0], [0, 0]];\n        expect(matrixMultiply(mat1, mat2)).toEqual(expected);\n    });\n\n    test('should yield the correct product when multiplying two square matrices', () => {\n        const mat1 = [[1, 2], [3, 4]];\n        const mat2 = [[5, 6], [7, 8]];\n        const expected = [[19, 22], [43, 50]];\n        expect(matrixMultiply(mat1, mat2)).toEqual(expected);\n    });\n\n    test('should yield the answer matrix when multiplying by a larger identity matrix', () => {\n        const mat1 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\n        const mat2 = [[5, 6, 7], [8, 9, 10], [11, 12, 13]];\n        const expected = [[5, 6, 7], [8, 9, 10], [11, 12, 13]];\n        expect(matrixMultiply(mat1, mat2)).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Implements matrix multiplication.\n * \n * @param matrixA - The first matrix.\n * @param matrixB - The second matrix.\n * @returns The result of multiplying matrixA by matrixB.\n */\nfunction matrixMultiply(matrixA: number[][], matrixB: number[][]): number[][] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Implements matrix multiplication.\n *\n * @param matrixA The first matrix.\n * @param matrixB The second matrix.\n *\n * @return std::vector<std::vector<int>> The result of multiplying matrixA by matrixB.\n */\nstd::vector<std::vector<int>> matrix_multiply(const std::vector<std::vector<int>>& matrixA, const std::vector<std::vector<int>>& matrixB) {}", "test_code": "TEST_CASE(\"Test Matrix Multiplication\", \"[matrix_multiply]\") {\n    SECTION(\"Standard Matrices\") {\n        std::vector<std::vector<int>> mat1 = {{1, 2}, {3, 4}};\n        std::vector<std::vector<int>> mat2 = {{5, 6}, {7, 8}};\n        std::vector<std::vector<int>> expected = {{19, 22}, {43, 50}};\n        \n        REQUIRE(matrix_multiply(mat1, mat2) == expected);\n    }\n\n    SECTION(\"Identity Matrix\") {\n        std::vector<std::vector<int>> mat1 = {{1, 0}, {0, 1}};\n        std::vector<std::vector<int>> mat2 = {{5, 6}, {7, 8}};\n        std::vector<std::vector<int>> expected = {{5, 6}, {7, 8}};\n        \n        REQUIRE(matrix_multiply(mat1, mat2) == expected);\n    }\n\n    SECTION(\"Zero Matrix\") {\n        std::vector<std::vector<int>> mat1 = {{0, 0}, {0, 0}};\n        std::vector<std::vector<int>> mat2 = {{5, 6}, {7, 8}};\n        std::vector<std::vector<int>> expected = {{0, 0}, {0, 0}};\n        \n        REQUIRE(matrix_multiply(mat1, mat2) == expected);\n    }\n\n    SECTION(\"Square Matrix Multiplication\") {\n        std::vector<std::vector<int>> mat1 = {{1, 2}, {3, 4}};\n        std::vector<std::vector<int>> mat2 = {{5, 6}, {7, 8}};\n        std::vector<std::vector<int>> expected = {{19, 22}, {43, 50}};\n        \n        REQUIRE(matrix_multiply(mat1, mat2) == expected);\n    }\n\n    SECTION(\"Large Identity Matrix\") {\n        std::vector<std::vector<int>> mat1 = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};\n        std::vector<std::vector<int>> mat2 = {{5, 6, 7}, {8, 9, 10}, {11, 12, 13}};\n        std::vector<std::vector<int>> expected = {{5, 6, 7}, {8, 9, 10}, {11, 12, 13}};\n        \n        REQUIRE(matrix_multiply(mat1, mat2) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Implements matrix multiplication.\n *\n * @param matrixA The first matrix.\n * @param matrixB The second matrix.\n *\n * @return std::vector<std::vector<int>> The result of multiplying matrixA by matrixB.\n */\nstd::vector<std::vector<int>> matrix_multiply(const std::vector<std::vector<int>>& matrixA, const std::vector<std::vector<int>>& matrixB) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Implements matrix multiplication.\n *\n * @param matrixA The first matrix.\n * @param matrixB The second matrix.\n * @return The result of multiplying matrixA by matrixB.\n * @throws IllegalArgumentException If the matrices cannot be multiplied due to incompatible dimensions.\n */\npublic static List<List<Integer>> matrixMultiply(List<List<Integer>> matrixA, List<List<Integer>> matrixB) {}", "test_code": "package org.real.temp;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.List;\nimport java.util.ArrayList;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testStandardMatrices() {\n        List<List<Integer>> mat1 = new ArrayList<>();\n        mat1.add(new ArrayList<>(List.of(1, 2)));\n        mat1.add(new ArrayList<>(List.of(3, 4)));\n\n        List<List<Integer>> mat2 = new ArrayList<>();\n        mat2.add(new ArrayList<>(List.of(5, 6)));\n        mat2.add(new ArrayList<>(List.of(7, 8)));\n\n        List<List<Integer>> expected = new ArrayList<>();\n        expected.add(new ArrayList<>(List.of(19, 22)));\n        expected.add(new ArrayList<>(List.of(43, 50)));\n\n        assertEquals(\"Should correctly multiply standard matrices\",expected, matrixMultiply(mat1, mat2));\n    }\n\n    @Test\n    public void testIdentityMatrix() {\n        List<List<Integer>> mat1 = new ArrayList<>();\n        mat1.add(new ArrayList<>(List.of(1, 0)));\n        mat1.add(new ArrayList<>(List.of(0, 1)));\n\n        List<List<Integer>> mat2 = new ArrayList<>();\n        mat2.add(new ArrayList<>(List.of(5, 6)));\n        mat2.add(new ArrayList<>(List.of(7, 8)));\n\n        List<List<Integer>> expected = new ArrayList<>();\n        expected.add(new ArrayList<>(List.of(5, 6)));\n        expected.add(new ArrayList<>(List.of(7, 8)));\n\n        assertEquals(\"Multiplying by the identity matrix should yield the answer matrix\",expected, matrixMultiply(mat1, mat2));\n    }\n\n    @Test\n    public void testZeroMatrix() {\n        List<List<Integer>> mat1 = new ArrayList<>();\n        mat1.add(new ArrayList<>(List.of(0, 0)));\n        mat1.add(new ArrayList<>(List.of(0, 0)));\n\n        List<List<Integer>> mat2 = new ArrayList<>();\n        mat2.add(new ArrayList<>(List.of(5, 6)));\n        mat2.add(new ArrayList<>(List.of(7, 8)));\n\n        List<List<Integer>> expected = new ArrayList<>();\n        expected.add(new ArrayList<>(List.of(0, 0)));\n        expected.add(new ArrayList<>(List.of(0, 0)));\n\n        assertEquals(\"Multiplying by the zero matrix should yield a zero matrix\",expected, matrixMultiply(mat1, mat2));\n    }\n\n    @Test\n    public void testSquareMatrixMultiplication() {\n        List<List<Integer>> mat1 = new ArrayList<>();\n        mat1.add(new ArrayList<>(List.of(1, 2)));\n        mat1.add(new ArrayList<>(List.of(3, 4)));\n\n        List<List<Integer>> mat2 = new ArrayList<>();\n        mat2.add(new ArrayList<>(List.of(5, 6)));\n        mat2.add(new ArrayList<>(List.of(7, 8)));\n\n        List<List<Integer>> expected = new ArrayList<>();\n        expected.add(new ArrayList<>(List.of(19, 22)));\n        expected.add(new ArrayList<>(List.of(43, 50)));\n\n        assertEquals(\"The multiplication of two square matrices should yield the correct product\",expected, matrixMultiply(mat1, mat2));\n    }\n\n    @Test\n    public void testLargeIdentityMatrix() {\n        List<List<Integer>> mat1 = new ArrayList<>();\n        mat1.add(new ArrayList<>(List.of(1, 0, 0)));\n        mat1.add(new ArrayList<>(List.of(0, 1, 0)));\n        mat1.add(new ArrayList<>(List.of(0, 0, 1)));\n\n        List<List<Integer>> mat2 = new ArrayList<>();\n        mat2.add(new ArrayList<>(List.of(5, 6, 7)));\n        mat2.add(new ArrayList<>(List.of(8, 9, 10)));\n        mat2.add(new ArrayList<>(List.of(11, 12, 13)));\n\n        List<List<Integer>> expected = new ArrayList<>();\n        expected.add(new ArrayList<>(List.of(5, 6, 7)));\n        expected.add(new ArrayList<>(List.of(8, 9, 10)));\n        expected.add(new ArrayList<>(List.of(11, 12, 13)));\n\n        assertEquals(\"Multiplying by the larger identity matrix should yield the answer matrix\",expected, matrixMultiply(mat1, mat2));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Implements matrix multiplication.\n *\n * @param matrixA The first matrix.\n * @param matrixB The second matrix.\n * @return The result of multiplying matrixA by matrixB.\n * @throws IllegalArgumentException If the matrices cannot be multiplied due to incompatible dimensions.\n */\npublic static List<List<Integer>> matrixMultiply(List<List<Integer>> matrixA, List<List<Integer>> matrixB) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 6, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "simplify file paths in windows systems into name strings, for example, D:\\downlaod\\text.py is simplified to D_download_text.py\n", "language_version_list": {"python": {"code_signature": "def simplify_windows_path(path: str) -> str:\n    \"\"\"\n    simplify file paths in windows systems into name strings.\n    For example:\n        input: C:\\\\Users\\\\User\\\\file.txt\n        output: C_Users_User_file.txt\n    Args:\n        path (str): windows file path str\n\n    Returns:\n        str: simplify path str\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSimplifyWindowsPath(unittest.TestCase):\n    def test_simple_path(self):\n        self.assertEqual(simplify_windows_path(r\"C:\\Users\\User\\file.txt\"), \"C_Users_User_file.txt\")\n\n    def test_simple_path2(self):\n        self.assertEqual(simplify_windows_path(r\"D:\\User\\file.txt\"), \"D_User_file.txt\")\n\n    def test_path_with_spaces(self):\n        self.assertEqual(simplify_windows_path(r\"E:\\New Folder\\my file.docx\"), \"E_New Folder_my file.docx\")\n\n    def test_nested_directories(self):\n        self.assertEqual(simplify_windows_path(r\"G:\\folder1\\folder2\\folder3\\file.jpeg\"),\n                         \"G_folder1_folder2_folder3_file.jpeg\")\n    def test_path_with_single_backslash(self):\n        self.assertEqual(simplify_windows_path(r'F:\\\\'), 'F_')\n", "prompt": "please write a python function , the function signature as below def simplify_windows_path(path: str) -> str:\n    \"\"\"\n    simplify file paths in windows systems into name strings.\n    For example:\n        input: C:\\\\Users\\\\User\\\\file.txt\n        output: C_Users_User_file.txt\n    Args:\n        path (str): windows file path str\n\n    Returns:\n        str: simplify path str\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Simplifies file paths in Windows systems into name strings.\n * For example:\n *     input: C:\\\\Users\\\\User\\\\file.txt\n *     output: C_Users_User_file.txt\n * \n * @param {string} path - The Windows file path string.\n * @returns {string} The simplified path string.\n */\nfunction simplifyWindowsPath(path) {}", "test_code": "describe('TestSimplifyWindowsPath', () => {\n    test('should simplify a simple path', () => {\n        expect(simplifyWindowsPath('C:\\\\Users\\\\User\\\\file.txt')).toBe('C_Users_User_file.txt');\n    });\n\n    test('should simplify another simple path', () => {\n        expect(simplifyWindowsPath('D:\\\\User\\\\file.txt')).toBe('D_User_file.txt');\n    });\n\n    test('should simplify a path with spaces', () => {\n        expect(simplifyWindowsPath('E:\\\\New Folder\\\\my file.docx')).toBe('E_New Folder_my file.docx');\n    });\n\n    test('should simplify a nested directory path', () => {\n        expect(simplifyWindowsPath('G:\\\\folder1\\\\folder2\\\\folder3\\\\file.jpeg')).toBe('G_folder1_folder2_folder3_file.jpeg');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Simplifies file paths in Windows systems into name strings.\n * For example:\n *     input: C:\\\\Users\\\\User\\\\file.txt\n *     output: C_Users_User_file.txt\n * \n * @param {string} path - The Windows file path string.\n * @returns {string} The simplified path string.\n */\nfunction simplifyWindowsPath(path) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Simplify file paths in Windows systems into name strings.\n * \n * For example:\n *   Input: C:\\Users\\User\\file.txt\n *   Output: C_Users_User_file.txt\n * \n * @param path - The Windows file path string.\n * @returns The simplified path string.\n */\nfunction simplifyWindowsPath(path: string): string {}", "test_code": "describe('TestSimplifyWindowsPath', () => {\n    test('should simplify a simple path', () => {\n      expect(simplifyWindowsPath('C:\\\\Users\\\\User\\\\file.txt')).toBe('C_Users_User_file.txt');\n    });\n  \n    test('should simplify another simple path', () => {\n      expect(simplifyWindowsPath('D:\\\\User\\\\file.txt')).toBe('D_User_file.txt');\n    });\n  \n    test('should simplify a path with spaces', () => {\n      expect(simplifyWindowsPath('E:\\\\New Folder\\\\my file.docx')).toBe('E_New Folder_my file.docx');\n    });\n  \n    test('should simplify a nested directory path', () => {\n      expect(simplifyWindowsPath('G:\\\\folder1\\\\folder2\\\\folder3\\\\file.jpeg')).toBe('G_folder1_folder2_folder3_file.jpeg');\n    });\n    test('should simplify a path with single backslash',()=>{\n        expect(simplifyWindowsPath(\"F:\\\\\")).toBe(\"F_\")\n    })\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Simplify file paths in Windows systems into name strings.\n * \n * For example:\n *   Input: C:\\Users\\User\\file.txt\n *   Output: C_Users_User_file.txt\n * \n * @param path - The Windows file path string.\n * @returns The simplified path string.\n */\nfunction simplifyWindowsPath(path: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Simplify file paths in Windows systems into name strings.\n * For example:\n *     Input: C:\\\\Users\\\\User\\\\file.txt\n *     Output: C_Users_User_file.txt\n *\n * @param path The Windows file path string.\n * @return The simplified path string.\n */\nstd::string simplifyWindowsPath(const std::string& path) {}", "test_code": "TEST_CASE(\"Test Simplify Windows Path\") {\n    SECTION(\"Simple Path\") {\n        CHECK(simplifyWindowsPath(\"C:\\\\Users\\\\User\\\\file.txt\") == \"C_Users_User_file.txt\");\n    }\n\n    SECTION(\"Simple Path 2\") {\n        CHECK(simplifyWindowsPath(\"D:\\\\User\\\\file.txt\") == \"D_User_file.txt\");\n    }\n\n    SECTION(\"Path with Spaces\") {\n        CHECK(simplifyWindowsPath(\"E:\\\\New Folder\\\\my file.docx\") == \"E_New Folder_my file.docx\");\n    }\n\n    SECTION(\"Nested Directories\") {\n        CHECK(simplifyWindowsPath(\"G:\\\\folder1\\\\folder2\\\\folder3\\\\file.jpeg\") == \"G_folder1_folder2_folder3_file.jpeg\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Simplify file paths in Windows systems into name strings.\n * For example:\n *     Input: C:\\\\Users\\\\User\\\\file.txt\n *     Output: C_Users_User_file.txt\n *\n * @param path The Windows file path string.\n * @return The simplified path string.\n */\nstd::string simplifyWindowsPath(const std::string& path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Simplifies a given Windows path by replacing the drive letter and colon with the drive letter followed by an underscore,\n * replacing all backslashes with underscores, and removing any leading or trailing underscores.\n *\n * @param path The Windows path to be simplified.\n * @return The simplified path.\n */\npublic static String simplifyWindowsPath(String path) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testSimplePath() {\n        assertEquals(\"C_Users_User_file.txt\", simplifyWindowsPath(\"C:\\\\Users\\\\User\\\\file.txt\"));\n    }\n\n    @Test\n    public void testSimplePath2() {\n        assertEquals(\"D_User_file.txt\", simplifyWindowsPath(\"D:\\\\User\\\\file.txt\"));\n    }\n\n    @Test\n    public void testPathWithSpaces() {\n        assertEquals(\"E_New Folder_my file.docx\", simplifyWindowsPath(\"E:\\\\New Folder\\\\my file.docx\"));\n    }\n\n    @Test\n    public void testNestedDirectories() {\n        assertEquals(\"G_folder1_folder2_folder3_file.jpeg\", simplifyWindowsPath(\"G:\\\\folder1\\\\folder2\\\\folder3\\\\file.jpeg\"));\n    }\n\n    @Test\n    public void testPathWithSingleBackslash(){\n        assertEquals(\"F_\",simplifyWindowsPath(\"F:\\\\\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Simplifies a given Windows path by replacing the drive letter and colon with the drive letter followed by an underscore,\n * replacing all backslashes with underscores, and removing any leading or trailing underscores.\n *\n * @param path The Windows path to be simplified.\n * @return The simplified path.\n */\npublic static String simplifyWindowsPath(String path) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 8, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Implement decryption based on polynomials and keys\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef perform_polynomial_decryption(degree: int, modulus: int, key: List[int], encrypted_data: List[int]) -> List[int]:\n    \"\"\"\n    Implement decryption based on polynomials and keys\n    Args:\n        degree (int): The highest degree of a polynomial is added by one\n        modulus (int): Modulus to use when encrypting question\n        key (List[int]): An array of encrypted keys\n        encrypted_data (List[int]): An array of encrypted question\n\n    Returns: decrypted question\n\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestDecryptFunction(unittest.TestCase):\n    def test_basic_functionality(self):\n        self.assertEqual(perform_polynomial_decryption(4, 5, [1, 2, 3, 4], [5, 6, 7, 8]), [4, 4, 4, 4])\n\n    def test_zero_secret_key(self):\n        self.assertEqual(perform_polynomial_decryption(3, 7, [0, 0, 0], [6, 13, 20]), [6, 6, 6])\n\n    def test_zero_ciphertext(self):\n        self.assertEqual(perform_polynomial_decryption(3, 9, [1, 2, 3], [0, 0, 0]), [8, 7, 6])\n\n    def test_large_values(self):\n        self.assertEqual(perform_polynomial_decryption(2, 1000, [500, 500], [1000, 1000]), [500, 500])", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef perform_polynomial_decryption(degree: int, modulus: int, key: List[int], encrypted_data: List[int]) -> List[int]:\n    \"\"\"\n    Implement decryption based on polynomials and keys\n    Args:\n        degree (int): The highest degree of a polynomial is added by one\n        modulus (int): Modulus to use when encrypting question\n        key (List[int]): An array of encrypted keys\n        encrypted_data (List[int]): An array of encrypted question\n\n    Returns: decrypted question\n\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Implement decryption based on polynomials and keys.\n * @param {number} degree - The highest degree of a polynomial plus one.\n * @param {number} modulus - Modulus used during encryption.\n * @param {Array<number>} key - An array of encrypted keys.\n * @param {Array<number>} encryptedData - An array of encrypted data.\n * @returns {Array<number>} Decrypted data.\n */\nfunction performPolynomialDecryption(degree, modulus, key, encryptedData) {}", "test_code": "describe('TestDecryptFunction', () => {\n    it('test basic functionality', () => {\n        expect(performPolynomialDecryption(4, 5, [1, 2, 3, 4], [5, 6, 7, 8])).toEqual([4, 4, 4, 4]);\n    });\n\n    it('test zero secret key', () => {\n        expect(performPolynomialDecryption(3, 7, [0, 0, 0], [6, 13, 20])).toEqual([6, 6, 6]);\n    });\n\n    it('test zero ciphertext', () => {\n        expect(performPolynomialDecryption(3, 9, [1, 2, 3], [0, 0, 0])).toEqual([8, 7, 6]);\n    });\n\n    it('test large values', () => {\n        expect(performPolynomialDecryption(2, 1000, [500, 500], [1000, 1000])).toEqual([500, 500]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Implement decryption based on polynomials and keys.\n * @param {number} degree - The highest degree of a polynomial plus one.\n * @param {number} modulus - Modulus used during encryption.\n * @param {Array<number>} key - An array of encrypted keys.\n * @param {Array<number>} encryptedData - An array of encrypted data.\n * @returns {Array<number>} Decrypted data.\n */\nfunction performPolynomialDecryption(degree, modulus, key, encryptedData) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Implement decryption based on polynomials and keys.\n * \n * @param degree - The highest degree of a polynomial plus one.\n * @param modulus - Modulus to use when encrypting the data.\n * @param key - An array of encrypted keys.\n * @param encryptedData - An array of encrypted data.\n * \n * @returns The decrypted data.\n */\nfunction performPolynomialDecryption(degree: number, modulus: number, key: number[], encryptedData: number[]): number[] {}", "test_code": "describe('TestDecryptFunction', () => {\n    test('test basic functionality', () => {\n        expect(performPolynomialDecryption(4, 5, [1, 2, 3, 4], [5, 6, 7, 8])).toEqual([4, 4, 4, 4]);\n    });\n\n    test('test zero secret key', () => {\n        expect(performPolynomialDecryption(3, 7, [0, 0, 0], [6, 13, 20])).toEqual([6, 6, 6]);\n    });\n\n    test('test zero ciphertext', () => {\n        expect(performPolynomialDecryption(3, 9, [1, 2, 3], [0, 0, 0])).toEqual([8, 7, 6]);\n    });\n\n    test('test large values', () => {\n        expect(performPolynomialDecryption(2, 1000, [500, 500], [1000, 1000])).toEqual([500, 500]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Implement decryption based on polynomials and keys.\n * \n * @param degree - The highest degree of a polynomial plus one.\n * @param modulus - Modulus to use when encrypting the data.\n * @param key - An array of encrypted keys.\n * @param encryptedData - An array of encrypted data.\n * \n * @returns The decrypted data.\n */\nfunction performPolynomialDecryption(degree: number, modulus: number, key: number[], encryptedData: number[]): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Implement decryption based on polynomials and keys\n *\n * @param degree The highest degree of a polynomial is added by one\n * @param modulus Modulus to use when encrypting question\n * @param key An array of encrypted keys\n * @param encrypted_data An array of encrypted question\n *\n * @return Decrypted question\n */\nstd::vector<int> perform_polynomial_decryption(int degree, int modulus, const std::vector<int>& key, const std::vector<int>& encrypted_data) {}", "test_code": "TEST_CASE(\"Test Decrypt Function\", \"[decrypt]\") {\n    SECTION(\"Basic functionality\") {\n        REQUIRE(perform_polynomial_decryption(4, 5, {1, 2, 3, 4}, {5, 6, 7, 8}) == std::vector<int>({4, 4, 4, 4}));\n    }\n\n    SECTION(\"Zero secret key\") {\n        REQUIRE(perform_polynomial_decryption(3, 7, {0, 0, 0}, {6, 13, 20}) == std::vector<int>({6, 6, 6}));\n    }\n\n    SECTION(\"Zero ciphertext\") {\n        REQUIRE(perform_polynomial_decryption(3, 9, {1, 2, 3}, {0, 0, 0}) == std::vector<int>({8, 7, 6}));\n    }\n\n    SECTION(\"Large values\") {\n        REQUIRE(perform_polynomial_decryption(2, 1000, {500, 500}, {1000, 1000}) == std::vector<int>({500, 500}));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Implement decryption based on polynomials and keys\n *\n * @param degree The highest degree of a polynomial is added by one\n * @param modulus Modulus to use when encrypting question\n * @param key An array of encrypted keys\n * @param encrypted_data An array of encrypted question\n *\n * @return Decrypted question\n */\nstd::vector<int> perform_polynomial_decryption(int degree, int modulus, const std::vector<int>& key, const std::vector<int>& encrypted_data) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Implement decryption based on polynomials and keys.\n *\n * @param degree The highest degree of a polynomial is added by one.\n * @param modulus Modulus to use when encrypting the question.\n * @param key An array of encrypted keys.\n * @param encryptedData An array of encrypted question.\n * @return Decrypted question as a List of integers.\n */\npublic static List<Integer> performPolynomialDecryption(int degree, int modulus, List<Integer> key, List<Integer> encryptedData) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.Arrays;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testBasicFunctionality() {\n        assertEquals(Arrays.asList(4, 4, 4, 4),\n                     performPolynomialDecryption(4, 5, Arrays.asList(1, 2, 3, 4), Arrays.asList(5, 6, 7, 8)));\n    }\n\n    @Test\n    public void testZeroSecretKey() {\n        assertEquals(Arrays.asList(6, 6, 6),\n                     performPolynomialDecryption(3, 7, Arrays.asList(0, 0, 0), Arrays.asList(6, 13, 20)));\n    }\n\n    @Test\n    public void testZeroCiphertext() {\n        assertEquals(Arrays.asList(8, 7, 6),\n                     performPolynomialDecryption(3, 9, Arrays.asList(1, 2, 3), Arrays.asList(0, 0, 0)));\n    }\n\n    @Test\n    public void testLargeValues() {\n        assertEquals(Arrays.asList(500, 500),\n                     performPolynomialDecryption(2, 1000, Arrays.asList(500, 500), Arrays.asList(1000, 1000)));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Implement decryption based on polynomials and keys.\n *\n * @param degree The highest degree of a polynomial is added by one.\n * @param modulus Modulus to use when encrypting the question.\n * @param key An array of encrypted keys.\n * @param encryptedData An array of encrypted question.\n * @return Decrypted question as a List of integers.\n */\npublic static List<Integer> performPolynomialDecryption(int degree, int modulus, List<Integer> key, List<Integer> encryptedData) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 9, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Check whether A point is on a line formed by two points, such as point C is on a line formed by points A and B", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef is_point_on_line(A: List[int], B: List[int], C: List[int]) -> bool:\n    \"\"\"\n    Check whether A point is on a line formed by two points, such as point C is on a line formed by points A and B\n    Args:\n        A (List[int]): point A xy\n        B (List[int]): point B xy\n        C (List[int]): point C xy\n\n    Returns: is C in line of A B\n\n    \"\"\"", "test_code": "import unittest\n\n\ndef is_point_on_line(A, B, C):\n    (x_a, y_a), (x_b, y_b), (x_c, y_c) = A, B, C\n    if x_a == x_b:  # Check for vertical line\n        return x_c == x_a\n    return (y_c - y_a) * (x_b - x_a) == (y_b - y_a) * (x_c - x_a)\n\n\nclass TestPointOnLine(unittest.TestCase):\n    def test_point_on_line(self):\n        A = (0, 0)\n        B = (10, 10)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_point_not_on_line(self):\n        A = (0, 0)\n        B = (10, 10)\n        C = (5, 6)\n        self.assertFalse(is_point_on_line(A, B, C))\n\n    def test_vertical_line(self):\n        A = (5, 0)\n        B = (5, 10)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_horizontal_line(self):\n        A = (0, 5)\n        B = (10, 5)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_point_not_on_vertical_line(self):\n        A = (5, 0)\n        B = (5, 10)\n        C = (6, 5)\n        self.assertFalse(is_point_on_line(A, B, C))\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef is_point_on_line(A: List[int], B: List[int], C: List[int]) -> bool:\n    \"\"\"\n    Check whether A point is on a line formed by two points, such as point C is on a line formed by points A and B\n    Args:\n        A (List[int]): point A xy\n        B (List[int]): point B xy\n        C (List[int]): point C xy\n\n    Returns: is C in line of A B\n\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Check whether a point is on a line formed by two points, such as point C is on a line formed by points A and B.\n * \n * @param {Array<number>} A - Point A [x, y]\n * @param {Array<number>} B - Point B [x, y]\n * @param {Array<number>} C - Point C [x, y]\n * @returns {boolean} - True if point C is on the line formed by points A and B, false otherwise.\n */\nfunction isPointOnLine(A, B, C) {}", "test_code": "describe('TestPointOnLine', () => {\n    test('should return true when point C is on the line formed by points A and B', () => {\n        const A = [0, 0];\n        const B = [10, 10];\n        const C = [5, 5];\n        expect(isPointOnLine(A, B, C)).toBe(true);\n    });\n\n    test('should return false when point C is not on the line formed by points A and B', () => {\n        const A = [0, 0];\n        const B = [10, 10];\n        const C = [5, 6];\n        expect(isPointOnLine(A, B, C)).toBe(false);\n    });\n\n    test('should return true for a vertical line', () => {\n        const A = [5, 0];\n        const B = [5, 10];\n        const C = [5, 5];\n        expect(isPointOnLine(A, B, C)).toBe(true);\n    });\n\n    test('should return true for a horizontal line', () => {\n        const A = [0, 5];\n        const B = [10, 5];\n        const C = [5, 5];\n        expect(isPointOnLine(A, B, C)).toBe(true);\n    });\n\n    test('should return false for a point not on a vertical line', () => {\n        const A = [5, 0];\n        const B = [5, 10];\n        const C = [6, 5];\n        expect(isPointOnLine(A, B, C)).toBe(false);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Check whether a point is on a line formed by two points, such as point C is on a line formed by points A and B.\n * \n * @param {Array<number>} A - Point A [x, y]\n * @param {Array<number>} B - Point B [x, y]\n * @param {Array<number>} C - Point C [x, y]\n * @returns {boolean} - True if point C is on the line formed by points A and B, false otherwise.\n */\nfunction isPointOnLine(A, B, C) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Check whether a point C is on a line formed by points A and B.\n * \n * @param A - Point A coordinates [x, y]\n * @param B - Point B coordinates [x, y]\n * @param C - Point C coordinates [x, y]\n * @returns true if point C is on the line formed by points A and B, false otherwise.\n */\nfunction isPointOnLine(A: [number, number], B: [number, number], C: [number, number]): boolean {}", "test_code": "describe('isPointOnLine', () => {\n    test('should return true when point C is on the line formed by points A and B', () => {\n        const A: [number, number] = [0, 0];\n        const B: [number, number] = [10, 10];\n        const C: [number, number] = [5, 5];\n        expect(isPointOnLine(A, B, C)).toBe(true);\n    });\n\n    test('should return false when point C is not on the line formed by points A and B', () => {\n        const A: [number, number] = [0, 0];\n        const B: [number, number] = [10, 10];\n        const C: [number, number] = [5, 6];\n        expect(isPointOnLine(A, B, C)).toBe(false);\n    });\n\n    test('should return true for a vertical line', () => {\n        const A: [number, number] = [5, 0];\n        const B: [number, number] = [5, 10];\n        const C: [number, number] = [5, 5];\n        expect(isPointOnLine(A, B, C)).toBe(true);\n    });\n\n    test('should return true for a horizontal line', () => {\n        const A: [number, number] = [0, 5];\n        const B: [number, number] = [10, 5];\n        const C: [number, number] = [5, 5];\n        expect(isPointOnLine(A, B, C)).toBe(true);\n    });\n\n    test('should return false for a point not on a vertical line', () => {\n        const A: [number, number] = [5, 0];\n        const B: [number, number] = [5, 10];\n        const C: [number, number] = [6, 5];\n        expect(isPointOnLine(A, B, C)).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Check whether a point C is on a line formed by points A and B.\n * \n * @param A - Point A coordinates [x, y]\n * @param B - Point B coordinates [x, y]\n * @param C - Point C coordinates [x, y]\n * @returns true if point C is on the line formed by points A and B, false otherwise.\n */\nfunction isPointOnLine(A: [number, number], B: [number, number], C: [number, number]): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Check whether a point is on a line formed by two points, such as point C is on a line formed by points A and B.\n *\n * @param A A vector containing the x and y coordinates of point A.\n * @param B A vector containing the x and y coordinates of point B.\n * @param C A vector containing the x and y coordinates of point C.\n *\n * @return True if point C is on the line formed by points A and B, false otherwise.\n */\nbool is_point_on_line(const std::vector<int>& A, const std::vector<int>& B, const std::vector<int>& C) {}", "test_code": "TEST_CASE(\"Test Point On Line\", \"[point_on_line]\") {\n    SECTION(\"Point on line\") {\n        std::vector<int> A = {0, 0};\n        std::vector<int> B = {10, 10};\n        std::vector<int> C = {5, 5};\n        REQUIRE(is_point_on_line(A, B, C));\n    }\n\n    SECTION(\"Point not on line\") {\n        std::vector<int> A = {0, 0};\n        std::vector<int> B = {10, 10};\n        std::vector<int> C = {5, 6};\n        REQUIRE_FALSE(is_point_on_line(A, B, C));\n    }\n\n    SECTION(\"Vertical line\") {\n        std::vector<int> A = {5, 0};\n        std::vector<int> B = {5, 10};\n        std::vector<int> C = {5, 5};\n        REQUIRE(is_point_on_line(A, B, C));\n    }\n\n    SECTION(\"Horizontal line\") {\n        std::vector<int> A = {0, 5};\n        std::vector<int> B = {10, 5};\n        std::vector<int> C = {5, 5};\n        REQUIRE(is_point_on_line(A, B, C));\n    }\n\n    SECTION(\"Point not on vertical line\") {\n        std::vector<int> A = {5, 0};\n        std::vector<int> B = {5, 10};\n        std::vector<int> C = {6, 5};\n        REQUIRE_FALSE(is_point_on_line(A, B, C));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Check whether a point is on a line formed by two points, such as point C is on a line formed by points A and B.\n *\n * @param A A vector containing the x and y coordinates of point A.\n * @param B A vector containing the x and y coordinates of point B.\n * @param C A vector containing the x and y coordinates of point C.\n *\n * @return True if point C is on the line formed by points A and B, false otherwise.\n */\nbool is_point_on_line(const std::vector<int>& A, const std::vector<int>& B, const std::vector<int>& C) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks whether point C is on the line formed by points A and B.\n *\n * @param A an array of two integers representing point A (x, y)\n * @param B an array of two integers representing point B (x, y)\n * @param C an array of two integers representing point C (x, y)\n * @return true if point C is on the line formed by points A and B, false otherwise\n */\npublic static boolean isPointOnLine(int[] A, int[] B, int[] C) {}", "test_code": "package org.real.temp;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport org.junit.Test;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n    @Test\n    public void testPointOnLine() {\n        int[] A = {0, 0};\n        int[] B = {10, 10};\n        int[] C = {5, 5};\n        assertTrue(isPointOnLine(A, B, C));\n    }\n\n    @Test\n    public void testPointNotOnLine() {\n        int[] A = {0, 0};\n        int[] B = {10, 10};\n        int[] C = {5, 6};\n        assertFalse(isPointOnLine(A, B, C));\n    }\n\n    @Test\n    public void testVerticalLine() {\n        int[] A = {5, 0};\n        int[] B = {5, 10};\n        int[] C = {5, 5};\n        assertTrue(isPointOnLine(A, B, C));\n    }\n\n    @Test\n    public void testHorizontalLine() {\n        int[] A = {0, 5};\n        int[] B = {10, 5};\n        int[] C = {5, 5};\n        assertTrue(isPointOnLine(A, B, C));\n    }\n\n    @Test\n    public void testPointNotOnVerticalLine() {\n        int[] A = {5, 0};\n        int[] B = {5, 10};\n        int[] C = {6, 5};\n        assertFalse(isPointOnLine(A, B, C));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks whether point C is on the line formed by points A and B.\n *\n * @param A an array of two integers representing point A (x, y)\n * @param B an array of two integers representing point B (x, y)\n * @param C an array of two integers representing point C (x, y)\n * @return true if point C is on the line formed by points A and B, false otherwise\n */\npublic static boolean isPointOnLine(int[] A, int[] B, int[] C) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 11, "code_type": "class", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Implement a dictionary tree for fast string retrieval and storage\n", "language_version_list": {"python": {"code_signature": "class Trie:\n    \"\"\"\n    Implement a dictionary tree for fast string retrieval and storage\n    \"\"\"\n\n    def insert(self, word):\n        pass\n\n    def search(self, word):\n        pass\n\n    def starts_with(self, prefix):\n        pass\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n", "test_code": "import unittest\n\n\nclass TestTrie(unittest.TestCase):\n    def setUp(self):\n        self.trie = Trie()\n        self.trie.insert(\"apple\")\n        self.trie.insert(\"app\")\n        self.trie.insert(\"apricot\")\n        self.trie.insert(\"banana\")\n        self.trie.insert(\"carrot\")\n        self.trie.insert(\"car\")\n        self.trie.insert(\"care\")\n        self.trie.insert(\"\")\n        self.trie.insert(\"Hello\")\n        self.trie.insert(\"hello\")\n\n    def test_basic_search(self):\n        self.assertTrue(self.trie.search(\"apple\"))\n        self.assertTrue(self.trie.search(\"app\"))\n        self.assertTrue(self.trie.search(\"apricot\"))\n\n    def test_unsuccessful_search(self):\n        self.assertFalse(self.trie.search(\"bandana\"))\n\n    def test_prefix_search(self):\n        self.assertTrue(self.trie.starts_with(\"car\"))\n        self.assertTrue(self.trie.starts_with(\"care\"))\n        self.assertFalse(self.trie.starts_with(\"cat\"))\n\n    def test_empty_string(self):\n        self.assertTrue(self.trie.search(\"\"))\n        self.assertTrue(self.trie.starts_with(\"\"))\n\n    def test_case_sensitivity(self):\n        self.assertTrue(self.trie.search(\"Hello\"))\n        self.assertTrue(self.trie.search(\"hello\"))\n        self.assertFalse(self.trie.search(\"HELLO\"))\n", "prompt": "please write a python class , the class signature as below class Trie:\n    \"\"\"\n    Implement a dictionary tree for fast string retrieval and storage\n    \"\"\"\n\n    def insert(self, word):\n        pass\n\n    def search(self, word):\n        pass\n\n    def starts_with(self, prefix):\n        pass\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Implements a dictionary tree (Trie) for fast string retrieval and storage.\n */\nclass Trie {\n    /**\n     * Inserts a word into the trie.\n     * @param {string} word - The word to insert.\n     */\n    insert(word) {\n        // Implementation goes here\n    }\n\n    /**\n     * Searches for a word in the trie.\n     * @param {string} word - The word to search for.\n     * @returns {boolean} - Returns true if the word is found, false otherwise.\n     */\n    search(word) {\n        // Implementation goes here\n    }\n\n    /**\n     * Checks if there is any word in the trie that starts with the given prefix.\n     * @param {string} prefix - The prefix to check.\n     * @returns {boolean} - Returns true if there is any word with the prefix, false otherwise.\n     */\n    startsWith(prefix) {\n        // Implementation goes here\n    }\n}\n\n/**\n * Represents a node in the Trie.\n */\nclass TrieNode {\n    /**\n     * Constructs a new TrieNode.\n     */\n    constructor() {\n        this.children = {};\n    }\n}", "test_code": "describe('Trie', () => {\n    let trie;\n\n    beforeEach(() => {\n        trie = new Trie();\n        trie.insert(\"apple\");\n        trie.insert(\"app\");\n        trie.insert(\"apricot\");\n        trie.insert(\"banana\");\n        trie.insert(\"carrot\");\n        trie.insert(\"car\");\n        trie.insert(\"care\");\n        trie.insert(\"\");\n        trie.insert(\"Hello\");\n        trie.insert(\"hello\");\n    });\n\n    describe('basic search', () => {\n        it('should find words that exist in the trie', () => {\n            expect(trie.search(\"apple\")).toBe(true);\n            expect(trie.search(\"app\")).toBe(true);\n            expect(trie.search(\"apricot\")).toBe(true);\n        });\n    });\n\n    describe('unsuccessful search', () => {\n        it('should not find words that do not exist in the trie', () => {\n            expect(trie.search(\"bandana\")).toBe(false);\n        });\n    });\n\n    describe('prefix search', () => {\n        it('should find prefixes that exist in the trie', () => {\n            expect(trie.startsWith(\"car\")).toBe(true);\n            expect(trie.startsWith(\"care\")).toBe(true);\n            expect(trie.startsWith(\"cat\")).toBe(false);\n        });\n    });\n\n    describe('empty string', () => {\n        it('should handle empty strings correctly', () => {\n            expect(trie.search(\"\")).toBe(true);\n            expect(trie.startsWith(\"\")).toBe(true);\n        });\n    });\n\n    describe('case sensitivity', () => {\n        it('should handle case sensitivity correctly', () => {\n            expect(trie.search(\"Hello\")).toBe(true);\n            expect(trie.search(\"hello\")).toBe(true);\n            expect(trie.search(\"HELLO\")).toBe(false);\n        });\n    });\n});", "prompt": "please write a javascript class , the class signature as below /**\n * Implements a dictionary tree (Trie) for fast string retrieval and storage.\n */\nclass Trie {\n    /**\n     * Inserts a word into the trie.\n     * @param {string} word - The word to insert.\n     */\n    insert(word) {\n        // Implementation goes here\n    }\n\n    /**\n     * Searches for a word in the trie.\n     * @param {string} word - The word to search for.\n     * @returns {boolean} - Returns true if the word is found, false otherwise.\n     */\n    search(word) {\n        // Implementation goes here\n    }\n\n    /**\n     * Checks if there is any word in the trie that starts with the given prefix.\n     * @param {string} prefix - The prefix to check.\n     * @returns {boolean} - Returns true if there is any word with the prefix, false otherwise.\n     */\n    startsWith(prefix) {\n        // Implementation goes here\n    }\n}\n\n/**\n * Represents a node in the Trie.\n */\nclass TrieNode {\n    /**\n     * Constructs a new TrieNode.\n     */\n    constructor() {\n        this.children = {};\n    }\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Implements a dictionary tree (Trie) for fast string retrieval and storage.\n */\nclass Trie {\n    /**\n     * Inserts a word into the trie.\n     * @param word The word to insert.\n     */\n    insert(word: string): void {\n      // Implementation goes here\n    }\n  \n    /**\n     * Searches for a word in the trie.\n     * @param word The word to search for.\n     * @returns true if the word is found, false otherwise.\n     */\n    search(word: string): boolean {\n      // Implementation goes here\n    }\n  \n    /**\n     * Checks if there is any word in the trie that starts with the given prefix.\n     * @param prefix The prefix to check.\n     * @returns true if there is any word starting with the prefix, false otherwise.\n     */\n    startsWith(prefix: string): boolean {\n      // Implementation goes here\n    }\n  }\n  \n  /**\n   * Represents a node in the Trie.\n   */\n  class TrieNode {\n    children: { [key: string]: TrieNode };\n  \n    constructor() {\n      this.children = {};\n    }\n  }", "test_code": "describe('Trie', () => {\n    let trie: Trie;\n  \n    beforeEach(() => {\n      trie = new Trie();\n      trie.insert(\"apple\");\n      trie.insert(\"app\");\n      trie.insert(\"apricot\");\n      trie.insert(\"banana\");\n      trie.insert(\"carrot\");\n      trie.insert(\"car\");\n      trie.insert(\"care\");\n      trie.insert(\"\");\n      trie.insert(\"Hello\");\n      trie.insert(\"hello\");\n    });\n  \n    it('should search for basic words', () => {\n      expect(trie.search(\"apple\")).toBe(true);\n      expect(trie.search(\"app\")).toBe(true);\n      expect(trie.search(\"apricot\")).toBe(true);\n    });\n  \n    it('should handle unsuccessful searches', () => {\n      expect(trie.search(\"bandana\")).toBe(false);\n    });\n  \n    it('should handle prefix searches', () => {\n      expect(trie.startsWith(\"car\")).toBe(true);\n      expect(trie.startsWith(\"care\")).toBe(true);\n      expect(trie.startsWith(\"cat\")).toBe(false);\n    });\n  \n    it('should handle empty strings', () => {\n      expect(trie.search(\"\")).toBe(true);\n      expect(trie.startsWith(\"\")).toBe(true);\n    });\n  \n    it('should handle case sensitivity', () => {\n      expect(trie.search(\"Hello\")).toBe(true);\n      expect(trie.search(\"hello\")).toBe(true);\n      expect(trie.search(\"HELLO\")).toBe(false);\n    });\n  });", "prompt": "please write a typescript class , the class signature as below /**\n * Implements a dictionary tree (Trie) for fast string retrieval and storage.\n */\nclass Trie {\n    /**\n     * Inserts a word into the trie.\n     * @param word The word to insert.\n     */\n    insert(word: string): void {\n      // Implementation goes here\n    }\n  \n    /**\n     * Searches for a word in the trie.\n     * @param word The word to search for.\n     * @returns true if the word is found, false otherwise.\n     */\n    search(word: string): boolean {\n      // Implementation goes here\n    }\n  \n    /**\n     * Checks if there is any word in the trie that starts with the given prefix.\n     * @param prefix The prefix to check.\n     * @returns true if there is any word starting with the prefix, false otherwise.\n     */\n    startsWith(prefix: string): boolean {\n      // Implementation goes here\n    }\n  }\n  \n  /**\n   * Represents a node in the Trie.\n   */\n  class TrieNode {\n    children: { [key: string]: TrieNode };\n  \n    constructor() {\n      this.children = {};\n    }\n  }", "addition_info": ""}, "c&cpp": {"code_signature": "// TrieNode class\nclass TrieNode {\npublic:\n    std::unordered_map<char, TrieNode*> children;\n\n    TrieNode() {}\n};\n\n// Trie class\nclass Trie {\npublic:\n    /**\n     * Implement a dictionary tree for fast string retrieval and storage\n     */\n    TrieNode* root;\n\n    Trie() : root(new TrieNode()) {}\n\n    ~Trie() {\n        delete root;\n    }\n\n    // Insert a word into the trie\n    void insert(const std::string& word);\n\n    // Search for a word in the trie\n    bool search(const std::string& word);\n\n    // Check if there is any word in the trie that starts with the given prefix\n    bool starts_with(const std::string& prefix);\n};\n\n// Implementation of the insert method\nvoid Trie::insert(const std::string& word) {\n    // Implementation goes here\n    // ...\n}\n\n// Implementation of the search method\nbool Trie::search(const std::string& word) {\n    // Implementation goes here\n    // ...\n}\n\n// Implementation of the starts_with method\nbool Trie::starts_with(const std::string& prefix) {\n    // Implementation goes here\n    // ...\n}", "test_code": "TEST_CASE(\"Test Trie operations\", \"[Trie]\") {\n    Trie trie;\n    trie.insert(\"apple\");\n    trie.insert(\"app\");\n    trie.insert(\"apricot\");\n    trie.insert(\"banana\");\n    trie.insert(\"carrot\");\n    trie.insert(\"car\");\n    trie.insert(\"care\");\n    trie.insert(\"\");\n    trie.insert(\"Hello\");\n    trie.insert(\"hello\");\n\n    SECTION(\"Basic search\") {\n        REQUIRE(trie.search(\"apple\"));\n        REQUIRE(trie.search(\"app\"));\n        REQUIRE(trie.search(\"apricot\"));\n    }\n\n    SECTION(\"Unsuccessful search\") {\n        REQUIRE_FALSE(trie.search(\"bandana\"));\n    }\n\n    SECTION(\"Prefix search\") {\n        REQUIRE(trie.starts_with(\"car\"));\n        REQUIRE(trie.starts_with(\"care\"));\n        REQUIRE_FALSE(trie.starts_with(\"cat\"));\n    }\n\n    SECTION(\"Empty string\") {\n        REQUIRE(trie.search(\"\"));\n        REQUIRE(trie.starts_with(\"\"));\n    }\n\n    SECTION(\"Case sensitivity\") {\n        REQUIRE(trie.search(\"Hello\"));\n        REQUIRE(trie.search(\"hello\"));\n        REQUIRE_FALSE(trie.search(\"HELLO\"));\n    }\n}", "prompt": "please write a cpp class , the class signature as below // TrieNode class\nclass TrieNode {\npublic:\n    std::unordered_map<char, TrieNode*> children;\n\n    TrieNode() {}\n};\n\n// Trie class\nclass Trie {\npublic:\n    /**\n     * Implement a dictionary tree for fast string retrieval and storage\n     */\n    TrieNode* root;\n\n    Trie() : root(new TrieNode()) {}\n\n    ~Trie() {\n        delete root;\n    }\n\n    // Insert a word into the trie\n    void insert(const std::string& word);\n\n    // Search for a word in the trie\n    bool search(const std::string& word);\n\n    // Check if there is any word in the trie that starts with the given prefix\n    bool starts_with(const std::string& prefix);\n};\n\n// Implementation of the insert method\nvoid Trie::insert(const std::string& word) {\n    // Implementation goes here\n    // ...\n}\n\n// Implementation of the search method\nbool Trie::search(const std::string& word) {\n    // Implementation goes here\n    // ...\n}\n\n// Implementation of the starts_with method\nbool Trie::starts_with(const std::string& prefix) {\n    // Implementation goes here\n    // ...\n}", "addition_info": ""}, "java": {"code_signature": "public class Trie {\n\n    /**\n     * Inserts a word into the Trie.\n     *\n     * @param word the word to insert\n     */\n    public void insert(String word) {\n        // Implementation goes here\n    }\n\n    /**\n     * Searches for a word in the Trie.\n     *\n     * @param word the word to search for\n     * @return true if the word is found, false otherwise\n     */\n    public boolean search(String word) {\n        // Implementation goes here\n    }\n\n    /**\n     * Checks if there is any word in the Trie that starts with the given prefix.\n     *\n     * @param prefix the prefix to check\n     * @return true if there is a word starting with the prefix, false otherwise\n     */\n    public boolean startsWith(String prefix) {\n        // Implementation goes here\n    }\n}\n\n/**\n * Represents a node in the Trie.\n */\npublic class TrieNode {\n\n    /**\n     * A map of child nodes indexed by characters.\n     */\n    private final java.util.Map<Character, TrieNode> children = new java.util.HashMap<>();\n\n    /**\n     * Constructs a new TrieNode.\n     */\n    public TrieNode() {\n        // Constructor implementation goes here\n    }\n\n    /**\n     * Checks if this node has a child with the specified character.\n     *\n     * @param ch the character to check\n     * @return true if the child exists, false otherwise\n     */\n    public boolean hasChild(char ch) {\n        return children.containsKey(ch);\n    }\n\n    /**\n     * Gets the child node with the specified character.\n     *\n     * @param ch the character of the child\n     * @return the child node, or null if it does not exist\n     */\n    public TrieNode getChild(char ch) {\n        return children.get(ch);\n    }\n\n    /**\n     * Adds a child node with the specified character.\n     *\n     * @param ch the character of the child\n     */\n    public void addChild(char ch) {\n        if (!children.containsKey(ch)) {\n            children.put(ch, new TrieNode());\n        }\n    }\n\n    /**\n     * Sets the end-of-word flag for this node.\n     */\n    public void setEndOfWord() {\n        // Implementation goes here\n    }\n\n    /**\n     * Checks if this node represents the end of a word.\n     *\n     * @return true if this node is the end of a word, false otherwise\n     */\n    public boolean isEndOfWord() {\n        // Implementation goes here\n    }\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    private Trie trie;\n\n    @Before\n    public void setUp() {\n        trie = new Trie();\n        trie.insert(\"apple\");\n        trie.insert(\"app\");\n        trie.insert(\"apricot\");\n        trie.insert(\"banana\");\n        trie.insert(\"carrot\");\n        trie.insert(\"car\");\n        trie.insert(\"care\");\n        trie.insert(\"\");\n        trie.insert(\"Hello\");\n        trie.insert(\"hello\");\n    }\n\n    @Test\n    public void testBasicSearch() {\n        assertTrue(trie.search(\"apple\"));\n        assertTrue(trie.search(\"app\"));\n        assertTrue(trie.search(\"apricot\"));\n    }\n\n    @Test\n    public void testUnsuccessfulSearch() {\n        assertFalse(trie.search(\"bandana\"));\n    }\n\n    @Test\n    public void testPrefixSearch() {\n        assertTrue(trie.startsWith(\"car\"));\n        assertTrue(trie.startsWith(\"care\"));\n        assertFalse(trie.startsWith(\"cat\"));\n    }\n\n    @Test\n    public void testEmptyString() {\n        assertTrue(trie.search(\"\"));\n        assertTrue(trie.startsWith(\"\"));\n    }\n\n    @Test\n    public void testCaseSensitivity() {\n        assertTrue(trie.search(\"Hello\"));\n        assertTrue(trie.search(\"hello\"));\n        assertFalse(trie.search(\"HELLO\"));\n    }\n}", "prompt": "please write a java class , the function signature as below public class Trie {\n\n    /**\n     * Inserts a word into the Trie.\n     *\n     * @param word the word to insert\n     */\n    public void insert(String word) {\n        // Implementation goes here\n    }\n\n    /**\n     * Searches for a word in the Trie.\n     *\n     * @param word the word to search for\n     * @return true if the word is found, false otherwise\n     */\n    public boolean search(String word) {\n        // Implementation goes here\n    }\n\n    /**\n     * Checks if there is any word in the Trie that starts with the given prefix.\n     *\n     * @param prefix the prefix to check\n     * @return true if there is a word starting with the prefix, false otherwise\n     */\n    public boolean startsWith(String prefix) {\n        // Implementation goes here\n    }\n}\n\n/**\n * Represents a node in the Trie.\n */\npublic class TrieNode {\n\n    /**\n     * A map of child nodes indexed by characters.\n     */\n    private final java.util.Map<Character, TrieNode> children = new java.util.HashMap<>();\n\n    /**\n     * Constructs a new TrieNode.\n     */\n    public TrieNode() {\n        // Constructor implementation goes here\n    }\n\n    /**\n     * Checks if this node has a child with the specified character.\n     *\n     * @param ch the character to check\n     * @return true if the child exists, false otherwise\n     */\n    public boolean hasChild(char ch) {\n        return children.containsKey(ch);\n    }\n\n    /**\n     * Gets the child node with the specified character.\n     *\n     * @param ch the character of the child\n     * @return the child node, or null if it does not exist\n     */\n    public TrieNode getChild(char ch) {\n        return children.get(ch);\n    }\n\n    /**\n     * Adds a child node with the specified character.\n     *\n     * @param ch the character of the child\n     */\n    public void addChild(char ch) {\n        if (!children.containsKey(ch)) {\n            children.put(ch, new TrieNode());\n        }\n    }\n\n    /**\n     * Sets the end-of-word flag for this node.\n     */\n    public void setEndOfWord() {\n        // Implementation goes here\n    }\n\n    /**\n     * Checks if this node represents the end of a word.\n     *\n     * @return true if this node is the end of a word, false otherwise\n     */\n    public boolean isEndOfWord() {\n        // Implementation goes here\n    }\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 12, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Calculates the Euclidean distance between two agents based on their coordinates in the observations.", "language_version_list": {"python": {"code_signature": "def calculate_distance(agent1: str, agent2: str, observations: dict) -> float:\n    \"\"\"\n    Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n\n    Args:\n        agent1 (str): String representation of agent1's identifier.\n        agent2 (str): String representation of agent2's identifier.\n        observations (dict): Dictionary containing observation question with agent identifiers as keys.Each value is a dictionary with 'x' and 'y' keys representing coordinates.\n\n    Returns:\n        float: Euclidean distance between the two agents.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestCalculateDistance(unittest.TestCase):\n\n    def test_same_point(self):\n        # Both agents are at the same point\n        observations = {\n            \"agent1\": {\"x\": 0, \"y\": 0},\n            \"agent2\": {\"x\": 0, \"y\": 0}\n        }\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), 0.0)\n\n    def test_horizontal_distance(self):\n        # Agents are horizontally apart\n        observations = {\n            \"agent1\": {\"x\": 0, \"y\": 0},\n            \"agent2\": {\"x\": 3, \"y\": 0}\n        }\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), 3.0)\n\n    def test_vertical_distance(self):\n        # Agents are vertically apart\n        observations = {\n            \"agent1\": {\"x\": 0, \"y\": 0},\n            \"agent2\": {\"x\": 0, \"y\": 4}\n        }\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), 4.0)\n\n    def test_diagonal_distance(self):\n        # Agents are diagonally apart\n        observations = {\n            \"agent1\": {\"x\": 1, \"y\": 2},\n            \"agent2\": {\"x\": 4, \"y\": 6}\n        }\n        expected_distance = np.sqrt((4 - 1) ** 2 + (6 - 2) ** 2)\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), expected_distance)\n\n    def test_negative_coordinates(self):\n        # Agents have negative coordinates\n        observations = {\n            \"agent1\": {\"x\": -1, \"y\": -1},\n            \"agent2\": {\"x\": -4, \"y\": -5}\n        }\n        expected_distance = np.sqrt((-4 + 1) ** 2 + (-5 + 1) ** 2)\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), expected_distance)", "prompt": "please write a python function , the function signature as below def calculate_distance(agent1: str, agent2: str, observations: dict) -> float:\n    \"\"\"\n    Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n\n    Args:\n        agent1 (str): String representation of agent1's identifier.\n        agent2 (str): String representation of agent2's identifier.\n        observations (dict): Dictionary containing observation question with agent identifiers as keys.Each value is a dictionary with 'x' and 'y' keys representing coordinates.\n\n    Returns:\n        float: Euclidean distance between the two agents.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n *\n * @param {string} agent1 - String representation of agent1's identifier.\n * @param {string} agent2 - String representation of agent2's identifier.\n * @param {Object} observations - Object containing observation data with agent identifiers as keys.\n *                                Each value is an object with 'x' and 'y' properties representing coordinates.\n * @returns {number} Euclidean distance between the two agents.\n */\nfunction calculateDistance(agent1, agent2, observations) {}", "test_code": "describe('TestCalculateDistance', () => {\n    it('should calculate the distance when both agents are at the same point', () => {\n        const observations = {\n            \"agent1\": { x: 0, y: 0 },\n            \"agent2\": { x: 0, y: 0 }\n        };\n        expect(calculateDistance(\"agent1\", \"agent2\", observations)).toBeCloseTo(0.0);\n    });\n\n    it('should calculate the horizontal distance', () => {\n        const observations = {\n            \"agent1\": { x: 0, y: 0 },\n            \"agent2\": { x: 3, y: 0 }\n        };\n        expect(calculateDistance(\"agent1\", \"agent2\", observations)).toBeCloseTo(3.0);\n    });\n\n    it('should calculate the vertical distance', () => {\n        const observations = {\n            \"agent1\": { x: 0, y: 0 },\n            \"agent2\": { x: 0, y: 4 }\n        };\n        expect(calculateDistance(\"agent1\", \"agent2\", observations)).toBeCloseTo(4.0);\n    });\n\n    it('should calculate the diagonal distance', () => {\n        const observations = {\n            \"agent1\": { x: 1, y: 2 },\n            \"agent2\": { x: 4, y: 6 }\n        };\n        const expectedDistance = Math.sqrt(Math.pow(4 - 1, 2) + Math.pow(6 - 2, 2));\n        expect(calculateDistance(\"agent1\", \"agent2\", observations)).toBeCloseTo(expectedDistance);\n    });\n\n    it('should calculate the distance with negative coordinates', () => {\n        const observations = {\n            \"agent1\": { x: -1, y: -1 },\n            \"agent2\": { x: -4, y: -5 }\n        };\n        const expectedDistance = Math.sqrt(Math.pow(-4 + 1, 2) + Math.pow(-5 + 1, 2));\n        expect(calculateDistance(\"agent1\", \"agent2\", observations)).toBeCloseTo(expectedDistance);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n *\n * @param {string} agent1 - String representation of agent1's identifier.\n * @param {string} agent2 - String representation of agent2's identifier.\n * @param {Object} observations - Object containing observation data with agent identifiers as keys.\n *                                Each value is an object with 'x' and 'y' properties representing coordinates.\n * @returns {number} Euclidean distance between the two agents.\n */\nfunction calculateDistance(agent1, agent2, observations) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n *\n * @param agent1 - String representation of agent1's identifier.\n * @param agent2 - String representation of agent2's identifier.\n * @param observations - Dictionary containing observation data with agent identifiers as keys.\n *                       Each value is an object with 'x' and 'y' properties representing coordinates.\n * @returns The Euclidean distance between the two agents.\n */\nfunction calculateDistance(agent1: string, agent2: string, observations: Record<string, { x: number; y: number }>): number {", "test_code": "describe('TestCalculateDistance', () => {\n    it('should return 0.0 when both agents are at the same point', () => {\n        const observations: ObservationData = {\n            \"agent1\": { x: 0, y: 0 },\n            \"agent2\": { x: 0, y: 0 }\n        };\n\n        expect(calculateDistance(\"agent1\", \"agent2\", observations)).toBeCloseTo(0.0);\n    });\n\n    it('should return 3.0 when agents are horizontally apart', () => {\n        const observations: ObservationData = {\n            \"agent1\": { x: 0, y: 0 },\n            \"agent2\": { x: 3, y: 0 }\n        };\n\n        expect(calculateDistance(\"agent1\", \"agent2\", observations)).toBeCloseTo(3.0);\n    });\n\n    it('should return 4.0 when agents are vertically apart', () => {\n        const observations: ObservationData = {\n            \"agent1\": { x: 0, y: 0 },\n            \"agent2\": { x: 0, y: 4 }\n        };\n\n        expect(calculateDistance(\"agent1\", \"agent2\", observations)).toBeCloseTo(4.0);\n    });\n\n    it('should return the correct diagonal distance', () => {\n        const observations: ObservationData = {\n            \"agent1\": { x: 1, y: 2 },\n            \"agent2\": { x: 4, y: 6 }\n        };\n\n        const expectedDistance = Math.sqrt(Math.pow(4 - 1, 2) + Math.pow(6 - 2, 2));\n        expect(calculateDistance(\"agent1\", \"agent2\", observations)).toBeCloseTo(expectedDistance);\n    });\n\n    it('should return the correct distance with negative coordinates', () => {\n        const observations: ObservationData = {\n            \"agent1\": { x: -1, y: -1 },\n            \"agent2\": { x: -4, y: -5 }\n        };\n\n        const expectedDistance = Math.sqrt(Math.pow(-4 + 1, 2) + Math.pow(-5 + 1, 2));\n        expect(calculateDistance(\"agent1\", \"agent2\", observations)).toBeCloseTo(expectedDistance);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n *\n * @param agent1 - String representation of agent1's identifier.\n * @param agent2 - String representation of agent2's identifier.\n * @param observations - Dictionary containing observation data with agent identifiers as keys.\n *                       Each value is an object with 'x' and 'y' properties representing coordinates.\n * @returns The Euclidean distance between the two agents.\n */\nfunction calculateDistance(agent1: string, agent2: string, observations: Record<string, { x: number; y: number }>): number {", "addition_info": "type ObservationData = {\n    [agentId: string]: {\n        x: number;\n        y: number;\n    };\n};"}, "c&cpp": {"code_signature": "/**\n * @brief Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n *\n * @param agent1 A string representation of agent1's identifier.\n * @param agent2 A string representation of agent2's identifier.\n * @param observations A map containing observation data with agent identifiers as keys.\n *                     Each value is a map with 'x' and 'y' keys representing coordinates.\n * @return The Euclidean distance between the two agents.\n */\nfloat calculate_distance(const std::string& agent1, const std::string& agent2, \n                         const std::map<std::string, std::map<std::string, float>>& observations) {}", "test_code": "TEST_CASE(\"Test Calculate Distance\") {\n    SECTION(\"Same Point\") {\n        // Both agents are at the same point\n        std::map<std::string, std::map<std::string, float>> observations = {\n            {\"agent1\", {{\"x\", 0.0f}, {\"y\", 0.0f}}},\n            {\"agent2\", {{\"x\", 0.0f}, {\"y\", 0.0f}}}\n        };\n        REQUIRE(calculate_distance(\"agent1\", \"agent2\", observations) == Approx(0.0f));\n    }\n\n    SECTION(\"Horizontal Distance\") {\n        // Agents are horizontally apart\n        std::map<std::string, std::map<std::string, float>> observations = {\n            {\"agent1\", {{\"x\", 0.0f}, {\"y\", 0.0f}}},\n            {\"agent2\", {{\"x\", 3.0f}, {\"y\", 0.0f}}}\n        };\n        REQUIRE(calculate_distance(\"agent1\", \"agent2\", observations) == Approx(3.0f));\n    }\n\n    SECTION(\"Vertical Distance\") {\n        // Agents are vertically apart\n        std::map<std::string, std::map<std::string, float>> observations = {\n            {\"agent1\", {{\"x\", 0.0f}, {\"y\", 0.0f}}},\n            {\"agent2\", {{\"x\", 0.0f}, {\"y\", 4.0f}}}\n        };\n        REQUIRE(calculate_distance(\"agent1\", \"agent2\", observations) == Approx(4.0f));\n    }\n\n    SECTION(\"Diagonal Distance\") {\n        // Agents are diagonally apart\n        std::map<std::string, std::map<std::string, float>> observations = {\n            {\"agent1\", {{\"x\", 1.0f}, {\"y\", 2.0f}}},\n            {\"agent2\", {{\"x\", 4.0f}, {\"y\", 6.0f}}}\n        };\n        float expected_distance = std::sqrt(std::pow(4.0f - 1.0f, 2) + std::pow(6.0f - 2.0f, 2));\n        REQUIRE(calculate_distance(\"agent1\", \"agent2\", observations) == Approx(expected_distance));\n    }\n\n    SECTION(\"Negative Coordinates\") {\n        // Agents have negative coordinates\n        std::map<std::string, std::map<std::string, float>> observations = {\n            {\"agent1\", {{\"x\", -1.0f}, {\"y\", -1.0f}}},\n            {\"agent2\", {{\"x\", -4.0f}, {\"y\", -5.0f}}}\n        };\n        float expected_distance = std::sqrt(std::pow(-4.0f + 1.0f, 2) + std::pow(-5.0f + 1.0f, 2));\n        REQUIRE(calculate_distance(\"agent1\", \"agent2\", observations) == Approx(expected_distance));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n *\n * @param agent1 A string representation of agent1's identifier.\n * @param agent2 A string representation of agent2's identifier.\n * @param observations A map containing observation data with agent identifiers as keys.\n *                     Each value is a map with 'x' and 'y' keys representing coordinates.\n * @return The Euclidean distance between the two agents.\n */\nfloat calculate_distance(const std::string& agent1, const std::string& agent2, \n                         const std::map<std::string, std::map<std::string, float>>& observations) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n *\n * @param agent1      String representation of agent1's identifier.\n * @param agent2      String representation of agent2's identifier.\n * @param observations Map containing observation data with agent identifiers as keys.\n *                     Each value is a Map with 'x' and 'y' keys representing coordinates.\n * @return The Euclidean distance between the two agents.\n */\npublic static double calculateDistance(String agent1, String agent2, Map<String, Map<String, Double>> observations) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testSamePoint() {\n        // Both agents are at the same point\n        Map<String, Map<String, Double>> observations = new HashMap<>();\n        Map<String, Double> agent1Coordinates = new HashMap<>();\n        agent1Coordinates.put(\"x\", 0.0);\n        agent1Coordinates.put(\"y\", 0.0);\n        Map<String, Double> agent2Coordinates = new HashMap<>();\n        agent2Coordinates.put(\"x\", 0.0);\n        agent2Coordinates.put(\"y\", 0.0);\n\n        observations.put(\"agent1\", agent1Coordinates);\n        observations.put(\"agent2\", agent2Coordinates);\n\n        double distance = calculateDistance(\"agent1\", \"agent2\", observations);\n        assertEquals(0.0, distance, 0.001);\n    }\n\n    @Test\n    public void testHorizontalDistance() {\n        // Agents are horizontally apart\n        Map<String, Map<String, Double>> observations = new HashMap<>();\n        Map<String, Double> agent1Coordinates = new HashMap<>();\n        agent1Coordinates.put(\"x\", 0.0);\n        agent1Coordinates.put(\"y\", 0.0);\n        Map<String, Double> agent2Coordinates = new HashMap<>();\n        agent2Coordinates.put(\"x\", 3.0);\n        agent2Coordinates.put(\"y\", 0.0);\n\n        observations.put(\"agent1\", agent1Coordinates);\n        observations.put(\"agent2\", agent2Coordinates);\n\n        double distance = calculateDistance(\"agent1\", \"agent2\", observations);\n        assertEquals(3.0, distance, 0.001);\n    }\n\n    @Test\n    public void testVerticalDistance() {\n        // Agents are vertically apart\n        Map<String, Map<String, Double>> observations = new HashMap<>();\n        Map<String, Double> agent1Coordinates = new HashMap<>();\n        agent1Coordinates.put(\"x\", 0.0);\n        agent1Coordinates.put(\"y\", 0.0);\n        Map<String, Double> agent2Coordinates = new HashMap<>();\n        agent2Coordinates.put(\"x\", 0.0);\n        agent2Coordinates.put(\"y\", 4.0);\n\n        observations.put(\"agent1\", agent1Coordinates);\n        observations.put(\"agent2\", agent2Coordinates);\n\n        double distance = calculateDistance(\"agent1\", \"agent2\", observations);\n        assertEquals(4.0, distance, 0.001);\n    }\n\n    @Test\n    public void testDiagonalDistance() {\n        // Agents are diagonally apart\n        Map<String, Map<String, Double>> observations = new HashMap<>();\n        Map<String, Double> agent1Coordinates = new HashMap<>();\n        agent1Coordinates.put(\"x\", 1.0);\n        agent1Coordinates.put(\"y\", 2.0);\n        Map<String, Double> agent2Coordinates = new HashMap<>();\n        agent2Coordinates.put(\"x\", 4.0);\n        agent2Coordinates.put(\"y\", 6.0);\n\n        observations.put(\"agent1\", agent1Coordinates);\n        observations.put(\"agent2\", agent2Coordinates);\n\n        double expectedDistance = Math.sqrt(Math.pow(4.0 - 1.0, 2) + Math.pow(6.0 - 2.0, 2));\n        double distance = calculateDistance(\"agent1\", \"agent2\", observations);\n        assertEquals(expectedDistance, distance, 0.001);\n    }\n\n    @Test\n    public void testNegativeCoordinates() {\n        // Agents have negative coordinates\n        Map<String, Map<String, Double>> observations = new HashMap<>();\n        Map<String, Double> agent1Coordinates = new HashMap<>();\n        agent1Coordinates.put(\"x\", -1.0);\n        agent1Coordinates.put(\"y\", -1.0);\n        Map<String, Double> agent2Coordinates = new HashMap<>();\n        agent2Coordinates.put(\"x\", -4.0);\n        agent2Coordinates.put(\"y\", -5.0);\n\n        observations.put(\"agent1\", agent1Coordinates);\n        observations.put(\"agent2\", agent2Coordinates);\n\n        double expectedDistance = Math.sqrt(Math.pow(-4.0 + 1.0, 2) + Math.pow(-5.0 + 1.0, 2));\n        double distance = calculateDistance(\"agent1\", \"agent2\", observations);\n        assertEquals(expectedDistance, distance, 0.001);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n *\n * @param agent1      String representation of agent1's identifier.\n * @param agent2      String representation of agent2's identifier.\n * @param observations Map containing observation data with agent identifiers as keys.\n *                     Each value is a Map with 'x' and 'y' keys representing coordinates.\n * @return The Euclidean distance between the two agents.\n */\npublic static double calculateDistance(String agent1, String agent2, Map<String, Map<String, Double>> observations) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 13, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Parse the string of the table in Markdown format and return a list of tuples, one for each row in the table", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef parse_markdown_table(md_table: str) -> List[tuple]:\n    \"\"\"\n    Parses a Markdown formatted table into a list of tuples, each tuple representing a row.\n\n    Args:\n        md_table (str): A string representing a Markdown table.\n\n    Returns:\n        list of tuples: A list where each tuple represents a row in the table.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestParseMarkdownTable(unittest.TestCase):\n    def test_standard_table(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        | Row1Col1 | Row1Col2 | Row1Col3 |\n        | Row2Col1 | Row2Col2 | Row2Col3 |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('Row1Col1', 'Row1Col2', 'Row1Col3'),\n            ('Row2Col1', 'Row2Col2', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_inconsistent_columns(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 |\n        |----------|----------|\n        | Row1     | Row1Col2 | ExtraCol |\n        | Row2     |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2'),\n            ('Row1', 'Row1Col2', 'ExtraCol'),\n            ('Row2',)\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_empty_cells(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          | Row1Col2 |          |\n        | Row2Col1 |          | Row2Col3 |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('', 'Row1Col2', ''),\n            ('Row2Col1', '', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_all_empty_rows(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          |          |          |\n        |          |          |          |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('', '', ''),\n            ('', '', '')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_excessive_whitespace(self):\n        md_table = \"\"\"\n        |  Header 1  |  Header 2  |  Header 3  |\n        |------------|------------|------------|\n        |  Row1Col1  |  Row1Col2  |  Row1Col3  |\n        |  Row2Col1  |  Row2Col2  |  Row2Col3  |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('Row1Col1', 'Row1Col2', 'Row1Col3'),\n            ('Row2Col1', 'Row2Col2', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n\ndef parse_markdown_table(md_table):\n    \"\"\"\n    Parses a Markdown formatted table into a list of tuples, each tuple representing a row.\n\n    Args:\n        md_table (str): A string representing a Markdown table.\n\n    Returns:\n        list of tuples: A list where each tuple represents a row in the table.\n    \"\"\"\n    # Split the input string into lines and strip whitespace\n    lines = md_table.strip().split('\\n')\n\n    # Filter out the separator line for the header (which usually contains \"---\")\n    lines = [line for line in lines if not line.strip().startswith('|---')]\n\n    # Initialize the list to store each row as a tuple\n    table_data = []\n\n    # Process each line\n    for line in lines:\n        # Strip leading and trailing spaces and pipes, then split by \"|\"\n        row = line.strip('| \\n').split('|')\n        # Strip spaces from each cell, handle empty cells, and create a tuple\n        table_data.append(tuple(cell.strip() for cell in row if cell.strip() or cell == ''))\n\n    return table_data\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef parse_markdown_table(md_table: str) -> List[tuple]:\n    \"\"\"\n    Parses a Markdown formatted table into a list of tuples, each tuple representing a row.\n\n    Args:\n        md_table (str): A string representing a Markdown table.\n\n    Returns:\n        list of tuples: A list where each tuple represents a row in the table.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Parses a Markdown formatted table into an array of tuples, each tuple representing a row.\n *\n * @param {string} mdTable - A string representing a Markdown table.\n * @returns {Array<Array<string>>} An array where each sub-array represents a row in the table.\n */\nfunction parseMarkdownTable(mdTable) {}", "test_code": "describe('parseMarkdownTable', () => {\n    it('should correctly parse a standard table', () => {\n        const mdTable = `\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        | Row1Col1 | Row1Col2 | Row1Col3 |\n        | Row2Col1 | Row2Col2 | Row2Col3 |\n        `;\n        const expected = [\n            ['Header 1', 'Header 2', 'Header 3'],\n            ['Row1Col1', 'Row1Col2', 'Row1Col3'],\n            ['Row2Col1', 'Row2Col2', 'Row2Col3']\n        ];\n        const result = parseMarkdownTable(mdTable);\n        expect(result).toEqual(expected);\n    });\n\n    it('should correctly parse a table with inconsistent columns', () => {\n        const mdTable = `\n        | Header 1 | Header 2 |\n        |----------|----------|\n        | Row1     | Row1Col2 | ExtraCol |\n        | Row2     |\n        `;\n        const expected = [\n            ['Header 1', 'Header 2'],\n            ['Row1', 'Row1Col2', 'ExtraCol'],\n            ['Row2']\n        ];\n        const result = parseMarkdownTable(mdTable);\n        expect(result).toEqual(expected);\n    });\n\n    it('should correctly parse a table with empty cells', () => {\n        const mdTable = `\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          | Row1Col2 |          |\n        | Row2Col1 |          | Row2Col3 |\n        `;\n        const expected = [\n            ['Header 1', 'Header 2', 'Header 3'],\n            ['', 'Row1Col2', ''],\n            ['Row2Col1', '', 'Row2Col3']\n        ];\n        const result = parseMarkdownTable(mdTable);\n        expect(result).toEqual(expected);\n    });\n\n    it('should correctly parse a table with all empty rows', () => {\n        const mdTable = `\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          |          |          |\n        |          |          |          |\n        `;\n        const expected = [\n            ['Header 1', 'Header 2', 'Header 3'],\n            ['', '', ''],\n            ['', '', '']\n        ];\n        const result = parseMarkdownTable(mdTable);\n        expect(result).toEqual(expected);\n    });\n\n    it('should correctly parse a table with excessive whitespace', () => {\n        const mdTable = `\n        |  Header 1  |  Header 2  |  Header 3  |\n        |------------|------------|------------|\n        |  Row1Col1  |  Row1Col2  |  Row1Col3  |\n        |  Row2Col1  |  Row2Col2  |  Row2Col3  |\n        `;\n        const expected = [\n            ['Header 1', 'Header 2', 'Header 3'],\n            ['Row1Col1', 'Row1Col2', 'Row1Col3'],\n            ['Row2Col1', 'Row2Col2', 'Row2Col3']\n        ];\n        const result = parseMarkdownTable(mdTable);\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Parses a Markdown formatted table into an array of tuples, each tuple representing a row.\n *\n * @param {string} mdTable - A string representing a Markdown table.\n * @returns {Array<Array<string>>} An array where each sub-array represents a row in the table.\n */\nfunction parseMarkdownTable(mdTable) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Parses a Markdown table into an array of tuples where each tuple represents a row in the table.\n *\n * @param mdTable - A string representing the Markdown table. The string should include rows separated by newline characters,\n *                  and columns separated by pipes (`|`). The function assumes that the table may include a header separator\n *                  (usually a line of dashes) which will be ignored during parsing.\n *\n * @returns An array of tuples, where each tuple represents a row of the table. The first element of the tuple corresponds to\n *          the first cell in the row (typically the header or first column), and the subsequent elements represent the other\n *          cells in the row. Empty cells will be represented as empty strings.\n *\n * @example\n * const markdownTable = `\n * | Name     | Age | City     |\n * |----------|-----|----------|\n * | Alice    | 25  | New York |\n * | Bob      | 30  | London   |\n * `;\n */\nfunction parseMarkdownTable(mdTable: string): Array<[string]> {}\n", "test_code": "describe('parseMarkdownTable', () => {\n    test('should correctly parse a standard table', () => {\n        const mdTable = `\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        | Row1Col1 | Row1Col2 | Row1Col3 |\n        | Row2Col1 | Row2Col2 | Row2Col3 |\n        `;\n        const expected = [\n            ['Header 1', 'Header 2', 'Header 3'],\n            ['Row1Col1', 'Row1Col2', 'Row1Col3'],\n            ['Row2Col1', 'Row2Col2', 'Row2Col3']\n        ];\n        const result = parseMarkdownTable(mdTable);\n        expect(result).toEqual(expected);\n    });\n\n    test('should correctly parse a table with inconsistent columns', () => {\n        const mdTable = `\n        | Header 1 | Header 2 |\n        |----------|----------|\n        | Row1     | Row1Col2 | ExtraCol |\n        | Row2     |\n        `;\n        const expected = [\n            ['Header 1', 'Header 2'],\n            ['Row1', 'Row1Col2', 'ExtraCol'],\n            ['Row2']\n        ];\n        const result = parseMarkdownTable(mdTable);\n        expect(result).toEqual(expected);\n    });\n\n    test('should correctly parse a table with empty cells', () => {\n        const mdTable = `\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          | Row1Col2 |          |\n        | Row2Col1 |          | Row2Col3 |\n        `;\n        const expected = [\n            ['Header 1', 'Header 2', 'Header 3'],\n            ['', 'Row1Col2', ''],\n            ['Row2Col1', '', 'Row2Col3']\n        ];\n        const result = parseMarkdownTable(mdTable);\n        expect(result).toEqual(expected);\n    });\n\n    test('should correctly parse a table with all empty rows', () => {\n        const mdTable = `\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          |          |          |\n        |          |          |          |\n        `;\n        const expected = [\n            ['Header 1', 'Header 2', 'Header 3'],\n            ['', '', ''],\n            ['', '', '']\n        ];\n        const result = parseMarkdownTable(mdTable);\n        expect(result).toEqual(expected);\n    });\n\n    test('should correctly parse a table with excessive whitespace', () => {\n        const mdTable = `\n        |  Header 1  |  Header 2  |  Header 3  |\n        |------------|------------|------------|\n        |  Row1Col1  |  Row1Col2  |  Row1Col3  |\n        |  Row2Col1  |  Row2Col2  |  Row2Col3  |\n        `;\n        const expected = [\n            ['Header 1', 'Header 2', 'Header 3'],\n            ['Row1Col1', 'Row1Col2', 'Row1Col3'],\n            ['Row2Col1', 'Row2Col2', 'Row2Col3']\n        ];\n        const result = parseMarkdownTable(mdTable);\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Parses a Markdown table into an array of tuples where each tuple represents a row in the table.\n *\n * @param mdTable - A string representing the Markdown table. The string should include rows separated by newline characters,\n *                  and columns separated by pipes (`|`). The function assumes that the table may include a header separator\n *                  (usually a line of dashes) which will be ignored during parsing.\n *\n * @returns An array of tuples, where each tuple represents a row of the table. The first element of the tuple corresponds to\n *          the first cell in the row (typically the header or first column), and the subsequent elements represent the other\n *          cells in the row. Empty cells will be represented as empty strings.\n *\n * @example\n * const markdownTable = `\n * | Name     | Age | City     |\n * |----------|-----|----------|\n * | Alice    | 25  | New York |\n * | Bob      | 30  | London   |\n * `;\n */\nfunction parseMarkdownTable(mdTable: string): Array<[string]> {}\n", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Parses a Markdown formatted table into a vector of tuples, each tuple representing a row.\n *\n * @param md_table A string representing a Markdown table.\n * @return A vector where each tuple represents a row in the table.\n */\nstd::vector<std::tuple<std::string, std::string, std::string>> parse_markdown_table(const std::string& md_table) {}", "test_code": "TEST_CASE(\"Test parse_markdown_table\", \"[parse_markdown_table]\") {\n    SECTION(\"test_standard_table\") {\n        std::string md_table = R\"(\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        | Row1Col1 | Row1Col2 | Row1Col3 |\n        | Row2Col1 | Row2Col2 | Row2Col3 |\n        )\";\n        std::vector<std::tuple<std::string, std::string, std::string>> expected = {\n            {\"Header 1\", \"Header 2\", \"Header 3\"},\n            {\"Row1Col1\", \"Row1Col2\", \"Row1Col3\"},\n            {\"Row2Col1\", \"Row2Col2\", \"Row2Col3\"}\n        };\n        auto result = parse_markdown_table(md_table);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_inconsistent_columns\") {\n        std::string md_table = R\"(\n        | Header 1 | Header 2 |\n        |----------|----------|\n        | Row1     | Row1Col2 | ExtraCol |\n        | Row2     |\n        )\";\n        std::vector<std::tuple<std::string, std::string, std::string>> expected = {\n            {\"Header 1\", \"Header 2\"},\n            {\"Row1\", \"Row1Col2\", \"ExtraCol\"},\n            {\"Row2\"}\n        };\n        auto result = parse_markdown_table(md_table);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_empty_cells\") {\n        std::string md_table = R\"(\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          | Row1Col2 |          |\n        | Row2Col1 |          | Row2Col3 |\n        )\";\n        std::vector<std::tuple<std::string, std::string, std::string>> expected = {\n            {\"Header 1\", \"Header 2\", \"Header 3\"},\n            {\"\", \"Row1Col2\", \"\"},\n            {\"Row2Col1\", \"\", \"Row2Col3\"}\n        };\n        auto result = parse_markdown_table(md_table);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_all_empty_rows\") {\n        std::string md_table = R\"(\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          |          |          |\n        |          |          |          |\n        )\";\n        std::vector<std::tuple<std::string, std::string, std::string>> expected = {\n            {\"Header 1\", \"Header 2\", \"Header 3\"},\n            {\"\", \"\", \"\"},\n            {\"\", \"\", \"\"}\n        };\n        auto result = parse_markdown_table(md_table);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_excessive_whitespace\") {\n        std::string md_table = R\"(\n        |  Header 1  |  Header 2  |  Header 3  |\n        |------------|------------|------------|\n        |  Row1Col1  |  Row1Col2  |  Row1Col3  |\n        |  Row2Col1  |  Row2Col2  |  Row2Col3  |\n        )\";\n        std::vector<std::tuple<std::string, std::string, std::string>> expected = {\n            {\"Header 1\", \"Header 2\", \"Header 3\"},\n            {\"Row1Col1\", \"Row1Col2\", \"Row1Col3\"},\n            {\"Row2Col1\", \"Row2Col2\", \"Row2Col3\"}\n        };\n        auto result = parse_markdown_table(md_table);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Parses a Markdown formatted table into a vector of tuples, each tuple representing a row.\n *\n * @param md_table A string representing a Markdown table.\n * @return A vector where each tuple represents a row in the table.\n */\nstd::vector<std::tuple<std::string, std::string, std::string>> parse_markdown_table(const std::string& md_table) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Parses a Markdown formatted table into a list of arrays, each array representing a row.\n *\n * @param mdTable A string representing a Markdown table.\n * @return A list where each array represents a row in the table.\n */\npublic static List<String[]> parseMarkdownTable(String mdTable) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testStandardTable() {\n        String mdTable = \"| Header 1 | Header 2 | Header 3 |\\n\" +\n                         \"|----------|----------|----------|\\n\" +\n                         \"| Row1Col1 | Row1Col2 | Row1Col3 |\\n\" +\n                         \"| Row2Col1 | Row2Col2 | Row2Col3 |\";\n\n        List<String[]> expected = Arrays.asList(\n            new String[]{\"Header 1\", \"Header 2\", \"Header 3\"},\n            new String[]{\"Row1Col1\", \"Row1Col2\", \"Row1Col3\"},\n            new String[]{\"Row2Col1\", \"Row2Col2\", \"Row2Col3\"}\n        );\n\n        List<String[]> result = parseMarkdownTable(mdTable);\n\n        assertEquals(expected.size(), result.size());\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(Arrays.asList(expected.get(i)), Arrays.asList(result.get(i)));\n        }\n    }\n\n    @Test\n    public void testInconsistentColumns() {\n        String mdTable = \"| Header 1 | Header 2 |\\n\" +\n                         \"|----------|----------|\\n\" +\n                         \"| Row1     | Row1Col2 | ExtraCol |\\n\" +\n                         \"| Row2     |\";\n\n        List<String[]> expected = Arrays.asList(\n            new String[]{\"Header 1\", \"Header 2\"},\n            new String[]{\"Row1\", \"Row1Col2\", \"ExtraCol\"},\n            new String[]{\"Row2\"}\n        );\n\n        List<String[]> result = parseMarkdownTable(mdTable);\n\n        assertEquals(expected.size(), result.size());\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(Arrays.asList(expected.get(i)), Arrays.asList(result.get(i)));\n        }\n    }\n\n    @Test\n    public void testEmptyCells() {\n        String mdTable = \"| Header 1 | Header 2 | Header 3 |\\n\" +\n                         \"|----------|----------|----------|\\n\" +\n                         \"|          | Row1Col2 |          |\\n\" +\n                         \"| Row2Col1 |          | Row2Col3 |\";\n\n        List<String[]> expected = Arrays.asList(\n            new String[]{\"Header 1\", \"Header 2\", \"Header 3\"},\n            new String[]{\"\", \"Row1Col2\", \"\"},\n            new String[]{\"Row2Col1\", \"\", \"Row2Col3\"}\n        );\n\n        List<String[]> result = parseMarkdownTable(mdTable);\n\n        assertEquals(expected.size(), result.size());\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(Arrays.asList(expected.get(i)), Arrays.asList(result.get(i)));\n        }\n    }\n\n    @Test\n    public void testAllEmptyRows() {\n        String mdTable = \"| Header 1 | Header 2 | Header 3 |\\n\" +\n                         \"|----------|----------|----------|\\n\" +\n                         \"|          |          |          |\\n\" +\n                         \"|          |          |          |\";\n\n        List<String[]> expected = Arrays.asList(\n            new String[]{\"Header 1\", \"Header 2\", \"Header 3\"},\n            new String[]{\"\", \"\", \"\"},\n            new String[]{\"\", \"\", \"\"}\n        );\n\n        List<String[]> result = parseMarkdownTable(mdTable);\n\n        assertEquals(expected.size(), result.size());\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(Arrays.asList(expected.get(i)), Arrays.asList(result.get(i)));\n        }\n    }\n\n    @Test\n    public void testExcessiveWhitespace() {\n        String mdTable = \"|  Header 1  |  Header 2  |  Header 3  |\\n\" +\n                         \"|------------|------------|------------|\\n\" +\n                         \"|  Row1Col1  |  Row1Col2  |  Row1Col3  |\\n\" +\n                         \"|  Row2Col1  |  Row2Col2  |  Row2Col3  |\";\n\n        List<String[]> expected = Arrays.asList(\n            new String[]{\"Header 1\", \"Header 2\", \"Header 3\"},\n            new String[]{\"Row1Col1\", \"Row1Col2\", \"Row1Col3\"},\n            new String[]{\"Row2Col1\", \"Row2Col2\", \"Row2Col3\"}\n        );\n\n        List<String[]> result = parseMarkdownTable(mdTable);\n\n        assertEquals(expected.size(), result.size());\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(Arrays.asList(expected.get(i)), Arrays.asList(result.get(i)));\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Parses a Markdown formatted table into a list of arrays, each array representing a row.\n *\n * @param mdTable A string representing a Markdown table.\n * @return A list where each array represents a row in the table.\n */\npublic static List<String[]> parseMarkdownTable(String mdTable) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 17, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "calculate the distance between two points on the earth based on their latitude and longitude\n", "language_version_list": {"python": {"code_signature": "def haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the distance between two points on the earth based on their latitude and longitude\n    Args:\n        lat1 (float): Latitude of the first point in degrees.\n        lon1 (float): Longitude of the first point in degrees.\n        lat2 (float): Latitude of the second point in degrees.\n        lon2 (float): Longitude of the second point in degrees.\n\n    Returns:\n        Distance between the two points in kilometers.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestHaversineDistance(unittest.TestCase):\n\n    def test_same_point(self):\n        # Same point should return a distance of 0\n        lat, lon = 52.2296756, 21.0122287\n        result = haversine_distance(lat, lon, lat, lon)\n        self.assertAlmostEqual(result, 0.0, places=6)\n\n    def test_small_distance(self):\n        # Points that are very close together (few meters apart)\n        lat1, lon1 = 52.2296756, 21.0122287  # Warsaw, Poland\n        lat2, lon2 = 52.2296756, 21.0122297  # Very close to the previous point\n        result = haversine_distance(lat1, lon1, lat2, lon2)\n        self.assertAlmostEqual(result, 0.0001, places=4)  # Expected small distance\n\n    def test_large_distance(self):\n        # Points that are far apart\n        lat1, lon1 = 52.2296756, 21.0122287  # Warsaw, Poland\n        lat2, lon2 = 41.8919300, 12.5113300  # Rome, Italy\n        result = haversine_distance(lat1, lon1, lat2, lon2)\n        self.assertAlmostEqual(result, 1315.514, places=2)  # Approx distance in km\n\n    def test_equator_distance(self):\n        # Points on the equator\n        lat1, lon1 = 0.0, 0.0  # Gulf of Guinea (Equator and Prime Meridian intersection)\n        lat2, lon2 = 0.0, 90.0  # On the Equator, 90 degrees east\n        result = haversine_distance(lat1, lon1, lat2, lon2)\n        self.assertAlmostEqual(result, 10007.54, places=2)  # Approx quarter of Earth's circumference\n\n    def test_pole_to_pole(self):\n        # Distance from North Pole to South Pole\n        lat1, lon1 = 90.0, 0.0  # North Pole\n        lat2, lon2 = -90.0, 0.0  # South Pole\n        result = haversine_distance(lat1, lon1, lat2, lon2)\n        self.assertAlmostEqual(result, 20015.09, places=2)  # Approx half of Earth's circumference\n", "prompt": "please write a python function , the function signature as below def haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the distance between two points on the earth based on their latitude and longitude\n    Args:\n        lat1 (float): Latitude of the first point in degrees.\n        lon1 (float): Longitude of the first point in degrees.\n        lat2 (float): Latitude of the second point in degrees.\n        lon2 (float): Longitude of the second point in degrees.\n\n    Returns:\n        Distance between the two points in kilometers.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculate the distance between two points on the Earth based on their latitude and longitude.\n * \n * @param {number} lat1 - Latitude of the first point in degrees.\n * @param {number} lon1 - Longitude of the first point in degrees.\n * @param {number} lat2 - Latitude of the second point in degrees.\n * @param {number} lon2 - Longitude of the second point in degrees.\n * @returns {number} Distance between the two points in kilometers.\n */\nfunction haversineDistance(lat1, lon1, lat2, lon2) {}", "test_code": "describe('TestHaversineDistance', () => {\n    it('should return a distance of 0 for the same point', () => {\n        const lat = 52.2296756;\n        const lon = 21.0122287;\n        const result = haversineDistance(lat, lon, lat, lon);\n        expect(result).toBeCloseTo(0.0, 6);\n    });\n\n    it('should return a small distance for points very close together', () => {\n        const lat1 = 52.2296756;\n        const lon1 = 21.0122287;  // Warsaw, Poland\n        const lat2 = 52.2296756;\n        const lon2 = 21.0122297;  // Very close to the previous point\n        const result = haversineDistance(lat1, lon1, lat2, lon2);\n        expect(result).toBeCloseTo(0.0001, 4);\n    });\n\n    it('should return a large distance for points far apart', () => {\n        const lat1 = 52.2296756;\n        const lon1 = 21.0122287;  // Warsaw, Poland\n        const lat2 = 41.8919300;\n        const lon2 = 12.5113300;  // Rome, Italy\n        const result = haversineDistance(lat1, lon1, lat2, lon2);\n        expect(result).toBeCloseTo(1315.514, 2);\n    });\n\n    it('should return the correct distance for points on the equator', () => {\n        const lat1 = 0.0;\n        const lon1 = 0.0;  // Gulf of Guinea (Equator and Prime Meridian intersection)\n        const lat2 = 0.0;\n        const lon2 = 90.0;  // On the Equator, 90 degrees east\n        const result = haversineDistance(lat1, lon1, lat2, lon2);\n        expect(result).toBeCloseTo(10007.54, 2);\n    });\n\n    it('should return the correct distance from North Pole to South Pole', () => {\n        const lat1 = 90.0;\n        const lon1 = 0.0;  // North Pole\n        const lat2 = -90.0;\n        const lon2 = 0.0;  // South Pole\n        const result = haversineDistance(lat1, lon1, lat2, lon2);\n        expect(result).toBeCloseTo(20015.09, 2);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculate the distance between two points on the Earth based on their latitude and longitude.\n * \n * @param {number} lat1 - Latitude of the first point in degrees.\n * @param {number} lon1 - Longitude of the first point in degrees.\n * @param {number} lat2 - Latitude of the second point in degrees.\n * @param {number} lon2 - Longitude of the second point in degrees.\n * @returns {number} Distance between the two points in kilometers.\n */\nfunction haversineDistance(lat1, lon1, lat2, lon2) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculate the distance between two points on the Earth based on their latitude and longitude.\n * \n * @param lat1 - Latitude of the first point in degrees.\n * @param lon1 - Longitude of the first point in degrees.\n * @param lat2 - Latitude of the second point in degrees.\n * @param lon2 - Longitude of the second point in degrees.\n * @returns Distance between the two points in kilometers.\n */\nfunction haversineDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {}", "test_code": "describe('TestHaversineDistance', () => {\n    it('should return a distance of 0 for the same point', () => {\n        const lat = 52.2296756;\n        const lon = 21.0122287;\n        const result = haversineDistance(lat, lon, lat, lon);\n        expect(result).toBeCloseTo(0.0, 6);\n    });\n\n    it('should return a small distance for points very close together', () => {\n        const lat1 = 52.2296756;\n        const lon1 = 21.0122287;  // Warsaw, Poland\n        const lat2 = 52.2296756;\n        const lon2 = 21.0122297;  // Very close to the previous point\n        const result = haversineDistance(lat1, lon1, lat2, lon2);\n        expect(result).toBeCloseTo(0.0001, 4);\n    });\n\n    it('should return a large distance for points far apart', () => {\n        const lat1 = 52.2296756;\n        const lon1 = 21.0122287;  // Warsaw, Poland\n        const lat2 = 41.8919300;\n        const lon2 = 12.5113300;  // Rome, Italy\n        const result = haversineDistance(lat1, lon1, lat2, lon2);\n        expect(result).toBeCloseTo(1315.514, 2);\n    });\n\n    it('should return the correct distance for points on the equator', () => {\n        const lat1 = 0.0;\n        const lon1 = 0.0;  // Gulf of Guinea (Equator and Prime Meridian intersection)\n        const lat2 = 0.0;\n        const lon2 = 90.0;  // On the Equator, 90 degrees east\n        const result = haversineDistance(lat1, lon1, lat2, lon2);\n        expect(result).toBeCloseTo(10007.54, 2);\n    });\n\n    it('should return the correct distance from North Pole to South Pole', () => {\n        const lat1 = 90.0;\n        const lon1 = 0.0;  // North Pole\n        const lat2 = -90.0;\n        const lon2 = 0.0;  // South Pole\n        const result = haversineDistance(lat1, lon1, lat2, lon2);\n        expect(result).toBeCloseTo(20015.09, 2);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculate the distance between two points on the Earth based on their latitude and longitude.\n * \n * @param lat1 - Latitude of the first point in degrees.\n * @param lon1 - Longitude of the first point in degrees.\n * @param lat2 - Latitude of the second point in degrees.\n * @param lon2 - Longitude of the second point in degrees.\n * @returns Distance between the two points in kilometers.\n */\nfunction haversineDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the distance between two points on the Earth's surface using the Haversine formula.\n *\n * @param lat1 Latitude of the first point in degrees.\n * @param lon1 Longitude of the first point in degrees.\n * @param lat2 Latitude of the second point in degrees.\n * @param lon2 Longitude of the second point in degrees.\n *\n * @return Distance between the two points in kilometers. The result is a double precision floating-point\n *         number representing the shortest distance over the Earth's surface, accounting for its curvature.\n *\n * @note This implementation assumes the Earth is a perfect sphere, which may introduce slight errors in distance\n *       calculations, especially for long distances. For most practical purposes, the results are sufficiently accurate.\n */\ndouble haversine_distance(double lat1, double lon1, double lat2, double lon2) {}\n", "test_code": "TEST_CASE(\"Test Haversine Distance\", \"[haversine_distance]\") {\n    SECTION(\"Same point should return a distance of 0\") {\n        double lat = 52.2296756;\n        double lon = 21.0122287;\n        double result = haversine_distance(lat, lon, lat, lon);\n        REQUIRE(std::abs(result - 0.0) < 1e-6);\n    }\n\n    SECTION(\"Points that are very close together (few meters apart)\") {\n        double lat1 = 52.2296756;\n        double lon1 = 21.0122287;  // Warsaw, Poland\n        double lat2 = 52.2296756;\n        double lon2 = 21.0122297;  // Very close to the previous point\n        double result = haversine_distance(lat1, lon1, lat2, lon2);\n        REQUIRE(std::abs(result - 0.0001) < 1e-4);\n    }\n\n    SECTION(\"Points that are far apart\") {\n        double lat1 = 52.2296756;\n        double lon1 = 21.0122287;  // Warsaw, Poland\n        double lat2 = 41.8919300;\n        double lon2 = 12.5113300;  // Rome, Italy\n        double result = haversine_distance(lat1, lon1, lat2, lon2);\n        REQUIRE(std::abs(result - 1315.514) < 1e-2);\n    }\n\n    SECTION(\"Points on the equator\") {\n        double lat1 = 0.0;\n        double lon1 = 0.0;  // Gulf of Guinea (Equator and Prime Meridian intersection)\n        double lat2 = 0.0;\n        double lon2 = 90.0;  // On the Equator, 90 degrees east\n        double result = haversine_distance(lat1, lon1, lat2, lon2);\n        REQUIRE(std::abs(result - 10007.54) < 1e-2);\n    }\n\n    SECTION(\"Distance from North Pole to South Pole\") {\n        double lat1 = 90.0;\n        double lon1 = 0.0;  // North Pole\n        double lat2 = -90.0;\n        double lon2 = 0.0;  // South Pole\n        double result = haversine_distance(lat1, lon1, lat2, lon2);\n        REQUIRE(std::abs(result - 20015.09) < 1e-2);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the distance between two points on the Earth's surface using the Haversine formula.\n *\n * @param lat1 Latitude of the first point in degrees.\n * @param lon1 Longitude of the first point in degrees.\n * @param lat2 Latitude of the second point in degrees.\n * @param lon2 Longitude of the second point in degrees.\n *\n * @return Distance between the two points in kilometers. The result is a double precision floating-point\n *         number representing the shortest distance over the Earth's surface, accounting for its curvature.\n *\n * @note This implementation assumes the Earth is a perfect sphere, which may introduce slight errors in distance\n *       calculations, especially for long distances. For most practical purposes, the results are sufficiently accurate.\n */\ndouble haversine_distance(double lat1, double lon1, double lat2, double lon2) {}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the distance between two points on the Earth based on their latitude and longitude.\n *\n * @param lat1 Latitude of the first point in degrees.\n * @param lon1 Longitude of the first point in degrees.\n * @param lat2 Latitude of the second point in degrees.\n * @param lon2 Longitude of the second point in degrees.\n * @return Distance between the two points in kilometers.\n */\npublic static double haversineDistance(double lat1, double lon1, double lat2, double lon2) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals; \nimport org.junit.Test;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    private static final double DELTA = 1e-6; // Tolerance for floating-point comparisons\n\n    @Test\n    public void testSamePoint() {\n        double lat = 52.2296756;\n        double lon = 21.0122287;\n        double result = haversineDistance(lat, lon, lat, lon);\n        assertEquals(0.0, result, DELTA);\n    }\n\n    @Test\n    public void testSmallDistance() {\n        double lat1 = 52.2296756;\n        double lon1 = 21.0122287;  // Warsaw, Poland\n        double lat2 = 52.2296756;\n        double lon2 = 21.0122297;  // Very close to the previous point\n        double result = haversineDistance(lat1, lon1, lat2, lon2);\n        assertEquals(0.0001, result, 1e-4);  // Expected small distance\n    }\n\n    @Test\n    public void testLargeDistance() {\n        double lat1 = 52.2296756;\n        double lon1 = 21.0122287;  // Warsaw, Poland\n        double lat2 = 41.8919300;\n        double lon2 = 12.5113300;  // Rome, Italy\n        double result = haversineDistance(lat1, lon1, lat2, lon2);\n        assertEquals(1315.514, result, 1e-2);  // Approx distance in km\n    }\n\n    @Test\n    public void testEquatorDistance() {\n        double lat1 = 0.0;\n        double lon1 = 0.0;  // Gulf of Guinea (Equator and Prime Meridian intersection)\n        double lat2 = 0.0;\n        double lon2 = 90.0;  // On the Equator, 90 degrees east\n        double result = haversineDistance(lat1, lon1, lat2, lon2);\n        assertEquals(10007.54, result, 1e-2);  // Approx quarter of Earth's circumference\n    }\n\n    @Test\n    public void testPoleToPole() {\n        double lat1 = 90.0;\n        double lon1 = 0.0;  // North Pole\n        double lat2 = -90.0;\n        double lon2 = 0.0;  // South Pole\n        double result = haversineDistance(lat1, lon1, lat2, lon2);\n        assertEquals(20015.09, result, 1e-2);  // Approx half of Earth's circumference\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Calculates the distance between two points on the Earth based on their latitude and longitude.\n *\n * @param lat1 Latitude of the first point in degrees.\n * @param lon1 Longitude of the first point in degrees.\n * @param lat2 Latitude of the second point in degrees.\n * @param lon2 Longitude of the second point in degrees.\n * @return Distance between the two points in kilometers.\n */\npublic static double haversineDistance(double lat1, double lon1, double lat2, double lon2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 18, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Convert a floating point number between 0 and 1 to a color from red to green in the color format RGB", "language_version_list": {"python": {"code_signature": "def float_to_rgb(value: float) -> tuple:\n    \"\"\"\n    convert a floating point number between 0 and 1 to a color from red to green in the color format RGB\n    Args:\n        value (float): a float between 0 and 1.\n\n    Returns:\n        a tuple representing the RGB color.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFloatToRGB(unittest.TestCase):\n\n    def test_pure_red(self):\n        # Value at the lower boundary (0.0) should return pure red\n        result = float_to_rgb(0.0)\n        self.assertEqual(result, (255, 0, 0))\n\n    def test_pure_green(self):\n        # Value at the upper boundary (1.0) should return pure green\n        result = float_to_rgb(1.0)\n        self.assertEqual(result, (0, 255, 0))\n\n    def test_midpoint(self):\n        # Value at 0.5 should return an equal mix of red and green, resulting in yellow\n        result = float_to_rgb(0.5)\n        self.assertEqual(result, (127, 127, 0))\n\n    def test_quarter_point(self):\n        # Value at 0.25 should return more red than green\n        result = float_to_rgb(0.25)\n        self.assertEqual(result, (191, 63, 0))\n\n    def test_invalid_value(self):\n        # Value outside the range [0, 1] should raise a ValueError\n        with self.assertRaises(ValueError):\n            float_to_rgb(1.5)", "prompt": "please write a python function , the function signature as below def float_to_rgb(value: float) -> tuple:\n    \"\"\"\n    convert a floating point number between 0 and 1 to a color from red to green in the color format RGB\n    Args:\n        value (float): a float between 0 and 1.\n\n    Returns:\n        a tuple representing the RGB color.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a floating-point number between 0 and 1 to a color from red to green in the RGB format.\n * \n * @param {number} value - A float between 0 and 1.\n * @returns {Array} An array representing the RGB color.\n */\nfunction floatToRGB(value) {}", "test_code": "describe('TestFloatToRGB', () => {\n    it('should return pure red for value 0.0', () => {\n        const result = floatToRGB(0.0);\n        expect(result).toEqual([255, 0, 0]);\n    });\n\n    it('should return pure green for value 1.0', () => {\n        const result = floatToRGB(1.0);\n        expect(result).toEqual([0, 255, 0]);\n    });\n\n    it('should return yellow (equal mix of red and green) for value 0.5', () => {\n        const result = floatToRGB(0.5);\n        expect(result).toEqual([127, 127, 0]);\n    });\n\n    it('should return more red than green for value 0.25', () => {\n        const result = floatToRGB(0.25);\n        expect(result).toEqual([191, 63, 0]);\n    });\n\n    it('should throw an error for value outside the range [0, 1]', () => {\n        expect(() => floatToRGB(1.5)).toThrow('Value must be between 0 and 1 inclusive.');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a floating-point number between 0 and 1 to a color from red to green in the RGB format.\n * \n * @param {number} value - A float between 0 and 1.\n * @returns {Array} An array representing the RGB color.\n */\nfunction floatToRGB(value) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a floating-point number between 0 and 1 to a color from red to green in the RGB format.\n * \n * @param value - A float between 0 and 1.\n * @returns A tuple representing the RGB color.\n */\nfunction floatToRGB(value: number): [number, number, number] {}", "test_code": "describe('TestFloatToRGB', () => {\n    it('should return pure red for value 0.0', () => {\n        const result = floatToRGB(0.0);\n        expect(result).toEqual([255, 0, 0]);\n    });\n\n    it('should return pure green for value 1.0', () => {\n        const result = floatToRGB(1.0);\n        expect(result).toEqual([0, 255, 0]);\n    });\n\n    it('should return yellow (equal mix of red and green) for value 0.5', () => {\n        const result = floatToRGB(0.5);\n        expect(result).toEqual([127, 127, 0]);\n    });\n\n    it('should return more red than green for value 0.25', () => {\n        const result = floatToRGB(0.25);\n        expect(result).toEqual([191, 63, 0]);\n    });\n\n    it('should throw an error for value outside the range [0, 1]', () => {\n        expect(() => floatToRGB(1.5)).toThrow('Value must be between 0 and 1 inclusive.');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a floating-point number between 0 and 1 to a color from red to green in the RGB format.\n * \n * @param value - A float between 0 and 1.\n * @returns A tuple representing the RGB color.\n */\nfunction floatToRGB(value: number): [number, number, number] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert a floating-point number between 0 and 1 to a color from red to green in the RGB format.\n *\n * @param value A float between 0 and 1.\n * @return A tuple representing the RGB color.\n */\nstd::tuple<int, int, int> float_to_rgb(float value) {}", "test_code": "TEST_CASE(\"Test Float to RGB Conversion\") {\n    SECTION(\"Pure Red\") {\n        // Value at the lower boundary (0.0) should return pure red\n        auto result = float_to_rgb(0.0f);\n        REQUIRE(std::get<0>(result) == 255);\n        REQUIRE(std::get<1>(result) == 0);\n        REQUIRE(std::get<2>(result) == 0);\n    }\n\n    SECTION(\"Pure Green\") {\n        // Value at the upper boundary (1.0) should return pure green\n        auto result = float_to_rgb(1.0f);\n        REQUIRE(std::get<0>(result) == 0);\n        REQUIRE(std::get<1>(result) == 255);\n        REQUIRE(std::get<2>(result) == 0);\n    }\n\n    SECTION(\"Midpoint\") {\n        // Value at 0.5 should return an equal mix of red and green, resulting in yellow\n        auto result = float_to_rgb(0.5f);\n        REQUIRE(std::get<0>(result) == 127);\n        REQUIRE(std::get<1>(result) == 127);\n        REQUIRE(std::get<2>(result) == 0);\n    }\n\n    SECTION(\"Quarter Point\") {\n        // Value at 0.25 should return more red than green\n        auto result = float_to_rgb(0.25f);\n        REQUIRE(std::get<0>(result) == 191);\n        REQUIRE(std::get<1>(result) == 63);\n        REQUIRE(std::get<2>(result) == 0);\n    }\n\n    SECTION(\"Invalid Value\") {\n        // Value outside the range [0, 1] should throw an exception\n        REQUIRE_THROWS_AS(float_to_rgb(1.5f), std::invalid_argument);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert a floating-point number between 0 and 1 to a color from red to green in the RGB format.\n *\n * @param value A float between 0 and 1.\n * @return A tuple representing the RGB color.\n */\nstd::tuple<int, int, int> float_to_rgb(float value) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a floating-point number between 0 and 1 to a color from red to green in the RGB format.\n *\n * @param value a float between 0 and 1.\n * @return an array representing the RGB color.\n * @throws IllegalArgumentException if the value is not between 0 and 1 inclusive.\n */\npublic static int[] floatToRGB(float value) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    /**\n     * Tests that a value at the lower boundary (0.0) returns pure red.\n     */\n    @Test\n    public void testPureRed() {\n        int[] result = floatToRGB(0.0f);\n        assertArrayEquals(new int[]{255, 0, 0}, result);\n    }\n\n    /**\n     * Tests that a value at the upper boundary (1.0) returns pure green.\n     */\n    @Test\n    public void testPureGreen() {\n        int[] result = floatToRGB(1.0f);\n        assertArrayEquals(new int[]{0, 255, 0}, result);\n    }\n\n    /**\n     * Tests that a value at 0.5 returns an equal mix of red and green, resulting in yellow.\n     */\n    @Test\n    public void testMidpoint() {\n        int[] result = floatToRGB(0.5f);\n        assertArrayEquals(new int[]{127, 127, 0}, result);\n    }\n\n    /**\n     * Tests that a value at 0.25 returns more red than green.\n     */\n    @Test\n    public void testQuarterPoint() {\n        int[] result = floatToRGB(0.25f);\n        assertArrayEquals(new int[]{191, 63, 0}, result);\n    }\n\n    /**\n     * Tests that a value outside the range [0, 1] raises an IllegalArgumentException.\n     */\n    @Test(expected = IllegalArgumentException.class)\n    public void testInvalidValue() {\n        floatToRGB(1.5f);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a floating-point number between 0 and 1 to a color from red to green in the RGB format.\n *\n * @param value a float between 0 and 1.\n * @return an array representing the RGB color.\n * @throws IllegalArgumentException if the value is not between 0 and 1 inclusive.\n */\npublic static int[] floatToRGB(float value) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 19, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Determines whether the string contains a phone number; a possible format for a phone number is +1-800-555-1234, 555-555-1234, 555 555 1234", "language_version_list": {"python": {"code_signature": "def is_hava_phone_number(s: str) -> bool:\n    \"\"\"\n    determines whether the string contains a phone number; a possible format for a phone number is +1-800-555-1234, 555-555-1234, 555 555 1234\n    Args:\n        s (str): input str maybe contain phone number\n\n    Returns: weather this str contain phone number\n\n    \"\"\"\n", "test_code": "import re\nimport unittest\n\n\nclass TestPhoneNumberDetection(unittest.TestCase):\n    def test_with_international_prefix(self):\n        self.assertTrue(is_hava_phone_number(\"+1-800-555-1234\"), \"Should detect international prefix\")\n\n    def test_with_standard_dashes(self):\n        self.assertTrue(is_hava_phone_number(\"800-555-1234\"), \"Should detect standard format with dashes\")\n\n    def test_with_spaces(self):\n        self.assertTrue(is_hava_phone_number(\"800 555 1234\"), \"Should detect standard format with spaces\")\n\n    def test_without_phone_number(self):\n        self.assertFalse(is_hava_phone_number(\"Hello, world!\"), \"Should not detect any phone number\")\n\n    def test_with_text_containing_numbers(self):\n        self.assertTrue(is_hava_phone_number(\"Call me at 800-555-1234 today!\"), \"Should detect phone number in text\")", "prompt": "please write a python function , the function signature as below def is_hava_phone_number(s: str) -> bool:\n    \"\"\"\n    determines whether the string contains a phone number; a possible format for a phone number is +1-800-555-1234, 555-555-1234, 555 555 1234\n    Args:\n        s (str): input str maybe contain phone number\n\n    Returns: weather this str contain phone number\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Determines whether the string contains a phone number. Possible formats for a phone number include +1-800-555-1234, 555-555-1234, and 555 555 1234.\n * @param {string} s - The input string that may contain a phone number.\n * @returns {boolean} - Whether the string contains a phone number.\n */\nfunction containsPhoneNumber(s) {}", "test_code": "describe('TestPhoneNumberDetection', () => {\n    it('should detect international prefix', () => {\n        expect(containsPhoneNumber('+1-800-555-1234')).toBe(true);\n    });\n\n    it('should detect standard format with dashes', () => {\n        expect(containsPhoneNumber('800-555-1234')).toBe(true);\n    });\n\n    it('should detect standard format with spaces', () => {\n        expect(containsPhoneNumber('800 555 1234')).toBe(true);\n    });\n\n    it('should not detect any phone number', () => {\n        expect(containsPhoneNumber('Hello, world!')).toBe(false);\n    });\n\n    it('should detect phone number in text', () => {\n        expect(containsPhoneNumber('Call me at 800-555-1234 today!')).toBe(true);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Determines whether the string contains a phone number. Possible formats for a phone number include +1-800-555-1234, 555-555-1234, and 555 555 1234.\n * @param {string} s - The input string that may contain a phone number.\n * @returns {boolean} - Whether the string contains a phone number.\n */\nfunction containsPhoneNumber(s) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Determines whether the string contains a phone number.\n * Possible formats for a phone number include +1-800-555-1234, 555-555-1234, 555 555 1234.\n * \n * @param s - The input string that may contain a phone number.\n * @returns true if the string contains a phone number, false otherwise.\n */\nfunction containsPhoneNumber(s: string): boolean {}", "test_code": "describe('containsPhoneNumber', () => {\n    it('should detect international prefix', () => {\n        expect(containsPhoneNumber('+1-800-555-1234')).toBe(true);\n    });\n\n    it('should detect standard format with dashes', () => {\n        expect(containsPhoneNumber('800-555-1234')).toBe(true);\n    });\n\n    it('should detect standard format with spaces', () => {\n        expect(containsPhoneNumber('800 555 1234')).toBe(true);\n    });\n\n    it('should not detect any phone number', () => {\n        expect(containsPhoneNumber('Hello, world!')).toBe(false);\n    });\n\n    it('should detect phone number in text', () => {\n        expect(containsPhoneNumber('Call me at 800-555-1234 today!')).toBe(true);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Determines whether the string contains a phone number.\n * Possible formats for a phone number include +1-800-555-1234, 555-555-1234, 555 555 1234.\n * \n * @param s - The input string that may contain a phone number.\n * @returns true if the string contains a phone number, false otherwise.\n */\nfunction containsPhoneNumber(s: string): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Determines whether the string contains a phone number.\n * A possible format for a phone number is +1-800-555-1234, 555-555-1234, or 555 555 1234.\n *\n * @param s The input string which may contain a phone number.\n * @return True if the string contains a phone number, false otherwise.\n */\nbool contains_phone_number(const std::string& s){}", "test_code": "TEST_CASE(\"Test PhoneNumber Detection\", \"[PhoneNumberDetection]\") {\n    SECTION(\"with international prefix\") {\n        REQUIRE(contains_phone_number(\"+1-800-555-1234\"));\n    }\n\n    SECTION(\"with standard dashes\") {\n        REQUIRE(contains_phone_number(\"800-555-1234\"));\n    }\n\n    SECTION(\"with spaces\") {\n        REQUIRE(contains_phone_number(\"800 555 1234\"));\n    }\n\n    SECTION(\"without phone number\") {\n        REQUIRE_FALSE(contains_phone_number(\"Hello, world!\"));\n    }\n\n    SECTION(\"with text containing numbers\") {\n        REQUIRE(contains_phone_number(\"Call me at 800-555-1234 today!\"));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Determines whether the string contains a phone number.\n * A possible format for a phone number is +1-800-555-1234, 555-555-1234, or 555 555 1234.\n *\n * @param s The input string which may contain a phone number.\n * @return True if the string contains a phone number, false otherwise.\n */\nbool contains_phone_number(const std::string& s){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Determines whether the string contains a phone number.\n * A possible format for a phone number is +1-800-555-1234, 555-555-1234, 555 555 1234.\n *\n * @param s the input string that may contain a phone number\n * @return true if the string contains a phone number, false otherwise\n */\npublic static boolean containsPhoneNumber(String s) {}", "test_code": "package org.real.temp;\nimport org.junit.Test;  \nimport static org.junit.Assert.*; \nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testWithInternationalPrefix() {\n        assertTrue(\"Should detect international prefix\", containsPhoneNumber(\"+1-800-555-1234\"));\n    }\n\n    @Test\n    public void testWithStandardDashes() {\n        assertTrue(\"Should detect standard format with dashes\",containsPhoneNumber(\"800-555-1234\"));\n    }\n\n    @Test\n    public void testWithSpaces() {\n        assertTrue(\"Should detect standard format with spaces\",containsPhoneNumber(\"800 555 1234\"));\n    }\n\n    @Test\n    public void testWithoutPhoneNumber() {\n        assertFalse(\"Should not detect any phone number\",containsPhoneNumber(\"Hello, world!\"));\n    }\n\n    @Test\n    public void testWithTextContainingNumbers() {\n        assertTrue(\"Should detect phone number in text\", containsPhoneNumber(\"Call me at 800-555-1234 today!\"));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Determines whether the string contains a phone number.\n * A possible format for a phone number is +1-800-555-1234, 555-555-1234, 555 555 1234.\n *\n * @param s the input string that may contain a phone number\n * @return true if the string contains a phone number, false otherwise\n */\npublic static boolean containsPhoneNumber(String s) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 20, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Match the text with (*... *) The inner asterisks in the part of the format are removed and the outer parts (* and *) are left unchanged. For example,(*he*l*lo*) would be converted to (*hello*)\n", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef remove_inner_asterisks(text: str) -> str:\n    \"\"\"\n    Transforms the input text by finding and modifying patterns that match the format '(*...*)'.\n    Specifically, it removes any asterisks inside the parentheses while preserving the outer format.\n    For example:\n        input: *he*l*lo*\n        output: *hello*\n\n    Args:\n        text (str): The input text containing patterns to be transformed.\n\n    Returns:\n        str: The transformed text with asterisks inside '(*...*)' patterns removed.\n    \"\"\"\n", "test_code": "import unittest\nimport re\n\n\nclass TestTransformParentheses(unittest.TestCase):\n\n    def test_basic_case(self):\n        text = \"Hello (*wo*rld*)!\"\n        expected = \"Hello (*world*)!\"\n        self.assertEqual(remove_inner_asterisks(text), expected)\n\n    def test_multiple_asterisks(self):\n        text = \"(*he*l*lo*)\"\n        expected = \"(*hello*)\"\n        self.assertEqual(remove_inner_asterisks(text), expected)\n\n    def test_no_asterisks_inside(self):\n        text = \"(*hello*)\"\n        expected = \"(*hello*)\"\n        self.assertEqual(remove_inner_asterisks(text), expected)\n\n    def test_multiple_patterns(self):\n        text = \"(*hi*), (*there*), (*world*)!\"\n        expected = \"(*hi*), (*there*), (*world*)!\"\n        self.assertEqual(remove_inner_asterisks(text), expected)\n\n    def test_no_matching_pattern(self):\n        text = \"This is a test without matching parentheses.\"\n        expected = \"This is a test without matching parentheses.\"\n        self.assertEqual(remove_inner_asterisks(text), expected)\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef remove_inner_asterisks(text: str) -> str:\n    \"\"\"\n    Transforms the input text by finding and modifying patterns that match the format '(*...*)'.\n    Specifically, it removes any asterisks inside the parentheses while preserving the outer format.\n    For example:\n        input: *he*l*lo*\n        output: *hello*\n\n    Args:\n        text (str): The input text containing patterns to be transformed.\n\n    Returns:\n        str: The transformed text with asterisks inside '(*...*)' patterns removed.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Transforms the input text by finding and modifying patterns that match the format '(*...*)'.\n * Specifically, it removes any asterisks inside the parentheses while preserving the outer format.\n * For example:\n *     input: *he*l*lo*\n *     output: *hello*\n *\n * @param {string} text - The input text containing patterns to be transformed.\n * @returns {string} - The transformed text with asterisks inside '(*...*)' patterns removed.\n */\nfunction removeInnerAsterisks(text) {}", "test_code": "describe('remove_inner_asterisks', () => {\n    test('basic case', () => {\n        const text = \"Hello (*wo*rld*)!\";\n        const expected = \"Hello (*world*)!\";\n        expect(removeInnerAsterisks(text)).toBe(expected);\n    });\n\n    test('multiple asterisks', () => {\n        const text = \"(*he*l*lo*)\";\n        const expected = \"(*hello*)\";\n        expect(removeInnerAsterisks(text)).toBe(expected);\n    });\n\n    test('no asterisks inside', () => {\n        const text = \"(*hello*)\";\n        const expected = \"(*hello*)\";\n        expect(removeInnerAsterisks(text)).toBe(expected);\n    });\n\n    test('multiple patterns', () => {\n        const text = \"(*hi*), (*there*), (*world*)!\";\n        const expected = \"(*hi*), (*there*), (*world*)!\";\n        expect(removeInnerAsterisks(text)).toBe(expected);\n    });\n\n    test('no matching pattern', () => {\n        const text = \"This is a test without matching parentheses.\";\n        const expected = \"This is a test without matching parentheses.\";\n        expect(removeInnerAsterisks(text)).toBe(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Transforms the input text by finding and modifying patterns that match the format '(*...*)'.\n * Specifically, it removes any asterisks inside the parentheses while preserving the outer format.\n * For example:\n *     input: *he*l*lo*\n *     output: *hello*\n *\n * @param {string} text - The input text containing patterns to be transformed.\n * @returns {string} - The transformed text with asterisks inside '(*...*)' patterns removed.\n */\nfunction removeInnerAsterisks(text) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Transforms the input text by finding and modifying patterns that match the format '(*...*)'.\n * Specifically, it removes any asterisks inside the parentheses while preserving the outer format.\n * For example:\n *     input: *he*l*lo*\n *     output: *hello*\n *\n * @param {string} text - The input text containing patterns to be transformed.\n * @returns {string} - The transformed text with asterisks inside '(*...*)' patterns removed.\n */\nfunction removeInnerAsterisks(text: string): string {}", "test_code": "describe('removeInnerAsterisks', () => {\n    test('basic case', () => {\n        const text = \"Hello (*wo*rld*)!\";\n        const expected = \"Hello (*world*)!\";\n        expect(removeInnerAsterisks(text)).toBe(expected);\n    });\n\n    test('multiple asterisks', () => {\n        const text = \"(*he*l*lo*)\";\n        const expected = \"(*hello*)\";\n        expect(removeInnerAsterisks(text)).toBe(expected);\n    });\n\n    test('no asterisks inside', () => {\n        const text = \"(*hello*)\";\n        const expected = \"(*hello*)\";\n        expect(removeInnerAsterisks(text)).toBe(expected);\n    });\n\n    test('multiple patterns', () => {\n        const text = \"(*hi*), (*there*), (*world*)!\";\n        const expected = \"(*hi*), (*there*), (*world*)!\";\n        expect(removeInnerAsterisks(text)).toBe(expected);\n    });\n\n    test('no matching pattern', () => {\n        const text = \"This is a test without matching parentheses.\";\n        const expected = \"This is a test without matching parentheses.\";\n        expect(removeInnerAsterisks(text)).toBe(expected);\n    });\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Transforms the input text by finding and modifying patterns that match the format '(*...*)'.\n * Specifically, it removes any asterisks inside the parentheses while preserving the outer format.\n * For example:\n *     input: *he*l*lo*\n *     output: *hello*\n *\n * @param {string} text - The input text containing patterns to be transformed.\n * @returns {string} - The transformed text with asterisks inside '(*...*)' patterns removed.\n */\nfunction removeInnerAsterisks(text: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Processes a string containing Markdown-like asterisks.\n * \n * This function removes asterisks ('*') found between the first and last occurrence\n * if there are more than two asterisks in the string. If the number of asterisks\n * is two or fewer, the original string is returned unchanged.\n *\n * @param s The input string that may contain asterisks.\n * @return A string with the asterisks between the first and last occurrence removed,\n *         or the original string if there are two or fewer asterisks.\n */\n std::string process_markdown(const std::string& s) {}", "test_code": "TEST_CASE(\"Tests for process_markdown function\") {\n\n    SECTION(\"Test single asterisk pair\") {\n        std::string content = \"This is a *test.js* string.\";\n        std::string expected = \"This is a *test.js* string.\";\n        REQUIRE(process_markdown(content) == expected);\n    }\n\n    SECTION(\"Test nested asterisks\") {\n        std::string content = \"Example of **nested *asterisks***.\";\n        std::string expected = \"Example of *nested asterisks*.\";\n        REQUIRE(process_markdown(content) == expected);\n    }\n\n    SECTION(\"Test multiple asterisk pairs\") {\n        std::string content = \"*Multiple* pairs of *asterisks* in *one* sentence.\";\n        std::string expected = \"*Multiple pairs of asterisks in one* sentence.\";\n        REQUIRE(process_markdown(content) == expected);\n    }\n\n    SECTION(\"Test asterisks with no text\") {\n        std::string content = \"Asterisks with ** no text.\";\n        std::string expected = \"Asterisks with ** no text.\";\n        REQUIRE(process_markdown(content) == expected);\n    }\n\n    SECTION(\"Test asterisks around spaces\") {\n        std::string content = \"Asterisks around * *spaces* * are tricky.\";\n        std::string expected = \"Asterisks around * spaces * are tricky.\";\n        REQUIRE(process_markdown(content) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Processes a string containing Markdown-like asterisks.\n * \n * This function removes asterisks ('*') found between the first and last occurrence\n * if there are more than two asterisks in the string. If the number of asterisks\n * is two or fewer, the original string is returned unchanged.\n *\n * @param s The input string that may contain asterisks.\n * @return A string with the asterisks between the first and last occurrence removed,\n *         or the original string if there are two or fewer asterisks.\n */\n std::string process_markdown(const std::string& s) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Transforms the input text by finding and modifying patterns that match the format '(...)'.\n * Specifically, it removes any asterisks inside the parentheses while preserving the outer format.\n * \n * For example:\n * input: hello\n * output: hello\n *\n * @param text The input text containing patterns to be transformed.\n * @return The transformed text with asterisks inside '(*...*)' patterns removed.\n */\npublic static String removeInnerAsterisks(String text) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testBasicCase() {\n        String text = \"Hello (*wo*rld*)!\";\n        String expected = \"Hello (*world*)!\";\n        assertEquals(expected, removeInnerAsterisks(text));\n    }\n\n    @Test\n    public void testMultipleAsterisks() {\n        String text = \"(*he*l*lo*)\";\n        String expected = \"(*hello*)\";\n        assertEquals(expected, removeInnerAsterisks(text));\n    }\n\n    @Test\n    public void testNoAsterisksInside() {\n        String text = \"(*hello*)\";\n        String expected = \"(*hello*)\";\n        assertEquals(expected, removeInnerAsterisks(text));\n    }\n\n    @Test\n    public void testMultiplePatterns() {\n        String text = \"(*hi*), (*there*), (*world*)!\";\n        String expected = \"(*hi*), (*there*), (*world*)!\";\n        assertEquals(expected, removeInnerAsterisks(text));\n    }\n\n    @Test\n    public void testNoMatchingPattern() {\n        String text = \"This is a test without matching parentheses.\";\n        String expected = \"This is a test without matching parentheses.\";\n        assertEquals(expected, removeInnerAsterisks(text));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Transforms the input text by finding and modifying patterns that match the format '(...)'.\n * Specifically, it removes any asterisks inside the parentheses while preserving the outer format.\n * \n * For example:\n * input: hello\n * output: hello\n *\n * @param text The input text containing patterns to be transformed.\n * @return The transformed text with asterisks inside '(*...*)' patterns removed.\n */\npublic static String removeInnerAsterisks(String text) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 21, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": " compare the contents of two files and print the differences in unified diff format.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef diff_files(file1_path: str, file2_path: str) -> List[str]:\n    \"\"\"\n    Compare the contents of two files and print the differences in unified diff format.\n\n    Args:\n    file1_path (str): Path to the first file.\n    file2_path (str): Path to the second file.\n\n    Returns:\n    List[str]: A list containing the lines of differences, if any.\n\n    Raises:\n    FileNotFoundError: If either file does not exist.\n    IOError: If there is an error reading the files.\n    \"\"\"\n", "test_code": "import os\nimport unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestCompareFiles(unittest.TestCase):\n\n    def setUp(self):\n        # \u521b\u5efa\u6587\u4ef6\u7528\u4e8e\u6d4b\u8bd5\n        self.file1_path = 'file1.txt'\n        self.file2_path = 'file2.txt'\n\n    def tearDown(self):\n        # \u5220\u9664\u521b\u5efa\u7684\u6587\u4ef6\n        if os.path.exists(self.file1_path):\n            os.remove(self.file1_path)\n        if os.path.exists(self.file2_path):\n            os.remove(self.file2_path)\n\n    def test_identical_files(self):\n        # Mock question for two identical files\n        file1_content = \"Line1\\nLine2\\nLine3\\n\"\n        file2_content = \"Line1\\nLine2\\nLine3\\n\"\n\n        with open(self.file1_path, 'w') as f1, open(self.file2_path, 'w') as f2:\n            f1.write(file1_content)\n            f2.write(file2_content)\n\n        result = diff_files(self.file1_path, self.file2_path)\n        self.assertEqual(len(result), 0, \"There should be no differences detected\")\n\n    def test_files_with_differences(self):\n        # Mock question for two different files\n        file1_content = \"Line1\\nLine2\\nLine3\\n\"\n        file2_content = \"Line1\\nLineChanged\\nLine3\\n\"\n\n        with open(self.file1_path, 'w') as f1, open(self.file2_path, 'w') as f2:\n            f1.write(file1_content)\n            f2.write(file2_content)\n\n        result = diff_files(self.file1_path, self.file2_path)\n        self.assertNotEqual(len(result), 0, \"There should be differences detected\")\n\n    def test_nonexistent_file(self):\n        # Test when one of the files does not exist\n        with patch('builtins.open', side_effect=FileNotFoundError(\"File not found\")):\n            with self.assertRaises(FileNotFoundError):\n                diff_files('nonexistent.txt', 'file2.txt')\n\n    def test_file_reading_error(self):\n        # Test when there's an error reading the file\n        with patch('builtins.open', side_effect=IOError(\"Error reading file\")):\n            with self.assertRaises(IOError):\n                diff_files('file1.txt', 'file2.txt')\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef diff_files(file1_path: str, file2_path: str) -> List[str]:\n    \"\"\"\n    Compare the contents of two files and print the differences in unified diff format.\n\n    Args:\n    file1_path (str): Path to the first file.\n    file2_path (str): Path to the second file.\n\n    Returns:\n    List[str]: A list containing the lines of differences, if any.\n\n    Raises:\n    FileNotFoundError: If either file does not exist.\n    IOError: If there is an error reading the files.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Compare the contents of two files and print the differences in unified diff format.\n *\n * @param {string} file1Path - Path to the first file.\n * @param {string} file2Path - Path to the second file.\n * @returns {Promise<Array<string>>} A promise that resolves to a list containing the lines of differences, if any.\n * @throws {Error} If either file does not exist.\n * @throws {Error} If there is an error reading the files.\n */\nasync function compareFiles(file1Path, file2Path) {}", "test_code": "describe('TestCompareFiles', () => {\n  let file1Path;\n  let file2Path;\n\n  beforeEach(() => {\n      // Create files for testing\n      file1Path = 'file1.txt';\n      file2Path = 'file2.txt';\n  });\n\n  afterEach(() => {\n      // Remove created files\n      if (fs.existsSync(file1Path)) {\n          fs.unlinkSync(file1Path);\n      }\n      if (fs.existsSync(file2Path)) {\n          fs.unlinkSync(file2Path);\n      }\n  });\n\n  it('should detect no differences in identical files', () => {\n      const file1Content = \"Line1\\nLine2\\nLine3\\n\";\n      const file2Content = \"Line1\\nLine2\\nLine3\\n\";\n\n      fs.writeFileSync(file1Path, file1Content);\n      fs.writeFileSync(file2Path, file2Content);\n\n      const result = compareFiles(file1Path, file2Path);\n      expect(result.length).toBe(0, \"There should be no differences detected\");\n  });\n\n  it('should detect differences in different files', () => {\n      const file1Content = \"Line1\\nLine2\\nLine3\\n\";\n      const file2Content = \"Line1\\nLineChanged\\nLine3\\n\";\n\n      fs.writeFileSync(file1Path, file1Content);\n      fs.writeFileSync(file2Path, file2Content);\n\n      const result = compareFiles(file1Path, file2Path);\n      expect(result.length).not.toBe(0, \"There should be differences detected\");\n  });\n\n  it('should throw an error when one of the files does not exist', () => {\n      const mockOpen = jest.fn().mockImplementation(() => {\n          throw new Error('File not found');\n      });\n\n      global.open = mockOpen;\n\n      expect(() => compareFiles('nonexistent.txt', 'file2.txt')).toThrow('One of the files was not found.');\n\n      delete global.open;\n  });\n\n  it('should throw an error when there is an error reading the file', () => {\n      const mockOpen = jest.fn().mockImplementation(() => {\n          throw new Error('Error reading file');\n      });\n\n      global.open = mockOpen;\n\n      expect(() => compareFiles('file1.txt', 'file2.txt')).toThrow('Error reading files: Error reading file');\n\n      delete global.open;\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Compare the contents of two files and print the differences in unified diff format.\n *\n * @param {string} file1Path - Path to the first file.\n * @param {string} file2Path - Path to the second file.\n * @returns {Promise<Array<string>>} A promise that resolves to a list containing the lines of differences, if any.\n * @throws {Error} If either file does not exist.\n * @throws {Error} If there is an error reading the files.\n */\nasync function compareFiles(file1Path, file2Path) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * compare the contents of two files and print the differences in unified diff format.\n *\n * @param file1Path - Path to the first file.\n * @param file2Path - Path to the second file.\n * @returns An array containing the lines of differences, if any.\n * @throws {Error} If either file does not exist or there is an error reading the files.\n */\nfunction compareFiles(file1Path: string, file2Path: string): string[] {}", "test_code": "describe('TestCompareFiles', () => {\n  let file1Path: string;\n  let file2Path: string;\n\n  beforeEach(() => {\n    // Create files for testing\n    file1Path = 'file1.txt';\n    file2Path = 'file2.txt';\n  });\n\n  afterEach(() => {\n    // Delete created files\n    if (fs.existsSync(file1Path)) {\n      fs.unlinkSync(file1Path);\n    }\n    if (fs.existsSync(file2Path)) {\n      fs.unlinkSync(file2Path);\n    }\n  });\n\n  it('should handle identical files correctly', () => {\n    const file1Content = \"Line1\\nLine2\\nLine3\\n\";\n    const file2Content = \"Line1\\nLine2\\nLine3\\n\";\n\n    fs.writeFileSync(file1Path, file1Content);\n    fs.writeFileSync(file2Path, file2Content);\n\n    const result = compareFiles(file1Path, file2Path);\n    expect(result.length).toBe(0);\n  });\n\n  it('should detect differences between files', () => {\n    const file1Content = \"Line1\\nLine2\\nLine3\\n\";\n    const file2Content = \"Line1\\nLineChanged\\nLine3\\n\";\n\n    fs.writeFileSync(file1Path, file1Content);\n    fs.writeFileSync(file2Path, file2Content);\n\n    const result = compareFiles(file1Path, file2Path);\n    expect(result.length).not.toBe(0);\n  });\n\n  it('should throw an error when one of the files does not exist', () => {\n    jest.spyOn(fs, 'readFileSync').mockImplementation(() => {\n      throw new Error('File not found');\n    });\n\n    expect(() => compareFiles('nonexistent.txt', file2Path)).toThrow('File not found');\n  });\n\n  it('should throw an error when there is an error reading the file', () => {\n    jest.spyOn(fs, 'readFileSync').mockImplementation(() => {\n      throw new Error('Error reading file');\n    });\n\n    expect(() => compareFiles(file1Path, file2Path)).toThrow('Error reading file');\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * compare the contents of two files and print the differences in unified diff format.\n *\n * @param file1Path - Path to the first file.\n * @param file2Path - Path to the second file.\n * @returns An array containing the lines of differences, if any.\n * @throws {Error} If either file does not exist or there is an error reading the files.\n */\nfunction compareFiles(file1Path: string, file2Path: string): string[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief compare the contents of two files and print the differences in unified diff format.\n *\n * @param file1_path Path to the first file.\n * @param file2_path Path to the second file.\n *\n * @return A vector containing the lines of differences, if any.\n *\n * @throws std::runtime_error If either file does not exist or there is an error reading the files.\n */\nstd::vector<std::string> compare_files(const std::string& file1_path, const std::string& file2_path) {}", "test_code": "TEST_CASE(\"Test Compare Files\") {\n    // Create temporary files for testing\n    const std::string file1_path = \"file1.txt\";\n    const std::string file2_path = \"file2.txt\";\n\n    SECTION(\"Identical Files\") {\n        std::string file1_content = \"Line1\\nLine2\\nLine3\\n\";\n        std::string file2_content = \"Line1\\nLine2\\nLine3\\n\";\n\n        std::ofstream f1(file1_path);\n        std::ofstream f2(file2_path);\n        f1 << file1_content;\n        f2 << file2_content;\n\n        REQUIRE(compare_files(file1_path, file2_path).empty());\n    }\n\n    SECTION(\"Files with Differences\") {\n        std::string file1_content = \"Line1\\nLine2\\nLine3\\n\";\n        std::string file2_content = \"Line1\\nLineChanged\\nLine3\\n\";\n\n        std::ofstream f1(file1_path);\n        std::ofstream f2(file2_path);\n        f1 << file1_content;\n        f2 << file2_content;\n\n        auto result = compare_files(file1_path, file2_path);\n        REQUIRE(!result.empty());\n    }\n\n    SECTION(\"Nonexistent File\") {\n        REQUIRE_THROWS_AS(compare_files(\"nonexistent.txt\", file2_path), std::runtime_error);\n    }\n\n    SECTION(\"File Reading Error\") {\n        // Simulate file reading error by creating a file that cannot be read\n        std::ofstream f1(file1_path);\n        f1 << \"Line1\\nLine2\\nLine3\\n\";\n\n        // Change file permissions to make it unreadable\n        fs::permissions(file1_path, fs::perms::none);\n\n        REQUIRE_THROWS_AS(compare_files(file1_path, file2_path), std::runtime_error);\n\n        // Restore file permissions\n        fs::permissions(file1_path, fs::perms::owner_read | fs::perms::owner_write);\n    }\n\n    // Clean up temporary files\n    if (fs::exists(file1_path)) {\n        fs::remove(file1_path);\n    }\n    if (fs::exists(file2_path)) {\n        fs::remove(file2_path);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief compare the contents of two files and print the differences in unified diff format.\n *\n * @param file1_path Path to the first file.\n * @param file2_path Path to the second file.\n *\n * @return A vector containing the lines of differences, if any.\n *\n * @throws std::runtime_error If either file does not exist or there is an error reading the files.\n */\nstd::vector<std::string> compare_files(const std::string& file1_path, const std::string& file2_path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Compare the contents of two files and print the differences in unified diff format.\n *\n * @param file1Path Path to the first file.\n * @param file2Path Path to the second file.\n * @return A list containing the lines of differences, if any.\n * @throws java.io.FileNotFoundException If either file does not exist.\n * @throws java.io.IOException If there is an error reading the files.\n */\npublic static List<String> compareFiles(String file1Path, String file2Path) throws java.io.FileNotFoundException, IOException {}", "test_code": "package org.real.temp;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.util.List;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Mock;\nimport org.mockito.Mockito;\nimport org.mockito.MockitoAnnotations;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\npublic class Tester {\n\n    private static final String FILE1_CONTENT = \"Line1\\nLine2\\nLine3\\n\";\n    private static final String FILE2_CONTENT = \"Line1\\nLineChanged\\nLine3\\n\";\n\n    private Path file1Path;\n    private Path file2Path;\n\n    @BeforeEach\n    public void setUp(@TempDir Path tempDir) {\n        file1Path = tempDir.resolve(\"file1.txt\");\n        file2Path = tempDir.resolve(\"file2.txt\");\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (file1Path.toFile().exists()) {\n            file1Path.toFile().delete();\n        }\n        if (file2Path.toFile().exists()) {\n            file2Path.toFile().delete();\n        }\n    }\n\n    @Test\n    public void testIdenticalFiles() throws IOException {\n        writeToFile(file1Path, FILE1_CONTENT);\n        writeToFile(file2Path, FILE1_CONTENT);\n\n        List<String> result = compareFiles(file1Path.toString(), file2Path.toString());\n        assertEquals(0, result.size(), \"There should be no differences detected\");\n    }\n\n    @Test\n    public void testFilesWithDifferences() throws IOException {\n        writeToFile(file1Path, FILE1_CONTENT);\n        writeToFile(file2Path, FILE2_CONTENT);\n\n        List<String> result = compareFiles(file1Path.toString(), file2Path.toString());\n        assertNotEquals(0, result.size(), \"There should be differences detected\");\n    }\n\n    @Test\n    public void testNonexistentFile() {\n        try (MockedStatic<Answer> mockedStatic = Mockito.mockStatic(Answer.class)) {\n            mockedStatic.when(() -> Answer.readFile(\"nonexistent.txt\"))\n                    .thenThrow(new java.io.FileNotFoundException(\"File not found\"));\n\n            Exception exception = assertThrows(java.io.FileNotFoundException.class,\n                    () -> compareFiles(\"nonexistent.txt\", file2Path.toString()));\n            assertEquals(\"File not found\", exception.getMessage());\n        }\n    }\n\n    @Test\n    public void testFileReadingError() {\n        try (MockedStatic<Answer> mockedStatic = Mockito.mockStatic(Answer.class)) {\n            mockedStatic.when(() -> Answer.readFile(file1Path.toString()))\n                    .thenThrow(new java.io.IOException(\"Error reading file\"));\n\n            Exception exception = assertThrows(java.io.IOException.class,\n                    () -> compareFiles(file1Path.toString(), file2Path.toString()));\n            assertEquals(\"Error reading file\", exception.getMessage());\n        }\n    }\n\n    private void writeToFile(Path filePath, String content) throws IOException {\n        try (FileWriter writer = new FileWriter(filePath.toFile())) {\n            writer.write(content);\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Compare the contents of two files and print the differences in unified diff format.\n *\n * @param file1Path Path to the first file.\n * @param file2Path Path to the second file.\n * @return A list containing the lines of differences, if any.\n * @throws java.io.FileNotFoundException If either file does not exist.\n * @throws java.io.IOException If there is an error reading the files.\n */\npublic static List<String> compareFiles(String file1Path, String file2Path) throws java.io.FileNotFoundException, IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 23, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "calculate the intersection point of two line segments.", "language_version_list": {"python": {"code_signature": "from typing import Union\n\n\ndef check_segments_intersection(seg1: tuple, seg2: tuple) -> Union[tuple, None]:\n    \"\"\"\n    Calculate the intersection point of two line segments, if it exists.\n\n    Args:\n        seg1 (tuple): Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n        seg2 (tuple): Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n\n    Returns:\n        Union[tuple, None]: The (x, y) coordinates of the intersection point if the line segments intersect,\n                            otherwise None.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestLineSegmentIntersection(unittest.TestCase):\n\n    def test_intersection(self):\n        seg1 = ((1, 1), (4, 4))\n        seg2 = ((1, 4), (4, 1))\n        expected = (2.5, 2.5)\n        result = check_segments_intersection(seg1, seg2)\n        self.assertEqual(result, expected, \"The intersection should be at (2.5, 2.5)\")\n\n    def test_no_intersection(self):\n        seg1 = ((1, 1), (2, 2))\n        seg2 = ((3, 3), (4, 4))\n        result = check_segments_intersection(seg1, seg2)\n        self.assertIsNone(result, \"There should be no intersection\")\n\n    def test_parallel_segments(self):\n        seg1 = ((1, 1), (2, 2))\n        seg2 = ((1, 2), (2, 3))\n        result = check_segments_intersection(seg1, seg2)\n        self.assertIsNone(result, \"Parallel segments should not intersect\")\n\n    def test_no_intersection_due_to_offset(self):\n        seg1 = ((1, 1), (3, 3))\n        seg2 = ((3, 2), (4, 2))\n        result = check_segments_intersection(seg1, seg2)\n        self.assertIsNone(result, \"There should be no intersection due to offset between segments\")\n\n    def test_intersection_with_large_coordinates(self):\n        seg1 = ((1000, 1000), (2000, 2000))\n        seg2 = ((1000, 2000), (2000, 1000))\n        expected = (1500.0, 1500.0)\n        result = check_segments_intersection(seg1, seg2)\n        self.assertEqual(result, expected, \"The intersection should be at (1500.0, 1500.0)\")\n\n\n", "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef check_segments_intersection(seg1: tuple, seg2: tuple) -> Union[tuple, None]:\n    \"\"\"\n    Calculate the intersection point of two line segments, if it exists.\n\n    Args:\n        seg1 (tuple): Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n        seg2 (tuple): Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n\n    Returns:\n        Union[tuple, None]: The (x, y) coordinates of the intersection point if the line segments intersect,\n                            otherwise None.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * calculates the intersection point of two line segments, if it exists.\n *\n * @param {Array} seg1 - Coordinates of the first line segment, defined as [[x1, y1], [x2, y2]].\n * @param {Array} seg2 - Coordinates of the second line segment, defined as [[x3, y3], [x4, y4]].\n * @returns {Array|null} - The [x, y] coordinates of the intersection point if the line segments intersect,\n *                         otherwise null.\n */\nfunction getLineSegmentIntersection(seg1, seg2) {}", "test_code": "describe('TestLineSegmentIntersection', () => {\n    it('should find the intersection at (2.5, 2.5)', () => {\n        const seg1 = [[1, 1], [4, 4]];\n        const seg2 = [[1, 4], [4, 1]];\n        const expected = [2.5, 2.5];\n        const result = getLineSegmentIntersection(seg1, seg2);\n        expect(result).toEqual(expected);\n    });\n\n    it('should return null when there is no intersection', () => {\n        const seg1 = [[1, 1], [2, 2]];\n        const seg2 = [[3, 3], [4, 4]];\n        const result = getLineSegmentIntersection(seg1, seg2);\n        expect(result).toBeNull();\n    });\n\n    it('should return null for parallel segments', () => {\n        const seg1 = [[1, 1], [2, 2]];\n        const seg2 = [[1, 2], [2, 3]];\n        const result = getLineSegmentIntersection(seg1, seg2);\n        expect(result).toBeNull();\n    });\n\n    it('should return null when there is no intersection due to offset', () => {\n        const seg1 = [[1, 1], [3, 3]];\n        const seg2 = [[3, 2], [4, 2]];\n        const result = getLineSegmentIntersection(seg1, seg2);\n        expect(result).toBeNull();\n    });\n\n    it('should find the intersection at (1500.0, 1500.0) with large coordinates', () => {\n        const seg1 = [[1000, 1000], [2000, 2000]];\n        const seg2 = [[1000, 2000], [2000, 1000]];\n        const expected = [1500.0, 1500.0];\n        const result = getLineSegmentIntersection(seg1, seg2);\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * calculates the intersection point of two line segments, if it exists.\n *\n * @param {Array} seg1 - Coordinates of the first line segment, defined as [[x1, y1], [x2, y2]].\n * @param {Array} seg2 - Coordinates of the second line segment, defined as [[x3, y3], [x4, y4]].\n * @returns {Array|null} - The [x, y] coordinates of the intersection point if the line segments intersect,\n *                         otherwise null.\n */\nfunction getLineSegmentIntersection(seg1, seg2) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the intersection point of two line segments, if it exists.\n * \n * @param seg1 - Coordinates of the first line segment, defined as [[x1, y1], [x2, y2]].\n * @param seg2 - Coordinates of the second line segment, defined as [[x3, y3], [x4, y4]].\n * @returns The [x, y] coordinates of the intersection point if the line segments intersect,\n *          otherwise null.\n */\nfunction getLineSegmentIntersection(seg1: [number, number][], seg2: [number, number][]): [number, number] | null {}", "test_code": "describe('TestLineSegmentIntersection', () => {\n  it('should find the intersection correctly', () => {\n      const seg1: [number, number][] = [[1, 1], [4, 4]];\n      const seg2: [number, number][] = [[1, 4], [4, 1]];\n      const expected: [number, number] = [2.5, 2.5];\n      const result = getLineSegmentIntersection(seg1, seg2);\n      expect(result).toEqual(expected);\n  });\n\n  it('should return null when there is no intersection', () => {\n      const seg1: [number, number][] = [[1, 1], [2, 2]];\n      const seg2: [number, number][] = [[3, 3], [4, 4]];\n      const result = getLineSegmentIntersection(seg1, seg2);\n      expect(result).toBeNull();\n  });\n\n  it('should return null for parallel segments', () => {\n      const seg1: [number, number][] = [[1, 1], [2, 2]];\n      const seg2: [number, number][] = [[1, 2], [2, 3]];\n      const result = getLineSegmentIntersection(seg1, seg2);\n      expect(result).toBeNull();\n  });\n\n  it('should return null when there is no intersection due to offset', () => {\n      const seg1: [number, number][] = [[1, 1], [3, 3]];\n      const seg2: [number, number][] = [[3, 2], [4, 2]];\n      const result = getLineSegmentIntersection(seg1, seg2);\n      expect(result).toBeNull();\n  });\n\n  it('should find the intersection with large coordinates correctly', () => {\n      const seg1: [number, number][] = [[1000, 1000], [2000, 2000]];\n      const seg2: [number, number][] = [[1000, 2000], [2000, 1000]];\n      const expected: [number, number] = [1500.0, 1500.0];\n      const result = getLineSegmentIntersection(seg1, seg2);\n      expect(result).toEqual(expected);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the intersection point of two line segments, if it exists.\n * \n * @param seg1 - Coordinates of the first line segment, defined as [[x1, y1], [x2, y2]].\n * @param seg2 - Coordinates of the second line segment, defined as [[x3, y3], [x4, y4]].\n * @returns The [x, y] coordinates of the intersection point if the line segments intersect,\n *          otherwise null.\n */\nfunction getLineSegmentIntersection(seg1: [number, number][], seg2: [number, number][]): [number, number] | null {}", "addition_info": ""}, "c&cpp": {"code_signature": "union IntersectionResult {\n    std::pair<double, double> point;\n    bool isNone;\n\n    IntersectionResult() : isNone(true) {}\n    IntersectionResult(double x, double y) : point(x, y), isNone(false) {}\n\n    // Destructor\n    ~IntersectionResult() {}\n\n    // Equality operator for checking if the result is None\n    bool operator==(const std::pair<double, double>& p) const {\n        return !isNone && point == p;\n    }\n\n    // Equality operator for checking if the result is None\n    bool operator==(bool none) const {\n        return isNone == none;\n    }\n};\n\n/**\n * @brief Calculate the intersection point of two line segments, if it exists.\n *\n * @param seg1 Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n * @param seg2 Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n * @return The (x, y) coordinates of the intersection point if the line segments intersect,\n *         otherwise an empty IntersectionResult indicating no intersection.\n */\nIntersectionResult get_line_segment_intersection(const std::pair<std::pair<double, double>, std::pair<double, double>>& seg1,\n                                              const std::pair<std::pair<double, double>, std::pair<double, double>>& seg2) {}", "test_code": "TEST_CASE(\"Test Line Segment Intersection\") {\n    SECTION(\"Intersection\") {\n        auto seg1 = std::make_pair(std::make_pair(1.0, 1.0), std::make_pair(4.0, 4.0));\n        auto seg2 = std::make_pair(std::make_pair(1.0, 4.0), std::make_pair(4.0, 1.0));\n        auto expected = std::make_pair(2.5, 2.5);\n        auto result = get_line_segment_intersection(seg1, seg2);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"No Intersection\") {\n        auto seg1 = std::make_pair(std::make_pair(1.0, 1.0), std::make_pair(2.0, 2.0));\n        auto seg2 = std::make_pair(std::make_pair(3.0, 3.0), std::make_pair(4.0, 4.0));\n        auto result = get_line_segment_intersection(seg1, seg2);\n        REQUIRE(result == true); // True indicates no intersection\n    }\n\n    SECTION(\"Parallel Segments\") {\n        auto seg1 = std::make_pair(std::make_pair(1.0, 1.0), std::make_pair(2.0, 2.0));\n        auto seg2 = std::make_pair(std::make_pair(1.0, 2.0), std::make_pair(2.0, 3.0));\n        auto result = get_line_segment_intersection(seg1, seg2);\n        REQUIRE(result == true); // True indicates no intersection\n    }\n\n    SECTION(\"No Intersection Due to Offset\") {\n        auto seg1 = std::make_pair(std::make_pair(1.0, 1.0), std::make_pair(3.0, 3.0));\n        auto seg2 = std::make_pair(std::make_pair(3.0, 2.0), std::make_pair(4.0, 2.0));\n        auto result = get_line_segment_intersection(seg1, seg2);\n        REQUIRE(result == true); // True indicates no intersection\n    }\n\n    SECTION(\"Intersection with Large Coordinates\") {\n        auto seg1 = std::make_pair(std::make_pair(1000.0, 1000.0), std::make_pair(2000.0, 2000.0));\n        auto seg2 = std::make_pair(std::make_pair(1000.0, 2000.0), std::make_pair(2000.0, 1000.0));\n        auto expected = std::make_pair(1500.0, 1500.0);\n        auto result = get_line_segment_intersection(seg1, seg2);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below union IntersectionResult {\n    std::pair<double, double> point;\n    bool isNone;\n\n    IntersectionResult() : isNone(true) {}\n    IntersectionResult(double x, double y) : point(x, y), isNone(false) {}\n\n    // Destructor\n    ~IntersectionResult() {}\n\n    // Equality operator for checking if the result is None\n    bool operator==(const std::pair<double, double>& p) const {\n        return !isNone && point == p;\n    }\n\n    // Equality operator for checking if the result is None\n    bool operator==(bool none) const {\n        return isNone == none;\n    }\n};\n\n/**\n * @brief Calculate the intersection point of two line segments, if it exists.\n *\n * @param seg1 Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n * @param seg2 Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n * @return The (x, y) coordinates of the intersection point if the line segments intersect,\n *         otherwise an empty IntersectionResult indicating no intersection.\n */\nIntersectionResult get_line_segment_intersection(const std::pair<std::pair<double, double>, std::pair<double, double>>& seg1,\n                                              const std::pair<std::pair<double, double>, std::pair<double, double>>& seg2) {}", "addition_info": "union IntersectionResult {\n    std::pair<double, double> point;\n    bool isNone;\n\n    IntersectionResult() : isNone(true) {}\n    IntersectionResult(double x, double y) : point(x, y), isNone(false) {}\n\n    // Destructor\n    ~IntersectionResult() {}\n\n    // Equality operator for checking if the result is None\n    bool operator==(const std::pair<double, double>& p) const {\n        return !isNone && point == p;\n    }\n\n    // Equality operator for checking if the result is None\n    bool operator==(bool none) const {\n        return isNone == none;\n    }\n};"}, "java": {"code_signature": "/**\n * Calculates the intersection point of two line segments, if it exists.\n *\n * @param seg1 Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n * @param seg2 Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n * @return A Point representing the (x, y) coordinates of the intersection point if the line segments intersect,\n *         otherwise null.\n */\nstatic class Point {\n    double x, y;\n\n    Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + x + \", \" + y + \")\";\n    }\n}\npublic static Point getLineSegmentIntersection(Point seg1Start, Point seg1End, Point seg2Start, Point seg2End) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testIntersection() {\n        Point seg1Start = new Point(1, 1);\n        Point seg1End = new Point(4, 4);\n        Point seg2Start = new Point(1, 4);\n        Point seg2End = new Point(4, 1);\n        Point expected = new Point(2.5, 2.5);\n\n        Point result = getLineSegmentIntersection(seg1Start, seg1End, seg2Start, seg2End);\n        assertTrue(\"The intersection should be at (2.5, 2.5)\",(expected.x == result.x)&&(expected.y == result.y));\n    }\n\n    @Test\n    public void testNoIntersection() {\n        Point seg1Start = new Point(1, 1);\n        Point seg1End = new Point(2, 2);\n        Point seg2Start = new Point(3, 3);\n        Point seg2End = new Point(4, 4);\n\n        Point result = getLineSegmentIntersection(seg1Start, seg1End, seg2Start, seg2End);\n        assertNull(\"There should be no intersection\", result);\n    }\n\n    @Test\n    public void testParallelSegments() {\n        Point seg1Start = new Point(1, 1);\n        Point seg1End = new Point(2, 2);\n        Point seg2Start = new Point(1, 2);\n        Point seg2End = new Point(2, 3);\n\n        Point result = getLineSegmentIntersection(seg1Start, seg1End, seg2Start, seg2End);\n        assertNull(\"Parallel segments should not intersect\", result);\n    }\n\n    @Test\n    public void testNoIntersectionDueToOffset() {\n        Point seg1Start = new Point(1, 1);\n        Point seg1End = new Point(3, 3);\n        Point seg2Start = new Point(3, 2);\n        Point seg2End = new Point(4, 2);\n\n        Point result = getLineSegmentIntersection(seg1Start, seg1End, seg2Start, seg2End);\n        assertNull(\"There should be no intersection due to offset between segments\", result);\n    }\n\n    @Test\n    public void testIntersectionWithLargeCoordinates() {\n        Point seg1Start = new Point(1000, 1000);\n        Point seg1End = new Point(2000, 2000);\n        Point seg2Start = new Point(1000, 2000);\n        Point seg2End = new Point(2000, 1000);\n        Point expected = new Point(1500.0, 1500.0);\n\n        Point result = getLineSegmentIntersection(seg1Start, seg1End, seg2Start, seg2End);\n        assertTrue(\"The intersection should be at (1500.0, 1500.0)\", (expected.x == result.x)&&(expected.y == result.y));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the intersection point of two line segments, if it exists.\n *\n * @param seg1 Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n * @param seg2 Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n * @return A Point representing the (x, y) coordinates of the intersection point if the line segments intersect,\n *         otherwise null.\n */\nstatic class Point {\n    double x, y;\n\n    Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + x + \", \" + y + \")\";\n    }\n}\npublic static Point getLineSegmentIntersection(Point seg1Start, Point seg1End, Point seg2Start, Point seg2End) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 24, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "convert yaml format files to json format files\n", "language_version_list": {"python": {"code_signature": "def convert_yaml_to_json(yaml_file: str, json_file: str) -> None:\n    \"\"\"\n    convert yaml format files to json format files\n    Args:\n        yaml_file (str): path to the input YAML file.\n        json_file (str): path to the output JSON file.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\nimport os\nimport json\nimport yaml\n\n\nclass TestConvertYamlToJson(unittest.TestCase):\n\n    def setUp(self):\n        # Create temporary YAML files for testing\n        self.simple_yaml = 'simple.yaml'\n        self.nested_yaml = 'nested.yaml'\n        self.empty_yaml = 'empty.yaml'\n        self.list_yaml = 'list.yaml'\n        self.invalid_yaml = 'invalid.yaml'\n\n        with open(self.simple_yaml, 'w') as file:\n            file.write(\"name: John Doe\\nage: 30\\n\")\n\n        with open(self.nested_yaml, 'w') as file:\n            file.write(\"person:\\n  name: Jane Doe\\n  age: 25\\n  address:\\n    city: New York\\n    zip: 10001\\n\")\n\n        with open(self.empty_yaml, 'w') as file:\n            file.write(\"\")\n\n        with open(self.list_yaml, 'w') as file:\n            file.write(\"- item1\\n- item2\\n- item3\\n\")\n\n        with open(self.invalid_yaml, 'w') as file:\n            file.write(\"{ invalid: YAML: structure }\\n\")\n\n    def tearDown(self):\n        # Remove temporary files after testing\n        os.remove(self.simple_yaml)\n        os.remove(self.nested_yaml)\n        os.remove(self.empty_yaml)\n        os.remove(self.list_yaml)\n        os.remove(self.invalid_yaml)\n\n        if os.path.exists('output.json'):\n            os.remove('output.json')\n\n    def test_simple_yaml_conversion(self):\n        convert_yaml_to_json(self.simple_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        self.assertEqual(data, {\"name\": \"John Doe\", \"age\": 30})\n\n    def test_nested_yaml_conversion(self):\n        convert_yaml_to_json(self.nested_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        expected_data = {\n            \"person\": {\n                \"name\": \"Jane Doe\",\n                \"age\": 25,\n                \"address\": {\n                    \"city\": \"New York\",\n                    \"zip\": 10001\n                }\n            }\n        }\n        self.assertEqual(data, expected_data)\n\n    def test_empty_yaml_conversion(self):\n        convert_yaml_to_json(self.empty_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        self.assertEqual(data, None)  # YAML.safe_load() returns None for empty files\n\n    def test_list_yaml_conversion(self):\n        convert_yaml_to_json(self.list_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        self.assertEqual(data, [\"item1\", \"item2\", \"item3\"])\n\n    def test_invalid_yaml_conversion(self):\n        with self.assertRaises(yaml.YAMLError):\n            convert_yaml_to_json(self.invalid_yaml, 'output.json')\n", "prompt": "please write a python function , the function signature as below def convert_yaml_to_json(yaml_file: str, json_file: str) -> None:\n    \"\"\"\n    convert yaml format files to json format files\n    Args:\n        yaml_file (str): path to the input YAML file.\n        json_file (str): path to the output JSON file.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Convert a YAML file to a JSON file.\n * @param {string} yamlFile - Path to the input YAML file.\n * @param {string} jsonFile - Path to the output JSON file.\n */\nfunction convertYamlToJson(yamlFile, jsonFile) {}", "test_code": "describe('TestConvertYamlToJson', () => {\n    let simpleYaml;\n    let nestedYaml;\n    let emptyYaml;\n    let listYaml;\n    let invalidYaml;\n\n    beforeAll(() => {\n        // Create temporary YAML files for testing\n        simpleYaml = 'simple.yaml';\n        nestedYaml = 'nested.yaml';\n        emptyYaml = 'empty.yaml';\n        listYaml = 'list.yaml';\n        invalidYaml = 'invalid.yaml';\n\n        fs.writeFileSync(simpleYaml, \"name: John Doe\\nage: 30\\n\");\n        fs.writeFileSync(nestedYaml, \"person:\\n  name: Jane Doe\\n  age: 25\\n  address:\\n    city: New York\\n    zip: 10001\\n\");\n        fs.writeFileSync(emptyYaml, \"\");\n        fs.writeFileSync(listYaml, \"- item1\\n- item2\\n- item3\\n\");\n        fs.writeFileSync(invalidYaml, \"{ invalid: YAML: structure }\\n\");\n    });\n\n    afterAll(() => {\n        // Remove temporary files after testing\n        fs.unlinkSync(simpleYaml);\n        fs.unlinkSync(nestedYaml);\n        fs.unlinkSync(emptyYaml);\n        fs.unlinkSync(listYaml);\n        fs.unlinkSync(invalidYaml);\n\n        if (fs.existsSync('output.json')) {\n            fs.unlinkSync('output.json');\n        }\n    });\n\n    it('should correctly convert simple YAML to JSON', () => {\n        convertYamlToJson(simpleYaml, 'output.json');\n        const data = JSON.parse(fs.readFileSync('output.json', 'utf-8'));\n        expect(data).toEqual({ \"name\": \"John Doe\", \"age\": 30 });\n    });\n\n    it('should correctly convert nested YAML to JSON', () => {\n        convertYamlToJson(nestedYaml, 'output.json');\n        const data = JSON.parse(fs.readFileSync('output.json', 'utf-8'));\n        const expectedData = {\n            \"person\": {\n                \"name\": \"Jane Doe\",\n                \"age\": 25,\n                \"address\": {\n                    \"city\": \"New York\",\n                    \"zip\": 10001\n                }\n            }\n        };\n        expect(data).toEqual(expectedData);\n    });\n\n    it('should correctly handle empty YAML conversion', () => {\n        convertYamlToJson(emptyYaml, 'output.json');\n        const data = JSON.parse(fs.readFileSync('output.json', 'utf-8'));\n        expect(data).toBeNull();  // YAML.safeLoad() returns null for empty files\n    });\n\n    it('should correctly convert list YAML to JSON', () => {\n        convertYamlToJson(listYaml, 'output.json');\n        const data = JSON.parse(fs.readFileSync('output.json', 'utf-8'));\n        expect(data).toEqual([\"item1\", \"item2\", \"item3\"]);\n    });\n\n    it('should throw an error when converting invalid YAML', () => {\n        expect(() => convertYamlToJson(invalidYaml, 'output.json')).toThrow();\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Convert a YAML file to a JSON file.\n * @param {string} yamlFile - Path to the input YAML file.\n * @param {string} jsonFile - Path to the output JSON file.\n */\nfunction convertYamlToJson(yamlFile, jsonFile) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a YAML file to a JSON file.\n * \n * @param yamlFile - Path to the input YAML file.\n * @param jsonFile - Path to the output JSON file.\n */\nfunction convertYamlToJson(yamlFile: string, jsonFile: string): void {}", "test_code": "const fs = require('fs')\ndescribe('TestConvertYamlToJson', () => {\n    let simpleYaml: string;\n    let nestedYaml: string;\n    let emptyYaml: string;\n    let listYaml: string;\n    let invalidYaml: string;\n  \n    beforeEach(() => {\n      // Create temporary YAML files for testing\n      simpleYaml = 'simple.yaml';\n      nestedYaml = 'nested.yaml';\n      emptyYaml = 'empty.yaml';\n      listYaml = 'list.yaml';\n      invalidYaml = 'invalid.yaml';\n  \n      fs.writeFileSync(simpleYaml, \"name: John Doe\\nage: 30\\n\");\n      fs.writeFileSync(nestedYaml, \"person:\\n  name: Jane Doe\\n  age: 25\\n  address:\\n    city: New York\\n    zip: 10001\\n\");\n      fs.writeFileSync(emptyYaml, \"\");\n      fs.writeFileSync(listYaml, \"- item1\\n- item2\\n- item3\\n\");\n      fs.writeFileSync(invalidYaml, \"{ invalid: YAML: structure }\\n\");\n    });\n  \n    afterEach(() => {\n      // Remove temporary files after testing\n      fs.unlinkSync(simpleYaml);\n      fs.unlinkSync(nestedYaml);\n      fs.unlinkSync(emptyYaml);\n      fs.unlinkSync(listYaml);\n      fs.unlinkSync(invalidYaml);\n  \n      if (fs.existsSync('output.json')) {\n        fs.unlinkSync('output.json');\n      }\n    });\n  \n    it('should correctly convert simple YAML to JSON', () => {\n      convertYamlToJson(simpleYaml, 'output.json');\n      const data = JSON.parse(fs.readFileSync('output.json', 'utf-8'));\n      expect(data).toEqual({ name: 'John Doe', age: 30 });\n    });\n  \n    it('should correctly convert nested YAML to JSON', () => {\n      convertYamlToJson(nestedYaml, 'output.json');\n      const data = JSON.parse(fs.readFileSync('output.json', 'utf-8'));\n      const expectedData = {\n        person: {\n          name: 'Jane Doe',\n          age: 25,\n          address: {\n            city: 'New York',\n            zip: 10001\n          }\n        }\n      };\n      expect(data).toEqual(expectedData);\n    });\n  \n    it('should correctly handle empty YAML conversion', () => {\n      convertYamlToJson(emptyYaml, 'output.json');\n      const data = JSON.parse(fs.readFileSync('output.json', 'utf-8'));\n      expect(data).toBeNull();\n    });\n  \n    it('should correctly convert list YAML to JSON', () => {\n      convertYamlToJson(listYaml, 'output.json');\n      const data = JSON.parse(fs.readFileSync('output.json', 'utf-8'));\n      expect(data).toEqual(['item1', 'item2', 'item3']);\n    });\n  \n    it('should throw an error when converting invalid YAML', () => {\n      expect(() => convertYamlToJson(invalidYaml, 'output.json')).toThrowErrorMatchingInlineSnapshot(`\"YAMLException: while parsing a flow scalar\\\\n  in \\\\\"<unicode string>\\\\\", line 1, column 1:\\\\n    { invalid: YAML: structure }\\\\n    ^\\\\nexpected \\\\'<<\\\\', but found \\\\'{\\\\'\\\\n  in \\\\\"<unicode string>\\\\\", line 1, column 2:\\\\n    { invalid: YAML: structure }\\\\n      ^\\\\\"`);\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a YAML file to a JSON file.\n * \n * @param yamlFile - Path to the input YAML file.\n * @param jsonFile - Path to the output JSON file.\n */\nfunction convertYamlToJson(yamlFile: string, jsonFile: string): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert a YAML file to a JSON file.\n *\n * @param yaml_file Path to the input YAML file.\n * @param json_file Path to the output JSON file.\n */\nvoid convert_yaml_to_json(const std::string& yaml_file, const std::string& json_file) {}", "test_code": "TEST_CASE(\"Test conversion of YAML files to JSON\") {\n    // Create temporary YAML files for testing\n    const std::string simple_yaml = \"simple.yaml\";\n    const std::string nested_yaml = \"nested.yaml\";\n    const std::string empty_yaml = \"empty.yaml\";\n    const std::string list_yaml = \"list.yaml\";\n    const std::string invalid_yaml = \"invalid.yaml\";\n\n    SECTION(\"Setup temporary files\") {\n        // Write simple YAML file\n        std::ofstream simpleFile(simple_yaml);\n        simpleFile << \"name: John Doe\\nage: 30\\n\";\n        simpleFile.close();\n\n        // Write nested YAML file\n        std::ofstream nestedFile(nested_yaml);\n        nestedFile << \"person:\\n  name: Jane Doe\\n  age: 25\\n  address:\\n    city: New York\\n    zip: 10001\\n\";\n        nestedFile.close();\n\n        // Write empty YAML file\n        std::ofstream emptyFile(empty_yaml);\n        emptyFile.close();\n\n        // Write list YAML file\n        std::ofstream listFile(list_yaml);\n        listFile << \"- item1\\n- item2\\n- item3\\n\";\n        listFile.close();\n\n        // Write invalid YAML file\n        std::ofstream invalidFile(invalid_yaml);\n        invalidFile << \"{ invalid: YAML: structure }\\n\";\n        invalidFile.close();\n    }\n\n    SECTION(\"Test simple YAML conversion\") {\n        convert_yaml_to_json(simple_yaml, \"output.json\");\n        std::ifstream jsonFile(\"output.json\");\n        REQUIRE(jsonFile.is_open());\n        json jsonData;\n        jsonFile >> jsonData;\n        REQUIRE(jsonData == (json{{\"name\", \"John Doe\"}, {\"age\", 30}}));\n    }\n\n    SECTION(\"Test nested YAML conversion\") {\n        convert_yaml_to_json(nested_yaml, \"output.json\");\n        std::ifstream jsonFile(\"output.json\");\n        REQUIRE(jsonFile.is_open());\n        json jsonData;\n        jsonFile >> jsonData;\n        REQUIRE(jsonData == (json{\n            {\"person\", {\n                {\"name\", \"Jane Doe\"},\n                {\"age\", 25},\n                {\"address\", {\n                    {\"city\", \"New York\"},\n                    {\"zip\", 10001}\n                }}\n            }}\n        }));\n    }\n\n    SECTION(\"Test empty YAML conversion\") {\n        convert_yaml_to_json(empty_yaml, \"output.json\");\n        std::ifstream jsonFile(\"output.json\");\n        REQUIRE(jsonFile.is_open());\n        json jsonData;\n        jsonFile >> jsonData;\n        REQUIRE(jsonData.is_null());\n    }\n\n    SECTION(\"Test list YAML conversion\") {\n        convert_yaml_to_json(list_yaml, \"output.json\");\n        std::ifstream jsonFile(\"output.json\");\n        REQUIRE(jsonFile.is_open());\n        json jsonData;\n        jsonFile >> jsonData;\n        REQUIRE(jsonData == (json{\"item1\", \"item2\", \"item3\"}));\n    }\n\n    SECTION(\"Test invalid YAML conversion\") {\n        REQUIRE_THROWS_AS(convert_yaml_to_json(invalid_yaml, \"output.json\"), YAML::Exception);\n    }\n\n    SECTION(\"Teardown temporary files\") {\n        std::remove(simple_yaml.c_str());\n        std::remove(nested_yaml.c_str());\n        std::remove(empty_yaml.c_str());\n        std::remove(list_yaml.c_str());\n        std::remove(invalid_yaml.c_str());\n        if (std::ifstream(\"output.json\").is_open()) {\n            std::remove(\"output.json\");\n        }\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert a YAML file to a JSON file.\n *\n * @param yaml_file Path to the input YAML file.\n * @param json_file Path to the output JSON file.\n */\nvoid convert_yaml_to_json(const std::string& yaml_file, const std::string& json_file) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a YAML file to a JSON file.\n *\n * @param yamlFilePath  Path to the input YAML file.\n * @param jsonFilePath  Path to the output JSON file.\n */\npublic static void convertYamlToJson(String yamlFilePath, String jsonFilePath) {}", "test_code": "package org.real.temp;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\nimport com.fasterxml.jackson.core.JsonProcessingException;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.Rule;\nimport org.junit.rules.TemporaryFolder;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Path;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\n/**\n * Tests for converting YAML files to JSON files.\n */\npublic class Tester {\n\n    private static final String SIMPLE_YAML = \"simple.yaml\";\n    private static final String NESTED_YAML = \"nested.yaml\";\n    private static final String EMPTY_YAML = \"empty.yaml\";\n    private static final String LIST_YAML = \"list.yaml\";\n    private static final String INVALID_YAML = \"invalid.yaml\";\n\n    @Rule\n    public TemporaryFolder tempFolder = new TemporaryFolder();\n\n    private Path tempDir;\n\n    @Before\n    public void setUp() throws IOException {\n        this.tempDir = tempFolder.newFolder().toPath();\n\n        // Create temporary YAML files for testing\n        writeYamlFile(tempDir.resolve(SIMPLE_YAML), \"name: John Doe\\nage: 30\\n\");\n        writeYamlFile(tempDir.resolve(NESTED_YAML), \"person:\\n  name: Jane Doe\\n  age: 25\\n  address:\\n    city: New York\\n    zip: 10001\\n\");\n        writeYamlFile(tempDir.resolve(EMPTY_YAML), \"\");\n        writeYamlFile(tempDir.resolve(LIST_YAML), \"- item1\\n- item2\\n- item3\\n\");\n        writeYamlFile(tempDir.resolve(INVALID_YAML), \"{ invalid: YAML: structure }\\n\");\n    }\n\n    @After\n    public void tearDown() {\n        // No explicit cleanup required with TemporaryFolder\n    }\n\n    @Test\n    public void testSimpleYamlConversion() throws IOException {\n        convertYamlToJson(tempDir.resolve(SIMPLE_YAML).toString(), \"output.json\");\n        assertEquals(\"{\\\"name\\\":\\\"John Doe\\\",\\\"age\\\":30}\", readFileContent(tempDir.resolve(\"output.json\")));\n    }\n\n    @Test\n    public void testNestedYamlConversion() throws IOException {\n        convertYamlToJson(tempDir.resolve(NESTED_YAML).toString(), \"output.json\");\n        assertEquals(\"{\\\"person\\\":{\\\"name\\\":\\\"Jane Doe\\\",\\\"age\\\":25,\\\"address\\\":{\\\"city\\\":\\\"New York\\\",\\\"zip\\\":10001}}}\", readFileContent(tempDir.resolve(\"output.json\")));\n    }\n\n    @Test\n    public void testEmptyYamlConversion() throws IOException {\n        convertYamlToJson(tempDir.resolve(EMPTY_YAML).toString(), \"output.json\");\n        assertEquals(\"\", readFileContent(tempDir.resolve(\"output.json\")));  // YAML.safe_load() returns null, but JSON dump of null is \"\"\n    }\n\n    @Test\n    public void testListYamlConversion() throws IOException {\n        convertYamlToJson(tempDir.resolve(LIST_YAML).toString(), \"output.json\");\n        assertEquals(\"[\\\"item1\\\",\\\"item2\\\",\\\"item3\\\"]\", readFileContent(tempDir.resolve(\"output.json\")));\n    }\n\n    @Test\n    public void testInvalidYamlConversion() {\n        assertThrows(Exception.class, () -> convertYamlToJson(tempDir.resolve(INVALID_YAML).toString(), \"output.json\"));\n    }\n\n    private void writeYamlFile(Path filePath, String content) throws IOException {\n        try (FileWriter writer = new FileWriter(filePath.toFile())) {\n            writer.write(content);\n        }\n    }\n\n    private String readFileContent(Path filePath) throws IOException {\n        return new String(java.nio.file.Files.readAllBytes(filePath));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts a YAML file to a JSON file.\n *\n * @param yamlFilePath  Path to the input YAML file.\n * @param jsonFilePath  Path to the output JSON file.\n */\npublic static void convertYamlToJson(String yamlFilePath, String jsonFilePath) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 25, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "read the JSON file data based on whether the pid field in the object is included in a specified pid_list. These objects are then classified into two categories based on matches and mismatches and saved in different files", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef classify_json_objects_by_pid(source_file: str, pid_list: List[int], match_file: str, mismatch_file: str) -> None:\n    \"\"\"\n    read the JSON file question based on whether the pid field in the object is included in a specified pid_list. These objects are then classified into two categories based on matches and mismatches and saved in different files\n\n    Args:\n        source_file (str): Path to the source JSON file.\n        pid_list (list): List of pids to match.\n        match_file (str): Path to save matching objects JSON.\n        mismatch_file (str): Path to save mismatching objects JSON.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\nimport json\nimport tempfile\nimport os\n\nclass TestClassifyJsonObjectsByPid(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory\n        self.temp_dir = tempfile.mkdtemp()\n\n        # Create temporary files for testing\n        self.source_file = os.path.join(self.temp_dir, 'source.json')\n        self.match_file = os.path.join(self.temp_dir, 'match.json')\n        self.mismatch_file = os.path.join(self.temp_dir, 'mismatch.json')\n\n        # Example question\n        self.data = [\n            {\"name\": \"Alice\", \"pid\": 1},\n            {\"name\": \"Bob\", \"pid\": 2},\n            {\"name\": \"Charlie\", \"pid\": 3}\n        ]\n        self.pid_list = [1, 3]\n\n        # Write example question to source file\n        with open(self.source_file, 'w') as f:\n            json.dump(self.data, f)\n\n    def test_all_match(self):\n        # Test where all items match\n        classify_json_objects_by_pid(self.source_file, [1, 2, 3], self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 3)\n        self.assertEqual(len(mismatches), 0)\n\n    def test_no_match(self):\n        # Test where no items match\n        classify_json_objects_by_pid(self.source_file, [4, 5], self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 0)\n        self.assertEqual(len(mismatches), 3)\n\n    def test_partial_match(self):\n        # Test where some items match\n        classify_json_objects_by_pid(self.source_file, self.pid_list, self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 2)\n        self.assertEqual(len(mismatches), 1)\n\n    def test_empty_pid_list(self):\n        # Test with an empty PID list\n        classify_json_objects_by_pid(self.source_file, [], self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 0)\n        self.assertEqual(len(mismatches), 3)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef classify_json_objects_by_pid(source_file: str, pid_list: List[int], match_file: str, mismatch_file: str) -> None:\n    \"\"\"\n    read the JSON file question based on whether the pid field in the object is included in a specified pid_list. These objects are then classified into two categories based on matches and mismatches and saved in different files\n\n    Args:\n        source_file (str): Path to the source JSON file.\n        pid_list (list): List of pids to match.\n        match_file (str): Path to save matching objects JSON.\n        mismatch_file (str): Path to save mismatching objects JSON.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Classifies JSON objects by pid and writes matches and mismatches to separate files.\n * \n * @param {string} sourceFile - Path to the source JSON file.\n * @param {Array} pidList - List of pids to match.\n * @param {string} matchFile - Path to save matching objects JSON.\n * @param {string} mismatchFile - Path to save mismatching objects JSON.\n */\nfunction classifyJsonObjectsByPid(sourceFile, pidList, matchFile, mismatchFile) {}", "test_code": "import fs from 'fs';\nimport path from 'path';\n\ndescribe('Classify JSON Objects by PID', () => {\n  let tempDir;\n  let sourceFile;\n  let matchFile;\n  let mismatchFile;\n  \n  beforeAll(() => {\n    // Create a temporary directory\n    tempDir = fs.mkdtempSync(path.join(__dirname, 'temp-'));\n    \n    // Create temporary files for testing\n    sourceFile = path.join(tempDir, 'source.json');\n    matchFile = path.join(tempDir, 'match.json');\n    mismatchFile = path.join(tempDir, 'mismatch.json');\n    \n    // Example data\n    const data = [\n      { name: \"Alice\", pid: 1 },\n      { name: \"Bob\", pid: 2 },\n      { name: \"Charlie\", pid: 3 }\n    ];\n\n    // Write example data to source file\n    fs.writeFileSync(sourceFile, JSON.stringify(data));\n  });\n\n  afterAll(() => {\n    // Clean up temporary files and directory\n    fs.rmSync(tempDir, { recursive: true, force: true });\n  });\n  test('all match', () => {\n    classifyJsonObjectsByPid(sourceFile, [1, 2, 3], matchFile, mismatchFile);\n    \n    const matches = JSON.parse(fs.readFileSync(matchFile, 'utf8'));\n    const mismatches = JSON.parse(fs.readFileSync(mismatchFile, 'utf8'));\n\n    expect(matches.length).toBe(3);\n    expect(mismatches.length).toBe(0);\n  });\n\n  test('no match', () => {\n    classifyJsonObjectsByPid(sourceFile, [4, 5], matchFile, mismatchFile);\n    \n    const matches = JSON.parse(fs.readFileSync(matchFile, 'utf8'));\n    const mismatches = JSON.parse(fs.readFileSync(mismatchFile, 'utf8'));\n\n    expect(matches.length).toBe(0);\n    expect(mismatches.length).toBe(3);\n  });\n\n  test('partial match', () => {\n    classifyJsonObjectsByPid(sourceFile, [1, 3], matchFile, mismatchFile);\n    \n    const matches = JSON.parse(fs.readFileSync(matchFile, 'utf8'));\n    const mismatches = JSON.parse(fs.readFileSync(mismatchFile, 'utf8'));\n\n    expect(matches.length).toBe(2);\n    expect(mismatches.length).toBe(1);\n  });\n\n  test('empty PID list', () => {\n    classifyJsonObjectsByPid(sourceFile, [], matchFile, mismatchFile);\n    \n    const matches = JSON.parse(fs.readFileSync(matchFile, 'utf8'));\n    const mismatches = JSON.parse(fs.readFileSync(mismatchFile, 'utf8'));\n\n    expect(matches.length).toBe(0);\n    expect(mismatches.length).toBe(3);\n  });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Classifies JSON objects by pid and writes matches and mismatches to separate files.\n * \n * @param {string} sourceFile - Path to the source JSON file.\n * @param {Array} pidList - List of pids to match.\n * @param {string} matchFile - Path to save matching objects JSON.\n * @param {string} mismatchFile - Path to save mismatching objects JSON.\n */\nfunction classifyJsonObjectsByPid(sourceFile, pidList, matchFile, mismatchFile) {}", "addition_info": ""}, "typescript": {"code_signature": "\ninterface JsonObject {\n    pid?: string; // Adjust type based on your expected pid structure\n    [key: string]: any; // Allows for other properties in the object\n}\n/**\n * Classifies JSON objects by pid and writes matches and mismatches to separate files.\n * \n * @param {string} sourceFile - Path to the source JSON file.\n * @param {Array} pidList - List of pids to match.\n * @param {string} matchFile - Path to save matching objects JSON.\n * @param {string} mismatchFile - Path to save mismatching objects JSON.\n */\nfunction classifyJsonObjectsByPid(\n    sourceFile: string,\n    pidList: string[],\n    matchFile: string,\n    mismatchFile: string\n): void {}", "test_code": "import fs from 'fs';\nimport path from 'path';\n\ninterface DataObject {\n  name: string;\n  pid: number;\n}\n\ndescribe('classifyJsonObjectsByPid', () => {\n  const tempDir = fs.mkdtempSync(path.join(__dirname, 'temp-'));\n  const sourceFile = path.join(tempDir, 'source.json');\n  const matchFile = path.join(tempDir, 'match.json');\n  const mismatchFile = path.join(tempDir, 'mismatch.json');\n\n  const data: DataObject[] = [\n    { name: 'Alice', pid: 1 },\n    { name: 'Bob', pid: 2 },\n    { name: 'Charlie', pid: 3 }\n  ];\n  \n  const pidList = [1, 3];\n\n  beforeAll(() => {\n    // Write example data to source file\n    fs.writeFileSync(sourceFile, JSON.stringify(data));\n  });\n\n  afterAll(() => {\n    // Cleanup temporary directory\n    fs.rmdirSync(tempDir, { recursive: true });\n  });\n\n  test('all match', () => {\n    classifyJsonObjectsByPid(sourceFile, [1, 2, 3], matchFile, mismatchFile);\n    \n    const matches = JSON.parse(fs.readFileSync(matchFile, 'utf8'));\n    const mismatches = JSON.parse(fs.readFileSync(mismatchFile, 'utf8'));\n\n    expect(matches.length).toBe(3);\n    expect(mismatches.length).toBe(0);\n  });\n\n  test('no match', () => {\n    classifyJsonObjectsByPid(sourceFile, [4, 5], matchFile, mismatchFile);\n    \n    const matches = JSON.parse(fs.readFileSync(matchFile, 'utf8'));\n    const mismatches = JSON.parse(fs.readFileSync(mismatchFile, 'utf8'));\n\n    expect(matches.length).toBe(0);\n    expect(mismatches.length).toBe(3);\n  });\n\n  test('partial match', () => {\n    classifyJsonObjectsByPid(sourceFile, pidList, matchFile, mismatchFile);\n    \n    const matches = JSON.parse(fs.readFileSync(matchFile, 'utf8'));\n    const mismatches = JSON.parse(fs.readFileSync(mismatchFile, 'utf8'));\n\n    expect(matches.length).toBe(2);\n    expect(mismatches.length).toBe(1);\n  });\n\n  test('empty pid list', () => {\n    classifyJsonObjectsByPid(sourceFile, [], matchFile, mismatchFile);\n    \n    const matches = JSON.parse(fs.readFileSync(matchFile, 'utf8'));\n    const mismatches = JSON.parse(fs.readFileSync(mismatchFile, 'utf8'));\n\n    expect(matches.length).toBe(0);\n    expect(mismatches.length).toBe(3);\n  });\n});\n", "prompt": "please write a typescript function , the function signature as below \ninterface JsonObject {\n    pid?: string; // Adjust type based on your expected pid structure\n    [key: string]: any; // Allows for other properties in the object\n}\n/**\n * Classifies JSON objects by pid and writes matches and mismatches to separate files.\n * \n * @param {string} sourceFile - Path to the source JSON file.\n * @param {Array} pidList - List of pids to match.\n * @param {string} matchFile - Path to save matching objects JSON.\n * @param {string} mismatchFile - Path to save mismatching objects JSON.\n */\nfunction classifyJsonObjectsByPid(\n    sourceFile: string,\n    pidList: string[],\n    matchFile: string,\n    mismatchFile: string\n): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Classifies JSON objects from a source file based on a list of PIDs.\n * \n * This function reads JSON data from a specified source file, classifies each object \n * into matches and mismatches based on the presence of their 'pid' in a provided list,\n * and then saves the classified objects into separate JSON files.\n *\n * @param source_file The path to the input JSON file containing the objects.\n * @param pid_list A vector of PIDs to match against the 'pid' field of the JSON objects.\n * @param match_file The path to the output JSON file where matched objects will be saved.\n * @param mismatch_file The path to the output JSON file where unmatched objects will be saved.\n */\n void classify_json_objects_by_pid(const string &source_file, const vector<string> &pid_list, const string &match_file, const string &mismatch_file) {}", "test_code": "TEST_CASE(\"classify_json_objects_by_pid all match\", \"[classify]\") {\n    // Sample data\n    nlohmann::json data = R\"([\n        {\"name\": \"Alice\", \"pid\": 1},\n        {\"name\": \"Bob\", \"pid\": 2},\n        {\"name\": \"Charlie\", \"pid\": 3}\n    ])\"_json;\n    \n    // Convert JSON to string for file writing\n    const std::string json_content = data.dump(4);\n\n    std::string source_file = create_temp_file(json_content);\n    std::string match_file = create_temp_file(\"\");\n    std::string mismatch_file = create_temp_file(\"\");\n\n    std::vector<std::string> pid_list = {\"1\", \"2\", \"3\"};\n    classify_json_objects_by_pid(source_file, pid_list, match_file, mismatch_file);\n\n    // Verify match file content\n    std::ifstream match_in(match_file);\n    nlohmann::json matches;\n    match_in >> matches;\n\n    // Verify mismatch file content\n    std::ifstream mismatch_in(mismatch_file);\n    nlohmann::json mismatches;\n    mismatch_in >> mismatches;\n\n    REQUIRE(matches.size() == 3);\n    REQUIRE(mismatches.size() == 0);\n\n    // Clean up\n    std::remove(source_file.c_str());\n    std::remove(match_file.c_str());\n    std::remove(mismatch_file.c_str());\n}\n\nTEST_CASE(\"classify_json_objects_by_pid no match\", \"[classify]\") {\n    // Sample data\n    nlohmann::json data = R\"([\n        {\"name\": \"Alice\", \"pid\": 1},\n        {\"name\": \"Bob\", \"pid\": 2},\n        {\"name\": \"Charlie\", \"pid\": 3}\n    ])\"_json;\n\n    // Convert JSON to string for file writing\n    const std::string json_content = data.dump(4);\n\n    std::string source_file = create_temp_file(json_content);\n    std::string match_file = create_temp_file(\"\");\n    std::string mismatch_file = create_temp_file(\"\");\n\n    std::vector<std::string> pid_list = {\"4\", \"5\"};\n    classify_json_objects_by_pid(source_file, pid_list, match_file, mismatch_file);\n\n    // Verify match file content\n    std::ifstream match_in(match_file);\n    nlohmann::json matches;\n    match_in >> matches;\n\n    // Verify mismatch file content\n    std::ifstream mismatch_in(mismatch_file);\n    nlohmann::json mismatches;\n    mismatch_in >> mismatches;\n\n    REQUIRE(matches.size() == 0);\n    REQUIRE(mismatches.size() == 3);\n\n    // Clean up\n    std::remove(source_file.c_str());\n    std::remove(match_file.c_str());\n    std::remove(mismatch_file.c_str());\n}\n\nTEST_CASE(\"classify_json_objects_by_pid partial match\", \"[classify]\") {\n    // Sample data\n    nlohmann::json data = R\"([\n        {\"name\": \"Alice\", \"pid\": 1},\n        {\"name\": \"Bob\", \"pid\": 2},\n        {\"name\": \"Charlie\", \"pid\": 3}\n    ])\"_json;\n\n    // Convert JSON to string for file writing\n    const std::string json_content = data.dump(4);\n\n    std::string source_file = create_temp_file(json_content);\n    std::string match_file = create_temp_file(\"\");\n    std::string mismatch_file = create_temp_file(\"\");\n\n    std::vector<std::string> pid_list = {\"1\", \"3\"};\n    classify_json_objects_by_pid(source_file, pid_list, match_file, mismatch_file);\n\n    // Verify match file content\n    std::ifstream match_in(match_file);\n    nlohmann::json matches;\n    match_in >> matches;\n\n    // Verify mismatch file content\n    std::ifstream mismatch_in(mismatch_file);\n    nlohmann::json mismatches;\n    mismatch_in >> mismatches;\n\n    REQUIRE(matches.size() == 2);\n    REQUIRE(mismatches.size() == 1);\n\n    // Clean up\n    std::remove(source_file.c_str());\n    std::remove(match_file.c_str());\n    std::remove(mismatch_file.c_str());\n}\n\nTEST_CASE(\"classify_json_objects_by_pid empty pid list\", \"[classify]\") {\n    // Sample data\n    nlohmann::json data = R\"([\n        {\"name\": \"Alice\", \"pid\": 1},\n        {\"name\": \"Bob\", \"pid\": 2},\n        {\"name\": \"Charlie\", \"pid\": 3}\n    ])\"_json;\n\n    // Convert JSON to string for file writing\n    const std::string json_content = data.dump(4);\n\n    std::string source_file = create_temp_file(json_content);\n    std::string match_file = create_temp_file(\"\");\n    std::string mismatch_file = create_temp_file(\"\");\n\n    std::vector<std::string> pid_list = {};\n    classify_json_objects_by_pid(source_file, pid_list, match_file, mismatch_file);\n\n    // Verify match file content\n    std::ifstream match_in(match_file);\n    nlohmann::json matches;\n    match_in >> matches;\n\n    // Verify mismatch file content\n    std::ifstream mismatch_in(mismatch_file);\n    nlohmann::json mismatches;\n    mismatch_in >> mismatches;\n\n    REQUIRE(matches.size() == 0);\n    REQUIRE(mismatches.size() == 3);\n\n    // Clean up\n    std::remove(source_file.c_str());\n    std::remove(match_file.c_str());\n    std::remove(mismatch_file.c_str());\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Classifies JSON objects from a source file based on a list of PIDs.\n * \n * This function reads JSON data from a specified source file, classifies each object \n * into matches and mismatches based on the presence of their 'pid' in a provided list,\n * and then saves the classified objects into separate JSON files.\n *\n * @param source_file The path to the input JSON file containing the objects.\n * @param pid_list A vector of PIDs to match against the 'pid' field of the JSON objects.\n * @param match_file The path to the output JSON file where matched objects will be saved.\n * @param mismatch_file The path to the output JSON file where unmatched objects will be saved.\n */\n void classify_json_objects_by_pid(const string &source_file, const vector<string> &pid_list, const string &match_file, const string &mismatch_file) {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 26, "code_type": "method", "original_language": "python", "question_type": "Framework and library", "summary": "convert input strings that contain multiple separators (for example, * ; /) to comma-separated formatted strings\n", "language_version_list": {"python": {"code_signature": "def convert_to_comma_separated(input_string: str) -> str:\n    \"\"\"\n    convert input strings that contain multiple separators (for example, * ; /) to comma-separated formatted strings\n\n    Args:\n        input_string (str): The input string containing various separators like *, ;, /, -, :\n\n    Returns:\n        str: A comma-separated string where all specified separators have been replaced with commas.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestConvertToCommaSeparated(unittest.TestCase):\n    def test_basic_separators(self):\n        self.assertEqual(convert_to_comma_separated(\"apple;banana*orange/mango\"), \"apple,banana,orange,mango\",\n                         \"Failed to convert basic separators.\")\n\n    def test_mixed_separators(self):\n        self.assertEqual(convert_to_comma_separated(\"grapes;lemon/melon*kiwi;litchi\"), \"grapes,lemon,melon,kiwi,litchi\",\n                         \"Failed to convert mixed separators in a string.\")\n    def test_mixed_separators2(self):\n        self.assertEqual(convert_to_comma_separated(\"grapes/lemon/melon*kiwi*litchi\"), \"grapes,lemon,melon,kiwi,litchi\",\n                         \"Failed to convert mixed separators in a string.\")\n\n    def test_no_separators(self):\n        self.assertEqual(convert_to_comma_separated(\"watermelon\"), \"watermelon\",\n                         \"Failed when no separators are present.\")", "prompt": "please write a python function , the function signature as below def convert_to_comma_separated(input_string: str) -> str:\n    \"\"\"\n    convert input strings that contain multiple separators (for example, * ; /) to comma-separated formatted strings\n\n    Args:\n        input_string (str): The input string containing various separators like *, ;, /, -, :\n\n    Returns:\n        str: A comma-separated string where all specified separators have been replaced with commas.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts input strings that contain multiple separators (for example, *, ;, /) to comma-separated formatted strings.\n *\n * @param {string} inputString - The input string containing various separators like *, ;, /, -, :\n * @returns {string} A comma-separated string where all specified separators have been replaced with commas.\n */\nfunction convertToCommaSeparated(inputString) {}", "test_code": "describe('TestConvertToCommaSeparated', () => {\n    it('should convert basic separators correctly', () => {\n        expect(convertToCommaSeparated(\"apple;banana*orange/mango\")).toBe(\"apple,banana,orange,mango\");\n    });\n\n    it('should convert mixed separators in a string correctly', () => {\n        expect(convertToCommaSeparated(\"grapes;lemon/melon*kiwi;litchi\")).toBe(\"grapes,lemon,melon,kiwi,litchi\");\n    });\n\n    it('should convert mixed separators in a string correctly (second test)', () => {\n        expect(convertToCommaSeparated(\"grapes/lemon/melon*kiwi*litchi\")).toBe(\"grapes,lemon,melon,kiwi,litchi\");\n    });\n\n    it('should handle strings with no separators correctly', () => {\n        expect(convertToCommaSeparated(\"watermelon\")).toBe(\"watermelon\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts input strings that contain multiple separators (for example, *, ;, /) to comma-separated formatted strings.\n *\n * @param {string} inputString - The input string containing various separators like *, ;, /, -, :\n * @returns {string} A comma-separated string where all specified separators have been replaced with commas.\n */\nfunction convertToCommaSeparated(inputString) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts an input string with multiple separators to a comma-separated string.\n * Now handles additional separators: hyphens (-) and colons (:).\n *\n * @param inputString - The input string containing various separators like *, ;, /, -, :.\n * @returns A comma-separated string where all specified separators have been replaced with commas.\n */\nfunction convertToCommaSeparated(inputString: string): string {}", "test_code": "describe('convertToCommaSeparated', () => {\n    it('should convert basic separators', () => {\n        expect(convertToCommaSeparated(\"apple;banana*orange/mango\")).toBe(\"apple,banana,orange,mango\");\n    });\n\n    it('should convert mixed separators in a string', () => {\n        expect(convertToCommaSeparated(\"grapes;lemon/melon*kiwi;litchi\")).toBe(\"grapes,lemon,melon,kiwi,litchi\");\n    });\n\n    it('should convert mixed separators in another string', () => {\n        expect(convertToCommaSeparated(\"grapes/lemon/melon*kiwi*litchi\")).toBe(\"grapes,lemon,melon,kiwi,litchi\");\n    });\n\n    it('should handle strings without separators', () => {\n        expect(convertToCommaSeparated(\"watermelon\")).toBe(\"watermelon\");\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts an input string with multiple separators to a comma-separated string.\n * Now handles additional separators: hyphens (-) and colons (:).\n *\n * @param inputString - The input string containing various separators like *, ;, /, -, :.\n * @returns A comma-separated string where all specified separators have been replaced with commas.\n */\nfunction convertToCommaSeparated(inputString: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts an input string with multiple separators to a comma-separated string.\n *\n * This function handles additional separators such as hyphens (-) and colons (:).\n *\n * @param input_string The input string containing various separators like *, ;, /, -, :.\n * @return A comma-separated string where all specified separators have been replaced with commas.\n */\nstd::string convert_to_comma_separated(const std::string& input_string) {}", "test_code": "TEST_CASE(\"TestConvertToCommaSeparated\", \"[convert_to_comma_separated]\") {\n    SECTION(\"test_basic_separators\") {\n        CHECK(convert_to_comma_separated(\"apple;banana*orange/mango\") == \"apple,banana,orange,mango\");\n        INFO(\"Failed to convert basic separators.\");\n    }\n\n    SECTION(\"test_mixed_separators\") {\n        CHECK(convert_to_comma_separated(\"grapes;lemon/melon*kiwi;litchi\") == \"grapes,lemon,melon,kiwi,litchi\");\n        INFO(\"Failed to convert mixed separators in a string.\");\n    }\n\n    SECTION(\"test_mixed_separators2\") {\n        CHECK(convert_to_comma_separated(\"grapes/lemon/melon*kiwi*litchi\") == \"grapes,lemon,melon,kiwi,litchi\");\n        INFO(\"Failed to convert mixed separators in a string.\");\n    }\n\n    SECTION(\"test_no_separators\") {\n        CHECK(convert_to_comma_separated(\"watermelon\") == \"watermelon\");\n        INFO(\"Failed when no separators are present.\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts an input string with multiple separators to a comma-separated string.\n *\n * This function handles additional separators such as hyphens (-) and colons (:).\n *\n * @param input_string The input string containing various separators like *, ;, /, -, :.\n * @return A comma-separated string where all specified separators have been replaced with commas.\n */\nstd::string convert_to_comma_separated(const std::string& input_string) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts input strings that contain multiple separators (for example, *, ;, /, -, :) \n * to comma-separated formatted strings.\n *\n * @param inputString The input string containing various separators like *, ;, /, -, :\n * @return A comma-separated string where all specified separators have been replaced with commas.\n */\npublic static String convertToCommaSeparated(String inputString) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    /**\n     * Tests conversion of basic separators.\n     */\n    @Test\n    public void testBasicSeparators() {\n        assertEquals(\"Failed to convert basic separators.\",\n                     \"apple,banana,orange,mango\",\n                     convertToCommaSeparated(\"apple;banana*orange/mango\"));\n    }\n\n    /**\n     * Tests conversion of mixed separators in a string.\n     */\n    @Test\n    public void testMixedSeparators() {\n        assertEquals(\"Failed to convert mixed separators in a string.\",\n                     \"grapes,lemon,melon,kiwi,litchi\",\n                     convertToCommaSeparated(\"grapes;lemon/melon*kiwi;litchi\"));\n    }\n\n    /**\n     * Tests conversion of mixed separators in another string.\n     */\n    @Test\n    public void testMixedSeparators2() {\n        assertEquals(\"Failed to convert mixed separators in a string.\",\n                     \"grapes,lemon,melon,kiwi,litchi\",\n                     convertToCommaSeparated(\"grapes/lemon/melon*kiwi*litchi\"));\n    }\n\n    /**\n     * Tests the case where no separators are present.\n     */\n    @Test\n    public void testNoSeparators() {\n        assertEquals(\"Failed when no separators are present.\",\n                     \"watermelon\",\n                     convertToCommaSeparated(\"watermelon\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts input strings that contain multiple separators (for example, *, ;, /, -, :) \n * to comma-separated formatted strings.\n *\n * @param inputString The input string containing various separators like *, ;, /, -, :\n * @return A comma-separated string where all specified separators have been replaced with commas.\n */\npublic static String convertToCommaSeparated(String inputString) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 27, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "concatenate the root-level array JSON files in the specified directory", "language_version_list": {"python": {"code_signature": "import os\nimport json\nfrom typing import List\n\n\ndef concatenate_json_arrays(directory: str) -> List:\n    \"\"\"\n    concatenate the root-level array JSON files in the specified directory\n    Args:\n        directory (str): directory dir path\n\n    Returns: merged question\n\n    \"\"\"\n", "test_code": "import json\nimport os\nimport unittest\n\n\nclass TestConcatenateJsonArrays(unittest.TestCase):\n\n    def setUp(self):\n        # Set up a test.js directory and test.js files\n        self.test_dir = 'test_json'\n        os.makedirs(self.test_dir, exist_ok=True)\n        # Create test.js JSON files\n        self.create_test_file('array1.json', [1, 2, 3])\n        self.create_test_file('array2.json', ['a', 'b', 'c'])\n        self.create_test_file('not_array.json', {'key': 'value'})\n        self.create_test_file('empty.json', [])\n        self.create_test_file('non_json.txt', \"This is not a JSON file.\")\n\n    def tearDown(self):\n        # Clean up: Remove created files and directory\n        for filename in os.listdir(self.test_dir):\n            os.remove(os.path.join(self.test_dir, filename))\n        os.rmdir(self.test_dir)\n\n    def create_test_file(self, filename, content):\n        # Helper method to create JSON files\n        with open(os.path.join(self.test_dir, filename), 'w') as f:\n            json.dump(content, f)\n\n    def test_concatenate_valid_json_arrays(self):\n        # Test with valid JSON arrays\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertCountEqual(result, [1, 2, 3, 'a', 'b', 'c'])\n\n    def test_ignore_non_array_json(self):\n        # Test that non-array JSON files are ignored\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertNotIn('key', result)\n\n    def test_ignore_non_json_files(self):\n        # Test that non-JSON files are ignored\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertNotIn(\"This is not a JSON file.\", result)\n\n    def test_handle_empty_arrays(self):\n        # Test concatenation includes empty arrays\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertNotIn([], result)\n\n    def test_empty_directory(self):\n        # Test with no JSON files in the directory\n        empty_dir = 'empty_test_json'\n        os.makedirs(empty_dir, exist_ok=True)\n        result = concatenate_json_arrays(empty_dir)\n        self.assertEqual(result, [])\n        os.rmdir(empty_dir)\n", "prompt": "please write a python function , the function signature as below import os\nimport json\nfrom typing import List\n\n\ndef concatenate_json_arrays(directory: str) -> List:\n    \"\"\"\n    concatenate the root-level array JSON files in the specified directory\n    Args:\n        directory (str): directory dir path\n\n    Returns: merged question\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "import fs from 'fs';\nimport path from 'path';\n/**\n * Concatenate the root-level array JSON files in the specified directory.\n * \n * @param {string} directory - The directory path.\n * @returns {Array} Merged array of JSON objects.\n */\nfunction concatenateJsonArrays(directory) {}", "test_code": "describe('concatenateJsonArrays', () => {\n    const testDir = 'test_json';\n\n    beforeAll(() => {\n        // Set up test directory and JSON files\n        fs.mkdirSync(testDir, { recursive: true });\n        fs.writeFileSync(path.join(testDir, 'array1.json'), JSON.stringify([1, 2, 3]));\n        fs.writeFileSync(path.join(testDir, 'array2.json'), JSON.stringify(['a', 'b', 'c']));\n        fs.writeFileSync(path.join(testDir, 'not_array.json'), JSON.stringify({ key: 'value' }));\n        fs.writeFileSync(path.join(testDir, 'empty.json'), JSON.stringify([]));\n        fs.writeFileSync(path.join(testDir, 'non_json.txt'), \"This is not a JSON file.\");\n    });\n\n    afterAll(() => {\n        // Clean up: Remove created files and directory\n        fs.readdirSync(testDir).forEach(file => {\n            fs.unlinkSync(path.join(testDir, file));\n        });\n        fs.rmdirSync(testDir);\n    });\n\n    test('concatenate valid JSON arrays', () => {\n        const result = concatenateJsonArrays(testDir);\n        expect(result).toEqual(expect.arrayContaining([1, 2, 3, 'a', 'b', 'c']));\n    });\n\n    test('ignore non-array JSON', () => {\n        const result = concatenateJsonArrays(testDir);\n        expect(result).not.toContain('key');\n    });\n\n    test('ignore non-JSON files', () => {\n        const result = concatenateJsonArrays(testDir);\n        expect(result).not.toContain(\"This is not a JSON file.\");\n    });\n\n    test('handle empty arrays', () => {\n        const result = concatenateJsonArrays(testDir);\n        expect(result).not.toContain([]);\n    });\n\n    test('empty directory', () => {\n        const emptyDir = 'empty_test_json';\n        fs.mkdirSync(emptyDir, { recursive: true });\n        const result = concatenateJsonArrays(emptyDir);\n        expect(result).toEqual([]);\n        fs.rmdirSync(emptyDir);\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below import fs from 'fs';\nimport path from 'path';\n/**\n * Concatenate the root-level array JSON files in the specified directory.\n * \n * @param {string} directory - The directory path.\n * @returns {Array} Merged array of JSON objects.\n */\nfunction concatenateJsonArrays(directory) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as fs from 'fs';\nimport * as path from 'path';\n/**\n * Concatenate the root-level array JSON files in the specified directory.\n * \n * @param {string} directory - The directory path.\n * @returns {Array} Merged array of JSON objects.\n */\nfunction concatenateJsonArrays(directory: string): any[] {}", "test_code": "describe('concatenateJsonArrays', () => {\n    const testDir = 'test_json';\n\n    beforeAll(() => {\n        // Set up test directory and JSON files\n        fs.mkdirSync(testDir, { recursive: true });\n        fs.writeFileSync(path.join(testDir, 'array1.json'), JSON.stringify([1, 2, 3]));\n        fs.writeFileSync(path.join(testDir, 'array2.json'), JSON.stringify(['a', 'b', 'c']));\n        fs.writeFileSync(path.join(testDir, 'not_array.json'), JSON.stringify({ key: 'value' }));\n        fs.writeFileSync(path.join(testDir, 'empty.json'), JSON.stringify([]));\n        fs.writeFileSync(path.join(testDir, 'non_json.txt'), \"This is not a JSON file.\");\n    });\n\n    afterAll(() => {\n        // Clean up: Remove created files and directory\n        fs.readdirSync(testDir).forEach(file => {\n            fs.unlinkSync(path.join(testDir, file));\n        });\n        fs.rmdirSync(testDir);\n    });\n\n    test('concatenate valid JSON arrays', () => {\n        const result = concatenateJsonArrays(testDir);\n        expect(result).toEqual(expect.arrayContaining([1, 2, 3, 'a', 'b', 'c']));\n    });\n\n    test('ignore non-array JSON', () => {\n        const result = concatenateJsonArrays(testDir);\n        expect(result).not.toContain('key');\n    });\n\n    test('ignore non-JSON files', () => {\n        const result = concatenateJsonArrays(testDir);\n        expect(result).not.toContain(\"This is not a JSON file.\");\n    });\n\n    test('handle empty arrays', () => {\n        const result = concatenateJsonArrays(testDir);\n        expect(result).not.toContain([]);\n    });\n\n    test('empty directory', () => {\n        const emptyDir = 'empty_test_json';\n        fs.mkdirSync(emptyDir, { recursive: true });\n        const result = concatenateJsonArrays(emptyDir);\n        expect(result).toEqual([]);\n        fs.rmdirSync(emptyDir);\n    });\n});\n", "prompt": "please write a typescript function , the function signature as below import * as fs from 'fs';\nimport * as path from 'path';\n/**\n * Concatenate the root-level array JSON files in the specified directory.\n * \n * @param {string} directory - The directory path.\n * @returns {Array} Merged array of JSON objects.\n */\nfunction concatenateJsonArrays(directory: string): any[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Concatenates JSON arrays from all JSON files in a specified directory.\n * \n * This function iterates through all the files in the given directory, \n * reads the contents of each JSON file, and combines all the arrays \n * found at the root level of each file into a single vector.\n *\n * @param directory The path to the directory containing the JSON files.\n * @return A vector containing all the JSON objects found in the arrays \n *         across the JSON files in the specified directory.\n */\nstd::vector<Json::Value> concatenate_json_arrays(const std::string &directory) {}", "test_code": "// Test suite for concatenate_json_arrays\nTEST_CASE(\"Testconcatenate_json_arrays\", \"[json]\") {\n    std::string testDir = \"test_json\";\n    fs::create_directory(testDir);\n\n    // Set up test files\n    createTestFile(testDir + \"/array1.json\", Json::Value(Json::arrayValue));\n    createTestFile(testDir + \"/array1.json\")[0] = 1;\n    createTestFile(testDir + \"/array1.json\")[1] = 2;\n    createTestFile(testDir + \"/array1.json\")[2] = 3;\n\n    createTestFile(testDir + \"/array2.json\", Json::Value(Json::arrayValue));\n    createTestFile(testDir + \"/array2.json\")[0] = \"a\";\n    createTestFile(testDir + \"/array2.json\")[1] = \"b\";\n    createTestFile(testDir + \"/array2.json\")[2] = \"c\";\n\n    createTestFile(testDir + \"/not_array.json\", Json::Value(Json::objectValue));\n    createTestFile(testDir + \"/not_array.json\")[\"key\"] = \"value\";\n\n    createTestFile(testDir + \"/empty.json\", Json::Value(Json::arrayValue));\n\n    std::ofstream nonJsonFile(testDir + \"/non_json.txt\");\n    nonJsonFile << \"This is not a JSON file.\";\n    nonJsonFile.close();\n\n    // Test with valid JSON arrays\n    SECTION(\"Concatenate valid JSON arrays\") {\n        auto result = concatenate_json_arrays(testDir);\n        REQUIRE(result.size() == 5);\n        REQUIRE(result[0].asInt() == 1);\n        REQUIRE(result[1].asInt() == 2);\n        REQUIRE(result[2].asInt() == 3);\n        REQUIRE(result[3].asString() == \"a\");\n        REQUIRE(result[4].asString() == \"b\");\n        REQUIRE(result[5].asString() == \"c\");\n    }\n\n    // Test that non-array JSON files are ignored\n    SECTION(\"Ignore non-array JSON\") {\n        auto result = concatenate_json_arrays(testDir);\n        REQUIRE(result.size() == 5);\n        REQUIRE_FALSE(std::any_of(result.begin(), result.end(), [](const Json::Value &val) {\n            return val.isObject() && val.isMember(\"key\");\n        }));\n    }\n\n    // Test that non-JSON files are ignored\n    SECTION(\"Ignore non-JSON files\") {\n        auto result = concatenate_json_arrays(testDir);\n        REQUIRE_FALSE(std::any_of(result.begin(), result.end(), [](const Json::Value &val) {\n            return val.asString() == \"This is not a JSON file.\";\n        }));\n    }\n\n    // Test concatenation includes empty arrays\n    SECTION(\"Handle empty arrays\") {\n        auto result = concatenate_json_arrays(testDir);\n        REQUIRE(result.size() == 5);\n        REQUIRE_FALSE(std::any_of(result.begin(), result.end(), [](const Json::Value &val) {\n            return val.isArray() && val.empty();\n        }));\n    }\n\n    // Clean up created files\n    for (const auto &entry : fs::directory_iterator(testDir)) {\n        fs::remove(entry.path());\n    }\n    fs::remove(testDir);\n}\n\nTEST_CASE(\"TestEmptyDirectory\", \"[json]\") {\n    std::string emptyDir = \"empty_test_json\";\n    fs::create_directory(emptyDir);\n    auto result = concatenate_json_arrays(emptyDir);\n    REQUIRE(result.empty());\n    fs::remove(emptyDir);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Concatenates JSON arrays from all JSON files in a specified directory.\n * \n * This function iterates through all the files in the given directory, \n * reads the contents of each JSON file, and combines all the arrays \n * found at the root level of each file into a single vector.\n *\n * @param directory The path to the directory containing the JSON files.\n * @return A vector containing all the JSON objects found in the arrays \n *         across the JSON files in the specified directory.\n */\nstd::vector<Json::Value> concatenate_json_arrays(const std::string &directory) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Concatenates JSON arrays from all JSON files in a specified directory into a single list.\n *\n * @param directory The path to the directory containing JSON files.\n * @return A list of JSONObject instances, representing the combined data from all JSON arrays found.\n */\npublic List<JSONObject> concatenateJsonArrays(String directory) {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\n\nimport static org.junit.Assert.*;\n\npublic class Tester {\n    private String testDir;\n\n    @Before\n    public void setUp() throws IOException {\n        // Set up a test directory and JSON files\n        testDir = \"test_json\";\n        Files.createDirectories(Paths.get(testDir));\n        createTestFile(\"array1.json\", Arrays.asList(1, 2, 3));\n        createTestFile(\"array2.json\", Arrays.asList(\"a\", \"b\", \"c\"));\n        createTestFile(\"not_array.json\", \"{\\\"key\\\": \\\"value\\\"}\");\n        createTestFile(\"empty.json\", Arrays.asList());\n        createTestFile(\"non_json.txt\", \"This is not a JSON file.\");\n    }\n\n    @After\n    public void tearDown() throws IOException {\n        // Clean up: Remove created files and directory\n        File dir = new File(testDir);\n        for (File file : dir.listFiles()) {\n            file.delete();\n        }\n        dir.delete();\n    }\n\n    private void createTestFile(String filename, Object content) throws IOException {\n        // Helper method to create JSON files\n        try (FileWriter writer = new FileWriter(new File(testDir, filename))) {\n            if (content instanceof String) {\n                writer.write((String) content);\n            } else {\n                writer.write(new com.google.gson.Gson().toJson(content));\n            }\n        }\n    }\n\n    @Test\n    public void testConcatenateValidJsonArrays() {\n        // Test with valid JSON arrays\n        Object result = ConcatenateJsonArrays.concatenate(testDir);\n        assertArrayEquals(new Object[]{1, 2, 3, \"a\", \"b\", \"c\"}, (Object[]) result);\n    }\n\n    @Test\n    public void testIgnoreNonArrayJson() {\n        // Test that non-array JSON files are ignored\n        Object result = ConcatenateJsonArrays.concatenate(testDir);\n        assertFalse(Arrays.asList((Object[]) result).contains(\"key\"));\n    }\n\n    @Test\n    public void testIgnoreNonJsonFiles() {\n        // Test that non-JSON files are ignored\n        Object result = ConcatenateJsonArrays.concatenate(testDir);\n        assertFalse(Arrays.asList((Object[]) result).contains(\"This is not a JSON file.\"));\n    }\n\n    @Test\n    public void testHandleEmptyArrays() {\n        // Test concatenation includes empty arrays\n        Object result = ConcatenateJsonArrays.concatenate(testDir);\n        assertFalse(Arrays.asList((Object[]) result).contains(Arrays.asList()));\n    }\n\n    @Test\n    public void testEmptyDirectory() throws IOException {\n        // Test with no JSON files in the directory\n        String emptyDir = \"empty_test_json\";\n        Files.createDirectories(Paths.get(emptyDir));\n        Object result = ConcatenateJsonArrays.concatenate(emptyDir);\n        assertEquals(0, ((Object[]) result).length);\n        new File(emptyDir).delete();\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Concatenates JSON arrays from all JSON files in a specified directory into a single list.\n *\n * @param directory The path to the directory containing JSON files.\n * @return A list of JSONObject instances, representing the combined data from all JSON arrays found.\n */\npublic List<JSONObject> concatenateJsonArrays(String directory) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 28, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Read a section of memory, printing the status of each bit 0 or 1", "language_version_list": {"python": {"code_signature": "def print_memory_bits(memory_section: bytes):\n    \"\"\"\n    Prints the status of each bit (0 or 1) in the given section of memory.\n    For example:\n        input: 0b10101010\n        output: 10101010\n    If have multiple bytes use \\n split\n    For example:\n        input: [0b11001100, 0b11110000]\n        output: 11001100\\n11110000\n\n    Args:\n        memory_section (bytes): A bytes object representing the section of memory to be read.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\nfrom io import StringIO\nimport sys\n\n\nclass TestPrintMemoryBits(unittest.TestCase):\n\n    def setUp(self):\n        # Capture the output during each test\n        self.held_stdout = StringIO()\n        sys.stdout = self.held_stdout\n\n    def tearDown(self):\n        # Restore the normal stdout\n        sys.stdout = sys.__stdout__\n\n    def test_single_byte(self):\n        memory_section = bytes([0b10101010])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"10101010\"\n        self.assertEqual(output, expected_output)\n\n    def test_multiple_bytes(self):\n        memory_section = bytes([0b11001100, 0b11110000])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"11001100\\n11110000\"\n        self.assertEqual(output, expected_output)\n\n    def test_all_zeros(self):\n        memory_section = bytes([0b00000000])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"00000000\"\n        self.assertEqual(output, expected_output)\n\n    def test_all_ones(self):\n        memory_section = bytes([0b11111111])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"11111111\"\n        self.assertEqual(output, expected_output)", "prompt": "please write a python function , the function signature as below def print_memory_bits(memory_section: bytes):\n    \"\"\"\n    Prints the status of each bit (0 or 1) in the given section of memory.\n    For example:\n        input: 0b10101010\n        output: 10101010\n    If have multiple bytes use \\n split\n    For example:\n        input: [0b11001100, 0b11110000]\n        output: 11001100\\n11110000\n\n    Args:\n        memory_section (bytes): A bytes object representing the section of memory to be read.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Prints the status of each bit (0 or 1) in the given section of memory.\n * For example:\n *     input: 0b10101010\n *     output: 10101010\n * If there are multiple bytes, they are split using \\n.\n * For example:\n *     input: [0b11001100, 0b11110000]\n *     output: 11001100\n *            11110000\n *\n * @param memory_section A vector of uint8_t representing the section of memory to be read.\n */\nvoid print_memory_bits(const std::vector<uint8_t>& memory_section) {}", "test_code": "TEST_CASE(\"TestPrintMemoryBits\", \"[print_memory_bits]\") {\n    struct RedirectStdout {\n        std::streambuf* orig;\n        std::stringstream buffer;\n\n        RedirectStdout() : orig(std::cout.rdbuf(buffer.rdbuf())) {}\n        ~RedirectStdout() { std::cout.rdbuf(orig); }\n\n        std::string str() const { return buffer.str(); }\n    };\n\n    SECTION(\"test_single_byte\") {\n        std::vector<uint8_t> memory_section = {0b10101010};\n        RedirectStdout redirector;\n        print_memory_bits(memory_section);\n        std::string output = redirector.str().substr(0, 8); // Remove newline\n        REQUIRE(output == \"10101010\");\n    }\n\n    SECTION(\"test_multiple_bytes\") {\n        std::vector<uint8_t> memory_section = {0b11001100, 0b11110000};\n        RedirectStdout redirector;\n        print_memory_bits(memory_section);\n        std::string output = redirector.str();\n        REQUIRE(output == \"11001100\\n11110000\\n\");\n    }\n\n    SECTION(\"test_all_zeros\") {\n        std::vector<uint8_t> memory_section = {0b00000000};\n        RedirectStdout redirector;\n        print_memory_bits(memory_section);\n        std::string output = redirector.str().substr(0, 8); // Remove newline\n        REQUIRE(output == \"00000000\");\n    }\n\n    SECTION(\"test_all_ones\") {\n        std::vector<uint8_t> memory_section = {0b11111111};\n        RedirectStdout redirector;\n        print_memory_bits(memory_section);\n        std::string output = redirector.str().substr(0, 8); // Remove newline\n        REQUIRE(output == \"11111111\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Prints the status of each bit (0 or 1) in the given section of memory.\n * For example:\n *     input: 0b10101010\n *     output: 10101010\n * If there are multiple bytes, they are split using \\n.\n * For example:\n *     input: [0b11001100, 0b11110000]\n *     output: 11001100\n *            11110000\n *\n * @param memory_section A vector of uint8_t representing the section of memory to be read.\n */\nvoid print_memory_bits(const std::vector<uint8_t>& memory_section) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Prints the status of each bit (0 or 1) in the given section of memory.\n * For example:\n *     input: 0b10101010\n *     output: 10101010\n * If have multiple bytes use \\n split\n * For example:\n *     input: [0b11001100, 0b11110000]\n *     output: 11001100\\n11110000\n *\n * @param memorySection A byte array representing the section of memory to be read.\n */\npublic static void printMemoryBits(byte[] memorySection) {}\n", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\nimport static org.real.temp.Answer.*;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();\n    private final PrintStream originalOut = System.out;\n\n    @Before\n    public void setUp() {\n        // Redirect System.out to capture the output\n        System.setOut(new PrintStream(outContent));\n    }\n\n    @After\n    public void tearDown() {\n        // Restore the normal System.out\n        System.setOut(originalOut);\n    }\n\n    @Test\n    public void testSingleByte() {\n        byte[] memorySection = new byte[]{(byte) 0b10101010};\n        printMemoryBits(memorySection);\n        String output = outContent.toString().trim();\n        String expectedOutput = \"10101010\";\n        assertEquals(expectedOutput, output);\n    }\n\n    @Test\n    public void testMultipleBytes() {\n        byte[] memorySection = new byte[]{(byte) 0b11001100, (byte) 0b11110000};\n        printMemoryBits(memorySection);\n        String output = outContent.toString().trim();\n        String expectedOutput = \"11001100\\r\\n11110000\";\n        assertEquals(expectedOutput, output);\n    }\n\n    @Test\n    public void testAllZeros() {\n        byte[] memorySection = new byte[]{(byte) 0b00000000};\n        printMemoryBits(memorySection);\n        String output = outContent.toString().trim();\n        String expectedOutput = \"00000000\";\n        assertEquals(expectedOutput, output);\n    }\n\n    @Test\n    public void testAllOnes() {\n        byte[] memorySection = new byte[]{(byte) 0b11111111};\n        printMemoryBits(memorySection);\n        String output = outContent.toString().trim();\n        String expectedOutput = \"11111111\";\n        assertEquals(expectedOutput, output);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Prints the status of each bit (0 or 1) in the given section of memory.\n * For example:\n *     input: 0b10101010\n *     output: 10101010\n * If have multiple bytes use \\n split\n * For example:\n *     input: [0b11001100, 0b11110000]\n *     output: 11001100\\n11110000\n *\n * @param memorySection A byte array representing the section of memory to be read.\n */\npublic static void printMemoryBits(byte[] memorySection) {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 31, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Analyze a list of pixels, each represented by rgb, and calculate the proportion of red in the list", "language_version_list": {"python": {"code_signature": "from typing import List, Tuple\n\n\ndef calculate_red_proportion(pixels: List[Tuple[int, int, int]]) -> float:\n    \"\"\"\n    Analyze a list of pixels, each represented by rgb, and calculate the proportion of red in the list.\n\n    Args:\n        pixels (List[Tuple[int, int, int]]): A list of pixels, where each pixel is represented as a tuple of (R, G, B).\n\n    Returns:\n        float: The proportion of red in the list of pixels, as a value between 0 and 1.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCalculateRedProportion(unittest.TestCase):\n\n    def test_all_red_pixels(self):\n        # All pixels are fully red\n        pixels = [(255, 0, 0), (255, 0, 0), (255, 0, 0)]\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 1.0)\n\n    def test_no_red_pixels(self):\n        # No red component in any pixel\n        pixels = [(0, 255, 0), (0, 0, 255), (0, 255, 255)]\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 0.0)\n\n    def test_empty_pixel_list(self):\n        # Empty list of pixels\n        pixels = []\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 0.0)\n\n    def test_all_black_pixels(self):\n        # All pixels are black\n        pixels = [(0, 0, 0), (0, 0, 0), (0, 0, 0)]\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 0.0)\n", "prompt": "please write a python function , the function signature as below from typing import List, Tuple\n\n\ndef calculate_red_proportion(pixels: List[Tuple[int, int, int]]) -> float:\n    \"\"\"\n    Analyze a list of pixels, each represented by rgb, and calculate the proportion of red in the list.\n\n    Args:\n        pixels (List[Tuple[int, int, int]]): A list of pixels, where each pixel is represented as a tuple of (R, G, B).\n\n    Returns:\n        float: The proportion of red in the list of pixels, as a value between 0 and 1.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Analyze a list of pixels, each represented by RGB, and calculate the proportion of red in the list.\n *\n * @param {Array<Array<number>>} pixels - A list of pixels, where each pixel is represented as an array [R, G, B].\n * @returns {number} The proportion of red in the list of pixels, as a value between 0 and 1.\n */\nfunction calculateRedProportion(pixels) {}", "test_code": "describe('TestCalculateRedProportion', () => {\n    it('should return 1.0 when all pixels are fully red', () => {\n        const pixels = [[255, 0, 0], [255, 0, 0], [255, 0, 0]];\n        const result = calculateRedProportion(pixels);\n        expect(result).toBeCloseTo(1.0);\n    });\n\n    it('should return 0.0 when no red component in any pixel', () => {\n        const pixels = [[0, 255, 0], [0, 0, 255], [0, 255, 255]];\n        const result = calculateRedProportion(pixels);\n        expect(result).toBeCloseTo(0.0);\n    });\n\n    it('should return 0.0 when the pixel list is empty', () => {\n        const pixels = [];\n        const result = calculateRedProportion(pixels);\n        expect(result).toBeCloseTo(0.0);\n    });\n\n    it('should return 0.0 when all pixels are black', () => {\n        const pixels = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n        const result = calculateRedProportion(pixels);\n        expect(result).toBeCloseTo(0.0);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Analyze a list of pixels, each represented by RGB, and calculate the proportion of red in the list.\n *\n * @param {Array<Array<number>>} pixels - A list of pixels, where each pixel is represented as an array [R, G, B].\n * @returns {number} The proportion of red in the list of pixels, as a value between 0 and 1.\n */\nfunction calculateRedProportion(pixels) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Analyze a list of pixels, each represented by RGB, and calculate the proportion of red in the list.\n *\n * @param pixels - An array of pixels, where each pixel is represented as a tuple of [R, G, B].\n * @returns The proportion of red in the list of pixels, as a value between 0 and 1.\n */\nfunction calculateRedProportion(pixels: [number, number, number][]): number {}", "test_code": "describe('TestCalculateRedProportion', () => {\n    it('should return 1.0 for all fully red pixels', () => {\n      const pixels: [number, number, number][] = [[255, 0, 0], [255, 0, 0], [255, 0, 0]];\n      const result = calculateRedProportion(pixels);\n      expect(result).toBeCloseTo(1.0);\n    });\n  \n    it('should return 0.0 for no red component in any pixel', () => {\n      const pixels: [number, number, number][] = [[0, 255, 0], [0, 0, 255], [0, 255, 255]];\n      const result = calculateRedProportion(pixels);\n      expect(result).toBeCloseTo(0.0);\n    });\n  \n    it('should return 0.0 for an empty list of pixels', () => {\n      const pixels: [number, number, number][] = [];\n      const result = calculateRedProportion(pixels);\n      expect(result).toBeCloseTo(0.0);\n    });\n  \n    it('should return 0.0 for all black pixels', () => {\n      const pixels: [number, number, number][] = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n      const result = calculateRedProportion(pixels);\n      expect(result).toBeCloseTo(0.0);\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Analyze a list of pixels, each represented by RGB, and calculate the proportion of red in the list.\n *\n * @param pixels - An array of pixels, where each pixel is represented as a tuple of [R, G, B].\n * @returns The proportion of red in the list of pixels, as a value between 0 and 1.\n */\nfunction calculateRedProportion(pixels: [number, number, number][]): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculates the proportion of red in a list of pixels.\n *\n * Each pixel is represented as a tuple of (R, G, B).\n *\n * @param pixels A list of pixels, where each pixel is represented as a tuple of (R, G, B).\n *               This is a constant reference to a vector of tuples.\n * @return The proportion of red in the list of pixels, as a value between 0 and 1.\n */\nfloat calculate_red_proportion(const std::vector<std::tuple<int, int, int>>& pixels) {}", "test_code": "TEST_CASE(\"Test calculate_red_proportion\", \"[calculate_red_proportion]\") {\n    SECTION(\"All red pixels\") {\n        // All pixels are fully red\n        std::vector<std::tuple<int, int, int>> pixels = {{255, 0, 0}, {255, 0, 0}, {255, 0, 0}};\n        float result = calculate_red_proportion(pixels);\n        REQUIRE_THAT(result, Catch::Matchers::WithinAbs(1.0f, 0.001));\n    }\n\n    SECTION(\"No red pixels\") {\n        // No red component in any pixel\n        std::vector<std::tuple<int, int, int>> pixels = {{0, 255, 0}, {0, 0, 255}, {0, 255, 255}};\n        float result = calculate_red_proportion(pixels);\n        REQUIRE_THAT(result, Catch::Matchers::WithinAbs(0.0f, 0.001));\n    }\n\n    SECTION(\"Empty pixel list\") {\n        // Empty list of pixels\n        std::vector<std::tuple<int, int, int>> pixels = {};\n        float result = calculate_red_proportion(pixels);\n        REQUIRE_THAT(result, Catch::Matchers::WithinAbs(0.0f, 0.001));\n    }\n\n    SECTION(\"All black pixels\") {\n        // All pixels are black\n        std::vector<std::tuple<int, int, int>> pixels = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};\n        float result = calculate_red_proportion(pixels);\n        REQUIRE_THAT(result, Catch::Matchers::WithinAbs(0.0f, 0.001));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculates the proportion of red in a list of pixels.\n *\n * Each pixel is represented as a tuple of (R, G, B).\n *\n * @param pixels A list of pixels, where each pixel is represented as a tuple of (R, G, B).\n *               This is a constant reference to a vector of tuples.\n * @return The proportion of red in the list of pixels, as a value between 0 and 1.\n */\nfloat calculate_red_proportion(const std::vector<std::tuple<int, int, int>>& pixels) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Analyze a list of pixels, each represented by RGB, and calculate the proportion of red in the list.\n *\n * @param pixels A list of pixels, where each pixel is represented as an array of [R, G, B].\n * @return The proportion of red in the list of pixels, as a value between 0 and 1.\n */\npublic static double calculateRedProportion(List<int[]> pixels) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.real.temp.Answer;\n/**\n * Test class for the calculateRedProportion method.\n */\npublic class Tester {\n\n    /**\n     * Test case for all fully red pixels.\n     */\n    @Test\n    public void testAllRedPixels() {\n        List<int[]> pixels = Arrays.asList(\n                new int[]{255, 0, 0},\n                new int[]{255, 0, 0},\n                new int[]{255, 0, 0}\n        );\n        double result = Answer.calculateRedProportion(pixels);\n        assertEquals(1.0, result, 0.001);\n    }\n\n    /**\n     * Test case for no red component in any pixel.\n     */\n    @Test\n    public void testNoRedPixels() {\n        List<int[]> pixels = Arrays.asList(\n                new int[]{0, 255, 0},\n                new int[]{0, 0, 255},\n                new int[]{0, 255, 255}\n        );\n        double result = Answer.calculateRedProportion(pixels);\n        assertEquals(0.0, result, 0.001);\n    }\n\n    /**\n     * Test case for an empty list of pixels.\n     */\n    @Test\n    public void testEmptyPixelList() {\n        List<int[]> pixels = new ArrayList<>();\n        double result = Answer.calculateRedProportion(pixels);\n        assertEquals(0.0, result, 0.001);\n    }\n\n    /**\n     * Test case for all black pixels.\n     */\n    @Test\n    public void testAllBlackPixels() {\n        List<int[]> pixels = Arrays.asList(\n                new int[]{0, 0, 0},\n                new int[]{0, 0, 0},\n                new int[]{0, 0, 0}\n        );\n        double result = Answer.calculateRedProportion(pixels);\n        assertEquals(0.0, result, 0.001);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Analyze a list of pixels, each represented by RGB, and calculate the proportion of red in the list.\n *\n * @param pixels A list of pixels, where each pixel is represented as an array of [R, G, B].\n * @return The proportion of red in the list of pixels, as a value between 0 and 1.\n */\npublic static double calculateRedProportion(List<int[]> pixels) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 33, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "convert the XML file into a pandas DataFrame, where each <sequence>tag is treated as a row record in the XML, and the tag and text content of each sub-element are treated as columns and data of the DataFrame\n", "language_version_list": {"python": {"code_signature": "import pandas as pd\n\n\ndef parse_xml_to_dataframe(xml_file: str) -> pd.DataFrame:\n    \"\"\"\n    Convert the XML file into a pandas DataFrame, where each <sequence> tag is treated as a row record in the XML,\n    and the tag and text content of each sub-element are treated as columns of the DataFrame.\n\n    Args:\n        xml_file (str): Path to the XML file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the data extracted from the XML file.\n    \"\"\"\n", "test_code": "import unittest\nimport pandas as pd\nfrom io import StringIO\nimport xml.etree.ElementTree as ET\n\nclass TestXmlToDataFrame(unittest.TestCase):\n    def test_single_sequence(self):\n        xml_data = \"\"\"<root>\n                        <sequence>\n                            <name>John</name>\n                            <age>30</age>\n                        </sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = parse_xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{'name': 'John', 'age': '30'}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_multiple_sequences(self):\n        xml_data = \"\"\"<root>\n                        <sequence>\n                            <name>Alice</name>\n                            <age>25</age>\n                        </sequence>\n                        <sequence>\n                            <name>Bob</name>\n                            <age>22</age>\n                        </sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = parse_xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{'name': 'Alice', 'age': '25'}, {'name': 'Bob', 'age': '22'}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_empty_sequence(self):\n        xml_data = \"\"\"<root>\n                        <sequence></sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = parse_xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_mixed_content(self):\n        xml_data = \"\"\"<root>\n                        <sequence>\n                            <name>Chris</name>\n                        </sequence>\n                        <sequence>\n                            <age>28</age>\n                        </sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = parse_xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{'name': 'Chris', 'age': None}, {'name': None, 'age': '28'}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_no_sequences(self):\n        xml_data = \"\"\"<root></root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = parse_xml_to_dataframe(xml_input)\n        expected = pd.DataFrame()\n        pd.testing.assert_frame_equal(df, expected)\n", "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef parse_xml_to_dataframe(xml_file: str) -> pd.DataFrame:\n    \"\"\"\n    Convert the XML file into a pandas DataFrame, where each <sequence> tag is treated as a row record in the XML,\n    and the tag and text content of each sub-element are treated as columns of the DataFrame.\n\n    Args:\n        xml_file (str): Path to the XML file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the data extracted from the XML file.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 35, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "calculates whether a point lies within a defined polygon with a series of points\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef is_point_in_polygon(point: tuple, polygon: List[tuple]) -> bool:\n    \"\"\"\n    Determine if the point (x, y) is inside the given polygon.\n    The polygon is defined as a list of tuples (x, y) representing the vertices.\n\n    Args:\n    point: A tuple (x, y) representing the point to check.\n    polygon: A list of tuples (x, y) representing the vertices of the polygon.\n\n    Returns:\n    bool: True if the point is inside the polygon, False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestPointInPolygon(unittest.TestCase):\n    def setUp(self):\n        # Define some polygons to use in tests\n        self.square = [(0, 0), (0, 10), (10, 10), (10, 0)]\n        self.triangle = [(0, 0), (5, 10), (10, 0)]\n        self.concave = [(0, 0), (5, 5), (10, 0), (5, 10), (0, 10)]\n\n    def test_point_inside_square(self):\n        # Point inside the square\n        self.assertTrue(is_point_in_polygon((5, 5), self.square))\n\n    def test_point_outside_square(self):\n        # Point outside the square\n        self.assertFalse(is_point_in_polygon((15, 5), self.square))\n\n    def test_point_on_edge_of_triangle(self):\n        # Point on the edge of the triangle\n        self.assertFalse(is_point_in_polygon((5, 0), self.triangle))\n\n    def test_point_inside_concave_polygon(self):\n        # Point inside concave polygon\n        self.assertTrue(is_point_in_polygon((5, 9), self.concave))\n\n    def test_point_outside_concave_polygon(self):\n        # Point outside concave polygon\n        self.assertFalse(is_point_in_polygon((5, 1), self.concave))", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef is_point_in_polygon(point: tuple, polygon: List[tuple]) -> bool:\n    \"\"\"\n    Determine if the point (x, y) is inside the given polygon.\n    The polygon is defined as a list of tuples (x, y) representing the vertices.\n\n    Args:\n    point: A tuple (x, y) representing the point to check.\n    polygon: A list of tuples (x, y) representing the vertices of the polygon.\n\n    Returns:\n    bool: True if the point is inside the polygon, False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Determine if the point (x, y) is inside the given polygon.\n * The polygon is defined as an array of tuples [x, y] representing the vertices.\n *\n * @param {Array} point - An array [x, y] representing the point to check.\n * @param {Array} polygon - An array of arrays [x, y] representing the vertices of the polygon.\n * @returns {boolean} - True if the point is inside the polygon, False otherwise.\n */\nfunction isPointInPolygon(point, polygon) {}", "test_code": "describe('TestPointInPolygon', () => {\n    let square = [[0, 0], [0, 10], [10, 10], [10, 0]];\n    let triangle = [[0, 0], [5, 10], [10, 0]];\n    let concave = [[0, 0], [5, 5], [10, 0], [5, 10], [0, 10]];\n\n    it('should determine if a point is inside the square', () => {\n        // Point inside the square\n        expect(isPointInPolygon([5, 5], square)).toBe(true);\n    });\n\n    it('should determine if a point is outside the square', () => {\n        // Point outside the square\n        expect(isPointInPolygon([15, 5], square)).toBe(false);\n    });\n\n    it('should determine if a point is on the edge of the triangle', () => {\n        // Point on the edge of the triangle\n        expect(isPointInPolygon([5, 0], triangle)).toBe(false);\n    });\n\n    it('should determine if a point is inside a concave polygon', () => {\n        // Point inside concave polygon\n        expect(isPointInPolygon([5, 9], concave)).toBe(true);\n    });\n\n    it('should determine if a point is outside a concave polygon', () => {\n        // Point outside concave polygon\n        expect(isPointInPolygon([5, 1], concave)).toBe(false);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Determine if the point (x, y) is inside the given polygon.\n * The polygon is defined as an array of tuples [x, y] representing the vertices.\n *\n * @param {Array} point - An array [x, y] representing the point to check.\n * @param {Array} polygon - An array of arrays [x, y] representing the vertices of the polygon.\n * @returns {boolean} - True if the point is inside the polygon, False otherwise.\n */\nfunction isPointInPolygon(point, polygon) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Determine if the point (x, y) is inside the given polygon.\n * The polygon is defined as an array of tuples (x, y) representing the vertices.\n *\n * @param point - A tuple (x, y) representing the point to check.\n * @param polygon - An array of tuples (x, y) representing the vertices of the polygon.\n * @returns {boolean} True if the point is inside the polygon, False otherwise.\n */\nfunction isPointInPolygon(point: [number, number], polygon: [number, number][]): boolean {}", "test_code": "describe('TestPointInPolygon', () => {\n    let square: [number, number][];\n    let triangle: [number, number][];\n    let concave: [number, number][];\n\n    beforeEach(() => {\n        // Define some polygons to use in tests\n        square = [[0, 0], [0, 10], [10, 10], [10, 0]];\n        triangle = [[0, 0], [5, 10], [10, 0]];\n        concave = [[0, 0], [5, 5], [10, 0], [5, 10], [0, 10]];\n    });\n\n    it('should detect a point inside the square', () => {\n        // Point inside the square\n        expect(isPointInPolygon([5, 5], square)).toBe(true);\n    });\n\n    it('should detect a point outside the square', () => {\n        // Point outside the square\n        expect(isPointInPolygon([15, 5], square)).toBe(false);\n    });\n\n    it('should detect a point on the edge of the triangle', () => {\n        // Point on the edge of the triangle\n        expect(isPointInPolygon([5, 0], triangle)).toBe(false);\n    });\n\n    it('should detect a point inside the concave polygon', () => {\n        // Point inside concave polygon\n        expect(isPointInPolygon([5, 9], concave)).toBe(true);\n    });\n\n    it('should detect a point outside the concave polygon', () => {\n        // Point outside concave polygon\n        expect(isPointInPolygon([5, 1], concave)).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Determine if the point (x, y) is inside the given polygon.\n * The polygon is defined as an array of tuples (x, y) representing the vertices.\n *\n * @param point - A tuple (x, y) representing the point to check.\n * @param polygon - An array of tuples (x, y) representing the vertices of the polygon.\n * @returns {boolean} True if the point is inside the polygon, False otherwise.\n */\nfunction isPointInPolygon(point: [number, number], polygon: [number, number][]): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Determines if a point (x, y) is inside a given polygon.\n *\n * The polygon is defined as a vector of pairs (x, y) representing the vertices.\n *\n * @param point A pair (x, y) representing the point to check.\n * @param polygon A vector of pairs (x, y) representing the vertices of the polygon.\n * @return True if the point is inside the polygon, false otherwise.\n */\nbool is_point_in_polygon(const std::pair<double, double>& point, const std::vector<std::pair<double, double>>& polygon) {}\n", "test_code": "TEST_CASE(\"Test point in polygon\", \"[point_in_polygon]\") {\n    // Define some polygons to use in tests\n    std::vector<std::pair<double, double>> square = {{0, 0}, {0, 10}, {10, 10}, {10, 0}};\n    std::vector<std::pair<double, double>> triangle = {{0, 0}, {5, 10}, {10, 0}};\n    std::vector<std::pair<double, double>> concave = {{0, 0}, {5, 5}, {10, 0}, {5, 10}, {0, 10}};\n\n    SECTION(\"Point inside the square\") {\n        REQUIRE(is_point_in_polygon({5, 5}, square));\n    }\n\n    SECTION(\"Point outside the square\") {\n        REQUIRE_FALSE(is_point_in_polygon({15, 5}, square));\n    }\n\n    SECTION(\"Point on the edge of the triangle\") {\n        REQUIRE_FALSE(is_point_in_polygon({5, 0}, triangle));\n    }\n\n    SECTION(\"Point inside concave polygon\") {\n        REQUIRE(is_point_in_polygon({5, 9}, concave));\n    }\n\n    SECTION(\"Point outside concave polygon\") {\n        REQUIRE_FALSE(is_point_in_polygon({5, 1}, concave));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Determines if a point (x, y) is inside a given polygon.\n *\n * The polygon is defined as a vector of pairs (x, y) representing the vertices.\n *\n * @param point A pair (x, y) representing the point to check.\n * @param polygon A vector of pairs (x, y) representing the vertices of the polygon.\n * @return True if the point is inside the polygon, false otherwise.\n */\nbool is_point_in_polygon(const std::pair<double, double>& point, const std::vector<std::pair<double, double>>& polygon) {}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Determines if the point (x, y) is inside the given polygon.\n * The polygon is defined as a list of tuples (x, y) representing the vertices.\n *\n * @param point  A tuple (x, y) representing the point to check.\n * @param polygon A list of tuples (x, y) representing the vertices of the polygon.\n * @return True if the point is inside the polygon, False otherwise.\n */\nstatic class Point {\n    double x;\n    double y;\n\n    Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\npublic static boolean isPointInPolygon(Point point, List<Point> polygon) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Tester {\n\n    private List<Point> square = new ArrayList<>();\n    private List<Point> triangle = new ArrayList<>();\n    private List<Point> concave = new ArrayList<>();\n\n    @Before // Updated annotation for JUnit 5\n    public void setUp() {\n        // Define some polygons to use in test;\n        square.add(new Point(0, 0));\n        square.add(new Point(0, 10));\n        square.add(new Point(10, 10));\n        square.add(new Point(10, 0));\n\n        triangle = new ArrayList<>();\n        triangle.add(new Point(0, 0));\n        triangle.add(new Point(5, 10));\n        triangle.add(new Point(10, 0));\n\n        concave = new ArrayList<>();\n        concave.add(new Point(0, 0));\n        concave.add(new Point(5, 5));\n        concave.add(new Point(10, 0));\n        concave.add(new Point(5, 10));\n        concave.add(new Point(0, 10));\n    }\n\n    @Test\n    public void testPointInsideSquare() {\n        // Point inside the square\n        assertTrue(Answer.isPointInPolygon(new Point(5, 5), square));\n    }\n\n    @Test\n    public void testPointOutsideSquare() {\n        // Point outside the square\n        assertFalse(Answer.isPointInPolygon(new Point(15, 5), square));\n    }\n\n    @Test\n    public void testPointOnEdgeOfTriangle() {\n        // Point on the edge of the triangle\n        assertFalse(Answer.isPointInPolygon(new Point(5, 0), triangle));\n    }\n\n    @Test\n    public void testPointInsideConcavePolygon() {\n        // Point inside concave polygon\n        assertTrue(Answer.isPointInPolygon(new Point(5, 9), concave));\n    }\n\n    @Test\n    public void testPointOutsideConcavePolygon() {\n        // Point outside concave polygon\n        assertFalse(Answer.isPointInPolygon(new Point(5, 1), concave));\n    }\n\n\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Determines if the point (x, y) is inside the given polygon.\n * The polygon is defined as a list of tuples (x, y) representing the vertices.\n *\n * @param point  A tuple (x, y) representing the point to check.\n * @param polygon A list of tuples (x, y) representing the vertices of the polygon.\n * @return True if the point is inside the polygon, False otherwise.\n */\nstatic class Point {\n    double x;\n    double y;\n\n    Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\npublic static boolean isPointInPolygon(Point point, List<Point> polygon) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 36, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Implementing Floyd's algorithm", "language_version_list": {"python": {"code_signature": "from typing import List, Union\n\ndef find_shortest_paths_by_floyd_warshall(adjacency_matrix: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]:\n    \"\"\"\n    Implements Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n    in a graph represented by an adjacency matrix.\n\n    Args:\n        adjacency_matrix (List[List[Union[int, float]]]): The adjacency matrix representing the graph,\n        where adjacency_matrix[i][j] is the weight of the edge from vertex i to vertex j. If there is\n        no edge, the weight should be represented as float('inf').\n\n    Returns:\n        List[List[Union[int, float]]]: The matrix representing the shortest paths between all pairs of vertices.\n        shortest_paths[i][j] will hold the shortest distance from vertex i to vertex j.\n    \"\"\"", "test_code": "import unittest\n\nclass TestFloydWarshallShortestPaths(unittest.TestCase):\n    def test_basic_functionality(self):\n        # Basic test.js case with a simple graph\n        matrix = [\n            [0, 3, float('inf'), 7],\n            [8, 0, 2, float('inf')],\n            [5, float('inf'), 0, 1],\n            [2, float('inf'), float('inf'), 0]\n        ]\n        expected = [\n            [0, 3, 5, 6],\n            [5, 0, 2, 3],\n            [3, 6, 0, 1],\n            [2, 5, 7, 0]\n        ]\n        result = find_shortest_paths_by_floyd_warshall(matrix)\n        self.assertEqual(result, expected, \"Basic functionality test.js failed\")\n\n    def test_single_vertex_graph(self):\n        # Test case with a single vertex graph (1x1 matrix)\n        matrix = [\n            [0]\n        ]\n        expected = [\n            [0]\n        ]\n        result = find_shortest_paths_by_floyd_warshall(matrix)\n        self.assertEqual(result, expected, \"Single vertex graph test.js failed\")\n\n    def test_two_vertices_graph(self):\n        # Test case with two vertices\n        matrix = [\n            [0, 1],\n            [1, 0]\n        ]\n        expected = [\n            [0, 1],\n            [1, 0]\n        ]\n        result = find_shortest_paths_by_floyd_warshall(matrix)\n        self.assertEqual(result, expected, \"Two vertices graph test.js failed\")\n\n    def test_large_infinite_weights(self):\n        # Test case with infinite weights\n        matrix = [\n            [0, float('inf')],\n            [float('inf'), 0]\n        ]\n        expected = [\n            [0, float('inf')],\n            [float('inf'), 0]\n        ]\n        result = find_shortest_paths_by_floyd_warshall(matrix)\n        self.assertEqual(result, expected, \"Large infinite weights test.js failed\")\n\n    def test_negative_cycle(self):\n        # Test case with a negative cycle\n        matrix = [\n            [0, 1, float('inf')],\n            [float('inf'), 0, -1],\n            [-1, float('inf'), 0]\n        ]\n        expected = [\n            [-1, 0, -1],\n            [-2, -1, -2],\n            [-2, -1, -2]\n        ]\n        result = find_shortest_paths_by_floyd_warshall(matrix)\n        self.assertEqual(result, expected, \"Negative cycle test.js failed\")\n\n\n", "prompt": "please write a python function , the function signature as below from typing import List, Union\n\ndef find_shortest_paths_by_floyd_warshall(adjacency_matrix: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]:\n    \"\"\"\n    Implements Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n    in a graph represented by an adjacency matrix.\n\n    Args:\n        adjacency_matrix (List[List[Union[int, float]]]): The adjacency matrix representing the graph,\n        where adjacency_matrix[i][j] is the weight of the edge from vertex i to vertex j. If there is\n        no edge, the weight should be represented as float('inf').\n\n    Returns:\n        List[List[Union[int, float]]]: The matrix representing the shortest paths between all pairs of vertices.\n        shortest_paths[i][j] will hold the shortest distance from vertex i to vertex j.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Implements Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n * in a graph represented by an adjacency matrix.\n *\n * @param {Array<Array<number>>} adjacencyMatrix - The adjacency matrix representing the graph,\n * where adjacencyMatrix[i][j] is the weight of the edge from vertex i to vertex j. If there is\n * no edge, the weight should be represented as Infinity.\n *\n * @returns {Array<Array<number>>} - The matrix representing the shortest paths between all pairs of vertices.\n * shortestPaths[i][j] will hold the shortest distance from vertex i to vertex j.\n */\nfunction floydWarshallShortestPaths(adjacencyMatrix) {}", "test_code": "describe('TestFloydWarshallShortestPaths', () => {\n    it('should handle basic functionality with a simple graph', () => {\n        const matrix = [\n            [0, 3, Infinity, 7],\n            [8, 0, 2, Infinity],\n            [5, Infinity, 0, 1],\n            [2, Infinity, Infinity, 0]\n        ];\n        const expected = [\n            [0, 3, 5, 6],\n            [5, 0, 2, 3],\n            [3, 6, 0, 1],\n            [2, 5, 7, 0]\n        ];\n        const result = floydWarshallShortestPaths(matrix);\n        expect(result).toEqual(expected);\n    });\n\n    it('should handle a single vertex graph (1x1 matrix)', () => {\n        const matrix = [\n            [0]\n        ];\n        const expected = [\n            [0]\n        ];\n        const result = floydWarshallShortestPaths(matrix);\n        expect(result).toEqual(expected);\n    });\n\n    it('should handle a two vertices graph', () => {\n        const matrix = [\n            [0, 1],\n            [1, 0]\n        ];\n        const expected = [\n            [0, 1],\n            [1, 0]\n        ];\n        const result = floydWarshallShortestPaths(matrix);\n        expect(result).toEqual(expected);\n    });\n\n    it('should handle large infinite weights', () => {\n        const matrix = [\n            [0, Infinity],\n            [Infinity, 0]\n        ];\n        const expected = [\n            [0, Infinity],\n            [Infinity, 0]\n        ];\n        const result = floydWarshallShortestPaths(matrix);\n        expect(result).toEqual(expected);\n    });\n\n    it('should handle a negative cycle', () => {\n        const matrix = [\n            [0, 1, Infinity],\n            [Infinity, 0, -1],\n            [-1, Infinity, 0]\n        ];\n        const expected = [\n            [-1, 0, -1],\n            [-2, -1, -2],\n            [-2, -1, -2]\n        ];\n        const result = floydWarshallShortestPaths(matrix);\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Implements Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n * in a graph represented by an adjacency matrix.\n *\n * @param {Array<Array<number>>} adjacencyMatrix - The adjacency matrix representing the graph,\n * where adjacencyMatrix[i][j] is the weight of the edge from vertex i to vertex j. If there is\n * no edge, the weight should be represented as Infinity.\n *\n * @returns {Array<Array<number>>} - The matrix representing the shortest paths between all pairs of vertices.\n * shortestPaths[i][j] will hold the shortest distance from vertex i to vertex j.\n */\nfunction floydWarshallShortestPaths(adjacencyMatrix) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Implements the Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n * in a graph represented by an adjacency matrix.\n *\n * @param adjacencyMatrix - The adjacency matrix representing the graph,\n * where adjacencyMatrix[i][j] is the weight of the edge from vertex i to vertex j. If there is\n * no edge, the weight should be represented as Infinity.\n * @returns The matrix representing the shortest paths between all pairs of vertices.\n * shortestPaths[i][j] will hold the shortest distance from vertex i to vertex j.\n */\nfunction floydWarshallShortestPaths(adjacencyMatrix: number[][]): number[][] {}", "test_code": "describe('TestFloydWarshallShortestPaths', () => {\n    it('test basic functionality', () => {\n        // Basic test case with a simple graph\n        const matrix = [\n            [0, 3, Infinity, 7],\n            [8, 0, 2, Infinity],\n            [5, Infinity, 0, 1],\n            [2, Infinity, Infinity, 0]\n        ];\n        const expected = [\n            [0, 3, 5, 6],\n            [5, 0, 2, 3],\n            [3, 6, 0, 1],\n            [2, 5, 7, 0]\n        ];\n        const result = floydWarshallShortestPaths(matrix);\n        expect(result).toEqual(expected);\n    });\n\n    it('test single vertex graph', () => {\n        // Test case with a single vertex graph (1x1 matrix)\n        const matrix = [\n            [0]\n        ];\n        const expected = [\n            [0]\n        ];\n        const result = floydWarshallShortestPaths(matrix);\n        expect(result).toEqual(expected);\n    });\n\n    it('test two vertices graph', () => {\n        // Test case with two vertices\n        const matrix = [\n            [0, 1],\n            [1, 0]\n        ];\n        const expected = [\n            [0, 1],\n            [1, 0]\n        ];\n        const result = floydWarshallShortestPaths(matrix);\n        expect(result).toEqual(expected);\n    });\n\n    it('test large infinite weights', () => {\n        // Test case with infinite weights\n        const matrix = [\n            [0, Infinity],\n            [Infinity, 0]\n        ];\n        const expected = [\n            [0, Infinity],\n            [Infinity, 0]\n        ];\n        const result = floydWarshallShortestPaths(matrix);\n        expect(result).toEqual(expected);\n    });\n\n    it('test negative cycle', () => {\n        // Test case with a negative cycle\n        const matrix = [\n            [0, 1, Infinity],\n            [Infinity, 0, -1],\n            [-1, Infinity, 0]\n        ];\n        const expected = [\n            [-1, 0, -1],\n            [-2, -1, -2],\n            [-2, -1, -2]\n        ];\n        const result = floydWarshallShortestPaths(matrix);\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Implements the Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n * in a graph represented by an adjacency matrix.\n *\n * @param adjacencyMatrix - The adjacency matrix representing the graph,\n * where adjacencyMatrix[i][j] is the weight of the edge from vertex i to vertex j. If there is\n * no edge, the weight should be represented as Infinity.\n * @returns The matrix representing the shortest paths between all pairs of vertices.\n * shortestPaths[i][j] will hold the shortest distance from vertex i to vertex j.\n */\nfunction floydWarshallShortestPaths(adjacencyMatrix: number[][]): number[][] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Implements the Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n * in a graph represented by an adjacency matrix.\n *\n * @param adjacency_matrix A 2D vector representing the graph, where adjacency_matrix[i][j] is the weight\n *                         of the edge from vertex i to vertex j. If there is no edge, the weight should\n *                         be represented as INT_MAX.\n * @return A 2D vector representing the shortest paths between all pairs of vertices. shortest_paths[i][j]\n *         will hold the shortest distance from vertex i to vertex j.\n */\nstd::vector<std::vector<int>> floyd_warshall_shortest_paths(const std::vector<std::vector<int>>& adjacency_matrix) {}", "test_code": "TEST_CASE(\"Test Floyd-Warshall Shortest Paths\", \"[floyd-warshall]\") {\n    SECTION(\"Basic functionality\") {\n        // Basic test case with a simple graph\n        std::vector<std::vector<int>> matrix = {\n            {0, 3, INT_MAX, 7},\n            {8, 0, 2, INT_MAX},\n            {5, INT_MAX, 0, 1},\n            {2, INT_MAX, INT_MAX, 0}\n        };\n        std::vector<std::vector<int>> expected = {\n            {0, 3, 5, 6},\n            {5, 0, 2, 3},\n            {3, 6, 0, 1},\n            {2, 5, 7, 0}\n        };\n        auto result = floyd_warshall_shortest_paths(matrix);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Single vertex graph\") {\n        // Test case with a single vertex graph (1x1 matrix)\n        std::vector<std::vector<int>> matrix = {\n            {0}\n        };\n        std::vector<std::vector<int>> expected = {\n            {0}\n        };\n        auto result = floyd_warshall_shortest_paths(matrix);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Two vertices graph\") {\n        // Test case with two vertices\n        std::vector<std::vector<int>> matrix = {\n            {0, 1},\n            {1, 0}\n        };\n        std::vector<std::vector<int>> expected = {\n            {0, 1},\n            {1, 0}\n        };\n        auto result = floyd_warshall_shortest_paths(matrix);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Large infinite weights\") {\n        // Test case with infinite weights\n        std::vector<std::vector<int>> matrix = {\n            {0, INT_MAX},\n            {INT_MAX, 0}\n        };\n        std::vector<std::vector<int>> expected = {\n            {0, INT_MAX},\n            {INT_MAX, 0}\n        };\n        auto result = floyd_warshall_shortest_paths(matrix);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Negative cycle\") {\n        // Test case with a negative cycle\n        std::vector<std::vector<int>> matrix = {\n            {0, 1, INT_MAX},\n            {INT_MAX, 0, -1},\n            {-1, INT_MAX, 0}\n        };\n        std::vector<std::vector<int>> expected = {\n            {-1, 0, -1},\n            {-2, -1, -2},\n            {-2, -1, -2}\n        };\n        auto result = floyd_warshall_shortest_paths(matrix);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Implements the Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n * in a graph represented by an adjacency matrix.\n *\n * @param adjacency_matrix A 2D vector representing the graph, where adjacency_matrix[i][j] is the weight\n *                         of the edge from vertex i to vertex j. If there is no edge, the weight should\n *                         be represented as INT_MAX.\n * @return A 2D vector representing the shortest paths between all pairs of vertices. shortest_paths[i][j]\n *         will hold the shortest distance from vertex i to vertex j.\n */\nstd::vector<std::vector<int>> floyd_warshall_shortest_paths(const std::vector<std::vector<int>>& adjacency_matrix) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Implements the Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n * in a graph represented by an adjacency matrix.\n *\n * @param adjacencyMatrix The adjacency matrix representing the graph,\n *                        where adjacencyMatrix[i][j] is the weight of the edge from vertex i to vertex j.\n *                        If there is no edge, the weight should be represented as Double.POSITIVE_INFINITY.\n * @return The matrix representing the shortest paths between all pairs of vertices.\n *         shortestPaths[i][j] will hold the shortest distance from vertex i to vertex j.\n */\npublic static List<List<Double>> floydWarshallShortestPaths(List<List<Double>> adjacencyMatrix) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testBasicFunctionality() {\n        // Basic test case with a simple graph\n        List<List<Double>> matrix = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0, 3.0, Double.POSITIVE_INFINITY, 7.0)),\n            new ArrayList<>(Arrays.asList(8.0, 0.0, 2.0, Double.POSITIVE_INFINITY)),\n            new ArrayList<>(Arrays.asList(5.0, Double.POSITIVE_INFINITY, 0.0, 1.0)),\n            new ArrayList<>(Arrays.asList(2.0, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 0.0))\n        ));\n        List<List<Double>> expected = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0, 3.0, 5.0, 6.0)),\n            new ArrayList<>(Arrays.asList(5.0, 0.0, 2.0, 3.0)),\n            new ArrayList<>(Arrays.asList(3.0, 6.0, 0.0, 1.0)),\n            new ArrayList<>(Arrays.asList(2.0, 5.0, 7.0, 0.0))\n        ));\n        List<List<Double>> result = Answer.floydWarshallShortestPaths(matrix);\n        assertEquals(\"Basic functionality test failed\",expected, result);\n    }\n\n    @Test\n    public void testSingleVertexGraph() {\n        // Test case with a single vertex graph (1x1 matrix)\n        List<List<Double>> matrix = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0))\n        ));\n        List<List<Double>> expected = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0))\n        ));\n        List<List<Double>> result = Answer.floydWarshallShortestPaths(matrix);\n        assertEquals(\"Single vertex graph test failed\",expected, result);\n    }\n\n    @Test\n    public void testTwoVerticesGraph() {\n        // Test case with two vertices\n        List<List<Double>> matrix = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0, 1.0)),\n            new ArrayList<>(Arrays.asList(1.0, 0.0))\n        ));\n        List<List<Double>> expected = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0, 1.0)),\n            new ArrayList<>(Arrays.asList(1.0, 0.0))\n        ));\n        List<List<Double>> result = Answer.floydWarshallShortestPaths(matrix);\n        assertEquals(\"Two vertices graph test failed\",expected, result);\n    }\n\n    @Test\n    public void testLargeInfiniteWeights() {\n        // Test case with infinite weights\n        List<List<Double>> matrix = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0, Double.POSITIVE_INFINITY)),\n            new ArrayList<>(Arrays.asList(Double.POSITIVE_INFINITY, 0.0))\n        ));\n        List<List<Double>> expected = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0, Double.POSITIVE_INFINITY)),\n            new ArrayList<>(Arrays.asList(Double.POSITIVE_INFINITY, 0.0))\n        ));\n        List<List<Double>> result = Answer.floydWarshallShortestPaths(matrix);\n        assertEquals(\"Large infinite weights test failed\", expected, result );\n    }\n\n    @Test\n    public void testNegativeCycle() {\n        // Test case with a negative cycle\n        List<List<Double>> matrix = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(0.0, 1.0, Double.POSITIVE_INFINITY)),\n            new ArrayList<>(Arrays.asList(Double.POSITIVE_INFINITY, 0.0, -1.0)),\n            new ArrayList<>(Arrays.asList(-1.0, Double.POSITIVE_INFINITY, 0.0))\n        ));\n        List<List<Double>> expected = new ArrayList<>(Arrays.asList(\n            new ArrayList<>(Arrays.asList(-1.0, 0.0, -1.0)),\n            new ArrayList<>(Arrays.asList(-2.0, -1.0, -2.0)),\n            new ArrayList<>(Arrays.asList(-2.0, -1.0, -2.0))\n        ));\n        List<List<Double>> result = Answer.floydWarshallShortestPaths(matrix);\n        assertEquals(\"Negative cycle test failed\",expected, result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Implements the Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n * in a graph represented by an adjacency matrix.\n *\n * @param adjacencyMatrix The adjacency matrix representing the graph,\n *                        where adjacencyMatrix[i][j] is the weight of the edge from vertex i to vertex j.\n *                        If there is no edge, the weight should be represented as Double.POSITIVE_INFINITY.\n * @return The matrix representing the shortest paths between all pairs of vertices.\n *         shortestPaths[i][j] will hold the shortest distance from vertex i to vertex j.\n */\npublic static List<List<Double>> floydWarshallShortestPaths(List<List<Double>> adjacencyMatrix) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 37, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\nimport numpy as np\n\n\nclass QuadratureRule:\n    def __init__(self, x: np.ndarray, w: np.ndarray):\n        self.x = x\n        self.w = w\n\n\ndef lanczos(n: int, quadrature_rule: QuadratureRule) -> Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n    implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials\n    Args:\n        n (int): the number of orthogonal polynomials to generate\n        quadrature_rule (QuadratureRule): An object containing x (nodes) and w (weights) for the quadrature.\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass QuadratureRule:\n    def __init__(self, x, w):\n        self.x = np.array(x)\n        self.w = np.array(w)\n\n\nclass TestOrthogonalPolynomial(unittest.TestCase):\n    def test_lanczos_basic(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.333, 0.333, 0.334]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 2\n        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)\n\n        self.assertEqual(len(alpha), n)\n        self.assertEqual(len(beta), n - 1)\n        self.assertEqual(len(gamma), n)\n\n    def test_lanczos_n_greater_than_length(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.333, 0.333, 0.334]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 4\n\n        with self.assertRaises(ValueError):\n            lanczos(n, quadrature_rule)\n\n    def test_lanczos_n_zero(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.333, 0.333, 0.334]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 0\n\n        with self.assertRaises(ValueError):\n            lanczos(n, quadrature_rule)\n\n    def test_lanczos_weights_nonuniform(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.1, 0.4, 0.5]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 3\n        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)\n\n        self.assertEqual(len(alpha), n)\n        self.assertEqual(len(beta), n - 1)\n        self.assertEqual(len(gamma), n)\n        self.assertTrue(np.all(gamma > 0))\n\n    def test_lanczos_single_node(self):\n        x = [0.5]\n        w = [1.0]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 1\n        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)\n\n        self.assertEqual(len(alpha), n)\n        self.assertEqual(len(beta), n - 1)\n        self.assertEqual(len(gamma), n)\n        self.assertTrue(np.all(gamma > 0))", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\nimport numpy as np\n\n\nclass QuadratureRule:\n    def __init__(self, x: np.ndarray, w: np.ndarray):\n        self.x = x\n        self.w = w\n\n\ndef lanczos(n: int, quadrature_rule: QuadratureRule) -> Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n    implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials\n    Args:\n        n (int): the number of orthogonal polynomials to generate\n        quadrature_rule (QuadratureRule): An object containing x (nodes) and w (weights) for the quadrature.\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Represents a quadrature rule with nodes and weights.\n */\nclass QuadratureRule {\n    /**\n     * Constructs a QuadratureRule object.\n     * @param {number[]} x - The nodes for the quadrature.\n     * @param {number[]} w - The weights for the quadrature.\n     */\n    constructor(x, w) {\n        this.x = x;\n        this.w = w;\n    }\n}\n\n/**\n * Implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials.\n * @param {number} n - The number of orthogonal polynomials to generate.\n * @param {QuadratureRule} quadratureRule - An object containing x (nodes) and w (weights) for the quadrature.\n * @returns {[number[], number[], number[], QuadratureRule]} - The computed coefficients and the quadrature rule.\n */\nfunction lanczos(n, quadratureRule) {}", "test_code": "class QuadratureRule {\n    constructor(x, w) {\n        this.x = x;\n        this.w = w;\n    }\n}\n\ndescribe('OrthogonalPolynomial Tests', () => {\n    test('lanczos basic', () => {\n        const x = [0.0, 0.5, 1.0];\n        const w = [0.333, 0.333, 0.334];\n        const quadratureRule = new QuadratureRule(x, w);\n        const n = 2;\n        const { alpha, beta, gamma } = lanczos(n, quadratureRule);\n\n        expect(alpha.length).toBe(n);\n        expect(beta.length).toBe(n - 1);\n        expect(gamma.length).toBe(n);\n    });\n\n    test('lanczos n greater than length', () => {\n        const x = [0.0, 0.5, 1.0];\n        const w = [0.333, 0.333, 0.334];\n        const quadratureRule = new QuadratureRule(x, w);\n        const n = 4;\n\n        expect(() => lanczos(n, quadratureRule)).toThrow('n must be between 1 and len(x).');\n    });\n\n    test('lanczos n zero', () => {\n        const x = [0.0, 0.5, 1.0];\n        const w = [0.333, 0.333, 0.334];\n        const quadratureRule = new QuadratureRule(x, w);\n        const n = 0;\n\n        expect(() => lanczos(n, quadratureRule)).toThrow('n must be between 1 and len(x).');\n    });\n\n    test('lanczos weights nonuniform', () => {\n        const x = [0.0, 0.5, 1.0];\n        const w = [0.1, 0.4, 0.5];\n        const quadratureRule = new QuadratureRule(x, w);\n        const n = 3;\n        const { alpha, beta, gamma } = lanczos(n, quadratureRule);\n\n        expect(alpha.length).toBe(n);\n        expect(beta.length).toBe(n - 1);\n        expect(gamma.length).toBe(n);\n        expect(gamma.every(g => g > 0)).toBe(false);\n    });\n\n    test('lanczos single node', () => {\n        const x = [0.5];\n        const w = [1.0];\n        const quadratureRule = new QuadratureRule(x, w);\n        const n = 1;\n        const { alpha, beta, gamma } = lanczos(n, quadratureRule);\n\n        expect(alpha.length).toBe(n);\n        expect(beta.length).toBe(n - 1);\n        expect(gamma.length).toBe(n);\n        expect(gamma.every(g => g > 0)).toBe(true);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Represents a quadrature rule with nodes and weights.\n */\nclass QuadratureRule {\n    /**\n     * Constructs a QuadratureRule object.\n     * @param {number[]} x - The nodes for the quadrature.\n     * @param {number[]} w - The weights for the quadrature.\n     */\n    constructor(x, w) {\n        this.x = x;\n        this.w = w;\n    }\n}\n\n/**\n * Implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials.\n * @param {number} n - The number of orthogonal polynomials to generate.\n * @param {QuadratureRule} quadratureRule - An object containing x (nodes) and w (weights) for the quadrature.\n * @returns {[number[], number[], number[], QuadratureRule]} - The computed coefficients and the quadrature rule.\n */\nfunction lanczos(n, quadratureRule) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Represents a quadrature rule with nodes and weights.\n */\nclass QuadratureRule {\n    x: number[];\n    w: number[];\n\n    constructor(x: number[], w: number[]) {\n        this.x = x;\n        this.w = w;\n    }\n}\n\n/**\n * Implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials.\n * @param n The number of orthogonal polynomials to generate.\n * @param quadratureRule An object containing x (nodes) and w (weights) for the quadrature.\n * @returns A tuple containing the alpha, beta, gamma coefficients, and the quadrature rule.\n */\nfunction lanczos(n: number, quadratureRule: QuadratureRule): [number[], number[], number[], QuadratureRule] {}", "test_code": "class QuadratureRule {\n    x: number[];\n    w: number[];\n\n    constructor(x: number[], w: number[]) {\n        this.x = x;\n        this.w = w;\n    }\n}\ndescribe('OrthogonalPolynomial', () => {\n\n    test('test_lanczos_basic', () => {\n        const x = [0.0, 0.5, 1.0];\n        const w = [0.333, 0.333, 0.334];\n        const quadratureRule = new QuadratureRule(x, w);\n        const n = 2;\n        const [alpha, beta, gamma] = lanczos(n, quadratureRule);\n\n        expect(alpha.length).toBe(n);\n        expect(beta.length).toBe(n - 1);\n        expect(gamma.length).toBe(n);\n    });\n\n    test('test_lanczos_n_greater_than_length', () => {\n        const x = [0.0, 0.5, 1.0];\n        const w = [0.333, 0.333, 0.334];\n        const quadratureRule = new QuadratureRule(x, w);\n        const n = 4;\n\n        expect(() => lanczos(n, quadratureRule)).toThrowError('n must be between 1 and len(x).');\n    });\n\n    test('test_lanczos_n_zero', () => {\n        const x = [0.0, 0.5, 1.0];\n        const w = [0.333, 0.333, 0.334];\n        const quadratureRule = new QuadratureRule(x, w);\n        const n = 0;\n\n        expect(() => lanczos(n, quadratureRule)).toThrowError('n must be between 1 and len(x).');\n    });\n\n    test('test_lanczos_weights_nonuniform', () => {\n        const x = [0.0, 0.5, 1.0];\n        const w = [0.1, 0.4, 0.5];\n        const quadratureRule = new QuadratureRule(x, w);\n        const n = 3;\n        const [alpha, beta, gamma] = lanczos(n, quadratureRule);\n\n        expect(alpha.length).toBe(n);\n        expect(beta.length).toBe(n - 1);\n        expect(gamma.length).toBe(n);\n        expect(gamma.every(value => value > 0)).toBe(false);\n    });\n\n    test('test_lanczos_single_node', () => {\n        const x = [0.5];\n        const w = [1.0];\n        const quadratureRule = new QuadratureRule(x, w);\n        const n = 1;\n        const [alpha, beta, gamma] = lanczos(n, quadratureRule);\n\n        expect(alpha.length).toBe(n);\n        expect(beta.length).toBe(n - 1);\n        expect(gamma.length).toBe(n);\n        expect(gamma.every(value => value > 0)).toBe(true);\n    });\n\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Represents a quadrature rule with nodes and weights.\n */\nclass QuadratureRule {\n    x: number[];\n    w: number[];\n\n    constructor(x: number[], w: number[]) {\n        this.x = x;\n        this.w = w;\n    }\n}\n\n/**\n * Implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials.\n * @param n The number of orthogonal polynomials to generate.\n * @param quadratureRule An object containing x (nodes) and w (weights) for the quadrature.\n * @returns A tuple containing the alpha, beta, gamma coefficients, and the quadrature rule.\n */\nfunction lanczos(n: number, quadratureRule: QuadratureRule): [number[], number[], number[], QuadratureRule] {}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 41, "code_type": "class", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Implement a bloom filter class with an add method that adds an element to the Bloom filter.Callers can check for the presence of an element directly using the in keyword", "language_version_list": {"python": {"code_signature": "class BloomFilter:\n    \"\"\"\n    Implement a bloom filter class with an add method that adds an element to the Bloom filter.Callers can check for the presence of an element directly using the in keyword\n    \"\"\"\n\n    def __init__(self, size, hash_count):\n        pass\n\n    def add(self, item):\n        # Add an item to the bloom filter\n        pass\n", "test_code": "import unittest\n\n\nclass TestBloomFilter(unittest.TestCase):\n\n    def setUp(self):\n        # Initialize BloomFilter with reasonable size and hash count for testing\n        self.bf = BloomFilter(1000, 5)\n\n    def test_add_and_check_presence(self):\n        # Test that added elements are reported as present\n        test_item = \"hello world\"\n        self.bf.add(test_item)\n        self.assertIn(test_item, self.bf)\n\n    def test_check_absence(self):\n        # Test that an unadded element is not present\n        self.assertNotIn(\"random item\", self.bf)\n\n    def test_false_positives(self):\n        # Adding some elements and check for a false positive\n        items_to_add = [\"item1\", \"item2\", \"item3\"]\n        for item in items_to_add:\n            self.bf.add(item)\n        # Check for an item not added, expecting a very low chance of false positive due to size and hash count\n        self.assertNotIn(\"item4\", self.bf)\n\n    def test_collision_handling(self):\n        # Test how the Bloom filter handles hash collisions by adding similar items\n        self.bf.add(\"item123\")\n        self.bf.add(\"item124\")\n        self.assertIn(\"item123\", self.bf)\n        self.assertIn(\"item124\", self.bf)\n\n    def test_empty_bloom_filter(self):\n        # Ensure that an empty Bloom Filter reports no items\n        self.assertNotIn(\"anything\", self.bf)", "prompt": "please write a python class , the class signature as below class BloomFilter:\n    \"\"\"\n    Implement a bloom filter class with an add method that adds an element to the Bloom filter.Callers can check for the presence of an element directly using the in keyword\n    \"\"\"\n\n    def __init__(self, size, hash_count):\n        pass\n\n    def add(self, item):\n        # Add an item to the bloom filter\n        pass\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Implement a Bloom filter class with an add method that adds an element to the Bloom filter.\n * Callers can check for the presence of an element directly using the `contains` method.\n */\nclass BloomFilter {\n    /**\n     * Constructs a new BloomFilter instance.\n     * @param {number} size - The size of the Bloom filter.\n     * @param {number} hashCount - The number of hash functions to use.\n     */\n    constructor(size, hashCount) {\n        this.size = size;\n        this.hashCount = hashCount;\n        this.bitArray = new Uint8Array(size / 8);\n    }\n\n    /**\n     * Adds an item to the Bloom filter.\n     * @param {string} item - The item to add.\n     */\n    add(item) {\n        // Add an item to the Bloom filter\n        // Implementation details go here\n    }\n\n    /**\n     * Checks if an item is possibly in the Bloom filter.\n     * @param {string} item - The item to check.\n     * @returns {boolean} - True if the item might be in the Bloom filter, false otherwise.\n     */\n    contains(item) {\n        // Check if an item is in the Bloom filter\n        // Implementation details go here\n    }\n}", "test_code": "describe('BloomFilter', () => {\n    let bf;\n\n    beforeEach(() => {\n        // Initialize BloomFilter with reasonable size and hash count for testing\n        bf = new BloomFilter(1000, 5);\n    });\n\n    it('adds elements and reports them as present', () => {\n        // Test that added elements are reported as present\n        const testItem = \"hello world\";\n        bf.add(testItem);\n        expect(bf.contains(testItem)).toBe(true);\n    });\n\n    it('reports unadded elements as absent', () => {\n        // Test that an unadded element is not present\n        expect(bf.contains(\"random item\")).toBe(false);\n    });\n\n    it('checks for false positives', () => {\n        // Adding some elements and check for a false positive\n        const itemsToAdd = [\"item1\", \"item2\", \"item3\"];\n        itemsToAdd.forEach(item => {\n            bf.add(item);\n        });\n        // Check for an item not added, expecting a very low chance of false positive due to size and hash count\n        expect(bf.contains(\"item4\")).toBe(false);\n    });\n\n    it('handles hash collisions correctly', () => {\n        // Test how the Bloom filter handles hash collisions by adding similar items\n        bf.add(\"item123\");\n        bf.add(\"item124\");\n        expect(bf.contains(\"item123\")).toBe(true);\n        expect(bf.contains(\"item124\")).toBe(true);\n    });\n\n    it('reports no items in an empty Bloom Filter', () => {\n        // Ensure that an empty Bloom Filter reports no items\n        expect(bf.contains(\"anything\")).toBe(false);\n    });\n});", "prompt": "please write a javascript class , the class signature as below /**\n * Implement a Bloom filter class with an add method that adds an element to the Bloom filter.\n * Callers can check for the presence of an element directly using the `contains` method.\n */\nclass BloomFilter {\n    /**\n     * Constructs a new BloomFilter instance.\n     * @param {number} size - The size of the Bloom filter.\n     * @param {number} hashCount - The number of hash functions to use.\n     */\n    constructor(size, hashCount) {\n        this.size = size;\n        this.hashCount = hashCount;\n        this.bitArray = new Uint8Array(size / 8);\n    }\n\n    /**\n     * Adds an item to the Bloom filter.\n     * @param {string} item - The item to add.\n     */\n    add(item) {\n        // Add an item to the Bloom filter\n        // Implementation details go here\n    }\n\n    /**\n     * Checks if an item is possibly in the Bloom filter.\n     * @param {string} item - The item to check.\n     * @returns {boolean} - True if the item might be in the Bloom filter, false otherwise.\n     */\n    contains(item) {\n        // Check if an item is in the Bloom filter\n        // Implementation details go here\n    }\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Implements a Bloom filter class with an add method that adds an element to the Bloom filter.\n * Callers can check for the presence of an element directly using the `in` keyword.\n */\nclass BloomFilter {\n    private size: number;\n    private hashCount: number;\n    private bitArray: boolean[];\n  \n    /**\n     * Initializes the Bloom filter with a specified size and number of hash functions.\n     * @param size The size of the bit array.\n     * @param hashCount The number of hash functions to use.\n     */\n    constructor(size: number, hashCount: number) {}\n  \n    /**\n     * Adds an item to the Bloom filter.\n     * @param item The item to add.\n     */\n    add(item: string): void {\n      // Add an item to the Bloom filter\n      // Implementation details go here\n    }\n  \n    /**\n     * Checks if an item is possibly in the Bloom filter.\n     * @param item The item to check.\n     * @returns true if the item might be in the Bloom filter, false otherwise.\n     */\n    contains(item: string): boolean {\n      // Implementation details go here\n    }\n  }", "test_code": "describe('BloomFilter', () => {\n  let bf: BloomFilter;\n\n  beforeEach(() => {\n    // Initialize BloomFilter with reasonable size and hash count for testing\n    bf = new BloomFilter(1000, 5);\n  });\n\n  it('adds elements and checks their presence', () => {\n    // Test that added elements are reported as present\n    const testItem = \"hello world\";\n    bf.add(testItem);\n    expect(bf.contains(testItem)).toBe(true);\n  });\n\n  it('checks absence of unadded elements', () => {\n    // Test that an unadded element is not present\n    expect(bf.contains(\"random item\")).toBe(false);\n  });\n\n  it('checks for false positives', () => {\n    // Adding some elements and check for a false positive\n    const itemsToAdd = [\"item1\", \"item2\", \"item3\"];\n    itemsToAdd.forEach(item => {\n      bf.add(item);\n    });\n    // Check for an item not added, expecting a very low chance of false positive due to size and hash count\n    expect(bf.contains(\"item4\")).toBe(false);\n  });\n\n  it('handles hash collisions with similar items', () => {\n    // Test how the Bloom filter handles hash collisions by adding similar items\n    bf.add(\"item123\");\n    bf.add(\"item124\");\n    expect(bf.contains(\"item123\")).toBe(true);\n    expect(bf.contains(\"item124\")).toBe(true);\n  });\n\n  it('reports no items in an empty Bloom Filter', () => {\n    // Ensure that an empty Bloom Filter reports no items\n    expect(bf.contains(\"anything\")).toBe(false);\n  });\n});", "prompt": "please write a typescript class , the class signature as below /**\n * Implements a Bloom filter class with an add method that adds an element to the Bloom filter.\n * Callers can check for the presence of an element directly using the `in` keyword.\n */\nclass BloomFilter {\n    private size: number;\n    private hashCount: number;\n    private bitArray: boolean[];\n  \n    /**\n     * Initializes the Bloom filter with a specified size and number of hash functions.\n     * @param size The size of the bit array.\n     * @param hashCount The number of hash functions to use.\n     */\n    constructor(size: number, hashCount: number) {}\n  \n    /**\n     * Adds an item to the Bloom filter.\n     * @param item The item to add.\n     */\n    add(item: string): void {\n      // Add an item to the Bloom filter\n      // Implementation details go here\n    }\n  \n    /**\n     * Checks if an item is possibly in the Bloom filter.\n     * @param item The item to check.\n     * @returns true if the item might be in the Bloom filter, false otherwise.\n     */\n    contains(item: string): boolean {\n      // Implementation details go here\n    }\n  }", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Implement a Bloom filter class with an add method that adds an element to the Bloom filter.\n * Callers can check for the presence of an element directly using the in keyword.\n */\nclass BloomFilter {\npublic:\n    /**\n     * Constructor for the BloomFilter class.\n     *\n     * @param size The size of the bit array.\n     * @param hash_count The number of hash functions to use.\n     */\n    BloomFilter(size_t size, size_t hash_count);\n\n    /**\n     * Add an item to the Bloom filter.\n     *\n     * @param item The item to add.\n     */\n    void add(const std::string& item);\n\nprivate:\n    size_t size;          // Size of the bit array\n    size_t hash_count;    // Number of hash functions\n    std::vector<bool> bit_array; // Bit array for the Bloom filter\n};", "test_code": "TEST_CASE(\"Test BloomFilter functionality\", \"[BloomFilter]\") {\n    SECTION(\"Test add and check presence\") {\n        BloomFilter bf(1000, 5);\n        std::string test_item = \"hello world\";\n        bf.add(test_item);\n        REQUIRE(bf.contains(test_item));\n    }\n\n    SECTION(\"Test check absence\") {\n        BloomFilter bf(1000, 5);\n        REQUIRE_FALSE(bf.contains(\"random item\"));\n    }\n\n    SECTION(\"Test false positives\") {\n        BloomFilter bf(1000, 5);\n        std::vector<std::string> items_to_add = {\"item1\", \"item2\", \"item3\"};\n        for (const auto& item : items_to_add) {\n            bf.add(item);\n        }\n        REQUIRE_FALSE(bf.contains(\"item4\"));\n    }\n\n    SECTION(\"Test collision handling\") {\n        BloomFilter bf(1000, 5);\n        bf.add(\"item123\");\n        bf.add(\"item124\");\n        REQUIRE(bf.contains(\"item123\"));\n        REQUIRE(bf.contains(\"item124\"));\n    }\n\n    SECTION(\"Test empty Bloom Filter\") {\n        BloomFilter bf(1000, 5);\n        REQUIRE_FALSE(bf.contains(\"anything\"));\n    }\n}", "prompt": "please write a cpp class , the class signature as below /**\n * Implement a Bloom filter class with an add method that adds an element to the Bloom filter.\n * Callers can check for the presence of an element directly using the in keyword.\n */\nclass BloomFilter {\npublic:\n    /**\n     * Constructor for the BloomFilter class.\n     *\n     * @param size The size of the bit array.\n     * @param hash_count The number of hash functions to use.\n     */\n    BloomFilter(size_t size, size_t hash_count);\n\n    /**\n     * Add an item to the Bloom filter.\n     *\n     * @param item The item to add.\n     */\n    void add(const std::string& item);\n\nprivate:\n    size_t size;          // Size of the bit array\n    size_t hash_count;    // Number of hash functions\n    std::vector<bool> bit_array; // Bit array for the Bloom filter\n};", "addition_info": ""}, "java": {"code_signature": "/**\n * Implements a Bloom filter class with an add method that adds an element to the Bloom filter.\n * Callers can check for the presence of an element directly.\n */\npublic class BloomFilter {\n\n    /**\n     * Constructs a Bloom filter with the specified size and number of hash functions.\n     *\n     * @param size       the size of the Bloom filter\n     * @param hashCount  the number of hash functions to use\n     */\n    public BloomFilter(int size, int hashCount) {\n        // Constructor implementation goes here\n    }\n\n    /**\n     * Adds an item to the Bloom filter.\n     *\n     * @param item the item to add\n     */\n    public void add(String item) {\n        // Add an item to the Bloom filter\n        // Implementation goes here\n    }\n\n    /**\n     * Checks if an item is possibly present in the Bloom filter.\n     *\n     * @param item the item to check\n     * @return true if the item might be present, false otherwise\n     */\n    public boolean contains(String item) {\n        // Check if the item is possibly present in the Bloom filter\n        // Implementation goes here\n    }\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Test class for the BloomFilter implementation.\n */\npublic class Tester {\n\n    private Answer.BloomFilter bf;\n\n    @Before\n    public void setUp() {\n        // Initialize BloomFilter with reasonable size and hash count for testing\n        bf = new Answer.BloomFilter(1000, 5);\n    }\n\n    @Test\n    public void testAddAndCheckPresence() {\n        // Test that added elements are reported as present\n        String testItem = \"hello world\";\n        bf.add(testItem);\n        assertTrue(bf.contains(testItem));\n    }\n\n    @Test\n    public void testCheckAbsence() {\n        // Test that an unadded element is not present\n        assertFalse(bf.contains(\"random item\"));\n    }\n\n    @Test\n    public void testFalsePositives() {\n        // Adding some elements and check for a false positive\n        String[] itemsToAdd = {\"item1\", \"item2\", \"item3\"};\n        for (String item : itemsToAdd) {\n            bf.add(item);\n        }\n        // Check for an item not added, expecting a very low chance of false positive due to size and hash count\n        assertFalse(bf.contains(\"item4\"));\n    }\n\n    @Test\n    public void testCollisionHandling() {\n        // Test how the Bloom filter handles hash collisions by adding similar items\n        bf.add(\"item123\");\n        bf.add(\"item124\");\n        assertTrue(bf.contains(\"item123\"));\n        assertTrue(bf.contains(\"item124\"));\n    }\n\n    @Test\n    public void testEmptyBloomFilter() {\n        // Ensure that an empty Bloom Filter reports no items\n        assertFalse(bf.contains(\"anything\"));\n    }\n}\n", "prompt": "please write a java class , the function signature as below /**\n * Implements a Bloom filter class with an add method that adds an element to the Bloom filter.\n * Callers can check for the presence of an element directly.\n */\npublic class BloomFilter {\n\n    /**\n     * Constructs a Bloom filter with the specified size and number of hash functions.\n     *\n     * @param size       the size of the Bloom filter\n     * @param hashCount  the number of hash functions to use\n     */\n    public BloomFilter(int size, int hashCount) {\n        // Constructor implementation goes here\n    }\n\n    /**\n     * Adds an item to the Bloom filter.\n     *\n     * @param item the item to add\n     */\n    public void add(String item) {\n        // Add an item to the Bloom filter\n        // Implementation goes here\n    }\n\n    /**\n     * Checks if an item is possibly present in the Bloom filter.\n     *\n     * @param item the item to check\n     * @return true if the item might be present, false otherwise\n     */\n    public boolean contains(String item) {\n        // Check if the item is possibly present in the Bloom filter\n        // Implementation goes here\n    }\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 42, "code_type": "method", "original_language": "python", "question_type": "Program input code", "summary": "replace all phones in the string with the string [PHONE_NUM]", "language_version_list": {"python": {"code_signature": "def replace_phone_numbers(text: str):\n    \"\"\"\n    replace all phones(phone formats in many) in the string with the string [PHONE_NUM]\n    For example:\n        input: Call me at 123-456-7890.\n        output: Call me at [PHONE_NUM].\n\n    Args:\n        text (str): The input string that may contain phone numbers.\n\n    Returns:\n        str: The modified string with phone numbers replaced by '[PHONE_NUM]'.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestReplacePhoneNumbers(unittest.TestCase):\n    def test_basic_number(self):\n        msg = \"Call me at 123-456-7890.\"\n        expected = \"Call me at [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n\n    def test_number_with_parentheses(self):\n        msg = \"Our office number is 123 456-7890.\"\n        expected = \"Our office number is [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n    def test_number_with_dots(self):\n        msg = \"Fax us at 123.456.7890.\"\n        expected = \"Fax us at [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n    def test_no_phone_number(self):\n        msg = \"Hello, please reply to this email.\"\n        expected = \"Hello, please reply to this email.\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n", "prompt": "please write a python function , the function signature as below def replace_phone_numbers(text: str):\n    \"\"\"\n    replace all phones(phone formats in many) in the string with the string [PHONE_NUM]\n    For example:\n        input: Call me at 123-456-7890.\n        output: Call me at [PHONE_NUM].\n\n    Args:\n        text (str): The input string that may contain phone numbers.\n\n    Returns:\n        str: The modified string with phone numbers replaced by '[PHONE_NUM]'.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Replaces all phone numbers in the string with the string [PHONE_NUM].\n * For example:\n *   input: \"Call me at 123-456-7890.\"\n *   output: \"Call me at [PHONE_NUM].\"\n *\n * @param {string} text - The input string that may contain phone numbers.\n * @returns {string} The modified string with phone numbers replaced by '[PHONE_NUM]'.\n */\nfunction replacePhoneNumbers(text) {}", "test_code": "describe('replacePhoneNumbers', () => {\n    it('should replace a basic phone number', () => {\n        const msg = \"Call me at 123-456-7890.\";\n        const expected = \"Call me at [PHONE_NUM].\";\n        expect(replacePhoneNumbers(msg)).toBe(expected);\n    });\n\n    it('should replace a phone number with parentheses', () => {\n        const msg = \"Our office number is 123 456-7890.\";\n        const expected = \"Our office number is [PHONE_NUM].\";\n        expect(replacePhoneNumbers(msg)).toBe(expected);\n    });\n\n    it('should replace a phone number with dots', () => {\n        const msg = \"Fax us at 123.456.7890.\";\n        const expected = \"Fax us at [PHONE_NUM].\";\n        expect(replacePhoneNumbers(msg)).toBe(expected);\n    });\n\n    it('should not replace text without a phone number', () => {\n        const msg = \"Hello, please reply to this email.\";\n        const expected = \"Hello, please reply to this email.\";\n        expect(replacePhoneNumbers(msg)).toBe(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Replaces all phone numbers in the string with the string [PHONE_NUM].\n * For example:\n *   input: \"Call me at 123-456-7890.\"\n *   output: \"Call me at [PHONE_NUM].\"\n *\n * @param {string} text - The input string that may contain phone numbers.\n * @returns {string} The modified string with phone numbers replaced by '[PHONE_NUM]'.\n */\nfunction replacePhoneNumbers(text) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Replaces all phone numbers in the given string with the placeholder '[PHONE_NUM]'.\n * \n * Example:\n *   Input: \"Call me at 123-456-7890.\"\n *   Output: \"Call me at [PHONE_NUM].\"\n * \n * @param text - The input string that may contain phone numbers.\n * @returns The modified string with phone numbers replaced by '[PHONE_NUM]'.\n */\nfunction replacePhoneNumbers(text: string): string {}", "test_code": "describe('replacePhoneNumbers', () => {\n    it('should replace a basic phone number', () => {\n        const msg = \"Call me at 123-456-7890.\";\n        const expected = \"Call me at [PHONE_NUM].\";\n        expect(replacePhoneNumbers(msg)).toBe(expected);\n    });\n\n    it('should replace a phone number with parentheses', () => {\n        const msg = \"Our office number is 123 456-7890.\";\n        const expected = \"Our office number is [PHONE_NUM].\";\n        expect(replacePhoneNumbers(msg)).toBe(expected);\n    });\n\n    it('should replace a phone number with dots', () => {\n        const msg = \"Fax us at 123.456.7890.\";\n        const expected = \"Fax us at [PHONE_NUM].\";\n        expect(replacePhoneNumbers(msg)).toBe(expected);\n    });\n\n    it('should not replace text without a phone number', () => {\n        const msg = \"Hello, please reply to this email.\";\n        const expected = \"Hello, please reply to this email.\";\n        expect(replacePhoneNumbers(msg)).toBe(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Replaces all phone numbers in the given string with the placeholder '[PHONE_NUM]'.\n * \n * Example:\n *   Input: \"Call me at 123-456-7890.\"\n *   Output: \"Call me at [PHONE_NUM].\"\n * \n * @param text - The input string that may contain phone numbers.\n * @returns The modified string with phone numbers replaced by '[PHONE_NUM]'.\n */\nfunction replacePhoneNumbers(text: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Replaces all phone numbers in the given string with the string [PHONE_NUM].\n *\n * Example:\n *     Input: \"Call me at 123-456-7890.\"\n *     Output: \"Call me at [PHONE_NUM].\"\n *\n * @param text The input string that may contain phone numbers.\n * @return The modified string with phone numbers replaced by '[PHONE_NUM]'.\n */\nstd::string replace_phone_numbers(const std::string& text) {}", "test_code": "TEST_CASE(\"Test Replace Phone Numbers\") {\n    SECTION(\"Basic Number\") {\n        std::string msg = \"Call me at 123-456-7890.\";\n        std::string expected = \"Call me at [PHONE_NUM].\";\n        REQUIRE(replace_phone_numbers(msg) == expected);\n    }\n\n    SECTION(\"Number with Parentheses\") {\n        std::string msg = \"Our office number is 123 456-7890.\";\n        std::string expected = \"Our office number is [PHONE_NUM].\";\n        REQUIRE(replace_phone_numbers(msg) == expected);\n    }\n\n    SECTION(\"Number with Dots\") {\n        std::string msg = \"Fax us at 123.456.7890.\";\n        std::string expected = \"Fax us at [PHONE_NUM].\";\n        REQUIRE(replace_phone_numbers(msg) == expected);\n    }\n\n    SECTION(\"No Phone Number\") {\n        std::string msg = \"Hello, please reply to this email.\";\n        std::string expected = \"Hello, please reply to this email.\";\n        REQUIRE(replace_phone_numbers(msg) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Replaces all phone numbers in the given string with the string [PHONE_NUM].\n *\n * Example:\n *     Input: \"Call me at 123-456-7890.\"\n *     Output: \"Call me at [PHONE_NUM].\"\n *\n * @param text The input string that may contain phone numbers.\n * @return The modified string with phone numbers replaced by '[PHONE_NUM]'.\n */\nstd::string replace_phone_numbers(const std::string& text) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Replaces all phone numbers in the given string with \"[PHONE_NUM]\".\n * <p>\n * Example usage:\n * <pre>\n *     Input: Call me at 123-456-7890.\n *     Output: Call me at [PHONE_NUM].\n * </pre>\n *\n * @param text The input string that may contain phone numbers.\n * @return The modified string with phone numbers replaced by \"[PHONE_NUM]\".\n */\npublic static String replacePhoneNumbers(String text) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n/**\n * Test cases for the replacePhoneNumbers method.\n */\npublic class Tester {\n\n    /**\n     * Tests replacing a basic phone number.\n     */\n    @Test\n    public void testBasicNumber() {\n        String msg = \"Call me at 123-456-7890.\";\n        String expected = \"Call me at [PHONE_NUM].\";\n        assertEquals(expected, replacePhoneNumbers(msg));\n    }\n\n    /**\n     * Tests replacing a phone number with spaces.\n     */\n    @Test\n    public void testNumberWithSpaces() {\n        String msg = \"Our office number is 123 456-7890.\";\n        String expected = \"Our office number is [PHONE_NUM].\";\n        assertEquals(expected, replacePhoneNumbers(msg));\n    }\n\n    /**\n     * Tests replacing a phone number with dots.\n     */\n    @Test\n    public void testNumberWithDots() {\n        String msg = \"Fax us at 123.456.7890.\";\n        String expected = \"Fax us at [PHONE_NUM].\";\n        assertEquals(expected, replacePhoneNumbers(msg));\n    }\n\n    /**\n     * Tests a message without a phone number.\n     */\n    @Test\n    public void testNoPhoneNumber() {\n        String msg = \"Hello, please reply to this email.\";\n        String expected = \"Hello, please reply to this email.\";\n        assertEquals(expected, replacePhoneNumbers(msg));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Replaces all phone numbers in the given string with \"[PHONE_NUM]\".\n * <p>\n * Example usage:\n * <pre>\n *     Input: Call me at 123-456-7890.\n *     Output: Call me at [PHONE_NUM].\n * </pre>\n *\n * @param text The input string that may contain phone numbers.\n * @return The modified string with phone numbers replaced by \"[PHONE_NUM]\".\n */\npublic static String replacePhoneNumbers(String text) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 43, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Convert RGB color to HSV color\n", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef rgb_to_hsv(r: int, g: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    convert RGB color to HSV color.\n    For example:\n        input: 0, 0, 255\n        output: 240, 100, 100\n    Args:\n        r (int): rgb read value\n        g (int): rgb green value\n        b (int): rgb blue value\n\n    Returns:\n       Tuple[int, int, int]: HSV value\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestRGBtoHSV(unittest.TestCase):\n\n    def test_rgb_to_hsv_red(self):\n        # Test conversion of pure red color\n        r, g, b = 255, 0, 0\n        expected_result = (0, 100, 100)  # Hue should be 0, Saturation 1, Value 1 for red\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_green(self):\n        # Test conversion of pure green color\n        r, g, b = 0, 255, 0\n        expected_result = (120, 100, 100)  # Hue should be 120, Saturation 1, Value 1 for green\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_blue(self):\n        # Test conversion of pure blue color\n        r, g, b = 0, 0, 255\n        expected_result = (240, 100, 100)  # Hue should be 240, Saturation 1, Value 1 for blue\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_white(self):\n        # Test conversion of white color\n        r, g, b = 255, 255, 255\n        expected_result = (0, 0, 100)  # Hue is undefined, typically 0; Saturation 0, Value 1 for white\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_black(self):\n        # Test conversion of black color\n        r, g, b = 0, 0, 0\n        expected_result = (0, 0, 0)  # Hue is undefined, typically 0; Saturation 0, Value 0 for black\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef rgb_to_hsv(r: int, g: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    convert RGB color to HSV color.\n    For example:\n        input: 0, 0, 255\n        output: 240, 100, 100\n    Args:\n        r (int): rgb read value\n        g (int): rgb green value\n        b (int): rgb blue value\n\n    Returns:\n       Tuple[int, int, int]: HSV value\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts RGB color to HSV color.\n * \n * Example:\n *   Input: 0, 0, 255\n *   Output: [240, 100, 100]\n * \n * @param {number} r - The red value (0-255)\n * @param {number} g - The green value (0-255)\n * @param {number} b - The blue value (0-255)\n * \n * @returns {Array<number>} An array representing the HSV values [H, S, V]\n */\nfunction rgbToHsv(r, g, b) {}", "test_code": "describe('Test RGB to HSV Conversion', () => {\n  it('converts pure red color correctly', () => {\n      // Test conversion of pure red color\n      const r = 255;\n      const g = 0;\n      const b = 0;\n      const expectedResult = [0, 100, 100];  // Hue should be 0, Saturation 1, Value 1 for red\n      const result = rgbToHsv(r, g, b);\n      expect(result).toEqual(expectedResult);\n  });\n\n  it('converts pure green color correctly', () => {\n      // Test conversion of pure green color\n      const r = 0;\n      const g = 255;\n      const b = 0;\n      const expectedResult = [120, 100, 100];  // Hue should be 120, Saturation 1, Value 1 for green\n      const result = rgbToHsv(r, g, b);\n      expect(result).toEqual(expectedResult);\n  });\n\n  it('converts pure blue color correctly', () => {\n      // Test conversion of pure blue color\n      const r = 0;\n      const g = 0;\n      const b = 255;\n      const expectedResult = [240, 100, 100];  // Hue should be 240, Saturation 1, Value 1 for blue\n      const result = rgbToHsv(r, g, b);\n      expect(result).toEqual(expectedResult);\n  });\n\n  it('converts white color correctly', () => {\n      // Test conversion of white color\n      const r = 255;\n      const g = 255;\n      const b = 255;\n      const expectedResult = [0, 0, 100];  // Hue is undefined, typically 0; Saturation 0, Value 1 for white\n      const result = rgbToHsv(r, g, b);\n      expect(result).toEqual(expectedResult);\n  });\n\n  it('converts black color correctly', () => {\n      // Test conversion of black color\n      const r = 0;\n      const g = 0;\n      const b = 0;\n      const expectedResult = [0, 0, 0];  // Hue is undefined, typically 0; Saturation 0, Value 0 for black\n      const result = rgbToHsv(r, g, b);\n      expect(result).toEqual(expectedResult);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts RGB color to HSV color.\n * \n * Example:\n *   Input: 0, 0, 255\n *   Output: [240, 100, 100]\n * \n * @param {number} r - The red value (0-255)\n * @param {number} g - The green value (0-255)\n * @param {number} b - The blue value (0-255)\n * \n * @returns {Array<number>} An array representing the HSV values [H, S, V]\n */\nfunction rgbToHsv(r, g, b) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts an RGB color to an HSV color.\n * \n * Example:\n *   Input: 0, 0, 255\n *   Output: [240, 100, 100]\n * \n * @param r - The red value of the RGB color (0-255).\n * @param g - The green value of the RGB color (0-255).\n * @param b - The blue value of the RGB color (0-255).\n * @returns A tuple representing the HSV color values [H, S, V].\n */\nfunction rgbToHsv(r: number, g: number, b: number): [number, number, number] {}", "test_code": "describe('Test RGB to HSV Conversion', () => {\n  it('should convert pure red color correctly', () => {\n      // Test conversion of pure red color\n      const r = 255;\n      const g = 0;\n      const b = 0;\n      const expectedResult: [number, number, number] = [0, 100, 100];  // Hue should be 0, Saturation 100, Value 100 for red\n      const result = rgbToHsv(r, g, b);\n      expect(result).toEqual(expectedResult);\n  });\n\n  it('should convert pure green color correctly', () => {\n      // Test conversion of pure green color\n      const r = 0;\n      const g = 255;\n      const b = 0;\n      const expectedResult: [number, number, number] = [120, 100, 100];  // Hue should be 120, Saturation 100, Value 100 for green\n      const result = rgbToHsv(r, g, b);\n      expect(result).toEqual(expectedResult);\n  });\n\n  it('should convert pure blue color correctly', () => {\n      // Test conversion of pure blue color\n      const r = 0;\n      const g = 0;\n      const b = 255;\n      const expectedResult: [number, number, number] = [240, 100, 100];  // Hue should be 240, Saturation 100, Value 100 for blue\n      const result = rgbToHsv(r, g, b);\n      expect(result).toEqual(expectedResult);\n  });\n\n  it('should convert white color correctly', () => {\n      // Test conversion of white color\n      const r = 255;\n      const g = 255;\n      const b = 255;\n      const expectedResult: [number, number, number] = [0, 0, 100];  // Hue is undefined, typically 0; Saturation 0, Value 100 for white\n      const result = rgbToHsv(r, g, b);\n      expect(result).toEqual(expectedResult);\n  });\n\n  it('should convert black color correctly', () => {\n      // Test conversion of black color\n      const r = 0;\n      const g = 0;\n      const b = 0;\n      const expectedResult: [number, number, number] = [0, 0, 0];  // Hue is undefined, typically 0; Saturation 0, Value 0 for black\n      const result = rgbToHsv(r, g, b);\n      expect(result).toEqual(expectedResult);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts an RGB color to an HSV color.\n * \n * Example:\n *   Input: 0, 0, 255\n *   Output: [240, 100, 100]\n * \n * @param r - The red value of the RGB color (0-255).\n * @param g - The green value of the RGB color (0-255).\n * @param b - The blue value of the RGB color (0-255).\n * @returns A tuple representing the HSV color values [H, S, V].\n */\nfunction rgbToHsv(r: number, g: number, b: number): [number, number, number] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert RGB color to HSV color.\n * \n * Example:\n *     Input: 0, 0, 255\n *     Output: 240, 100, 100\n * \n * @param r The red value of the RGB color.\n * @param g The green value of the RGB color.\n * @param b The blue value of the RGB color.\n * \n * @return A tuple containing the HSV values.\n */\nstd::tuple<double, double, double> rgb_to_hsv(int r, int g, int b) {}", "test_code": "TEST_CASE(\"Test RGB to HSV conversion\") {\n    SECTION(\"Test conversion of pure red color\") {\n        int r = 255, g = 0, b = 0;\n        auto expected_result = std::make_tuple(0.0, 100.0, 100.0);\n        auto result = rgb_to_hsv(r, g, b);\n        REQUIRE(std::get<0>(result) == std::get<0>(expected_result));\n        REQUIRE(std::get<1>(result) == std::get<1>(expected_result));\n        REQUIRE(std::get<2>(result) == std::get<2>(expected_result));\n    }\n\n    SECTION(\"Test conversion of pure green color\") {\n        int r = 0, g = 255, b = 0;\n        auto expected_result = std::make_tuple(120.0, 100.0, 100.0);\n        auto result = rgb_to_hsv(r, g, b);\n        REQUIRE(std::get<0>(result) == std::get<0>(expected_result));\n        REQUIRE(std::get<1>(result) == std::get<1>(expected_result));\n        REQUIRE(std::get<2>(result) == std::get<2>(expected_result));\n    }\n\n    SECTION(\"Test conversion of pure blue color\") {\n        int r = 0, g = 0, b = 255;\n        auto expected_result = std::make_tuple(240.0, 100.0, 100.0);\n        auto result = rgb_to_hsv(r, g, b);\n        REQUIRE(std::get<0>(result) == std::get<0>(expected_result));\n        REQUIRE(std::get<1>(result) == std::get<1>(expected_result));\n        REQUIRE(std::get<2>(result) == std::get<2>(expected_result));\n    }\n\n    SECTION(\"Test conversion of white color\") {\n        int r = 255, g = 255, b = 255;\n        auto expected_result = std::make_tuple(0.0, 0.0, 100.0);\n        auto result = rgb_to_hsv(r, g, b);\n        REQUIRE(std::get<0>(result) == std::get<0>(expected_result));\n        REQUIRE(std::get<1>(result) == std::get<1>(expected_result));\n        REQUIRE(std::get<2>(result) == std::get<2>(expected_result));\n    }\n\n    SECTION(\"Test conversion of black color\") {\n        int r = 0, g = 0, b = 0;\n        auto expected_result = std::make_tuple(0.0, 0.0, 0.0);\n        auto result = rgb_to_hsv(r, g, b);\n        REQUIRE(std::get<0>(result) == std::get<0>(expected_result));\n        REQUIRE(std::get<1>(result) == std::get<1>(expected_result));\n        REQUIRE(std::get<2>(result) == std::get<2>(expected_result));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert RGB color to HSV color.\n * \n * Example:\n *     Input: 0, 0, 255\n *     Output: 240, 100, 100\n * \n * @param r The red value of the RGB color.\n * @param g The green value of the RGB color.\n * @param b The blue value of the RGB color.\n * \n * @return A tuple containing the HSV values.\n */\nstd::tuple<double, double, double> rgb_to_hsv(int r, int g, int b) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts RGB color values to HSV (Hue, Saturation, Value).\n *\n * @param r the red component of the RGB color (0-255)\n * @param g the green component of the RGB color (0-255)\n * @param b the blue component of the RGB color (0-255)\n * @return an array containing the HSV values: [H, S, V]\n */\npublic static double[] rgbToHsv(int r, int g, int b) {}\n", "test_code": "package org.real.temp;\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testRgbToHsvRed() {\n        // Test conversion of pure red color\n        int r = 255, g = 0, b = 0;\n        double[] expectedResult = {0, 100, 100}; // Hue should be 0, Saturation 100%, Value 100%\n        double[] result = rgbToHsv(r, g, b);\n        assertArrayEquals(expectedResult, result, 0.01); // Assert with a delta for floating point comparison\n    }\n\n    @Test\n    public void testRgbToHsvGreen() {\n        // Test conversion of pure green color\n        int r = 0, g = 255, b = 0;\n        double[] expectedResult = {120, 100, 100}; // Hue should be 120, Saturation 100%, Value 100%\n        double[] result = rgbToHsv(r, g, b);\n        assertArrayEquals(expectedResult, result, 0.01); // Assert with a delta for floating point comparison\n    }\n\n    @Test\n    public void testRgbToHsvBlue() {\n        // Test conversion of pure blue color\n        int r = 0, g = 0, b = 255;\n        double[] expectedResult = {240, 100, 100}; // Hue should be 240, Saturation 100%, Value 100%\n        double[] result = rgbToHsv(r, g, b);\n        assertArrayEquals(expectedResult, result, 0.01); // Assert with a delta for floating point comparison\n    }\n\n    @Test\n    public void testRgbToHsvWhite() {\n        // Test conversion of white color\n        int r = 255, g = 255, b = 255;\n        double[] expectedResult = {0, 0, 100}; // Hue is undefined, typically 0; Saturation 0%, Value 100%\n        double[] result = rgbToHsv(r, g, b);\n        assertArrayEquals(expectedResult, result, 0.01); // Assert with a delta for floating point comparison\n    }\n\n    @Test\n    public void testRgbToHsvBlack() {\n        // Test conversion of black color\n        int r = 0, g = 0, b = 0;\n        double[] expectedResult = {0, 0, 0}; // Hue is undefined, typically 0; Saturation 0%, Value 0%\n        double[] result = rgbToHsv(r, g, b);\n        assertArrayEquals(expectedResult, result, 0.01); // Assert with a delta for floating point comparison\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts RGB color values to HSV (Hue, Saturation, Value).\n *\n * @param r the red component of the RGB color (0-255)\n * @param g the green component of the RGB color (0-255)\n * @param b the blue component of the RGB color (0-255)\n * @return an array containing the HSV values: [H, S, V]\n */\npublic static double[] rgbToHsv(int r, int g, int b) {}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 44, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Align two lines of string to the left, supplementing with Spaces if the length is not enough", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef align_lines_left(str1: str, str2: str) -> Tuple[str, str]:\n    \"\"\"\n    Align two lines of string to the left, supplementing with Spaces if the length is not enough\n\n    Args:\n        str1 (str): str1\n        str2 (str): str2\n\n    Returns:\n        Tuple[str,str]: aligned str1 aligned str2\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestAlignLinesLeft(unittest.TestCase):\n\n    def test_equal_length_strings(self):\n        str1 = \"Hello\"\n        str2 = \"World\"\n        expected_str1 = \"Hello\"\n        expected_str2 = \"World\"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_first_string_longer(self):\n        str1 = \"Hello, World!\"\n        str2 = \"Hi\"\n        expected_str1 = \"Hello, World!\"\n        expected_str2 = \"Hi           \"  # 14 spaces after \"Hi\"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_second_string_longer(self):\n        str1 = \"Hey\"\n        str2 = \"Goodbye, friend!\"\n        expected_str1 = \"Hey             \"  # 15 spaces after \"Hey\"\n        expected_str2 = \"Goodbye, friend!\"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_empty_first_string(self):\n        str1 = \"\"\n        str2 = \"World\"\n        expected_str1 = \"     \"  # 5 spaces\n        expected_str2 = \"World\"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_empty_second_string(self):\n        str1 = \"Hello\"\n        str2 = \"\"\n        expected_str1 = \"Hello\"\n        expected_str2 = \"     \"  # 5 spaces\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_both_strings_empty(self):\n        str1 = \"\"\n        str2 = \"\"\n        expected_str1 = \"\"\n        expected_str2 = \"\"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_strings_with_spaces(self):\n        str1 = \"Hello \"\n        str2 = \"World  \"\n        expected_str1 = \"Hello  \"\n        expected_str2 = \"World  \"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef align_lines_left(str1: str, str2: str) -> Tuple[str, str]:\n    \"\"\"\n    Align two lines of string to the left, supplementing with Spaces if the length is not enough\n\n    Args:\n        str1 (str): str1\n        str2 (str): str2\n\n    Returns:\n        Tuple[str,str]: aligned str1 aligned str2\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Align two lines of string to the left, supplementing with spaces if the length is not enough.\n *\n * @param {string} str1 - The first string.\n * @param {string} str2 - The second string.\n * @returns {Array<string>} An array containing the aligned str1 and aligned str2.\n */\nfunction alignLinesLeft(str1, str2) {}", "test_code": "describe('alignLinesLeft', () => {\n  it('aligns equal length strings correctly', () => {\n      const str1 = \"Hello\";\n      const str2 = \"World\";\n      const expected_str1 = \"Hello\";\n      const expected_str2 = \"World\";\n      const [aligned_str1, aligned_str2] = alignLinesLeft(str1, str2);\n      expect(aligned_str1).toBe(expected_str1);\n      expect(aligned_str2).toBe(expected_str2);\n  });\n\n  it('aligns first string longer than second', () => {\n      const str1 = \"Hello, World!\";\n      const str2 = \"Hi\";\n      const expected_str1 = \"Hello, World!\";\n      const expected_str2 = \"Hi           \";  // 14 spaces after \"Hi\"\n      const [aligned_str1, aligned_str2] = alignLinesLeft(str1, str2);\n      expect(aligned_str1).toBe(expected_str1);\n      expect(aligned_str2).toBe(expected_str2);\n  });\n\n  it('aligns second string longer than first', () => {\n      const str1 = \"Hey\";\n      const str2 = \"Goodbye, friend!\";\n      const expected_str1 = \"Hey             \";  // 15 spaces after \"Hey\"\n      const expected_str2 = \"Goodbye, friend!\";\n      const [aligned_str1, aligned_str2] = alignLinesLeft(str1, str2);\n      expect(aligned_str1).toBe(expected_str1);\n      expect(aligned_str2).toBe(expected_str2);\n  });\n\n  it('aligns empty first string', () => {\n      const str1 = \"\";\n      const str2 = \"World\";\n      const expected_str1 = \"     \";  // 5 spaces\n      const expected_str2 = \"World\";\n      const [aligned_str1, aligned_str2] = alignLinesLeft(str1, str2);\n      expect(aligned_str1).toBe(expected_str1);\n      expect(aligned_str2).toBe(expected_str2);\n  });\n\n  it('aligns empty second string', () => {\n      const str1 = \"Hello\";\n      const str2 = \"\";\n      const expected_str1 = \"Hello\";\n      const expected_str2 = \"     \";  // 5 spaces\n      const [aligned_str1, aligned_str2] = alignLinesLeft(str1, str2);\n      expect(aligned_str1).toBe(expected_str1);\n      expect(aligned_str2).toBe(expected_str2);\n  });\n\n  it('aligns both empty strings', () => {\n      const str1 = \"\";\n      const str2 = \"\";\n      const expected_str1 = \"\";\n      const expected_str2 = \"\";\n      const [aligned_str1, aligned_str2] = alignLinesLeft(str1, str2);\n      expect(aligned_str1).toBe(expected_str1);\n      expect(aligned_str2).toBe(expected_str2);\n  });\n\n  it('aligns strings with spaces', () => {\n      const str1 = \"Hello \";\n      const str2 = \"World  \";\n      const expected_str1 = \"Hello  \";\n      const expected_str2 = \"World  \";\n      const [aligned_str1, aligned_str2] = alignLinesLeft(str1, str2);\n      expect(aligned_str1).toBe(expected_str1);\n      expect(aligned_str2).toBe(expected_str2);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Align two lines of string to the left, supplementing with spaces if the length is not enough.\n *\n * @param {string} str1 - The first string.\n * @param {string} str2 - The second string.\n * @returns {Array<string>} An array containing the aligned str1 and aligned str2.\n */\nfunction alignLinesLeft(str1, str2) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Align two lines of string to the left, supplementing with spaces if the length is not enough.\n *\n * @param str1 - The first string.\n * @param str2 - The second string.\n * @returns A tuple containing the aligned versions of str1 and str2.\n */\nfunction alignLinesLeft(str1: string, str2: string): [string, string] {}", "test_code": "describe('alignLinesLeft', () => {\n    it('should align equal length strings correctly', () => {\n      const str1 = \"Hello\";\n      const str2 = \"World\";\n      const expectedStr1 = \"Hello\";\n      const expectedStr2 = \"World\";\n      const [alignedStr1, alignedStr2] = alignLinesLeft(str1, str2);\n      expect(alignedStr1).toBe(expectedStr1);\n      expect(alignedStr2).toBe(expectedStr2);\n    });\n  \n    it('should align when the first string is longer', () => {\n      const str1 = \"Hello, World!\";\n      const str2 = \"Hi\";\n      const expectedStr1 = \"Hello, World!\";\n      const expectedStr2 = \"Hi           \"; // 14 spaces after \"Hi\"\n      const [alignedStr1, alignedStr2] = alignLinesLeft(str1, str2);\n      expect(alignedStr1).toBe(expectedStr1);\n      expect(alignedStr2).toBe(expectedStr2);\n    });\n  \n    it('should align when the second string is longer', () => {\n      const str1 = \"Hey\";\n      const str2 = \"Goodbye, friend!\";\n      const expectedStr1 = \"Hey             \"; // 15 spaces after \"Hey\"\n      const expectedStr2 = \"Goodbye, friend!\";\n      const [alignedStr1, alignedStr2] = alignLinesLeft(str1, str2);\n      expect(alignedStr1).toBe(expectedStr1);\n      expect(alignedStr2).toBe(expectedStr2);\n    });\n  \n    it('should align when the first string is empty', () => {\n      const str1 = \"\";\n      const str2 = \"World\";\n      const expectedStr1 = \"     \"; // 5 spaces\n      const expectedStr2 = \"World\";\n      const [alignedStr1, alignedStr2] = alignLinesLeft(str1, str2);\n      expect(alignedStr1).toBe(expectedStr1);\n      expect(alignedStr2).toBe(expectedStr2);\n    });\n  \n    it('should align when the second string is empty', () => {\n      const str1 = \"Hello\";\n      const str2 = \"\";\n      const expectedStr1 = \"Hello\";\n      const expectedStr2 = \"     \"; // 5 spaces\n      const [alignedStr1, alignedStr2] = alignLinesLeft(str1, str2);\n      expect(alignedStr1).toBe(expectedStr1);\n      expect(alignedStr2).toBe(expectedStr2);\n    });\n  \n    it('should align when both strings are empty', () => {\n      const str1 = \"\";\n      const str2 = \"\";\n      const expectedStr1 = \"\";\n      const expectedStr2 = \"\";\n      const [alignedStr1, alignedStr2] = alignLinesLeft(str1, str2);\n      expect(alignedStr1).toBe(expectedStr1);\n      expect(alignedStr2).toBe(expectedStr2);\n    });\n  \n    it('should align strings with spaces correctly', () => {\n      const str1 = \"Hello \";\n      const str2 = \"World  \";\n      const expectedStr1 = \"Hello  \";\n      const expectedStr2 = \"World  \";\n      const [alignedStr1, alignedStr2] = alignLinesLeft(str1, str2);\n      expect(alignedStr1).toBe(expectedStr1);\n      expect(alignedStr2).toBe(expectedStr2);\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Align two lines of string to the left, supplementing with spaces if the length is not enough.\n *\n * @param str1 - The first string.\n * @param str2 - The second string.\n * @returns A tuple containing the aligned versions of str1 and str2.\n */\nfunction alignLinesLeft(str1: string, str2: string): [string, string] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Align two lines of string to the left, supplementing with spaces if the length is not enough.\n *\n * @param str1 The first string.\n * @param str2 The second string.\n * @return A pair of aligned strings (aligned_str1, aligned_str2).\n */\nstd::pair<std::string, std::string> align_lines_left(const std::string& str1, const std::string& str2) {}", "test_code": "TEST_CASE(\"Test align_lines_left function\", \"[align_lines_left]\") {\n    SECTION(\"Equal length strings\") {\n        std::string str1 = \"Hello\";\n        std::string str2 = \"World\";\n        std::string expected_str1 = \"Hello\";\n        std::string expected_str2 = \"World\";\n        auto [aligned_str1, aligned_str2] = align_lines_left(str1, str2);\n        REQUIRE(aligned_str1 == expected_str1);\n        REQUIRE(aligned_str2 == expected_str2);\n    }\n\n    SECTION(\"First string longer\") {\n        std::string str1 = \"Hello, World!\";\n        std::string str2 = \"Hi\";\n        std::string expected_str1 = \"Hello, World!\";\n        std::string expected_str2 = \"Hi           \";  // 14 spaces after \"Hi\"\n        auto [aligned_str1, aligned_str2] = align_lines_left(str1, str2);\n        REQUIRE(aligned_str1 == expected_str1);\n        REQUIRE(aligned_str2 == expected_str2);\n    }\n\n    SECTION(\"Second string longer\") {\n        std::string str1 = \"Hey\";\n        std::string str2 = \"Goodbye, friend!\";\n        std::string expected_str1 = \"Hey             \";  // 15 spaces after \"Hey\"\n        std::string expected_str2 = \"Goodbye, friend!\";\n        auto [aligned_str1, aligned_str2] = align_lines_left(str1, str2);\n        REQUIRE(aligned_str1 == expected_str1);\n        REQUIRE(aligned_str2 == expected_str2);\n    }\n\n    SECTION(\"Empty first string\") {\n        std::string str1 = \"\";\n        std::string str2 = \"World\";\n        std::string expected_str1 = \"     \";  // 5 spaces\n        std::string expected_str2 = \"World\";\n        auto [aligned_str1, aligned_str2] = align_lines_left(str1, str2);\n        REQUIRE(aligned_str1 == expected_str1);\n        REQUIRE(aligned_str2 == expected_str2);\n    }\n\n    SECTION(\"Empty second string\") {\n        std::string str1 = \"Hello\";\n        std::string str2 = \"\";\n        std::string expected_str1 = \"Hello\";\n        std::string expected_str2 = \"     \";  // 5 spaces\n        auto [aligned_str1, aligned_str2] = align_lines_left(str1, str2);\n        REQUIRE(aligned_str1 == expected_str1);\n        REQUIRE(aligned_str2 == expected_str2);\n    }\n\n    SECTION(\"Both strings empty\") {\n        std::string str1 = \"\";\n        std::string str2 = \"\";\n        std::string expected_str1 = \"\";\n        std::string expected_str2 = \"\";\n        auto [aligned_str1, aligned_str2] = align_lines_left(str1, str2);\n        REQUIRE(aligned_str1 == expected_str1);\n        REQUIRE(aligned_str2 == expected_str2);\n    }\n\n    SECTION(\"Strings with spaces\") {\n        std::string str1 = \"Hello \";\n        std::string str2 = \"World  \";\n        std::string expected_str1 = \"Hello  \";\n        std::string expected_str2 = \"World  \";\n        auto [aligned_str1, aligned_str2] = align_lines_left(str1, str2);\n        REQUIRE(aligned_str1 == expected_str1);\n        REQUIRE(aligned_str2 == expected_str2);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Align two lines of string to the left, supplementing with spaces if the length is not enough.\n *\n * @param str1 The first string.\n * @param str2 The second string.\n * @return A pair of aligned strings (aligned_str1, aligned_str2).\n */\nstd::pair<std::string, std::string> align_lines_left(const std::string& str1, const std::string& str2) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Aligns two lines of string to the left, supplementing with spaces if the length is not enough.\n *\n * @param str1 the first string\n * @param str2 the second string\n * @return an array containing the aligned strings (aligned str1, aligned str2)\n */\npublic static String[] alignLinesLeft(String str1, String str2) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static junit.framework.TestCase.assertEquals;\nimport static org.junit.Assert.assertArrayEquals; // Import for JUnit 4 assertions\n/**\n * Test class for aligning strings to the left.\n */\npublic class Tester {\n\n    /**\n     * Tests aligning strings of equal length.\n     */\n    @Test\n    public void testEqualLengthStrings() {\n        String str1 = \"Hello\";\n        String str2 = \"World\";\n        String expectedStr1 = \"Hello\";\n        String expectedStr2 = \"World\";\n        String[] alignedStrings = Answer.alignLinesLeft(str1, str2);\n        assertEquals(expectedStr1, alignedStrings[0]);\n        assertEquals(expectedStr2, alignedStrings[1]);\n    }\n\n    /**\n     * Tests aligning strings where the first string is longer.\n     */\n    @Test\n    public void testFirstStringLonger() {\n        String str1 = \"Hello, World!\";\n        String str2 = \"Hi\";\n        String expectedStr1 = \"Hello, World!\";\n        String expectedStr2 = \"Hi           \";  // 14 spaces after \"Hi\"\n        String[] alignedStrings = Answer.alignLinesLeft(str1, str2);\n        assertEquals(expectedStr1, alignedStrings[0]);\n        assertEquals(expectedStr2, alignedStrings[1]);\n    }\n\n    /**\n     * Tests aligning strings where the second string is longer.\n     */\n    @Test\n    public void testSecondStringLonger() {\n        String str1 = \"Hey\";\n        String str2 = \"Goodbye, friend!\";\n        String expectedStr1 = \"Hey             \";  // 15 spaces after \"Hey\"\n        String expectedStr2 = \"Goodbye, friend!\";\n        String[] alignedStrings = Answer.alignLinesLeft(str1, str2);\n        assertEquals(expectedStr1, alignedStrings[0]);\n        assertEquals(expectedStr2, alignedStrings[1]);\n    }\n\n    /**\n     * Tests aligning strings where the first string is empty.\n     */\n    @Test\n    public void testEmptyFirstString() {\n        String str1 = \"\";\n        String str2 = \"World\";\n        String expectedStr1 = \"     \";  // 5 spaces\n        String expectedStr2 = \"World\";\n        String[] alignedStrings = Answer.alignLinesLeft(str1, str2);\n        assertEquals(expectedStr1, alignedStrings[0]);\n        assertEquals(expectedStr2, alignedStrings[1]);\n    }\n\n    /**\n     * Tests aligning strings where the second string is empty.\n     */\n    @Test\n    public void testEmptySecondString() {\n        String str1 = \"Hello\";\n        String str2 = \"\";\n        String expectedStr1 = \"Hello\";\n        String expectedStr2 = \"     \";  // 5 spaces\n        String[] alignedStrings = Answer.alignLinesLeft(str1, str2);\n        assertEquals(expectedStr1, alignedStrings[0]);\n        assertEquals(expectedStr2, alignedStrings[1]);\n    }\n\n    /**\n     * Tests aligning strings with trailing spaces.\n     */\n    @Test\n    public void testStringsWithSpaces() {\n        String str1 = \"Hello \";\n        String str2 = \"World  \";\n        String expectedStr1 = \"Hello  \";\n        String expectedStr2 = \"World  \";\n        String[] alignedStrings = Answer.alignLinesLeft(str1, str2);\n        assertEquals(expectedStr1, alignedStrings[0]);\n        assertEquals(expectedStr2, alignedStrings[1]);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Aligns two lines of string to the left, supplementing with spaces if the length is not enough.\n *\n * @param str1 the first string\n * @param str2 the second string\n * @return an array containing the aligned strings (aligned str1, aligned str2)\n */\npublic static String[] alignLinesLeft(String str1, String str2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 45, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Returns the current time information including year, month, week of the month, and day of.eg {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }", "language_version_list": {"python": {"code_signature": "import datetime\n\n\ndef get_current_date_info(test_date: datetime.date) -> dict:\n    \"\"\"\n    Returns the current time information including year, month, week of the month, and day of.eg {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }\n\n    Args:\n        test_date (datetime.date): The date to compute information for, defaults to today's date if not provided.\n\n    Returns:\n        dict: A dictionary containing the year, month, week of the month, and day of the week.\n    \"\"\"\n", "test_code": "import unittest\nimport datetime\n\n\nclass TestGetCurrentDateInfo(unittest.TestCase):\n\n    def test_beginning_of_month(self):\n        result = get_current_date_info(datetime.date(2023, 1, 1))\n        expected = {\n            'year': 2023,\n            'month': 'January',\n            'week_of_the_month': 1,\n            'day_of_the_week': 'Sunday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_middle_of_month(self):\n        result = get_current_date_info(datetime.date(2023, 1, 15))\n        expected = {\n            'year': 2023,\n            'month': 'January',\n            'week_of_the_month': 3,\n            'day_of_the_week': 'Sunday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_leap_year(self):\n        result = get_current_date_info(datetime.date(2024, 2, 29))\n        expected = {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_change_of_year(self):\n        result = get_current_date_info(datetime.date(2022, 12, 31))\n        expected = {\n            'year': 2022,\n            'month': 'December',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Saturday'\n        }\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below import datetime\n\n\ndef get_current_date_info(test_date: datetime.date) -> dict:\n    \"\"\"\n    Returns the current time information including year, month, week of the month, and day of.eg {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }\n\n    Args:\n        test_date (datetime.date): The date to compute information for, defaults to today's date if not provided.\n\n    Returns:\n        dict: A dictionary containing the year, month, week of the month, and day of the week.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Returns the current time information including year, month, week of the month, and day of the week.\n * Example output:\n * {\n *     'year': 2024,\n *     'month': 'February',\n *     'week_of_the_month': 5,\n *     'day_of_the_week': 'Thursday'\n * }\n *\n * @param {Date} [testDate] - The date to compute information for, defaults to today's date if not provided.\n * @returns {Object} An object containing the year, month, week of the month, and day of the week.\n */\nfunction getCurrentDateInfo(testDate = new Date()) {}", "test_code": "describe('TestGetCurrentDateInfo', () => {\n  describe('test_beginning_of_month', () => {\n      it('should return correct info for the beginning of the month', () => {\n          const result = get_current_date_info(new Date(2023, 0, 1));\n          const expected = {\n              'year': 2023,\n              'month': 'January',\n              'week_of_the_month': 1,\n              'day_of_the_week': 'Sunday'\n          };\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_middle_of_month', () => {\n      it('should return correct info for the middle of the month', () => {\n          const result = get_current_date_info(new Date(2023, 0, 15));\n          const expected = {\n              'year': 2023,\n              'month': 'January',\n              'week_of_the_month': 3,\n              'day_of_the_week': 'Sunday'\n          };\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_leap_year', () => {\n      it('should return correct info for a leap year', () => {\n          const result = get_current_date_info(new Date(2024, 1, 29));\n          const expected = {\n              'year': 2024,\n              'month': 'February',\n              'week_of_the_month': 5,\n              'day_of_the_week': 'Thursday'\n          };\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_change_of_year', () => {\n      it('should return correct info for the end of the year', () => {\n          const result = get_current_date_info(new Date(2022, 11, 31));\n          const expected = {\n              'year': 2022,\n              'month': 'December',\n              'week_of_the_month': 5,\n              'day_of_the_week': 'Saturday'\n          };\n          expect(result).toEqual(expected);\n      });\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Returns the current time information including year, month, week of the month, and day of the week.\n * Example output:\n * {\n *     'year': 2024,\n *     'month': 'February',\n *     'week_of_the_month': 5,\n *     'day_of_the_week': 'Thursday'\n * }\n *\n * @param {Date} [testDate] - The date to compute information for, defaults to today's date if not provided.\n * @returns {Object} An object containing the year, month, week of the month, and day of the week.\n */\nfunction getCurrentDateInfo(testDate = new Date()) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Returns the current time information including year, month, week of the month, and day of the week.\n * Example output:\n * {\n *     'year': 2024,\n *     'month': 'February',\n *     'week_of_the_month': 5,\n *     'day_of_the_week': 'Thursday'\n * }\n *\n * @param testDate - The date to compute information for, defaults to today's date if not provided.\n * @returns A dictionary containing the year, month, week of the month, and day of the week.\n */\nfunction getCurrentDateInfo(testDate?: DateTime): { year: number; month: string; weekOfTheMonth: number; dayOfWeek: string } {}", "test_code": "describe('TestGetCurrentDateInfo', () => {\n  describe('test_beginning_of_month', () => {\n      it('should return correct info for the beginning of the month', () => {\n          const result = getCurrentDateInfo(new Date(2023, 0, 1));\n          const expected = {\n              'year': 2023,\n              'month': 'January',\n              'week_of_the_month': 1,\n              'day_of_the_week': 'Sunday'\n          };\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_middle_of_month', () => {\n      it('should return correct info for the middle of the month', () => {\n          const result = getCurrentDateInfo(new Date(2023, 0, 15));\n          const expected = {\n              'year': 2023,\n              'month': 'January',\n              'week_of_the_month': 3,\n              'day_of_the_week': 'Sunday'\n          };\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_leap_year', () => {\n      it('should return correct info for a leap year', () => {\n          const result = getCurrentDateInfo(new Date(2024, 1, 29));\n          const expected = {\n              'year': 2024,\n              'month': 'February',\n              'week_of_the_month': 5,\n              'day_of_the_week': 'Thursday'\n          };\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_change_of_year', () => {\n      it('should return correct info for the end of the year', () => {\n          const result = getCurrentDateInfo(new Date(2022, 11, 31));\n          const expected = {\n              'year': 2022,\n              'month': 'December',\n              'week_of_the_month': 5,\n              'day_of_the_week': 'Saturday'\n          };\n          expect(result).toEqual(expected);\n      });\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Returns the current time information including year, month, week of the month, and day of the week.\n * Example output:\n * {\n *     'year': 2024,\n *     'month': 'February',\n *     'week_of_the_month': 5,\n *     'day_of_the_week': 'Thursday'\n * }\n *\n * @param testDate - The date to compute information for, defaults to today's date if not provided.\n * @returns A dictionary containing the year, month, week of the month, and day of the week.\n */\nfunction getCurrentDateInfo(testDate?: DateTime): { year: number; month: string; weekOfTheMonth: number; dayOfWeek: string } {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Returns the current time information including year, month, week of the month, and day of the week.\n *\n * Example output:\n * {\n *     'year': 2024,\n *     'month': 'February',\n *     'week_of_the_month': 5,\n *     'day_of_the_week': 'Thursday'\n * }\n *\n * @param test_date The date to compute information for, defaults to today's date if not provided.\n * @return A map containing the year, month, week of the month, and day of the week.\n */\nstd::map<std::string, std::string> get_current_date_info(const std::tm* test_date = nullptr) {", "test_code": "TEST_CASE(\"TestGetCurrentDateInfo\") {\n    SECTION(\"Beginning of the month\") {\n        std::tm date = {};\n        date.tm_year = 2023 - 1900; // Year since 1900\n        date.tm_mon = 0; // Month (0-based)\n        date.tm_mday = 1; // Day of the month\n        date.tm_isdst = -1; // Daylight saving time flag\n\n        auto result = get_current_date_info(&date);\n        std::map<std::string, std::string> expected = {\n            {\"year\", \"2023\"},\n            {\"month\", \"January\"},\n            {\"week_of_the_month\", \"1\"},\n            {\"day_of_the_week\", \"Sunday\"}\n        };\n\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Middle of the month\") {\n        std::tm date = {};\n        date.tm_year = 2023 - 1900; // Year since 1900\n        date.tm_mon = 0; // Month (0-based)\n        date.tm_mday = 15; // Day of the month\n        date.tm_isdst = -1; // Daylight saving time flag\n\n        auto result = get_current_date_info(&date);\n        std::map<std::string, std::string> expected = {\n            {\"year\", \"2023\"},\n            {\"month\", \"January\"},\n            {\"week_of_the_month\", \"3\"},\n            {\"day_of_the_week\", \"Sunday\"}\n        };\n\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Leap year\") {\n        std::tm date = {};\n        date.tm_year = 2024 - 1900; // Year since 1900\n        date.tm_mon = 1; // Month (0-based)\n        date.tm_mday = 29; // Day of the month\n        date.tm_isdst = -1; // Daylight saving time flag\n\n        auto result = get_current_date_info(&date);\n        std::map<std::string, std::string> expected = {\n            {\"year\", \"2024\"},\n            {\"month\", \"February\"},\n            {\"week_of_the_month\", \"5\"},\n            {\"day_of_the_week\", \"Thursday\"}\n        };\n\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Change of year\") {\n        std::tm date = {};\n        date.tm_year = 2022 - 1900; // Year since 1900\n        date.tm_mon = 11; // Month (0-based)\n        date.tm_mday = 31; // Day of the month\n        date.tm_isdst = -1; // Daylight saving time flag\n\n        auto result = get_current_date_info(&date);\n        std::map<std::string, std::string> expected = {\n            {\"year\", \"2022\"},\n            {\"month\", \"December\"},\n            {\"week_of_the_month\", \"5\"},\n            {\"day_of_the_week\", \"Saturday\"}\n        };\n\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Returns the current time information including year, month, week of the month, and day of the week.\n *\n * Example output:\n * {\n *     'year': 2024,\n *     'month': 'February',\n *     'week_of_the_month': 5,\n *     'day_of_the_week': 'Thursday'\n * }\n *\n * @param test_date The date to compute information for, defaults to today's date if not provided.\n * @return A map containing the year, month, week of the month, and day of the week.\n */\nstd::map<std::string, std::string> get_current_date_info(const std::tm* test_date = nullptr) {", "addition_info": ""}, "java": {"code_signature": "/**\n * Returns the current time information including year, month, week of the month, and day of the week.\n * Optionally takes a date object for testing purposes.\n *\n * @param testDate The date to compute information for, defaults to today's date if not provided.\n * @return A map containing the year, month, week of the month, and day of the week.\n */\npublic static Map<String, Object> getCurrentDateInfo(LocalDate testDate) {}", "test_code": "package org.real.temp;\n\nimport java.time.LocalDate;\nimport java.time.DayOfWeek;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.Test; // JUnit 4 Test annotation\nimport static org.junit.Assert.assertEquals; // JUnit 4 assertion methods\n\npublic class Tester {\n\n\n    @Test\n    public void testBeginningOfMonth() {\n        LocalDate testDate = LocalDate.of(2023, 1, 1);\n        Map<String, Object> result = Answer.getCurrentDateInfo(testDate);\n        Map<String, Object> expected = new HashMap<>();\n        expected.put(\"year\", 2023);\n        expected.put(\"month\", \"January\".toUpperCase());\n        expected.put(\"week_of_the_month\", 1);\n        expected.put(\"day_of_the_week\", \"SUNDAY\");\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testMiddleOfMonth() {\n        LocalDate testDate = LocalDate.of(2023, 1, 15);\n        Map<String, Object> result = Answer.getCurrentDateInfo(testDate);\n        Map<String, Object> expected = new HashMap<>();\n        expected.put(\"year\", 2023);\n        expected.put(\"month\", \"January\".toUpperCase());\n        expected.put(\"week_of_the_month\", 3);\n        expected.put(\"day_of_the_week\", \"SUNDAY\");\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testLeapYear() {\n        LocalDate testDate = LocalDate.of(2024, 2, 29);\n        Map<String, Object> result = Answer.getCurrentDateInfo(testDate);\n        Map<String, Object> expected = new HashMap<>();\n        expected.put(\"year\", 2024);\n        expected.put(\"month\", \"FEBRUARY\");\n        expected.put(\"week_of_the_month\", 5);\n        expected.put(\"day_of_the_week\", \"THURSDAY\");\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testChangeOfYear() {\n        LocalDate testDate = LocalDate.of(2022, 12, 31);\n        Map<String, Object> result = Answer.getCurrentDateInfo(testDate);\n        Map<String, Object> expected = new HashMap<>();\n        expected.put(\"year\", 2022);\n        expected.put(\"month\", \"DECEMBER\");\n        expected.put(\"week_of_the_month\", 5);\n        expected.put(\"day_of_the_week\", \"SATURDAY\");\n        assertEquals(expected, result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Returns the current time information including year, month, week of the month, and day of the week.\n * Optionally takes a date object for testing purposes.\n *\n * @param testDate The date to compute information for, defaults to today's date if not provided.\n * @return A map containing the year, month, week of the month, and day of the week.\n */\npublic static Map<String, Object> getCurrentDateInfo(LocalDate testDate) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 46, "code_type": "class", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Create a binary tree class, and implement its preorder traversal, inorder traversal, postorder traversal", "language_version_list": {"python": {"code_signature": "class TreeNode:\n    \"\"\"\n    binary tree node\n    \"\"\"\n\n    def __init__(self, value=0, left=None, right=None):\n        pass\n\n\nclass BinaryTree:\n    \"\"\"\n    binary tree\n    \"\"\"\n\n    def __init__(self, root=None):\n        pass\n\n    def preorder_traversal(self, node, result=None):\n        pass\n\n    def inorder_traversal(self, node, result=None):\n        pass\n\n    def postorder_traversal(self, node, result=None):\n        pass\n", "test_code": "import unittest\n\n\nclass TestBinaryTree(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Setup basic tree structure for testing.\"\"\"\n        # Tree structure:\n        #      1\n        #     / \\\n        #    2   3\n        #   / \\\n        #  4   5\n        self.tree = BinaryTree(TreeNode(1))\n        self.tree.root.left = TreeNode(2, TreeNode(4), TreeNode(5))\n        self.tree.root.right = TreeNode(3)\n\n    def test_preorder_traversal(self):\n        \"\"\"Test preorder traversal.\"\"\"\n        result = self.tree.preorder_traversal(self.tree.root)\n        self.assertEqual(result, [1, 2, 4, 5, 3])\n\n    def test_inorder_traversal(self):\n        \"\"\"Test inorder traversal.\"\"\"\n        result = self.tree.inorder_traversal(self.tree.root)\n        self.assertEqual(result, [4, 2, 5, 1, 3])\n\n    def test_postorder_traversal(self):\n        \"\"\"Test postorder traversal.\"\"\"\n        result = self.tree.postorder_traversal(self.tree.root)\n        self.assertEqual(result, [4, 5, 2, 3, 1])\n\n    def test_empty_tree(self):\n        \"\"\"Test traversals on an empty tree.\"\"\"\n        empty_tree = BinaryTree()\n        self.assertEqual(empty_tree.preorder_traversal(empty_tree.root), [])\n        self.assertEqual(empty_tree.inorder_traversal(empty_tree.root), [])\n        self.assertEqual(empty_tree.postorder_traversal(empty_tree.root), [])\n\n    def test_single_node_tree(self):\n        \"\"\"Test all traversals on a tree with only one node.\"\"\"\n        single_node_tree = BinaryTree(TreeNode(10))\n        self.assertEqual(single_node_tree.preorder_traversal(single_node_tree.root), [10])\n        self.assertEqual(single_node_tree.inorder_traversal(single_node_tree.root), [10])\n        self.assertEqual(single_node_tree.postorder_traversal(single_node_tree.root), [10])\n", "prompt": "please write a python class , the class signature as below class TreeNode:\n    \"\"\"\n    binary tree node\n    \"\"\"\n\n    def __init__(self, value=0, left=None, right=None):\n        pass\n\n\nclass BinaryTree:\n    \"\"\"\n    binary tree\n    \"\"\"\n\n    def __init__(self, root=None):\n        pass\n\n    def preorder_traversal(self, node, result=None):\n        pass\n\n    def inorder_traversal(self, node, result=None):\n        pass\n\n    def postorder_traversal(self, node, result=None):\n        pass\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Binary tree node.\n */\nclass TreeNode {\n    /**\n     * Constructs a new TreeNode.\n     * @param {number} [value=0] - The value of the node.\n     * @param {TreeNode} [left=null] - The left child node.\n     * @param {TreeNode} [right=null] - The right child node.\n     */\n    constructor(value = 0, left = null, right = null) {\n        // Implementation goes here\n    }\n}\n\n/**\n * Binary tree.\n */\nclass BinaryTree {\n    /**\n     * Constructs a new BinaryTree.\n     * @param {TreeNode} [root=null] - The root node of the tree.\n     */\n    constructor(root = null) {\n        // Implementation goes here\n    }\n\n    /**\n     * Performs a preorder traversal of the tree.\n     * @param {TreeNode} node - The current node being traversed.\n     * @param {Array} [result=null] - The result array to store the values.\n     * @returns {Array} The result array containing the values.\n     */\n    preorderTraversal(node, result = null) {\n        // Implementation goes here\n    }\n\n    /**\n     * Performs an inorder traversal of the tree.\n     * @param {TreeNode} node - The current node being traversed.\n     * @param {Array} [result=null] - The result array to store the values.\n     * @returns {Array} The result array containing the values.\n     */\n    inorderTraversal(node, result = null) {\n        // Implementation goes here\n    }\n\n    /**\n     * Performs a postorder traversal of the tree.\n     * @param {TreeNode} node - The current node being traversed.\n     * @param {Array} [result=null] - The result array to store the values.\n     * @returns {Array} The result array containing the values.\n     */\n    postorderTraversal(node, result = null) {\n        // Implementation goes here\n    }\n}", "test_code": "describe('BinaryTree', () => {\n    let tree;\n\n    beforeEach(() => {\n        /** Setup basic tree structure for testing. */\n        // Tree structure:\n        //      1\n        //     / \\\n        //    2   3\n        //   / \\\n        //  4   5\n        tree = new BinaryTree(new TreeNode(1));\n        tree.root.left = new TreeNode(2, new TreeNode(4), new TreeNode(5));\n        tree.root.right = new TreeNode(3);\n    });\n\n    test('preorder traversal', () => {\n        /** Test preorder traversal. */\n        const result = tree.preorderTraversal(tree.root);\n        expect(result).toEqual([1, 2, 4, 5, 3]);\n    });\n\n    test('inorder traversal', () => {\n        /** Test inorder traversal. */\n        const result = tree.inorderTraversal(tree.root);\n        expect(result).toEqual([4, 2, 5, 1, 3]);\n    });\n\n    test('postorder traversal', () => {\n        /** Test postorder traversal. */\n        const result = tree.postorderTraversal(tree.root);\n        expect(result).toEqual([4, 5, 2, 3, 1]);\n    });\n\n    test('empty tree', () => {\n        /** Test traversals on an empty tree. */\n        const emptyTree = new BinaryTree();\n        expect(emptyTree.preorderTraversal(emptyTree.root)).toEqual([]);\n        expect(emptyTree.inorderTraversal(emptyTree.root)).toEqual([]);\n        expect(emptyTree.postorderTraversal(emptyTree.root)).toEqual([]);\n    });\n\n    test('single node tree', () => {\n        /** Test all traversals on a tree with only one node. */\n        const singleNodeTree = new BinaryTree(new TreeNode(10));\n        expect(singleNodeTree.preorderTraversal(singleNodeTree.root)).toEqual([10]);\n        expect(singleNodeTree.inorderTraversal(singleNodeTree.root)).toEqual([10]);\n        expect(singleNodeTree.postorderTraversal(singleNodeTree.root)).toEqual([10]);\n    });\n});", "prompt": "please write a javascript class , the class signature as below /**\n * Binary tree node.\n */\nclass TreeNode {\n    /**\n     * Constructs a new TreeNode.\n     * @param {number} [value=0] - The value of the node.\n     * @param {TreeNode} [left=null] - The left child node.\n     * @param {TreeNode} [right=null] - The right child node.\n     */\n    constructor(value = 0, left = null, right = null) {\n        // Implementation goes here\n    }\n}\n\n/**\n * Binary tree.\n */\nclass BinaryTree {\n    /**\n     * Constructs a new BinaryTree.\n     * @param {TreeNode} [root=null] - The root node of the tree.\n     */\n    constructor(root = null) {\n        // Implementation goes here\n    }\n\n    /**\n     * Performs a preorder traversal of the tree.\n     * @param {TreeNode} node - The current node being traversed.\n     * @param {Array} [result=null] - The result array to store the values.\n     * @returns {Array} The result array containing the values.\n     */\n    preorderTraversal(node, result = null) {\n        // Implementation goes here\n    }\n\n    /**\n     * Performs an inorder traversal of the tree.\n     * @param {TreeNode} node - The current node being traversed.\n     * @param {Array} [result=null] - The result array to store the values.\n     * @returns {Array} The result array containing the values.\n     */\n    inorderTraversal(node, result = null) {\n        // Implementation goes here\n    }\n\n    /**\n     * Performs a postorder traversal of the tree.\n     * @param {TreeNode} node - The current node being traversed.\n     * @param {Array} [result=null] - The result array to store the values.\n     * @returns {Array} The result array containing the values.\n     */\n    postorderTraversal(node, result = null) {\n        // Implementation goes here\n    }\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Represents a binary tree node.\n */\nclass TreeNode {\n    value: number;\n    left: TreeNode | null;\n    right: TreeNode | null;\n\n    /**\n     * Constructs a new TreeNode.\n     * @param value The value of the node.\n     * @param left The left child of the node.\n     * @param right The right child of the node.\n     */\n    constructor(value: number = 0, left: TreeNode | null = null, right: TreeNode | null = null) {\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n}\n\n/**\n * Represents a binary tree.\n */\nclass BinaryTree {\n    root: TreeNode | null;\n\n    /**\n     * Constructs a new BinaryTree.\n     * @param root The root node of the binary tree.\n     */\n    constructor(root: TreeNode | null = null) {\n        this.root = root;\n    }\n\n    /**\n     * Performs a recursive preorder traversal.\n     * @param node The current node being traversed.\n     * @param result The array to store the traversal results.\n     * @returns An array containing the preorder traversal results.\n     */\n    preorderTraversal(node: TreeNode | null, result?: number[]): number[] {\n    }\n\n    /**\n     * Performs a recursive inorder traversal.\n     * @param node The current node being traversed.\n     * @param result The array to store the traversal results.\n     * @returns An array containing the inorder traversal results.\n     */\n    inorderTraversal(node: TreeNode | null, result?: number[]): number[] {\n    }\n\n    /**\n     * Performs a recursive postorder traversal.\n     * @param node The current node being traversed.\n     * @param result The array to store the traversal results.\n     * @returns An array containing the postorder traversal results.\n     */\n    postorderTraversal(node: TreeNode | null, result?: number[]): number[] {\n    }\n}", "test_code": "describe('BinaryTree', () => {\n    let tree: BinaryTree;\n\n    beforeEach(() => {\n        // Setup basic tree structure for testing.\n        // Tree structure:\n        //      1\n        //     / \\\n        //    2   3\n        //   / \\\n        //  4   5\n        tree = new BinaryTree(new TreeNode(1));\n        tree.root.left = new TreeNode(2, new TreeNode(4), new TreeNode(5));\n        tree.root.right = new TreeNode(3);\n    });\n\n    describe('preorderTraversal', () => {\n        it('should perform preorder traversal correctly', () => {\n            const result = tree.preorderTraversal(tree.root);\n            expect(result).toEqual([1, 2, 4, 5, 3]);\n        });\n    });\n\n    describe('inorderTraversal', () => {\n        it('should perform inorder traversal correctly', () => {\n            const result = tree.inorderTraversal(tree.root);\n            expect(result).toEqual([4, 2, 5, 1, 3]);\n        });\n    });\n\n    describe('postorderTraversal', () => {\n        it('should perform postorder traversal correctly', () => {\n            const result = tree.postorderTraversal(tree.root);\n            expect(result).toEqual([4, 5, 2, 3, 1]);\n        });\n    });\n\n    describe('empty tree', () => {\n        it('should handle an empty tree correctly', () => {\n            const emptyTree = new BinaryTree();\n            expect(emptyTree.preorderTraversal(emptyTree.root)).toEqual([]);\n            expect(emptyTree.inorderTraversal(emptyTree.root)).toEqual([]);\n            expect(emptyTree.postorderTraversal(emptyTree.root)).toEqual([]);\n        });\n    });\n\n    describe('single node tree', () => {\n        it('should handle a single node tree correctly', () => {\n            const singleNodeTree = new BinaryTree(new TreeNode(10));\n            expect(singleNodeTree.preorderTraversal(singleNodeTree.root)).toEqual([10]);\n            expect(singleNodeTree.inorderTraversal(singleNodeTree.root)).toEqual([10]);\n            expect(singleNodeTree.postorderTraversal(singleNodeTree.root)).toEqual([10]);\n        });\n    });\n});", "prompt": "please write a typescript class , the class signature as below /**\n * Represents a binary tree node.\n */\nclass TreeNode {\n    value: number;\n    left: TreeNode | null;\n    right: TreeNode | null;\n\n    /**\n     * Constructs a new TreeNode.\n     * @param value The value of the node.\n     * @param left The left child of the node.\n     * @param right The right child of the node.\n     */\n    constructor(value: number = 0, left: TreeNode | null = null, right: TreeNode | null = null) {\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n}\n\n/**\n * Represents a binary tree.\n */\nclass BinaryTree {\n    root: TreeNode | null;\n\n    /**\n     * Constructs a new BinaryTree.\n     * @param root The root node of the binary tree.\n     */\n    constructor(root: TreeNode | null = null) {\n        this.root = root;\n    }\n\n    /**\n     * Performs a recursive preorder traversal.\n     * @param node The current node being traversed.\n     * @param result The array to store the traversal results.\n     * @returns An array containing the preorder traversal results.\n     */\n    preorderTraversal(node: TreeNode | null, result?: number[]): number[] {\n    }\n\n    /**\n     * Performs a recursive inorder traversal.\n     * @param node The current node being traversed.\n     * @param result The array to store the traversal results.\n     * @returns An array containing the inorder traversal results.\n     */\n    inorderTraversal(node: TreeNode | null, result?: number[]): number[] {\n    }\n\n    /**\n     * Performs a recursive postorder traversal.\n     * @param node The current node being traversed.\n     * @param result The array to store the traversal results.\n     * @returns An array containing the postorder traversal results.\n     */\n    postorderTraversal(node: TreeNode | null, result?: number[]): number[] {\n    }\n}", "addition_info": ""}, "c&cpp": {"code_signature": "// TreeNode class definition\nclass TreeNode {\npublic:\n    // Binary tree node\n    int value;\n    TreeNode* left;\n    TreeNode* right;\n\n    // Constructor for TreeNode\n    TreeNode(int val = 0, TreeNode* l = nullptr, TreeNode* r = nullptr) \n        : value(val), left(l), right(r) {}\n};\n\n// BinaryTree class definition\nclass BinaryTree {\npublic:\n    // Binary tree\n    TreeNode* root;\n\n    // Constructor for BinaryTree\n    BinaryTree(TreeNode* r = nullptr) : root(r) {}\n\n    // Recursive Preorder Traversal\n    std::vector<int> preorder_traversal(TreeNode* node, std::vector<int>* result = nullptr) {}\n\n    // Recursive Inorder Traversal\n    std::vector<int> inorder_traversal(TreeNode* node, std::vector<int>* result = nullptr) {}\n\n    // Recursive Postorder Traversal\n    std::vector<int> postorder_traversal(TreeNode* node, std::vector<int>* result = nullptr) {}\n};", "test_code": "TEST_CASE(\"TestBinaryTree\", \"[BinaryTree]\") {\n    BinaryTree tree;\n\n    SECTION(\"Test preorder traversal\") {\n        std::vector<int> result = tree.preorder_traversal(tree.root);\n        REQUIRE_THAT(result, Catch::Matchers::Equals(std::vector<int>({1, 2, 4, 5, 3})));\n    }\n\n    SECTION(\"Test inorder traversal\") {\n        std::vector<int> result = tree.inorder_traversal(tree.root);\n        REQUIRE_THAT(result, Catch::Matchers::Equals(std::vector<int>({4, 2, 5, 1, 3})));\n    }\n\n    SECTION(\"Test postorder traversal\") {\n        std::vector<int> result =tree.postorder_traversal(tree.root);\n        REQUIRE_THAT(result, Catch::Matchers::Equals(std::vector<int>({4, 5, 2, 3, 1})));\n    }\n\n    SECTION(\"Test empty tree\") {\n        BinaryTree empty_tree;\n        REQUIRE_THAT(empty_tree.preorder_traversal(empty_tree.root), Catch::Matchers::Equals(std::vector<int>({})));\n        REQUIRE_THAT(empty_tree.inorder_traversal(empty_tree.root), Catch::Matchers::Equals(std::vector<int>({})));\n        REQUIRE_THAT(empty_tree.postorder_traversal(empty_tree.root), Catch::Matchers::Equals(std::vector<int>({})));\n    }\n\n    SECTION(\"Test single node tree\") {\n        BinaryTree single_node_tree(new TreeNode(10));\n        REQUIRE_THAT(single_node_tree.preorder_traversal(single_node_tree.root), Catch::Matchers::Equals(std::vector<int>({10})));\n        REQUIRE_THAT(single_node_tree.inorder_traversal(single_node_tree.root), Catch::Matchers::Equals(std::vector<int>({10})));\n        REQUIRE_THAT(single_node_tree.postorder_traversal(single_node_tree.root), Catch::Matchers::Equals(std::vector<int>({10})));\n    }\n}", "prompt": "please write a cpp class , the class signature as below // TreeNode class definition\nclass TreeNode {\npublic:\n    // Binary tree node\n    int value;\n    TreeNode* left;\n    TreeNode* right;\n\n    // Constructor for TreeNode\n    TreeNode(int val = 0, TreeNode* l = nullptr, TreeNode* r = nullptr) \n        : value(val), left(l), right(r) {}\n};\n\n// BinaryTree class definition\nclass BinaryTree {\npublic:\n    // Binary tree\n    TreeNode* root;\n\n    // Constructor for BinaryTree\n    BinaryTree(TreeNode* r = nullptr) : root(r) {}\n\n    // Recursive Preorder Traversal\n    std::vector<int> preorder_traversal(TreeNode* node, std::vector<int>* result = nullptr) {}\n\n    // Recursive Inorder Traversal\n    std::vector<int> inorder_traversal(TreeNode* node, std::vector<int>* result = nullptr) {}\n\n    // Recursive Postorder Traversal\n    std::vector<int> postorder_traversal(TreeNode* node, std::vector<int>* result = nullptr) {}\n};", "addition_info": ""}, "java": {"code_signature": "/**\n * Represents a binary tree node.\n */\npublic class TreeNode {\n    private int value;\n    private TreeNode left;\n    private TreeNode right;\n\n    /**\n     * Constructs a new TreeNode with the specified value and optional children.\n     *\n     * @param value the value of the node\n     * @param left  the left child of the node\n     * @param right the right child of the node\n     */\n    public TreeNode(int value, TreeNode left, TreeNode right) {\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n\n    /**\n     * Constructs a new TreeNode with the specified value and no children.\n     *\n     * @param value the value of the node\n     */\n    public TreeNode(int value) {\n        this(value, null, null);\n    }\n\n    // Getters and setters for the fields\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public TreeNode getLeft() {\n        return left;\n    }\n\n    public void setLeft(TreeNode left) {\n        this.left = left;\n    }\n\n    public TreeNode getRight() {\n        return right;\n    }\n\n    public void setRight(TreeNode right) {\n        this.right = right;\n    }\n}\n\n/**\n * Represents a binary tree.\n */\npublic class BinaryTree {\n    private TreeNode root;\n\n    /**\n     * Constructs a new BinaryTree with the specified root node.\n     *\n     * @param root the root node of the tree\n     */\n    public BinaryTree(TreeNode root) {\n        this.root = root;\n    }\n\n    /**\n     * Constructs a new BinaryTree with no root node.\n     */\n    public BinaryTree() {\n        this(null);\n    }\n\n    /**\n     * Performs a preorder traversal of the binary tree.\n     *\n     * @param node   the current node being visited\n     * @param result the list to store the traversal results\n     * @return the list containing the preorder traversal results\n     */\n    public List<Integer> preorderTraversal(TreeNode node) {}\n\n    /**\n     * Performs an inorder traversal of the binary tree.\n     *\n     * @param node   the current node being visited\n     * @param result the list to store the traversal results\n     * @return the list containing the inorder traversal results\n     */\n    public List<Integer> inorderTraversal(TreeNode node) {}\n\n    /**\n     * Performs a postorder traversal of the binary tree.\n     *\n     * @param node   the current node being visited\n     * @param result the list to store the traversal results\n     * @return the list containing the postorder traversal results\n     */\n    public List<Integer> postorderTraversal(TreeNode node) {}\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.real.temp.Answer.TreeNode;\nimport org.real.temp.Answer.BinaryTree;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for BinaryTree operations.\n */\npublic class Tester {\n\n    private BinaryTree tree;\n    private BinaryTree emptyTree;\n\n    @Before\n    public void setUp() {\n        // Tree structure:\n        //      1\n        //     / \\\n        //    2   3\n        //   / \\\n        //  4   5\n        tree = new Answer.BinaryTree(new TreeNode(1));\n        tree.root.left = new Answer.TreeNode(2, new TreeNode(4), new TreeNode(5));\n        tree.root.right = new TreeNode(3);\n\n        emptyTree = new BinaryTree();\n\n    }\n\n    @Test\n    public void testPreorderTraversal() {\n        // Test preorder traversal\n        List<Integer> result = new ArrayList<>();\n        result = tree.preorderTraversal(tree.root,result);\n        assertEquals(\"[1, 2, 4, 5, 3]\", result.toString());\n    }\n\n    @Test\n    public void testInorderTraversal() {\n        // Test inorder traversal\n        List<Integer> result = new ArrayList<>();\n\n        result = tree.inorderTraversal(tree.root,result);\n        assertEquals(\"[4, 2, 5, 1, 3]\", result.toString());\n    }\n\n    @Test\n    public void testPostorderTraversal() {\n        List<Integer> result = new ArrayList<>();\n        result = tree.postorderTraversal(tree.root,result);\n        assertEquals(\"[4, 5, 2, 3, 1]\", result.toString());\n    }\n\n    @Test\n    public void testEmptyTree() {\n        // Test traversals on an empty tree\n        List<Integer> result = new ArrayList<>();\n        assertEquals(\"[]\", emptyTree.preorderTraversal(emptyTree.root,result).toString());\n        assertEquals(\"[]\", emptyTree.inorderTraversal(emptyTree.root,result).toString());\n        assertEquals(\"[]\", emptyTree.postorderTraversal(emptyTree.root,result).toString());\n    }\n\n}", "prompt": "please write a java class , the function signature as below /**\n * Represents a binary tree node.\n */\npublic class TreeNode {\n    private int value;\n    private TreeNode left;\n    private TreeNode right;\n\n    /**\n     * Constructs a new TreeNode with the specified value and optional children.\n     *\n     * @param value the value of the node\n     * @param left  the left child of the node\n     * @param right the right child of the node\n     */\n    public TreeNode(int value, TreeNode left, TreeNode right) {\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n\n    /**\n     * Constructs a new TreeNode with the specified value and no children.\n     *\n     * @param value the value of the node\n     */\n    public TreeNode(int value) {\n        this(value, null, null);\n    }\n\n    // Getters and setters for the fields\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public TreeNode getLeft() {\n        return left;\n    }\n\n    public void setLeft(TreeNode left) {\n        this.left = left;\n    }\n\n    public TreeNode getRight() {\n        return right;\n    }\n\n    public void setRight(TreeNode right) {\n        this.right = right;\n    }\n}\n\n/**\n * Represents a binary tree.\n */\npublic class BinaryTree {\n    private TreeNode root;\n\n    /**\n     * Constructs a new BinaryTree with the specified root node.\n     *\n     * @param root the root node of the tree\n     */\n    public BinaryTree(TreeNode root) {\n        this.root = root;\n    }\n\n    /**\n     * Constructs a new BinaryTree with no root node.\n     */\n    public BinaryTree() {\n        this(null);\n    }\n\n    /**\n     * Performs a preorder traversal of the binary tree.\n     *\n     * @param node   the current node being visited\n     * @param result the list to store the traversal results\n     * @return the list containing the preorder traversal results\n     */\n    public List<Integer> preorderTraversal(TreeNode node) {}\n\n    /**\n     * Performs an inorder traversal of the binary tree.\n     *\n     * @param node   the current node being visited\n     * @param result the list to store the traversal results\n     * @return the list containing the inorder traversal results\n     */\n    public List<Integer> inorderTraversal(TreeNode node) {}\n\n    /**\n     * Performs a postorder traversal of the binary tree.\n     *\n     * @param node   the current node being visited\n     * @param result the list to store the traversal results\n     * @return the list containing the postorder traversal results\n     */\n    public List<Integer> postorderTraversal(TreeNode node) {}\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 47, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "calculate the nth occurrence of a specific working day (k) in a given month (m) and year (y).\nIf there is no nth date in the month, the last date of the month is returned", "language_version_list": {"python": {"code_signature": "import datetime\n\n\ndef calculate_nth_weekday_in_month(year: int, month: int, occurrence: int, weekday: int) -> datetime.date:\n    \"\"\"\n    Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n    If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n    This function extends the capability to handle edge cases where the nth weekday might not be present,\n    by providing the closest previous weekday in such cases\n    Args:\n        y (int): The year for which the date is to be calculated.\n        m (int): The month for which the date is to be calculated, where January is 1 and December is 12.\n        n (int): The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n        k (int): The weekday, where Monday is 0 and Sunday is 6.\n\n    Returns:\n        datetime: The calculated date of the nth occurrence of the weekday in the given month and year.\n      If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n    \"\"\"\n", "test_code": "import unittest\nimport datetime\n\n\nclass TestFindNthWeekdayOfSpecificYear(unittest.TestCase):\n\n    def test_regular_occurrence(self):\n        # Test for the 2nd Monday of May 2023\n        result = calculate_nth_weekday_in_month(2023, 5, 2, 0)  # Monday is 0\n        expected = datetime.date(2023, 5, 8)\n        self.assertEqual(result, expected)\n\n    def test_last_occurrence(self):\n        # Test for the 5th Monday of May 2023, which doesn't exist, should return the last Monday\n        result = calculate_nth_weekday_in_month(2023, 5, 5, 0)  # Monday is 0\n        expected = datetime.date(2023, 5, 29)\n        self.assertEqual(result, expected)\n\n    def test_first_day_is_weekday(self):\n        # Test for when the first day of the month is the weekday in question, 1st Tuesday of August 2023\n        result = calculate_nth_weekday_in_month(2023, 8, 1, 1)  # Tuesday is 1\n        expected = datetime.date(2023, 8, 1)\n        self.assertEqual(result, expected)\n\n    def test_edge_year_transition(self):\n        # Test for the 1st Friday of December 2023\n        result = calculate_nth_weekday_in_month(2023, 12, 1, 4)  # Friday is 4\n        expected = datetime.date(2023, 12, 1)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below import datetime\n\n\ndef calculate_nth_weekday_in_month(year: int, month: int, occurrence: int, weekday: int) -> datetime.date:\n    \"\"\"\n    Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n    If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n    This function extends the capability to handle edge cases where the nth weekday might not be present,\n    by providing the closest previous weekday in such cases\n    Args:\n        y (int): The year for which the date is to be calculated.\n        m (int): The month for which the date is to be calculated, where January is 1 and December is 12.\n        n (int): The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n        k (int): The weekday, where Monday is 0 and Sunday is 6.\n\n    Returns:\n        datetime: The calculated date of the nth occurrence of the weekday in the given month and year.\n      If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n * If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n * This function extends the capability to handle edge cases where the nth weekday might not be present,\n * by providing the closest previous weekday in such cases.\n * \n * @param {number} y - The year for which the date is to be calculated.\n * @param {number} m - The month for which the date is to be calculated, where January is 1 and December is 12.\n * @param {number} n - The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n * @param {number} k - The weekday, where Monday is 1 and Sunday is 7.\n * @returns {Date} The calculated date of the nth occurrence of the weekday in the given month and year.\n *                If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n */\nfunction findNthWeekdayOfSpecificYear(y, m, n, k) {}", "test_code": "describe('TestFindNthWeekdayOfSpecificYear', () => {\n  describe('Regular Occurrence', () => {\n      it('should return the 2nd Monday of May 2023', () => {\n          const result = findNthWeekdayOfSpecificYear(2023, 5, 2, 0); // Monday is 0\n          const expected = new Date(2023, 4, 8); // Note: Months are 0-indexed in JavaScript\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('Last Occurrence', () => {\n      it('should return the last Monday of May 2023', () => {\n          const result = findNthWeekdayOfSpecificYear(2023, 5, 5, 0); // Monday is 0\n          const expected = new Date(2023, 4, 29); // Note: Months are 0-indexed in JavaScript\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('First Day is Weekday', () => {\n      it('should return the 1st Tuesday of August 2023', () => {\n          const result = findNthWeekdayOfSpecificYear(2023, 8, 1, 1); // Tuesday is 1\n          const expected = new Date(2023, 7, 1); // Note: Months are 0-indexed in JavaScript\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('Edge Year Transition', () => {\n      it('should return the 1st Friday of December 2023', () => {\n          const result = findNthWeekdayOfSpecificYear(2023, 12, 1, 4); // Friday is 4\n          const expected = new Date(2023, 11, 1); // Note: Months are 0-indexed in JavaScript\n          expect(result).toEqual(expected);\n      });\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n * If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n * This function extends the capability to handle edge cases where the nth weekday might not be present,\n * by providing the closest previous weekday in such cases.\n * \n * @param {number} y - The year for which the date is to be calculated.\n * @param {number} m - The month for which the date is to be calculated, where January is 1 and December is 12.\n * @param {number} n - The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n * @param {number} k - The weekday, where Monday is 1 and Sunday is 7.\n * @returns {Date} The calculated date of the nth occurrence of the weekday in the given month and year.\n *                If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n */\nfunction findNthWeekdayOfSpecificYear(y, m, n, k) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n * If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n * This function extends the capability to handle edge cases where the nth weekday might not be present,\n * by providing the closest previous weekday in such cases.\n * \n * @param y - The year for which the date is to be calculated.\n * @param m - The month for which the date is to be calculated, where January is 1 and December is 12.\n * @param n - The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n * @param k - The weekday, where Monday is 0 and Sunday is 6.\n * @returns The calculated date of the nth occurrence of the weekday in the given month and year.\n *          If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n */\nfunction findNthWeekdayOfSpecificYear(y: number, m: number, n: number, k: number): DateTime {}", "test_code": "describe('TestFindNthWeekdayOfSpecificYear', () => {\n    it('should return the 2nd Monday of May 2023', () => {\n        // Test for the 2nd Monday of May 2023\n        const result = findNthWeekdayOfSpecificYear(2023, 5, 2, 0); // Monday is 0\n        const expected = DateTime.local(2023, 5, 8);\n        expect(result).toEqual(expected);\n    });\n\n    it('should return the last Monday of May 2023', () => {\n        // Test for the 5th Monday of May 2023, which doesn't exist, should return the last Monday\n        const result = findNthWeekdayOfSpecificYear(2023, 5, 5, 0); // Monday is 0\n        const expected = DateTime.local(2023, 5, 29);\n        expect(result).toEqual(expected);\n    });\n\n    it('should return the 1st Tuesday of August 2023', () => {\n        // Test for when the first day of the month is the weekday in question, 1st Tuesday of August 2023\n        const result = findNthWeekdayOfSpecificYear(2023, 8, 1, 1); // Tuesday is 1\n        const expected = DateTime.local(2023, 8, 1);\n        expect(result).toEqual(expected);\n    });\n\n    it('should return the 1st Friday of December 2023', () => {\n        // Test for the 1st Friday of December 2023\n        const result = findNthWeekdayOfSpecificYear(2023, 12, 1, 4); // Friday is 4\n        const expected = DateTime.local(2023, 12, 1);\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n * If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n * This function extends the capability to handle edge cases where the nth weekday might not be present,\n * by providing the closest previous weekday in such cases.\n * \n * @param y - The year for which the date is to be calculated.\n * @param m - The month for which the date is to be calculated, where January is 1 and December is 12.\n * @param n - The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n * @param k - The weekday, where Monday is 0 and Sunday is 6.\n * @returns The calculated date of the nth occurrence of the weekday in the given month and year.\n *          If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n */\nfunction findNthWeekdayOfSpecificYear(y: number, m: number, n: number, k: number): DateTime {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n* @brief Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n* If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n* This function extends the capability to handle edge cases where the nth weekday might not be present,\n* by providing the closest previous weekday in such cases.\n*\n* @param y The year for which the date is to be calculated.\n* @param m The month for which the date is to be calculated, where January is 1 and December is 12.\n* @param n The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n* @param k The weekday, where Monday is 0 and Sunday is 6.\n*\n* @return The calculated date of the nth occurrence of the weekday in the given month and year.\n*         If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n*/\nstd::chrono::sys_days find_nth_weekday_of_specific_year(int y, int m, int n, int k) {}\n", "test_code": "TEST_CASE(\"Test find_nth_weekday_of_specific_year\", \"[find_nth_weekday_of_specific_year]\") {\n    SECTION(\"Regular occurrence\") {\n        // Test for the 2nd Monday of May 2023\n        auto result = find_nth_weekday_of_specific_year(2023, 5, 2, 0);  // Monday is 0\n        auto expected = std::chrono::sys_days{std::chrono::year_month_day{std::chrono::year{2023}, std::chrono::month{5}, std::chrono::day{8}}};\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Last occurrence\") {\n        // Test for the 5th Monday of May 2023, which doesn't exist, should return the last Monday\n        auto result = find_nth_weekday_of_specific_year(2023, 5, 5, 0);  // Monday is 0\n        auto expected = std::chrono::sys_days{std::chrono::year_month_day{std::chrono::year{2023}, std::chrono::month{5}, std::chrono::day{29}}};\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"First day is weekday\") {\n        // Test for when the first day of the month is the weekday in question, 1st Tuesday of August 2023\n        auto result = find_nth_weekday_of_specific_year(2023, 8, 1, 1);  // Tuesday is 1\n        auto expected = std::chrono::sys_days{std::chrono::year_month_day{std::chrono::year{2023}, std::chrono::month{8}, std::chrono::day{1}}};\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Edge year transition\") {\n        // Test for the 1st Friday of December 2023\n        auto result = find_nth_weekday_of_specific_year(2023, 12, 1, 4);  // Friday is 4\n        auto expected = std::chrono::sys_days{std::chrono::year_month_day{std::chrono::year{2023}, std::chrono::month{12}, std::chrono::day{1}}};\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n* @brief Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n* If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n* This function extends the capability to handle edge cases where the nth weekday might not be present,\n* by providing the closest previous weekday in such cases.\n*\n* @param y The year for which the date is to be calculated.\n* @param m The month for which the date is to be calculated, where January is 1 and December is 12.\n* @param n The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n* @param k The weekday, where Monday is 0 and Sunday is 6.\n*\n* @return The calculated date of the nth occurrence of the weekday in the given month and year.\n*         If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n*/\nstd::chrono::sys_days find_nth_weekday_of_specific_year(int y, int m, int n, int k) {}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the date of the nth occurrence of a specific weekday in a given month and year.\n * \n * @param y The year for which the date is to be calculated.\n * @param m The month for which the date is to be calculated, where January is 1 and December is 12.\n * @param n The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n * @param k The weekday, where Monday is 0 and Sunday is 6.\n * @return LocalDate The calculated date of the nth occurrence of the weekday in the given month and year.\n *         If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n */\npublic static LocalDate findNthWeekdayOfSpecificYear(int y, int m, int n, int k) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; // JUnit 4 Test annotation\nimport static org.junit.Assert.assertEquals; // JUnit 4 assertion method\nimport java.time.LocalDate;\n\npublic class Tester {\n\n    @Test\n    public void testRegularOccurrence() {\n        // Test for the 2nd Monday of May 2023\n        LocalDate result = findNthWeekdayOfSpecificYear(2023, 5, 2, 0);  // Monday is 0\n        LocalDate expected = LocalDate.of(2023, 5, 8);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testLastOccurrence() {\n        // Test for the 5th Monday of May 2023, which doesn't exist, should return the last Monday\n        LocalDate result = findNthWeekdayOfSpecificYear(2023, 5, 5, 0);  // Monday is 0\n        LocalDate expected = LocalDate.of(2023, 5, 29);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testFirstDayIsWeekday() {\n        // Test for when the first day of the month is the weekday in question, 1st Tuesday of August 2023\n        LocalDate result = findNthWeekdayOfSpecificYear(2023, 8, 1, 1);  // Tuesday is 1\n        LocalDate expected = LocalDate.of(2023, 8, 1);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testEdgeYearTransition() {\n        // Test for the 1st Friday of December 2023\n        LocalDate result = findNthWeekdayOfSpecificYear(2023, 12, 1, 4);  // Friday is 4\n        LocalDate expected = LocalDate.of(2023, 12, 1);\n        assertEquals(expected, result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Calculates the date of the nth occurrence of a specific weekday in a given month and year.\n * \n * @param y The year for which the date is to be calculated.\n * @param m The month for which the date is to be calculated, where January is 1 and December is 12.\n * @param n The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n * @param k The weekday, where Monday is 0 and Sunday is 6.\n * @return LocalDate The calculated date of the nth occurrence of the weekday in the given month and year.\n *         If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n */\npublic static LocalDate findNthWeekdayOfSpecificYear(int y, int m, int n, int k) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 51, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "convert a point cloud data from the current coordinate system to coordinates in a coordinate system defined by three reference points\n", "language_version_list": {"python": {"code_signature": "from typing import List\nimport numpy as np\n\n\ndef transform_point_cloud_to_reference_frame(point_cloud: np.array, ref_frame_points: List[np.array]) -> np.array:\n    \"\"\"\n    Transforms a point cloud to a new reference frame defined by three points.\n\n    Parameters:\n        point_cloud (np.array): The Nx3 array of points in the original reference frame.\n        ref_frame_points (List): A list of three points (np.array), defining the new reference frame.\n\n    Returns:\n        np.array: Transformed point cloud in the new reference frame.\n    \"\"\"\n", "test_code": "import unittest\nimport numpy as np\n\nclass TestChangeReferenceFrame(unittest.TestCase):\n    def setUp(self):\n        # Basic setup for tests, initialize some common point clouds and frames\n        self.point_cloud = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        self.ref_frame_points = [np.array([0, 0, 0]), np.array([1, 0, 0]), np.array([0, 1, 0])]\n\n    def test_identity_transformation(self):\n        # Test with an identity transformation where the reference frame is the standard basis\n        result = transform_point_cloud_to_reference_frame(self.point_cloud, self.ref_frame_points)\n        np.testing.assert_array_almost_equal(result, self.point_cloud - np.array([0, 0, 0]))\n\n    def test_translation(self):\n        # Only translation no rotation; move the origin\n        frame_points = [np.array([1, 1, 1]), np.array([2, 1, 1]), np.array([1, 2, 1])]\n        result = transform_point_cloud_to_reference_frame(self.point_cloud, frame_points)\n        expected = np.array([[-1. , 0.,  1.], [ 2. , 3.,  4.], [ 5.,  6. , 7.]])\n        np.testing.assert_array_almost_equal(result, expected)\n\n    def test_rotation(self):\n        # Rotation about z-axis by 90 degrees\n        frame_points = [np.array([0, 0, 0]), np.array([0, 1, 0]), np.array([0, 1, 1])]\n        result = transform_point_cloud_to_reference_frame(self.point_cloud, frame_points)\n        expected = np.array([[2. , 3.,  1.], [ 5. , 6.,  4.], [ 8.,  9. , 7.]])\n        np.testing.assert_array_almost_equal(result, expected)\n\n    def test_non_orthonormal_frame(self):\n        # Use non-orthonormal frame to see how function handles it (should normalize internally)\n        frame_points = [np.array([0, 0, 0]), np.array([1, 0, 0]), np.array([1, 1, 0])]\n        result = transform_point_cloud_to_reference_frame(self.point_cloud, frame_points)\n        # Manually compute expected model_answer_result\n        u = np.array([1, 0, 0])\n        v = np.array([0, 1, 0])\n        w = np.cross(u, v)\n        rotation_matrix = np.column_stack((u, v, w))\n        expected = np.dot(self.point_cloud, rotation_matrix.T)\n        np.testing.assert_array_almost_equal(result, expected)\n\n    def test_inverted_frame(self):\n        # Inverting the frame to see if negatives are handled\n        frame_points = [np.array([0, 0, 0]), np.array([-1, 0, 0]), np.array([0, -1, 0])]\n        result = transform_point_cloud_to_reference_frame(self.point_cloud, frame_points)\n        expected = np.dot(self.point_cloud, np.array([[-1, 0, 0], [0, -1, 0], [0, 0, 1]]))\n        np.testing.assert_array_almost_equal(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\nimport numpy as np\n\n\ndef transform_point_cloud_to_reference_frame(point_cloud: np.array, ref_frame_points: List[np.array]) -> np.array:\n    \"\"\"\n    Transforms a point cloud to a new reference frame defined by three points.\n\n    Parameters:\n        point_cloud (np.array): The Nx3 array of points in the original reference frame.\n        ref_frame_points (List): A list of three points (np.array), defining the new reference frame.\n\n    Returns:\n        np.array: Transformed point cloud in the new reference frame.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Transforms a point cloud to a new reference frame defined by three points.\n *\n * @param {Float64Array} pointCloud - The Nx3 array of points in the original reference frame.\n * @param {Array<Float64Array>} refFramePoints - A list of three Float64Arrays, defining the new reference frame.\n * @returns {Float64Array} Transformed point cloud in the new reference frame.\n */\nfunction transformPointCloudToReferenceFrame(pointCloud, refFramePoints) {}", "test_code": "describe('TestChangeReferenceFrame', () => {\n    let pointCloud;\n    let refFramePoints;\n\n    beforeEach(() => {\n        // Basic setup for tests, initialize some common point clouds and frames\n        pointCloud = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n        refFramePoints = [[0, 0, 0], [1, 0, 0], [0, 1, 0]];\n    });\n\n    function arraysAlmostEqual(arr1, arr2, tolerance = 1e-5) {\n        expect(arr1.length).toBe(arr2.length);\n        arr1.forEach((row, i) => {\n            expect(row.length).toBe(arr2[i].length);\n            row.forEach((val, j) => {\n                expect(Math.abs(val - arr2[i][j])).toBeLessThan(tolerance);\n            });\n        });\n    }\n\n    test('test_identity_transformation', () => {\n        // Test with an identity transformation where the reference frame is the standard basis\n        const result = transformPointCloudToReferenceFrame(pointCloud, refFramePoints);\n        const expected = pointCloud.map(point => subtract(point, [0, 0, 0]));\n        arraysAlmostEqual(result, expected);\n    });\n\n    test('test_translation', () => {\n        // Only translation no rotation; move the origin\n        const framePoints = [[1, 1, 1], [2, 1, 1], [1, 2, 1]];\n        const result = transformPointCloudToReferenceFrame(pointCloud, framePoints);\n        const expected = [[-1, 0, 1], [2, 3, 4], [5, 6, 7]];\n        arraysAlmostEqual(result, expected);\n    });\n\n    test('test_rotation', () => {\n        // Rotation about z-axis by 90 degrees\n        const framePoints = [[0, 0, 0], [0, 1, 0], [0, 1, 1]];\n        const result = transformPointCloudToReferenceFrame(pointCloud, framePoints);\n        const expected = [[2, 3, 1], [5, 6, 4], [8, 9, 7]];\n        arraysAlmostEqual(result, expected);\n    });\n\n    test('test_non_orthonormal_frame', () => {\n        // Use non-orthonormal frame to see how function handles it (should normalize internally)\n        const framePoints = [[0, 0, 0], [1, 0, 0], [1, 1, 0]];\n        const result = transformPointCloudToReferenceFrame(pointCloud, framePoints);\n        \n        const u = [1, 0, 0];\n        const v = [0, 1, 0];\n        const w = cross(u, v);\n        const rotationMatrix = transpose([u, v, w]);\n        const expected = pointCloud.map(point => column(point, 3).map((row, i) => row * rotationMatrix[i][i]));\n        \n        arraysAlmostEqual(result, expected);\n    });\n\n    test('test_inverted_frame', () => {\n        // Inverting the frame to see if negatives are handled\n        const framePoints = [[0, 0, 0], [-1, 0, 0], [0, -1, 0]];\n        const result = transformPointCloudToReferenceFrame(pointCloud, framePoints);\n        \n        const transformationMatrix = [[-1, 0, 0], [0, -1, 0], [0, 0, 1]];\n        const expected = pointCloud.map(point => column(point, 3).map((row, i) => row * transformationMatrix[i][i]));\n        \n        arraysAlmostEqual(result, expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Transforms a point cloud to a new reference frame defined by three points.\n *\n * @param {Float64Array} pointCloud - The Nx3 array of points in the original reference frame.\n * @param {Array<Float64Array>} refFramePoints - A list of three Float64Arrays, defining the new reference frame.\n * @returns {Float64Array} Transformed point cloud in the new reference frame.\n */\nfunction transformPointCloudToReferenceFrame(pointCloud, refFramePoints) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Transforms a point cloud to a new reference frame defined by three points.\n *\n * @param {number[][]} pointCloud - An array of 3D points where each point is represented \n * as an array of three numbers [x, y, z]. \n * Example: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n *\n * @param {number[][]} refFramePoints - An array of 3D points that define the new reference frame.\n * This is typically an array of at least three non-collinear points. Each point should be \n * represented as an array of three numbers [x, y, z].\n * Example: [[0, 0, 0], [1, 0, 0], [0, 1, 0]]\n *\n * @returns {number[][]} A new array of 3D points, each transformed to the specified reference frame.\n * The returned array maintains the same structure as the input point cloud.\n * Example: [[1, 2, 3], [4, 5, 6]] will be transformed based on the reference frame points.\n *\n * @throws {Error} Throws an error if the input point cloud or reference frame points are \n * invalid (e.g., if they do not contain three points, or if any point is not 3-dimensional).\n *\n * @example\n * const pointCloud = [\n *     [1, 2, 3],\n *     [4, 5, 6],\n *     [7, 8, 9]\n * ];\n * \n * const refFramePoints = [\n *     [0, 0, 0],\n *     [1, 0, 0],\n *     [0, 1, 0]\n * ];\n * \n */\nfunction transformPointCloudToReferenceFrame(\n    pointCloud: number[][],\n    refFramePoints: number[][]\n): number[][] {}", "test_code": "describe('TestChangeReferenceFrame', () => {\n    let pointCloud;\n    let refFramePoints;\n\n    beforeEach(() => {\n        // Basic setup for tests, initialize some common point clouds and frames\n        pointCloud = [\n            [1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]\n        ];\n        refFramePoints = [\n            [0, 0, 0],\n            [1, 0, 0],\n            [0, 1, 0]\n        ];\n    });\n\n    test('identity transformation', () => {\n        // Test with an identity transformation where the reference frame is the standard basis\n        const result = transformPointCloudToReferenceFrame(pointCloud, refFramePoints);\n        const expected = pointCloud.map(point => point.map(coord => coord - 0)); // No change expected\n        expect(result).toEqual(expected);\n    });\n\n    test('translation', () => {\n        // Only translation, no rotation; move the origin\n        const framePoints = [\n            [1, 1, 1],\n            [2, 1, 1],\n            [1, 2, 1]\n        ];\n        const result = transformPointCloudToReferenceFrame(pointCloud, framePoints);\n        const expected = [\n            [-1, 0, 1],\n            [2, 3, 4],\n            [5, 6, 7]\n        ];\n        expect(result).toEqual(expected);\n    });\n\n    test('rotation', () => {\n        // Rotation about z-axis by 90 degrees\n        const framePoints = [\n            [0, 0, 0],\n            [0, 1, 0],\n            [0, 1, 1]\n        ];\n        const result = transformPointCloudToReferenceFrame(pointCloud, framePoints);\n        const expected = [\n            [2, 3, 1],\n            [5, 6, 4],\n            [8, 9, 7]\n        ];\n        expect(result).toEqual(expected);\n    });\n\n    test('non-orthonormal frame', () => {\n        // Use non-orthonormal frame to see how function handles it\n        const framePoints = [\n            [0, 0, 0],\n            [1, 0, 0],\n            [1, 1, 0]\n        ];\n        const result = transformPointCloudToReferenceFrame(pointCloud, framePoints);\n        // Manually compute expected model_answer_result\n        const u = [1, 0, 0];\n        const v = [0, 1, 0];\n        const w = crossProduct(u, v); // Assuming you have a crossProduct function defined\n        const rotationMatrix = [u, v, w];\n        const expected = pointCloud.map(point => {\n            return point.map((_, i) => point.reduce((sum, val, j) => sum + val * rotationMatrix[j][i], 0));\n        });\n        expect(result).toEqual(expected);\n    });\n\n    test('inverted frame', () => {\n        // Inverting the frame to see if negatives are handled\n        const framePoints = [\n            [0, 0, 0],\n            [-1, 0, 0],\n            [0, -1, 0]\n        ];\n        const result = transformPointCloudToReferenceFrame(pointCloud, framePoints);\n        const expected = pointCloud.map(point => {\n            return [\n                -point[0],\n                -point[1],\n                point[2]\n            ];\n        });\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Transforms a point cloud to a new reference frame defined by three points.\n *\n * @param {number[][]} pointCloud - An array of 3D points where each point is represented \n * as an array of three numbers [x, y, z]. \n * Example: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n *\n * @param {number[][]} refFramePoints - An array of 3D points that define the new reference frame.\n * This is typically an array of at least three non-collinear points. Each point should be \n * represented as an array of three numbers [x, y, z].\n * Example: [[0, 0, 0], [1, 0, 0], [0, 1, 0]]\n *\n * @returns {number[][]} A new array of 3D points, each transformed to the specified reference frame.\n * The returned array maintains the same structure as the input point cloud.\n * Example: [[1, 2, 3], [4, 5, 6]] will be transformed based on the reference frame points.\n *\n * @throws {Error} Throws an error if the input point cloud or reference frame points are \n * invalid (e.g., if they do not contain three points, or if any point is not 3-dimensional).\n *\n * @example\n * const pointCloud = [\n *     [1, 2, 3],\n *     [4, 5, 6],\n *     [7, 8, 9]\n * ];\n * \n * const refFramePoints = [\n *     [0, 0, 0],\n *     [1, 0, 0],\n *     [0, 1, 0]\n * ];\n * \n */\nfunction transformPointCloudToReferenceFrame(\n    pointCloud: number[][],\n    refFramePoints: number[][]\n): number[][] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Changes the reference frame of a point cloud based on three reference points.\n *\n * This function takes a point cloud and a set of three points that define a new reference frame.\n * It calculates a rotation matrix and a translation vector to transform the point cloud into \n * the new reference frame, which is defined by the three input points.\n *\n * @param pointCloud A MatrixXd representing a collection of 3D points (Nx3), where each row \n *                   corresponds to a point in the format [x, y, z].\n * @param refFramePoints A vector of Vector3d containing three points (A, B, C) in 3D space \n *                       that define the new reference frame. These points should not be collinear.\n *\n * @return A MatrixXd representing the transformed point cloud in the new reference frame.\n */\n MatrixXd changeReferenceFrame(const MatrixXd &pointCloud, const vector<Vector3d> &refFramePoints) {}", "test_code": "TEST_CASE(\"Change Reference Frame\") {\n    // Initializing the point cloud and reference frame points\n    Eigen::MatrixXd pointCloud(3, 3);\n    pointCloud << 1, 2, 3,\n                  4, 5, 6,\n                  7, 8, 9;\n\n    SECTION(\"Identity Transformation\") {\n        std::vector<Eigen::Vector3d> refFramePoints = {\n            {0, 0, 0}, \n            {1, 0, 0}, \n            {0, 1, 0}\n        };\n        Eigen::MatrixXd result = changeReferenceFrame(pointCloud, refFramePoints);\n        Eigen::MatrixXd expected = pointCloud; // Expect the same because identity\n        REQUIRE((result - expected).norm() < 1e-9); // Use a small tolerance for floating-point comparison\n    }\n\n    SECTION(\"Translation\") {\n        std::vector<Eigen::Vector3d> framePoints = {\n            {1, 1, 1}, \n            {2, 1, 1}, \n            {1, 2, 1}\n        };\n        Eigen::MatrixXd result = changeReferenceFrame(pointCloud, framePoints);\n        Eigen::MatrixXd expected(3, 3);\n        expected << -1.0, 0.0, 1.0,\n                    2.0, 3.0, 4.0,\n                    5.0, 6.0, 7.0;\n        REQUIRE((result - expected).norm() < 1e-9);\n    }\n\n    SECTION(\"Rotation\") {\n        std::vector<Eigen::Vector3d> framePoints = {\n            {0, 0, 0}, \n            {0, 1, 0}, \n            {0, 1, 1}\n        };\n        Eigen::MatrixXd result = changeReferenceFrame(pointCloud, framePoints);\n        Eigen::MatrixXd expected(3, 3);\n        expected << 2.0, 3.0, 1.0,\n                    5.0, 6.0, 4.0,\n                    8.0, 9.0, 7.0;\n        REQUIRE((result - expected).norm() < 1e-9);\n    }\n\n    SECTION(\"Non-Orthonormal Frame\") {\n        std::vector<Eigen::Vector3d> framePoints = {\n            {0, 0, 0},\n            {1, 0, 0},\n            {1, 1, 0}\n        };\n        Eigen::Vector3d u = {1, 0, 0};\n        Eigen::Vector3d v = {0, 1, 0};\n        Eigen::Vector3d w = u.cross(v);\n        Eigen::Matrix3d rotationMatrix;\n        rotationMatrix.col(0) = u;\n        rotationMatrix.col(1) = v;\n        rotationMatrix.col(2) = w;\n        \n        Eigen::MatrixXd result = changeReferenceFrame(pointCloud, framePoints);\n        Eigen::MatrixXd expected = pointCloud * rotationMatrix.transpose();\n        REQUIRE((result - expected).norm() < 1e-9);\n    }\n\n    SECTION(\"Inverted Frame\") {\n        std::vector<Eigen::Vector3d> framePoints = {\n            {0, 0, 0},\n            {-1, 0, 0},\n            {0, -1, 0}\n        };\n        Eigen::MatrixXd rotationMatrix(3, 3);\n        rotationMatrix << -1, 0, 0,\n                          0, -1, 0,\n                          0, 0, 1;\n\n        Eigen::MatrixXd result = changeReferenceFrame(pointCloud, framePoints);\n        Eigen::MatrixXd expected = pointCloud * rotationMatrix;\n        REQUIRE((result - expected).norm() < 1e-9);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Changes the reference frame of a point cloud based on three reference points.\n *\n * This function takes a point cloud and a set of three points that define a new reference frame.\n * It calculates a rotation matrix and a translation vector to transform the point cloud into \n * the new reference frame, which is defined by the three input points.\n *\n * @param pointCloud A MatrixXd representing a collection of 3D points (Nx3), where each row \n *                   corresponds to a point in the format [x, y, z].\n * @param refFramePoints A vector of Vector3d containing three points (A, B, C) in 3D space \n *                       that define the new reference frame. These points should not be collinear.\n *\n * @return A MatrixXd representing the transformed point cloud in the new reference frame.\n */\n MatrixXd changeReferenceFrame(const MatrixXd &pointCloud, const vector<Vector3d> &refFramePoints) {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.jupiter.api.Test;\n\n\nimport java.util.Arrays;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    private double[][] pointCloud;\n    private double[][] refFramePoints;\n\n    @Before\n    public void setUp() {\n        // Basic setup for tests, initialize some common point clouds and frames\n        pointCloud = new double[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        refFramePoints = new double[][]{{0, 0, 0}, {1, 0, 0}, {0, 1, 0}};\n    }\n\n    @Test\n    public void testIdentityTransformation() {\n        // Test with an identity transformation where the reference frame is the standard basis\n        double[][] result = transformPointCloudToReferenceFrame(pointCloud, refFramePoints);\n        double[][] expected = new double[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testTranslation() {\n        // Only translation no rotation; move the origin\n        double[][] framePoints = new double[][]{{1, 1, 1}, {2, 1, 1}, {1, 2, 1}};\n        double[][] result = transformPointCloudToReferenceFrame(pointCloud, framePoints);\n        double[][] expected = new double[][]{{-1, 0, 1}, {2, 3, 4}, {5, 6, 7}};\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testRotation() {\n        // Rotation about z-axis by 90 degrees\n        double[][] framePoints = new double[][]{{0, 0, 0}, {0, 1, 0}, {0, 1, 1}};\n        double[][] result = transformPointCloudToReferenceFrame(pointCloud, framePoints);\n        double[][] expected = new double[][]{{2, 3, 1}, {5, 6, 4}, {8, 9, 7}};\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testNonOrthonormalFrame() {\n        // Use non-orthonormal frame to see how function handles it (should normalize internally)\n        double[][] framePoints = new double[][]{{0, 0, 0}, {1, 0, 0}, {1, 1, 0}};\n        double[][] result = transformPointCloudToReferenceFrame(pointCloud, framePoints);\n\n        // Manually compute expected result\n        double[] u = new double[]{1, 0, 0};\n        double[] v = new double[]{0, 1, 0};\n        double[] w = crossProduct(u, v);\n        double[][] rotationMatrix = new double[][]{u, v, w};\n        double[][] expected = matrixMultiply(pointCloud, transpose(rotationMatrix));\n\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testInvertedFrame() {\n        // Inverting the frame to see if negatives are handled\n        double[][] framePoints = new double[][]{{0, 0, 0}, {-1, 0, 0}, {0, -1, 0}};\n        double[][] result = transformPointCloudToReferenceFrame(pointCloud, framePoints);\n        double[][] expected = matrixMultiply(pointCloud, new double[][]{{-1, 0, 0}, {0, -1, 0}, {0, 0, 1}});\n\n        assertArrayEquals(expected, result);\n    }\n\n    private double[] crossProduct(double[] a, double[] b) {\n        return new double[]{\n                a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0]\n        };\n    }\n\n    private double[][] transpose(double[][] matrix) {\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        double[][] transposed = new double[cols][rows];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                transposed[j][i] = matrix[i][j];\n            }\n        }\n        return transposed;\n    }\n\n    private double[][] matrixMultiply(double[][] a, double[][] b) {\n        // Check if the number of columns in a equals the number of rows in b\n        if (a[0].length != b.length) {\n            throw new IllegalArgumentException(\"Matrix A columns must match Matrix B rows.\");\n        }\n\n        // Initialize the result matrix with the correct dimensions\n        double[][] result = new double[a.length][b[0].length];\n\n        // Perform matrix multiplication\n        for (int i = 0; i < a.length; i++) { // Iterate over rows of A\n            for (int j = 0; j < b[0].length; j++) { // Iterate over columns of B\n                for (int k = 0; k < a[0].length; k++) { // Iterate over columns of A\n                    result[i][j] += a[i][k] * b[k][j]; // Calculate the dot product\n                }\n            }\n        }\n\n        return result; // Return the resulting matrix\n    }\n}\n", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 52, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "rename the windows file path string, replacing the colon: in the file name with the \"_\"", "language_version_list": {"python": {"code_signature": "def rename_file_path(path: str) -> str:\n    \"\"\"\n    Renames a Windows file path by replacing colons in the filename with underscores.\n\n    Parameters:\n        path (str): The original file path.\n\n    Returns:\n        str: The modified file path with colons in the filename replaced by underscores.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestRenameFilePath(unittest.TestCase):\n    def test_rename_with_colon_in_filename(self):\n        # Test path with colon in the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\report:2023.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\report_2023.txt'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_without_colon_in_filename(self):\n        # Test path without colon in the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_with_multiple_colons_in_filename(self):\n        # Test path with multiple colons in the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\project:report:2023.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\project_report_2023.txt'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_with_colon_at_end_of_filename(self):\n        # Test path with a colon at the end of the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\backup:'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\backup_'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_with_colon_at_start_of_filename(self):\n        # Test path with a colon at the start of the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\:initial_setup.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\_initial_setup.txt'\n        self.assertEqual(rename_file_path(path), expected)\n", "prompt": "please write a python function , the function signature as below def rename_file_path(path: str) -> str:\n    \"\"\"\n    Renames a Windows file path by replacing colons in the filename with underscores.\n\n    Parameters:\n        path (str): The original file path.\n\n    Returns:\n        str: The modified file path with colons in the filename replaced by underscores.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "import path from 'path';\n/**\n * Renames a Windows file path by replacing colons in the filename with underscores.\n * \n * @param {string} path - The original file path.\n * @returns {string} The modified file path with colons in the filename replaced by underscores.\n */\nfunction renameFilePath(path) {}", "test_code": "describe('TestRenameFilePath', () => {\n  it('should rename a path with colon in the filename', () => {\n      // Test path with colon in the filename\n      const path = 'C:\\\\Users\\\\example\\\\Documents\\\\report:2023.txt';\n      const expected = 'C:\\\\Users\\\\example\\\\Documents\\\\report_2023.txt';\n      expect(renameFilePath(path)).toEqual(expected);\n  });\n\n  it('should not rename a path without colon in the filename', () => {\n      // Test path without colon in the filename\n      const path = 'C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt';\n      const expected = 'C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt';\n      expect(renameFilePath(path)).toEqual(expected);\n  });\n\n  it('should rename a path with multiple colons in the filename', () => {\n      // Test path with multiple colons in the filename\n      const path = 'C:\\\\Users\\\\example\\\\Documents\\\\project:report:2023.txt';\n      const expected = 'C:\\\\Users\\\\example\\\\Documents\\\\project_report_2023.txt';\n      expect(renameFilePath(path)).toEqual(expected);\n  });\n\n  it('should rename a path with a colon at the end of the filename', () => {\n      // Test path with a colon at the end of the filename\n      const path = 'C:\\\\Users\\\\example\\\\Documents\\\\backup:';\n      const expected = 'C:\\\\Users\\\\example\\\\Documents\\\\backup_';\n      expect(renameFilePath(path)).toEqual(expected);\n  });\n\n  it('should rename a path with a colon at the start of the filename', () => {\n      // Test path with a colon at the start of the filename\n      const path = 'C:\\\\Users\\\\example\\\\Documents\\\\:initial_setup.txt';\n      const expected = 'C:\\\\Users\\\\example\\\\Documents\\\\_initial_setup.txt';\n      expect(renameFilePath(path)).toEqual(expected);\n  });\n});", "prompt": "please write a javascript function , the function signature as below import path from 'path';\n/**\n * Renames a Windows file path by replacing colons in the filename with underscores.\n * \n * @param {string} path - The original file path.\n * @returns {string} The modified file path with colons in the filename replaced by underscores.\n */\nfunction renameFilePath(path) {}", "addition_info": ""}, "typescript": {"code_signature": "import path  from \"path\";\n/**\n * Renames a Windows file path by replacing colons in the filename with underscores.\n * \n * @param {string} path - The original file path.\n * @returns {string} - The modified file path with colons in the filename replaced by underscores.\n */\nfunction renameFilePath(path: string): string {}", "test_code": "describe('TestRenameFilePath', () => {\n  it('should rename with colon in the filename', () => {\n    // Test path with colon in the filename\n    const path = 'C:\\\\Users\\\\example\\\\Documents\\\\report:2023.txt';\n    const expected = 'C:\\\\Users\\\\example\\\\Documents\\\\report_2023.txt';\n    expect(renameFilePath(path)).toEqual(expected);\n  });\n\n  it('should rename without colon in the filename', () => {\n    // Test path without colon in the filename\n    const path = 'C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt';\n    const expected = 'C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt';\n    expect(renameFilePath(path)).toEqual(expected);\n  });\n\n  it('should rename with multiple colons in the filename', () => {\n    // Test path with multiple colons in the filename\n    const path = 'C:\\\\Users\\\\example\\\\Documents\\\\project:report:2023.txt';\n    const expected = 'C:\\\\Users\\\\example\\\\Documents\\\\project_report_2023.txt';\n    expect(renameFilePath(path)).toEqual(expected);\n  });\n\n  it('should rename with colon at the end of the filename', () => {\n    // Test path with a colon at the end of the filename\n    const path = 'C:\\\\Users\\\\example\\\\Documents\\\\backup:';\n    const expected = 'C:\\\\Users\\\\example\\\\Documents\\\\backup_';\n    expect(renameFilePath(path)).toEqual(expected);\n  });\n\n  it('should rename with colon at the start of the filename', () => {\n    // Test path with a colon at the start of the filename\n    const path = 'C:\\\\Users\\\\example\\\\Documents\\\\:initial_setup.txt';\n    const expected = 'C:\\\\Users\\\\example\\\\Documents\\\\_initial_setup.txt';\n    expect(renameFilePath(path)).toEqual(expected);\n  });\n});", "prompt": "please write a typescript function , the function signature as below import path  from \"path\";\n/**\n * Renames a Windows file path by replacing colons in the filename with underscores.\n * \n * @param {string} path - The original file path.\n * @returns {string} - The modified file path with colons in the filename replaced by underscores.\n */\nfunction renameFilePath(path: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Renames a Windows file path by replacing colons in the filename with underscores.\n *\n * @param path The original file path.\n * @return The modified file path with colons in the filename replaced by underscores.\n */\nstd::string rename_file_path(const std::string& path) {}", "test_code": "TEST_CASE(\"Test rename_file_path function\", \"[rename_file_path]\") {\n    SECTION(\"Test path with colon in the filename\") {\n        // Test path with colon in the filename\n        std::string path = \"C:\\\\Users\\\\example\\\\Documents\\\\report:2023.txt\";\n        std::string expected = \"C:\\\\Users\\\\example\\\\Documents\\\\report_2023.txt\";\n        REQUIRE(rename_file_path(path) == expected);\n    }\n\n    SECTION(\"Test path without colon in the filename\") {\n        // Test path without colon in the filename\n        std::string path = \"C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt\";\n        std::string expected = \"C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt\";\n        REQUIRE(rename_file_path(path) == expected);\n    }\n\n    SECTION(\"Test path with multiple colons in the filename\") {\n        // Test path with multiple colons in the filename\n        std::string path = \"C:\\\\Users\\\\example\\\\Documents\\\\project:report:2023.txt\";\n        std::string expected = \"C:\\\\Users\\\\example\\\\Documents\\\\project_report_2023.txt\";\n        REQUIRE(rename_file_path(path) == expected);\n    }\n\n    SECTION(\"Test path with a colon at the end of the filename\") {\n        // Test path with a colon at the end of the filename\n        std::string path = \"C:\\\\Users\\\\example\\\\Documents\\\\backup:\";\n        std::string expected = \"C:\\\\Users\\\\example\\\\Documents\\\\backup_\";\n        REQUIRE(rename_file_path(path) == expected);\n    }\n\n    SECTION(\"Test path with a colon at the start of the filename\") {\n        // Test path with a colon at the start of the filename\n        std::string path = \"C:\\\\Users\\\\example\\\\Documents\\\\:initial_setup.txt\";\n        std::string expected = \"C:\\\\Users\\\\example\\\\Documents\\\\_initial_setup.txt\";\n        REQUIRE(rename_file_path(path) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Renames a Windows file path by replacing colons in the filename with underscores.\n *\n * @param path The original file path.\n * @return The modified file path with colons in the filename replaced by underscores.\n */\nstd::string rename_file_path(const std::string& path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Renames a Windows file path by replacing colons in the filename with underscores.\n *\n * @param path The original file path.\n * @return The modified file path with colons in the filename replaced by underscores.\n */\npublic static String renameFilePath(String path) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; // Change to JUnit 4 Test import\n\nimport static org.junit.Assert.assertEquals; // Change to JUnit 4 assertion\nimport static org.real.temp.Answer.*;\n\n/**\n * Test cases for the renameFilePath method.\n */\npublic class Tester {\n\n    /**\n     * Tests renaming a file path with a colon in the filename.\n     */\n    @Test\n    public void testRenameWithColonInFilename() {\n        // Test path with colon in the filename\n        String path = \"C:\\\\Users\\\\example\\\\Documents\\\\report:2023.txt\";\n        String expected = \"C:\\\\Users\\\\example\\\\Documents\\\\report_2023.txt\";\n        assertEquals(expected, renameFilePath(path));\n    }\n\n    /**\n     * Tests renaming a file path without a colon in the filename.\n     */\n    @Test\n    public void testRenameWithoutColonInFilename() {\n        // Test path without colon in the filename\n        String path = \"C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt\";\n        String expected = \"C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt\";\n        assertEquals(expected, renameFilePath(path));\n    }\n\n    /**\n     * Tests renaming a file path with multiple colons in the filename.\n     */\n    @Test\n    public void testRenameWithMultipleColonsInFilename() {\n        // Test path with multiple colons in the filename\n        String path = \"C:\\\\Users\\\\example\\\\Documents\\\\project:report:2023.txt\";\n        String expected = \"C:\\\\Users\\\\example\\\\Documents\\\\project_report_2023.txt\";\n        assertEquals(expected, renameFilePath(path));\n    }\n\n    /**\n     * Tests renaming a file path with a colon at the end of the filename.\n     */\n    @Test\n    public void testRenameWithColonAtEndOfFilename() {\n        // Test path with a colon at the end of the filename\n        String path = \"C:\\\\Users\\\\example\\\\Documents\\\\backup:\";\n        String expected = \"C:\\\\Users\\\\example\\\\Documents\\\\backup_\";\n        assertEquals(expected, renameFilePath(path));\n    }\n\n    /**\n     * Tests renaming a file path with a colon at the start of the filename.\n     */\n    @Test\n    public void testRenameWithColonAtStartOfFilename() {\n        // Test path with a colon at the start of the filename\n        String path = \"C:\\\\Users\\\\example\\\\Documents\\\\:initial_setup.txt\";\n        String expected = \"C:\\\\Users\\\\example\\\\Documents\\\\_initial_setup.txt\";\n        assertEquals(expected, renameFilePath(path));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Renames a Windows file path by replacing colons in the filename with underscores.\n *\n * @param path The original file path.\n * @return The modified file path with colons in the filename replaced by underscores.\n */\npublic static String renameFilePath(String path) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 53, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "computes and returns the size of an object in bytes in memory\n", "language_version_list": {"python": {"code_signature": "def size_in_bytes(obj) -> int:\n    \"\"\"\n    computes and returns the size of an object in bytes in memory\n\n    Args:\n        obj (any): question object\n\n    Returns: the size of this object in bytes in memory\n\n    \"\"\"\n", "test_code": "import unittest\nimport sys\n\nclass TestSizeInBytes(unittest.TestCase):\n\n    def test_size_of_integer(self):\n        # Test the size of an integer\n        integer_value = 42\n        expected_size = sys.getsizeof(integer_value)\n        result_size = size_in_bytes(integer_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_string(self):\n        # Test the size of a string\n        string_value = \"Hello, world!\"\n        expected_size = sys.getsizeof(string_value)\n        result_size = size_in_bytes(string_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_list(self):\n        # Test the size of a list\n        list_value = [1, 2, 3, 4, 5]\n        expected_size = sys.getsizeof(list_value)\n        result_size = size_in_bytes(list_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_dictionary(self):\n        # Test the size of a dictionary\n        dict_value = {'key1': 'value1', 'key2': 'value2'}\n        expected_size = sys.getsizeof(dict_value)\n        result_size = size_in_bytes(dict_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_custom_object(self):\n        # Test the size of a custom object\n        class CustomObject:\n            def __init__(self):\n                self.attr1 = 'a'\n                self.attr2 = 123\n        custom_obj = CustomObject()\n        expected_size = sys.getsizeof(custom_obj)  # Note: Does not include size of attributes unless explicitly calculated\n        result_size = size_in_bytes(custom_obj)\n        self.assertEqual(result_size, expected_size)", "prompt": "please write a python function , the function signature as below def size_in_bytes(obj) -> int:\n    \"\"\"\n    computes and returns the size of an object in bytes in memory\n\n    Args:\n        obj (any): question object\n\n    Returns: the size of this object in bytes in memory\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 54, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "process a list of strings, removing the three consecutive backticks from each string", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef remove_triple_backticks(string_list: List[str]) -> List[str]:\n    \"\"\"\n    process a list of strings, removing the three consecutive backticks from each string\n    Args:\n        string_list (List[str]): The list of strings to process.\n\n    Returns:\n        A new list with all instances of three consecutive backticks removed from each string.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestRemoveTripleBackticks(unittest.TestCase):\n\n    def test_remove_triple_backticks_basic(self):\n        # Test basic functionality\n        input_strings = ['Here is ```code``` example', 'Another ```example``` here', 'No backticks here']\n        expected_output = ['Here is code example', 'Another example here', 'No backticks here']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_strings_with_multiple_instances(self):\n        # Test strings containing multiple instances of triple backticks\n        input_strings = ['Multiple ```backticks``` in ```one``` string']\n        expected_output = ['Multiple backticks in one string']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_empty_strings(self):\n        # Test with empty strings\n        input_strings = ['']\n        expected_output = ['']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_no_triple_backticks(self):\n        # Test strings that do not contain triple backticks\n        input_strings = ['Just a normal string', 'Another normal string']\n        expected_output = ['Just a normal string', 'Another normal string']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_edge_cases(self):\n        # Test edge cases like strings made entirely of triple backticks\n        input_strings = ['```', '```more```', 'text``````']\n        expected_output = ['', 'more', 'text']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef remove_triple_backticks(string_list: List[str]) -> List[str]:\n    \"\"\"\n    process a list of strings, removing the three consecutive backticks from each string\n    Args:\n        string_list (List[str]): The list of strings to process.\n\n    Returns:\n        A new list with all instances of three consecutive backticks removed from each string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Processes an array of strings, removing all occurrences of three consecutive backticks from each string.\n *\n * @param {string[]} stringList - The array of strings to process.\n * @returns {string[]} A new array with all instances of three consecutive backticks removed from each string.\n */\nfunction removeTripleBackticks(stringList) {}", "test_code": "describe('TestRemoveTripleBackticks', () => {\n  describe('Basic functionality', () => {\n      it('should handle basic removal of triple backticks', () => {\n          const inputStrings = ['Here is ```code``` example', 'Another ```example``` here', 'No backticks here'];\n          const expectedOutput = ['Here is code example', 'Another example here', 'No backticks here'];\n          expect(removeTripleBackticks(inputStrings)).toEqual(expectedOutput);\n      });\n  });\n\n  describe('Strings with multiple instances of triple backticks', () => {\n      it('should handle multiple instances of triple backticks', () => {\n          const inputStrings = ['Multiple ```backticks``` in ```one``` string'];\n          const expectedOutput = ['Multiple backticks in one string'];\n          expect(removeTripleBackticks(inputStrings)).toEqual(expectedOutput);\n      });\n  });\n\n  describe('Empty strings', () => {\n      it('should handle empty strings', () => {\n          const inputStrings = [''];\n          const expectedOutput = [''];\n          expect(removeTripleBackticks(inputStrings)).toEqual(expectedOutput);\n      });\n  });\n\n  describe('Strings without triple backticks', () => {\n      it('should handle strings without triple backticks', () => {\n          const inputStrings = ['Just a normal string', 'Another normal string'];\n          const expectedOutput = ['Just a normal string', 'Another normal string'];\n          expect(removeTripleBackticks(inputStrings)).toEqual(expectedOutput);\n      });\n  });\n\n  describe('Edge cases', () => {\n      it('should handle edge cases like strings made entirely of triple backticks', () => {\n          const inputStrings = ['```', '```more```', 'text``````'];\n          const expectedOutput = ['', 'more', 'text'];\n          expect(removeTripleBackticks(inputStrings)).toEqual(expectedOutput);\n      });\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Processes an array of strings, removing all occurrences of three consecutive backticks from each string.\n *\n * @param {string[]} stringList - The array of strings to process.\n * @returns {string[]} A new array with all instances of three consecutive backticks removed from each string.\n */\nfunction removeTripleBackticks(stringList) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Processes a list of strings, removing all occurrences of three consecutive backticks from each string.\n * \n * @param stringList - The list of strings to process.\n * @returns A new list with all instances of three consecutive backticks removed from each string.\n */\nfunction removeTripleBackticks(stringList: string[]): string[] {}", "test_code": "describe('TestRemoveTripleBackticks', () => {\n  describe('Basic functionality', () => {\n      it('should handle basic removal of triple backticks', () => {\n          const inputStrings = ['Here is ```code``` example', 'Another ```example``` here', 'No backticks here'];\n          const expectedOutput = ['Here is code example', 'Another example here', 'No backticks here'];\n          expect(removeTripleBackticks(inputStrings)).toEqual(expectedOutput);\n      });\n  });\n\n  describe('Strings with multiple instances of triple backticks', () => {\n      it('should handle multiple instances of triple backticks', () => {\n          const inputStrings = ['Multiple ```backticks``` in ```one``` string'];\n          const expectedOutput = ['Multiple backticks in one string'];\n          expect(removeTripleBackticks(inputStrings)).toEqual(expectedOutput);\n      });\n  });\n\n  describe('Empty strings', () => {\n      it('should handle empty strings', () => {\n          const inputStrings = [''];\n          const expectedOutput = [''];\n          expect(removeTripleBackticks(inputStrings)).toEqual(expectedOutput);\n      });\n  });\n\n  describe('Strings without triple backticks', () => {\n      it('should handle strings without triple backticks', () => {\n          const inputStrings = ['Just a normal string', 'Another normal string'];\n          const expectedOutput = ['Just a normal string', 'Another normal string'];\n          expect(removeTripleBackticks(inputStrings)).toEqual(expectedOutput);\n      });\n  });\n\n  describe('Edge cases', () => {\n      it('should handle edge cases like strings made entirely of triple backticks', () => {\n          const inputStrings = ['```', '```more```', 'text``````'];\n          const expectedOutput = ['', 'more', 'text'];\n          expect(removeTripleBackticks(inputStrings)).toEqual(expectedOutput);\n      });\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Processes a list of strings, removing all occurrences of three consecutive backticks from each string.\n * \n * @param stringList - The list of strings to process.\n * @returns A new list with all instances of three consecutive backticks removed from each string.\n */\nfunction removeTripleBackticks(stringList: string[]): string[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Processes a list of strings, removing all occurrences of three consecutive backticks from each string.\n *\n * @param string_list The list of strings to process.\n * @return A new list with all instances of three consecutive backticks removed from each string.\n */\nstd::vector<std::string> remove_triple_backticks(const std::vector<std::string>& string_list) {}", "test_code": "TEST_CASE(\"Test remove_triple_backticks functionality\") {\n    SECTION(\"Basic functionality\") {\n        // Test basic functionality\n        std::vector<std::string> input_strings = {\"Here is ```code``` example\", \"Another ```example``` here\", \"No backticks here\"};\n        std::vector<std::string> expected_output = {\"Here is code example\", \"Another example here\", \"No backticks here\"};\n        REQUIRE(remove_triple_backticks(input_strings) == expected_output);\n    }\n\n    SECTION(\"Strings with multiple instances of triple backticks\") {\n        // Test strings containing multiple instances of triple backticks\n        std::vector<std::string> input_strings = {\"Multiple ```backticks``` in ```one``` string\"};\n        std::vector<std::string> expected_output = {\"Multiple backticks in one string\"};\n        REQUIRE(remove_triple_backticks(input_strings) == expected_output);\n    }\n\n    SECTION(\"Empty strings\") {\n        // Test with empty strings\n        std::vector<std::string> input_strings = {\"\"};\n        std::vector<std::string> expected_output = {\"\"};\n        REQUIRE(remove_triple_backticks(input_strings) == expected_output);\n    }\n\n    SECTION(\"Strings that do not contain triple backticks\") {\n        // Test strings that do not contain triple backticks\n        std::vector<std::string> input_strings = {\"Just a normal string\", \"Another normal string\"};\n        std::vector<std::string> expected_output = {\"Just a normal string\", \"Another normal string\"};\n        REQUIRE(remove_triple_backticks(input_strings) == expected_output);\n    }\n\n    SECTION(\"Edge cases\") {\n        // Test edge cases like strings made entirely of triple backticks\n        std::vector<std::string> input_strings = {\"```\", \"```more```\", \"text``````\"};\n        std::vector<std::string> expected_output = {\"\", \"more\", \"text\"};\n        REQUIRE(remove_triple_backticks(input_strings) == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Processes a list of strings, removing all occurrences of three consecutive backticks from each string.\n *\n * @param string_list The list of strings to process.\n * @return A new list with all instances of three consecutive backticks removed from each string.\n */\nstd::vector<std::string> remove_triple_backticks(const std::vector<std::string>& string_list) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Processes a list of strings, removing all occurrences of three consecutive backticks from each string.\n *\n * @param stringList The list of strings to process.\n * @return A new list with all instances of three consecutive backticks removed from each string.\n */\npublic static List<String> removeTripleBackticks(List<String> stringList) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; // JUnit 4 Test annotation\nimport static org.junit.Assert.assertEquals; // JUnit 4 assertion method\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testRemoveTripleBackticksBasic() {\n        // Test basic functionality\n        List<String> inputStrings = Arrays.asList(\"Here is ```code``` example\", \"Another ```example``` here\", \"No backticks here\");\n        List<String> expectedOutput = Arrays.asList(\"Here is code example\", \"Another example here\", \"No backticks here\");\n        assertEquals(expectedOutput, removeTripleBackticks(inputStrings));\n    }\n\n    @Test\n    public void testStringsWithMultipleInstances() {\n        // Test strings containing multiple instances of triple backticks\n        List<String> inputStrings = Arrays.asList(\"Multiple ```backticks``` in ```one``` string\");\n        List<String> expectedOutput = Arrays.asList(\"Multiple backticks in one string\");\n        assertEquals(expectedOutput, removeTripleBackticks(inputStrings));\n    }\n\n    @Test\n    public void testEmptyStrings() {\n        // Test with empty strings\n        List<String> inputStrings = Arrays.asList(\"\");\n        List<String> expectedOutput = Arrays.asList(\"\");\n        assertEquals(expectedOutput, removeTripleBackticks(inputStrings));\n    }\n\n    @Test\n    public void testNoTripleBackticks() {\n        // Test strings that do not contain triple backticks\n        List<String> inputStrings = Arrays.asList(\"Just a normal string\", \"Another normal string\");\n        List<String> expectedOutput = Arrays.asList(\"Just a normal string\", \"Another normal string\");\n        assertEquals(expectedOutput, removeTripleBackticks(inputStrings));\n    }\n\n    @Test\n    public void testEdgeCases() {\n        // Test edge cases like strings made entirely of triple backticks\n        List<String> inputStrings = Arrays.asList(\"```\", \"```more```\", \"text``````\");\n        List<String> expectedOutput = Arrays.asList(\"\", \"more\", \"text\");\n        assertEquals(expectedOutput, removeTripleBackticks(inputStrings));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Processes a list of strings, removing all occurrences of three consecutive backticks from each string.\n *\n * @param stringList The list of strings to process.\n * @return A new list with all instances of three consecutive backticks removed from each string.\n */\npublic static List<String> removeTripleBackticks(List<String> stringList) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 55, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "You are given an integer array nums. In one move, you can pick an index i where 0 <= i < nums.length and increment nums[i] by 1.Return the minimum number of moves to make every value in nums unique.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef min_removals_to_make_unique(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array, calculate the minimum number of elements to delete so that the elements in the array are not duplicate.\n    For example:\n        input: [3, 3, 1, 2, 2, 1]\n        output: 3\n\n    Args:\n        nums (List[int]): integer array of nums\n\n    Returns:\n        minimum number of moves to make every value in nums unique\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestMinRemovalsToMakeUnique(unittest.TestCase):\n    def test_basic_array(self):\n        \"\"\"Test with a basic array where multiple removals are needed.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([3, 3, 1, 2, 2, 1]), 3)\n\n    def test_all_identical(self):\n        \"\"\"Test an array where all elements are identical.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([4, 4, 4, 4]), 3)\n\n    def test_all_unique(self):\n        \"\"\"Test an array where all elements are already unique.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([1, 2, 3, 4]), 0)\n\n    def test_empty_array(self):\n        \"\"\"Test an empty array.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([]), 0)\n\n    def test_complex_case(self):\n        \"\"\"Test a more complex case with a larger array.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]), 6)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef min_removals_to_make_unique(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array, calculate the minimum number of elements to delete so that the elements in the array are not duplicate.\n    For example:\n        input: [3, 3, 1, 2, 2, 1]\n        output: 3\n\n    Args:\n        nums (List[int]): integer array of nums\n\n    Returns:\n        minimum number of moves to make every value in nums unique\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculates the minimum number of elements to delete so that the elements in the array are not duplicate.\n * \n * Example:\n *   input: [3, 3, 1, 2, 2, 1]\n *   output: 3\n *\n * @param {Array<number>} nums - Integer array of numbers\n * @returns {number} The minimum number of moves to make every value in nums unique\n */\nfunction minRemovalsToMakeUnique(nums) {}", "test_code": "describe('TestMinRemovalsToMakeUnique', () => {\n  test('test_basic_array', () => {\n      /** Test with a basic array where multiple removals are needed. */\n      expect(minRemovalsToMakeUnique([3, 3, 1, 2, 2, 1])).toBe(3);\n  });\n\n  test('test_all_identical', () => {\n      /** Test an array where all elements are identical. */\n      expect(minRemovalsToMakeUnique([4, 4, 4, 4])).toBe(3);\n  });\n\n  test('test_all_unique', () => {\n      /** Test an array where all elements are already unique. */\n      expect(minRemovalsToMakeUnique([1, 2, 3, 4])).toBe(0);\n  });\n\n  test('test_empty_array', () => {\n      /** Test an empty array. */\n      expect(minRemovalsToMakeUnique([])).toBe(0);\n  });\n\n  test('test_complex_case', () => {\n      /** Test a more complex case with a larger array. */\n      expect(minRemovalsToMakeUnique([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])).toBe(6);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the minimum number of elements to delete so that the elements in the array are not duplicate.\n * \n * Example:\n *   input: [3, 3, 1, 2, 2, 1]\n *   output: 3\n *\n * @param {Array<number>} nums - Integer array of numbers\n * @returns {number} The minimum number of moves to make every value in nums unique\n */\nfunction minRemovalsToMakeUnique(nums) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the minimum number of elements to delete so that the elements in the array are not duplicate.\n * \n * Example:\n *   Input: [3, 3, 1, 2, 2, 1]\n *   Output: 3\n * \n * @param nums - An array of integers.\n * @returns The minimum number of moves to make every value in the array unique.\n */\nfunction minRemovalsToMakeUnique(nums: number[]): number {}", "test_code": "describe('minRemovalsToMakeUnique', () => {\n  it('test with a basic array where multiple removals are needed', () => {\n    expect(minRemovalsToMakeUnique([3, 3, 1, 2, 2, 1])).toBe(3);\n  });\n\n  it('test an array where all elements are identical', () => {\n    expect(minRemovalsToMakeUnique([4, 4, 4, 4])).toBe(3);\n  });\n\n  it('test an array where all elements are already unique', () => {\n    expect(minRemovalsToMakeUnique([1, 2, 3, 4])).toBe(0);\n  });\n\n  it('test an empty array', () => {\n    expect(minRemovalsToMakeUnique([])).toBe(0);\n  });\n\n  it('test a more complex case with a larger array', () => {\n    expect(minRemovalsToMakeUnique([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])).toBe(6);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the minimum number of elements to delete so that the elements in the array are not duplicate.\n * \n * Example:\n *   Input: [3, 3, 1, 2, 2, 1]\n *   Output: 3\n * \n * @param nums - An array of integers.\n * @returns The minimum number of moves to make every value in the array unique.\n */\nfunction minRemovalsToMakeUnique(nums: number[]): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the minimum number of elements to delete so that the elements in the vector are not duplicate.\n *\n * Example:\n *      Input: {3, 3, 1, 2, 2, 1}\n *      Output: 3\n *\n * @param nums The vector of integers.\n * @return Minimum number of moves to make every value in nums unique.\n */\nint min_removals_to_make_unique(const std::vector<int>& nums) {}\n", "test_code": "TEST_CASE(\"Test cases for min_removals_to_make_unique\", \"[min_removals_to_make_unique]\") {\n    SECTION(\"Test with a basic array where multiple removals are needed\") {\n        REQUIRE(min_removals_to_make_unique({3, 3, 1, 2, 2, 1}) == 3);\n    }\n\n    SECTION(\"Test an array where all elements are identical\") {\n        REQUIRE(min_removals_to_make_unique({4, 4, 4, 4}) == 3);\n    }\n\n    SECTION(\"Test an array where all elements are already unique\") {\n        REQUIRE(min_removals_to_make_unique({1, 2, 3, 4}) == 0);\n    }\n\n    SECTION(\"Test an empty array\") {\n        REQUIRE(min_removals_to_make_unique({}) == 0);\n    }\n\n    SECTION(\"Test a more complex case with a larger array\") {\n        REQUIRE(min_removals_to_make_unique({1, 2, 2, 3, 3, 3, 4, 4, 4, 4}) == 6);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the minimum number of elements to delete so that the elements in the vector are not duplicate.\n *\n * Example:\n *      Input: {3, 3, 1, 2, 2, 1}\n *      Output: 3\n *\n * @param nums The vector of integers.\n * @return Minimum number of moves to make every value in nums unique.\n */\nint min_removals_to_make_unique(const std::vector<int>& nums) {}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the minimum number of elements to delete so that the elements in the array are not duplicate.\n * \n * Example:\n *     Input: [3, 3, 1, 2, 2, 1]\n *     Output: 3\n * \n * @param nums The integer array.\n * @return The minimum number of moves to make every value in the array unique.\n */\npublic static int minRemovalsToMakeUnique(List<Integer> nums) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\n\npublic class Tester {\n\n    @Test\n    public void testBasicArray() {\n        // Test with a basic array where multiple removals are needed.\n        assertEquals(3, minRemovalsToMakeUnique(List.of(3, 3, 1, 2, 2, 1)));\n    }\n\n    @Test\n    public void testAllIdentical() {\n        // Test an array where all elements are identical.\n        assertEquals(3, minRemovalsToMakeUnique(List.of(4, 4, 4, 4)));\n    }\n\n    @Test\n    public void testAllUnique() {\n        // Test an array where all elements are already unique.\n        assertEquals(0, minRemovalsToMakeUnique(List.of(1, 2, 3, 4)));\n    }\n\n    @Test\n    public void testEmptyArray() {\n        // Test an empty array.\n        assertEquals(0, minRemovalsToMakeUnique(List.of()));\n    }\n\n    @Test\n    public void testComplexCase() {\n        // Test a more complex case with a larger array.\n        assertEquals(6, minRemovalsToMakeUnique(List.of(1, 2, 2, 3, 3, 3, 4, 4, 4, 4)));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the minimum number of elements to delete so that the elements in the array are not duplicate.\n * \n * Example:\n *     Input: [3, 3, 1, 2, 2, 1]\n *     Output: 3\n * \n * @param nums The integer array.\n * @return The minimum number of moves to make every value in the array unique.\n */\npublic static int minRemovalsToMakeUnique(List<Integer> nums) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 56, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "find all the characters that can be represented in Shift-JIS, but not in GBK, and return them as an array", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef find_shiftjis_not_gbk() -> List:\n    \"\"\"\n    find all the characters that can be represented in Shift-JIS, but not in GBK, and return them as an array\n\n    Returns:\n        list: A list of characters that are unique to Shift-JIS, not encodable in GBK.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFindShiftJISNotGBK(unittest.TestCase):\n\n    def setUp(self):\n        # Pre-calculate the list once since it's computationally expensive\n        self.shiftjis_not_gbk = find_shiftjis_not_gbk()\n\n    def test_known_shiftjis_character_not_in_gbk(self):\n        # Test known characters (example values provided might not actually be in one and not the other; please adjust accordingly based on actual encoding tables)\n        known_shiftjis_only = '\u30f1'  # An example character, ensure this is correct as per your encodings\n        self.assertNotIn(known_shiftjis_only, self.shiftjis_not_gbk)\n\n    def test_character_in_both_encodings(self):\n        # Test characters known to be in both encodings\n        common_character = '\u6c34'  # Common in both, ensure accuracy\n        self.assertNotIn(common_character, self.shiftjis_not_gbk)\n\n    def test_character_in_neither_encoding(self):\n        # Character not typically found in either encoding\n        neither_encoding_char = '\\U0001F4A9'  # Emoji, not in basic Shift-JIS or GBK\n        self.assertNotIn(neither_encoding_char, self.shiftjis_not_gbk)\n\n    def test_bounds_of_bmp(self):\n        # Characters at the edge of the BMP should be checked\n        edge_of_bmp = '\\uffff'  # Last character in BMP\n        # Since this test.js is situational, we check based on the known state; may not be necessary\n        if edge_of_bmp in self.shiftjis_not_gbk:\n            self.assertIn(edge_of_bmp, self.shiftjis_not_gbk)\n        else:\n            self.assertNotIn(edge_of_bmp, self.shiftjis_not_gbk)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_shiftjis_not_gbk() -> List:\n    \"\"\"\n    find all the characters that can be represented in Shift-JIS, but not in GBK, and return them as an array\n\n    Returns:\n        list: A list of characters that are unique to Shift-JIS, not encodable in GBK.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Finds all the characters that can be represented in Shift-JIS but not in GBK, and returns them as an array.\n *\n * @returns {string[]} An array of characters that are unique to Shift-JIS and not encodable in GBK.\n */\nfunction findShiftJisNotGbk() {}", "test_code": "describe('TestFindShiftJISNotGBK', () => {\n  let shiftjisNotGbk;\n\n  beforeAll(() => {\n      // Pre-calculate the list once since it's computationally expensive\n      shiftjisNotGbk = findShiftJisNotGbk();\n  });\n\n  test('test_known_shiftjis_character_not_in_gbk', () => {\n      // Test known characters (example values provided might not actually be in one and not the other; please adjust accordingly based on actual encoding tables)\n      const knownShiftJisOnly = '\u30f1';  // An example character, ensure this is correct as per your encodings\n      expect(shiftjisNotGbk).not.toContain(knownShiftJisOnly);\n  });\n\n  test('test_character_in_both_encodings', () => {\n      // Test characters known to be in both encodings\n      const commonCharacter = '\u6c34';  // Common in both, ensure accuracy\n      expect(shiftjisNotGbk).not.toContain(commonCharacter);\n  });\n\n  test('test_character_in_neither_encoding', () => {\n      // Character not typically found in either encoding\n      const neitherEncodingChar = '\\u{1F4A9}';  // Emoji, not in basic Shift-JIS or GBK\n      expect(shiftjisNotGbk).not.toContain(neitherEncodingChar);\n  });\n\n  test('test_bounds_of_bmp', () => {\n      // Characters at the edge of the BMP should be checked\n      const edgeOfBmp = '\\uffff';  // Last character in BMP\n      // Since this test.js is situational, we check based on the known state; may not be necessary\n      if (shiftjisNotGbk.includes(edgeOfBmp)) {\n          expect(shiftjisNotGbk).toContain(edgeOfBmp);\n      } else {\n          expect(shiftjisNotGbk).not.toContain(edgeOfBmp);\n      }\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Finds all the characters that can be represented in Shift-JIS but not in GBK, and returns them as an array.\n *\n * @returns {string[]} An array of characters that are unique to Shift-JIS and not encodable in GBK.\n */\nfunction findShiftJisNotGbk() {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Finds all the characters that can be represented in Shift-JIS but not in GBK,\n * and returns them as an array.\n *\n * @returns {string[]} An array of characters that are unique to Shift-JIS and not encodable in GBK.\n */\nfunction findShiftJisNotGbk(): string[] {}", "test_code": "describe('TestFindShiftJISNotGBK', () => {\n  let shiftjisNotGbk: string[];\n\n  beforeAll(() => {\n      // Pre-calculate the list once since it's computationally expensive\n      shiftjisNotGbk = findShiftJisNotGbk();\n  });\n\n  it('should not include known Shift-JIS characters not in GBK', () => {\n      // Test known characters (example values provided might not actually be in one and not the other; please adjust accordingly based on actual encoding tables)\n      const knownShiftJisOnly = '\u30f1';  // An example character, ensure this is correct as per your encodings\n      expect(shiftjisNotGbk).not.toContain(knownShiftJisOnly);\n  });\n\n  it('should not include characters known to be in both encodings', () => {\n      // Test characters known to be in both encodings\n      const commonCharacter = '\u6c34';  // Common in both, ensure accuracy\n      expect(shiftjisNotGbk).not.toContain(commonCharacter);\n  });\n\n  it('should not include characters not in either encoding', () => {\n      // Character not typically found in either encoding\n      const neitherEncodingChar = '\\u{1F4A9}';  // Emoji, not in basic Shift-JIS or GBK\n      expect(shiftjisNotGbk).not.toContain(neitherEncodingChar);\n  });\n\n  it('should handle characters at the edge of the BMP correctly', () => {\n      // Characters at the edge of the BMP should be checked\n      const edgeOfBmp = '\\uffff';  // Last character in BMP\n      if (shiftjisNotGbk.includes(edgeOfBmp)) {\n          expect(shiftjisNotGbk).toContain(edgeOfBmp);\n      } else {\n          expect(shiftjisNotGbk).not.toContain(edgeOfBmp);\n      }\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Finds all the characters that can be represented in Shift-JIS but not in GBK,\n * and returns them as an array.\n *\n * @returns {string[]} An array of characters that are unique to Shift-JIS and not encodable in GBK.\n */\nfunction findShiftJisNotGbk(): string[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds all the characters that can be represented in Shift-JIS, \n *        but not in GBK, and returns them as a vector.\n * \n * @return std::vector<wchar_t> A vector of characters that are unique to \n *         Shift-JIS and not encodable in GBK.\n */\nstd::vector<wchar_t> find_shiftjis_not_gbk() {}", "test_code": "TEST_CASE(\"TestFindShiftJISNotGBK\", \"[ShiftJISTest]\") {\n    // Pre-calculate the list once since it's computationally expensive\n    auto shiftjis_not_gbk = find_shiftjis_not_gbk();\n\n    SECTION(\"test_known_shiftjis_character_not_in_gbk\") {\n        // Test known characters (example values provided might not actually be in one and not the other; please adjust accordingly based on actual encoding tables)\n        wchar_t known_shiftjis_only = L'\u30f1';  // An example character, ensure this is correct as per your encodings\n        REQUIRE(std::find(shiftjis_not_gbk.begin(), shiftjis_not_gbk.end(), known_shiftjis_only) == shiftjis_not_gbk.end());\n    }\n\n    SECTION(\"test_character_in_both_encodings\") {\n        // Test characters known to be in both encodings\n        wchar_t common_character = L'\u6c34';  // Common in both, ensure accuracy\n        REQUIRE(std::find(shiftjis_not_gbk.begin(), shiftjis_not_gbk.end(), common_character) == shiftjis_not_gbk.end());\n    }\n\n    SECTION(\"test_character_in_neither_encoding\") {\n        // Character not typically found in either encoding\n        wchar_t neither_encoding_char = L'\\U0001F4A9';  // Emoji, not in basic Shift-JIS or GBK\n        REQUIRE(std::find(shiftjis_not_gbk.begin(), shiftjis_not_gbk.end(), neither_encoding_char) == shiftjis_not_gbk.end());\n    }\n\n    SECTION(\"test_bounds_of_bmp\") {\n        // Characters at the edge of the BMP should be checked\n        wchar_t edge_of_bmp = L'\\uffff';  // Last character in BMP\n        // Since this test is situational, we check based on the known state; may not be necessary\n        if (std::find(shiftjis_not_gbk.begin(), shiftjis_not_gbk.end(), edge_of_bmp) != shiftjis_not_gbk.end()) {\n            REQUIRE(std::find(shiftjis_not_gbk.begin(), shiftjis_not_gbk.end(), edge_of_bmp) != shiftjis_not_gbk.end());\n        } else {\n            REQUIRE(std::find(shiftjis_not_gbk.begin(), shiftjis_not_gbk.end(), edge_of_bmp) == shiftjis_not_gbk.end());\n        }\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds all the characters that can be represented in Shift-JIS, \n *        but not in GBK, and returns them as a vector.\n * \n * @return std::vector<wchar_t> A vector of characters that are unique to \n *         Shift-JIS and not encodable in GBK.\n */\nstd::vector<wchar_t> find_shiftjis_not_gbk() {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds all the characters that can be represented in Shift-JIS but not in GBK, and returns them as an array.\n *\n * @return An array of characters that are unique to Shift-JIS and not encodable in GBK.\n */\npublic static char[] findShiftJisNotGbk() {}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    private char[] shiftjisNotGbk;\n\n    @Before\n    public void setUp() {\n        // Pre-calculate the list once since it's computationally expensive\n        shiftjisNotGbk = findShiftJisNotGbk();\n    }\n\n    @Test\n    public void testKnownShiftJISCharacterNotInGBK() {\n        // Test known characters (example values provided might not actually be in one and not the other; please adjust accordingly based on actual encoding tables)\n        char knownShiftJisOnly = '\u30f1';  // An example character, ensure this is correct as per your encodings\n        assertFalse(\"The character should not be in the list\", contains(shiftjisNotGbk, knownShiftJisOnly));\n    }\n\n    @Test\n    public void testCharacterInBothEncodings() {\n        // Test characters known to be in both encodings\n        char commonCharacter = '\u6c34';  // Common in both, ensure accuracy\n        assertFalse(\"The character should not be in the list\", contains(shiftjisNotGbk, commonCharacter));\n    }\n\n    @Test\n    public void testCharacterInNeitherEncoding() {\n        // Character not typically found in either encoding\n        char neitherEncodingChar = '\\u1F4A9';  // Emoji, not in basic Shift-JIS or GBK\n        assertFalse(\"The character should not be in the list\", contains(shiftjisNotGbk, neitherEncodingChar));\n    }\n\n    @Test\n    public void testBoundsOfBMP() {\n        // Characters at the edge of the BMP should be checked\n        char edgeOfBmp = '\\uFFFF';  // Last character in BMP\n        // Since this test is situational, we check based on the known state; may not be necessary\n        if (contains(shiftjisNotGbk, edgeOfBmp)) {\n            assertTrue(\"The character should be in the list\", contains(shiftjisNotGbk, edgeOfBmp));\n        } else {\n            assertFalse(\"The character should not be in the list\", contains(shiftjisNotGbk, edgeOfBmp));\n        }\n    }\n\n    // Dummy implementation for contains method\n    private boolean contains(char[] array, char value) {\n        for (char c : array) {\n            if (c == value) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Finds all the characters that can be represented in Shift-JIS but not in GBK, and returns them as an array.\n *\n * @return An array of characters that are unique to Shift-JIS and not encodable in GBK.\n */\npublic static char[] findShiftJisNotGbk() {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 57, "code_type": "method", "original_language": "python", "question_type": "Machine learning and deep learning", "summary": "convert png images to ico files\n", "language_version_list": {"python": {"code_signature": "def convert_png_to_ico(png_file_path, ico_file_path, icon_sizes=[(32, 32)]):\n    \"\"\"\n    convert png images to ico files\n    Args:\n        png_file_path (str): Path to the source PNG image file.\n        ico_file_path (str): Path to save the ICO file.\n        icon_sizes (list): List of tuples specifying the sizes to include in the ICO file.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass TestConvertPngToIco(unittest.TestCase):\n    @patch('PIL.Image.open')\n    def test_single_icon_size(self, mock_open):\n        mock_image = mock_open.return_value.__enter__.return_value\n        convert_png_to_ico('source.png', 'output.ico', [(64, 64)])\n        mock_image.save.assert_called_with('output.ico', format='ICO', sizes=[(64, 64)])\n\n    @patch('PIL.Image.open')\n    def test_multiple_icon_sizes(self, mock_open):\n        mock_image = mock_open.return_value.__enter__.return_value\n        convert_png_to_ico('source.png', 'output.ico', [(16, 16), (32, 32), (64, 64)])\n        mock_image.save.assert_called_with('output.ico', format='ICO', sizes=[(16, 16), (32, 32), (64, 64)])\n\n    @patch('PIL.Image.open')\n    def test_default_icon_size(self, mock_open):\n        mock_image = mock_open.return_value.__enter__.return_value\n        convert_png_to_ico('source.png', 'output.ico')\n        mock_image.save.assert_called_with('output.ico', format='ICO', sizes=[(32, 32)])\n\n    @patch('PIL.Image.open')\n    def test_file_handling(self, mock_open):\n        mock_image = MagicMock()\n        mock_open.return_value.__enter__.return_value = mock_image\n        convert_png_to_ico('source.png', 'output.ico')\n        # Check if save was called correctly\n        mock_image.save.assert_called_once_with('output.ico', format='ICO', sizes=[(32, 32)])\n\n    @patch('PIL.Image.open')\n    def test_invalid_image_path(self, mock_open):\n        mock_open.side_effect = FileNotFoundError\n        with self.assertRaises(FileNotFoundError):\n            convert_png_to_ico('invalid.png', 'output.ico')\n", "prompt": "please write a python function , the function signature as below def convert_png_to_ico(png_file_path, ico_file_path, icon_sizes=[(32, 32)]):\n    \"\"\"\n    convert png images to ico files\n    Args:\n        png_file_path (str): Path to the source PNG image file.\n        ico_file_path (str): Path to save the ICO file.\n        icon_sizes (list): List of tuples specifying the sizes to include in the ICO file.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a PNG image file to an ICO format file.\n * \n * @param {string} pngFilePath - Path to the source PNG image file.\n * @param {string} icoFilePath - Path to save the ICO file.\n * @param {Array.<Array.<number>>} [iconSizes=[[32, 32]]] - List of tuples specifying the sizes to include in the ICO file.\n */\nfunction convertPngToIco(pngFilePath, icoFilePath, iconSizes = [[32, 32]]) {}", "test_code": "const fs = require('fs').promises; // Import fs.promises for mocking errors\n\ndescribe('TestConvertPngToIco', () => {\n    beforeEach(() => {\n        jest.resetModules();\n        jest.clearAllMocks();\n    });\n\n    describe('testSingleIconSize', () => {\n        it('should save the image with a single icon size', () => {\n            const mockImage = {\n                save: jest.fn()\n            };\n\n            const mockOpen = jest.fn().mockReturnValue({\n                __enter__: jest.fn().mockReturnValue(mockImage),\n                __exit__: jest.fn()\n            });\n\n            jest.doMock('sharp', () => ({\n                open: mockOpen\n            }));\n\n            convertPngToIco('source.png', 'output.ico', [[64, 64]]);\n            expect(mockImage.save).toHaveBeenCalledWith('output.ico', { format: 'ICO', sizes: [[64, 64]] });\n        });\n    });\n\n    describe('testMultipleIconSizes', () => {\n        it('should save the image with multiple icon sizes', () => {\n            const mockImage = {\n                save: jest.fn()\n            };\n\n            const mockOpen = jest.fn().mockReturnValue({\n                __enter__: jest.fn().mockReturnValue(mockImage),\n                __exit__: jest.fn()\n            });\n\n            jest.doMock('sharp', () => ({\n                open: mockOpen\n            }));\n\n            convertPngToIco('source.png', 'output.ico', [[16, 16], [32, 32], [64, 64]]);\n            expect(mockImage.save).toHaveBeenCalledWith('output.ico', { format: 'ICO', sizes: [[16, 16], [32, 32], [64, 64]] });\n        });\n    });\n\n    describe('testDefaultIconSize', () => {\n        it('should save the image with the default icon size', () => {\n            const mockImage = {\n                save: jest.fn()\n            };\n\n            const mockOpen = jest.fn().mockReturnValue({\n                __enter__: jest.fn().mockReturnValue(mockImage),\n                __exit__: jest.fn()\n            });\n\n            jest.doMock('sharp', () => ({\n                open: mockOpen\n            }));\n\n            convertPngToIco('source.png', 'output.ico');\n            expect(mockImage.save).toHaveBeenCalledWith('output.ico', { format: 'ICO', sizes: [[32, 32]] });\n        });\n    });\n\n    describe('testFileHandling', () => {\n        it('should save the image with the correct parameters', () => {\n            const mockImage = {\n                save: jest.fn()\n            };\n\n            const mockOpen = jest.fn().mockReturnValue({\n                __enter__: jest.fn().mockReturnValue(mockImage),\n                __exit__: jest.fn()\n            });\n\n            jest.doMock('sharp', () => ({\n                open: mockOpen\n            }));\n\n            convertPngToIco('source.png', 'output.ico');\n            expect(mockImage.save).toHaveBeenCalledTimes(1);\n            expect(mockImage.save).toHaveBeenCalledWith('output.ico', { format: 'ICO', sizes: [[32, 32]] });\n        });\n    });\n\n    describe('testInvalidImagePath', () => {\n        it('should throw an error when the image path is invalid', async () => {\n            const mockOpen = jest.fn().mockRejectedValue(new Error('File not found'));\n\n            jest.doMock('sharp', () => ({\n                open: mockOpen\n            }));\n\n            await expect(convertPngToIco('invalid.png', 'output.ico')).rejects.toThrow('File not found');\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a PNG image file to an ICO format file.\n * \n * @param {string} pngFilePath - Path to the source PNG image file.\n * @param {string} icoFilePath - Path to save the ICO file.\n * @param {Array.<Array.<number>>} [iconSizes=[[32, 32]]] - List of tuples specifying the sizes to include in the ICO file.\n */\nfunction convertPngToIco(pngFilePath, icoFilePath, iconSizes = [[32, 32]]) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts PNG images to ICO files.\n * \n * @param pngFilePath - Path to the source PNG image file.\n * @param icoFilePath - Path to save the ICO file.\n * @param iconSizes - List of tuples specifying the sizes to include in the ICO file.\n */\nfunction convertPngToIco(pngFilePath: string, icoFilePath: string, iconSizes: [number, number][] = [[32, 32]]): void {}", "test_code": "import { mock } from 'jest-mock-extended';\n\ndescribe('TestConvertPngToIco', () => {\n    let mockImage: any;\n\n    beforeEach(() => {\n        mockImage = mock();\n    });\n\n    describe('convertPngToIco', () => {\n        it('should save ICO with a single icon size', () => {\n            const mockOpen = jest.fn().mockReturnValue({\n                __enter__: jest.fn().mockReturnValue(mockImage),\n                __exit__: jest.fn(),\n            });\n\n            jest.spyOn(global, 'Image').mockImplementation(() => ({\n                open: mockOpen,\n            }));\n\n            convertPngToIco('source.png', 'output.ico', [[64, 64]]);\n            expect(mockImage.save).toHaveBeenCalledWith('output.ico', { format: 'ICO', sizes: [[64, 64]] });\n        });\n\n        it('should save ICO with multiple icon sizes', () => {\n            const mockOpen = jest.fn().mockReturnValue({\n                __enter__: jest.fn().mockReturnValue(mockImage),\n                __exit__: jest.fn(),\n            });\n\n            jest.spyOn(global, 'Image').mockImplementation(() => ({\n                open: mockOpen,\n            }));\n\n            convertPngToIco('source.png', 'output.ico', [[16, 16], [32, 32], [64, 64]]);\n            expect(mockImage.save).toHaveBeenCalledWith('output.ico', { format: 'ICO', sizes: [[16, 16], [32, 32], [64, 64]] });\n        });\n\n        it('should save ICO with the default icon size', () => {\n            const mockOpen = jest.fn().mockReturnValue({\n                __enter__: jest.fn().mockReturnValue(mockImage),\n                __exit__: jest.fn(),\n            });\n\n            jest.spyOn(global, 'Image').mockImplementation(() => ({\n                open: mockOpen,\n            }));\n\n            convertPngToIco('source.png', 'output.ico');\n            expect(mockImage.save).toHaveBeenCalledWith('output.ico', { format: 'ICO', sizes: [[32, 32]] });\n        });\n\n        it('should handle file opening correctly', () => {\n            const mockOpen = jest.fn().mockReturnValue({\n                __enter__: jest.fn().mockReturnValue(mockImage),\n                __exit__: jest.fn(),\n            });\n\n            jest.spyOn(global, 'Image').mockImplementation(() => ({\n                open: mockOpen,\n            }));\n\n            convertPngToIco('source.png', 'output.ico');\n            expect(mockImage.save).toHaveBeenCalledTimes(1);\n            expect(mockImage.save).toHaveBeenCalledWith('output.ico', { format: 'ICO', sizes: [[32, 32]] });\n        });\n\n        it('should throw an error when the image path is invalid', () => {\n            const mockOpen = jest.fn().mockImplementation(() => {\n                throw new Error('File not found');\n            });\n\n            jest.spyOn(global, 'Image').mockImplementation(() => ({\n                open: mockOpen,\n            }));\n\n            expect(() => convertPngToIco('invalid.png', 'output.ico')).toThrow('File not found');\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts PNG images to ICO files.\n * \n * @param pngFilePath - Path to the source PNG image file.\n * @param icoFilePath - Path to save the ICO file.\n * @param iconSizes - List of tuples specifying the sizes to include in the ICO file.\n */\nfunction convertPngToIco(pngFilePath: string, icoFilePath: string, iconSizes: [number, number][] = [[32, 32]]): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 58, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Calculate the probability that n red balls will be drawn when 15 balls are randomly returned from a jar containing x red balls and y blue balls", "language_version_list": {"python": {"code_signature": "def probability_of_red_balls(n: int, x: int, y: int) -> float:\n    \"\"\"\n    Calculate the probability that n red balls will be drawn when 15 balls are randomly returned from a jar containing x red balls and y blue balls.\n\n    Args:\n        n (int): Number of red balls to be drawn.\n        x (int): Number of red balls in the jar.\n        y (int): Number of blue balls in the jar.\n\n    Returns:\n        float: The probability of drawing exactly n red balls.\n    \"\"\"\n", "test_code": "import unittest\nfrom math import isclose\n\n\nclass TestProbabilityOfRedBalls(unittest.TestCase):\n\n    def test_half_red_balls(self):\n        # Scenario where half of the drawn balls are expected to be red\n        result = probability_of_red_balls(7, 10, 10)\n        expected_result = probability_of_red_balls(7, 10, 10)  # Calculate manually or from another tool\n        self.assertTrue(isclose(result, expected_result), \"Test with half red balls failed\")\n\n    def test_some_red_balls(self):\n        # Scenario with some red balls in the jar, expecting a few red draws\n        result = probability_of_red_balls(5, 5, 10)\n        expected_result = probability_of_red_balls(5, 5, 10)  # Calculate manually or from another tool\n        self.assertTrue(isclose(result, expected_result), \"Test with some red balls failed\")\n\n    def test_extreme_case(self):\n        # Extreme scenario where the probability is low for the chosen n\n        result = probability_of_red_balls(15, 1, 99)\n        expected_result = probability_of_red_balls(15, 1, 99)  # Calculate manually or from another tool\n        self.assertTrue(isclose(result, expected_result), \"Test with extreme case failed\")", "prompt": "please write a python function , the function signature as below def probability_of_red_balls(n: int, x: int, y: int) -> float:\n    \"\"\"\n    Calculate the probability that n red balls will be drawn when 15 balls are randomly returned from a jar containing x red balls and y blue balls.\n\n    Args:\n        n (int): Number of red balls to be drawn.\n        x (int): Number of red balls in the jar.\n        y (int): Number of blue balls in the jar.\n\n    Returns:\n        float: The probability of drawing exactly n red balls.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculate the probability that n red balls will be drawn when 15 balls are randomly drawn from a jar containing x red balls and y blue balls.\n *\n * @param {number} n - Number of red balls to be drawn.\n * @param {number} x - Number of red balls in the jar.\n * @param {number} y - Number of blue balls in the jar.\n * @returns {number} - The probability of drawing exactly n red balls.\n */\nfunction probabilityOfRedBalls(n, x, y) {}", "test_code": "const { isClose } = require('mathjs'); // Assuming we use mathjs for isClose function\n\ndescribe('TestProbabilityOfRedBalls', () => {\n    describe('testHalfRedBalls', () => {\n        it('should pass for half red balls', () => {\n            // Scenario where half of the drawn balls are expected to be red\n            const result = probabilityOfRedBalls(7, 10, 10);\n            const expectedResult = probabilityOfRedBalls(7, 10, 10); // Calculate manually or from another tool\n            expect(isClose(result, expectedResult)).toBe(true);\n        });\n    });\n\n    describe('testSomeRedBalls', () => {\n        it('should pass for some red balls', () => {\n            // Scenario with some red balls in the jar, expecting a few red draws\n            const result = probabilityOfRedBalls(5, 5, 10);\n            const expectedResult = probabilityOfRedBalls(5, 5, 10); // Calculate manually or from another tool\n            expect(isClose(result, expectedResult)).toBe(true);\n        });\n    });\n\n    describe('testExtremeCase', () => {\n        it('should pass for extreme case', () => {\n            // Extreme scenario where the probability is low for the chosen n\n            const result = probabilityOfRedBalls(15, 1, 99);\n            const expectedResult = probabilityOfRedBalls(15, 1, 99); // Calculate manually or from another tool\n            expect(isClose(result, expectedResult)).toBe(true);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculate the probability that n red balls will be drawn when 15 balls are randomly drawn from a jar containing x red balls and y blue balls.\n *\n * @param {number} n - Number of red balls to be drawn.\n * @param {number} x - Number of red balls in the jar.\n * @param {number} y - Number of blue balls in the jar.\n * @returns {number} - The probability of drawing exactly n red balls.\n */\nfunction probabilityOfRedBalls(n, x, y) {}", "addition_info": ""}, "typescript": {"code_signature": "import { comb } from 'mathjs';\n\n/**\n * Calculate the probability that n red balls will be drawn when 15 balls are randomly drawn from a jar containing x red balls and y blue balls.\n *\n * @param n - Number of red balls to be drawn.\n * @param x - Number of red balls in the jar.\n * @param y - Number of blue balls in the jar.\n * @returns The probability of drawing exactly n red balls.\n */\nfunction probabilityOfRedBalls(n: number, x: number, y: number): number {}", "test_code": "describe('TestProbabilityOfRedBalls', () => {\n    describe('testHalfRedBalls', () => {\n        it('should calculate the correct probability for half red balls', () => {\n            const result = probabilityOfRedBalls(7, 10, 10);\n            const expectedResult = probabilityOfRedBalls(7, 10, 10); // Calculate manually or from another tool\n            expect(result).toBeCloseTo(expectedResult, 10); // Use beCloseTo for floating-point comparison\n        });\n    });\n\n    describe('testSomeRedBalls', () => {\n        it('should calculate the correct probability for some red balls', () => {\n            const result = probabilityOfRedBalls(5, 5, 10);\n            const expectedResult = probabilityOfRedBalls(5, 5, 10); // Calculate manually or from another tool\n            expect(result).toBeCloseTo(expectedResult, 10); // Use beCloseTo for floating-point comparison\n        });\n    });\n\n    describe('testExtremeCase', () => {\n        it('should calculate the correct probability for an extreme case', () => {\n            const result = probabilityOfRedBalls(15, 1, 99);\n            const expectedResult = probabilityOfRedBalls(15, 1, 99); // Calculate manually or from another tool\n            expect(result).toBeCloseTo(expectedResult, 10); // Use beCloseTo for floating-point comparison\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below import { comb } from 'mathjs';\n\n/**\n * Calculate the probability that n red balls will be drawn when 15 balls are randomly drawn from a jar containing x red balls and y blue balls.\n *\n * @param n - Number of red balls to be drawn.\n * @param x - Number of red balls in the jar.\n * @param y - Number of blue balls in the jar.\n * @returns The probability of drawing exactly n red balls.\n */\nfunction probabilityOfRedBalls(n: number, x: number, y: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the probability that n red balls will be drawn when 15 balls are randomly drawn from a jar containing x red balls and y blue balls.\n *\n * @param n Number of red balls to be drawn.\n * @param x Number of red balls in the jar.\n * @param y Number of blue balls in the jar.\n * @return The probability of drawing exactly n red balls.\n */\ndouble probability_of_red_balls(int n, int x, int y) {}", "test_code": "bool isclose(double a, double b, double rel_tol = 1e-9, double abs_tol = 0.0) {\n    return std::abs(a - b) <= std::max(rel_tol * std::max(std::abs(a), std::abs(b)), abs_tol);\n}\n\n// Test suite for the probability_of_red_balls function\nTEST_CASE(\"Test probability_of_red_balls\", \"[probability_of_red_balls]\") {\n    SECTION(\"Test with half red balls\") {\n        // Scenario where half of the drawn balls are expected to be red\n        double result = probability_of_red_balls(7, 10, 10);\n        double expected_result = 0.0542635;  // Manually calculated or from another tool\n        REQUIRE(isclose(result, expected_result));\n    }\n\n    SECTION(\"Test with some red balls\") {\n        // Scenario with some red balls in the jar, expecting a few red draws\n        double result = probability_of_red_balls(5, 5, 10);\n        double expected_result = 0.00371398;  // Manually calculated or from another tool\n        REQUIRE(isclose(result, expected_result));\n    }\n\n    SECTION(\"Test with extreme case\") {\n        // Extreme scenario where the probability is low for the chosen n\n        double result = probability_of_red_balls(15, 1, 99);\n        double expected_result = 1.01168e-10;  // Manually calculated or from another tool\n        REQUIRE(isclose(result, expected_result));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the probability that n red balls will be drawn when 15 balls are randomly drawn from a jar containing x red balls and y blue balls.\n *\n * @param n Number of red balls to be drawn.\n * @param x Number of red balls in the jar.\n * @param y Number of blue balls in the jar.\n * @return The probability of drawing exactly n red balls.\n */\ndouble probability_of_red_balls(int n, int x, int y) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate the probability that n red balls will be drawn when 15 balls are randomly drawn from a jar containing x red balls and y blue balls.\n *\n * @param n The number of red balls to be drawn.\n * @param x The number of red balls in the jar.\n * @param y The number of blue balls in the jar.\n * @return The probability of drawing exactly n red balls.\n */\npublic static double probabilityOfRedBalls(int n, int x, int y) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test; // JUnit 4 Test annotation\nimport static org.junit.Assert.assertTrue; // JUnit 4 assertion method\nimport static org.junit.Assert.assertEquals; // JUnit 4 assertion method\nimport static org.junit.Assert.fail; // JUnit 4 fail method\nimport org.real.temp.Answer.*;\npublic class Tester {\n\n    private static final double DELTA = 1e-15;\n\n    /**\n     * Test the probability of drawing half red balls.\n     */\n    @Test\n    public void testHalfRedBalls() {\n        // Scenario where half of the drawn balls are expected to be red\n        double result = probabilityOfRedBalls(7, 10, 10);\n        double expectedResult = 0.001376; // Replace with the actual expected result\n        assertTrue(\"Test with half red balls failed\", isClose(result, expectedResult, DELTA));\n    }\n\n    /**\n     * Test the probability of drawing some red balls.\n     */\n    @Test\n    public void testSomeRedBalls() {\n        // Scenario with some red balls in the jar, expecting a few red draws\n        double result = probabilityOfRedBalls(5, 5, 10);\n        double expectedResult = 0.02795; // Replace with the actual expected result\n        assertTrue(\"Test with some red balls failed\", isClose(result, expectedResult, DELTA));\n    }\n\n    /**\n     * Test the probability of drawing red balls in an extreme case.\n     */\n    @Test\n    public void testExtremeCase() {\n        // Extreme scenario where the probability is low for the chosen n\n        double result = probabilityOfRedBalls(15, 1, 99);\n        double expectedResult = 0.000001; // Replace with the actual expected result\n        assertTrue(\"Test with extreme case failed\", isClose(result, expectedResult, DELTA));\n    }\n\n    // Helper method to check if two doubles are close enough\n    private boolean isClose(double a, double b, double delta) {\n        return Math.abs(a - b) <= delta;\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Calculate the probability that n red balls will be drawn when 15 balls are randomly drawn from a jar containing x red balls and y blue balls.\n *\n * @param n The number of red balls to be drawn.\n * @param x The number of red balls in the jar.\n * @param y The number of blue balls in the jar.\n * @return The probability of drawing exactly n red balls.\n */\npublic static double probabilityOfRedBalls(int n, int x, int y) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 59, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "calculate the probability that x balls will be randomly drawn from a jar containing n red balls and m blue balls, and all of them will be red balls\n", "language_version_list": {"python": {"code_signature": "def probability_red_balls(x: int, n: int, m: int) -> float:\n    \"\"\"\n    calculate the probability that x balls will be randomly drawn from a jar containing n red balls and m blue balls, and all of them will be red balls\n    Args:\n        x (int): Number of balls to draw.\n        n (int): Number of red balls in the jar.\n        m (int): Number of blue balls in the jar.\n\n    Returns:\n        The probability that all x drawn balls are red.\n    \"\"\"\n", "test_code": "import unittest\nfrom math import comb\n\n\nclass TestProbabilityRedBalls(unittest.TestCase):\n    def test_all_red(self):\n        # Case where all balls are red\n        self.assertEqual(probability_red_balls(5, 5, 0), 1)\n\n    def test_no_red(self):\n        # Case where no red balls are available\n        self.assertEqual(probability_red_balls(1, 0, 5), 0)\n\n    def test_typical_case(self):\n        # Typical scenario\n        self.assertAlmostEqual(probability_red_balls(2, 10, 5), comb(10, 2) / comb(15, 2))\n\n    def test_impossible_case(self):\n        # More balls requested than available\n        self.assertEqual(probability_red_balls(6, 5, 4), 0)\n\n    def test_high_combinations(self):\n        # Test with higher number of combinations\n        self.assertAlmostEqual(probability_red_balls(3, 20, 30), comb(20, 3) / comb(50, 3))", "prompt": "please write a python function , the function signature as below def probability_red_balls(x: int, n: int, m: int) -> float:\n    \"\"\"\n    calculate the probability that x balls will be randomly drawn from a jar containing n red balls and m blue balls, and all of them will be red balls\n    Args:\n        x (int): Number of balls to draw.\n        n (int): Number of red balls in the jar.\n        m (int): Number of blue balls in the jar.\n\n    Returns:\n        The probability that all x drawn balls are red.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculate the probability that x balls will be randomly drawn from a jar containing n red balls and m blue balls, and all of them will be red balls.\n * \n * @param {number} x - Number of balls to draw.\n * @param {number} n - Number of red balls in the jar.\n * @param {number} m - Number of blue balls in the jar.\n * \n * @returns {number} The probability that all x drawn balls are red.\n */\nfunction probabilityRedBalls(x, n, m) {}", "test_code": "const { comb } = require('js-combinatorics');\n\ndescribe('TestProbabilityRedBalls', () => {\n  describe('test_all_red', () => {\n      it('should return 1 when all balls are red', () => {\n          expect(probabilityRedBalls(5, 5, 0)).toBe(1);\n      });\n  });\n\n  describe('test_no_red', () => {\n      it('should return 0 when no red balls are available', () => {\n          expect(probabilityRedBalls(1, 0, 5)).toBe(0);\n      });\n  });\n\n  describe('test_typical_case', () => {\n      it('should return the correct probability in a typical scenario', () => {\n          const expectedProbability = comb(10, 2) / comb(15, 2);\n          expect(probabilityRedBalls(2, 10, 5)).toBeCloseTo(expectedProbability, 10); // Adjust precision as needed\n      });\n  });\n\n  describe('test_impossible_case', () => {\n      it('should return 0 when more balls are requested than available', () => {\n          expect(probabilityRedBalls(6, 5, 4)).toBe(0);\n      });\n  });\n\n  describe('test_high_combinations', () => {\n      it('should return the correct probability with higher number of combinations', () => {\n          const expectedProbability = comb(20, 3) / comb(50, 3);\n          expect(probabilityRedBalls(3, 20, 30)).toBeCloseTo(expectedProbability, 10); // Adjust precision as needed\n      });\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculate the probability that x balls will be randomly drawn from a jar containing n red balls and m blue balls, and all of them will be red balls.\n * \n * @param {number} x - Number of balls to draw.\n * @param {number} n - Number of red balls in the jar.\n * @param {number} m - Number of blue balls in the jar.\n * \n * @returns {number} The probability that all x drawn balls are red.\n */\nfunction probabilityRedBalls(x, n, m) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculate the probability that x balls will be randomly drawn from a jar containing\n * n red balls and m blue balls, and all of them will be red balls.\n * \n * @param x - Number of balls to draw.\n * @param n - Number of red balls in the jar.\n * @param m - Number of blue balls in the jar.\n * @returns The probability that all x drawn balls are red.\n */\nfunction probabilityRedBalls(x: number, n: number, m: number): number {}", "test_code": "const { comb } = require('js-combinatorics');\n\ndescribe('TestProbabilityRedBalls', () => {\n    it('should return 1 when all balls are red', () => {\n        // Case where all balls are red\n        expect(probabilityRedBalls(5, 5, 0)).toBe(1);\n    });\n\n    it('should return 0 when no red balls are available', () => {\n        // Case where no red balls are available\n        expect(probabilityRedBalls(1, 0, 5)).toBe(0);\n    });\n\n    it('should return the correct probability in a typical scenario', () => {\n        // Typical scenario\n        const expectedProbability = comb(10, 2) / comb(15, 2);\n        expect(probabilityRedBalls(2, 10, 5)).toBeCloseTo(expectedProbability, 6);\n    });\n\n    it('should return 0 when more balls are requested than available', () => {\n        // More balls requested than available\n        expect(probabilityRedBalls(6, 5, 4)).toBe(0);\n    });\n\n    it('should return the correct probability with higher number of combinations', () => {\n        // Test with higher number of combinations\n        const expectedProbability = comb(20, 3) / comb(50, 3);\n        expect(probabilityRedBalls(3, 20, 30)).toBeCloseTo(expectedProbability, 6);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculate the probability that x balls will be randomly drawn from a jar containing\n * n red balls and m blue balls, and all of them will be red balls.\n * \n * @param x - Number of balls to draw.\n * @param n - Number of red balls in the jar.\n * @param m - Number of blue balls in the jar.\n * @returns The probability that all x drawn balls are red.\n */\nfunction probabilityRedBalls(x: number, n: number, m: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the probability that x balls will be randomly drawn from a jar containing\n * n red balls and m blue balls, and all of them will be red balls.\n *\n * @param x Number of balls to draw.\n * @param n Number of red balls in the jar.\n * @param m Number of blue balls in the jar.\n *\n * @return The probability that all x drawn balls are red.\n */\ndouble probability_red_balls(int x, int n, int m) {}", "test_code": "TEST_CASE(\"Test Probability Red Balls\") {\n    SECTION(\"All balls are red\") {\n        REQUIRE(probability_red_balls(5, 5, 0) == Approx(1));\n    }\n\n    SECTION(\"No red balls are available\") {\n        REQUIRE(probability_red_balls(1, 0, 5) == Approx(0));\n    }\n\n    SECTION(\"Typical scenario\") {\n        REQUIRE(probability_red_balls(2, 10, 5) == Approx(static_cast<double>(binomial_coefficient(10, 2)) / binomial_coefficient(15, 2)));\n    }\n\n    SECTION(\"More balls requested than available\") {\n        REQUIRE(probability_red_balls(6, 5, 4) == Approx(0));\n    }\n\n    SECTION(\"High combinations\") {\n        REQUIRE(probability_red_balls(3, 20, 30) == Approx(static_cast<double>(binomial_coefficient(20, 3)) / binomial_coefficient(50, 3)));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the probability that x balls will be randomly drawn from a jar containing\n * n red balls and m blue balls, and all of them will be red balls.\n *\n * @param x Number of balls to draw.\n * @param n Number of red balls in the jar.\n * @param m Number of blue balls in the jar.\n *\n * @return The probability that all x drawn balls are red.\n */\ndouble probability_red_balls(int x, int n, int m) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the probability that x balls will be randomly drawn from a jar containing\n * n red balls and m blue balls, and all of them will be red balls.\n *\n * @param x Number of balls to draw.\n * @param n Number of red balls in the jar.\n * @param m Number of blue balls in the jar.\n * @return The probability that all x drawn balls are red.\n */\npublic static double probabilityRedBalls(int x, int n, int m) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\nimport java.math.BigInteger;\n\nimport static org.real.temp.Answer.*;\n\n/**\n * Test class for the probabilityRedBalls method.\n */\npublic class Tester {\n\n    /**\n     * Tests the case where all balls are red.\n     */\n    @Test\n    public void testAllRed() {\n        assertEquals(1.0, probabilityRedBalls(5, 5, 0), 0.0);\n    }\n\n    /**\n     * Tests the case where no red balls are available.\n     */\n    @Test\n    public void testNoRed() {\n        assertEquals(0.0, probabilityRedBalls(1, 0, 5), 0.0);\n    }\n\n    /**\n     * Tests a typical scenario.\n     */\n    @Test\n    public void testTypicalCase() {\n        double expected = comb(10, 2).doubleValue() / comb(15, 2).doubleValue();\n        assertEquals(expected, probabilityRedBalls(2, 10, 5), 0.0001);\n    }\n\n    /**\n     * Tests the case where more balls are requested than available.\n     */\n    @Test\n    public void testImpossibleCase() {\n        assertEquals(0.0, probabilityRedBalls(6, 5, 4), 0.0);\n    }\n\n    /**\n     * Tests the case with a higher number of combinations.\n     */\n    @Test\n    public void testHighCombinations() {\n        double expected = comb(20, 3).doubleValue() / comb(50, 3).doubleValue();\n        assertEquals(expected, probabilityRedBalls(3, 20, 30), 0.0001);\n    }\n\n    /**\n     * Calculates the number of combinations (n choose k).\n     *\n     * @param n The total number of items.\n     * @param k The number of items to choose.\n     * @return The number of combinations.\n     */\n    private BigInteger comb(int n, int k) {\n        BigInteger result = BigInteger.ONE;\n        for (int i = 0; i < k; i++) {\n            result = result.multiply(BigInteger.valueOf(n - i))\n                    .divide(BigInteger.valueOf(i + 1));\n        }\n        return result;\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Calculates the probability that x balls will be randomly drawn from a jar containing\n * n red balls and m blue balls, and all of them will be red balls.\n *\n * @param x Number of balls to draw.\n * @param n Number of red balls in the jar.\n * @param m Number of blue balls in the jar.\n * @return The probability that all x drawn balls are red.\n */\npublic static double probabilityRedBalls(int x, int n, int m) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 60, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "find the common columns of all csv files in a directory and return these column names as a list\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef get_common_columns_from_csvs(directory: str) -> List:\n    \"\"\"\n    find the common columns of all csv files in a directory and return these column names as a list\n    Args:\n        directory (str): directory path\n\n    Returns:\n        same column list\n    \"\"\"\n", "test_code": "import unittest\nimport pandas as pd\nimport os\n\n\nclass TestCommonColumns(unittest.TestCase):\n    def setUp(self):\n        # Set up a temporary directory\n        self.test_dir = \"test_dir\"\n        os.makedirs(self.test_dir, exist_ok=True)\n\n    def tearDown(self):\n        # Remove created files and directory after each test.js\n        for filename in os.listdir(self.test_dir):\n            os.remove(os.path.join(self.test_dir, filename))\n        os.rmdir(self.test_dir)\n\n    def test_all_same_columns(self):\n        # All CSV files have the same columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"A,B,C\\n4,5,6\"\n        data3 = \"A,B,C\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(set(get_common_columns_from_csvs(self.test_dir)), set(['C', 'B', 'A']))\n\n    def test_no_common_columns(self):\n        # No common columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"D,E,F\\n4,5,6\"\n        data3 = \"G,H,I\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(get_common_columns_from_csvs(self.test_dir), [])\n\n    def test_some_common_columns(self):\n        # Some common columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"B,C,D\\n4,5,6\"\n        data3 = \"C,D,E\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(get_common_columns_from_csvs(self.test_dir), ['C'])\n\n    def test_mixed_common_and_unique_columns(self):\n        # Mixed common and unique columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"B,C,D\\n4,5,6\"\n        data3 = \"B,C,E\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(set(get_common_columns_from_csvs(self.test_dir)), set(['B', 'C']))\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef get_common_columns_from_csvs(directory: str) -> List:\n    \"\"\"\n    find the common columns of all csv files in a directory and return these column names as a list\n    Args:\n        directory (str): directory path\n\n    Returns:\n        same column list\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Finds the common columns of all CSV files in a directory and returns these column names as a list.\n * @param {string} directory - The directory path.\n * @returns {Array<string>} - List of common column names.\n */\nfunction findCommonColumns(directory) {}", "test_code": "const fs = require('fs');\nconst path = require('path');\nconst Papa = require('papaparse');\n\ndescribe('TestCommonColumns', () => {\n  const testDir = 'test_dir';\n\n  beforeEach(() => {\n      // Set up a temporary directory\n      fs.mkdir(testDir, { recursive: true }, (err) => {\n          if (err && err.code !== 'EEXIST') throw err;\n      });\n  });\n\n  afterEach(() => {\n      // Remove created files and directory after each test\n      fs.readdir(testDir, (err, files) => {\n          if (err) throw err;\n          files.forEach(file => {\n              fs.unlink(path.join(testDir, file), (unlinkErr) => {\n                  if (unlinkErr) throw unlinkErr;\n              });\n          });\n          fs.rmdir(testDir, (rmdirErr) => {\n              if (rmdirErr) throw rmdirErr;\n          });\n      });\n  });\n\n  it('should find all same columns', async () => {\n      const data1 = \"A,B,C\\n1,2,3\";\n      const data2 = \"A,B,C\\n4,5,6\";\n      const data3 = \"A,B,C\\n7,8,9\";\n      const filenames = ['file1.csv', 'file2.csv', 'file3.csv'];\n      const datas = [data1, data2, data3];\n\n      filenames.forEach((filename, index) => {\n          fs.writeFile(path.join(testDir, filename), datas[index], (writeErr) => {\n              if (writeErr) throw writeErr;\n          });\n      });\n\n      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for writes to complete\n\n      const result = findCommonColumns(testDir);\n      expect(result).toEqual(['C', 'B', 'A']);\n  });\n\n  it('should find no common columns', async () => {\n      const data1 = \"A,B,C\\n1,2,3\";\n      const data2 = \"D,E,F\\n4,5,6\";\n      const data3 = \"G,H,I\\n7,8,9\";\n      const filenames = ['file1.csv', 'file2.csv', 'file3.csv'];\n      const datas = [data1, data2, data3];\n\n      filenames.forEach((filename, index) => {\n          fs.writeFile(path.join(testDir, filename), datas[index], (writeErr) => {\n              if (writeErr) throw writeErr;\n          });\n      });\n\n      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for writes to complete\n\n      const result = findCommonColumns(testDir);\n      expect(result).toEqual([]);\n  });\n\n  it('should find some common columns', async () => {\n      const data1 = \"A,B,C\\n1,2,3\";\n      const data2 = \"B,C,D\\n4,5,6\";\n      const data3 = \"C,D,E\\n7,8,9\";\n      const filenames = ['file1.csv', 'file2.csv', 'file3.csv'];\n      const datas = [data1, data2, data3];\n\n      filenames.forEach((filename, index) => {\n          fs.writeFile(path.join(testDir, filename), datas[index], (writeErr) => {\n              if (writeErr) throw writeErr;\n          });\n      });\n\n      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for writes to complete\n\n      const result = findCommonColumns(testDir);\n      expect(result).toEqual(['C']);\n  });\n\n  it('should find mixed common and unique columns', async () => {\n      const data1 = \"A,B,C\\n1,2,3\";\n      const data2 = \"B,C,D\\n4,5,6\";\n      const data3 = \"B,C,E\\n7,8,9\";\n      const filenames = ['file1.csv', 'file2.csv', 'file3.csv'];\n      const datas = [data1, data2, data3];\n\n      filenames.forEach((filename, index) => {\n          fs.writeFile(path.join(testDir, filename), datas[index], (writeErr) => {\n              if (writeErr) throw writeErr;\n          });\n      });\n\n      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for writes to complete\n\n      const result = findCommonColumns(testDir);\n      expect(result).toEqual(['B', 'C']);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Finds the common columns of all CSV files in a directory and returns these column names as a list.\n * @param {string} directory - The directory path.\n * @returns {Array<string>} - List of common column names.\n */\nfunction findCommonColumns(directory) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Finds the common columns of all CSV files in a directory and returns these column names as a list.\n * @param directory - The directory path.\n * @returns An array of common column names.\n */\nfunction findCommonColumns(directory: string): string[] {}", "test_code": "import * as fs from 'fs';\nimport * as path from 'path';\ndescribe('TestCommonColumns', () => {\n  const testDir = 'test_dir';\n\n  beforeEach(() => {\n      // Set up a temporary directory\n      fs.mkdir(testDir, { recursive: true }, (err) => {\n          if (err && err.code !== 'EEXIST') throw err;\n      });\n  });\n\n  afterEach(() => {\n      // Remove created files and directory after each test\n      fs.readdir(testDir, (err, files) => {\n          if (err) throw err;\n          files.forEach(file => {\n              fs.unlink(path.join(testDir, file), (unlinkErr) => {\n                  if (unlinkErr) throw unlinkErr;\n              });\n          });\n          fs.rmdir(testDir, (rmdirErr) => {\n              if (rmdirErr) throw rmdirErr;\n          });\n      });\n  });\n\n  it('should find all same columns', async () => {\n      const data1 = \"A,B,C\\n1,2,3\";\n      const data2 = \"A,B,C\\n4,5,6\";\n      const data3 = \"A,B,C\\n7,8,9\";\n      const filenames = ['file1.csv', 'file2.csv', 'file3.csv'];\n      const datas = [data1, data2, data3];\n\n      filenames.forEach((filename, index) => {\n          fs.writeFile(path.join(testDir, filename), datas[index], (writeErr) => {\n              if (writeErr) throw writeErr;\n          });\n      });\n\n      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for writes to complete\n\n      const result = findCommonColumns(testDir);\n      expect(result).toEqual(['C', 'B', 'A']);\n  });\n\n  it('should find no common columns', async () => {\n      const data1 = \"A,B,C\\n1,2,3\";\n      const data2 = \"D,E,F\\n4,5,6\";\n      const data3 = \"G,H,I\\n7,8,9\";\n      const filenames = ['file1.csv', 'file2.csv', 'file3.csv'];\n      const datas = [data1, data2, data3];\n\n      filenames.forEach((filename, index) => {\n          fs.writeFile(path.join(testDir, filename), datas[index], (writeErr) => {\n              if (writeErr) throw writeErr;\n          });\n      });\n\n      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for writes to complete\n\n      const result = findCommonColumns(testDir);\n      expect(result).toEqual([]);\n  });\n\n  it('should find some common columns', async () => {\n      const data1 = \"A,B,C\\n1,2,3\";\n      const data2 = \"B,C,D\\n4,5,6\";\n      const data3 = \"C,D,E\\n7,8,9\";\n      const filenames = ['file1.csv', 'file2.csv', 'file3.csv'];\n      const datas = [data1, data2, data3];\n\n      filenames.forEach((filename, index) => {\n          fs.writeFile(path.join(testDir, filename), datas[index], (writeErr) => {\n              if (writeErr) throw writeErr;\n          });\n      });\n\n      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for writes to complete\n\n      const result = findCommonColumns(testDir);\n      expect(result).toEqual(['C']);\n  });\n\n  it('should find mixed common and unique columns', async () => {\n      const data1 = \"A,B,C\\n1,2,3\";\n      const data2 = \"B,C,D\\n4,5,6\";\n      const data3 = \"B,C,E\\n7,8,9\";\n      const filenames = ['file1.csv', 'file2.csv', 'file3.csv'];\n      const datas = [data1, data2, data3];\n\n      filenames.forEach((filename, index) => {\n          fs.writeFile(path.join(testDir, filename), datas[index], (writeErr) => {\n              if (writeErr) throw writeErr;\n          });\n      });\n\n      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for writes to complete\n\n      const result = findCommonColumns(testDir);\n      expect(result).toEqual(['B', 'C']);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Finds the common columns of all CSV files in a directory and returns these column names as a list.\n * @param directory - The directory path.\n * @returns An array of common column names.\n */\nfunction findCommonColumns(directory: string): string[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Find the common columns of all CSV files in a directory and return these column names as a list.\n *\n * @param directory Directory path.\n * @return A vector containing the common column names.\n */\nstd::vector<std::string> find_common_columns(const std::string& directory) {}", "test_code": "TEST_CASE(\"Test common columns functionality\", \"[common-columns]\") {\n    // Set up a temporary directory\n    const std::string test_dir = \"test_dir\";\n    std::filesystem::create_directories(test_dir);\n\n    SECTION(\"All CSV files have the same columns\") {\n        const std::string data1 = \"A,B,C\\n1,2,3\";\n        const std::string data2 = \"A,B,C\\n4,5,6\";\n        const std::string data3 = \"A,B,C\\n7,8,9\";\n        const std::vector<std::string> filenames = {\"file1.csv\", \"file2.csv\", \"file3.csv\"};\n        const std::vector<std::string> datas = {data1, data2, data3};\n\n        for (size_t i = 0; i < filenames.size(); ++i) {\n            const std::string filepath = test_dir + \"/\" + filenames[i];\n            std::ofstream file(filepath);\n            file << datas[i];\n        }\n\n        REQUIRE(find_common_columns(test_dir) == std::vector<std::string>({\"A\", \"B\", \"C\"}));\n    }\n\n    SECTION(\"No common columns\") {\n        const std::string data1 = \"A,B,C\\n1,2,3\";\n        const std::string data2 = \"D,E,F\\n4,5,6\";\n        const std::string data3 = \"G,H,I\\n7,8,9\";\n        const std::vector<std::string> filenames = {\"file1.csv\", \"file2.csv\", \"file3.csv\"};\n        const std::vector<std::string> datas = {data1, data2, data3};\n\n        for (size_t i = 0; i < filenames.size(); ++i) {\n            const std::string filepath = test_dir + \"/\" + filenames[i];\n            std::ofstream file(filepath);\n            file << datas[i];\n        }\n\n        REQUIRE(find_common_columns(test_dir).empty());\n    }\n\n    SECTION(\"Some common columns\") {\n        const std::string data1 = \"A,B,C\\n1,2,3\";\n        const std::string data2 = \"B,C,D\\n4,5,6\";\n        const std::string data3 = \"C,D,E\\n7,8,9\";\n        const std::vector<std::string> filenames = {\"file1.csv\", \"file2.csv\", \"file3.csv\"};\n        const std::vector<std::string> datas = {data1, data2, data3};\n\n        for (size_t i = 0; i < filenames.size(); ++i) {\n            const std::string filepath = test_dir + \"/\" + filenames[i];\n            std::ofstream file(filepath);\n            file << datas[i];\n        }\n\n        REQUIRE(find_common_columns(test_dir) == std::vector<std::string>({\"C\"}));\n    }\n\n    SECTION(\"Mixed common and unique columns\") {\n        const std::string data1 = \"A,B,C\\n1,2,3\";\n        const std::string data2 = \"B,C,D\\n4,5,6\";\n        const std::string data3 = \"B,C,E\\n7,8,9\";\n        const std::vector<std::string> filenames = {\"file1.csv\", \"file2.csv\", \"file3.csv\"};\n        const std::vector<std::string> datas = {data1, data2, data3};\n\n        for (size_t i = 0; i < filenames.size(); ++i) {\n            const std::string filepath = test_dir + \"/\" + filenames[i];\n            std::ofstream file(filepath);\n            file << datas[i];\n        }\n\n        REQUIRE(find_common_columns(test_dir) == std::vector<std::string>({\"B\", \"C\"}));\n    }\n\n    // Clean up the temporary directory\n    for (const auto& entry : std::filesystem::directory_iterator(test_dir)) {\n        std::filesystem::remove(entry.path());\n    }\n    std::filesystem::remove_all(test_dir);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Find the common columns of all CSV files in a directory and return these column names as a list.\n *\n * @param directory Directory path.\n * @return A vector containing the common column names.\n */\nstd::vector<std::string> find_common_columns(const std::string& directory) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds the common columns of all CSV files in a directory and returns these column names as a list.\n *\n * @param directoryPath the path to the directory containing CSV files\n * @return a list of common column names\n */\npublic static List<String> findCommonColumns(String directoryPath) {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport static org.real.temp.Answer.*;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    private static final String TEST_DIR = \"test_dir\";\n\n    @Before\n    public void setUp() throws IOException {\n        // Set up a temporary directory\n        Files.createDirectories(new File(TEST_DIR).toPath());\n    }\n\n    @After\n    public void tearDown() throws IOException {\n        // Remove created files and directory after each test\n        File dir = new File(TEST_DIR);\n        File[] files = dir.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                file.delete();\n            }\n        }\n        dir.delete();\n    }\n\n    @Test\n    public void testAllSameColumns() throws IOException {\n        // All CSV files have the same columns\n        String data1 = \"A,B,C\\n1,2,3\";\n        String data2 = \"A,B,C\\n4,5,6\";\n        String data3 = \"A,B,C\\n7,8,9\";\n        List<String> filenames = Arrays.asList(\"file1.csv\", \"file2.csv\", \"file3.csv\");\n        List<String> datas = Arrays.asList(data1, data2, data3);\n\n        writeFiles(filenames, datas);\n\n        assertEquals(Arrays.asList(\"A\", \"B\", \"C\"), findCommonColumns(TEST_DIR));\n    }\n\n    @Test\n    public void testNoCommonColumns() throws IOException {\n        // No common columns\n        String data1 = \"A,B,C\\n1,2,3\";\n        String data2 = \"D,E,F\\n4,5,6\";\n        String data3 = \"G,H,I\\n7,8,9\";\n        List<String> filenames = Arrays.asList(\"file1.csv\", \"file2.csv\", \"file3.csv\");\n        List<String> datas = Arrays.asList(data1, data2, data3);\n\n        writeFiles(filenames, datas);\n\n        assertEquals(List.of(), findCommonColumns(TEST_DIR));\n    }\n\n    @Test\n    public void testSomeCommonColumns() throws IOException {\n        // Some common columns\n        String data1 = \"A,B,C\\n1,2,3\";\n        String data2 = \"B,C,D\\n4,5,6\";\n        String data3 = \"C,D,E\\n7,8,9\";\n        List<String> filenames = Arrays.asList(\"file1.csv\", \"file2.csv\", \"file3.csv\");\n        List<String> datas = Arrays.asList(data1, data2, data3);\n\n        writeFiles(filenames, datas);\n\n        assertEquals(List.of(\"C\"), findCommonColumns(TEST_DIR));\n    }\n\n    @Test\n    public void testMixedCommonAndUniqueColumns() throws IOException {\n        // Mixed common and unique columns\n        String data1 = \"A,B,C\\n1,2,3\";\n        String data2 = \"B,C,D\\n4,5,6\";\n        String data3 = \"B,C,E\\n7,8,9\";\n        List<String> filenames = Arrays.asList(\"file1.csv\", \"file2.csv\", \"file3.csv\");\n        List<String> datas = Arrays.asList(data1, data2, data3);\n\n        writeFiles(filenames, datas);\n\n        assertEquals(Arrays.asList(\"B\", \"C\"), findCommonColumns(TEST_DIR));\n    }\n\n    private void writeFiles(List<String> filenames, List<String> datas) throws IOException {\n        for (int i = 0; i < filenames.size(); i++) {\n            String filename = filenames.get(i);\n            String data = datas.get(i);\n            File file = new File(TEST_DIR, filename);\n            try (FileWriter writer = new FileWriter(file)) {\n                writer.write(data);\n            }\n        }\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Finds the common columns of all CSV files in a directory and returns these column names as a list.\n *\n * @param directoryPath the path to the directory containing CSV files\n * @return a list of common column names\n */\npublic static List<String> findCommonColumns(String directoryPath) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 62, "code_type": "class", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "implement the tree in the data structure and implement its three traversal methods\n", "language_version_list": {"python": {"code_signature": "class TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\n\nclass BinaryTree:\n    \"\"\"\n    implement the tree in the question structure and implement its three traversal methods\n    \"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        pass\n\n    def _insert(self, node, key):\n        pass\n\n    def inorder_traversal(self):\n        pass\n\n    def _inorder_traversal(self, node, result):\n        pass\n\n    def preorder_traversal(self):\n        pass\n\n    def _preorder_traversal(self, node, result):\n        pass\n\n    def postorder_traversal(self):\n        pass\n\n    def _postorder_traversal(self, node, result):\n        pass\n", "test_code": "import unittest\n\n\nclass TestBinaryTree(unittest.TestCase):\n\n    def test_empty_tree(self):\n        bt = BinaryTree()\n        self.assertEqual(bt.inorder_traversal(), [])\n        self.assertEqual(bt.preorder_traversal(), [])\n        self.assertEqual(bt.postorder_traversal(), [])\n\n    def test_single_node_tree(self):\n        bt = BinaryTree()\n        bt.insert(10)\n        self.assertEqual(bt.inorder_traversal(), [10])\n        self.assertEqual(bt.preorder_traversal(), [10])\n        self.assertEqual(bt.postorder_traversal(), [10])\n\n    def test_balanced_tree(self):\n        bt = BinaryTree()\n        elements = [8, 3, 10, 1, 6, 9, 14]\n        for elem in elements:\n            bt.insert(elem)\n        self.assertEqual(bt.inorder_traversal(), [1, 3, 6, 8, 9, 10, 14])\n        self.assertEqual(bt.preorder_traversal(), [8, 3, 1, 6, 10, 9, 14])\n        self.assertEqual(bt.postorder_traversal(), [1, 6, 3, 9, 14, 10, 8])\n\n    def test_left_heavy_tree(self):\n        bt = BinaryTree()\n        for i in range(10, 0, -1):  # Inserts 10, 9, ..., 1\n            bt.insert(i)\n        self.assertEqual(bt.inorder_traversal(), [i for i in range(1, 11)])\n        self.assertEqual(bt.preorder_traversal(), [10-i for i in range(10)])\n        self.assertEqual(bt.postorder_traversal(), [i for i in range(1, 11)])\n\n    def test_right_heavy_tree(self):\n        bt = BinaryTree()\n        for i in range(1, 11):  # Inserts 1, 2, ..., 10\n            bt.insert(i)\n        self.assertEqual(bt.inorder_traversal(), [i for i in range(1, 11)])\n        self.assertEqual(bt.preorder_traversal(), [i for i in range(1, 11)])\n        self.assertEqual(bt.postorder_traversal(), [i for i in range(10, 0, -1)])", "prompt": "please write a python class , the class signature as below class TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\n\nclass BinaryTree:\n    \"\"\"\n    implement the tree in the question structure and implement its three traversal methods\n    \"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        pass\n\n    def _insert(self, node, key):\n        pass\n\n    def inorder_traversal(self):\n        pass\n\n    def _inorder_traversal(self, node, result):\n        pass\n\n    def preorder_traversal(self):\n        pass\n\n    def _preorder_traversal(self, node, result):\n        pass\n\n    def postorder_traversal(self):\n        pass\n\n    def _postorder_traversal(self, node, result):\n        pass\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Represents a node in a binary tree.\n */\nclass TreeNode {\n    /**\n     * Constructs a new TreeNode.\n     * @param {number} key - The value of the node.\n     */\n    constructor(key) {\n        this.left = null;\n        this.right = null;\n        this.val = key;\n    }\n}\n\n/**\n * Represents a binary tree and implements its traversal methods.\n */\nclass BinaryTree {\n    /**\n     * Constructs a new BinaryTree.\n     */\n    constructor() {\n        this.root = null;\n    }\n\n    /**\n     * Inserts a new node with the given key into the binary tree.\n     * @param {number} key - The value to be inserted.\n     */\n    insert(key) {\n        // Implementation goes here\n    }\n\n    /**\n     * Inserts a new node with the given key into the subtree rooted at the specified node.\n     * @param {TreeNode} node - The root node of the subtree.\n     * @param {number} key - The value to be inserted.\n     * @private\n     */\n    _insert(node, key) {\n        // Implementation goes here\n    }\n\n    /**\n     * Performs an in-order traversal of the binary tree.\n     * @returns {Array<number>} An array containing the values of the nodes in in-order traversal order.\n     */\n    inorderTraversal() {\n        return this._inorderTraversal(this.root, []);\n    }\n\n    /**\n     * Helper method for performing an in-order traversal of the subtree rooted at the specified node.\n     * @param {TreeNode} node - The root node of the subtree.\n     * @param {Array<number>} result - The array to store the traversal results.\n     * @returns {Array<number>} The updated result array.\n     * @private\n     */\n    _inorderTraversal(node, result) {\n        // Implementation goes here\n    }\n\n    /**\n     * Performs a pre-order traversal of the binary tree.\n     * @returns {Array<number>} An array containing the values of the nodes in pre-order traversal order.\n     */\n    preorderTraversal() {\n        return this._preorderTraversal(this.root, []);\n    }\n\n    /**\n     * Helper method for performing a pre-order traversal of the subtree rooted at the specified node.\n     * @param {TreeNode} node - The root node of the subtree.\n     * @param {Array<number>} result - The array to store the traversal results.\n     * @returns {Array<number>} The updated result array.\n     * @private\n     */\n    _preorderTraversal(node, result) {\n        // Implementation goes here\n    }\n\n    /**\n     * Performs a post-order traversal of the binary tree.\n     * @returns {Array<number>} An array containing the values of the nodes in post-order traversal order.\n     */\n    postorderTraversal() {\n        return this._postorderTraversal(this.root, []);\n    }\n\n    /**\n     * Helper method for performing a post-order traversal of the subtree rooted at the specified node.\n     * @param {TreeNode} node - The root node of the subtree.\n     * @param {Array<number>} result - The array to store the traversal results.\n     * @returns {Array<number>} The updated result array.\n     * @private\n     */\n    _postorderTraversal(node, result) {\n        // Implementation goes here\n    }\n}", "test_code": "describe('BinaryTree', () => {\n    describe('test_empty_tree', () => {\n        it('should handle an empty tree correctly', () => {\n            const bt = new BinaryTree();\n            expect(bt.inorderTraversal()).toEqual([]);\n            expect(bt.preorderTraversal()).toEqual([]);\n            expect(bt.postorderTraversal()).toEqual([]);\n        });\n    });\n\n    describe('test_single_node_tree', () => {\n        it('should handle a single node tree correctly', () => {\n            const bt = new BinaryTree();\n            bt.insert(10);\n            expect(bt.inorderTraversal()).toEqual([10]);\n            expect(bt.preorderTraversal()).toEqual([10]);\n            expect(bt.postorderTraversal()).toEqual([10]);\n        });\n    });\n\n    describe('test_balanced_tree', () => {\n        it('should handle a balanced tree correctly', () => {\n            const bt = new BinaryTree();\n            const elements = [8, 3, 10, 1, 6, 9, 14];\n            elements.forEach((elem) => bt.insert(elem));\n            expect(bt.inorderTraversal()).toEqual([1, 3, 6, 8, 9, 10, 14]);\n            expect(bt.preorderTraversal()).toEqual([8, 3, 1, 6, 10, 9, 14]);\n            expect(bt.postorderTraversal()).toEqual([1, 6, 3, 9, 14, 10, 8]);\n        });\n    });\n\n    describe('test_left_heavy_tree', () => {\n        it('should handle a left-heavy tree correctly', () => {\n            const bt = new BinaryTree();\n            for (let i = 10; i > 0; i--) {\n                bt.insert(i);\n            }\n            expect(bt.inorderTraversal()).toEqual([...Array(10).keys()].map(i => i + 1));\n            expect(bt.preorderTraversal()).toEqual([...Array(10).keys()].map(i => 10 - i));\n            expect(bt.postorderTraversal()).toEqual([...Array(10).keys()].map(i => i + 1));\n        });\n    });\n\n    describe('test_right_heavy_tree', () => {\n        it('should handle a right-heavy tree correctly', () => {\n            const bt = new BinaryTree();\n            for (let i = 1; i <= 10; i++) {\n                bt.insert(i);\n            }\n            expect(bt.inorderTraversal()).toEqual([...Array(10).keys()].map(i => i + 1));\n            expect(bt.preorderTraversal()).toEqual([...Array(10).keys()].map(i => i + 1));\n            expect(bt.postorderTraversal()).toEqual([...Array(10).keys()].reverse().map(i => i + 1));\n        });\n    });\n});", "prompt": "please write a javascript class , the class signature as below /**\n * Represents a node in a binary tree.\n */\nclass TreeNode {\n    /**\n     * Constructs a new TreeNode.\n     * @param {number} key - The value of the node.\n     */\n    constructor(key) {\n        this.left = null;\n        this.right = null;\n        this.val = key;\n    }\n}\n\n/**\n * Represents a binary tree and implements its traversal methods.\n */\nclass BinaryTree {\n    /**\n     * Constructs a new BinaryTree.\n     */\n    constructor() {\n        this.root = null;\n    }\n\n    /**\n     * Inserts a new node with the given key into the binary tree.\n     * @param {number} key - The value to be inserted.\n     */\n    insert(key) {\n        // Implementation goes here\n    }\n\n    /**\n     * Inserts a new node with the given key into the subtree rooted at the specified node.\n     * @param {TreeNode} node - The root node of the subtree.\n     * @param {number} key - The value to be inserted.\n     * @private\n     */\n    _insert(node, key) {\n        // Implementation goes here\n    }\n\n    /**\n     * Performs an in-order traversal of the binary tree.\n     * @returns {Array<number>} An array containing the values of the nodes in in-order traversal order.\n     */\n    inorderTraversal() {\n        return this._inorderTraversal(this.root, []);\n    }\n\n    /**\n     * Helper method for performing an in-order traversal of the subtree rooted at the specified node.\n     * @param {TreeNode} node - The root node of the subtree.\n     * @param {Array<number>} result - The array to store the traversal results.\n     * @returns {Array<number>} The updated result array.\n     * @private\n     */\n    _inorderTraversal(node, result) {\n        // Implementation goes here\n    }\n\n    /**\n     * Performs a pre-order traversal of the binary tree.\n     * @returns {Array<number>} An array containing the values of the nodes in pre-order traversal order.\n     */\n    preorderTraversal() {\n        return this._preorderTraversal(this.root, []);\n    }\n\n    /**\n     * Helper method for performing a pre-order traversal of the subtree rooted at the specified node.\n     * @param {TreeNode} node - The root node of the subtree.\n     * @param {Array<number>} result - The array to store the traversal results.\n     * @returns {Array<number>} The updated result array.\n     * @private\n     */\n    _preorderTraversal(node, result) {\n        // Implementation goes here\n    }\n\n    /**\n     * Performs a post-order traversal of the binary tree.\n     * @returns {Array<number>} An array containing the values of the nodes in post-order traversal order.\n     */\n    postorderTraversal() {\n        return this._postorderTraversal(this.root, []);\n    }\n\n    /**\n     * Helper method for performing a post-order traversal of the subtree rooted at the specified node.\n     * @param {TreeNode} node - The root node of the subtree.\n     * @param {Array<number>} result - The array to store the traversal results.\n     * @returns {Array<number>} The updated result array.\n     * @private\n     */\n    _postorderTraversal(node, result) {\n        // Implementation goes here\n    }\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Represents a node in a binary tree.\n */\nclass TreeNode {\n    left: TreeNode | null;\n    right: TreeNode | null;\n    val: number;\n\n    constructor(key: number) {\n        this.left = null;\n        this.right = null;\n        this.val = key;\n    }\n}\n\n/**\n * Represents a binary tree and implements its traversal methods.\n */\nclass BinaryTree {\n    /**\n     * Initializes a new instance of the BinaryTree class.\n     */\n    root: TreeNode | null;\n\n    constructor() {\n        this.root = null;\n    }\n\n    /**\n     * Inserts a new node with the given key into the binary tree.\n     * @param key The value to insert.\n     */\n    insert(key: number): void {\n    }\n\n    /**\n     * Helper method to insert a new node with the given key into the binary tree.\n     * @param node The current node.\n     * @param key The value to insert.\n     */\n    private _insert(node: TreeNode, key: number): void {\n    }\n\n    /**\n     * Performs an in-order traversal of the binary tree.\n     * @returns An array containing the values of the nodes in in-order traversal order.\n     */\n    inorderTraversal(): number[] {\n    }\n\n    /**\n     * Helper method to perform an in-order traversal of the binary tree.\n     * @param node The current node.\n     * @param result The array to store the traversal results.\n     */\n    private _inorderTraversal(node: TreeNode | null, result: number[]): void {\n    }\n\n    /**\n     * Performs a pre-order traversal of the binary tree.\n     * @returns An array containing the values of the nodes in pre-order traversal order.\n     */\n    preorderTraversal(): number[] {\n    }\n\n    /**\n     * Helper method to perform a pre-order traversal of the binary tree.\n     * @param node The current node.\n     * @param result The array to store the traversal results.\n     */\n    private _preorderTraversal(node: TreeNode | null, result: number[]): void {\n    }\n\n    /**\n     * Performs a post-order traversal of the binary tree.\n     * @returns An array containing the values of the nodes in post-order traversal order.\n     */\n    postorderTraversal(): number[] {\n    }\n\n    /**\n     * Helper method to perform a post-order traversal of the binary tree.\n     * @param node The current node.\n     * @param result The array to store the traversal results.\n     */\n    private _postorderTraversal(node: TreeNode | null, result: number[]): void {\n    }\n}", "test_code": "describe('BinaryTree', () => {\n  it('should handle an empty tree', () => {\n      const bt = new BinaryTree();\n      expect(bt.inorderTraversal()).toEqual([]);\n      expect(bt.preorderTraversal()).toEqual([]);\n      expect(bt.postorderTraversal()).toEqual([]);\n  });\n\n  it('should handle a single node tree', () => {\n      const bt = new BinaryTree();\n      bt.insert(10);\n      expect(bt.inorderTraversal()).toEqual([10]);\n      expect(bt.preorderTraversal()).toEqual([10]);\n      expect(bt.postorderTraversal()).toEqual([10]);\n  });\n\n  it('should handle a balanced tree', () => {\n      const bt = new BinaryTree();\n      const elements = [8, 3, 10, 1, 6, 9, 14];\n      elements.forEach((elem) => bt.insert(elem));\n      expect(bt.inorderTraversal()).toEqual([1, 3, 6, 8, 9, 10, 14]);\n      expect(bt.preorderTraversal()).toEqual([8, 3, 1, 6, 10, 9, 14]);\n      expect(bt.postorderTraversal()).toEqual([1, 6, 3, 9, 14, 10, 8]);\n  });\n\n  it('should handle a left-heavy tree', () => {\n      const bt = new BinaryTree();\n      for (let i = 10; i >= 1; i--) {\n          bt.insert(i);\n      }\n      expect(bt.inorderTraversal()).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n      expect(bt.preorderTraversal()).toEqual([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);\n      expect(bt.postorderTraversal()).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n  });\n\n  it('should handle a right-heavy tree', () => {\n      const bt = new BinaryTree();\n      for (let i = 1; i <= 10; i++) {\n          bt.insert(i);\n      }\n      expect(bt.inorderTraversal()).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n      expect(bt.preorderTraversal()).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n      expect(bt.postorderTraversal()).toEqual([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);\n  });\n});", "prompt": "please write a typescript class , the class signature as below /**\n * Represents a node in a binary tree.\n */\nclass TreeNode {\n    left: TreeNode | null;\n    right: TreeNode | null;\n    val: number;\n\n    constructor(key: number) {\n        this.left = null;\n        this.right = null;\n        this.val = key;\n    }\n}\n\n/**\n * Represents a binary tree and implements its traversal methods.\n */\nclass BinaryTree {\n    /**\n     * Initializes a new instance of the BinaryTree class.\n     */\n    root: TreeNode | null;\n\n    constructor() {\n        this.root = null;\n    }\n\n    /**\n     * Inserts a new node with the given key into the binary tree.\n     * @param key The value to insert.\n     */\n    insert(key: number): void {\n    }\n\n    /**\n     * Helper method to insert a new node with the given key into the binary tree.\n     * @param node The current node.\n     * @param key The value to insert.\n     */\n    private _insert(node: TreeNode, key: number): void {\n    }\n\n    /**\n     * Performs an in-order traversal of the binary tree.\n     * @returns An array containing the values of the nodes in in-order traversal order.\n     */\n    inorderTraversal(): number[] {\n    }\n\n    /**\n     * Helper method to perform an in-order traversal of the binary tree.\n     * @param node The current node.\n     * @param result The array to store the traversal results.\n     */\n    private _inorderTraversal(node: TreeNode | null, result: number[]): void {\n    }\n\n    /**\n     * Performs a pre-order traversal of the binary tree.\n     * @returns An array containing the values of the nodes in pre-order traversal order.\n     */\n    preorderTraversal(): number[] {\n    }\n\n    /**\n     * Helper method to perform a pre-order traversal of the binary tree.\n     * @param node The current node.\n     * @param result The array to store the traversal results.\n     */\n    private _preorderTraversal(node: TreeNode | null, result: number[]): void {\n    }\n\n    /**\n     * Performs a post-order traversal of the binary tree.\n     * @returns An array containing the values of the nodes in post-order traversal order.\n     */\n    postorderTraversal(): number[] {\n    }\n\n    /**\n     * Helper method to perform a post-order traversal of the binary tree.\n     * @param node The current node.\n     * @param result The array to store the traversal results.\n     */\n    private _postorderTraversal(node: TreeNode | null, result: number[]): void {\n    }\n}", "addition_info": ""}, "c&cpp": {"code_signature": "// TreeNode class represents a node in the binary tree.\nclass TreeNode {\npublic:\n    // Constructor initializes a new TreeNode with the given key.\n    TreeNode(int key) : val(key), left(nullptr), right(nullptr) {}\n\n    // Pointers to the left and right child nodes.\n    TreeNode* left;\n    TreeNode* right;\n\n    // Value stored in the node.\n    int val;\n};\n\n// BinaryTree class implements a binary tree with insertion and traversal methods.\nclass BinaryTree {\npublic:\n    // Constructor initializes the root of the binary tree to null.\n    BinaryTree() : root(nullptr) {}\n\n    // Inserts a new node with the given key into the binary tree.\n    void insert(int key);\n\nprivate:\n    // Helper function to insert a new node with the given key.\n    void _insert(TreeNode* node, int key);\n\npublic:\n    // Performs an inorder traversal of the binary tree and returns the result.\n    std::vector<int> inorder_traversal();\n\nprivate:\n    // Helper function to perform an inorder traversal.\n    void _inorder_traversal(TreeNode* node, std::vector<int>& result);\n\npublic:\n    // Performs a preorder traversal of the binary tree and returns the result.\n    std::vector<int> preorder_traversal();\n\nprivate:\n    // Helper function to perform a preorder traversal.\n    void _preorder_traversal(TreeNode* node, std::vector<int>& result);\n\npublic:\n    // Performs a postorder traversal of the binary tree and returns the result.\n    std::vector<int> postorder_traversal();\n\nprivate:\n    // Helper function to perform a postorder traversal.\n    void _postorder_traversal(TreeNode* node, std::vector<int>& result);\n\n    // Pointer to the root of the binary tree.\n    TreeNode* root;\n};", "test_code": "// Test cases using Catch2\nTEST_CASE(\"Test empty tree\", \"[BinaryTree]\") {\n    BinaryTree bt;\n    REQUIRE(bt.inorder_traversal() == std::vector<int>());\n    REQUIRE(bt.preorder_traversal() == std::vector<int>());\n    REQUIRE(bt.postorder_traversal() == std::vector<int>());\n}\n\nTEST_CASE(\"Test single node tree\", \"[BinaryTree]\") {\n    BinaryTree bt;\n    bt.insert(10);\n    REQUIRE(bt.inorder_traversal() == std::vector<int>({10}));\n    REQUIRE(bt.preorder_traversal() == std::vector<int>({10}));\n    REQUIRE(bt.postorder_traversal() == std::vector<int>({10}));\n}\n\nTEST_CASE(\"Test balanced tree\", \"[BinaryTree]\") {\n    BinaryTree bt;\n    std::vector<int> elements = {8, 3, 10, 1, 6, 9, 14};\n    for (int elem : elements) {\n        bt.insert(elem);\n    }\n    REQUIRE(bt.inorder_traversal() == std::vector<int>({1, 3, 6, 8, 9, 10, 14}));\n    REQUIRE(bt.preorder_traversal() == std::vector<int>({8, 3, 1, 6, 10, 9, 14}));\n    REQUIRE(bt.postorder_traversal() == std::vector<int>({1, 6, 3, 9, 14, 10, 8}));\n}\n\nTEST_CASE(\"Test left-heavy tree\", \"[BinaryTree]\") {\n    BinaryTree bt;\n    for (int i = 10; i >= 1; --i) {\n        bt.insert(i);\n    }\n    REQUIRE(bt.inorder_traversal() == std::vector<int>({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}));\n    REQUIRE(bt.preorder_traversal() == std::vector<int>({10, 9, 8, 7, 6, 5, 4, 3, 2, 1}));\n    REQUIRE(bt.postorder_traversal() == std::vector<int>({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}));\n}\n\nTEST_CASE(\"Test right-heavy tree\", \"[BinaryTree]\") {\n    BinaryTree bt;\n    for (int i = 1; i <= 10; ++i) {\n        bt.insert(i);\n    }\n    REQUIRE(bt.inorder_traversal() == std::vector<int>({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}));\n    REQUIRE(bt.preorder_traversal() == std::vector<int>({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}));\n    REQUIRE(bt.postorder_traversal() == std::vector<int>({10, 9, 8, 7, 6, 5, 4, 3, 2, 1}));\n}", "prompt": "please write a cpp class , the class signature as below // TreeNode class represents a node in the binary tree.\nclass TreeNode {\npublic:\n    // Constructor initializes a new TreeNode with the given key.\n    TreeNode(int key) : val(key), left(nullptr), right(nullptr) {}\n\n    // Pointers to the left and right child nodes.\n    TreeNode* left;\n    TreeNode* right;\n\n    // Value stored in the node.\n    int val;\n};\n\n// BinaryTree class implements a binary tree with insertion and traversal methods.\nclass BinaryTree {\npublic:\n    // Constructor initializes the root of the binary tree to null.\n    BinaryTree() : root(nullptr) {}\n\n    // Inserts a new node with the given key into the binary tree.\n    void insert(int key);\n\nprivate:\n    // Helper function to insert a new node with the given key.\n    void _insert(TreeNode* node, int key);\n\npublic:\n    // Performs an inorder traversal of the binary tree and returns the result.\n    std::vector<int> inorder_traversal();\n\nprivate:\n    // Helper function to perform an inorder traversal.\n    void _inorder_traversal(TreeNode* node, std::vector<int>& result);\n\npublic:\n    // Performs a preorder traversal of the binary tree and returns the result.\n    std::vector<int> preorder_traversal();\n\nprivate:\n    // Helper function to perform a preorder traversal.\n    void _preorder_traversal(TreeNode* node, std::vector<int>& result);\n\npublic:\n    // Performs a postorder traversal of the binary tree and returns the result.\n    std::vector<int> postorder_traversal();\n\nprivate:\n    // Helper function to perform a postorder traversal.\n    void _postorder_traversal(TreeNode* node, std::vector<int>& result);\n\n    // Pointer to the root of the binary tree.\n    TreeNode* root;\n};", "addition_info": ""}, "java": {"code_signature": "static class TreeNode {\n    TreeNode left;\n    TreeNode right;\n    int val;\n\n    public TreeNode(int key) {\n        this.left = null;\n        this.right = null;\n        this.val = key;\n    }\n}\n\nstatic class BinaryTree {\n    private TreeNode root;\n\n    public BinaryTree() {\n        this.root = null;\n    }\n\n    public void insert(int key) {\n\n    }\n\n    private void insertRecursive(TreeNode node, int key) {\n\n    }\n\n    public int[] inorderTraversal() {\n    }\n\n    private java.util.List<Integer> inorderTraversalRecursive(TreeNode node, java.util.List<Integer> result) {\n\n    }\n\n    public int[] preorderTraversal() {\n    }\n\n    private java.util.List<Integer> preorderTraversalRecursive(TreeNode node, java.util.List<Integer> result) {\n\n    }\n\n    public int[] postorderTraversal() {\n    }\n\n    private java.util.List<Integer> postorderTraversalRecursive(TreeNode node, java.util.List<Integer> result) {\n\n    }\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.real.temp.Answer.*;\n/**\n * Test class for BinaryTree operations.\n */\npublic class Tester {\n\n    @Test\n    public void testEmptyTree() {\n        BinaryTree bt = new BinaryTree();\n        assertArrayEquals(new int[]{}, bt.inorderTraversal());\n        assertArrayEquals(new int[]{}, bt.preorderTraversal());\n        assertArrayEquals(new int[]{}, bt.postorderTraversal());\n    }\n\n    @Test\n    public void testSingleNodeTree() {\n        BinaryTree bt = new BinaryTree();\n        bt.insert(10);\n        assertArrayEquals(new int[]{10}, bt.inorderTraversal());\n        assertArrayEquals(new int[]{10}, bt.preorderTraversal());\n        assertArrayEquals(new int[]{10}, bt.postorderTraversal());\n    }\n\n    @Test\n    public void testBalancedTree() {\n        BinaryTree bt = new BinaryTree();\n        int[] elements = {8, 3, 10, 1, 6, 9, 14};\n        for (int elem : elements) {\n            bt.insert(elem);\n        }\n        assertArrayEquals(new int[]{1, 3, 6, 8, 9, 10, 14}, bt.inorderTraversal());\n        assertArrayEquals(new int[]{8, 3, 1, 6, 10, 9, 14}, bt.preorderTraversal());\n        assertArrayEquals(new int[]{1, 6, 3, 9, 14, 10, 8}, bt.postorderTraversal());\n    }\n\n    @Test\n    public void testLeftHeavyTree() {\n        BinaryTree bt = new BinaryTree();\n        for (int i = 10; i > 0; i--) {\n            bt.insert(i);\n        }\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, bt.inorderTraversal());\n        assertArrayEquals(new int[]{10, 9, 8, 7, 6, 5, 4, 3, 2, 1}, bt.preorderTraversal());\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, bt.postorderTraversal());\n    }\n\n    @Test\n    public void testRightHeavyTree() {\n        BinaryTree bt = new BinaryTree();\n        for (int i = 1; i <= 10; i++) {\n            bt.insert(i);\n        }\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, bt.inorderTraversal());\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, bt.preorderTraversal());\n        assertArrayEquals(new int[]{10, 9, 8, 7, 6, 5, 4, 3, 2, 1}, bt.postorderTraversal());\n    }\n}", "prompt": "please write a java class , the function signature as below static class TreeNode {\n    TreeNode left;\n    TreeNode right;\n    int val;\n\n    public TreeNode(int key) {\n        this.left = null;\n        this.right = null;\n        this.val = key;\n    }\n}\n\nstatic class BinaryTree {\n    private TreeNode root;\n\n    public BinaryTree() {\n        this.root = null;\n    }\n\n    public void insert(int key) {\n\n    }\n\n    private void insertRecursive(TreeNode node, int key) {\n\n    }\n\n    public int[] inorderTraversal() {\n    }\n\n    private java.util.List<Integer> inorderTraversalRecursive(TreeNode node, java.util.List<Integer> result) {\n\n    }\n\n    public int[] preorderTraversal() {\n    }\n\n    private java.util.List<Integer> preorderTraversalRecursive(TreeNode node, java.util.List<Integer> result) {\n\n    }\n\n    public int[] postorderTraversal() {\n    }\n\n    private java.util.List<Integer> postorderTraversalRecursive(TreeNode node, java.util.List<Integer> result) {\n\n    }\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 63, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "convert a DataFrame object to a table in markdown format", "language_version_list": {"python": {"code_signature": "import pandas as pd\n\n\ndef convert_dataframe_to_markdown(df: pd.DataFrame, md_path: str) -> str:\n    \"\"\"\n    convert a DataFrame object to a table in markdown format\n    For example:\n        input: dataframe {'Name': ['Alice', 'Bob'], 'Age': [25, 30]}\n        output: | Name | Age |\\n| --- | --- |\\n| Alice | 25 |\\n| Bob | 30 |\\n\n\n    Args:\n        df (DataFrame): DataFrame type question\n        md_path (str): output md file path\n\n    Returns:\n        markdown file content str\n    \"\"\"\n", "test_code": "import unittest\n=import pandas as pd\n\n\nclass TestDataframeToMarkdown(unittest.TestCase):\n    def setUp(self):\n        # Create a sample DataFrame\n        self.data = {'Name': ['Alice', 'Bob'], 'Age': [25, 30]}\n        self.df = pd.DataFrame(self.data)\n\n    def test_df_to_str(self):\n        # Test that the function writes the correct markdown to a file\n        expected_markdown = \"| Name   |   Age |\\n|:-------|------:|\\n| Alice  |    25 |\\n| Bob    |    30 |\"\n        result = convert_dataframe_to_markdown(self.df, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_empty_dataframe(self):\n        # Test how the function handles an empty DataFrame\n        df_empty = pd.DataFrame()\n        expected_markdown = \"\"\n        result = convert_dataframe_to_markdown(df_empty, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_single_row_dataframe(self):\n        # Test with a DataFrame that contains only one row\n        df_single_row = pd.DataFrame({'Name': ['Alice'], 'Age': [30]})\n        expected_markdown = \"| Name   |   Age |\\n|:-------|------:|\\n| Alice  |    30 |\"\n        result = convert_dataframe_to_markdown(df_single_row, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_non_string_columns(self):\n        # Test with non-string question types in the DataFrame\n        df_non_string = pd.DataFrame({'Name': ['Alice', 'Bob'], 'Age': [25, 30], 'Height': [5.5, 6.0]})\n        expected_markdown = ('| Name   |   Age |   Height |\\n'\n                             '|:-------|------:|---------:|\\n'\n                             '| Alice  |    25 |      5.5 |\\n'\n                             '| Bob    |    30 |      6   |')\n        result = convert_dataframe_to_markdown(df_non_string, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_special_characters(self):\n        # Test handling of special characters in DataFrame\n        df_special_chars = pd.DataFrame(\n            {'Name': ['Alice', 'Bob'], 'Comments': ['Good@Work!', 'Excellent & Commendable']})\n        expected_markdown = ('| Name   | Comments                |\\n'\n                             '|:-------|:------------------------|\\n'\n                             '| Alice  | Good@Work!              |\\n'\n                             '| Bob    | Excellent & Commendable |')\n        result = convert_dataframe_to_markdown(df_special_chars, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n", "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef convert_dataframe_to_markdown(df: pd.DataFrame, md_path: str) -> str:\n    \"\"\"\n    convert a DataFrame object to a table in markdown format\n    For example:\n        input: dataframe {'Name': ['Alice', 'Bob'], 'Age': [25, 30]}\n        output: | Name | Age |\\n| --- | --- |\\n| Alice | 25 |\\n| Bob | 30 |\\n\n\n    Args:\n        df (DataFrame): DataFrame type question\n        md_path (str): output md file path\n\n    Returns:\n        markdown file content str\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 64, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Converts the contents of a csv file into an SQL insert statement with a table name with the suffix removed", "language_version_list": {"python": {"code_signature": "import csv\nimport os\n\n\ndef csv_to_sql_insert(csv_file_path: str) -> str:\n    \"\"\"\n    Converts the contents of a csv file into an SQL insert statement with a table name with the suffix removed.\n\n    Args:\n        csv_file_path (str): csv file path\n\n    Returns:\n        str: parsed sql str\n    \"\"\"\n", "test_code": "import unittest\nimport os\n\n\nclass TestCsvToSqlInsert(unittest.TestCase):\n\n    def setUp(self):\n        # Create sample CSV files for testing\n        self.test_files = {\n            'test1.csv': 'id,name,age\\n1,Alice,30\\n2,Bob,25',\n            'test2.csv': 'product_id,product_name,price\\n101,Widget,9.99\\n102,Gadget,12.49',\n            'test3.csv': 'user_id,email\\n3,test@example.com\\n4,user@domain.com',\n            'test4.csv': 'order_id,order_date,total\\n1001,2024-09-01,59.99',\n            'test5.csv': 'quote_id,quote\\n1,\"It\\'s a beautiful day.\"\\n2,\"She said, \"\"Hello!\"\"\"'\n        }\n        # Create the files on disk\n        for filename, content in self.test_files.items():\n            with open(filename, 'w') as f:\n                f.write(content)\n\n    def tearDown(self):\n        # Remove the test files after tests\n        for filename in self.test_files:\n            os.remove(filename)\n\n    def test_simple_csv(self):\n        expected_sql = (\n            \"INSERT INTO test1 (id, name, age) VALUES ('1', 'Alice', '30');\\n\"\n            \"INSERT INTO test1 (id, name, age) VALUES ('2', 'Bob', '25');\"\n        )\n        result = csv_to_sql_insert('test1.csv')\n        self.assertEqual(result, expected_sql)\n\n    def test_product_csv(self):\n        expected_sql = (\n            \"INSERT INTO test2 (product_id, product_name, price) VALUES ('101', 'Widget', '9.99');\\n\"\n            \"INSERT INTO test2 (product_id, product_name, price) VALUES ('102', 'Gadget', '12.49');\"\n        )\n        result = csv_to_sql_insert('test2.csv')\n        self.assertEqual(result, expected_sql)\n\n    def test_email_csv(self):\n        expected_sql = (\n            \"INSERT INTO test3 (user_id, email) VALUES ('3', 'test@example.com');\\n\"\n            \"INSERT INTO test3 (user_id, email) VALUES ('4', 'user@domain.com');\"\n        )\n        result = csv_to_sql_insert('test3.csv')\n        self.assertEqual(result, expected_sql)\n\n    def test_date_and_decimal_csv(self):\n        expected_sql = (\n            \"INSERT INTO test4 (order_id, order_date, total) VALUES ('1001', '2024-09-01', '59.99');\"\n        )\n        result = csv_to_sql_insert('test4.csv')\n        self.assertEqual(result, expected_sql)", "prompt": "please write a python function , the function signature as below import csv\nimport os\n\n\ndef csv_to_sql_insert(csv_file_path: str) -> str:\n    \"\"\"\n    Converts the contents of a csv file into an SQL insert statement with a table name with the suffix removed.\n\n    Args:\n        csv_file_path (str): csv file path\n\n    Returns:\n        str: parsed sql str\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "const fs = require('fs');\nconst path = require('path');\nconst csvParser = require('csv-parser');\n\n/**\n * Converts the contents of a CSV file into an SQL insert statement with a table name with the suffix removed.\n * \n * @param {string} csvFilePath - The path to the CSV file.\n * @returns {Promise<string>} A promise that resolves to the parsed SQL insert statements.\n */\nfunction csvToSqlInsert(csvFilePath) {}", "test_code": "const fs = require('fs');\nconst path = require('path');\nconst csvParser = require('csv-parser');\n\ndescribe('TestCsvToSqlInsert', () => {\n  beforeAll(() => {\n      // Create sample CSV files for testing\n      const testFiles = {\n          'test1.csv': 'id,name,age\\n1,Alice,30\\n2,Bob,25',\n          'test2.csv': 'product_id,product_name,price\\n101,Widget,9.99\\n102,Gadget,12.49',\n          'test3.csv': 'user_id,email\\n3,test@example.com\\n4,user@domain.com',\n          'test4.csv': 'order_id,order_date,total\\n1001,2024-09-01,59.99',\n          'test5.csv': 'quote_id,quote\\n1,\"It\\'s a beautiful day.\"\\n2,\"She said, \"\"Hello!\"\"\"'\n      };\n\n      // Create the files on disk\n      for (const [filename, content] of Object.entries(testFiles)) {\n          fs.writeFileSync(filename, content);\n      }\n  });\n\n  afterAll(() => {\n      // Remove the test files after tests\n      const testFiles = Object.keys(testFiles);\n      testFiles.forEach(filename => fs.unlinkSync(filename));\n  });\n\n  it('should handle simple CSV correctly', () => {\n      const expectedSql = (\n          \"INSERT INTO test1 (id, name, age) VALUES ('1', 'Alice', '30');\\n\" +\n          \"INSERT INTO test1 (id, name, age) VALUES ('2', 'Bob', '25');\"\n      );\n      const result = csv_to_sql_insert('test1.csv');\n      expect(result).toEqual(expectedSql);\n  });\n\n  it('should handle product CSV correctly', () => {\n      const expectedSql = (\n          \"INSERT INTO test2 (product_id, product_name, price) VALUES ('101', 'Widget', '9.99');\\n\" +\n          \"INSERT INTO test2 (product_id, product_name, price) VALUES ('102', 'Gadget', '12.49');\"\n      );\n      const result = csv_to_sql_insert('test2.csv');\n      expect(result).toEqual(expectedSql);\n  });\n\n  it('should handle email CSV correctly', () => {\n      const expectedSql = (\n          \"INSERT INTO test3 (user_id, email) VALUES ('3', 'test@example.com');\\n\" +\n          \"INSERT INTO test3 (user_id, email) VALUES ('4', 'user@domain.com');\"\n      );\n      const result = csv_to_sql_insert('test4.csv');\n      expect(result).toEqual(expectedSql);\n  });\n\n  it('should handle date and decimal CSV correctly', () => {\n      const expectedSql = (\n          \"INSERT INTO test4 (order_id, order_date, total) VALUES ('1001', '2024-09-01', '59.99');\"\n      );\n      const result = csv_to_sql_insert('test4.csv');\n      expect(result).toEqual(expectedSql);\n  });\n});", "prompt": "please write a javascript function , the function signature as below const fs = require('fs');\nconst path = require('path');\nconst csvParser = require('csv-parser');\n\n/**\n * Converts the contents of a CSV file into an SQL insert statement with a table name with the suffix removed.\n * \n * @param {string} csvFilePath - The path to the CSV file.\n * @returns {Promise<string>} A promise that resolves to the parsed SQL insert statements.\n */\nfunction csvToSqlInsert(csvFilePath) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as fs from 'fs';\nimport * as path from 'path';\nimport * as csvParser from 'csv-parser';\n\n/**\n * Converts the contents of a CSV file into an SQL insert statement with a table name with the suffix removed.\n * \n * @param csvFilePath - The path to the CSV file.\n * @returns A string containing the SQL insert statements.\n */\nfunction csvToSqlInsert(csvFilePath: string): string {}", "test_code": "import * as fs from 'fs';\nimport * as path from 'path';\nimport * as csvParser from 'csv-parser';\n\n\ndescribe('TestCsvToSqlInsert', () => {\n  const testFiles = {\n      'test1.csv': 'id,name,age\\n1,Alice,30\\n2,Bob,25',\n      'test2.csv': 'product_id,product_name,price\\n101,Widget,9.99\\n102,Gadget,12.49',\n      'test3.csv': 'user_id,email\\n3,test@example.com\\n4,user@domain.com',\n      'test4.csv': 'order_id,order_date,total\\n1001,2024-09-01,59.99',\n      'test5.csv': 'quote_id,quote\\n1,\"It\\'s a beautiful day.\"\\n2,\"She said, \"\"Hello!\"\"\"'\n  };\n\n  beforeAll(() => {\n      // Create the sample CSV files for testing\n      for (const [filename, content] of Object.entries(testFiles)) {\n          fs.writeFileSync(filename, content);\n      }\n  });\n\n  afterAll(() => {\n      // Remove the test files after tests\n      for (const filename of Object.keys(testFiles)) {\n          fs.unlinkSync(filename);\n      }\n  });\n\n  it('should handle simple CSV correctly', () => {\n      const expectedSql = (\n          \"INSERT INTO test1 (id, name, age) VALUES ('1', 'Alice', '30');\\n\" +\n          \"INSERT INTO test1 (id, name, age) VALUES ('2', 'Bob', '25');\"\n      );\n      const result = csvToSqlInsert('test1.csv');\n      expect(result).toEqual(expectedSql);\n  });\n\n  it('should handle product CSV correctly', () => {\n      const expectedSql = (\n          \"INSERT INTO test2 (product_id, product_name, price) VALUES ('101', 'Widget', '9.99');\\n\" +\n          \"INSERT INTO test2 (product_id, product_name, price) VALUES ('102', 'Gadget', '12.49');\"\n      );\n      const result = csvToSqlInsert('test2.csv');\n      expect(result).toEqual(expectedSql);\n  });\n\n  it('should handle email CSV correctly', () => {\n      const expectedSql = (\n          \"INSERT INTO test3 (user_id, email) VALUES ('3', 'test@example.com');\\n\" +\n          \"INSERT INTO test3 (user_id, email) VALUES ('4', 'user@domain.com');\"\n      );\n      const result = csvToSqlInsert('test3.csv');\n      expect(result).toEqual(expectedSql);\n  });\n\n  it('should handle date and decimal CSV correctly', () => {\n      const expectedSql = (\n          \"INSERT INTO test4 (order_id, order_date, total) VALUES ('1001', '2024-09-01', '59.99');\"\n      );\n      const result = csvToSqlInsert('test4.csv');\n      expect(result).toEqual(expectedSql);\n  });\n});", "prompt": "please write a typescript function , the function signature as below import * as fs from 'fs';\nimport * as path from 'path';\nimport * as csvParser from 'csv-parser';\n\n/**\n * Converts the contents of a CSV file into an SQL insert statement with a table name with the suffix removed.\n * \n * @param csvFilePath - The path to the CSV file.\n * @returns A string containing the SQL insert statements.\n */\nfunction csvToSqlInsert(csvFilePath: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts the contents of a CSV file into an SQL insert statement with the table name derived from the file name.\n *\n * @param csv_file_path The path to the CSV file.\n * @return A string containing the SQL insert statements.\n */\nstd::string csv_to_sql_insert(const std::string& csv_file_path) {}", "test_code": "TEST_CASE(\"TestCsvToSqlInsert\", \"[csv_to_sql_insert]\") {\n    // Create sample CSV files for testing\n    std::map<std::string, std::string> test_files = {\n        {\"test1.csv\", \"id,name,age\\n1,Alice,30\\n2,Bob,25\"},\n        {\"test2.csv\", \"product_id,product_name,price\\n101,Widget,9.99\\n102,Gadget,12.49\"},\n        {\"test3.csv\", \"user_id,email\\n3,test@example.com\\n4,user@domain.com\"},\n        {\"test4.csv\", \"order_id,order_date,total\\n1001,2024-09-01,59.99\"},\n        {\"test5.csv\", \"quote_id,quote\\n1,\\\"It's a beautiful day.\\\"\\n2,\\\"She said, \\\"\\\"Hello!\\\"\\\"\\\"\"}\n    };\n\n    // Create the files on disk\n    for (const auto& [filename, content] : test_files) {\n        std::ofstream file(filename);\n        file << content;\n        file.close();\n    }\n\n    SECTION(\"test_simple_csv\") {\n        std::string expected_sql = (\n            \"INSERT INTO test1 (id, name, age) VALUES ('1', 'Alice', '30');\\n\"\n            \"INSERT INTO test1 (id, name, age) VALUES ('2', 'Bob', '25');\"\n        );\n        std::string result = csv_to_sql_insert(\"test1.csv\");\n        REQUIRE(result == expected_sql);\n    }\n\n    SECTION(\"test_product_csv\") {\n        std::string expected_sql = (\n            \"INSERT INTO test2 (product_id, product_name, price) VALUES ('101', 'Widget', '9.99');\\n\"\n            \"INSERT INTO test2 (product_id, product_name, price) VALUES ('102', 'Gadget', '12.49');\"\n        );\n        std::string result = csv_to_sql_insert(\"test2.csv\");\n        REQUIRE(result == expected_sql);\n    }\n\n    SECTION(\"test_email_csv\") {\n        std::string expected_sql = (\n            \"INSERT INTO test3 (user_id, email) VALUES ('3', 'test@example.com');\\n\"\n            \"INSERT INTO test3 (user_id, email) VALUES ('4', 'user@domain.com');\"\n        );\n        std::string result = csv_to_sql_insert(\"test3.csv\");\n        REQUIRE(result == expected_sql);\n    }\n\n    SECTION(\"test_date_and_decimal_csv\") {\n        std::string expected_sql = (\n            \"INSERT INTO test4 (order_id, order_date, total) VALUES ('1001', '2024-09-01', '59.99');\"\n        );\n        std::string result = csv_to_sql_insert(\"test4.csv\");\n        REQUIRE(result == expected_sql);\n    }\n\n    // Remove the test files after tests\n    for (const auto& filename : test_files) {\n        fs::remove(filename.first);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts the contents of a CSV file into an SQL insert statement with the table name derived from the file name.\n *\n * @param csv_file_path The path to the CSV file.\n * @return A string containing the SQL insert statements.\n */\nstd::string csv_to_sql_insert(const std::string& csv_file_path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts the contents of a CSV file into an SQL insert statement with the table name derived from the file name.\n *\n * @param csvFilePath the path to the CSV file\n * @return a string containing the SQL insert statements\n */\npublic static String csvToSqlInsert(String csvFilePath) {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    private Map<String, String> testFiles = new HashMap<String, String>() {{\n        put(\"test1.csv\", \"id,name,age\\n1,Alice,30\\n2,Bob,25\");\n        put(\"test2.csv\", \"product_id,product_name,price\\n101,Widget,9.99\\n102,Gadget,12.49\");\n        put(\"test3.csv\", \"user_id,email\\n3,test@example.com\\n4,user@domain.com\");\n        put(\"test4.csv\", \"order_id,order_date,total\\n1001,2024-09-01,59.99\");\n        put(\"test5.csv\", \"quote_id,quote\\n1,\\\"It's a beautiful day.\\\"\\n2,\\\"She said, \\\"\\\"Hello!\\\"\\\"\\\"\");\n    }};\n\n    private Path tempDir;\n\n    @Before\n    public void setUp() throws IOException {\n        // Create a temporary directory\n        tempDir = Files.createTempDirectory(\"tempDir\");\n\n        // Create the sample CSV files in the temporary directory\n        for (Map.Entry<String, String> entry : testFiles.entrySet()) {\n            File file = tempDir.resolve(entry.getKey()).toFile();\n            try (FileWriter writer = new FileWriter(file)) {\n                writer.write(entry.getValue());\n            }\n        }\n    }\n\n    @After\n    public void tearDown() throws IOException {\n        // Delete the temporary directory and its contents\n        Files.walk(tempDir)\n                .sorted((path1, path2) -> path2.compareTo(path1)) // Sort in reverse order to delete files before directories\n                .map(Path::toFile)\n                .forEach(File::delete);\n    }\n\n    @Test\n    public void testSimpleCsv() throws IOException {\n        String expectedSql = \"INSERT INTO test1 (id, name, age) VALUES ('1', 'Alice', '30');\\n\"\n                + \"INSERT INTO test1 (id, name, age) VALUES ('2', 'Bob', '25');\";\n\n        String result = csvToSqlInsert(tempDir.resolve(\"test1.csv\").toString());\n        assertEquals(expectedSql, result);\n    }\n\n    @Test\n    public void testProductCsv() throws IOException {\n        String expectedSql = \"INSERT INTO test2 (product_id, product_name, price) VALUES ('101', 'Widget', '9.99');\\n\"\n                + \"INSERT INTO test2 (product_id, product_name, price) VALUES ('102', 'Gadget', '12.49');\";\n\n        String result = csvToSqlInsert(tempDir.resolve(\"test2.csv\").toString());\n        assertEquals(expectedSql, result);\n    }\n\n    @Test\n    public void testEmailCsv() throws IOException {\n        String expectedSql = \"INSERT INTO test3 (user_id, email) VALUES ('3', 'test@example.com');\\n\"\n                + \"INSERT INTO test3 (user_id, email) VALUES ('4', 'user@domain.com');\";\n\n        String result = csvToSqlInsert(tempDir.resolve(\"test3.csv\").toString());\n        assertEquals(expectedSql, result);\n    }\n\n    @Test\n    public void testDateAndDecimalCsv() throws IOException {\n        String expectedSql = \"INSERT INTO 'test4' (order_id, order_date, total) VALUES ('1001', '2024-09-01', '59.99');\";\n\n        String result = csvToSqlInsert(tempDir.resolve(\"test4.csv\").toString());\n        assertEquals(expectedSql, result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts the contents of a CSV file into an SQL insert statement with the table name derived from the file name.\n *\n * @param csvFilePath the path to the CSV file\n * @return a string containing the SQL insert statements\n */\npublic static String csvToSqlInsert(String csvFilePath) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 65, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Find duplicate IPs in the given IP list and exclude IPs specified to ignore\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef find_duplicates_excluding_ips(ip_list: List[str], ignore_list: List[str]) -> List[str]:\n    \"\"\"\n    Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n\n    Args:\n        ip_list (List[str]): List of IP addresses\n        ignore_list (List[str]): List of IP addresses to ignor\n\n    Returns:\n        List[str]: A list of duplicate IPs excluding those in the ignore list.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFindDuplicateIPs(unittest.TestCase):\n\n    def test_basic_duplicates(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.1\"]\n        ignore_list = []\n        self.assertEqual(find_duplicates_excluding_ips(ip_list, ignore_list), [\"192.168.1.1\"])\n\n    def test_ignored_duplicates(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.2\"]\n        ignore_list = [\"192.168.1.1\"]\n        self.assertEqual(find_duplicates_excluding_ips(ip_list, ignore_list), [])\n\n    def test_no_duplicates(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.3\"]\n        ignore_list = []\n        self.assertEqual(find_duplicates_excluding_ips(ip_list, ignore_list), [])\n\n    def test_mixed_duplicates(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.1\", \"10.0.0.1\", \"192.168.1.2\"]\n        ignore_list = [\"192.168.1.2\"]\n        self.assertEqual(find_duplicates_excluding_ips(ip_list, ignore_list), [\"192.168.1.1\"])\n\n    def test_empty_input(self):\n        ip_list = []\n        ignore_list = []\n        self.assertEqual(find_duplicates_excluding_ips(ip_list, ignore_list), [])\n\n    def test_only_ignored_ips(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.1\"]\n        ignore_list = [\"192.168.1.1\"]\n        self.assertEqual(find_duplicates_excluding_ips(ip_list, ignore_list), [])\n\n    def test_all_duplicates(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.1\"]\n        ignore_list = []\n        self.assertEqual(find_duplicates_excluding_ips(ip_list, ignore_list), [\"192.168.1.1\"])", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_duplicates_excluding_ips(ip_list: List[str], ignore_list: List[str]) -> List[str]:\n    \"\"\"\n    Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n\n    Args:\n        ip_list (List[str]): List of IP addresses\n        ignore_list (List[str]): List of IP addresses to ignor\n\n    Returns:\n        List[str]: A list of duplicate IPs excluding those in the ignore list.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n *\n * @param {string[]} ipList - List of IP addresses.\n * @param {string[]} ignoreList - List of IP addresses to ignore.\n * @returns {string[]} A list of duplicate IPs excluding those in the ignore list.\n */\nfunction findDuplicateIPs(ipList, ignoreList) {}", "test_code": "describe('TestFindDuplicateIPs', () => {\n  it('should handle basic duplicates', () => {\n      const ipList = [\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.1\"];\n      const ignoreList = [];\n      expect(findDuplicateIPs(ipList, ignoreList)).toEqual([\"192.168.1.1\"]);\n  });\n\n  it('should handle ignored duplicates', () => {\n      const ipList = [\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.2\"];\n      const ignoreList = [\"192.168.1.1\"];\n      expect(findDuplicateIPs(ipList, ignoreList)).toEqual([]);\n  });\n\n  it('should handle no duplicates', () => {\n      const ipList = [\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.3\"];\n      const ignoreList = [];\n      expect(findDuplicateIPs(ipList, ignoreList)).toEqual([]);\n  });\n\n  it('should handle mixed duplicates', () => {\n      const ipList = [\"192.168.1.1\", \"192.168.1.1\", \"10.0.0.1\", \"192.168.1.2\"];\n      const ignoreList = [\"192.168.1.2\"];\n      expect(findDuplicateIPs(ipList, ignoreList)).toEqual([\"192.168.1.1\"]);\n  });\n\n  it('should handle empty input', () => {\n      const ipList = [];\n      const ignoreList = [];\n      expect(findDuplicateIPs(ipList, ignoreList)).toEqual([]);\n  });\n\n  it('should handle only ignored IPs', () => {\n      const ipList = [\"192.168.1.1\", \"192.168.1.1\"];\n      const ignoreList = [\"192.168.1.1\"];\n      expect(findDuplicateIPs(ipList, ignoreList)).toEqual([]);\n  });\n\n  it('should handle all duplicates', () => {\n      const ipList = [\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.1\"];\n      const ignoreList = [];\n      expect(findDuplicateIPs(ipList, ignoreList)).toEqual([\"192.168.1.1\"]);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n *\n * @param {string[]} ipList - List of IP addresses.\n * @param {string[]} ignoreList - List of IP addresses to ignore.\n * @returns {string[]} A list of duplicate IPs excluding those in the ignore list.\n */\nfunction findDuplicateIPs(ipList, ignoreList) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n *\n * @param ipList - List of IP addresses.\n * @param ignoreList - List of IP addresses to ignore.\n * @returns A list of duplicate IPs excluding those in the ignore list.\n */\nfunction findDuplicateIPs(ipList: string[], ignoreList: string[]): string[] {}", "test_code": "describe('findDuplicateIPs', () => {\n  it('should handle basic duplicates', () => {\n      const ipList = [\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.1\"];\n      const ignoreList = [];\n      expect(findDuplicateIPs(ipList, ignoreList)).toEqual([\"192.168.1.1\"]);\n  });\n\n  it('should handle ignored duplicates', () => {\n      const ipList = [\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.2\"];\n      const ignoreList = [\"192.168.1.1\"];\n      expect(findDuplicateIPs(ipList, ignoreList)).toEqual([]);\n  });\n\n  it('should handle no duplicates', () => {\n      const ipList = [\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.3\"];\n      const ignoreList = [];\n      expect(findDuplicateIPs(ipList, ignoreList)).toEqual([]);\n  });\n\n  it('should handle mixed duplicates', () => {\n      const ipList = [\"192.168.1.1\", \"192.168.1.1\", \"10.0.0.1\", \"192.168.1.2\"];\n      const ignoreList = [\"192.168.1.2\"];\n      expect(findDuplicateIPs(ipList, ignoreList)).toEqual([\"192.168.1.1\"]);\n  });\n\n  it('should handle empty input', () => {\n      const ipList = [];\n      const ignoreList = [];\n      expect(findDuplicateIPs(ipList, ignoreList)).toEqual([]);\n  });\n\n  it('should handle only ignored IPs', () => {\n      const ipList = [\"192.168.1.1\", \"192.168.1.1\"];\n      const ignoreList = [\"192.168.1.1\"];\n      expect(findDuplicateIPs(ipList, ignoreList)).toEqual([]);\n  });\n\n  it('should handle all duplicates', () => {\n      const ipList = [\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.1\"];\n      const ignoreList = [];\n      expect(findDuplicateIPs(ipList, ignoreList)).toEqual([\"192.168.1.1\"]);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n *\n * @param ipList - List of IP addresses.\n * @param ignoreList - List of IP addresses to ignore.\n * @returns A list of duplicate IPs excluding those in the ignore list.\n */\nfunction findDuplicateIPs(ipList: string[], ignoreList: string[]): string[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n *\n * @param ip_list A vector of IP addresses.\n * @param ignore_list A vector of IP addresses to ignore.\n * @return A vector of duplicate IPs excluding those in the ignore list.\n */\nstd::vector<std::string> findDuplicateIPs(const std::vector<std::string>& ipList, const std::vector<std::string>& ignoreList) {}", "test_code": "TEST_CASE(\"Test findDuplicateIPs function\") {\n    SECTION(\"Basic duplicates\") {\n        std::vector<std::string> ipList = {\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.1\"};\n        std::vector<std::string> ignoreList = {};\n        REQUIRE(findDuplicateIPs(ipList, ignoreList) == std::vector<std::string>({\"192.168.1.1\"}));\n    }\n\n    SECTION(\"Ignored duplicates\") {\n        std::vector<std::string> ipList = {\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.2\"};\n        std::vector<std::string> ignoreList = {\"192.168.1.1\"};\n        REQUIRE(findDuplicateIPs(ipList, ignoreList).empty());\n    }\n\n    SECTION(\"No duplicates\") {\n        std::vector<std::string> ipList = {\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.3\"};\n        std::vector<std::string> ignoreList = {};\n        REQUIRE(findDuplicateIPs(ipList, ignoreList).empty());\n    }\n\n    SECTION(\"Mixed duplicates\") {\n        std::vector<std::string> ipList = {\"192.168.1.1\", \"192.168.1.1\", \"10.0.0.1\", \"192.168.1.2\"};\n        std::vector<std::string> ignoreList = {\"192.168.1.2\"};\n        REQUIRE(findDuplicateIPs(ipList, ignoreList) == std::vector<std::string>({\"192.168.1.1\"}));\n    }\n\n    SECTION(\"Empty input\") {\n        std::vector<std::string> ipList = {};\n        std::vector<std::string> ignoreList = {};\n        REQUIRE(findDuplicateIPs(ipList, ignoreList).empty());\n    }\n\n    SECTION(\"Only ignored IPs\") {\n        std::vector<std::string> ipList = {\"192.168.1.1\", \"192.168.1.1\"};\n        std::vector<std::string> ignoreList = {\"192.168.1.1\"};\n        REQUIRE(findDuplicateIPs(ipList, ignoreList).empty());\n    }\n\n    SECTION(\"All duplicates\") {\n        std::vector<std::string> ipList = {\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.1\"};\n        std::vector<std::string> ignoreList = {};\n        REQUIRE(findDuplicateIPs(ipList, ignoreList) == std::vector<std::string>({\"192.168.1.1\"}));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n *\n * @param ip_list A vector of IP addresses.\n * @param ignore_list A vector of IP addresses to ignore.\n * @return A vector of duplicate IPs excluding those in the ignore list.\n */\nstd::vector<std::string> findDuplicateIPs(const std::vector<std::string>& ipList, const std::vector<std::string>& ignoreList) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n *\n * @param ipList      List of IP addresses\n * @param ignoreList  List of IP addresses to ignore\n * @return            A list of duplicate IPs excluding those in the ignore list\n */\npublic static List<String> findDuplicateIps(List<String> ipList, List<String> ignoreList) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testBasicDuplicates() {\n        List<String> ipList = Arrays.asList(\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.1\");\n        List<String> ignoreList = Arrays.asList();\n        assertEquals(Arrays.asList(\"192.168.1.1\"), findDuplicateIps(ipList, ignoreList));\n    }\n\n    @Test\n    public void testIgnoredDuplicates() {\n        List<String> ipList = Arrays.asList(\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.2\");\n        List<String> ignoreList = Arrays.asList(\"192.168.1.1\");\n        assertEquals(Arrays.asList(), findDuplicateIps(ipList, ignoreList));\n    }\n\n    @Test\n    public void testNoDuplicates() {\n        List<String> ipList = Arrays.asList(\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.3\");\n        List<String> ignoreList = Arrays.asList();\n        assertEquals(Arrays.asList(), findDuplicateIps(ipList, ignoreList));\n    }\n\n    @Test\n    public void testMixedDuplicates() {\n        List<String> ipList = Arrays.asList(\"192.168.1.1\", \"192.168.1.1\", \"10.0.0.1\", \"192.168.1.2\");\n        List<String> ignoreList = Arrays.asList(\"192.168.1.2\");\n        assertEquals(Arrays.asList(\"192.168.1.1\"), findDuplicateIps(ipList, ignoreList));\n    }\n\n    @Test\n    public void testEmptyInput() {\n        List<String> ipList = Arrays.asList();\n        List<String> ignoreList = Arrays.asList();\n        assertEquals(Arrays.asList(), findDuplicateIps(ipList, ignoreList));\n    }\n\n    @Test\n    public void testOnlyIgnoredIPs() {\n        List<String> ipList = Arrays.asList(\"192.168.1.1\", \"192.168.1.1\");\n        List<String> ignoreList = Arrays.asList(\"192.168.1.1\");\n        assertEquals(Arrays.asList(), findDuplicateIps(ipList, ignoreList));\n    }\n\n    @Test\n    public void testAllDuplicates() {\n        List<String> ipList = Arrays.asList(\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.1\");\n        List<String> ignoreList = Arrays.asList();\n        assertEquals(Arrays.asList(\"192.168.1.1\"), findDuplicateIps(ipList, ignoreList));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n *\n * @param ipList      List of IP addresses\n * @param ignoreList  List of IP addresses to ignore\n * @return            A list of duplicate IPs excluding those in the ignore list\n */\npublic static List<String> findDuplicateIps(List<String> ipList, List<String> ignoreList) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 66, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Performs a topological sort on a collection of courses using Kahn's algorithm.", "language_version_list": {"python": {"code_signature": "from typing import Iterable, List\n\n\nclass Course:\n    def __init__(self, course_id, must_courses=None, recommend_courses=None):\n        self.id = course_id\n        self.must_courses = must_courses if must_courses is not None else []\n        self.recommend_courses = recommend_courses if recommend_courses is not None else []\n\n\nclass LeveledCourse:\n    def __init__(self, course: Course, level: int):\n        self.course = course\n        self.level = level\n\ndef topological_sort(courses: Iterable[Course]) -> List[LeveledCourse]:\n    \"\"\"\n    Performs a topological sort on a collection of courses using Kahn's algorithm.\n\n    Args:\n    courses (Iterable[Course]): A collection of courses, where each course is assumed to have an 'id',\n                                and optionally 'must_courses' and 'recommend_courses' lists of course ids.\n\n    Returns:\n    List[LeveledCourse]: A list of courses sorted in topological order, each wrapped in a LeveledCourse\n                         object that also contains the level (i.e., distance from start in topological sort).\n\n    Raises:\n    ValueError: If there is a cycle detected in the courses, which prevents a complete topological sort.\n    \"\"\"\n", "test_code": "import unittest\n\nclass Course:\n    def __init__(self, course_id, must_courses=None, recommend_courses=None):\n        self.id = course_id\n        self.must_courses = must_courses if must_courses is not None else []\n        self.recommend_courses = recommend_courses if recommend_courses is not None else []\n\n\nclass LeveledCourse:\n    def __init__(self, course: Course, level: int):\n        self.course = course\n        self.level = level\n\nclass TestTopologicalSort(unittest.TestCase):\n\n    def test_empty_list(self):\n        \"\"\" Test sorting with no courses \"\"\"\n        courses = []\n        self.assertEqual(topological_sort(courses), [])\n\n    def test_single_course(self):\n        \"\"\" Test sorting with one course that has no dependencies \"\"\"\n        courses = [Course(\"101\")]\n        sorted_courses = topological_sort(courses)\n        self.assertEqual(len(sorted_courses), 1)\n        self.assertEqual(sorted_courses[0].course.id, \"101\")\n\n    def test_basic_dependency(self):\n        \"\"\" Test sorting where one course directly depends on another \"\"\"\n        courses = [Course(\"101\"), Course(\"102\", [\"101\"])]\n        sorted_courses = topological_sort(courses)\n        self.assertEqual([course.course.id for course in sorted_courses], [\"101\", \"102\"])\n\n    def test_complex_dependency(self):\n        \"\"\" Test a complex scenario with multiple dependencies \"\"\"\n        courses = [\n            Course(\"Math\"),\n            Course(\"Advanced Math\", [\"Math\"]),\n            Course(\"Physics\", [\"Math\"], [\"Advanced Math\"]),\n            Course(\"Chemistry\")\n        ]\n        sorted_courses = topological_sort(courses)\n        ids = [course.course.id for course in sorted_courses]\n        self.assertTrue(ids.index(\"Math\") < ids.index(\"Advanced Math\"))\n        self.assertTrue(ids.index(\"Math\") < ids.index(\"Physics\"))\n\n    def test_cycle_detection(self):\n        \"\"\" Test detection of cycles in course prerequisites \"\"\"\n        courses = [Course(\"101\", [\"102\"]), Course(\"102\", [\"101\"])]\n        with self.assertRaises(ValueError):\n            topological_sort(courses)", "prompt": "please write a python function , the function signature as below from typing import Iterable, List\n\n\nclass Course:\n    def __init__(self, course_id, must_courses=None, recommend_courses=None):\n        self.id = course_id\n        self.must_courses = must_courses if must_courses is not None else []\n        self.recommend_courses = recommend_courses if recommend_courses is not None else []\n\n\nclass LeveledCourse:\n    def __init__(self, course: Course, level: int):\n        self.course = course\n        self.level = level\n\ndef topological_sort(courses: Iterable[Course]) -> List[LeveledCourse]:\n    \"\"\"\n    Performs a topological sort on a collection of courses using Kahn's algorithm.\n\n    Args:\n    courses (Iterable[Course]): A collection of courses, where each course is assumed to have an 'id',\n                                and optionally 'must_courses' and 'recommend_courses' lists of course ids.\n\n    Returns:\n    List[LeveledCourse]: A list of courses sorted in topological order, each wrapped in a LeveledCourse\n                         object that also contains the level (i.e., distance from start in topological sort).\n\n    Raises:\n    ValueError: If there is a cycle detected in the courses, which prevents a complete topological sort.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 67, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "parse the XAML file, extract the key-value pairs within the String element, and return the result in a dictionary\n", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef parse_xaml_to_dict(xaml_file: str) -> Dict[str, str]:\n    \"\"\"\n    parse the XAML file, extract the key-value pairs within the String element, and return the model_answer_result in a dictionary\n    Args:\n        xaml_file (str): Path to the XAML file.\n\n    Returns:\n        A dictionary containing the key-value pairs extracted from 'String' elements.\n    \"\"\"\n", "test_code": "import unittest\nimport xml.etree.ElementTree as ET\nfrom io import StringIO\n\n\nclass TestParseXamlToDict(unittest.TestCase):\n    def test_valid_strings(self):\n        xaml_data = \"\"\"<root>\n                         <String Key=\"Username\">Alice</String>\n                         <String Key=\"Password\">secret</String>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {'Username': 'Alice', 'Password': 'secret'}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n\n    def test_missing_key_attribute(self):\n        xaml_data = \"\"\"<root>\n                         <String>Alice</String>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n\n\n    def test_no_string_tags(self):\n        xaml_data = \"\"\"<root>\n                         <Data>Some question</Data>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n\n    def test_nested_string_tags(self):\n        xaml_data = \"\"\"<root>\n                         <Container>\n                           <String Key=\"Username\">Bob</String>\n                         </Container>\n                         <String Key=\"Location\">Earth</String>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {'Username': 'Bob', 'Location': 'Earth'}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef parse_xaml_to_dict(xaml_file: str) -> Dict[str, str]:\n    \"\"\"\n    parse the XAML file, extract the key-value pairs within the String element, and return the model_answer_result in a dictionary\n    Args:\n        xaml_file (str): Path to the XAML file.\n\n    Returns:\n        A dictionary containing the key-value pairs extracted from 'String' elements.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Parses a XAML file, extracts the key-value pairs within the 'String' elements, and returns the result in a dictionary.\n * @param {string} xamlFile - Path to the XAML file.\n * @returns {Object} A dictionary containing the key-value pairs extracted from 'String' elements.\n */\nfunction parseXamlToDict(xamlFile) {}", "test_code": "const { parse } = require('xml2js');\n\ndescribe('TestParseXamlToDict', () => {\n    it('should correctly parse valid strings', () => {\n        const xamlData = `\n            <root>\n                <String Key=\"Username\">Alice</String>\n                <String Key=\"Password\">secret</String>\n            </root>\n        `;\n        const expected = { Username: 'Alice', Password: 'secret' };\n        const result = parseXamlToDict(xamlData);\n        expect(result).toEqual(expected);\n    });\n\n    it('should handle missing key attribute', () => {\n        const xamlData = `\n            <root>\n                <String>Alice</String>\n            </root>\n        `;\n        const expected = {};\n        const result = parseXamlToDict(xamlData);\n        expect(result).toEqual(expected);\n    });\n\n    it('should handle no string tags', () => {\n        const xamlData = `\n            <root>\n                <Data>Some question</Data>\n            </root>\n        `;\n        const expected = {};\n        const result = parseXamlToDict(xamlData);\n        expect(result).toEqual(expected);\n    });\n\n    it('should correctly parse nested string tags', () => {\n        const xamlData = `\n            <root>\n                <Container>\n                    <String Key=\"Username\">Bob</String>\n                </Container>\n                <String Key=\"Location\">Earth</String>\n            </root>\n        `;\n        const expected = { Username: 'Bob', Location: 'Earth' };\n        const result = parseXamlToDict(xamlData);\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Parses a XAML file, extracts the key-value pairs within the 'String' elements, and returns the result in a dictionary.\n * @param {string} xamlFile - Path to the XAML file.\n * @returns {Object} A dictionary containing the key-value pairs extracted from 'String' elements.\n */\nfunction parseXamlToDict(xamlFile) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as fs from 'fs';\nimport * as xml2js from 'xml2js';\n\n/**\n * Parses a XAML file, extracts the key-value pairs within the 'String' elements,\n * and returns the result in a dictionary.\n * \n * @param xamlFile - Path to the XAML file.\n * @returns A dictionary containing the key-value pairs extracted from 'String' elements.\n */\nfunction parseXamlToDict(xamlFile: string): Record<string, string> {}", "test_code": "import * as fs from 'fs';\nimport * as xml2js from 'xml2js';\n\ndescribe('TestParseXamlToDict', () => {\n  it('should correctly parse valid strings', () => {\n    const xamlData = `\n      <root>\n        <String Key=\"Username\">Alice</String>\n        <String Key=\"Password\">secret</String>\n      </root>\n    `;\n    const expected = { Username: 'Alice', Password: 'secret' };\n    const result = parseXamlToDict(xamlData);\n    expect(result).toEqual(expected);\n  });\n\n  it('should handle missing key attribute', () => {\n    const xamlData = `\n      <root>\n        <String>Alice</String>\n      </root>\n    `;\n    const expected = {};\n    const result = parseXamlToDict(xamlData);\n    expect(result).toEqual(expected);\n  });\n\n  it('should handle no string tags', () => {\n    const xamlData = `\n      <root>\n        <Data>Some question</Data>\n      </root>\n    `;\n    const expected = {};\n    const result = parseXamlToDict(xamlData);\n    expect(result).toEqual(expected);\n  });\n\n  it('should correctly parse nested string tags', () => {\n    const xamlData = `\n      <root>\n        <Container>\n          <String Key=\"Username\">Bob</String>\n        </Container>\n        <String Key=\"Location\">Earth</String>\n      </root>\n    `;\n    const expected = { Username: 'Bob', Location: 'Earth' };\n    const result = parseXamlToDict(xamlData);\n    expect(result).toEqual(expected);\n  });\n});", "prompt": "please write a typescript function , the function signature as below import * as fs from 'fs';\nimport * as xml2js from 'xml2js';\n\n/**\n * Parses a XAML file, extracts the key-value pairs within the 'String' elements,\n * and returns the result in a dictionary.\n * \n * @param xamlFile - Path to the XAML file.\n * @returns A dictionary containing the key-value pairs extracted from 'String' elements.\n */\nfunction parseXamlToDict(xamlFile: string): Record<string, string> {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Parse the XAML file, extract the key-value pairs within the String element, and return the result in a dictionary.\n *\n * @param xaml_file The path to the XAML file.\n * @return A map containing the key-value pairs extracted from 'String' elements.\n */\nstd::map<std::string, std::string> parse_xaml_to_dict(const std::string& xaml_file) {}", "test_code": "TEST_CASE(\"Test parse_xaml_to_dict\", \"[parse_xaml_to_dict]\") {\n    SECTION(\"test_valid_strings\") {\n        std::string xaml_data = R\"(<root>\n                                     <String Key=\"Username\">Alice</String>\n                                     <String Key=\"Password\">secret</String>\n                                   </root>)\";\n        std::map<std::string, std::string> expected = {{\"Username\", \"Alice\"}, {\"Password\", \"secret\"}};\n        std::map<std::string, std::string> result = parse_xaml_to_dict(xaml_data);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_missing_key_attribute\") {\n        std::string xaml_data = R\"(<root>\n                                     <String>Alice</String>\n                                   </root>)\";\n        std::map<std::string, std::string> expected = {};\n        std::map<std::string, std::string> result = parse_xaml_to_dict(xaml_data);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_no_string_tags\") {\n        std::string xaml_data = R\"(<root>\n                                     <Data>Some question</Data>\n                                   </root>)\";\n        std::map<std::string, std::string> expected = {};\n        std::map<std::string, std::string> result = parse_xaml_to_dict(xaml_data);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_nested_string_tags\") {\n        std::string xaml_data = R\"(<root>\n                                     <Container>\n                                       <String Key=\"Username\">Bob</String>\n                                     </Container>\n                                     <String Key=\"Location\">Earth</String>\n                                   </root>)\";\n        std::map<std::string, std::string> expected = {{\"Username\", \"Bob\"}, {\"Location\", \"Earth\"}};\n        std::map<std::string, std::string> result = parse_xaml_to_dict(xaml_data);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Parse the XAML file, extract the key-value pairs within the String element, and return the result in a dictionary.\n *\n * @param xaml_file The path to the XAML file.\n * @return A map containing the key-value pairs extracted from 'String' elements.\n */\nstd::map<std::string, std::string> parse_xaml_to_dict(const std::string& xaml_file) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Parses a XAML file, extracts the key-value pairs within the 'String' elements,\n * and returns the result in a dictionary.\n *\n * @param xamlFile Path to the XAML file.\n * @return A map containing the key-value pairs extracted from 'String' elements.\n */\npublic static Map<String, String> parseXamlToDict(String xamlFile) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport java.util.HashMap;\nimport java.util.Map;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testValidStrings() {\n        String xamlData = \"<root>\\n\" +\n                \"  <String Key=\\\"Username\\\">Alice</String>\\n\" +\n                \"  <String Key=\\\"Password\\\">secret</String>\\n\" +\n                \"</root>\";\n        Map<String, String> expected = new HashMap<>();\n        expected.put(\"Username\", \"Alice\");\n        expected.put(\"Password\", \"secret\");\n\n        Map<String, String> result = parseXamlToDict(xamlData);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testMissingKeyAttribute() {\n        String xamlData = \"<root>\\n\" +\n                \"  <String>Alice</String>\\n\" +\n                \"</root>\";\n        Map<String, String> expected = new HashMap<>();\n\n        Map<String, String> result = parseXamlToDict(xamlData);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testNoStringTags() {\n        String xamlData = \"<root>\\n\" +\n                \"  <Data>Some question</Data>\\n\" +\n                \"</root>\";\n        Map<String, String> expected = new HashMap<>();\n\n        Map<String, String> result = parseXamlToDict(xamlData);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testNestedStringTags() {\n        String xamlData = \"<root>\\n\" +\n                \"  <Container>\\n\" +\n                \"    <String Key=\\\"Username\\\">Bob</String>\\n\" +\n                \"  </Container>\\n\" +\n                \"  <String Key=\\\"Location\\\">Earth</String>\\n\" +\n                \"</root>\";\n        Map<String, String> expected = new HashMap<>();\n        expected.put(\"Username\", \"Bob\");\n        expected.put(\"Location\", \"Earth\");\n\n        Map<String, String> result = parseXamlToDict(xamlData);\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Parses a XAML file, extracts the key-value pairs within the 'String' elements,\n * and returns the result in a dictionary.\n *\n * @param xamlFile Path to the XAML file.\n * @return A map containing the key-value pairs extracted from 'String' elements.\n */\npublic static Map<String, String> parseXamlToDict(String xamlFile) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 68, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "divide a list evenly into n parts and return a list of these parts. If the list length is not divisible by n, additional elements are added to the previous sections one by one\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef split_list_into_parts(lst: List, n: int) -> List:\n    \"\"\"\n    divide a list evenly into n parts and return a list of these parts. If the list length is not divisible by n, additional elements are added to the previous sections one by one\n    Args:\n        lst (List): The list to be divided.\n        n (int): The number of parts to divide the list into.\n\n    Returns:\n        A list containing n sublists, where each sublist represents a part of the original list.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestDivideList(unittest.TestCase):\n    def test_even_division(self):\n        lst = [1, 2, 3, 4, 5, 6]\n        n = 3\n        expected = [[1, 2], [3, 4], [5, 6]]\n        self.assertEqual(split_list_into_parts(lst, n), expected)\n\n    def test_uneven_division(self):\n        lst = [1, 2, 3, 4, 5, 6, 7]\n        n = 3\n        expected = [[1, 2, 3], [4, 5], [6, 7]]\n        self.assertEqual(split_list_into_parts(lst, n), expected)\n\n    def test_more_parts_than_items(self):\n        lst = [1, 2, 3]\n        n = 5\n        expected = [[1], [2], [3], [], []]\n        self.assertEqual(split_list_into_parts(lst, n), expected)\n\n    def test_single_element(self):\n        lst = [1]\n        n = 1\n        expected = [[1]]\n        self.assertEqual(split_list_into_parts(lst, n), expected)\n\n    def test_empty_list(self):\n        lst = []\n        n = 3\n        expected = [[], [], []]\n        self.assertEqual(split_list_into_parts(lst, n), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef split_list_into_parts(lst: List, n: int) -> List:\n    \"\"\"\n    divide a list evenly into n parts and return a list of these parts. If the list length is not divisible by n, additional elements are added to the previous sections one by one\n    Args:\n        lst (List): The list to be divided.\n        n (int): The number of parts to divide the list into.\n\n    Returns:\n        A list containing n sublists, where each sublist represents a part of the original list.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Divide an array evenly into n parts and return an array of these parts. If the array length is not divisible by n,\n * additional elements are added to the previous sections one by one.\n * \n * @param {Array} lst - The array to be divided.\n * @param {number} n - The number of parts to divide the array into.\n * \n * @returns {Array<Array>} - An array containing n subarrays, where each subarray represents a part of the original array.\n */\nfunction divideList(lst, n) {}", "test_code": "describe('TestDivideList', () => {\n    it('should handle even division', () => {\n        const lst = [1, 2, 3, 4, 5, 6];\n        const n = 3;\n        const expected = [[1, 2], [3, 4], [5, 6]];\n        expect(divideList(lst, n)).toEqual(expected);\n    });\n\n    it('should handle uneven division', () => {\n        const lst = [1, 2, 3, 4, 5, 6, 7];\n        const n = 3;\n        const expected = [[1, 2, 3], [4, 5], [6, 7]];\n        expect(divideList(lst, n)).toEqual(expected);\n    });\n\n    it('should handle more parts than items', () => {\n        const lst = [1, 2, 3];\n        const n = 5;\n        const expected = [[1], [2], [3], [], []];\n        expect(divideList(lst, n)).toEqual(expected);\n    });\n\n    it('should handle a single element', () => {\n        const lst = [1];\n        const n = 1;\n        const expected = [[1]];\n        expect(divideList(lst, n)).toEqual(expected);\n    });\n\n    it('should handle an empty list', () => {\n        const lst = [];\n        const n = 3;\n        const expected = [[], [], []];\n        expect(divideList(lst, n)).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Divide an array evenly into n parts and return an array of these parts. If the array length is not divisible by n,\n * additional elements are added to the previous sections one by one.\n * \n * @param {Array} lst - The array to be divided.\n * @param {number} n - The number of parts to divide the array into.\n * \n * @returns {Array<Array>} - An array containing n subarrays, where each subarray represents a part of the original array.\n */\nfunction divideList(lst, n) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Divides a list evenly into n parts and returns a list of these parts.\n * If the list length is not divisible by n, additional elements are added to the previous sections one by one.\n * \n * @param lst - The list to be divided.\n * @param n - The number of parts to divide the list into.\n * @returns A list containing n sublists, where each sublist represents a part of the original list.\n */\nfunction divideList(lst: number[], n: number): number[][] {}", "test_code": "describe('TestDivideList', () => {\n  it('should handle even division', () => {\n    const lst = [1, 2, 3, 4, 5, 6];\n    const n = 3;\n    const expected = [[1, 2], [3, 4], [5, 6]];\n    expect(divideList(lst, n)).toEqual(expected);\n  });\n\n  it('should handle uneven division', () => {\n    const lst = [1, 2, 3, 4, 5, 6, 7];\n    const n = 3;\n    const expected = [[1, 2, 3], [4, 5], [6, 7]];\n    expect(divideList(lst, n)).toEqual(expected);\n  });\n\n  it('should handle more parts than items', () => {\n    const lst = [1, 2, 3];\n    const n = 5;\n    const expected = [[1], [2], [3], [], []];\n    expect(divideList(lst, n)).toEqual(expected);\n  });\n\n  it('should handle a single element', () => {\n    const lst = [1];\n    const n = 1;\n    const expected = [[1]];\n    expect(divideList(lst, n)).toEqual(expected);\n  });\n\n  it('should handle an empty list', () => {\n    const lst: number[] = [];\n    const n = 3;\n    const expected = [[], [], []];\n    expect(divideList(lst, n)).toEqual(expected);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Divides a list evenly into n parts and returns a list of these parts.\n * If the list length is not divisible by n, additional elements are added to the previous sections one by one.\n * \n * @param lst - The list to be divided.\n * @param n - The number of parts to divide the list into.\n * @returns A list containing n sublists, where each sublist represents a part of the original list.\n */\nfunction divideList(lst: number[], n: number): number[][] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Divide a vector evenly into n parts and return a vector of these parts.\n * If the vector length is not divisible by n, additional elements are added to the previous sections one by one.\n *\n * @param lst The vector to be divided.\n * @param n The number of parts to divide the vector into.\n * @return A vector containing n subvectors, where each subvector represents a part of the original vector.\n */\nstd::vector<std::vector<int>> divide_list(const std::vector<int>& lst, int n) {}", "test_code": "TEST_CASE(\"Test divide_list function\", \"[divide_list]\") {\n    SECTION(\"Even division\") {\n        std::vector<int> lst = {1, 2, 3, 4, 5, 6};\n        int n = 3;\n        std::vector<std::vector<int>> expected = {{1, 2}, {3, 4}, {5, 6}};\n        REQUIRE(divide_list(lst, n) == expected);\n    }\n\n    SECTION(\"Uneven division\") {\n        std::vector<int> lst = {1, 2, 3, 4, 5, 6, 7};\n        int n = 3;\n        std::vector<std::vector<int>> expected = {{1, 2, 3}, {4, 5}, {6, 7}};\n        REQUIRE(divide_list(lst, n) == expected);\n    }\n\n    SECTION(\"More parts than items\") {\n        std::vector<int> lst = {1, 2, 3};\n        int n = 5;\n        std::vector<std::vector<int>> expected = {{1}, {2}, {3}, {}, {}};\n        REQUIRE(divide_list(lst, n) == expected);\n    }\n\n    SECTION(\"Single element\") {\n        std::vector<int> lst = {1};\n        int n = 1;\n        std::vector<std::vector<int>> expected = {{1}};\n        REQUIRE(divide_list(lst, n) == expected);\n    }\n\n    SECTION(\"Empty list\") {\n        std::vector<int> lst = {};\n        int n = 3;\n        std::vector<std::vector<int>> expected = {{}, {}, {}};\n        REQUIRE(divide_list(lst, n) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Divide a vector evenly into n parts and return a vector of these parts.\n * If the vector length is not divisible by n, additional elements are added to the previous sections one by one.\n *\n * @param lst The vector to be divided.\n * @param n The number of parts to divide the vector into.\n * @return A vector containing n subvectors, where each subvector represents a part of the original vector.\n */\nstd::vector<std::vector<int>> divide_list(const std::vector<int>& lst, int n) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Divides a list evenly into n parts and returns a list of these parts.\n * If the list length is not divisible by n, additional elements are added to the previous sections one by one.\n *\n * @param lst The list to be divided.\n * @param n The number of parts to divide the list into.\n * @return A list containing n sublists, where each sublist represents a part of the original list.\n */\npublic static List<List<Integer>> divideList(List<Integer> lst, int n) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n\n    @Test\n    public void testEvenDivision() {\n        List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6);\n        int n = 3;\n        List<List<Integer>> expected = Arrays.asList(\n                Arrays.asList(1, 2),\n                Arrays.asList(3, 4),\n                Arrays.asList(5, 6)\n        );\n        assertEquals(expected, divideList(lst, n));\n    }\n\n    @Test\n    public void testUnevenDivision() {\n        List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7);\n        int n = 3;\n        List<List<Integer>> expected = Arrays.asList(\n                Arrays.asList(1, 2, 3),\n                Arrays.asList(4, 5),\n                Arrays.asList(6, 7)\n        );\n        assertEquals(expected, divideList(lst, n));\n    }\n\n    @Test\n    public void testMorePartsThanItems() {\n        List<Integer> lst = Arrays.asList(1, 2, 3);\n        int n = 5;\n        List<List<Integer>> expected = Arrays.asList(\n                Arrays.asList(1),\n                Arrays.asList(2),\n                Arrays.asList(3),\n                Arrays.asList(),\n                Arrays.asList()\n        );\n        assertEquals(expected, divideList(lst, n));\n    }\n\n    @Test\n    public void testSingleElement() {\n        List<Integer> lst = Arrays.asList(1);\n        int n = 1;\n        List<List<Integer>> expected = Arrays.asList(\n                Arrays.asList(1)\n        );\n        assertEquals(expected, divideList(lst, n));\n    }\n\n    @Test\n    public void testEmptyList() {\n        List<Integer> lst = Arrays.asList();\n        int n = 3;\n        List<List<Integer>> expected = Arrays.asList(\n                Arrays.asList(),\n                Arrays.asList(),\n                Arrays.asList()\n        );\n        assertEquals(expected, divideList(lst, n));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Divides a list evenly into n parts and returns a list of these parts.\n * If the list length is not divisible by n, additional elements are added to the previous sections one by one.\n *\n * @param lst The list to be divided.\n * @param n The number of parts to divide the list into.\n * @return A list containing n sublists, where each sublist represents a part of the original list.\n */\npublic static List<List<Integer>> divideList(List<Integer> lst, int n) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 70, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "extracts the contents of the code block from the given Markdown string\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef code_block_remover(markdown_string: str) -> List[str]:\n    \"\"\"\n    extracts the contents of the code block from the given Markdown string.\n\n    Args:\n        markdown_string (str): The input markdown string.\n\n    Returns:\n        list: A list of strings, each representing the content of a code block.\n              Returns an empty list if no code blocks are found.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestCodeBlockRemover(unittest.TestCase):\n\n    def test_single_code_block(self):\n        markdown = \"\"\"\n        This is a markdown with a code block.\n\n        ```python\n        print(\"Hello, World!\")\n        ```\n\n        End of markdown.\n        \"\"\"\n        expected = ['print(\"Hello, World!\")']\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_multiple_code_blocks(self):\n        markdown = \"\"\"\n        First code block:\n\n        ```python\n        print(\"Hello, World!\")\n        ```\n\n        Second code block:\n\n        ```javascript\n        console.log(\"Hello, World!\");\n        ```\n        \"\"\"\n        expected = [\n            'print(\"Hello, World!\")',\n            'console.log(\"Hello, World!\");'\n        ]\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_no_code_block(self):\n        markdown = \"\"\"\n        This markdown has no code blocks.\n\n        Just some plain text.\n        \"\"\"\n        expected = []\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_empty_code_block(self):\n        markdown = \"\"\"\n        Here is an empty code block:\n\n        ```python\n        ```\n\n        End of markdown.\n        \"\"\"\n        expected = ['']\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_malformed_code_block(self):\n        markdown = \"\"\"\n        This code block is missing ending:\n\n        ```python\n        print(\"Hello, World!\")\n\n        And some more text.\n        \"\"\"\n        expected = []\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef code_block_remover(markdown_string: str) -> List[str]:\n    \"\"\"\n    extracts the contents of the code block from the given Markdown string.\n\n    Args:\n        markdown_string (str): The input markdown string.\n\n    Returns:\n        list: A list of strings, each representing the content of a code block.\n              Returns an empty list if no code blocks are found.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extracts the contents of the code block from the given Markdown string.\n *\n * @param {string} markdownString - The input markdown string.\n * @returns {Array<string>} An array of strings, each representing the content of a code block.\n *                           Returns an empty array if no code blocks are found.\n */\nfunction codeBlockRemover(markdownString) {}", "test_code": "describe('TestCodeBlockRemover', () => {\n  it('should handle a single code block', () => {\n      const markdown = `\n      This is a markdown with a code block.\n\n      \\`\\`\\`python\n      print(\"Hello, World!\")\n      \\`\\`\\`\n\n      End of markdown.\n      `;\n      const expected = ['print(\"Hello, World!\")'];\n      const result = codeBlockRemover(markdown);\n      expect(result).toEqual(expected);\n  });\n\n  it('should handle multiple code blocks', () => {\n      const markdown = `\n      First code block:\n\n      \\`\\`\\`python\n      print(\"Hello, World!\")\n      \\`\\`\\`\n\n      Second code block:\n\n      \\`\\`\\`javascript\n      console.log(\"Hello, World!\");\n      \\`\\`\\`\n      `;\n      const expected = [\n          'print(\"Hello, World!\")',\n          'console.log(\"Hello, World!\");'\n      ];\n      const result = codeBlockRemover(markdown);\n      expect(result).toEqual(expected);\n  });\n\n  it('should handle no code blocks', () => {\n      const markdown = `\n      This markdown has no code blocks.\n\n      Just some plain text.\n      `;\n      const expected = [];\n      const result = codeBlockRemover(markdown);\n      expect(result).toEqual(expected);\n  });\n\n  it('should handle an empty code block', () => {\n      const markdown = `\n      Here is an empty code block:\n\n      \\`\\`\\`python\n      \\`\\`\\`\n\n      End of markdown.\n      `;\n      const expected = [''];\n      const result = codeBlockRemover(markdown);\n      expect(result).toEqual(expected);\n  });\n\n  it('should handle a malformed code block', () => {\n      const markdown = `\n      This code block is missing ending:\n\n      \\`\\`\\`python\n      print(\"Hello, World!\")\n\n      And some more text.\n      `;\n      const expected = [];\n      const result = codeBlockRemover(markdown);\n      expect(result).toEqual(expected);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Extracts the contents of the code block from the given Markdown string.\n *\n * @param {string} markdownString - The input markdown string.\n * @returns {Array<string>} An array of strings, each representing the content of a code block.\n *                           Returns an empty array if no code blocks are found.\n */\nfunction codeBlockRemover(markdownString) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Extracts the contents of the code block from the given Markdown string.\n *\n * @param markdownString - The input Markdown string.\n * @returns An array of strings, each representing the content of a code block.\n *          Returns an empty array if no code blocks are found.\n */\nfunction codeBlockRemover(markdownString: string): string[] {}", "test_code": "describe('TestCodeBlockRemover', () => {\n    it('should handle a single code block correctly', () => {\n      const markdown = `\n        This is a markdown with a code block.\n  \n        \\`\\`\\`python\n        print(\"Hello, World!\")\n        \\`\\`\\`\n  \n        End of markdown.\n      `;\n      const expected = ['print(\"Hello, World!\")'];\n      const result = codeBlockRemover(markdown);\n      expect(result).toEqual(expected);\n    });\n  \n    it('should handle multiple code blocks correctly', () => {\n      const markdown = `\n        First code block:\n  \n        \\`\\`\\`python\n        print(\"Hello, World!\")\n        \\`\\`\\`\n  \n        Second code block:\n  \n        \\`\\`\\`javascript\n        console.log(\"Hello, World!\");\n        \\`\\`\\`\n      `;\n      const expected = [\n        'print(\"Hello, World!\")',\n        'console.log(\"Hello, World!\");'\n      ];\n      const result = codeBlockRemover(markdown);\n      expect(result).toEqual(expected);\n    });\n  \n    it('should return an empty array when there are no code blocks', () => {\n      const markdown = `\n        This markdown has no code blocks.\n  \n        Just some plain text.\n      `;\n      const expected = [];\n      const result = codeBlockRemover(markdown);\n      expect(result).toEqual(expected);\n    });\n  \n    it('should handle an empty code block correctly', () => {\n      const markdown = `\n        Here is an empty code block:\n  \n        \\`\\`\\`python\n        \\`\\`\\`\n  \n        End of markdown.\n      `;\n      const expected = [''];\n      const result = codeBlockRemover(markdown);\n      expect(result).toEqual(expected);\n    });\n  \n    it('should not extract malformed code blocks', () => {\n      const markdown = `\n        This code block is missing ending:\n  \n        \\`\\`\\`python\n        print(\"Hello, World!\")\n  \n        And some more text.\n      `;\n      const expected = [];\n      const result = codeBlockRemover(markdown);\n      expect(result).toEqual(expected);\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Extracts the contents of the code block from the given Markdown string.\n *\n * @param markdownString - The input Markdown string.\n * @returns An array of strings, each representing the content of a code block.\n *          Returns an empty array if no code blocks are found.\n */\nfunction codeBlockRemover(markdownString: string): string[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extracts the contents of the code block from the given Markdown string.\n *\n * @param markdown_string The input markdown string.\n *\n * @return A vector of strings, each representing the content of a code block.\n *         Returns an empty vector if no code blocks are found.\n */\nstd::vector<std::string> code_block_remover(const std::string& markdown_string) {}", "test_code": "TEST_CASE(\"Test code_block_remover\", \"[code_block_remover]\") {\n    SECTION(\"Single code block\") {\n        std::string markdown = R\"(\n        This is a markdown with a code block.\n\n        ```python\n        print(\"Hello, World!\")\n        ```\n\n        End of markdown.\n        )\";\n        std::vector<std::string> expected = {\"print(\\\"Hello, World!\\\")\"};\n        std::vector<std::string> result = code_block_remover(markdown);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Multiple code blocks\") {\n        std::string markdown = R\"(\n        First code block:\n\n        ```python\n        print(\"Hello, World!\")\n        ```\n\n        Second code block:\n\n        ```javascript\n        console.log(\"Hello, World!\");\n        )\";\n        std::vector<std::string> expected = {\n            \"print(\\\"Hello, World!\\\")\",\n            \"console.log(\\\"Hello, World!\\\");\"\n        };\n        std::vector<std::string> result = code_block_remover(markdown);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"No code block\") {\n        std::string markdown = R\"(\n        This markdown has no code blocks.\n\n        Just some plain text.\n        )\";\n        std::vector<std::string> expected = {};\n        std::vector<std::string> result = code_block_remover(markdown);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Empty code block\") {\n        std::string markdown = R\"(\n        Here is an empty code block:\n\n        ```python\n        ```\n\n        End of markdown.\n        )\";\n        std::vector<std::string> expected = {\"\"};\n        std::vector<std::string> result = code_block_remover(markdown);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Malformed code block\") {\n        std::string markdown = R\"(\n        This code block is missing ending:\n\n        ```python\n        print(\"Hello, World!\")\n\n        And some more text.\n        )\";\n        std::vector<std::string> expected = {};\n        std::vector<std::string> result = code_block_remover(markdown);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts the contents of the code block from the given Markdown string.\n *\n * @param markdown_string The input markdown string.\n *\n * @return A vector of strings, each representing the content of a code block.\n *         Returns an empty vector if no code blocks are found.\n */\nstd::vector<std::string> code_block_remover(const std::string& markdown_string) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Extracts the contents of the code block from the given Markdown string.\n *\n * @param markdownString The input Markdown string.\n * @return A list of strings, each representing the content of a code block.\n *         Returns an empty list if no code blocks are found.\n */\npublic static List<String> codeBlockRemover(String markdownString) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testSingleCodeBlock() {\n        String markdown = \"This is a markdown with a code block.\\n\\n```python\\nprint(\\\"Hello, World!\\\")\\n```\\n\\nEnd of markdown.\";\n        List<String> expected = Arrays.asList(\"print(\\\"Hello, World!\\\")\");\n        List<String> result = codeBlockRemover(markdown);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testMultipleCodeBlocks() {\n        String markdown = \"First code block:\\n\\n```python\\nprint(\\\"Hello, World!\\\")\\n```\\n\\nSecond code block:\\n\\n```javascript\\nconsole.log(\\\"Hello, World!\\\");\\n```\\n\";\n        List<String> expected = Arrays.asList(\n            \"print(\\\"Hello, World!\\\")\",\n            \"console.log(\\\"Hello, World!\\\");\"\n        );\n        List<String> result = codeBlockRemover(markdown);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testNoCodeBlock() {\n        String markdown = \"This markdown has no code blocks.\\n\\nJust some plain text.\";\n        List<String> expected = Arrays.asList();\n        List<String> result = codeBlockRemover(markdown);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testEmptyCodeBlock() {\n        String markdown = \"Here is an empty code block:\\n\\n```python\\n```\\n\\nEnd of markdown.\";\n        List<String> expected = Arrays.asList(\"\");\n        List<String> result = codeBlockRemover(markdown);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testMalformedCodeBlock() {\n        String markdown = \"This code block is missing ending:\\n\\n```python\\nprint(\\\"Hello, World!\\\")\\n\\nAnd some more text.\";\n        List<String> expected = Arrays.asList();\n        List<String> result = codeBlockRemover(markdown);\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts the contents of the code block from the given Markdown string.\n *\n * @param markdownString The input Markdown string.\n * @return A list of strings, each representing the content of a code block.\n *         Returns an empty list if no code blocks are found.\n */\npublic static List<String> codeBlockRemover(String markdownString) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 71, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Reads numerical columns from a file starting from the line after the last line containing '/'.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef read_numerical_columns_from_file(file_name: str) -> np.array:\n    \"\"\"\n    Reads numerical columns from a file starting from the line after the last line containing '/'.\n\n    Args:\n        file_name (str): The name of the file to read.\n\n    Returns:\n        numpy.ndarray: A 2D numpy array containing the numerical question.\n\n    Raises:\n        ValueError: If the file does not contain any '/' character.\n    \"\"\"\n", "test_code": "import os\nimport unittest\nimport numpy as np\n\nclass TestReadColumns(unittest.TestCase):\n\n    def setUp(self):\n        # Setup a temporary directory to use for each test\n        self.test_file = 'test_file.txt'\n\n    def tearDown(self):\n        # Clean up the temporary file after each test\n        if os.path.exists(self.test_file):\n            os.remove(self.test_file)\n\n    def test_basic_functionality(self):\n        # Test reading a file with a valid structure and numerical question\n        content = \"\"\"Line 1\nLine 2\n/\n1.0 2.0 3.0\n4.0 5.0 6.0\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        result = read_numerical_columns_from_file(self.test_file)\n        expected_result = np.array([[1.0, 2.0, 3.0],\n                                    [4.0, 5.0, 6.0]])\n        np.testing.assert_array_equal(result, expected_result)\n\n    def test_no_slash_character(self):\n        # Test that a ValueError is raised if no '/' character is found\n        content = \"\"\"Line 1\nLine 2\nLine 3\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        with self.assertRaises(ValueError):\n            read_numerical_columns_from_file(self.test_file)\n\n    def test_file_with_comments_and_empty_lines(self):\n        # Test handling of comments and empty lines\n        content = \"\"\"Line 1\n/\n! This is a comment\n1.0 2.0 3.0\n\n4.0 5.0 6.0\n! Another comment\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        result = read_numerical_columns_from_file(self.test_file)\n        expected_result = np.array([[1.0, 2.0, 3.0],\n                                    [4.0, 5.0, 6.0]])\n        np.testing.assert_array_equal(result, expected_result)\n\n    def test_different_number_of_columns(self):\n        # Test that the function handles different number of columns correctly\n        content = \"\"\"Line 1\n/\n1.0 2.0\n3.0 4.0\n5.0 6.0 7.0\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        with self.assertRaises(ValueError):\n            read_numerical_columns_from_file(self.test_file)\n\n    def test_empty_file(self):\n        # Test handling of an empty file\n        content = \"\"\"\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        with self.assertRaises(ValueError):\n            read_numerical_columns_from_file(self.test_file)\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef read_numerical_columns_from_file(file_name: str) -> np.array:\n    \"\"\"\n    Reads numerical columns from a file starting from the line after the last line containing '/'.\n\n    Args:\n        file_name (str): The name of the file to read.\n\n    Returns:\n        numpy.ndarray: A 2D numpy array containing the numerical question.\n\n    Raises:\n        ValueError: If the file does not contain any '/' character.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Reads numerical columns from a file starting from the line after the last line containing '/'.\n *\n * @param {string} fileName - The name of the file to read.\n * @returns {Array<Array<number>>} - A 2D array containing the numerical data.\n * @throws {Error} - If the file does not contain any '/' character.\n */\nfunction readColumns(fileName) {}", "test_code": "describe('TestReadColumns', () => {\n    const testFile = 'test_file.txt';\n\n    beforeEach(() => {\n        // Setup a temporary directory to use for each test\n    });\n\n    afterEach(() => {\n        // Clean up the temporary file after each test\n        if (fs.existsSync(testFile)) {\n            fs.unlinkSync(testFile);\n        }\n    });\n\n    it('should handle basic functionality', () => {\n        const content = `Line 1\nLine 2\n/\n1.0 2.0 3.0\n4.0 5.0 6.0`;\n\n        fs.writeFileSync(testFile, content);\n\n        const result = readColumns(testFile);\n        const expectedResult = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];\n        expect(result).toEqual(expectedResult);\n    });\n\n    it('should throw an error if no \"/\" character is found', () => {\n        const content = `Line 1\nLine 2\nLine 3`;\n\n        fs.writeFileSync(testFile, content);\n\n        expect(() => readColumns(testFile)).toThrow('File does not contain \\'/\\' character');\n    });\n\n    it('should handle comments and empty lines', () => {\n        const content = `Line 1\n/\n! This is a comment\n1.0 2.0 3.0\n\n4.0 5.0 6.0\n! Another comment`;\n\n        fs.writeFileSync(testFile, content);\n\n        const result = readColumns(testFile);\n        const expectedResult = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];\n        expect(result).toEqual(expectedResult);\n    });\n\n    it('should throw an error if the number of columns is inconsistent', () => {\n        const content = `Line 1\n/\n1.0 2.0\n3.0 4.0\n5.0 6.0 7.0`;\n\n        fs.writeFileSync(testFile, content);\n\n        expect(() => readColumns(testFile)).toThrow('File does not contain \\'/\\' character');\n    });\n\n    it('should throw an error if the file is empty', () => {\n        const content = ``;\n\n        fs.writeFileSync(testFile, content);\n\n        expect(() => readColumns(testFile)).toThrow('File does not contain \\'/\\' character');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Reads numerical columns from a file starting from the line after the last line containing '/'.\n *\n * @param {string} fileName - The name of the file to read.\n * @returns {Array<Array<number>>} - A 2D array containing the numerical data.\n * @throws {Error} - If the file does not contain any '/' character.\n */\nfunction readColumns(fileName) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Reads numerical columns from a file starting from the line after the last line containing '/'.\n *\n * @param {string} fileName - The name of the file to read.\n * @returns {number[][]} - A 2D array containing the numerical data.\n * @throws {Error} - If the file does not contain any '/' character.\n */\nfunction readColumns(fileName: string): number[][] {}", "test_code": "import { writeFileSync, existsSync, unlinkSync } from 'fs';\n\ndescribe('readColumns', () => {\n    const testFile = 'test_file.txt';\n\n    beforeEach(() => {\n        // Setup a temporary directory to use for each test\n    });\n\n    afterEach(() => {\n        // Clean up the temporary file after each test\n        if (existsSync(testFile)) {\n            unlinkSync(testFile);\n        }\n    });\n\n    it('should read a file with a valid structure and numerical data', () => {\n        const content = `Line 1\nLine 2\n/\n1.0 2.0 3.0\n4.0 5.0 6.0`;\n\n        writeFileSync(testFile, content);\n\n        const result = readColumns(testFile);\n        const expectedResult = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];\n        expect(result).toEqual(expectedResult);\n    });\n\n    it('should throw an error if no \\'/\\' character is found', () => {\n        const content = `Line 1\nLine 2\nLine 3`;\n\n        writeFileSync(testFile, content);\n\n        expect(() => readColumns(testFile)).toThrow('File does not contain \\'/\\' character');\n    });\n\n    it('should handle comments and empty lines correctly', () => {\n        const content = `Line 1\n/\n! This is a comment\n1.0 2.0 3.0\n\n4.0 5.0 6.0\n! Another comment`;\n\n        writeFileSync(testFile, content);\n\n        const result = readColumns(testFile);\n        const expectedResult = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];\n        expect(result).toEqual(expectedResult);\n    });\n\n    it('should throw an error if the number of columns is inconsistent', () => {\n        const content = `Line 1\n/\n1.0 2.0\n3.0 4.0\n5.0 6.0 7.0`;\n\n        writeFileSync(testFile, content);\n\n        expect(() => readColumns(testFile)).toThrow();\n    });\n\n    it('should throw an error if the file is empty', () => {\n        const content = ``;\n\n        writeFileSync(testFile, content);\n\n        expect(() => readColumns(testFile)).toThrow('File does not contain \\'/\\' character');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Reads numerical columns from a file starting from the line after the last line containing '/'.\n *\n * @param {string} fileName - The name of the file to read.\n * @returns {number[][]} - A 2D array containing the numerical data.\n * @throws {Error} - If the file does not contain any '/' character.\n */\nfunction readColumns(fileName: string): number[][] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads numerical columns from a file starting from the line after the last line containing '/'.\n *\n * @param file_name The name of the file to read.\n * @return A 2D vector containing the numerical data.\n * @throws std::runtime_error If the file does not contain any '/' character.\n */\nstd::vector<std::vector<double>> read_columns(const std::string& file_name) {}", "test_code": "TEST_CASE(\"Test read_columns function\", \"[read_columns]\") {\n    const std::string test_file = \"test_file.txt\";\n\n    SECTION(\"Basic functionality\") {\n        // Test reading a file with a valid structure and numerical question\n        std::string content = R\"(\nLine 1\nLine 2\n/\n1.0 2.0 3.0\n4.0 5.0 6.0\n)\";\n        std::ofstream file(test_file);\n        file << content;\n        file.close();\n\n        std::vector<std::vector<double>> result = read_columns(test_file);\n        std::vector<std::vector<double>> expected_result = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}};\n        REQUIRE(result == expected_result);\n\n        if (std::remove(test_file.c_str()) != 0) {\n            std::cerr << \"Failed to remove test file.\" << std::endl;\n        }\n    }\n\n    SECTION(\"No slash character\") {\n        // Test that a runtime_error is raised if no '/' character is found\n        std::string content = R\"(\nLine 1\nLine 2\nLine 3\n)\";\n        std::ofstream file(test_file);\n        file << content;\n        file.close();\n\n        REQUIRE_THROWS_AS(read_columns(test_file), std::runtime_error);\n\n        if (std::remove(test_file.c_str()) != 0) {\n            std::cerr << \"Failed to remove test file.\" << std::endl;\n        }\n    }\n\n    SECTION(\"File with comments and empty lines\") {\n        // Test handling of comments and empty lines\n        std::string content = R\"(\nLine 1\n/\n! This is a comment\n1.0 2.0 3.0\n\n4.0 5.0 6.0\n! Another comment\n)\";\n        std::ofstream file(test_file);\n        file << content;\n        file.close();\n\n        std::vector<std::vector<double>> result = read_columns(test_file);\n        std::vector<std::vector<double>> expected_result = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}};\n        REQUIRE(result == expected_result);\n\n        if (std::remove(test_file.c_str()) != 0) {\n            std::cerr << \"Failed to remove test file.\" << std::endl;\n        }\n    }\n\n    SECTION(\"Different number of columns\") {\n        // Test that the function handles different number of columns correctly\n        std::string content = R\"(\nLine 1\n/\n1.0 2.0\n3.0 4.0\n5.0 6.0 7.0\n)\";\n        std::ofstream file(test_file);\n        file << content;\n        file.close();\n\n        REQUIRE_THROWS_AS(read_columns(test_file), std::runtime_error);\n\n        if (std::remove(test_file.c_str()) != 0) {\n            std::cerr << \"Failed to remove test file.\" << std::endl;\n        }\n    }\n\n    SECTION(\"Empty file\") {\n        // Test handling of an empty file\n        std::string content = \"\";\n        std::ofstream file(test_file);\n        file << content;\n        file.close();\n\n        REQUIRE_THROWS_AS(read_columns(test_file), std::runtime_error);\n\n        if (std::remove(test_file.c_str()) != 0) {\n            std::cerr << \"Failed to remove test file.\" << std::endl;\n        }\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads numerical columns from a file starting from the line after the last line containing '/'.\n *\n * @param file_name The name of the file to read.\n * @return A 2D vector containing the numerical data.\n * @throws std::runtime_error If the file does not contain any '/' character.\n */\nstd::vector<std::vector<double>> read_columns(const std::string& file_name) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads numerical columns from a file starting from the line after the last line containing '/'.\n *\n * @param fileName The name of the file to read.\n * @return A 2D array containing the numerical data.\n * @throws IllegalArgumentException If the file does not contain any '/' character.\n * @throws IOException If an I/O error occurs.\n */\npublic static double[][] readColumns(String fileName) throws IOException {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\nimport static org.junit.Assert.assertArrayEquals;\n\npublic class Tester {\n\n    private static final String TEST_FILE = \"test_file.txt\";\n\n    @Before\n    public void setUp() throws IOException {\n        // Setup a temporary directory to use for each test\n        File testFile = new File(TEST_FILE);\n        if (!testFile.exists()) {\n            testFile.createNewFile();\n        }\n    }\n\n    @After\n    public void tearDown() {\n        // Clean up the temporary file after each test\n        File testFile = new File(TEST_FILE);\n        if (testFile.exists()) {\n            testFile.delete();\n        }\n    }\n\n    @Test\n    public void testBasicFunctionality() throws IOException {\n        // Test reading a file with a valid structure and numerical question\n        String content = \"Line 1\\n\" +\n                \"Line 2\\n\" +\n                \"/\\n\" +\n                \"1.0 2.0 3.0\\n\" +\n                \"4.0 5.0 6.0\\n\";\n\n        try (FileWriter writer = new FileWriter(TEST_FILE)) {\n            writer.write(content);\n        }\n\n        double[][] result = Answer.readColumns(TEST_FILE);\n        double[][] expectedResult = {\n                {1.0, 2.0, 3.0},\n                {4.0, 5.0, 6.0}\n        };\n\n        assertArrayEquals(expectedResult, result);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testNoSlashCharacter() throws IOException {\n        // Test that an IllegalArgumentException is raised if no '/' character is found\n        String content = \"Line 1\\n\" +\n                \"Line 2\\n\" +\n                \"Line 3\\n\";\n\n        try (FileWriter writer = new FileWriter(TEST_FILE)) {\n            writer.write(content);\n        }\n\n        Answer.readColumns(TEST_FILE);\n    }\n\n    @Test\n    public void testFileWithCommentsAndEmptyLines() throws IOException {\n        // Test handling of comments and empty lines\n        String content = \"Line 1\\n\" +\n                \"/\\n\" +\n                \"! This is a comment\\n\" +\n                \"1.0 2.0 3.0\\n\" +\n                \"\\n\" +\n                \"4.0 5.0 6.0\\n\" +\n                \"! Another comment\\n\";\n\n        try (FileWriter writer = new FileWriter(TEST_FILE)) {\n            writer.write(content);\n        }\n\n        double[][] result = Answer.readColumns(TEST_FILE);\n        double[][] expectedResult = {\n                {1.0, 2.0, 3.0},\n                {4.0, 5.0, 6.0}\n        };\n\n        assertArrayEquals(expectedResult, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Reads numerical columns from a file starting from the line after the last line containing '/'.\n *\n * @param fileName The name of the file to read.\n * @return A 2D array containing the numerical data.\n * @throws IllegalArgumentException If the file does not contain any '/' character.\n * @throws IOException If an I/O error occurs.\n */\npublic static double[][] readColumns(String fileName) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 72, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "    converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef convert_pixel_to_3d_coordinates(K: np.array, d: float, x: float, y: float) -> np.array:\n    \"\"\"\n    Convert 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n\n    Args:\n        K (np.array): A (3, 3) camera intrinsic matrix, which includes focal lengths and optical center.\n        d (float): Depth (distance along the z-axis) from the camera to the point in 3D space.\n        x (float): The x coordinate of the pixel in 2D image space.\n        y (float): The y coordinate of the pixel in 2D image space.\n\n    Returns:\n        np.array: A numpy array containing the 3D coordinates (x, y, z) in the camera's right-handed coordinate frame.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestGet3DCoordinates(unittest.TestCase):\n    def setUp(self):\n        # Define a common intrinsic matrix for testing\n        self.K = np.array([[1000, 0, 320],\n                           [0, 1000, 240],\n                           [0, 0, 1]])\n\n    def test_center_coordinates(self):\n        \"\"\" Test with center pixel coordinates where x and y should map to zero in NDC. \"\"\"\n        result = convert_pixel_to_3d_coordinates(self.K, 100, 320, 240)\n        np.testing.assert_array_almost_equal(result, np.array([0.0, 0.0, 100]))\n\n    def test_boundary_coordinates(self):\n        \"\"\" Test with boundary values in the image frame. \"\"\"\n        result = convert_pixel_to_3d_coordinates(self.K, 50, 640, 480)\n        expected_x = (640 - 320) / 1000 * 50\n        expected_y = (480 - 240) / 1000 * 50\n        np.testing.assert_array_almost_equal(result, np.array([expected_x, expected_y, 50]))\n\n    def test_negative_depth(self):\n        \"\"\" Test with a negative depth to see if it handles incorrect input properly. \"\"\"\n        result = convert_pixel_to_3d_coordinates(self.K, -100, 320, 240)\n        np.testing.assert_array_almost_equal(result, np.array([0.0, 0.0, -100]))\n\n    def test_zero_depth(self):\n        \"\"\" Test with zero depth which should lead to a zero-length vector. \"\"\"\n        result = convert_pixel_to_3d_coordinates(self.K, 0, 320, 240)\n        np.testing.assert_array_almost_equal(result, np.array([0.0, 0.0, 0.0]))\n\n    def test_non_integer_values(self):\n        \"\"\" Test with non-integer pixel coordinates. \"\"\"\n        result = convert_pixel_to_3d_coordinates(self.K, 100, 320.5, 240.5)\n        expected_x = (320.5 - 320) / 1000 * 100\n        expected_y = (240.5 - 240) / 1000 * 100\n        np.testing.assert_array_almost_equal(result, np.array([expected_x, expected_y, 100]))\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef convert_pixel_to_3d_coordinates(K: np.array, d: float, x: float, y: float) -> np.array:\n    \"\"\"\n    Convert 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n\n    Args:\n        K (np.array): A (3, 3) camera intrinsic matrix, which includes focal lengths and optical center.\n        d (float): Depth (distance along the z-axis) from the camera to the point in 3D space.\n        x (float): The x coordinate of the pixel in 2D image space.\n        y (float): The y coordinate of the pixel in 2D image space.\n\n    Returns:\n        np.array: A numpy array containing the 3D coordinates (x, y, z) in the camera's right-handed coordinate frame.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n * \n * @param {Array} K - Camera intrinsic matrix (3x3 array)\n * @param {number} d - Depth (distance along z-axis)\n * @param {number} x - Pixel x coordinate\n * @param {number} y - Pixel y coordinate\n * @returns {Array} - x, y, z 3D point coordinates in camera RDF coordinates\n */\nfunction get3DCoordinates(K, d, x, y) {}", "test_code": "describe('TestGet3DCoordinates', () => {\n    let K;\n\n    beforeEach(() => {\n        // Define a common intrinsic matrix for testing\n        K = [\n            [1000, 0, 320],\n            [0, 1000, 240],\n            [0, 0, 1]\n        ];\n    });\n\n    it('test center coordinates', () => {\n        // Test with center pixel coordinates where x and y should map to zero in NDC.\n        const result = get3DCoordinates(K, 100, 320, 240);\n        assert.deepStrictEqual(result, [0.0, 0.0, 100]);\n    });\n\n    it('test boundary coordinates', () => {\n        // Test with boundary values in the image frame.\n        const result = get3DCoordinates(K, 50, 640, 480);\n        const expected_x = (640 - 320) / 1000 * 50;\n        const expected_y = (480 - 240) / 1000 * 50;\n        assert.deepStrictEqual(result, [expected_x, expected_y, 50]);\n    });\n\n    it('test negative depth', () => {\n        // Test with a negative depth to see if it handles incorrect input properly.\n        const result = get3DCoordinates(K, -100, 320, 240);\n        assert.deepStrictEqual(result, [0.0, 0.0, -100]);\n    });\n\n    it('test zero depth', () => {\n        // Test with zero depth which should lead to a zero-length vector.\n        const result = get3DCoordinates(K, 0, 320, 240);\n        assert.deepStrictEqual(result, [0.0, 0.0, 0.0]);\n    });\n\n    it('test non-integer values', () => {\n        // Test with non-integer pixel coordinates.\n        const result = get3DCoordinates(K, 100, 320.5, 240.5);\n        const expected_x = (320.5 - 320) / 1000 * 100;\n        const expected_y = (240.5 - 240) / 1000 * 100;\n        assert.deepStrictEqual(result, [expected_x, expected_y, 100]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n * \n * @param {Array} K - Camera intrinsic matrix (3x3 array)\n * @param {number} d - Depth (distance along z-axis)\n * @param {number} x - Pixel x coordinate\n * @param {number} y - Pixel y coordinate\n * @returns {Array} - x, y, z 3D point coordinates in camera RDF coordinates\n */\nfunction get3DCoordinates(K, d, x, y) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n * \n * @param K - A 3x3 camera intrinsic matrix.\n * @param d - Depth (distance along the z-axis).\n * @param x - Pixel x coordinate.\n * @param y - Pixel y coordinate.\n * @returns A tuple representing the x, y, z 3D point coordinates in camera RDF coordinates.\n */\nfunction get3DCoordinates(K: number[][], d: number, x: number, y: number): [number, number, number] {}", "test_code": "describe('TestGet3DCoordinates', () => {\n    let K: number[][];\n\n    beforeEach(() => {\n        // Define a common intrinsic matrix for testing\n        K = [\n            [1000, 0, 320],\n            [0, 1000, 240],\n            [0, 0, 1]\n        ];\n    });\n\n    it('test_center_coordinates', () => {\n        // Test with center pixel coordinates where x and y should map to zero in NDC.\n        const result = get3DCoordinates(K, 100, 320, 240);\n        expect(result).toEqual([0.0, 0.0, 100]);\n    });\n\n    it('test_boundary_coordinates', () => {\n        // Test with boundary values in the image frame.\n        const result = get3DCoordinates(K, 50, 640, 480);\n        const expected_x = (640 - 320) / 1000 * 50;\n        const expected_y = (480 - 240) / 1000 * 50;\n        expect(result).toEqual([expected_x, expected_y, 50]);\n    });\n\n    it('test_negative_depth', () => {\n        // Test with a negative depth to see if it handles incorrect input properly.\n        const result = get3DCoordinates(K, -100, 320, 240);\n        expect(result).toEqual([0.0, 0.0, -100]);\n    });\n\n    it('test_zero_depth', () => {\n        // Test with zero depth which should lead to a zero-length vector.\n        const result = get3DCoordinates(K, 0, 320, 240);\n        expect(result).toEqual([0.0, 0.0, 0.0]);\n    });\n\n    it('test_non_integer_values', () => {\n        // Test with non-integer pixel coordinates.\n        const result = get3DCoordinates(K, 100, 320.5, 240.5);\n        const expected_x = (320.5 - 320) / 1000 * 100;\n        const expected_y = (240.5 - 240) / 1000 * 100;\n        expect(result).toEqual([expected_x, expected_y, 100]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n * \n * @param K - A 3x3 camera intrinsic matrix.\n * @param d - Depth (distance along the z-axis).\n * @param x - Pixel x coordinate.\n * @param y - Pixel y coordinate.\n * @returns A tuple representing the x, y, z 3D point coordinates in camera RDF coordinates.\n */\nfunction get3DCoordinates(K: number[][], d: number, x: number, y: number): [number, number, number] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n *\n * @param K A 3x3 matrix representing the camera intrinsic matrix.\n * @param d Depth (distance along the z-axis).\n * @param x Pixel x coordinate.\n * @param y Pixel y coordinate.\n *\n * @return A 3D vector containing the x, y, z coordinates in camera RDF coordinates.\n */\nVectorXd get_3d_coordinates(const MatrixXd& K, double d, double x, double y) {}", "test_code": "TEST_CASE(\"TestGet3DCoordinates\", \"[get_3d_coordinates]\") {\n    // Define a common intrinsic matrix for testing\n    MatrixXd K(3, 3);\n    K << 1000, 0, 320,\n         0, 1000, 240,\n         0, 0, 1;\n\n    SECTION(\"test_center_coordinates\") {\n        // Test with center pixel coordinates where x and y should map to zero in NDC.\n        VectorXd result = get_3d_coordinates(K, 100, 320, 240);\n        REQUIRE_THAT(result, Catch::Approx(VectorXd::Zero(3)).epsilon(1e-6));\n    }\n\n    SECTION(\"test_boundary_coordinates\") {\n        // Test with boundary values in the image frame.\n        VectorXd result = get_3d_coordinates(K, 50, 640, 480);\n        double expected_x = (640 - 320) / 1000 * 50;\n        double expected_y = (480 - 240) / 1000 * 50;\n        REQUIRE_THAT(result, Catch::Approx(VectorXd::Zero(3) + VectorXd({expected_x, expected_y, 50})).epsilon(1e-6));\n    }\n\n    SECTION(\"test_negative_depth\") {\n        // Test with a negative depth to see if it handles incorrect input properly.\n        VectorXd result = get_3d_coordinates(K, -100, 320, 240);\n        REQUIRE_THAT(result, Catch::Approx(VectorXd::Zero(3) + VectorXd({0.0, 0.0, -100})).epsilon(1e-6));\n    }\n\n    SECTION(\"test_zero_depth\") {\n        // Test with zero depth which should lead to a zero-length vector.\n        VectorXd result = get_3d_coordinates(K, 0, 320, 240);\n        REQUIRE_THAT(result, Catch::Approx(VectorXd::Zero(3)).epsilon(1e-6));\n    }\n\n    SECTION(\"test_non_integer_values\") {\n        // Test with non-integer pixel coordinates.\n        VectorXd result = get_3d_coordinates(K, 100, 320.5, 240.5);\n        double expected_x = (320.5 - 320) / 1000 * 100;\n        double expected_y = (240.5 - 240) / 1000 * 100;\n        REQUIRE_THAT(result, Catch::Approx(VectorXd::Zero(3) + VectorXd({expected_x, expected_y, 100})).epsilon(1e-6));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n *\n * @param K A 3x3 matrix representing the camera intrinsic matrix.\n * @param d Depth (distance along the z-axis).\n * @param x Pixel x coordinate.\n * @param y Pixel y coordinate.\n *\n * @return A 3D vector containing the x, y, z coordinates in camera RDF coordinates.\n */\nVectorXd get_3d_coordinates(const MatrixXd& K, double d, double x, double y) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n *\n * @param K A 3x3 matrix representing the camera intrinsic parameters.\n * @param d Depth (distance along the z-axis).\n * @param x Pixel x coordinate.\n * @param y Pixel y coordinate.\n * @return An array containing the 3D coordinates [x, y, z] in camera RDF coordinates.\n */\npublic static double[] get3DCoordinates(INDArray K, double d, double x, double y) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertArrayEquals;\n\nimport org.nd4j.linalg.api.ndarray.INDArray;\nimport org.nd4j.linalg.factory.Nd4j;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    private INDArray K;\n\n    @Before\n    public void setUp() {\n        // Define a common intrinsic matrix for testing\n        K = Nd4j.create(new double[][]{\n                {1000, 0, 320},\n                {0, 1000, 240},\n                {0, 0, 1}\n        });\n    }\n\n    @Test\n    public void testCenterCoordinates() {\n        // Test with center pixel coordinates where x and y should map to zero in NDC.\n        double[] result = get3DCoordinates(K, 100, 320, 240);\n        assertArrayEquals(new double[]{0.0, 0.0, 100}, result, 1e-6);\n    }\n\n    @Test\n    public void testBoundaryCoordinates() {\n        // Test with boundary values in the image frame.\n        double[] result = get3DCoordinates(K, 50, 640, 480);\n        double expectedX = (640 - 320) / 1000 * 50;\n        double expectedY = (480 - 240) / 1000 * 50;\n        assertArrayEquals(new double[]{expectedX, expectedY, 50}, result, 1e-6);\n    }\n\n    @Test\n    public void testNegativeDepth() {\n        // Test with a negative depth to see if it handles incorrect input properly.\n        double[] result = get3DCoordinates(K, -100, 320, 240);\n        assertArrayEquals(new double[]{0.0, 0.0, -100}, result, 1e-6);\n    }\n\n    @Test\n    public void testZeroDepth() {\n        // Test with zero depth which should lead to a zero-length vector.\n        double[] result = get3DCoordinates(K, 0, 320, 240);\n        assertArrayEquals(new double[]{0.0, 0.0, 0.0}, result, 1e-6);\n    }\n\n    @Test\n    public void testNonIntegerValues() {\n        // Test with non-integer pixel coordinates.\n        double[] result = get3DCoordinates(K, 100, 320.5, 240.5);\n        double expectedX = (320.5 - 320) / 1000 * 100;\n        double expectedY = (240.5 - 240) / 1000 * 100;\n        assertArrayEquals(new double[]{expectedX, expectedY, 100}, result, 1e-6);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n *\n * @param K A 3x3 matrix representing the camera intrinsic parameters.\n * @param d Depth (distance along the z-axis).\n * @param x Pixel x coordinate.\n * @param y Pixel y coordinate.\n * @return An array containing the 3D coordinates [x, y, z] in camera RDF coordinates.\n */\npublic static double[] get3DCoordinates(INDArray K, double d, double x, double y) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 73, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "convert a dictionary of lists to a list of dictionaries", "language_version_list": {"python": {"code_signature": "from typing import Dict, List\n\n\ndef dict_of_lists_to_list_of_dicts(dict_of_lists: Dict) -> List[Dict]:\n    \"\"\"\n    Convert a dictionary of lists into a list of dictionaries.\n    Args:\n        dict_of_lists (dict): A dictionary where each key has a list as its value.\n\n    Returns:\n        list of dicts: A list where each item is a dictionary formed by corresponding elements of lists in the input dictionary.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestDictOfListsToListOfDicts(unittest.TestCase):\n    def test_standard_conversion(self):\n        \"\"\"Test standard conversion with equal length lists.\"\"\"\n        dict_of_lists = {\n            \"name\": [\"Alice\", \"Bob\", \"Charlie\"],\n            \"age\": [25, 30, 35],\n            \"city\": [\"New York\", \"Los Angeles\", \"Chicago\"]\n        }\n        expected_result = [\n            {'name': 'Alice', 'age': 25, 'city': 'New York'},\n            {'name': 'Bob', 'age': 30, 'city': 'Los Angeles'},\n            {'name': 'Charlie', 'age': 35, 'city': 'Chicago'}\n        ]\n        result = dict_of_lists_to_list_of_dicts(dict_of_lists)\n        self.assertEqual(result, expected_result)\n\n    def test_empty_lists(self):\n        \"\"\"Test the function with empty lists.\"\"\"\n        dict_of_lists = {\n            \"name\": [],\n            \"age\": [],\n            \"city\": []\n        }\n        expected_result = []\n        result = dict_of_lists_to_list_of_dicts(dict_of_lists)\n        self.assertEqual(result, expected_result)\n\n    def test_single_element_lists(self):\n        \"\"\"Test the function with single-element lists.\"\"\"\n        dict_of_lists = {\n            \"name\": [\"Alice\"],\n            \"age\": [25],\n            \"city\": [\"New York\"]\n        }\n        expected_result = [\n            {'name': 'Alice', 'age': 25, 'city': 'New York'}\n        ]\n        result = dict_of_lists_to_list_of_dicts(dict_of_lists)\n        self.assertEqual(result, expected_result)\n", "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef dict_of_lists_to_list_of_dicts(dict_of_lists: Dict) -> List[Dict]:\n    \"\"\"\n    Convert a dictionary of lists into a list of dictionaries.\n    Args:\n        dict_of_lists (dict): A dictionary where each key has a list as its value.\n\n    Returns:\n        list of dicts: A list where each item is a dictionary formed by corresponding elements of lists in the input dictionary.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Convert a dictionary of lists into a list of dictionaries.\n * \n * @param {Object} dictOfLists - An object where each key has an array as its value.\n * @returns {Array} - An array where each item is an object formed by corresponding elements of arrays in the input object.\n * @throws {Error} - If arrays in the object are of different lengths.\n */\nfunction dictOfListsToListOfDicts(dictOfLists) {}", "test_code": "describe('TestDictOfListsToListOfDicts', () => {\n  describe('test_standard_conversion', () => {\n      it('should correctly convert a dictionary of lists into a list of dictionaries with equal length lists', () => {\n          const dictOfLists = {\n              name: ['Alice', 'Bob', 'Charlie'],\n              age: [25, 30, 35],\n              city: ['New York', 'Los Angeles', 'Chicago']\n          };\n          const expectedResult = [\n              { name: 'Alice', age: 25, city: 'New York' },\n              { name: 'Bob', age: 30, city: 'Los Angeles' },\n              { name: 'Charlie', age: 35, city: 'Chicago' }\n          ];\n          const result = dictOfListsToListOfDicts(dictOfLists);\n          expect(result).toEqual(expectedResult);\n      });\n  });\n\n  describe('test_empty_lists', () => {\n      it('should handle empty lists correctly', () => {\n          const dictOfLists = {\n              name: [],\n              age: [],\n              city: []\n          };\n          const expectedResult = [];\n          const result = dictOfListsToListOfDicts(dictOfLists);\n          expect(result).toEqual(expectedResult);\n      });\n  });\n\n  describe('test_single_element_lists', () => {\n      it('should correctly convert a dictionary of single-element lists into a list of dictionaries', () => {\n          const dictOfLists = {\n              name: ['Alice'],\n              age: [25],\n              city: ['New York']\n          };\n          const expectedResult = [\n              { name: 'Alice', age: 25, city: 'New York' }\n          ];\n          const result = dictOfListsToListOfDicts(dictOfLists);\n          expect(result).toEqual(expectedResult);\n      });\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Convert a dictionary of lists into a list of dictionaries.\n * \n * @param {Object} dictOfLists - An object where each key has an array as its value.\n * @returns {Array} - An array where each item is an object formed by corresponding elements of arrays in the input object.\n * @throws {Error} - If arrays in the object are of different lengths.\n */\nfunction dictOfListsToListOfDicts(dictOfLists) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Convert a dictionary of lists into a list of dictionaries.\n * \n * @param dictOfLists - A dictionary where each key has a list as its value.\n * @returns A list where each item is a dictionary formed by corresponding elements of lists in the input dictionary.\n * @throws {Error} If lists in the dictionary are of different lengths.\n */\nfunction dictOfListsToListOfDicts(dictOfLists: { [key: string]: any[] }): { [key: string]: any }[] {}", "test_code": "describe('TestDictOfListsToListOfDicts', () => {\n  it('test_standard_conversion', () => {\n      const dictOfLists = {\n          \"name\": [\"Alice\", \"Bob\", \"Charlie\"],\n          \"age\": [25, 30, 35],\n          \"city\": [\"New York\", \"Los Angeles\", \"Chicago\"]\n      };\n      const expectedResult = [\n          { name: 'Alice', age: 25, city: 'New York' },\n          { name: 'Bob', age: 30, city: 'Los Angeles' },\n          { name: 'Charlie', age: 35, city: 'Chicago' }\n      ];\n      const result = dictOfListsToListOfDicts(dictOfLists);\n      expect(result).toEqual(expectedResult);\n  });\n\n  it('test_empty_lists', () => {\n      const dictOfLists = {\n          \"name\": [],\n          \"age\": [],\n          \"city\": []\n      };\n      const expectedResult = [];\n      const result = dictOfListsToListOfDicts(dictOfLists);\n      expect(result).toEqual(expectedResult);\n  });\n\n  it('test_single_element_lists', () => {\n      const dictOfLists = {\n          \"name\": [\"Alice\"],\n          \"age\": [25],\n          \"city\": [\"New York\"]\n      };\n      const expectedResult = [\n          { name: 'Alice', age: 25, city: 'New York' }\n      ];\n      const result = dictOfListsToListOfDicts(dictOfLists);\n      expect(result).toEqual(expectedResult);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Convert a dictionary of lists into a list of dictionaries.\n * \n * @param dictOfLists - A dictionary where each key has a list as its value.\n * @returns A list where each item is a dictionary formed by corresponding elements of lists in the input dictionary.\n * @throws {Error} If lists in the dictionary are of different lengths.\n */\nfunction dictOfListsToListOfDicts(dictOfLists: { [key: string]: any[] }): { [key: string]: any }[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert a dictionary of lists into a list of dictionaries.\n *\n * @param dict_of_lists A map where each key has a vector as its value.\n * @return A vector of maps, where each map is formed by corresponding elements of vectors in the input map.\n */\nstd::vector<std::map<std::string, int>> dict_of_lists_to_list_of_dicts(const std::map<std::string, std::vector<int>>& dict_of_lists) {}", "test_code": "TEST_CASE(\"TestDictOfListsToListOfDicts\") {\n    SECTION(\"test_standard_conversion\") {\n        // Test standard conversion with equal length lists\n        std::map<std::string, std::vector<std::string>> dict_of_lists = {\n            {\"name\", {\"Alice\", \"Bob\", \"Charlie\"}},\n            {\"age\", {\"25\", \"30\", \"35\"}},\n            {\"city\", {\"New York\", \"Los Angeles\", \"Chicago\"}}\n        };\n        std::vector<std::map<std::string, std::string>> expected_result = {\n            {{\"name\", \"Alice\"}, {\"age\", \"25\"}, {\"city\", \"New York\"}},\n            {{\"name\", \"Bob\"}, {\"age\", \"30\"}, {\"city\", \"Los Angeles\"}},\n            {{\"name\", \"Charlie\"}, {\"age\", \"35\"}, {\"city\", \"Chicago\"}}\n        };\n\n        auto result = dict_of_lists_to_list_of_dicts(dict_of_lists);\n        REQUIRE(result == expected_result);\n    }\n\n    SECTION(\"test_empty_lists\") {\n        // Test the function with empty lists\n        std::map<std::string, std::vector<std::string>> dict_of_lists = {\n            {\"name\", {}},\n            {\"age\", {}},\n            {\"city\", {}}\n        };\n        std::vector<std::map<std::string, std::string>> expected_result = {};\n\n        auto result = dict_of_lists_to_list_of_dicts(dict_of_lists);\n        REQUIRE(result == expected_result);\n    }\n\n    SECTION(\"test_single_element_lists\") {\n        // Test the function with single-element lists\n        std::map<std::string, std::vector<std::string>> dict_of_lists = {\n            {\"name\", {\"Alice\"}},\n            {\"age\", {\"25\"}},\n            {\"city\", {\"New York\"}}\n        };\n        std::vector<std::map<std::string, std::string>> expected_result = {\n            {{\"name\", \"Alice\"}, {\"age\", \"25\"}, {\"city\", \"New York\"}}\n        };\n\n        auto result = dict_of_lists_to_list_of_dicts(dict_of_lists);\n        REQUIRE(result == expected_result);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert a dictionary of lists into a list of dictionaries.\n *\n * @param dict_of_lists A map where each key has a vector as its value.\n * @return A vector of maps, where each map is formed by corresponding elements of vectors in the input map.\n */\nstd::vector<std::map<std::string, int>> dict_of_lists_to_list_of_dicts(const std::map<std::string, std::vector<int>>& dict_of_lists) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Convert a map of lists into a list of maps.\n *\n * @param mapOfLists A map where each key has a list as its value.\n * @return A list where each item is a map formed by corresponding elements of lists in the input map.\n * @throws IllegalArgumentException If lists in the map are of different lengths.\n */\npublic static List<Map<String, Integer>> dictOfListsToListOfDicts(Map<String, List<Integer>> mapOfLists) throws IllegalArgumentException {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.*;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    private static final String NAME = \"name\";\n    private static final String AGE = \"age\";\n    private static final String CITY = \"city\";\n\n    /**\n     * Test standard conversion with equal length lists.\n     */\n    @Test\n    public void testStandardConversion() {\n        Map<String, List<Object>> dictOfLists = new HashMap<>();\n        dictOfLists.put(NAME, Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"));\n        dictOfLists.put(AGE, Arrays.asList(25, 30, 35));\n        dictOfLists.put(CITY, Arrays.asList(\"New York\", \"Los Angeles\", \"Chicago\"));\n\n        List<Map<String, Object>> expectedResult = Arrays.asList(\n            new HashMap<String, Object>() {{\n                put(NAME, \"Alice\");\n                put(AGE, 25);\n                put(CITY, \"New York\");\n            }},\n            new HashMap<String, Object>() {{\n                put(NAME, \"Bob\");\n                put(AGE, 30);\n                put(CITY, \"Los Angeles\");\n            }},\n            new HashMap<String, Object>() {{\n                put(NAME, \"Charlie\");\n                put(AGE, 35);\n                put(CITY, \"Chicago\");\n            }}\n        );\n\n        List<Map<String, Integer>> result = dictOfListsToListOfDicts(dictOfLists);\n        assertEquals(expectedResult, result);\n    }\n\n    /**\n     * Test the function with empty lists.\n     */\n    @Test\n    public void testEmptyLists() {\n        Map<String, List<Object>> dictOfLists = new HashMap<>();\n        dictOfLists.put(NAME, Collections.emptyList());\n        dictOfLists.put(AGE, Collections.emptyList());\n        dictOfLists.put(CITY, Collections.emptyList());\n\n        List<Map<String, Object>> expectedResult = Collections.emptyList();\n\n        List<Map<String, Integer>> result = dictOfListsToListOfDicts(dictOfLists);\n        assertEquals(expectedResult, result);\n    }\n\n    /**\n     * Test the function with single-element lists.\n     */\n    @Test\n    public void testSingleElementLists() {\n        Map<String, List<Object>> dictOfLists = new HashMap<>();\n        dictOfLists.put(NAME, Collections.singletonList(\"Alice\"));\n        dictOfLists.put(AGE, Collections.singletonList(25));\n        dictOfLists.put(CITY, Collections.singletonList(\"New York\"));\n\n        List<Map<String, Object>> expectedResult = Collections.singletonList(\n            new HashMap<String, Object>() {{\n                put(NAME, \"Alice\");\n                put(AGE, 25);\n                put(CITY, \"New York\");\n            }}\n        );\n\n        List<Map<String, Integer>> result = dictOfListsToListOfDicts(dictOfLists);\n        assertEquals(expectedResult, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Convert a map of lists into a list of maps.\n *\n * @param mapOfLists A map where each key has a list as its value.\n * @return A list where each item is a map formed by corresponding elements of lists in the input map.\n * @throws IllegalArgumentException If lists in the map are of different lengths.\n */\npublic static List<Map<String, Integer>> dictOfListsToListOfDicts(Map<String, List<Integer>> mapOfLists) throws IllegalArgumentException {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 74, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Convert a decimal number to a 32-bit or 64-bit binary representation.", "language_version_list": {"python": {"code_signature": "import struct\nfrom typing import Union\n\ndef convert_decimal_to_binary(decimal_value: float, bit_length: int) -> Union[str, None]:\n    \"\"\"\n    Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n    For example:\n        input: decimal 3.14 bit 32\n        output: 01000000010010001111010111000011\n\n    Args:\n        decimal_value (float): The decimal number to convert.\n        bit_length (int): The desired bit length for the binary representation (32 or 64).\n\n    Returns:\n        Union[str, None]: The binary string representation of the decimal number if the bit length\n                          is valid, otherwise `None`.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestConvertDecimalToBinary(unittest.TestCase):\n    def test_basic_32_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(3.14, 32),\n                         '01000000010010001111010111000011',\n                         \"3.14 should be correctly converted to 32-bit binary\")\n\n    def test_basic_64_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(3.14, 64),\n                         '0100000000001001000111101011100001010001111010111000010100011111',\n                         \"3.14 should be correctly converted to 64-bit binary\")\n\n    def test_advance_32_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(1.5, 32), '00111111110000000000000000000000',\n                         \"1.5 should be correctly converted to 32-bit binary\")\n\n    def test_advance_64_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(1.5, 64),\n                         '0011111111111000000000000000000000000000000000000000000000000000',\n                         \"1.5 should be correctly converted to 32-bit binary\")\n", "prompt": "please write a python function , the function signature as below import struct\nfrom typing import Union\n\ndef convert_decimal_to_binary(decimal_value: float, bit_length: int) -> Union[str, None]:\n    \"\"\"\n    Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n    For example:\n        input: decimal 3.14 bit 32\n        output: 01000000010010001111010111000011\n\n    Args:\n        decimal_value (float): The decimal number to convert.\n        bit_length (int): The desired bit length for the binary representation (32 or 64).\n\n    Returns:\n        Union[str, None]: The binary string representation of the decimal number if the bit length\n                          is valid, otherwise `None`.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n *\n * @param {number} decimalValue - The decimal number to convert.\n * @param {number} bitLength - The desired bit length for the binary representation (32 or 64).\n * @returns {string|null} The binary string representation of the decimal number if the bit length\n *                        is valid, otherwise `null`.\n * @throws {Error} Throws an error if the bit length is not 32 or 64.\n */\nfunction convertDecimalToBinary(decimalValue, bitLength) {}", "test_code": "describe('convertDecimalToBinary', () => {\n    test('basic 32-bit conversion for 3.14', () => {\n        expect(convertDecimalToBinary(3.14, 32)).toBe('01000000010010001111010111000011');\n    });\n\n    test('basic 64-bit conversion for 3.14', () => {\n        expect(convertDecimalToBinary(3.14, 64)).toBe('0100000000001001000111101011100001010001111010111000010100011111');\n    });\n\n    test('advanced 32-bit conversion for 1.5', () => {\n        expect(convertDecimalToBinary(1.5, 32)).toBe('00111111110000000000000000000000');\n    });\n\n    test('advanced 64-bit conversion for 1.5', () => {\n        expect(convertDecimalToBinary(1.5, 64)).toBe('0011111111111000000000000000000000000000000000000000000000000000');\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n *\n * @param {number} decimalValue - The decimal number to convert.\n * @param {number} bitLength - The desired bit length for the binary representation (32 or 64).\n * @returns {string|null} The binary string representation of the decimal number if the bit length\n *                        is valid, otherwise `null`.\n * @throws {Error} Throws an error if the bit length is not 32 or 64.\n */\nfunction convertDecimalToBinary(decimalValue, bitLength) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n *\n * @param {number} decimalValue - The decimal number to convert.\n * @param {number} bitLength - The desired bit length for the binary representation (32 or 64).\n * @returns {string | null} The binary string representation of the decimal number if the bit length\n *                          is valid, otherwise `null`.\n * @throws {Error} Throws an error if the bit length is not 32 or 64.\n */\nfunction convertDecimalToBinary(decimalValue: number, bitLength: number): string | null {}", "test_code": "describe('convertDecimalToBinary', () => {\n    test('basic 32-bit conversion for 3.14', () => {\n        expect(convertDecimalToBinary(3.14, 32)).toBe('01000000010010001111010111000011');\n    });\n\n    test('basic 64-bit conversion for 3.14', () => {\n        expect(convertDecimalToBinary(3.14, 64)).toBe('0100000000001001000111101011100001010001111010111000010100011111');\n    });\n\n    test('advanced 32-bit conversion for 1.5', () => {\n        expect(convertDecimalToBinary(1.5, 32)).toBe('00111111110000000000000000000000');\n    });\n\n    test('advanced 64-bit conversion for 1.5', () => {\n        expect(convertDecimalToBinary(1.5, 64)).toBe('0011111111111000000000000000000000000000000000000000000000000000');\n    });\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n *\n * @param {number} decimalValue - The decimal number to convert.\n * @param {number} bitLength - The desired bit length for the binary representation (32 or 64).\n * @returns {string | null} The binary string representation of the decimal number if the bit length\n *                          is valid, otherwise `null`.\n * @throws {Error} Throws an error if the bit length is not 32 or 64.\n */\nfunction convertDecimalToBinary(decimalValue: number, bitLength: number): string | null {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n *\n * This function takes a decimal number and converts it to its binary string representation\n * in either 32-bit (single precision) or 64-bit (double precision) format.\n *\n * @param decimal_value The decimal number to convert (can be a float or double).\n * @param bit_length The desired bit length for the binary representation (32 or 64).\n * @return A string containing the binary representation of the decimal number.\n * @throws std::invalid_argument if the bit_length is not 32 or 64.\n */\nstd::string convert_decimal_to_binary(double decimal_value, int bit_length) {}", "test_code": "TEST_CASE(\"Basic 32-bit conversion\") {\n    REQUIRE(convert_decimal_to_binary(3.14, 32) == \"01000000010010001111010111000011\");\n}\n\nTEST_CASE(\"Basic 64-bit conversion\") {\n    REQUIRE(convert_decimal_to_binary(3.14, 64) == \"0100000000001001000111101011100001010001111010111000010100011111\");\n}\n\nTEST_CASE(\"Advanced 32-bit conversion\") {\n    REQUIRE(convert_decimal_to_binary(1.5, 32) == \"00111111110000000000000000000000\");\n}\n\nTEST_CASE(\"Advanced 64-bit conversion\") {\n    REQUIRE(convert_decimal_to_binary(1.5, 64) == \"0011111111111000000000000000000000000000000000000000000000000000\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n *\n * This function takes a decimal number and converts it to its binary string representation\n * in either 32-bit (single precision) or 64-bit (double precision) format.\n *\n * @param decimal_value The decimal number to convert (can be a float or double).\n * @param bit_length The desired bit length for the binary representation (32 or 64).\n * @return A string containing the binary representation of the decimal number.\n * @throws std::invalid_argument if the bit_length is not 32 or 64.\n */\nstd::string convert_decimal_to_binary(double decimal_value, int bit_length) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n *\n * @param decimalValue the decimal number to convert. This can be a floating-point number\n *                     represented as a double.\n * @param bitLength    the desired bit length for the binary representation. It should be either\n *                     32 for a 32-bit binary representation or 64 for a 64-bit binary representation.\n * @return a binary string representation of the decimal number, zero-padded to the specified bit length.\n *         If the bit length is not 32 or 64, an IllegalArgumentException is thrown.\n * \n * @throws IllegalArgumentException if bitLength is not 32 or 64.\n */\npublic static String convertDecimalToBinary(double decimalValue, int bitLength) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testBasic32BitConversion() {\n        assertEquals(\"3.14 should be correctly converted to 32-bit binary\",\n                \"01000000010010001111010111000011\",\n                convertDecimalToBinary(3.14, 32));\n    }\n\n    @Test\n    public void testBasic64BitConversion() {\n        assertEquals(\"3.14 should be correctly converted to 64-bit binary\",\n                \"0100000000001001000111101011100001010001111010111000010100011111\",\n                convertDecimalToBinary(3.14, 64));\n    }\n\n    @Test\n    public void testAdvance32BitConversion() {\n        assertEquals(\"1.5 should be correctly converted to 32-bit binary\",\n                \"00111111110000000000000000000000\",\n                convertDecimalToBinary(1.5, 32));\n    }\n\n    @Test\n    public void testAdvance64BitConversion() {\n        assertEquals(\"1.5 should be correctly converted to 64-bit binary\",\n                \"0011111111111000000000000000000000000000000000000000000000000000\",\n                convertDecimalToBinary(1.5, 64));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n *\n * @param decimalValue the decimal number to convert. This can be a floating-point number\n *                     represented as a double.\n * @param bitLength    the desired bit length for the binary representation. It should be either\n *                     32 for a 32-bit binary representation or 64 for a 64-bit binary representation.\n * @return a binary string representation of the decimal number, zero-padded to the specified bit length.\n *         If the bit length is not 32 or 64, an IllegalArgumentException is thrown.\n * \n * @throws IllegalArgumentException if bitLength is not 32 or 64.\n */\npublic static String convertDecimalToBinary(double decimalValue, int bitLength) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 75, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": " Renames PNG files in a specified directory by appending a sequence number to each file.\n    The files are sorted alphabetically, and each base name is assigned sequential numbers.eg image1.png after change to be image1001.png", "language_version_list": {"python": {"code_signature": "def rename_png_files_in_directory(directory: str):\n    \"\"\"\n    Renames PNG files in a specified directory by appending a sequence number to each file.\n    The files are sorted alphabetically, and each base name is assigned sequential numbers.\n    For example:\n        director have three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\"\n        after renaming PNG files are \"image1001.png\", \"image2001.png\", \"image3001.png\"\n\n    Args:\n        directory (str): The path to the directory containing PNG files to be renamed.\n\n    Returns:\n        None\n    \"\"\"\n", "test_code": "import re\nimport unittest\nimport os\nimport shutil\nimport tempfile\nfrom pathlib import Path\n\n\n\nclass TestRenameFiles(unittest.TestCase):\n\n    def setUp(self):\n        self.test_dir = tempfile.mkdtemp()\n\n    def tearDown(self):\n        shutil.rmtree(self.test_dir)\n\n    def create_png_files(self, filenames):\n        for filename in filenames:\n            file_path = Path(self.test_dir) / filename\n            file_path.touch()  # Create an empty file\n\n    def test_basic_renaming(self):\n        filenames = [\"image1.png\", \"image2.png\", \"image3.png\"]\n        self.create_png_files(filenames)\n\n        rename_png_files_in_directory(self.test_dir)\n\n        expected_files = ['image1001.png', 'image2001.png', 'image3001.png']\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)\n\n    def test_reset_counter_for_different_base_names(self):\n        filenames = [\"image1.png\", \"picture1.png\", \"image2.png\", \"picture2.png\"]\n        self.create_png_files(filenames)\n\n        rename_png_files_in_directory(self.test_dir)\n\n        expected_files = ['image1001.png', 'image2001.png', 'picture1001.png', 'picture2001.png']\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)\n\n    def test_no_png_files(self):\n        filenames = [\"file1.txt\", \"file2.jpg\"]\n        self.create_png_files(filenames)\n\n        rename_png_files_in_directory(self.test_dir)\n\n        expected_files = filenames  # No changes expected\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)\n\n    def test_empty_directory(self):\n        rename_png_files_in_directory(self.test_dir)\n        expected_files = []  # No files to rename\n        result_files = os.listdir(self.test_dir)\n        self.assertEqual(result_files, expected_files)\n\n    def test_files_with_existing_numbers(self):\n        filenames = [\"file001.png\", \"file002.png\", \"file003.png\"]\n        self.create_png_files(filenames)\n\n        rename_png_files_in_directory(self.test_dir)\n\n        expected_files = ['file001001.png', 'file002001.png', 'file003001.png']\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)", "prompt": "please write a python function , the function signature as below def rename_png_files_in_directory(directory: str):\n    \"\"\"\n    Renames PNG files in a specified directory by appending a sequence number to each file.\n    The files are sorted alphabetically, and each base name is assigned sequential numbers.\n    For example:\n        director have three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\"\n        after renaming PNG files are \"image1001.png\", \"image2001.png\", \"image3001.png\"\n\n    Args:\n        directory (str): The path to the directory containing PNG files to be renamed.\n\n    Returns:\n        None\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Renames PNG files in a specified directory by appending a sequence number to each file.\n * The files are sorted alphabetically, and each base name is assigned sequential numbers.\n * For example:\n *   If the directory contains three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\",\n *   after renaming, the PNG files will be \"image1001.png\", \"image2001.png\", \"image3001.png\".\n *\n * @param {string} directory - The path to the directory containing PNG files to be renamed.\n * @returns {void} \n * @throws {Error} Throws an error if the directory cannot be accessed or if an error occurs during renaming.\n */\nfunction renameFiles(directory) {}", "test_code": "describe('TestRenameFiles', () => {\n    let testDir;\n\n    beforeAll(() => {\n        testDir = mkdtempSync(path.join(os.tmpdir(), 'test-rename-files-'));\n    });\n\n    afterAll(() => {\n        rmSync(testDir, { recursive: true });\n    });\n\n    beforeEach(() => {\n        // Ensure the test directory is clean before each test\n        fs.readdirSync(testDir).forEach(file => {\n            fs.unlinkSync(path.join(testDir, file));\n        });\n    });\n\n    function createPngFiles(filenames) {\n        filenames.forEach(filename => {\n            const filePath = path.join(testDir, filename);\n            fs.writeFileSync(filePath, '');\n        });\n    }\n\n    it('should rename files in a basic scenario with simple filenames', () => {\n        const filenames = [\"image1.png\", \"image2.png\", \"image3.png\"];\n        createPngFiles(filenames);\n\n        renameFiles(testDir);\n\n        const expectedFiles = ['image1001.png', 'image2001.png', 'image3001.png'];\n        const resultFiles = readdirSync(testDir).sort();\n        expect(resultFiles).toEqual(expectedFiles);\n    });\n\n    it('should reset the counter for different base names', () => {\n        const filenames = [\"image1.png\", \"picture1.png\", \"image2.png\", \"picture2.png\"];\n        createPngFiles(filenames);\n\n        renameFiles(testDir);\n\n        const expectedFiles = ['image1001.png', 'image2001.png', 'picture1001.png', 'picture2001.png'];\n        const resultFiles = readdirSync(testDir).sort();\n        expect(resultFiles).toEqual(expectedFiles);\n    });\n\n    it('should handle directories with no PNG files', () => {\n        const filenames = [\"file1.txt\", \"file2.jpg\"];\n        createPngFiles(filenames);\n\n        renameFiles(testDir);\n\n        const expectedFiles = filenames;\n        const resultFiles = readdirSync(testDir).sort();\n        expect(resultFiles).toEqual(expectedFiles);\n    });\n\n    it('should handle an empty directory', () => {\n        renameFiles(testDir);\n\n        const expectedFiles = [];\n        const resultFiles = readdirSync(testDir);\n        expect(resultFiles).toEqual(expectedFiles);\n    });\n\n    it('should rename files that already have numbers in their names', () => {\n        const filenames = [\"file001.png\", \"file002.png\", \"file003.png\"];\n        createPngFiles(filenames);\n\n        renameFiles(testDir);\n\n        const expectedFiles = ['file001001.png', 'file002001.png', 'file003001.png'];\n        const resultFiles = readdirSync(testDir).sort();\n        expect(resultFiles).toEqual(expectedFiles);\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Renames PNG files in a specified directory by appending a sequence number to each file.\n * The files are sorted alphabetically, and each base name is assigned sequential numbers.\n * For example:\n *   If the directory contains three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\",\n *   after renaming, the PNG files will be \"image1001.png\", \"image2001.png\", \"image3001.png\".\n *\n * @param {string} directory - The path to the directory containing PNG files to be renamed.\n * @returns {void} \n * @throws {Error} Throws an error if the directory cannot be accessed or if an error occurs during renaming.\n */\nfunction renameFiles(directory) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Renames PNG files in a specified directory by appending a sequence number to each file.\n * The files are sorted alphabetically, and each base name is assigned sequential numbers.\n * For example:\n *   If the directory contains three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\",\n *   after renaming, the PNG files will be \"image1001.png\", \"image2001.png\", \"image3001.png\".\n *\n * @param {string} directory - The path to the directory containing PNG files to be renamed.\n * @returns {void} \n * @throws {Error} Throws an error if the directory cannot be accessed or if an error occurs during renaming.\n */\nfunction renameFiles(directory: string): void {}", "test_code": "describe('TestRenameFiles', () => {\n    let testDir: string;\n\n    beforeEach(() => {\n        // Create a temporary directory for each test\n        testDir = fs.mkdtempSync(path.join(os.tmpdir(), 'test-rename-files-'));\n    });\n\n    afterEach(() => {\n        // Remove the temporary directory after each test\n        fs.rmSync(testDir, { recursive: true, force: true });\n    });\n\n    function createPngFiles(filenames: string[]): void {\n        filenames.forEach(filename => {\n            const filePath = path.join(testDir, filename);\n            fs.writeFileSync(filePath, '');\n        });\n    }\n\n    it('should rename files in a basic scenario with simple filenames', () => {\n        const filenames = ['image1.png', 'image2.png', 'image3.png'];\n        createPngFiles(filenames);\n\n        renameFiles(testDir);\n\n        const expectedFiles = ['image1001.png', 'image2001.png', 'image3001.png'];\n        const resultFiles = fs.readdirSync(testDir).sort();\n        expect(resultFiles).toEqual(expectedFiles);\n    });\n\n    it('should reset the counter for different base names', () => {\n        const filenames = ['image1.png', 'picture1.png', 'image2.png', 'picture2.png'];\n        createPngFiles(filenames);\n\n        renameFiles(testDir);\n\n        const expectedFiles = ['image1001.png', 'image2001.png', 'picture1001.png', 'picture2001.png'];\n        const resultFiles = fs.readdirSync(testDir).sort();\n        expect(resultFiles).toEqual(expectedFiles);\n    });\n\n    it('should handle directories with no PNG files', () => {\n        const filenames = ['file1.txt', 'file2.jpg'];\n        createPngFiles(filenames);\n\n        renameFiles(testDir);\n\n        const expectedFiles = filenames;\n        const resultFiles = fs.readdirSync(testDir).sort();\n        expect(resultFiles).toEqual(expectedFiles);\n    });\n\n    it('should handle an empty directory', () => {\n        renameFiles(testDir);\n\n        const expectedFiles = [];\n        const resultFiles = fs.readdirSync(testDir);\n        expect(resultFiles).toEqual(expectedFiles);\n    });\n\n    it('should rename files that already have numbers in their names', () => {\n        const filenames = ['file001.png', 'file002.png', 'file003.png'];\n        createPngFiles(filenames);\n\n        renameFiles(testDir);\n\n        const expectedFiles = ['file001001.png', 'file002001.png', 'file003001.png'];\n        const resultFiles = fs.readdirSync(testDir).sort();\n        expect(resultFiles).toEqual(expectedFiles);\n    });\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Renames PNG files in a specified directory by appending a sequence number to each file.\n * The files are sorted alphabetically, and each base name is assigned sequential numbers.\n * For example:\n *   If the directory contains three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\",\n *   after renaming, the PNG files will be \"image1001.png\", \"image2001.png\", \"image3001.png\".\n *\n * @param {string} directory - The path to the directory containing PNG files to be renamed.\n * @returns {void} \n * @throws {Error} Throws an error if the directory cannot be accessed or if an error occurs during renaming.\n */\nfunction renameFiles(directory: string): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n* @brief Renames PNG files in a specified directory by appending a sequence number to each file.\n* The files are sorted alphabetically, and each base name is assigned sequential numbers.\n* For example:\n*     If the directory has three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\",\n*     after renaming, the PNG files will be \"image1001.png\", \"image2001.png\", \"image3001.png\".\n*\n* @param directory The path to the directory containing PNG files to be renamed.\n*/\nvoid rename_files(const std::string& directory) {}", "test_code": "TEST_CASE(\"TestRenameFiles\", \"[rename_files]\") {\n    TempDir temp_dir;\n\n    SECTION(\"test_basic_renaming\") {\n        std::vector<std::string> filenames = {\"image1.png\", \"image2.png\", \"image3.png\"};\n        create_png_files(temp_dir.path, filenames);\n\n        rename_files(temp_dir.path.string());\n\n        std::vector<std::string> expected_files = {\"image1001.png\", \"image2001.png\", \"image3001.png\"};\n        std::vector<std::string> result_files;\n        for (const auto& entry : fs::directory_iterator(temp_dir.path)) {\n            result_files.push_back(entry.path().filename().string());\n        }\n        std::sort(result_files.begin(), result_files.end());\n\n        REQUIRE(result_files == expected_files);\n    }\n\n    SECTION(\"test_reset_counter_for_different_base_names\") {\n        std::vector<std::string> filenames = {\"image1.png\", \"picture1.png\", \"image2.png\", \"picture2.png\"};\n        create_png_files(temp_dir.path, filenames);\n\n        rename_files(temp_dir.path.string());\n\n        std::vector<std::string> expected_files = {\"image1001.png\", \"image2001.png\", \"picture1001.png\", \"picture2001.png\"};\n        std::vector<std::string> result_files;\n        for (const auto& entry : fs::directory_iterator(temp_dir.path)) {\n            result_files.push_back(entry.path().filename().string());\n        }\n        std::sort(result_files.begin(), result_files.end());\n\n        REQUIRE(result_files == expected_files);\n    }\n\n    SECTION(\"test_no_png_files\") {\n        std::vector<std::string> filenames = {\"file1.txt\", \"file2.jpg\"};\n        create_png_files(temp_dir.path, filenames);\n\n        rename_files(temp_dir.path.string());\n\n        std::vector<std::string> expected_files = filenames;\n        std::vector<std::string> result_files;\n        for (const auto& entry : fs::directory_iterator(temp_dir.path)) {\n            result_files.push_back(entry.path().filename().string());\n        }\n        std::sort(result_files.begin(), result_files.end());\n\n        REQUIRE(result_files == expected_files);\n    }\n\n    SECTION(\"test_empty_directory\") {\n        rename_files(temp_dir.path.string());\n\n        std::vector<std::string> expected_files = {};\n        std::vector<std::string> result_files;\n        for (const auto& entry : fs::directory_iterator(temp_dir.path)) {\n            result_files.push_back(entry.path().filename().string());\n        }\n\n        REQUIRE(result_files.empty());\n    }\n\n    SECTION(\"test_files_with_existing_numbers\") {\n        std::vector<std::string> filenames = {\"file001.png\", \"file002.png\", \"file003.png\"};\n        create_png_files(temp_dir.path, filenames);\n\n        rename_files(temp_dir.path.string());\n\n        std::vector<std::string> expected_files = {\"file001001.png\", \"file002001.png\", \"file003001.png\"};\n        std::vector<std::string> result_files;\n        for (const auto& entry : fs::directory_iterator(temp_dir.path)) {\n            result_files.push_back(entry.path().filename().string());\n        }\n        std::sort(result_files.begin(), result_files.end());\n\n        REQUIRE(result_files == expected_files);\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n* @brief Renames PNG files in a specified directory by appending a sequence number to each file.\n* The files are sorted alphabetically, and each base name is assigned sequential numbers.\n* For example:\n*     If the directory has three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\",\n*     after renaming, the PNG files will be \"image1001.png\", \"image2001.png\", \"image3001.png\".\n*\n* @param directory The path to the directory containing PNG files to be renamed.\n*/\nvoid rename_files(const std::string& directory) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Renames PNG files in a specified directory by appending a sequence number to each file.\n * The files are sorted alphabetically, and each base name is assigned sequential numbers.\n * For example:\n *   If the directory contains three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\",\n *   after renaming, the PNG files will be \"image1001.png\", \"image2001.png\", \"image3001.png\".\n *\n * @param directory The path to the directory containing PNG files to be renamed.\n */\npublic static void renameFiles(String directory) {\n\n }", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Rule\n    public TemporaryFolder tempFolder = new TemporaryFolder();\n    private Path testDir;\n\n    @Before\n    public void setUp() throws IOException {\n        this.testDir = tempFolder.newFolder().toPath(); // Create a new temporary directory\n    }\n\n    @After\n    public void tearDown() {\n        // TemporaryFolder will automatically delete the folder after the test\n    }\n\n    private void createPngFiles(List<String> filenames) throws IOException {\n        for (String filename : filenames) {\n            Path filePath = testDir.resolve(filename);\n            Files.createFile(filePath);  // Create an empty file\n        }\n    }\n\n    @Test\n    public void testBasicRenaming() throws IOException {\n        // Test renaming in a basic scenario with simple filenames\n        List<String> filenames = Arrays.asList(\"image1.png\", \"image2.png\", \"image3.png\");\n        createPngFiles(filenames);\n\n        renameFiles(testDir.toString());\n\n        List<String> expectedFiles = Arrays.asList(\"image1001.png\", \"image2001.png\", \"image3001.png\");\n        List<String> resultFiles = Files.list(testDir)\n                .map(Path::getFileName)\n                .map(Path::toString)\n                .sorted()\n                .collect(Collectors.toList());\n        assertEquals(expectedFiles, resultFiles);\n    }\n\n    @Test\n    public void testResetCounterForDifferentBaseNames() throws IOException {\n        // Test that the counter resets for different base names\n        List<String> filenames = Arrays.asList(\"image1.png\", \"picture1.png\", \"image2.png\", \"picture2.png\");\n        createPngFiles(filenames);\n\n        renameFiles(testDir.toString());\n\n        List<String> expectedFiles = Arrays.asList(\"image1001.png\", \"image2001.png\", \"picture1001.png\", \"picture2001.png\");\n        List<String> resultFiles = Files.list(testDir)\n                .map(Path::getFileName)\n                .map(Path::toString)\n                .sorted()\n                .collect(Collectors.toList());\n        assertEquals(expectedFiles, resultFiles);\n    }\n\n    @Test\n    public void testNoPngFiles() throws IOException {\n        // Test handling of directories with no PNG files\n        List<String> filenames = Arrays.asList(\"file1.txt\", \"file2.jpg\");\n        createPngFiles(filenames);\n\n        renameFiles(testDir.toString());\n\n        List<String> expectedFiles = filenames;  // No changes expected\n        List<String> resultFiles = Files.list(testDir)\n                .map(Path::getFileName)\n                .map(Path::toString)\n                .sorted()\n                .collect(Collectors.toList());\n        assertEquals(expectedFiles, resultFiles);\n    }\n\n    @Test\n    public void testEmptyDirectory() throws IOException {\n        // Test handling of an empty directory\n        renameFiles(testDir.toString());\n\n        List<String> expectedFiles = Arrays.asList();  // No files to rename\n        List<String> resultFiles = Files.list(testDir)\n                .map(Path::getFileName)\n                .map(Path::toString)\n                .collect(Collectors.toList());\n        assertEquals(expectedFiles, resultFiles);\n    }\n\n    @Test\n    public void testFilesWithExistingNumbers() throws IOException {\n        // Test renaming files that already have numbers in their names\n        List<String> filenames = Arrays.asList(\"file001.png\", \"file002.png\", \"file003.png\");\n        createPngFiles(filenames);\n\n        renameFiles(testDir.toString());\n\n        List<String> expectedFiles = Arrays.asList(\"file001001.png\", \"file002001.png\", \"file003001.png\");\n        List<String> resultFiles = Files.list(testDir)\n                .map(Path::getFileName)\n                .map(Path::toString)\n                .sorted()\n                .collect(Collectors.toList());\n        assertEquals(expectedFiles, resultFiles);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Renames PNG files in a specified directory by appending a sequence number to each file.\n * The files are sorted alphabetically, and each base name is assigned sequential numbers.\n * For example:\n *   If the directory contains three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\",\n *   after renaming, the PNG files will be \"image1001.png\", \"image2001.png\", \"image3001.png\".\n *\n * @param directory The path to the directory containing PNG files to be renamed.\n */\npublic static void renameFiles(String directory) {\n\n },package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 76, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Write a function to process a given multi-line string. The function should calculate the minimum indentation of all lines in the string and remove that indentation from each line, eliminating the extra indentation. Make sure that the relative indentation of the string is preserved.", "language_version_list": {"python": {"code_signature": "def remove_common_indentation(multiline_text: str) -> str:\n    \"\"\"\n    Removes the common leading indentation from each line in a given multi-line string,\n    preserving the relative indentation of the text.\n\n    Args:\n        multiline_text (str): The input string containing multiple lines.\n\n    Returns:\n        str: The sanitized string with common leading indentation removed.\n    \"\"\"", "test_code": "import unittest\n\nclass TestRemoveCommonIndentation(unittest.TestCase):\n\n    def test_empty_string(self):\n        # Testing edge case with an empty string\n        self.assertEqual(remove_common_indentation(\"\"), \"\", \"Should return an empty string\")\n\n    def test_single_line_string(self):\n        # Testing a single line with no indentation\n        self.assertEqual(remove_common_indentation(\"No indentation here\"), \"No indentation here\", \"Should return the same string as input\")\n\n    def test_multiple_lines_with_uniform_indentation(self):\n        # Testing basic logic with uniform indentation across multiple lines\n        input_text = \"    Line one\\n    Line two\\n    Line three\"\n        expected_output = \"Line one\\nLine two\\nLine three\"\n        self.assertEqual(remove_common_indentation(input_text), expected_output, \"Should remove common leading indentation\")\n\n    def test_multiple_lines_with_mixed_indentation(self):\n        # Testing lines with mixed indentation levels\n        input_text = \"  Line one\\n  Line two\\n  Line three\"\n        expected_output = \"Line one\\nLine two\\nLine three\"\n        self.assertEqual(remove_common_indentation(input_text), expected_output, \"Should remove the minimum common indentation\")\n\n", "prompt": "please write a python function , the function signature as below def remove_common_indentation(multiline_text: str) -> str:\n    \"\"\"\n    Removes the common leading indentation from each line in a given multi-line string,\n    preserving the relative indentation of the text.\n\n    Args:\n        multiline_text (str): The input string containing multiple lines.\n\n    Returns:\n        str: The sanitized string with common leading indentation removed.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Removes the common leading indentation from each line in a given multi-line string,\n * preserving the relative indentation of the text.\n *\n * @param {string} multilineText - The input string containing multiple lines.\n * @returns {string} The sanitized string with common leading indentation removed.\n */\nfunction removeCommonIndentation(multilineText) {}", "test_code": "describe('TestRemoveCommonIndentation', () => {\n    it('should return an empty string for an empty input', () => {\n        // Testing edge case with an empty string\n        expect(removeCommonIndentation(\"\")).toEqual(\"\");\n    });\n\n    it('should return the same string as input for a single line with no indentation', () => {\n        // Testing a single line with no indentation\n        expect(removeCommonIndentation(\"No indentation here\")).toEqual(\"No indentation here\");\n    });\n\n    it('should remove common leading indentation for multiple lines with uniform indentation', () => {\n        // Testing basic logic with uniform indentation across multiple lines\n        const inputText = \"    Line one\\n    Line two\\n    Line three\";\n        const expectedOutput = \"Line one\\nLine two\\nLine three\";\n        expect(removeCommonIndentation(inputText)).toEqual(expectedOutput);\n    });\n\n    it('should remove the minimum common indentation for lines with mixed indentation', () => {\n        // Testing lines with mixed indentation levels\n        const inputText = \"  Line one\\n  Line two\\n  Line three\";\n        const expectedOutput = \"Line one\\nLine two\\nLine three\";\n        expect(removeCommonIndentation(inputText)).toEqual(expectedOutput);\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Removes the common leading indentation from each line in a given multi-line string,\n * preserving the relative indentation of the text.\n *\n * @param {string} multilineText - The input string containing multiple lines.\n * @returns {string} The sanitized string with common leading indentation removed.\n */\nfunction removeCommonIndentation(multilineText) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Removes the common leading indentation from each line in a given multi-line string,\n * preserving the relative indentation of the text.\n *\n * @param {string} multilineText - The input string containing multiple lines.\n * @returns {string} The sanitized string with common leading indentation removed.\n */\nfunction removeCommonIndentation(multilineText: string): string {}", "test_code": "describe('TestRemoveCommonIndentation', () => {\n    it('should return an empty string for an empty input', () => {\n        // Testing edge case with an empty string\n        expect(removeCommonIndentation(\"\")).toBe(\"\");\n    });\n\n    it('should return the same string for a single line with no indentation', () => {\n        // Testing a single line with no indentation\n        const inputText = \"No indentation here\";\n        const expectedOutput = \"No indentation here\";\n        expect(removeCommonIndentation(inputText)).toBe(expectedOutput);\n    });\n\n    it('should remove common leading indentation for multiple lines with uniform indentation', () => {\n        // Testing basic logic with uniform indentation across multiple lines\n        const inputText = \"    Line one\\n    Line two\\n    Line three\";\n        const expectedOutput = \"Line one\\nLine two\\nLine three\";\n        expect(removeCommonIndentation(inputText)).toBe(expectedOutput);\n    });\n\n    it('should remove the minimum common indentation for lines with mixed indentation', () => {\n        // Testing lines with mixed indentation levels\n        const inputText = \"  Line one\\n  Line two\\n  Line three\";\n        const expectedOutput = \"Line one\\nLine two\\nLine three\";\n        expect(removeCommonIndentation(inputText)).toBe(expectedOutput);\n    });\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Removes the common leading indentation from each line in a given multi-line string,\n * preserving the relative indentation of the text.\n *\n * @param {string} multilineText - The input string containing multiple lines.\n * @returns {string} The sanitized string with common leading indentation removed.\n */\nfunction removeCommonIndentation(multilineText: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n* @brief Removes the common leading indentation from each line in a given multi-line string,\n* preserving the relative indentation of the text.\n*\n* @param multiline_text The input string containing multiple lines.\n* @return The sanitized string with common leading indentation removed.\n*/\nstd::string remove_common_indentation(const std::string& multiline_text) {}", "test_code": "TEST_CASE(\"Test remove_common_indentation function\", \"[remove_common_indentation]\") {\n    SECTION(\"test_empty_string\") {\n        // Testing edge case with an empty string\n        CHECK(remove_common_indentation(\"\") == \"\");\n    }\n\n    SECTION(\"test_single_line_string\") {\n        // Testing a single line with no indentation\n        CHECK(remove_common_indentation(\"No indentation here\") == \"No indentation here\");\n    }\n\n    SECTION(\"test_multiple_lines_with_uniform_indentation\") {\n        // Testing basic logic with uniform indentation across multiple lines\n        std::string input_text = \"    Line one\\n    Line two\\n    Line three\";\n        std::string expected_output = \"Line one\\nLine two\\nLine three\";\n        CHECK(remove_common_indentation(input_text) == expected_output);\n    }\n\n    SECTION(\"test_multiple_lines_with_mixed_indentation\") {\n        // Testing lines with mixed indentation levels\n        std::string input_text = \"  Line one\\n  Line two\\n  Line three\";\n        std::string expected_output = \"Line one\\nLine two\\nLine three\";\n        CHECK(remove_common_indentation(input_text) == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n* @brief Removes the common leading indentation from each line in a given multi-line string,\n* preserving the relative indentation of the text.\n*\n* @param multiline_text The input string containing multiple lines.\n* @return The sanitized string with common leading indentation removed.\n*/\nstd::string remove_common_indentation(const std::string& multiline_text) {}", "addition_info": ""}, "java": {"code_signature": "/**\n* Removes the common leading indentation from each line in a given multi-line string,\n* preserving the relative indentation of the text.\n*\n* @param multilineText The input string containing multiple lines.\n* @return The sanitized string with common leading indentation removed.\n*/\npublic static String removeCommonIndentation(String multilineText) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static junit.framework.TestCase.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    /**\n     * Tests the edge case with an empty string.\n     */\n    @Test\n    public void testEmptyString() {\n        // Testing edge case with an empty string\n        assertEquals(\"Should return an empty string\", \"\", removeCommonIndentation(\"\"));\n    }\n\n    /**\n     * Tests a single line with no indentation.\n     */\n    @Test\n    public void testSingleLineString() {\n        // Testing a single line with no indentation\n        assertEquals(\"Should return the same string as input\", \"No indentation here\", removeCommonIndentation(\"No indentation here\"));\n    }\n\n    /**\n     * Tests basic logic with uniform indentation across multiple lines.\n     */\n    @Test\n    public void testMultipleLinesWithUniformIndentation() {\n        // Testing basic logic with uniform indentation across multiple lines\n        String inputText = \"    Line one\\n    Line two\\n    Line three\";\n        String expectedOutput = \"Line one\\nLine two\\nLine three\";\n        assertEquals(\"Should remove common leading indentation\", expectedOutput, removeCommonIndentation(inputText));\n    }\n\n    /**\n     * Tests lines with mixed indentation levels.\n     */\n    @Test\n    public void testMultipleLinesWithMixedIndentation() {\n        // Testing lines with mixed indentation levels\n        String inputText = \"  Line one\\n  Line two\\n  Line three\";\n        String expectedOutput = \"Line one\\nLine two\\nLine three\";\n        assertEquals(\"Should remove the minimum common indentation\", expectedOutput, removeCommonIndentation(inputText));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n* Removes the common leading indentation from each line in a given multi-line string,\n* preserving the relative indentation of the text.\n*\n* @param multilineText The input string containing multiple lines.\n* @return The sanitized string with common leading indentation removed.\n*/\npublic static String removeCommonIndentation(String multilineText) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 77, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Formats the given timestamp (mtime) as a string, according to the specified format (the default format is '%a %b %d %I:%M:%S %p %z %Y'), and uses the system's local time zone.", "language_version_list": {"python": {"code_signature": "from typing import Optional\n\n\ndef format_timestamp_to_string(timestamp: float, date_format: Optional[str] = '%a %b %d %I:%M:%S %p %z %Y') -> str:\n    \"\"\"\n    Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n\n    Args:\n        timestamp (float): The time value representing the seconds since the epoch.\n        date_format (Optional[str]): The format string to use for formatting the timestamp.\n                                     Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n\n    Returns:\n        str: The formatted date and time string.\n    \"\"\"\n", "test_code": "import unittest\nfrom typing import Optional\n\nclass TestFormatTimestampToString(unittest.TestCase):\n    def test_basic_functionality(self):\n        \"\"\"Test basic functionality with a known timestamp.\"\"\"\n        timestamp = 1655364000.0  # Corresponds to Thu Jun 16 12:00:00 PM UTC 2022\n        # Assuming the local timezone is UTC\n        expected_date_str = 'Thu Jun 16 03:20:00 PM +0800 2022'\n        self.assertEqual(format_timestamp_to_string(timestamp), expected_date_str, \"Should correctly format the timestamp\")\n\n    def test_default_format(self):\n        \"\"\"Test using the default format string.\"\"\"\n        timestamp = 1655364000.0\n        expected_date_str = 'Thu Jun 16 03:20:00 PM +0800 2022'\n        self.assertEqual(format_timestamp_to_string(timestamp), expected_date_str, \"Default format should match the expected date string\")\n\n    def test_custom_format(self):\n        \"\"\"Test with a custom format string.\"\"\"\n        timestamp = 1655364000.0\n        custom_format = '%Y-%m-%d %H:%M:%S'\n        expected_date_str = '2022-06-16 15:20:00'\n        self.assertEqual(format_timestamp_to_string(timestamp, custom_format), expected_date_str, \"Should correctly format the timestamp using the custom format\")\n\n\n    def test_edge_case_boundary_value(self):\n        \"\"\"Test with an edge case timestamp (e.g., Unix epoch start).\"\"\"\n        timestamp = 0.0  # Unix epoch start\n        expected_date_str = 'Thu Jan 01 08:00:00 AM +0800 1970'\n        self.assertEqual(format_timestamp_to_string(timestamp), expected_date_str, \"Should correctly format the Unix epoch start time\")", "prompt": "please write a python function , the function signature as below from typing import Optional\n\n\ndef format_timestamp_to_string(timestamp: float, date_format: Optional[str] = '%a %b %d %I:%M:%S %p %z %Y') -> str:\n    \"\"\"\n    Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n\n    Args:\n        timestamp (float): The time value representing the seconds since the epoch.\n        date_format (Optional[str]): The format string to use for formatting the timestamp.\n                                     Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n\n    Returns:\n        str: The formatted date and time string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n *\n * @param {number} timestamp - The time value representing the seconds since the epoch.\n * @param {string} [dateFormat='%a %b %d %I:%M:%S %p %z %Y'] - The format string to use for formatting the timestamp.\n *                                                          Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n * @returns {string} - The formatted date and time string.\n */\nfunction formatTimestampToString(timestamp, dateFormat = '%a %b %d %I:%M:%S %p %z %Y') {}", "test_code": "describe('formatTimestampToString', () => {\n    it('test basic functionality with a known timestamp', () => {\n        const timestamp = 1655364000.0; // Corresponds to Thu Jun 16 12:00:00 PM UTC 2022\n        const expectedDateStr = 'Thu Jun 16 03:20:00 PM +0800 2022';\n        expect(formatTimestampToString(timestamp)).toBe(expectedDateStr);\n    });\n\n    it('test using the default format string', () => {\n        const timestamp = 1655364000.0;\n        const expectedDateStr = 'Thu Jun 16 03:20:00 PM +0800 2022';\n        expect(formatTimestampToString(timestamp)).toBe(expectedDateStr);\n    });\n\n    it('test with a custom format string', () => {\n        const timestamp = 1655364000.0;\n        const customFormat = 'yyyy-MM-dd HH:mm:ss';\n        const expectedDateStr = '2022-06-16 15:20:00';\n        expect(formatTimestampToString(timestamp, customFormat)).toBe(expectedDateStr);\n    });\n\n    it('test with an edge case timestamp (e.g., Unix epoch start)', () => {\n        const timestamp = 0.0; // Unix epoch start\n        const expectedDateStr = 'Thu Jan 01 08:00:00 AM +0800 1970';\n        expect(formatTimestampToString(timestamp)).toBe(expectedDateStr);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n *\n * @param {number} timestamp - The time value representing the seconds since the epoch.\n * @param {string} [dateFormat='%a %b %d %I:%M:%S %p %z %Y'] - The format string to use for formatting the timestamp.\n *                                                          Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n * @returns {string} - The formatted date and time string.\n */\nfunction formatTimestampToString(timestamp, dateFormat = '%a %b %d %I:%M:%S %p %z %Y') {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n *\n * @param timestamp - The time value representing the seconds since the epoch.\n * @param date_format - The format string to use for formatting the timestamp. Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n * @returns The formatted date and time string.\n */\nfunction formatTimestampToString(timestamp: number, date_format: string = 'ccc LLL d hh:mm:ss a zzzz yyyy'): string {}", "test_code": "describe('TestFormatTimestampToString', () => {\n    describe('test_basic_functionality', () => {\n        it('should correctly format the timestamp', () => {\n            const timestamp = 1655364000.0; // Corresponds to Thu Jun 16 12:00:00 PM UTC 2022\n            const expectedDateStr = 'Thu Jun 16 03:20:00 PM +0800 2022';\n            expect(formatTimestampToString(timestamp)).toBe(expectedDateStr);\n        });\n    });\n\n    describe('test_default_format', () => {\n        it('default format should match the expected date string', () => {\n            const timestamp = 1655364000.0;\n            const expectedDateStr = 'Thu Jun 16 03:20:00 PM +0800 2022';\n            expect(formatTimestampToString(timestamp)).toBe(expectedDateStr);\n        });\n    });\n\n    describe('test_custom_format', () => {\n        it('should correctly format the timestamp using the custom format', () => {\n            const timestamp = 1655364000.0;\n            const customFormat = 'yyyy-MM-dd HH:mm:ss';\n            const expectedDateStr = '2022-06-16 15:20:00';\n            expect(formatTimestampToString(timestamp, customFormat)).toBe(expectedDateStr);\n        });\n    });\n\n    describe('test_edge_case_boundary_value', () => {\n        it('should correctly format the Unix epoch start time', () => {\n            const timestamp = 0.0; // Unix epoch start\n            const expectedDateStr = 'Thu Jan 01 08:00:00 AM +0800 1970';\n            expect(formatTimestampToString(timestamp)).toBe(expectedDateStr);\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n *\n * @param timestamp - The time value representing the seconds since the epoch.\n * @param date_format - The format string to use for formatting the timestamp. Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n * @returns The formatted date and time string.\n */\nfunction formatTimestampToString(timestamp: number, date_format: string = 'ccc LLL d hh:mm:ss a zzzz yyyy'): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n* @brief Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n*\n* @param timestamp The time value representing the seconds since the epoch.\n* @param date_format The format string to use for formatting the timestamp.\n*                    Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n* @return The formatted date and time string.\n*/\nstd::string format_timestamp_to_string(double timestamp, std::optional<std::string> date_format = std::nullopt) {}\n", "test_code": "TEST_CASE(\"TestFormatTimestampToString\", \"[format_timestamp_to_string]\") {\n    SECTION(\"test_basic_functionality\") {\n        double timestamp = 1655364000.0; // Corresponds to Thu Jun 16 12:00:00 PM UTC 2022\n        std::string expected_date_str = \"Thu Jun 16 03:20:00 PM +0800 2022\";\n        REQUIRE(format_timestamp_to_string(timestamp) == expected_date_str);\n    }\n\n    SECTION(\"test_default_format\") {\n        double timestamp = 1655364000.0;\n        std::string expected_date_str = \"Thu Jun 16 03:20:00 PM +0800 2022\";\n        REQUIRE(format_timestamp_to_string(timestamp) == expected_date_str);\n    }\n\n    SECTION(\"test_custom_format\") {\n        double timestamp = 1655364000.0;\n        std::string custom_format = \"%Y-%m-%d %H:%M:%S\";\n        std::string expected_date_str = \"2022-06-16 15:20:00\";\n        REQUIRE(format_timestamp_to_string(timestamp, custom_format) == expected_date_str);\n    }\n\n    SECTION(\"test_edge_case_boundary_value\") {\n        double timestamp = 0.0; // Unix epoch start\n        std::string expected_date_str = \"Thu Jan 01 08:00:00 AM +0800 1970\";\n        REQUIRE(format_timestamp_to_string(timestamp) == expected_date_str);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n* @brief Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n*\n* @param timestamp The time value representing the seconds since the epoch.\n* @param date_format The format string to use for formatting the timestamp.\n*                    Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n* @return The formatted date and time string.\n*/\nstd::string format_timestamp_to_string(double timestamp, std::optional<std::string> date_format = std::nullopt) {}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n *\n * @param timestamp   The time value representing the seconds since the epoch.\n * @param dateFormat  The format string to use for formatting the timestamp.\n *                    Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n * @return            The formatted date and time string.\n */\npublic static String formatTimestampToString(long timestamp, String dateFormat) {\n\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.time.ZoneId;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    private static final ZoneId LOCAL_TZ = ZoneId.of(\"Asia/Singapore\"); // Assuming Asia/Singapore as the local timezone\n\n    @Test\n    public void testBasicFunctionality() {\n        long timestamp = 1655364000L; // Corresponds to Thu Jun 16 12:00:00 PM UTC 2022\n        String expectedDateStr = \"Thu Jun 16 03:20:00 PM +0800 2022\";\n        assertEquals(\"Should correctly format the timestamp\", expectedDateStr, formatTimestampToString(timestamp, null));\n    }\n\n    @Test\n    public void testDefaultFormat() {\n        long timestamp = 1655364000L;\n        String expectedDateStr = \"Thu Jun 16 03:20:00 PM +0800 2022\";\n        assertEquals(\"Default format should match the expected date string\", expectedDateStr, formatTimestampToString(timestamp, null));\n    }\n\n    @Test\n    public void testCustomFormat() {\n        long timestamp = 1655364000L;\n        String customFormat = \"%Y-%m-%d %H:%M:%S\";\n        String expectedDateStr = \"2022-06-16 15:20:00\";\n        assertEquals(\"Should correctly format the timestamp using the custom format\", expectedDateStr, formatTimestampToString(timestamp, customFormat));\n    }\n\n    @Test\n    public void testEdgeCaseBoundaryValue() {\n        long timestamp = 0L; // Unix epoch start\n        String expectedDateStr = \"Thu Jan 01 08:00:00 AM +0800 1970\";\n        assertEquals(\"Should correctly format the Unix epoch start time\", expectedDateStr, formatTimestampToString(timestamp, null));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n *\n * @param timestamp   The time value representing the seconds since the epoch.\n * @param dateFormat  The format string to use for formatting the timestamp.\n *                    Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n * @return            The formatted date and time string.\n */\npublic static String formatTimestampToString(long timestamp, String dateFormat) {\n\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 78, "code_type": "method", "original_language": "python", "question_type": "Framework and library", "summary": "Convert Euler angles (roll, pitch, yaw) to a rotation matrix.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef euler_to_rotation_matrix(roll: float, pitch: float, yaw: float) -> np.array:\n    \"\"\"\n    Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n\n    Args:\n        roll (float): Rotation around the x-axis in degrees.\n        pitch (float): Rotation around the y-axis in degrees.\n        yaw (float): Rotation around the z-axis in degrees.\n\n    Returns:\n        np.array: A 3x3 rotation matrix.\n    \"\"\"\n", "test_code": "import unittest\nimport numpy as np\n\nclass TestEulerToRotationMatrix(unittest.TestCase):\n    def test_zero_rotation(self):\n        # Test with zero rotation for all axes\n        R = euler_to_rotation_matrix(0, 0, 0)\n        np.testing.assert_array_almost_equal(R, np.identity(3))\n\n    def test_rotation_about_x(self):\n        # Test rotation about the x-axis\n        R = euler_to_rotation_matrix(90, 0, 0)\n        expected = np.array([\n            [1, 0, 0],\n            [0, 0, -1],\n            [0, 1, 0]\n        ])\n        np.testing.assert_array_almost_equal(R, expected)\n\n    def test_rotation_about_y(self):\n        # Test rotation about the y-axis\n        R = euler_to_rotation_matrix(0, 90, 0)\n        expected = np.array([\n            [0, 0, 1],\n            [0, 1, 0],\n            [-1, 0, 0]\n        ])\n        np.testing.assert_array_almost_equal(R, expected)\n\n    def test_rotation_about_z(self):\n        # Test rotation about the z-axis\n        R = euler_to_rotation_matrix(0, 0, 90)\n        expected = np.array([\n            [0, -1, 0],\n            [1, 0, 0],\n            [0, 0, 1]\n        ])\n        np.testing.assert_array_almost_equal(R, expected)\n\n    def test_combined_rotation(self):\n        # Test combined rotation\n        R = euler_to_rotation_matrix(30, 45, 60)\n        # Expected model_answer_result manually calculated or verified via a reliable source\n        expected = np.array([[ 0.35355339, -0.5732233,   0.73919892], [ 0.61237244 , 0.73919892,  0.28033009], [-0.70710678 , 0.35355339,  0.61237244]])\n        np.testing.assert_array_almost_equal(R, np.array(expected), decimal=5)", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef euler_to_rotation_matrix(roll: float, pitch: float, yaw: float) -> np.array:\n    \"\"\"\n    Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n\n    Args:\n        roll (float): Rotation around the x-axis in degrees.\n        pitch (float): Rotation around the y-axis in degrees.\n        yaw (float): Rotation around the z-axis in degrees.\n\n    Returns:\n        np.array: A 3x3 rotation matrix.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n *\n * @param {number} roll - Rotation around the x-axis in degrees.\n * @param {number} pitch - Rotation around the y-axis in degrees.\n * @param {number} yaw - Rotation around the z-axis in degrees.\n *\n * @returns {Array<Array<number>>} A 3x3 rotation matrix.\n */\nfunction eulerToRotationMatrix(roll, pitch, yaw) {}\n", "test_code": "describe('TestEulerToRotationMatrix', () => {\n    it('test_zero_rotation', () => {\n        // Test with zero rotation for all axes\n        const R = eulerToRotationMatrix(0, 0, 0);\n        expect(R).toEqual([\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ]);\n    });\n\n    it('test_rotation_about_x', () => {\n        // Test rotation about the x-axis\n        const R = eulerToRotationMatrix(90, 0, 0);\n        const expected = [\n            [1, 0, 0],\n            [0, 0, -1],\n            [0, 1, 0]\n        ];\n        expect(R).toEqual(expected);\n    });\n\n    it('test_rotation_about_y', () => {\n        // Test rotation about the y-axis\n        const R = eulerToRotationMatrix(0, 90, 0);\n        const expected = [\n            [0, 0, 1],\n            [0, 1, 0],\n            [-1, 0, 0]\n        ];\n        expect(R).toEqual(expected);\n    });\n\n    it('test_rotation_about_z', () => {\n        // Test rotation about the z-axis\n        const R = eulerToRotationMatrix(0, 0, 90);\n        const expected = [\n            [0, -1, 0],\n            [1, 0, 0],\n            [0, 0, 1]\n        ];\n        expect(R).toEqual(expected);\n    });\n\n    it('test_combined_rotation', () => {\n        // Test combined rotation\n        const R = eulerToRotationMatrix(30, 45, 60);\n        const expected = [\n            [0.35355339, -0.5732233, 0.73919892],\n            [0.61237244, 0.73919892, 0.28033009],\n            [-0.70710678, 0.35355339, 0.61237244]\n        ];\n        expect(R).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n *\n * @param {number} roll - Rotation around the x-axis in degrees.\n * @param {number} pitch - Rotation around the y-axis in degrees.\n * @param {number} yaw - Rotation around the z-axis in degrees.\n *\n * @returns {Array<Array<number>>} A 3x3 rotation matrix.\n */\nfunction eulerToRotationMatrix(roll, pitch, yaw) {}\n", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n *\n * @param roll - Rotation around the x-axis in degrees.\n * @param pitch - Rotation around the y-axis in degrees.\n * @param yaw - Rotation around the z-axis in degrees.\n * @returns A 3x3 rotation matrix.\n */\nfunction eulerToRotationMatrix(roll: number, pitch: number, yaw: number): Matrix {}", "test_code": "describe('TestEulerToRotationMatrix', () => {\n    it('test_zero_rotation', () => {\n        // Test with zero rotation for all axes\n        const R = eulerToRotationMatrix(0, 0, 0);\n        const identityMatrix = math.matrix([\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ]);\n        expect(math.equal(R, identityMatrix)).toBe(true);\n    });\n\n    it('test_rotation_about_x', () => {\n        // Test rotation about the x-axis\n        const R = eulerToRotationMatrix(90, 0, 0);\n        const expected = math.matrix([\n            [1, 0, 0],\n            [0, 0, -1],\n            [0, 1, 0]\n        ]);\n        expect(math.equal(R, expected)).toBe(true);\n    });\n\n    it('test_rotation_about_y', () => {\n        // Test rotation about the y-axis\n        const R = eulerToRotationMatrix(0, 90, 0);\n        const expected = math.matrix([\n            [0, 0, 1],\n            [0, 1, 0],\n            [-1, 0, 0]\n        ]);\n        expect(math.equal(R, expected)).toBe(true);\n    });\n\n    it('test_rotation_about_z', () => {\n        // Test rotation about the z-axis\n        const R = eulerToRotationMatrix(0, 0, 90);\n        const expected = math.matrix([\n            [0, -1, 0],\n            [1, 0, 0],\n            [0, 0, 1]\n        ]);\n        expect(math.equal(R, expected)).toBe(true);\n    });\n\n    it('test_combined_rotation', () => {\n        // Test combined rotation\n        const R = eulerToRotationMatrix(30, 45, 60);\n        const expected = math.matrix([\n            [0.35355339, -0.5732233, 0.73919892],\n            [0.61237244, 0.73919892, 0.28033009],\n            [-0.70710678, 0.35355339, 0.61237244]\n        ]);\n        expect(math.equal(R, expected, { relTol: 1e-5 })).toBe(true);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n *\n * @param roll - Rotation around the x-axis in degrees.\n * @param pitch - Rotation around the y-axis in degrees.\n * @param yaw - Rotation around the z-axis in degrees.\n * @returns A 3x3 rotation matrix.\n */\nfunction eulerToRotationMatrix(roll: number, pitch: number, yaw: number): Matrix {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n* Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n*\n* @param roll The rotation around the x-axis in degrees.\n* @param pitch The rotation around the y-axis in degrees.\n* @param yaw The rotation around the z-axis in degrees.\n*\n* @return A 3x3 rotation matrix.\n*/\nMatrix3f euler_to_rotation_matrix(float roll, float pitch, float yaw) {}", "test_code": "TEST_CASE(\"Test Euler to Rotation Matrix\") {\n    SECTION(\"Zero Rotation\") {\n        // Test with zero rotation for all axes\n        Matrix3f R = euler_to_rotation_matrix(0, 0, 0);\n        Matrix3f expected = Matrix3f::Identity();\n        REQUIRE_THAT(R, Catch::Approx(expected).epsilon(1e-6));\n    }\n\n    SECTION(\"Rotation About X\") {\n        // Test rotation about the x-axis\n        Matrix3f R = euler_to_rotation_matrix(90, 0, 0);\n        Matrix3f expected = Matrix3f::Zero();\n        expected << 1, 0, 0,\n                    0, 0, -1,\n                    0, 1, 0;\n        REQUIRE_THAT(R, Catch::Approx(expected).epsilon(1e-6));\n    }\n\n    SECTION(\"Rotation About Y\") {\n        // Test rotation about the y-axis\n        Matrix3f R = euler_to_rotation_matrix(0, 90, 0);\n        Matrix3f expected = Matrix3f::Zero();\n        expected << 0, 0, 1,\n                    0, 1, 0,\n                    -1, 0, 0;\n        REQUIRE_THAT(R, Catch::Approx(expected).epsilon(1e-6));\n    }\n\n    SECTION(\"Rotation About Z\") {\n        // Test rotation about the z-axis\n        Matrix3f R = euler_to_rotation_matrix(0, 0, 90);\n        Matrix3f expected = Matrix3f::Zero();\n        expected << 0, -1, 0,\n                    1, 0, 0,\n                    0, 0, 1;\n        REQUIRE_THAT(R, Catch::Approx(expected).epsilon(1e-6));\n    }\n\n    SECTION(\"Combined Rotation\") {\n        // Test combined rotation\n        Matrix3f R = euler_to_rotation_matrix(30, 45, 60);\n        Matrix3f expected = Matrix3f::Zero();\n        expected << 0.35355339, -0.5732233, 0.73919892,\n                    0.61237244, 0.73919892, 0.28033009,\n                    -0.70710678, 0.35355339, 0.61237244;\n        REQUIRE_THAT(R, Catch::Approx(expected).epsilon(1e-5));\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n* Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n*\n* @param roll The rotation around the x-axis in degrees.\n* @param pitch The rotation around the y-axis in degrees.\n* @param yaw The rotation around the z-axis in degrees.\n*\n* @return A 3x3 rotation matrix.\n*/\nMatrix3f euler_to_rotation_matrix(float roll, float pitch, float yaw) {}", "addition_info": ""}, "java": {"code_signature": "public static double[][] eulerToRotationMatrix(double roll, double pitch, double yaw) {\n    /**\n     * Converts Euler angles (roll, pitch, yaw) to a rotation matrix.\n     *\n     * @param roll  the rotation around the x-axis in degrees\n     * @param pitch the rotation around the y-axis in degrees\n     * @param yaw   the rotation around the z-axis in degrees\n     * @return a 3x3 rotation matrix\n     */\n}\n\nprivate static double[][] multiplyMatrices(double[][] a, double[][] b) {\n     /**\n     * Multiplies two matrices.\n     *\n     * @param a the first matrix\n     * @param b the second matrix\n     * @return the result of multiplying the two matrices\n     */\n}", "test_code": "import org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\npublic class Tester {\n\n    @Test\n    public void testZeroRotation() {\n        // Test with zero rotation for all axes\n        double[][] R = eulerToRotationMatrix(0, 0, 0);\n        double[][] expected = {\n            {1, 0, 0},\n            {0, 1, 0},\n            {0, 0, 1}\n        };\n        assertArrayEquals(expected, R, 1e-6);\n    }\n\n    @Test\n    public void testRotationAboutX() {\n        // Test rotation about the x-axis\n        double[][] R = eulerToRotationMatrix(90, 0, 0);\n        double[][] expected = {\n            {1, 0, 0},\n            {0, 0, -1},\n            {0, 1, 0}\n        };\n        assertArrayEquals(expected, R, 1e-6);\n    }\n\n    @Test\n    public void testRotationAboutY() {\n        // Test rotation about the y-axis\n        double[][] R = eulerToRotationMatrix(90, 0, 0);\n        double[][] expected = {\n            {0, 0, 1},\n            {0, 1, 0},\n            {-1, 0, 0}\n        };\n        assertArrayEquals(expected, R, 1e-6);\n    }\n\n    @Test\n    public void testRotationAboutZ() {\n        // Test rotation about the z-axis\n        double[][] R = eulerToRotationMatrix(0, 0, 90);\n        double[][] expected = {\n            {0, -1, 0},\n            {1, 0, 0},\n            {0, 0, 1}\n        };\n        assertArrayEquals(expected, R, 1e-6);\n    }\n\n    @Test\n    public void testCombinedRotation() {\n        // Test combined rotation\n        double[][] R = eulerToRotationMatrix(30, 45, 60);\n        double[][] expected = {\n            {0.35355339, -0.5732233, 0.73919892},\n            {0.61237244, 0.73919892, 0.28033009},\n            {-0.70710678, 0.35355339, 0.61237244}\n        };\n        assertArrayEquals(expected, R, 1e-5);\n    }\n}", "prompt": "please write a java function , the function signature as below public static double[][] eulerToRotationMatrix(double roll, double pitch, double yaw) {\n    /**\n     * Converts Euler angles (roll, pitch, yaw) to a rotation matrix.\n     *\n     * @param roll  the rotation around the x-axis in degrees\n     * @param pitch the rotation around the y-axis in degrees\n     * @param yaw   the rotation around the z-axis in degrees\n     * @return a 3x3 rotation matrix\n     */\n}\n\nprivate static double[][] multiplyMatrices(double[][] a, double[][] b) {\n     /**\n     * Multiplies two matrices.\n     *\n     * @param a the first matrix\n     * @param b the second matrix\n     * @return the result of multiplying the two matrices\n     */\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 79, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Generates a string based on the entered start and end dates. If the start date and end date are in the same month, only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you enter the start date and end date as,\"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\"\n", "language_version_list": {"python": {"code_signature": "def generate_date_range_string(start_date: str, end_date: str) -> str:\n    \"\"\"\n    Generates a string based on the entered start and end dates. If the start date and end date are in the same month, only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you enter the start date and end date as,\"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n\n    For example:\n        input:\n            start_date: 2023-08-01\n            end_date: 2023-08-15\n        output:\n            August 1 to 15, 2023\n\n    Args:\n        start_date (str): The start date in 'YYYY-MM-DD' format.\n        end_date (str): The end date in 'YYYY-MM-DD' format.\n\n    Returns:\n        str: A string representing the date range in a human-readable format.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestDateRangeString(unittest.TestCase):\n    def test_same_month(self):\n        # Test dates within the same month\n        result = generate_date_range_string(\"2023-08-01\", \"2023-08-15\")\n        self.assertEqual(result, \"August 1 to 15, 2023\")\n\n    def test_same_month_star_end(self):\n        # Test dates within the same month\n        result = generate_date_range_string(\"2023-08-01\", \"2023-08-31\")\n        self.assertEqual(result, \"August 1 to 31, 2023\")\n\n    def test_different_months_same_year(self):\n        # Test dates across different months within the same year\n        result = generate_date_range_string(\"2023-08-30\", \"2023-09-05\")\n        self.assertEqual(result, \"August 30, 2023 to September 5, 2023\")\n\n    def test_different_years(self):\n        # Test dates across different years\n        result = generate_date_range_string(\"2023-12-30\", \"2024-01-02\")\n        self.assertEqual(result, \"December 30, 2023 to January 2, 2024\")\n", "prompt": "please write a python function , the function signature as below def generate_date_range_string(start_date: str, end_date: str) -> str:\n    \"\"\"\n    Generates a string based on the entered start and end dates. If the start date and end date are in the same month, only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you enter the start date and end date as,\"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n\n    For example:\n        input:\n            start_date: 2023-08-01\n            end_date: 2023-08-15\n        output:\n            August 1 to 15, 2023\n\n    Args:\n        start_date (str): The start date in 'YYYY-MM-DD' format.\n        end_date (str): The end date in 'YYYY-MM-DD' format.\n\n    Returns:\n        str: A string representing the date range in a human-readable format.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Generates a string based on the entered start and end dates. If the start date and end date are in the same month,\n * only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you\n * enter the start date and end date as \"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n *\n * Example:\n *   Input:\n *     start_date: 2023-08-01\n *     end_date: 2023-08-15\n *   Output:\n *     August 1 to 15, 2023\n *\n * @param {string} start_date - The start date in 'YYYY-MM-DD' format.\n * @param {string} end_date - The end date in 'YYYY-MM-DD' format.\n * @returns {string} A string representing the date range in a human-readable format.\n * @throws {Error} If the start_date or end_date are not in the correct format or if start_date is after end_date.\n */\nfunction dateRangeString(start_date, end_date) {}", "test_code": "describe('TestDateRangeString', () => {\n    it('should correctly format dates within the same month', () => {\n        const result = dateRangeString(\"2023-08-01\", \"2023-08-15\");\n        expect(result).toBe(\"August 1 to 15, 2023\");\n    });\n\n    it('should correctly format dates within the same month (start to end)', () => {\n        const result = dateRangeString(\"2023-08-01\", \"2023-08-31\");\n        expect(result).toBe(\"August 1 to 31, 2023\");\n    });\n\n    it('should correctly format dates across different months within the same year', () => {\n        const result = dateRangeString(\"2023-08-30\", \"2023-09-05\");\n        expect(result).toBe(\"August 30, 2023 to September 5, 2023\");\n    });\n\n    it('should correctly format dates across different years', () => {\n        const result = dateRangeString(\"2023-12-30\", \"2024-01-02\");\n        expect(result).toBe(\"December 30, 2023 to January 2, 2024\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Generates a string based on the entered start and end dates. If the start date and end date are in the same month,\n * only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you\n * enter the start date and end date as \"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n *\n * Example:\n *   Input:\n *     start_date: 2023-08-01\n *     end_date: 2023-08-15\n *   Output:\n *     August 1 to 15, 2023\n *\n * @param {string} start_date - The start date in 'YYYY-MM-DD' format.\n * @param {string} end_date - The end date in 'YYYY-MM-DD' format.\n * @returns {string} A string representing the date range in a human-readable format.\n * @throws {Error} If the start_date or end_date are not in the correct format or if start_date is after end_date.\n */\nfunction dateRangeString(start_date, end_date) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Generates a string based on the entered start and end dates. If the start date and end date are in the same month,\n * only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you\n * enter the start date and end date as \"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n *\n * Example:\n *   Input:\n *     start_date: 2023-08-01\n *     end_date: 2023-08-15\n *   Output:\n *     August 1 to 15, 2023\n *\n * @param startDate - The start date in 'YYYY-MM-DD' format.\n * @param endDate - The end date in 'YYYY-MM-DD' format.\n * @returns A string representing the date range in a human-readable format.\n * @throws {Error} If the startDate or endDate are not in the correct format or if startDate is after endDate.\n */\nfunction dateRangeString(startDate: string, endDate: string): string {}", "test_code": "describe('TestDateRangeString', () => {\n    it('should generate the correct date range for dates within the same month', () => {\n      const result = dateRangeString('2023-08-01', '2023-08-15');\n      expect(result).toBe('August 1 to 15, 2023');\n    });\n  \n    it('should generate the correct date range for dates spanning the entire month', () => {\n      const result = dateRangeString('2023-08-01', '2023-08-31');\n      expect(result).toBe('August 1 to 31, 2023');\n    });\n  \n    it('should generate the correct date range for dates across different months within the same year', () => {\n      const result = dateRangeString('2023-08-30', '2023-09-05');\n      expect(result).toBe('August 30, 2023 to September 5, 2023');\n    });\n  \n    it('should generate the correct date range for dates across different years', () => {\n      const result = dateRangeString('2023-12-30', '2024-01-02');\n      expect(result).toBe('December 30, 2023 to January 2, 2024');\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Generates a string based on the entered start and end dates. If the start date and end date are in the same month,\n * only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you\n * enter the start date and end date as \"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n *\n * Example:\n *   Input:\n *     start_date: 2023-08-01\n *     end_date: 2023-08-15\n *   Output:\n *     August 1 to 15, 2023\n *\n * @param startDate - The start date in 'YYYY-MM-DD' format.\n * @param endDate - The end date in 'YYYY-MM-DD' format.\n * @returns A string representing the date range in a human-readable format.\n * @throws {Error} If the startDate or endDate are not in the correct format or if startDate is after endDate.\n */\nfunction dateRangeString(startDate: string, endDate: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n* @brief Generates a string based on the entered start and end dates. If the start date and end date are in the same month,\n* only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you\n* enter the start date and end date as \"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n*\n* Example:\n*     Input:\n*         start_date: 2023-08-01\n*         end_date: 2023-08-15\n*     Output:\n*         August 1 to 15, 2023\n*\n* @param start_date The start date in 'YYYY-MM-DD' format.\n* @param end_date The end date in 'YYYY-MM-DD' format.\n* @return A string representing the date range in a human-readable format.\n*/\nstd::string date_range_string(const std::string& start_date, const std::string& end_date) {}", "test_code": "TEST_CASE(\"Test date_range_string function\") {\n    SECTION(\"Test dates within the same month\") {\n        std::string result = date_range_string(\"2023-08-01\", \"2023-08-15\");\n        REQUIRE(result == \"August 1 to 15, 2023\");\n    }\n\n    SECTION(\"Test dates within the same month (start and end)\") {\n        std::string result = date_range_string(\"2023-08-01\", \"2023-08-31\");\n        REQUIRE(result == \"August 1 to 31, 2023\");\n    }\n\n    SECTION(\"Test dates across different months within the same year\") {\n        std::string result = date_range_string(\"2023-08-30\", \"2023-09-05\");\n        REQUIRE(result == \"August 30, 2023 to September 5, 2023\");\n    }\n\n    SECTION(\"Test dates across different years\") {\n        std::string result = date_range_string(\"2023-12-30\", \"2024-01-02\");\n        REQUIRE(result == \"December 30, 2023 to January 2, 2024\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n* @brief Generates a string based on the entered start and end dates. If the start date and end date are in the same month,\n* only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you\n* enter the start date and end date as \"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n*\n* Example:\n*     Input:\n*         start_date: 2023-08-01\n*         end_date: 2023-08-15\n*     Output:\n*         August 1 to 15, 2023\n*\n* @param start_date The start date in 'YYYY-MM-DD' format.\n* @param end_date The end date in 'YYYY-MM-DD' format.\n* @return A string representing the date range in a human-readable format.\n*/\nstd::string date_range_string(const std::string& start_date, const std::string& end_date) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Generates a string based on the entered start and end dates. If the start date and end date are in the same month,\n * only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you\n * enter the start date and end date as \"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n *\n * Example:\n *     Input:\n *         start_date: 2023-08-01\n *         end_date: 2023-08-15\n *     Output:\n *         August 1 to 15, 2023\n *\n * @param startDate The start date in 'YYYY-MM-DD' format.\n * @param endDate The end date in 'YYYY-MM-DD' format.\n * @return A string representing the date range in a human-readable format.\n * @throws IllegalArgumentException If the startDate or endDate are not in the correct format or if startDate is after endDate.\n */\npublic static String dateRangeString(String startDate, String endDate) throws IllegalArgumentException {\n\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\nimport java.text.ParseException;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testSameMonth() throws ParseException {\n        // Test dates within the same month\n        String result = dateRangeString(\"2023-08-01\", \"2023-08-15\");\n        assertEquals(\"August 1 to 15, 2023\", result);\n    }\n\n    @Test\n    public void testSameMonthStartToEnd() throws ParseException {\n        // Test dates within the same month\n        String result = dateRangeString(\"2023-08-01\", \"2023-08-31\");\n        assertEquals(\"August 1 to 31, 2023\", result);\n    }\n\n    @Test\n    public void testDifferentMonthsSameYear() throws ParseException {\n        // Test dates across different months within the same year\n        String result = dateRangeString(\"2023-08-30\", \"2023-09-05\");\n        assertEquals(\"August 30, 2023 to September 5, 2023\", result);\n    }\n\n    @Test\n    public void testDifferentYears() throws ParseException {\n        // Test dates across different years\n        String result = dateRangeString(\"2023-12-30\", \"2024-01-02\");\n        assertEquals(\"December 30, 2023 to January 2, 2024\", result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Generates a string based on the entered start and end dates. If the start date and end date are in the same month,\n * only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you\n * enter the start date and end date as \"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n *\n * Example:\n *     Input:\n *         start_date: 2023-08-01\n *         end_date: 2023-08-15\n *     Output:\n *         August 1 to 15, 2023\n *\n * @param startDate The start date in 'YYYY-MM-DD' format.\n * @param endDate The end date in 'YYYY-MM-DD' format.\n * @return A string representing the date range in a human-readable format.\n * @throws IllegalArgumentException If the startDate or endDate are not in the correct format or if startDate is after endDate.\n */\npublic static String dateRangeString(String startDate, String endDate) throws IllegalArgumentException {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 80, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "remove illegal characters from strings and handle spaces and empty characters to make the modified string comply with windows file name rules\n", "language_version_list": {"python": {"code_signature": "def sanitize_filename(filename: str) -> str:\n    \"\"\"\n    remove illegal characters from windows file path string\n\n    Args:\n        filename (str): The original filename string to be sanitized.\n\n    Returns:\n        str: A sanitized string that is safe to use as a Windows filename.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSanitizeFilename(unittest.TestCase):\n\n    def test_valid_filename(self):\n        self.assertEqual(sanitize_filename(\"valid_filename.txt\"), \"valid_filename.txt\")\n\n    def test_illegal_characters(self):\n        self.assertEqual(sanitize_filename(\"invalid<filename>.txt\"), \"invalid_filename_.txt\")\n        self.assertEqual(sanitize_filename(\"file/name:with*illegal|chars?.txt\"), \"file_name_with_illegal_chars_.txt\")\n\n\n    def test_long_filename(self):\n        long_filename = \"a\" * 300 + \".txt\"\n        sanitized_filename = sanitize_filename(long_filename)\n        self.assertEqual(len(sanitized_filename), 255)\n        self.assertEqual(sanitized_filename, \"a\" * 255)\n\n    def test_empty_filename(self):\n        self.assertEqual(sanitize_filename(\"\"), \"\")", "prompt": "please write a python function , the function signature as below def sanitize_filename(filename: str) -> str:\n    \"\"\"\n    remove illegal characters from windows file path string\n\n    Args:\n        filename (str): The original filename string to be sanitized.\n\n    Returns:\n        str: A sanitized string that is safe to use as a Windows filename.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Remove illegal characters from a Windows file path string.\n *\n * @param {string} filename - The original filename string to be sanitized.\n * @returns {string} A sanitized string that is safe to use as a Windows filename.\n */\nfunction sanitizeFilename(filename) {}", "test_code": "describe('TestSanitizeFilename', () => {\n    it('should handle valid filenames correctly', () => {\n        expect(sanitizeFilename(\"valid_filename.txt\")).toBe(\"valid_filename.txt\");\n    });\n\n    it('should sanitize filenames with illegal characters', () => {\n        expect(sanitizeFilename(\"invalid<filename>.txt\")).toBe(\"invalid_filename_.txt\");\n        expect(sanitizeFilename(\"file/name:with*illegal|chars?.txt\")).toBe(\"file_name_with_illegal_chars_.txt\");\n    });\n\n    it('should truncate long filenames to 255 characters', () => {\n        const longFilename = \"a\".repeat(300) + \".txt\";\n        const sanitizedFilename = sanitizeFilename(longFilename);\n        expect(sanitizedFilename.length).toBe(255);\n        expect(sanitizedFilename).toBe(\"a\".repeat(255));\n    });\n\n    it('should handle empty filenames correctly', () => {\n        expect(sanitizeFilename(\"\")).toBe(\"\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Remove illegal characters from a Windows file path string.\n *\n * @param {string} filename - The original filename string to be sanitized.\n * @returns {string} A sanitized string that is safe to use as a Windows filename.\n */\nfunction sanitizeFilename(filename) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Remove illegal characters from a Windows file path string.\n * \n * @param {string} filename - The original filename string to be sanitized.\n * @returns {string} A sanitized string that is safe to use as a Windows filename.\n */\nfunction sanitizeFilename(filename: string): string {}", "test_code": "describe('TestSanitizeFilename', () => {\n    describe('test_valid_filename', () => {\n        it('should handle valid filenames correctly', () => {\n            expect(sanitizeFilename(\"valid_filename.txt\")).toBe(\"valid_filename.txt\");\n        });\n    });\n\n    describe('test_illegal_characters', () => {\n        it('should sanitize filenames with illegal characters', () => {\n            expect(sanitizeFilename(\"invalid<filename>.txt\")).toBe(\"invalid_filename_.txt\");\n            expect(sanitizeFilename(\"file/name:with*illegal|chars?.txt\")).toBe(\"file_name_with_illegal_chars_.txt\");\n        });\n    });\n\n    describe('test_long_filename', () => {\n        it('should truncate long filenames to 255 characters', () => {\n            const longFilename = \"a\".repeat(300) + \".txt\";\n            const sanitizedFilename = sanitizeFilename(longFilename);\n            expect(sanitizedFilename.length).toBe(255);\n            expect(sanitizedFilename).toBe(\"a\".repeat(255));\n        });\n    });\n\n    describe('test_empty_filename', () => {\n        it('should handle empty filenames correctly', () => {\n            expect(sanitizeFilename(\"\")).toBe(\"\");\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Remove illegal characters from a Windows file path string.\n * \n * @param {string} filename - The original filename string to be sanitized.\n * @returns {string} A sanitized string that is safe to use as a Windows filename.\n */\nfunction sanitizeFilename(filename: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "\n/**\n* @brief Remove illegal characters from Windows file path string.\n*\n* This function sanitizes a given filename by replacing illegal characters\n* with underscores and limiting the length of the filename to ensure it is\n* safe to use as a Windows filename.\n*\n* @param filename The original filename string to be sanitized.\n* @return A sanitized string that is safe to use as a Windows filename.\n*/\nstd::string sanitize_filename(const std::string& filename) {}", "test_code": "TEST_CASE(\"TestSanitizeFilename\", \"[sanitize_filename]\") {\n    SECTION(\"test_valid_filename\") {\n        REQUIRE(sanitize_filename(\"valid_filename.txt\") == \"valid_filename.txt\");\n    }\n\n    SECTION(\"test_illegal_characters\") {\n        REQUIRE(sanitize_filename(\"invalid<filename>.txt\") == \"invalid_filename_.txt\");\n        REQUIRE(sanitize_filename(\"file/name:with*illegal|chars?.txt\") == \"file_name_with_illegal_chars_.txt\");\n    }\n\n    SECTION(\"test_long_filename\") {\n        std::string long_filename = std::string(300, 'a') + \".txt\";\n        std::string sanitized_filename = sanitize_filename(long_filename);\n        REQUIRE(sanitized_filename.length() == 255);\n        REQUIRE(sanitized_filename == std::string(255, 'a'));\n    }\n\n    SECTION(\"test_empty_filename\") {\n        REQUIRE(sanitize_filename(\"\") == \"\");\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below \n/**\n* @brief Remove illegal characters from Windows file path string.\n*\n* This function sanitizes a given filename by replacing illegal characters\n* with underscores and limiting the length of the filename to ensure it is\n* safe to use as a Windows filename.\n*\n* @param filename The original filename string to be sanitized.\n* @return A sanitized string that is safe to use as a Windows filename.\n*/\nstd::string sanitize_filename(const std::string& filename) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Removes illegal characters from a Windows file path string.\n *\n * @param filename The original filename string to be sanitized.\n * @return A sanitized string that is safe to use as a Windows filename.\n */\npublic static String sanitizeFilename(String filename) {}", "test_code": "package org.real.temp;\n\nimport static junit.framework.TestCase.assertEquals;\nimport static org.real.temp.Answer.*;\nimport org.junit.Test;\npublic class Tester {\n\n    @Test\n    public void testValidFilename() {\n        assertEquals(\"valid_filename.txt\", sanitizeFilename(\"valid_filename.txt\"));\n    }\n\n    @Test\n    public void testIllegalCharacters() {\n        assertEquals(\"invalid_filename_.txt\", sanitizeFilename(\"invalid<filename>.txt\"));\n        assertEquals(\"file_name_with_illegal_chars_.txt\", sanitizeFilename(\"file/name:with*illegal|chars?.txt\"));\n    }\n\n    @Test\n    public void testLongFilename() {\n        String longFilename = \"a\".repeat(300) + \".txt\";\n        String sanitizedFilename = sanitizeFilename(longFilename);\n        assertEquals(255, sanitizedFilename.length());\n        assertEquals(\"a\".repeat(255), sanitizedFilename);\n    }\n\n    @Test\n    public void testEmptyFilename() {\n        assertEquals(\"\", sanitizeFilename(\"\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Removes illegal characters from a Windows file path string.\n *\n * @param filename The original filename string to be sanitized.\n * @return A sanitized string that is safe to use as a Windows filename.\n */\npublic static String sanitizeFilename(String filename) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 81, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Takes a list of numbers as input and finds the element in it that is closest to a specified target number.", "language_version_list": {"python": {"code_signature": "from typing import List, Union\n\n\ndef find_closest_element(target: Union[int, float], elements: List[Union[int, float]]) -> Union[int, float]:\n    \"\"\"\n    Finds and returns the element from the given list that is closest to the specified target value.\n\n    Args:\n        target (Union[int, float]): The target number to which we want to find the closest element.\n        elements (List[Union[int, float]]): A list of numerical elements from which the closest element is to be found.\n\n    Returns:\n        Union[int, float]: The element from the list that is closest to the target value.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFindClosestElement(unittest.TestCase):\n\n    def test_basic_functionality(self):\n        self.assertEqual(find_closest_element(5, [1, 3, 7, 8, 9]), 3,\n                         \"Should return 3 as it is the first closest element to 5\")\n\n    def test_exact_match(self):\n        self.assertEqual(find_closest_element(7, [1, 3, 7, 8, 9]), 7,\n                         \"Should return 7 as it exactly matches the target\")\n\n    def test_multiple_closest_values(self):\n        self.assertEqual(find_closest_element(5, [4, 6, 8, 9]), 4,\n                         \"Should return 4 as it is the first closest element to 5\")\n\n    def test_float_values(self):\n        self.assertEqual(find_closest_element(5.5, [1.1, 3.3, 7.7, 8.8]), 3.3,\n                         \"Should return 3.3 as it is the first closest element to 5.5\")\n", "prompt": "please write a python function , the function signature as below from typing import List, Union\n\n\ndef find_closest_element(target: Union[int, float], elements: List[Union[int, float]]) -> Union[int, float]:\n    \"\"\"\n    Finds and returns the element from the given list that is closest to the specified target value.\n\n    Args:\n        target (Union[int, float]): The target number to which we want to find the closest element.\n        elements (List[Union[int, float]]): A list of numerical elements from which the closest element is to be found.\n\n    Returns:\n        Union[int, float]: The element from the list that is closest to the target value.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Finds and returns the element from the given array that is closest to the specified target value.\n *\n * @param {number} target - The target number to which we want to find the closest element.\n * @param {Array<number>} elements - An array of numerical elements from which the closest element is to be found.\n * @returns {number} The element from the array that is closest to the target value.\n */\nfunction findClosestElement(target, elements) {}", "test_code": "describe('TestFindClosestElement', () => {\n    it('should return 3 as it is the first closest element to 5', () => {\n        expect(findClosestElement(5, [1, 3, 7, 8, 9])).toBe(3);\n    });\n\n    it('should return 7 as it exactly matches the target', () => {\n        expect(findClosestElement(7, [1, 3, 7, 8, 9])).toBe(7);\n    });\n\n    it('should return 4 as it is the first closest element to 5', () => {\n        expect(findClosestElement(5, [4, 6, 8, 9])).toBe(4);\n    });\n\n    it('should return 3.3 as it is the first closest element to 5.5', () => {\n        expect(findClosestElement(5.5, [1.1, 3.3, 7.7, 8.8])).toBe(3.3);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Finds and returns the element from the given array that is closest to the specified target value.\n *\n * @param {number} target - The target number to which we want to find the closest element.\n * @param {Array<number>} elements - An array of numerical elements from which the closest element is to be found.\n * @returns {number} The element from the array that is closest to the target value.\n */\nfunction findClosestElement(target, elements) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Finds and returns the element from the given array that is closest to the specified target value.\n *\n * @param target - The target number to which we want to find the closest element.\n * @param elements - An array of numerical elements from which the closest element is to be found.\n * @returns The element from the array that is closest to the target value.\n */\nfunction findClosestElement(target: number, elements: number[]): number {}", "test_code": "describe('TestFindClosestElement', () => {\n  it('should return 3 as it is the first closest element to 5', () => {\n    expect(findClosestElement(5, [1, 3, 7, 8, 9])).toBe(3);\n  });\n\n  it('should return 7 as it exactly matches the target', () => {\n    expect(findClosestElement(7, [1, 3, 7, 8, 9])).toBe(7);\n  });\n\n  it('should return 4 as it is the first closest element to 5', () => {\n    expect(findClosestElement(5, [4, 6, 8, 9])).toBe(4);\n  });\n\n  it('should return 3.3 as it is the first closest element to 5.5', () => {\n    expect(findClosestElement(5.5, [1.1, 3.3, 7.7, 8.8])).toBe(3.3);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Finds and returns the element from the given array that is closest to the specified target value.\n *\n * @param target - The target number to which we want to find the closest element.\n * @param elements - An array of numerical elements from which the closest element is to be found.\n * @returns The element from the array that is closest to the target value.\n */\nfunction findClosestElement(target: number, elements: number[]): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds and returns the element from the given list that is closest to the specified target value.\n *\n * @param target The target number to which we want to find the closest element.\n * @param elements A list of numerical elements from which the closest element is to be found.\n * @return The element from the list that is closest to the target value.\n */\ndouble find_closest_element(double target, const std::vector<double>& elements) {}", "test_code": "TEST_CASE(\"TestFindClosestElement\", \"[find_closest_element]\") {\n    SECTION(\"test_basic_functionality\") {\n        REQUIRE(find_closest_element(5, {1, 3, 7, 8, 9}) == Approx(3));\n        CHECK(\"Should return 3 as it is the first closest element to 5\");\n    }\n\n    SECTION(\"test_exact_match\") {\n        REQUIRE(find_closest_element(7, {1, 3, 7, 8, 9}) == Approx(7));\n        CHECK(\"Should return 7 as it exactly matches the target\");\n    }\n\n    SECTION(\"test_multiple_closest_values\") {\n        REQUIRE(find_closest_element(5, {4, 6, 8, 9}) == Approx(4));\n        CHECK(\"Should return 4 as it is the first closest element to 5\");\n    }\n\n    SECTION(\"test_float_values\") {\n        REQUIRE(find_closest_element(5.5, {1.1, 3.3, 7.7, 8.8}) == Approx(3.3));\n        CHECK(\"Should return 3.3 as it is the first closest element to 5.5\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds and returns the element from the given list that is closest to the specified target value.\n *\n * @param target The target number to which we want to find the closest element.\n * @param elements A list of numerical elements from which the closest element is to be found.\n * @return The element from the list that is closest to the target value.\n */\ndouble find_closest_element(double target, const std::vector<double>& elements) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds and returns the element from the given list that is closest to the specified target value.\n *\n * @param target   The target number to which we want to find the closest element.\n * @param elements A list of numerical elements from which the closest element is to be found.\n * @return The element from the list that is closest to the target value.\n */\npublic static Number findClosestElement(Number target, List<Number> elements) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.List;\n\nimport static junit.framework.TestCase.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    /**\n     * Tests basic functionality of the findClosestElement method.\n     */\n    @Test\n    public void testBasicFunctionality() {\n        assertEquals(\"Should return 3 as it is the first closest element to 5\",\n                3, findClosestElement(5, List.of(1, 3, 7, 8, 9)).intValue());\n    }\n\n    /**\n     * Tests the exact match scenario for the findClosestElement method.\n     */\n    @Test\n    public void testExactMatch() {\n        assertEquals(\"Should return 7 as it exactly matches the target\",\n                7, findClosestElement(7, List.of(1, 3, 7, 8, 9)).intValue());\n    }\n\n    /**\n     * Tests multiple closest values scenario for the findClosestElement method.\n     */\n    @Test\n    public void testMultipleClosestValues() {\n        assertEquals(\"Should return 4 as it is the first closest element to 5\",\n                4, findClosestElement(5, List.of(4, 6, 8, 9)).intValue());\n    }\n\n    /**\n     * Tests float values scenario for the findClosestElement method.\n     */\n    @Test\n    public void testFloatValues() {\n        assertEquals(\"Should return 3.3 as it is the first closest element to 5.5\",\n                3.3, findClosestElement(5.5, List.of(1.1, 3.3, 7.7, 8.8)).doubleValue(), 0.001);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Finds and returns the element from the given list that is closest to the specified target value.\n *\n * @param target   The target number to which we want to find the closest element.\n * @param elements A list of numerical elements from which the closest element is to be found.\n * @return The element from the list that is closest to the target value.\n */\npublic static Number findClosestElement(Number target, List<Number> elements) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 82, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "find the unique cycles from the graph, classify them according to cycle size, and return a dictionary, the key of which is the cycle size, and the value is a list of cycles of corresponding size. The function also provides an option to filter out loops that visit the same node multiple times and ensure that each loop contains at least three nodes\n", "language_version_list": {"python": {"code_signature": "from typing import List, Dict, Any\n\nimport networkx as nx\n\n\nclass Graph:\n    def __init__(self, edges):\n        self.graph = nx.DiGraph(edges)\n\n    def cycles_by_size(self, filter_repeat_nodes=True) -> Dict[Any, List]:\n        \"\"\"\n        Finds all unique cycles in the graph that are larger than size 2, optionally filtering out cycles with repeated nodes.\n\n        Args:\n            filter_repeat_nodes (bool): If True, filters out cycles where any node appears more than once.\n\n        Returns:\n            Dict[int, List[nx.Graph]]: A dictionary mapping each cycle size to a list of subgraph objects representing\n                each unique cycle of that size.\n        \"\"\"\n", "test_code": "import unittest\nfrom collections import defaultdict\n\n\nclass TestGraphCycles(unittest.TestCase):\n    def test_empty_graph(self):\n        g = Graph([])\n        self.assertEqual(g.cycles_by_size(), defaultdict(list),\n                         \"Failed: Expected an empty defaultdict for an empty graph.\")\n\n    def test_graph_no_cycles(self):\n        g = Graph([(1, 2), (2, 3)])\n        self.assertEqual(g.cycles_by_size(), defaultdict(list),\n                         \"Failed: Expected an empty defaultdict for a graph with no cycles.\")\n\n    def test_simple_cycles(self):\n        g = Graph([(1, 2), (2, 3), (3, 1)])\n        results = g.cycles_by_size()\n        self.assertEqual(len(results[3]), 1, \"Failed: Expected one cycle of length 3.\")\n        self.assertIn(list(results[3][0].nodes()), [[1, 2, 3]], \"Failed: Expected cycle nodes to match.\")\n\n    def test_multiple_cycles(self):\n        g = Graph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1)])\n        results = g.cycles_by_size()\n        self.assertEqual(len(results[3]), 1, \"Failed: Expected one cycle of length 3.\")\n        self.assertEqual(len(results[4]), 1, \"Failed: Expected one cycle of length 4.\")\n", "prompt": "please write a python function , the function signature as below from typing import List, Dict, Any\n\nimport networkx as nx\n\n\nclass Graph:\n    def __init__(self, edges):\n        self.graph = nx.DiGraph(edges)\n\n    def cycles_by_size(self, filter_repeat_nodes=True) -> Dict[Any, List]:\n        \"\"\"\n        Finds all unique cycles in the graph that are larger than size 2, optionally filtering out cycles with repeated nodes.\n\n        Args:\n            filter_repeat_nodes (bool): If True, filters out cycles where any node appears more than once.\n\n        Returns:\n            Dict[int, List[nx.Graph]]: A dictionary mapping each cycle size to a list of subgraph objects representing\n                each unique cycle of that size.\n        \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 83, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Shift the list elements right one position in a loop: move the first element of the list to the end, and move the remaining elements forward one position in turn.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef rotate_list_elements(elements: List[int]) -> List[int]:\n    \"\"\"\n    Rotate the elements of the list to the left by one position. The first element\n    is moved to the end of the list, and all other elements are shifted one position to the left.\n\n    Args:\n        elements (List[int]): A list of integers to be rotated.\n\n    Returns:\n        List[int]: The rotated list with elements shifted to the left by one position.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestRotateListElements(unittest.TestCase):\n\n    def test_basic_rotation(self):\n        self.assertEqual(rotate_list_elements([1, 2, 3, 4]), [2, 3, 4, 1], \"Should rotate the list elements correctly\")\n\n    def test_single_element_list(self):\n        self.assertEqual(rotate_list_elements([10]), [10], \"Single element list should remain unchanged\")\n\n    def test_empty_list(self):\n        self.assertEqual(rotate_list_elements([]), [], \"Empty list should remain unchanged\")\n\n    def test_two_element_list(self):\n        self.assertEqual(rotate_list_elements([5, 9]), [9, 5], \"Should correctly rotate a two-element list\")\n\n    def test_large_list(self):\n        large_list = list(range(1, 1001))\n        rotated_list = rotate_list_elements(large_list)\n        self.assertEqual(rotated_list, list(range(2, 1001)) + [1], \"Should correctly rotate a large list\")\n\n\n\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef rotate_list_elements(elements: List[int]) -> List[int]:\n    \"\"\"\n    Rotate the elements of the list to the left by one position. The first element\n    is moved to the end of the list, and all other elements are shifted one position to the left.\n\n    Args:\n        elements (List[int]): A list of integers to be rotated.\n\n    Returns:\n        List[int]: The rotated list with elements shifted to the left by one position.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Rotate the elements of the array to the left by one position. The first element\n * is moved to the end of the array, and all other elements are shifted one position to the left.\n *\n * @param {number[]} elements - An array of numbers to be rotated.\n * @returns {number[]} The rotated array with elements shifted to the left by one position.\n */\nfunction rotateListElements(elements) {}", "test_code": "describe('TestRotateListElements', () => {\n    it('should rotate the list elements correctly', () => {\n        expect(rotateListElements([1, 2, 3, 4])).toEqual([2, 3, 4, 1]);\n    });\n\n    it('single element list should remain unchanged', () => {\n        expect(rotateListElements([10])).toEqual([10]);\n    });\n\n    it('empty list should remain unchanged', () => {\n        expect(rotateListElements([])).toEqual([]);\n    });\n\n    it('should correctly rotate a two-element list', () => {\n        expect(rotateListElements([5, 9])).toEqual([9, 5]);\n    });\n\n    it('should correctly rotate a large list', () => {\n        const largeList = Array.from({ length: 1000 }, (_, i) => i + 1);\n        const rotatedList = rotateListElements(largeList);\n        expect(rotatedList).toEqual(Array.from({ length: 999 }, (_, i) => i + 2).concat([1]));\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Rotate the elements of the array to the left by one position. The first element\n * is moved to the end of the array, and all other elements are shifted one position to the left.\n *\n * @param {number[]} elements - An array of numbers to be rotated.\n * @returns {number[]} The rotated array with elements shifted to the left by one position.\n */\nfunction rotateListElements(elements) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Rotate the elements of the list to the left by one position. The first element\n * is moved to the end of the list, and all other elements are shifted one position to the left.\n *\n * @param elements - An array of numbers to be rotated.\n * @returns The rotated array with elements shifted to the left by one position.\n */\nfunction rotateListElements(elements: number[]): number[] {}", "test_code": "describe('TestRotateListElements', () => {\n    it('should rotate the list elements correctly', () => {\n        expect(rotateListElements([1, 2, 3, 4])).toEqual([2, 3, 4, 1]);\n    });\n\n    it('single element list should remain unchanged', () => {\n        expect(rotateListElements([10])).toEqual([10]);\n    });\n\n    it('empty list should remain unchanged', () => {\n        expect(rotateListElements([])).toEqual([]);\n    });\n\n    it('should correctly rotate a two-element list', () => {\n        expect(rotateListElements([5, 9])).toEqual([9, 5]);\n    });\n\n    it('should correctly rotate a large list', () => {\n        const largeList = Array.from({ length: 1000 }, (_, i) => i + 1);\n        const rotatedList = rotateListElements(largeList);\n        expect(rotatedList).toEqual(Array.from({ length: 999 }, (_, i) => i + 2).concat([1]));\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Rotate the elements of the list to the left by one position. The first element\n * is moved to the end of the list, and all other elements are shifted one position to the left.\n *\n * @param elements - An array of numbers to be rotated.\n * @returns The rotated array with elements shifted to the left by one position.\n */\nfunction rotateListElements(elements: number[]): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Rotates the elements of a vector to the left by one position.\n *\n * This function takes a vector of integers and shifts all elements one position \n * to the left. The first element is moved to the end of the vector.\n *\n * @param elements A vector of integers to be rotated.\n * @return A new vector with elements rotated to the left by one position.\n */\nstd::vector<int> rotate_vector_elements(const std::vector<int>& elements) {}", "test_code": "TEST_CASE(\"Test Rotate Vector Elements\", \"[rotate_vector_elements]\") {\n    SECTION(\"Basic Rotation\") {\n        REQUIRE(rotate_vector_elements({1, 2, 3, 4}) == std::vector<int>({2, 3, 4, 1}));\n    }\n\n    SECTION(\"Single Element List\") {\n        REQUIRE(rotate_vector_elements({10}) == std::vector<int>({10}));\n    }\n\n    SECTION(\"Empty List\") {\n        REQUIRE(rotate_vector_elements({}) == std::vector<int>({}));\n    }\n\n    SECTION(\"Two Element List\") {\n        REQUIRE(rotate_vector_elements({5, 9}) == std::vector<int>({9, 5}));\n    }\n\n    SECTION(\"Large List\") {\n        std::vector<int> large_list;\n        for (int i = 1; i <= 1000; ++i) {\n            large_list.push_back(i);\n        }\n        std::vector<int> rotated_list = rotate_vector_elements(large_list);\n        std::vector<int> expected_list(large_list.begin() + 1, large_list.end());\n        expected_list.push_back(large_list.front());\n\n        REQUIRE(rotated_list == expected_list);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Rotates the elements of a vector to the left by one position.\n *\n * This function takes a vector of integers and shifts all elements one position \n * to the left. The first element is moved to the end of the vector.\n *\n * @param elements A vector of integers to be rotated.\n * @return A new vector with elements rotated to the left by one position.\n */\nstd::vector<int> rotate_vector_elements(const std::vector<int>& elements) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Rotate the elements of the list to the left by one position. The first element\n * is moved to the end of the list, and all other elements are shifted one position to the left.\n *\n * @param elements A list of integers to be rotated.\n * @return The rotated list with elements shifted to the left by one position.\n */\npublic static List<Integer> rotateListElements(List<Integer> elements) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static junit.framework.TestCase.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testBasicRotation() {\n        List<Integer> originalList = new ArrayList<>(Arrays.asList(1, 2, 3, 4));\n        List<Integer> expectedList = new ArrayList<>(Arrays.asList(2, 3, 4, 1));\n        assertEquals(\"Should rotate the list elements correctly\", expectedList, rotateListElements(originalList));\n    }\n\n    @Test\n    public void testSingleElementList() {\n        List<Integer> originalList = new ArrayList<>(Arrays.asList(10));\n        List<Integer> expectedList = new ArrayList<>(Arrays.asList(10));\n        assertEquals(\"Single element list should remain unchanged\", expectedList, rotateListElements(originalList));\n    }\n\n    @Test\n    public void testEmptyList() {\n        List<Integer> originalList = new ArrayList<>();\n        List<Integer> expectedList = new ArrayList<>();\n        assertEquals(\"Empty list should remain unchanged\", expectedList, rotateListElements(originalList));\n    }\n\n    @Test\n    public void testTwoElementList() {\n        List<Integer> originalList = new ArrayList<>(Arrays.asList(5, 9));\n        List<Integer> expectedList = new ArrayList<>(Arrays.asList(9, 5));\n        assertEquals(\"Should correctly rotate a two-element list\", expectedList, rotateListElements(originalList));\n    }\n\n    @Test\n    public void testLargeList() {\n        List<Integer> largeList = new ArrayList<>();\n        for (int i = 1; i <= 1000; i++) {\n            largeList.add(i);\n        }\n        List<Integer> expectedList = new ArrayList<>(largeList.subList(1, largeList.size()));\n        expectedList.add(largeList.get(0));\n        assertEquals(\"Should correctly rotate a large list\", expectedList, rotateListElements(largeList));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Rotate the elements of the list to the left by one position. The first element\n * is moved to the end of the list, and all other elements are shifted one position to the left.\n *\n * @param elements A list of integers to be rotated.\n * @return The rotated list with elements shifted to the left by one position.\n */\npublic static List<Integer> rotateListElements(List<Integer> elements) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 84, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Write a function that takes two strings, s and t, and returns the smallest substring in s that contains all the characters in t. If there are multiple such substrings, return any one of them. If no such substring exists, return an empty string.", "language_version_list": {"python": {"code_signature": "from collections import Counter\nfrom typing import Optional\n\n\ndef find_min_window_substring(source: str, target: str) -> Optional[str]:\n    \"\"\"\n    Finds the smallest window in the source string that contains all characters of the target string.\n\n    Args:\n        source (str): The source string in which to search for the window.\n        target (str): The target string containing the characters to be matched.\n\n    Returns:\n        Optional[str]: The smallest window in the source string that contains all characters of the target string.\n                       Returns an empty string if no such window exists.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFindMinWindowSubstring(unittest.TestCase):\n\n    def test_empty_source_string(self):\n        # Test with an empty source string\n        self.assertEqual(find_min_window_substring(\"\", \"abc\"), \"\", \"Should return an empty string when source is empty\")\n\n    def test_empty_target_string(self):\n        # Test with an empty target string\n        self.assertEqual(find_min_window_substring(\"abc\", \"\"), \"\", \"Should return an empty string when target is empty\")\n\n    def test_no_valid_window(self):\n        # Test when there is no valid window\n        self.assertEqual(find_min_window_substring(\"abcdef\", \"xyz\"), \"\",\n                         \"Should return an empty string when no valid window exists\")\n\n    def test_exact_match_window(self):\n        # Test when the entire source string is the exact match\n        self.assertEqual(find_min_window_substring(\"abcd\", \"abcd\"), \"abcd\",\n                         \"Should return the entire string when it is an exact match\")\n\n    def test_minimal_valid_window(self):\n        # Test with a minimal valid window case\n        self.assertEqual(find_min_window_substring(\"ADOBECODEBANC\", \"ABC\"), \"BANC\",\n                         \"Should return 'BANC' as the smallest window containing all characters of 'ABC'\")\n\n\n", "prompt": "please write a python function , the function signature as below from collections import Counter\nfrom typing import Optional\n\n\ndef find_min_window_substring(source: str, target: str) -> Optional[str]:\n    \"\"\"\n    Finds the smallest window in the source string that contains all characters of the target string.\n\n    Args:\n        source (str): The source string in which to search for the window.\n        target (str): The target string containing the characters to be matched.\n\n    Returns:\n        Optional[str]: The smallest window in the source string that contains all characters of the target string.\n                       Returns an empty string if no such window exists.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Finds the smallest window in the source string that contains all characters of the target string.\n *\n * @param {string} source - The source string in which to search for the window.\n * @param {string} target - The target string containing the characters to be matched.\n * @returns {string} The smallest window in the source string that contains all characters of the target string.\n *                   Returns an empty string if no such window exists.\n */\nfunction findMinWindowSubstring(source, target) {}", "test_code": "describe('TestFindMinWindowSubstring', () => {\n    it('should return an empty string when source is empty', () => {\n        expect(findMinWindowSubstring(\"\", \"abc\")).toBe(\"\");\n    });\n\n    it('should return an empty string when target is empty', () => {\n        expect(findMinWindowSubstring(\"abc\", \"\")).toBe(\"\");\n    });\n\n    it('should return an empty string when no valid window exists', () => {\n        expect(findMinWindowSubstring(\"abcdef\", \"xyz\")).toBe(\"\");\n    });\n\n    it('should return the entire string when it is an exact match', () => {\n        expect(findMinWindowSubstring(\"abcd\", \"abcd\")).toBe(\"abcd\");\n    });\n\n    it('should return \"BANC\" as the smallest window containing all characters of \"ABC\"', () => {\n        expect(findMinWindowSubstring(\"ADOBECODEBANC\", \"ABC\")).toBe(\"BANC\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Finds the smallest window in the source string that contains all characters of the target string.\n *\n * @param {string} source - The source string in which to search for the window.\n * @param {string} target - The target string containing the characters to be matched.\n * @returns {string} The smallest window in the source string that contains all characters of the target string.\n *                   Returns an empty string if no such window exists.\n */\nfunction findMinWindowSubstring(source, target) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Finds the smallest window in the source string that contains all characters of the target string.\n *\n * @param source The source string in which to search for the window.\n * @param target The target string containing the characters to be matched.\n * @returns The smallest window in the source string that contains all characters of the target string.\n *          Returns an empty string if no such window exists.\n */\nfunction findMinWindowSubstring(source: string, target: string): string {}", "test_code": "describe('findMinWindowSubstring', () => {\n  it('should return an empty string when source is empty', () => {\n    expect(findMinWindowSubstring(\"\", \"abc\")).toBe(\"\");\n  });\n\n  it('should return an empty string when target is empty', () => {\n    expect(findMinWindowSubstring(\"abc\", \"\")).toBe(\"\");\n  });\n\n  it('should return an empty string when no valid window exists', () => {\n    expect(findMinWindowSubstring(\"abcdef\", \"xyz\")).toBe(\"\");\n  });\n\n  it('should return the entire string when it is an exact match', () => {\n    expect(findMinWindowSubstring(\"abcd\", \"abcd\")).toBe(\"abcd\");\n  });\n\n  it('should return BANC as the smallest window containing all characters of ABC', () => {\n    expect(findMinWindowSubstring(\"ADOBECODEBANC\", \"ABC\")).toBe(\"BANC\");\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Finds the smallest window in the source string that contains all characters of the target string.\n *\n * @param source The source string in which to search for the window.\n * @param target The target string containing the characters to be matched.\n * @returns The smallest window in the source string that contains all characters of the target string.\n *          Returns an empty string if no such window exists.\n */\nfunction findMinWindowSubstring(source: string, target: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds the smallest window in the source string that contains all characters of the target string.\n *\n * This function searches for the smallest substring in the source string that includes \n * all characters present in the target string.\n *\n * @param source The source string in which to search for the window.\n * @param target The target string containing the characters to be matched.\n * @return The smallest window in the source string that contains all characters of the target string.\n *         Returns an empty string if no such window exists.\n */\nstd::string find_min_window_substring(const std::string& source, const std::string& target) {}\n", "test_code": "TEST_CASE(\"Test find_min_window_substring\") {\n    SECTION(\"Empty source string\") {\n        REQUIRE(find_min_window_substring(\"\", \"abc\") == \"\");\n        // Should return an empty string when source is empty\n    }\n\n    SECTION(\"Empty target string\") {\n        REQUIRE(find_min_window_substring(\"abc\", \"\") == \"\");\n        // Should return an empty string when target is empty\n    }\n\n    SECTION(\"No valid window\") {\n        REQUIRE(find_min_window_substring(\"abcdef\", \"xyz\") == \"\");\n        // Should return an empty string when no valid window exists\n    }\n\n    SECTION(\"Exact match window\") {\n        REQUIRE(find_min_window_substring(\"abcd\", \"abcd\") == \"abcd\");\n        // Should return the entire string when it is an exact match\n    }\n\n    SECTION(\"Minimal valid window\") {\n        REQUIRE(find_min_window_substring(\"ADOBECODEBANC\", \"ABC\") == \"BANC\");\n        // Should return 'BANC' as the smallest window containing all characters of 'ABC'\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds the smallest window in the source string that contains all characters of the target string.\n *\n * This function searches for the smallest substring in the source string that includes \n * all characters present in the target string.\n *\n * @param source The source string in which to search for the window.\n * @param target The target string containing the characters to be matched.\n * @return The smallest window in the source string that contains all characters of the target string.\n *         Returns an empty string if no such window exists.\n */\nstd::string find_min_window_substring(const std::string& source, const std::string& target) {}\n", "addition_info": ""}, "java": {"code_signature": "    /**\n * Finds the smallest window in the source string that contains all characters of the target string.\n *\n * @param source The source string in which to search for the window.\n * @param target The target string containing the characters to be matched.\n * @return The smallest window in the source string that contains all characters of the target string.\n *         Returns an empty string if no such window exists.\n */\n public static String findMinWindowSubstring(String source, String target) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    /**\n     * Tests the method findMinWindowSubstring with an empty source string.\n     */\n    @Test\n    public void testEmptySourceString() {\n        // Test with an empty source string\n        assertEquals(\"Should return an empty string when source is empty\",\n                \"\",\n                findMinWindowSubstring(\"\", \"abc\"));\n    }\n\n    /**\n     * Tests the method findMinWindowSubstring with an empty target string.\n     */\n    @Test\n    public void testEmptyTargetString() {\n        // Test with an empty target string\n        assertEquals(\"Should return an empty string when target is empty\",\n                \"\",\n                findMinWindowSubstring(\"abc\", \"\"));\n    }\n\n    /**\n     * Tests the method findMinWindowSubstring when there is no valid window.\n     */\n    @Test\n    public void testNoValidWindow() {\n        // Test when there is no valid window\n        assertEquals(\"Should return an empty string when no valid window exists\",\n                \"\",\n                findMinWindowSubstring(\"abcdef\", \"xyz\"));\n    }\n\n    /**\n     * Tests the method findMinWindowSubstring when the entire source string is the exact match.\n     */\n    @Test\n    public void testExactMatchWindow() {\n        // Test when the entire source string is the exact match\n        assertEquals(\"Should return the entire string when it is an exact match\",\n                \"abcd\",\n                findMinWindowSubstring(\"abcd\", \"abcd\"));\n    }\n\n    /**\n     * Tests the method findMinWindowSubstring with a minimal valid window case.\n     */\n    @Test\n    public void testMinimalValidWindow() {\n        // Test with a minimal valid window case\n        assertEquals(\"Should return 'BANC' as the smallest window containing all characters of 'ABC'\",\n                \"BANC\",\n                findMinWindowSubstring(\"ADOBECODEBANC\", \"ABC\"));\n    }\n}", "prompt": "please write a java function , the function signature as below     /**\n * Finds the smallest window in the source string that contains all characters of the target string.\n *\n * @param source The source string in which to search for the window.\n * @param target The target string containing the characters to be matched.\n * @return The smallest window in the source string that contains all characters of the target string.\n *         Returns an empty string if no such window exists.\n */\n public static String findMinWindowSubstring(String source, String target) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 85, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Uses the first valid value in the specified column to fill the pandas dataframe with the missing value for that column", "language_version_list": {"python": {"code_signature": "import pandas\nimport pandas as pd\n\n\ndef fill_missing_with_first_valid(df: pandas.DataFrame, column_name: str) -> pd.DataFrame:\n    \"\"\"\n    Fills missing values in the specified column of the DataFrame with the first valid value in that column.\n    Args:\n        df (pandas.DataFrame): The pandas DataFrame.\n        column_name (str): The name of the column to fill missing values.\n\n    Returns:\n        pd.DataFrame: The DataFrame with missing values filled.\n    \"\"\"\n", "test_code": "import unittest\n\nimport pandas as pd\n\n\nclass TestFillMissingWithFirstValid(unittest.TestCase):\n\n    def test_basic_filling(self):\n        df = pd.DataFrame({'A': [1, None, 3, None], 'B': ['foo', 'bar', None, 'baz']})\n        result = fill_missing_with_first_valid(df, 'B')\n        expected = pd.DataFrame({'A': [1, None, 3, None], 'B': ['foo', 'bar', 'foo', 'baz']})\n        pd.testing.assert_frame_equal(result, expected)\n\n    def test_no_missing_values(self):\n        df = pd.DataFrame({'A': [1, 2, 3], 'B': ['foo', 'bar', 'baz']})\n        result = fill_missing_with_first_valid(df, 'B')\n        expected = pd.DataFrame({'A': [1, 2, 3], 'B': ['foo', 'bar', 'baz']})\n        pd.testing.assert_frame_equal(result, expected)\n\n\n    def test_single_valid_value(self):\n        df = pd.DataFrame({'A': [1, None, None, 4], 'B': [None, 'bar', None, None]})\n        result = fill_missing_with_first_valid(df, 'B')\n        expected = pd.DataFrame({'A': [1, None, None, 4], 'B': ['bar', 'bar', 'bar', 'bar']})\n        pd.testing.assert_frame_equal(result, expected)\n\n    def test_multiple_valid_values(self):\n        df = pd.DataFrame({'A': [1, None, 3, 4], 'B': [None, 'bar', 'foo', None]})\n        result = fill_missing_with_first_valid(df, 'B')\n        expected = pd.DataFrame({'A': [1, None, 3, 4], 'B': ['bar', 'bar', 'foo', 'bar']})\n        pd.testing.assert_frame_equal(result, expected)\n", "prompt": "please write a python function , the function signature as below import pandas\nimport pandas as pd\n\n\ndef fill_missing_with_first_valid(df: pandas.DataFrame, column_name: str) -> pd.DataFrame:\n    \"\"\"\n    Fills missing values in the specified column of the DataFrame with the first valid value in that column.\n    Args:\n        df (pandas.DataFrame): The pandas DataFrame.\n        column_name (str): The name of the column to fill missing values.\n\n    Returns:\n        pd.DataFrame: The DataFrame with missing values filled.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 86, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "using bresenham, calculate the coordinates of all integer points on the line from point A to point B\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef bresenham_line(x1: int, y1: int, x2: int, y2: int) -> List[tuple]:\n    \"\"\"\n    Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n\n    Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n    It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n    determine which points should be rasterized to represent the line.\n\n    Args:\n        x1 (int): The x-coordinate of the starting point of the line.\n        y1 (int): The y-coordinate of the starting point of the line.\n        x2 (int): The x-coordinate of the ending point of the line.\n        y2 (int): The y-coordinate of the ending point of the line.\n\n    Returns:\n        list of tuples: A list where each tuple contains the x and y coordinates of a point on the line.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestBresenhamLineAlgorithm(unittest.TestCase):\n    def test_horizontal_line(self):\n        self.assertEqual(bresenham_line(1, 5, 5, 5), [(1, 5), (2, 5), (3, 5), (4, 5), (5, 5)])\n\n    def test_vertical_line(self):\n        self.assertEqual(bresenham_line(3, 2, 3, 6), [(3, 2), (3, 3), (3, 4), (3, 5), (3, 6)])\n\n    def test_diagonal_line(self):\n        self.assertEqual(bresenham_line(2, 2, 6, 6), [(2, 2), (3, 3), (4, 4), (5, 5), (6, 6)])\n\n    def test_steep_slope(self):\n        self.assertEqual(bresenham_line(1, 1, 4, 6), [(1, 1), (2, 2), (2, 3), (3, 4), (3, 5), (4, 6)])\n\n    def test_negative_slope(self):\n        self.assertEqual(bresenham_line(5, 1, 1, 5), [(5, 1), (4, 2), (3, 3), (2, 4), (1, 5)])\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef bresenham_line(x1: int, y1: int, x2: int, y2: int) -> List[tuple]:\n    \"\"\"\n    Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n\n    Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n    It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n    determine which points should be rasterized to represent the line.\n\n    Args:\n        x1 (int): The x-coordinate of the starting point of the line.\n        y1 (int): The y-coordinate of the starting point of the line.\n        x2 (int): The x-coordinate of the ending point of the line.\n        y2 (int): The y-coordinate of the ending point of the line.\n\n    Returns:\n        list of tuples: A list where each tuple contains the x and y coordinates of a point on the line.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param {number} x1 - The x-coordinate of the starting point of the line.\n * @param {number} y1 - The y-coordinate of the starting point of the line.\n * @param {number} x2 - The x-coordinate of the ending point of the line.\n * @param {number} y2 - The y-coordinate of the ending point of the line.\n * @returns {Array.<Array.<number>>} An array where each sub-array contains the x and y coordinates of a point on the line.\n */\nfunction bresenhamLine(x1, y1, x2, y2) {}", "test_code": "describe('Bresenham Line Algorithm', () => {\n    it('should generate horizontal line correctly', () => {\n        expect(bresenhamLine(1, 5, 5, 5)).toEqual([\n            [1, 5], [2, 5], [3, 5], [4, 5], [5, 5]\n        ]);\n    });\n\n    it('should generate vertical line correctly', () => {\n        expect(bresenhamLine(3, 2, 3, 6)).toEqual([\n            [3, 2], [3, 3], [3, 4], [3, 5], [3, 6]\n        ]);\n    });\n\n    it('should generate diagonal line correctly', () => {\n        expect(bresenhamLine(2, 2, 6, 6)).toEqual([\n            [2, 2], [3, 3], [4, 4], [5, 5], [6, 6]\n        ]);\n    });\n\n    it('should generate steep slope line correctly', () => {\n        expect(bresenhamLine(1, 1, 4, 6)).toEqual([\n            [1, 1], [2, 2], [2, 3], [3, 4], [3, 5], [4, 6]\n        ]);\n    });\n\n    it('should generate negative slope line correctly', () => {\n        expect(bresenhamLine(5, 1, 1, 5)).toEqual([\n            [5, 1], [4, 2], [3, 3], [2, 4], [1, 5]\n        ]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param {number} x1 - The x-coordinate of the starting point of the line.\n * @param {number} y1 - The y-coordinate of the starting point of the line.\n * @param {number} x2 - The x-coordinate of the ending point of the line.\n * @param {number} y2 - The y-coordinate of the ending point of the line.\n * @returns {Array.<Array.<number>>} An array where each sub-array contains the x and y coordinates of a point on the line.\n */\nfunction bresenhamLine(x1, y1, x2, y2) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param x1 - The x-coordinate of the starting point of the line.\n * @param y1 - The y-coordinate of the starting point of the line.\n * @param x2 - The x-coordinate of the ending point of the line.\n * @param y2 - The y-coordinate of the ending point of the line.\n * @returns An array of tuples, where each tuple contains the x and y coordinates of a point on the line.\n */\nfunction bresenhamLine(x1: number, y1: number, x2: number, y2: number): [number, number][] {}", "test_code": "describe('Bresenham Line Algorithm', () => {\n    it('should generate horizontal line correctly', () => {\n      expect(bresenhamLine(1, 5, 5, 5)).toEqual([\n        [1, 5],\n        [2, 5],\n        [3, 5],\n        [4, 5],\n        [5, 5]\n      ]);\n    });\n  \n    it('should generate vertical line correctly', () => {\n      expect(bresenhamLine(3, 2, 3, 6)).toEqual([\n        [3, 2],\n        [3, 3],\n        [3, 4],\n        [3, 5],\n        [3, 6]\n      ]);\n    });\n  \n    it('should generate diagonal line correctly', () => {\n      expect(bresenhamLine(2, 2, 6, 6)).toEqual([\n        [2, 2],\n        [3, 3],\n        [4, 4],\n        [5, 5],\n        [6, 6]\n      ]);\n    });\n  \n    it('should generate steep slope correctly', () => {\n      expect(bresenhamLine(1, 1, 4, 6)).toEqual([\n        [1, 1],\n        [2, 2],\n        [2, 3],\n        [3, 4],\n        [3, 5],\n        [4, 6]\n      ]);\n    });\n  \n    it('should generate negative slope correctly', () => {\n      expect(bresenhamLine(5, 1, 1, 5)).toEqual([\n        [5, 1],\n        [4, 2],\n        [3, 3],\n        [2, 4],\n        [1, 5]\n      ]);\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param x1 - The x-coordinate of the starting point of the line.\n * @param y1 - The y-coordinate of the starting point of the line.\n * @param x2 - The x-coordinate of the ending point of the line.\n * @param y2 - The y-coordinate of the ending point of the line.\n * @returns An array of tuples, where each tuple contains the x and y coordinates of a point on the line.\n */\nfunction bresenhamLine(x1: number, y1: number, x2: number, y2: number): [number, number][] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param x1 The x-coordinate of the starting point of the line.\n * @param y1 The y-coordinate of the starting point of the line.\n * @param x2 The x-coordinate of the ending point of the line.\n * @param y2 The y-coordinate of the ending point of the line.\n * @return A vector where each pair contains the x and y coordinates of a point on the line.\n */\nstd::vector<std::pair<int, int>> bresenham_line(int x1, int y1, int x2, int y2) {}", "test_code": "TEST_CASE(\"Test Bresenham Line Algorithm\", \"[Bresenham]\") {\n    SECTION(\"Horizontal Line\") {\n        std::vector<std::pair<int, int>> expected = {{1, 5}, {2, 5}, {3, 5}, {4, 5}, {5, 5}};\n        REQUIRE(bresenham_line(1, 5, 5, 5) == expected);\n    }\n\n    SECTION(\"Vertical Line\") {\n        std::vector<std::pair<int, int>> expected = {{3, 2}, {3, 3}, {3, 4}, {3, 5}, {3, 6}};\n        REQUIRE(bresenham_line(3, 2, 3, 6) == expected);\n    }\n\n    SECTION(\"Diagonal Line\") {\n        std::vector<std::pair<int, int>> expected = {{2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}};\n        REQUIRE(bresenham_line(2, 2, 6, 6) == expected);\n    }\n\n    SECTION(\"Steep Slope\") {\n        std::vector<std::pair<int, int>> expected = {{1, 1}, {2, 2}, {2, 3}, {3, 4}, {3, 5}, {4, 6}};\n        REQUIRE(bresenham_line(1, 1, 4, 6) == expected);\n    }\n\n    SECTION(\"Negative Slope\") {\n        std::vector<std::pair<int, int>> expected = {{5, 1}, {4, 2}, {3, 3}, {2, 4}, {1, 5}};\n        REQUIRE(bresenham_line(5, 1, 1, 5) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param x1 The x-coordinate of the starting point of the line.\n * @param y1 The y-coordinate of the starting point of the line.\n * @param x2 The x-coordinate of the ending point of the line.\n * @param y2 The y-coordinate of the ending point of the line.\n * @return A vector where each pair contains the x and y coordinates of a point on the line.\n */\nstd::vector<std::pair<int, int>> bresenham_line(int x1, int y1, int x2, int y2) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param x1 The x-coordinate of the starting point of the line.\n * @param y1 The y-coordinate of the starting point of the line.\n * @param x2 The x-coordinate of the ending point of the line.\n * @param y2 The y-coordinate of the ending point of the line.\n * @return A list of integer arrays, where each array contains the x and y coordinates of a point on the line.\n */\npublic static List<int[]> bresenhamLine(int x1, int y1, int x2, int y2) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testHorizontalLine() {\n        List<int[]> expected = Arrays.asList(\n                new int[]{1, 5},\n                new int[]{2, 5},\n                new int[]{3, 5},\n                new int[]{4, 5},\n                new int[]{5, 5}\n        );\n        List<int[]> actual = bresenhamLine(1, 5, 5, 5);\n        // Check if the sizes of the lists are equal\n        assertEquals(expected.size(), actual.size());\n\n        // Compare each int array in the lists\n        for (int i = 0; i < expected.size(); i++) {\n            assertArrayEquals(expected.get(i), actual.get(i));\n        }\n    }\n\n    @Test\n    public void testVerticalLine() {\n        List<int[]> expected = Arrays.asList(\n                new int[]{3, 2},\n                new int[]{3, 3},\n                new int[]{3, 4},\n                new int[]{3, 5},\n                new int[]{3, 6}\n        );\n        List<int[]> actual = bresenhamLine(3, 2, 3, 6);\n        // Check if the sizes of the lists are equal\n        assertEquals(expected.size(), actual.size());\n\n        // Compare each int array in the lists\n        for (int i = 0; i < expected.size(); i++) {\n            assertArrayEquals(expected.get(i), actual.get(i));\n        }\n    }\n\n    @Test\n    public void testDiagonalLine() {\n        List<int[]> expected = Arrays.asList(\n                new int[]{2, 2},\n                new int[]{3, 3},\n                new int[]{4, 4},\n                new int[]{5, 5},\n                new int[]{6, 6}\n        );\n        List<int[]> actual = bresenhamLine(2, 2, 6, 6);\n        // Check if the sizes of the lists are equal\n        assertEquals(expected.size(), actual.size());\n\n        // Compare each int array in the lists\n        for (int i = 0; i < expected.size(); i++) {\n            assertArrayEquals(expected.get(i), actual.get(i));\n        }\n    }\n\n    @Test\n    public void testSteepSlope() {\n        List<int[]> expected = Arrays.asList(\n                new int[]{1, 1},\n                new int[]{2, 2},\n                new int[]{2, 3},\n                new int[]{3, 4},\n                new int[]{3, 5},\n                new int[]{4, 6}\n        );\n        List<int[]> actual = bresenhamLine(1, 1, 4, 6);\n        // Check if the sizes of the lists are equal\n        assertEquals(expected.size(), actual.size());\n\n        // Compare each int array in the lists\n        for (int i = 0; i < expected.size(); i++) {\n            assertArrayEquals(expected.get(i), actual.get(i));\n        }\n    }\n\n    @Test\n    public void testNegativeSlope() {\n        List<int[]> expected = Arrays.asList(\n                new int[]{5, 1},\n                new int[]{4, 2},\n                new int[]{3, 3},\n                new int[]{2, 4},\n                new int[]{1, 5}\n        );\n        List<int[]> actual = bresenhamLine(5, 1, 1, 5);\n        // Check if the sizes of the lists are equal\n        assertEquals(expected.size(), actual.size());\n\n        // Compare each int array in the lists\n        for (int i = 0; i < expected.size(); i++) {\n            assertArrayEquals(expected.get(i), actual.get(i));\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param x1 The x-coordinate of the starting point of the line.\n * @param y1 The y-coordinate of the starting point of the line.\n * @param x2 The x-coordinate of the ending point of the line.\n * @param y2 The y-coordinate of the ending point of the line.\n * @return A list of integer arrays, where each array contains the x and y coordinates of a point on the line.\n */\npublic static List<int[]> bresenhamLine(int x1, int y1, int x2, int y2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 87, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "using bresenham, calculate the coordinates of all integer points on the line from point A to point B\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef bresenham_line(x1: int, y1: int, x2: int, y2: int) -> List[tuple]:\n    \"\"\"\n    Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n\n    Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n    It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n    determine which points should be rasterized to represent the line.\n\n    Args:\n        x1 (int): The x-coordinate of the starting point of the line.\n        y1 (int): The y-coordinate of the starting point of the line.\n        x2 (int): The x-coordinate of the ending point of the line.\n        y2 (int): The y-coordinate of the ending point of the line.\n\n    Returns:\n        list of tuples: A list where each tuple contains the x and y coordinates of a point on the line.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestBresenhamLineAlgorithm(unittest.TestCase):\n    def test_horizontal_line(self):\n        self.assertEqual(bresenham_line(1, 5, 5, 5), [(1, 5), (2, 5), (3, 5), (4, 5), (5, 5)])\n\n    def test_vertical_line(self):\n        self.assertEqual(bresenham_line(3, 2, 3, 6), [(3, 2), (3, 3), (3, 4), (3, 5), (3, 6)])\n\n    def test_diagonal_line(self):\n        self.assertEqual(bresenham_line(2, 2, 6, 6), [(2, 2), (3, 3), (4, 4), (5, 5), (6, 6)])\n\n    def test_steep_slope(self):\n        self.assertEqual(bresenham_line(1, 1, 4, 6), [(1, 1), (2, 2), (2, 3), (3, 4), (3, 5), (4, 6)])\n\n    def test_negative_slope(self):\n        self.assertEqual(bresenham_line(5, 1, 1, 5), [(5, 1), (4, 2), (3, 3), (2, 4), (1, 5)])\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef bresenham_line(x1: int, y1: int, x2: int, y2: int) -> List[tuple]:\n    \"\"\"\n    Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n\n    Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n    It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n    determine which points should be rasterized to represent the line.\n\n    Args:\n        x1 (int): The x-coordinate of the starting point of the line.\n        y1 (int): The y-coordinate of the starting point of the line.\n        x2 (int): The x-coordinate of the ending point of the line.\n        y2 (int): The y-coordinate of the ending point of the line.\n\n    Returns:\n        list of tuples: A list where each tuple contains the x and y coordinates of a point on the line.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param {number} x1 - The x-coordinate of the starting point of the line.\n * @param {number} y1 - The y-coordinate of the starting point of the line.\n * @param {number} x2 - The x-coordinate of the ending point of the line.\n * @param {number} y2 - The y-coordinate of the ending point of the line.\n * @returns {Array.<Array.<number>>} An array where each sub-array contains the x and y coordinates of a point on the line.\n */\nfunction bresenhamLine(x1, y1, x2, y2) {}", "test_code": "describe('Bresenham Line Algorithm', () => {\n    it('should generate horizontal line correctly', () => {\n        expect(bresenhamLine(1, 5, 5, 5)).toEqual([\n            [1, 5], [2, 5], [3, 5], [4, 5], [5, 5]\n        ]);\n    });\n\n    it('should generate vertical line correctly', () => {\n        expect(bresenhamLine(3, 2, 3, 6)).toEqual([\n            [3, 2], [3, 3], [3, 4], [3, 5], [3, 6]\n        ]);\n    });\n\n    it('should generate diagonal line correctly', () => {\n        expect(bresenhamLine(2, 2, 6, 6)).toEqual([\n            [2, 2], [3, 3], [4, 4], [5, 5], [6, 6]\n        ]);\n    });\n\n    it('should generate steep slope line correctly', () => {\n        expect(bresenhamLine(1, 1, 4, 6)).toEqual([\n            [1, 1], [2, 2], [2, 3], [3, 4], [3, 5], [4, 6]\n        ]);\n    });\n\n    it('should generate negative slope line correctly', () => {\n        expect(bresenhamLine(5, 1, 1, 5)).toEqual([\n            [5, 1], [4, 2], [3, 3], [2, 4], [1, 5]\n        ]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param {number} x1 - The x-coordinate of the starting point of the line.\n * @param {number} y1 - The y-coordinate of the starting point of the line.\n * @param {number} x2 - The x-coordinate of the ending point of the line.\n * @param {number} y2 - The y-coordinate of the ending point of the line.\n * @returns {Array.<Array.<number>>} An array where each sub-array contains the x and y coordinates of a point on the line.\n */\nfunction bresenhamLine(x1, y1, x2, y2) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param x1 - The x-coordinate of the starting point of the line.\n * @param y1 - The y-coordinate of the starting point of the line.\n * @param x2 - The x-coordinate of the ending point of the line.\n * @param y2 - The y-coordinate of the ending point of the line.\n * @returns An array of tuples, where each tuple contains the x and y coordinates of a point on the line.\n */\nfunction bresenhamLine(x1: number, y1: number, x2: number, y2: number): [number, number][] {}", "test_code": "describe('Bresenham Line Algorithm', () => {\n    it('should generate horizontal line correctly', () => {\n      expect(bresenhamLine(1, 5, 5, 5)).toEqual([\n        [1, 5],\n        [2, 5],\n        [3, 5],\n        [4, 5],\n        [5, 5]\n      ]);\n    });\n  \n    it('should generate vertical line correctly', () => {\n      expect(bresenhamLine(3, 2, 3, 6)).toEqual([\n        [3, 2],\n        [3, 3],\n        [3, 4],\n        [3, 5],\n        [3, 6]\n      ]);\n    });\n  \n    it('should generate diagonal line correctly', () => {\n      expect(bresenhamLine(2, 2, 6, 6)).toEqual([\n        [2, 2],\n        [3, 3],\n        [4, 4],\n        [5, 5],\n        [6, 6]\n      ]);\n    });\n  \n    it('should generate steep slope correctly', () => {\n      expect(bresenhamLine(1, 1, 4, 6)).toEqual([\n        [1, 1],\n        [2, 2],\n        [2, 3],\n        [3, 4],\n        [3, 5],\n        [4, 6]\n      ]);\n    });\n  \n    it('should generate negative slope correctly', () => {\n      expect(bresenhamLine(5, 1, 1, 5)).toEqual([\n        [5, 1],\n        [4, 2],\n        [3, 3],\n        [2, 4],\n        [1, 5]\n      ]);\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param x1 - The x-coordinate of the starting point of the line.\n * @param y1 - The y-coordinate of the starting point of the line.\n * @param x2 - The x-coordinate of the ending point of the line.\n * @param y2 - The y-coordinate of the ending point of the line.\n * @returns An array of tuples, where each tuple contains the x and y coordinates of a point on the line.\n */\nfunction bresenhamLine(x1: number, y1: number, x2: number, y2: number): [number, number][] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param x1 The x-coordinate of the starting point of the line.\n * @param y1 The y-coordinate of the starting point of the line.\n * @param x2 The x-coordinate of the ending point of the line.\n * @param y2 The y-coordinate of the ending point of the line.\n * @return A vector where each pair contains the x and y coordinates of a point on the line.\n */\nstd::vector<std::pair<int, int>> bresenham_line(int x1, int y1, int x2, int y2) {}", "test_code": "TEST_CASE(\"Test Bresenham Line Algorithm\", \"[Bresenham]\") {\n    SECTION(\"Horizontal Line\") {\n        std::vector<std::pair<int, int>> expected = {{1, 5}, {2, 5}, {3, 5}, {4, 5}, {5, 5}};\n        REQUIRE(bresenham_line(1, 5, 5, 5) == expected);\n    }\n\n    SECTION(\"Vertical Line\") {\n        std::vector<std::pair<int, int>> expected = {{3, 2}, {3, 3}, {3, 4}, {3, 5}, {3, 6}};\n        REQUIRE(bresenham_line(3, 2, 3, 6) == expected);\n    }\n\n    SECTION(\"Diagonal Line\") {\n        std::vector<std::pair<int, int>> expected = {{2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}};\n        REQUIRE(bresenham_line(2, 2, 6, 6) == expected);\n    }\n\n    SECTION(\"Steep Slope\") {\n        std::vector<std::pair<int, int>> expected = {{1, 1}, {2, 2}, {2, 3}, {3, 4}, {3, 5}, {4, 6}};\n        REQUIRE(bresenham_line(1, 1, 4, 6) == expected);\n    }\n\n    SECTION(\"Negative Slope\") {\n        std::vector<std::pair<int, int>> expected = {{5, 1}, {4, 2}, {3, 3}, {2, 4}, {1, 5}};\n        REQUIRE(bresenham_line(5, 1, 1, 5) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param x1 The x-coordinate of the starting point of the line.\n * @param y1 The y-coordinate of the starting point of the line.\n * @param x2 The x-coordinate of the ending point of the line.\n * @param y2 The y-coordinate of the ending point of the line.\n * @return A vector where each pair contains the x and y coordinates of a point on the line.\n */\nstd::vector<std::pair<int, int>> bresenham_line(int x1, int y1, int x2, int y2) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param x1 The x-coordinate of the starting point of the line.\n * @param y1 The y-coordinate of the starting point of the line.\n * @param x2 The x-coordinate of the ending point of the line.\n * @param y2 The y-coordinate of the ending point of the line.\n * @return A list of integer arrays, where each array contains the x and y coordinates of a point on the line.\n */\npublic static List<int[]> bresenhamLine(int x1, int y1, int x2, int y2) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testHorizontalLine() {\n        List<int[]> expected = Arrays.asList(\n                new int[]{1, 5},\n                new int[]{2, 5},\n                new int[]{3, 5},\n                new int[]{4, 5},\n                new int[]{5, 5}\n        );\n        List<int[]> actual = bresenhamLine(1, 5, 5, 5);\n        // Check if the sizes of the lists are equal\n        assertEquals(expected.size(), actual.size());\n\n        // Compare each int array in the lists\n        for (int i = 0; i < expected.size(); i++) {\n            assertArrayEquals(expected.get(i), actual.get(i));\n        }\n    }\n\n    @Test\n    public void testVerticalLine() {\n        List<int[]> expected = Arrays.asList(\n                new int[]{3, 2},\n                new int[]{3, 3},\n                new int[]{3, 4},\n                new int[]{3, 5},\n                new int[]{3, 6}\n        );\n        List<int[]> actual = bresenhamLine(3, 2, 3, 6);\n        // Check if the sizes of the lists are equal\n        assertEquals(expected.size(), actual.size());\n\n        // Compare each int array in the lists\n        for (int i = 0; i < expected.size(); i++) {\n            assertArrayEquals(expected.get(i), actual.get(i));\n        }\n    }\n\n    @Test\n    public void testDiagonalLine() {\n        List<int[]> expected = Arrays.asList(\n                new int[]{2, 2},\n                new int[]{3, 3},\n                new int[]{4, 4},\n                new int[]{5, 5},\n                new int[]{6, 6}\n        );\n        List<int[]> actual = bresenhamLine(2, 2, 6, 6);\n        // Check if the sizes of the lists are equal\n        assertEquals(expected.size(), actual.size());\n\n        // Compare each int array in the lists\n        for (int i = 0; i < expected.size(); i++) {\n            assertArrayEquals(expected.get(i), actual.get(i));\n        }\n    }\n\n    @Test\n    public void testSteepSlope() {\n        List<int[]> expected = Arrays.asList(\n                new int[]{1, 1},\n                new int[]{2, 2},\n                new int[]{2, 3},\n                new int[]{3, 4},\n                new int[]{3, 5},\n                new int[]{4, 6}\n        );\n        List<int[]> actual = bresenhamLine(1, 1, 4, 6);\n        // Check if the sizes of the lists are equal\n        assertEquals(expected.size(), actual.size());\n\n        // Compare each int array in the lists\n        for (int i = 0; i < expected.size(); i++) {\n            assertArrayEquals(expected.get(i), actual.get(i));\n        }\n    }\n\n    @Test\n    public void testNegativeSlope() {\n        List<int[]> expected = Arrays.asList(\n                new int[]{5, 1},\n                new int[]{4, 2},\n                new int[]{3, 3},\n                new int[]{2, 4},\n                new int[]{1, 5}\n        );\n        List<int[]> actual = bresenhamLine(5, 1, 1, 5);\n        // Check if the sizes of the lists are equal\n        assertEquals(expected.size(), actual.size());\n\n        // Compare each int array in the lists\n        for (int i = 0; i < expected.size(); i++) {\n            assertArrayEquals(expected.get(i), actual.get(i));\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n *\n * Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n * It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n * determine which points should be rasterized to represent the line.\n *\n * @param x1 The x-coordinate of the starting point of the line.\n * @param y1 The y-coordinate of the starting point of the line.\n * @param x2 The x-coordinate of the ending point of the line.\n * @param y2 The y-coordinate of the ending point of the line.\n * @return A list of integer arrays, where each array contains the x and y coordinates of a point on the line.\n */\npublic static List<int[]> bresenhamLine(int x1, int y1, int x2, int y2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 213, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Apply the im2col operation to an input image.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\ndef im2col(image, filter_height, filter_width, stride=1, padding=0):\n    \"\"\"\n    Apply the im2col operation to an input image.\n\n    Parameters:\n    - image (numpy array): The input image of shape (C, H, W) where:\n        C: Number of channels\n        H: Height of the image\n        W: Width of the image\n    - filter_height (int): Height of the filter\n    - filter_width (int): Width of the filter\n    - stride (int): Stride of the filter\n    - padding (int): Number of pixels to pad the input image\n\n    Returns:\n    - col (numpy array): A 2D array where each column is a flattened filter region\n    \"\"\"", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestIm2Col(unittest.TestCase):\n\n    def test_single_channel_no_padding_stride_1(self):\n        image = np.array([\n            [[1, 2, 3, 4],\n             [5, 6, 7, 8],\n             [9, 10, 11, 12],\n             [13, 14, 15, 16]]\n        ])  # Shape (1, 4, 4)\n        filter_height = 2\n        filter_width = 2\n        stride = 1\n        padding = 0\n\n        expected_output = np.array([\n            [1, 2, 3, 5, 6, 7, 9, 10, 11],\n            [2, 3, 4, 6, 7, 8, 10, 11, 12],\n            [5, 6, 7, 9, 10, 11, 13, 14, 15],\n            [6, 7, 8, 10, 11, 12, 14, 15, 16]\n        ])\n        output = im2col(image, filter_height, filter_width, stride, padding)\n        np.testing.assert_array_equal(output, expected_output)\n\n    def test_single_channel_no_padding_stride_2(self):\n        image = np.array([\n            [[1, 2, 3, 4],\n             [5, 6, 7, 8],\n             [9, 10, 11, 12],\n             [13, 14, 15, 16]]\n        ])  # Shape (1, 4, 4)\n        filter_height = 2\n        filter_width = 2\n        stride = 2\n        padding = 0\n\n        expected_output = np.array([\n            [1, 3, 9, 11],\n            [2, 4, 10, 12],\n            [5, 7, 13, 15],\n            [6, 8, 14, 16]\n        ])\n        output = im2col(image, filter_height, filter_width, stride, padding)\n        np.testing.assert_array_equal(output, expected_output)\n\n    def test_multi_channel_no_padding_stride_1(self):\n        image = np.array([\n            [[1, 2, 3],\n             [4, 5, 6],\n             [7, 8, 9]],\n            [[9, 8, 7],\n             [6, 5, 4],\n             [3, 2, 1]]\n        ])  # Shape (2, 3, 3), 2 channels\n        filter_height = 2\n        filter_width = 2\n        stride = 1\n        padding = 0\n\n        expected_output = np.array([\n            [1, 2, 4, 5],\n            [2, 3, 5, 6],\n            [4, 5, 7, 8],\n            [5, 6, 8, 9],\n            [9, 8, 6, 5],\n            [8, 7, 5, 4],\n            [6, 5, 3, 2],\n            [5, 4, 2, 1]\n        ])\n        output = im2col(image, filter_height, filter_width, stride, padding)\n        np.testing.assert_array_equal(output, expected_output)\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\ndef im2col(image, filter_height, filter_width, stride=1, padding=0):\n    \"\"\"\n    Apply the im2col operation to an input image.\n\n    Parameters:\n    - image (numpy array): The input image of shape (C, H, W) where:\n        C: Number of channels\n        H: Height of the image\n        W: Width of the image\n    - filter_height (int): Height of the filter\n    - filter_width (int): Width of the filter\n    - stride (int): Stride of the filter\n    - padding (int): Number of pixels to pad the input image\n\n    Returns:\n    - col (numpy array): A 2D array where each column is a flattened filter region\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 214, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Reads data from the given mapping file and returns a list where each element is a tuple containing the compiled regular expression and replacement strings\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef read_mapping_file(mapping_file_path: str) -> List:\n    \"\"\"\n    Reads question from the given mapping file and returns a list where each element is a tuple containing the compiled regular expression and replacement strings\n    Args:\n        mapping_file_path (str): Path to the file containing regex mappings.\n\n    Returns:\n        list of tuples: Each tuple contains a compiled regex object and a corresponding replacement string.\n    \"\"\"\n", "test_code": "import re\nimport unittest\nfrom unittest.mock import patch, mock_open\n\n\nclass TestReadMappingFile(unittest.TestCase):\n\n    def test_valid_mapping_file(self):\n        # Test with a valid mapping file content\n        mock_file_content = \"'old_pattern1','new_word1'\\n'old_pattern2','new_word2'\\n\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_file_content)):\n            result = read_mapping_file(\"dummy_path.txt\")\n            expected = [\n                (re.compile(\"old_pattern1\"), \"new_word1\"),\n                (re.compile(\"old_pattern2\"), \"new_word2\"),\n            ]\n            self.assertEqual(result, expected)\n\n    def test_missing_file(self):\n        # Test with a missing file\n        with self.assertRaises(FileNotFoundError):\n            read_mapping_file(\"non_existent_file.txt\")\n\n    def test_malformed_line_no_comma(self):\n        # Test with a line that does not contain a comma\n        mock_file_content = \"'old_pattern1' 'new_word1'\\n\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_file_content)):\n            with self.assertRaises(ValueError) as context:\n                read_mapping_file(\"dummy_path.txt\")\n            self.assertEqual(str(context.exception), \"Each line must contain exactly one comma separating the pattern and the replacement.\")\n\n    def test_valid_patterns_with_special_characters(self):\n        # Test with valid patterns that contain special regex characters\n        mock_file_content = \"'\\\\d+', 'number'\\n'\\\\w+', 'word'\\n\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_file_content)):\n            result = read_mapping_file(\"dummy_path.txt\")\n            expected = [\n                (re.compile(r\"\\d+\"), \"number\"),\n                (re.compile(r\"\\w+\"), \"word\"),\n            ]\n            self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef read_mapping_file(mapping_file_path: str) -> List:\n    \"\"\"\n    Reads question from the given mapping file and returns a list where each element is a tuple containing the compiled regular expression and replacement strings\n    Args:\n        mapping_file_path (str): Path to the file containing regex mappings.\n\n    Returns:\n        list of tuples: Each tuple contains a compiled regex object and a corresponding replacement string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Reads question from the given mapping file and returns an array where each element is a tuple containing the compiled regular expression and replacement strings.\n * \n * @param {string} mappingFilePath - Path to the file containing regex mappings.\n * @returns {Array} - An array of tuples, where each tuple contains a compiled regex object and a corresponding replacement string.\n * @throws {Error} - Throws an error if the mapping file does not exist or if any line in the file does not contain exactly one comma.\n */\nfunction readMappingFile(mappingFilePath) {}", "test_code": "jest.mock('fs', () => ({\n  ...jest.requireActual('fs'),\n  promises: {\n    readFile: jest.fn(),\n  },\n}));\n\ndescribe('readMappingFile', () => {\n  beforeEach(() => {\n    jest.resetModules();\n    jest.clearAllMocks();\n  });\n\n  it('should correctly parse a valid mapping file', () => {\n    const mockFileContent = \"'old_pattern1','new_word1'\\n'old_pattern2','new_word2'\\n\";\n    const mockPath = '/path/to/dummy_path.txt';\n    fs.promises.readFile.mockResolvedValue(mockFileContent);\n\n    return readMappingFile(mockPath).then(result => {\n      const expected = [\n        [new RegExp('old_pattern1'), 'new_word1'],\n        [new RegExp('old_pattern2'), 'new_word2'],\n      ];\n      expect(result).toEqual(expected);\n    });\n  });\n\n  it('should throw an error for a missing file', () => {\n    const nonExistentFilePath = '/path/to/non_existent_file.txt';\n    fs.promises.readFile.mockRejectedValue(new Error('ENOENT'));\n\n    return expect(readMappingFile(nonExistentFilePath)).rejects.toThrow('Unable to find the specified file: /path/to/non_existent_file.txt');\n  });\n\n  it('should throw an error for a malformed line without a comma', () => {\n    const mockFileContent = \"'old_pattern1' 'new_word1'\\n\";\n    const mockPath = '/path/to/dummy_path.txt';\n    fs.promises.readFile.mockResolvedValue(mockFileContent);\n\n    return expect(readMappingFile(mockPath)).rejects.toThrow('Each line must contain exactly one comma separating the pattern and the replacement.');\n  });\n\n  it('should correctly parse valid patterns with special characters', () => {\n    const mockFileContent = \"'\\\\d+', 'number'\\n'\\\\w+', 'word'\\n\";\n    const mockPath = '/path/to/dummy_path.txt';\n    fs.promises.readFile.mockResolvedValue(mockFileContent);\n\n    return readMappingFile(mockPath).then(result => {\n      const expected = [\n        [new RegExp('\\\\d+'), 'number'],\n        [new RegExp('\\\\w+'), 'word'],\n      ];\n      expect(result).toEqual(expected);\n    });\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Reads question from the given mapping file and returns an array where each element is a tuple containing the compiled regular expression and replacement strings.\n * \n * @param {string} mappingFilePath - Path to the file containing regex mappings.\n * @returns {Array} - An array of tuples, where each tuple contains a compiled regex object and a corresponding replacement string.\n * @throws {Error} - Throws an error if the mapping file does not exist or if any line in the file does not contain exactly one comma.\n */\nfunction readMappingFile(mappingFilePath) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as fs from 'fs';\nimport * as path from 'path';\nimport * as xregexp from 'xregexp';\n\ninterface Mapping {\n    regex: RegExp;\n    replacement: string;\n}\n\n/**\n * Reads question from the given mapping file and returns a list where each element is a tuple containing the compiled regular expression and replacement strings.\n * @param mappingFilePath - Path to the file containing regex mappings.\n * @returns An array of objects, each containing a compiled regex object and a corresponding replacement string.\n */\nfunction readMappingFile(mappingFilePath: string): Mapping[] {}", "test_code": "interface Mapping {\n    regex: RegExp;\n    replacement: string;\n}\ndescribe('TestReadMappingFile', () => {\n    it('test_valid_mapping_file', () => {\n        // Test with a valid mapping file content\n        const mockFileContent = \"'old_pattern1','new_word1'\\n'old_pattern2','new_word2'\\n\";\n        jest.spyOn(fs, 'readFileSync').mockImplementation(() => mockFileContent);\n\n        const result = readMappingFile('dummy_path.txt');\n        const expected: Mapping[] = [\n            { regex: xregexp('old_pattern1'), replacement: 'new_word1' },\n            { regex: xregexp('old_pattern2'), replacement: 'new_word2' },\n        ];\n\n        expect(result).toEqual(expected);\n    });\n\n    it('test_missing_file', () => {\n        // Test with a missing file\n        jest.spyOn(fs, 'readFileSync').mockImplementation(() => {\n            throw new Error('ENOENT: no such file or directory');\n        });\n\n        expect(() => readMappingFile('non_existent_file.txt')).toThrow('Unable to find the specified file: non_existent_file.txt');\n    });\n\n    it('test_malformed_line_no_comma', () => {\n        // Test with a line that does not contain a comma\n        const mockFileContent = \"'old_pattern1' 'new_word1'\\n\";\n        jest.spyOn(fs, 'readFileSync').mockImplementation(() => mockFileContent);\n\n        expect(() => readMappingFile('dummy_path.txt')).toThrow('Each line must contain exactly one comma separating the pattern and the replacement.');\n    });\n\n    it('test_valid_patterns_with_special_characters', () => {\n        // Test with valid patterns that contain special regex characters\n        const mockFileContent = \"'\\\\d+', 'number'\\n'\\\\w+', 'word'\\n\";\n        jest.spyOn(fs, 'readFileSync').mockImplementation(() => mockFileContent);\n\n        const result = readMappingFile('dummy_path.txt');\n        const expected: Mapping[] = [\n            { regex: xregexp('\\\\d+'), replacement: 'number' },\n            { regex: xregexp('\\\\w+'), replacement: 'word' },\n        ];\n\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below import * as fs from 'fs';\nimport * as path from 'path';\nimport * as xregexp from 'xregexp';\n\ninterface Mapping {\n    regex: RegExp;\n    replacement: string;\n}\n\n/**\n * Reads question from the given mapping file and returns a list where each element is a tuple containing the compiled regular expression and replacement strings.\n * @param mappingFilePath - Path to the file containing regex mappings.\n * @returns An array of objects, each containing a compiled regex object and a corresponding replacement string.\n */\nfunction readMappingFile(mappingFilePath: string): Mapping[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads question mappings from the specified file and returns a list of tuples \n *        containing compiled regular expressions and their corresponding replacement strings.\n *\n * This function processes a mapping file to extract regex patterns and their replacement \n * strings, compiling the patterns for later use.\n *\n * @param mapping_file_path The path to the file containing regex mappings.\n * @return A vector of Mapping structs, each containing a compiled regex object and \n *         its corresponding replacement string.\n */\nstd::vector<Mapping> read_mapping_file(const std::string& mapping_file_path) {}", "test_code": "TEST_CASE(\"Test read_mapping_file function\", \"[read_mapping_file]\") {\n    SECTION(\"Test with a valid mapping file content\") {\n        // Test with a valid mapping file content\n        const std::string mock_file_content = \"'old_pattern1','new_word1'\\n'old_pattern2','new_word2'\\n\";\n        std::istringstream mock_stream(mock_file_content);\n\n        // Redirect std::ifstream to use the mock stream\n        std::istringstream* original_ifstream_open = std::ifstream::open;\n        std::ifstream::open = [&mock_stream](const std::string&, std::ios_base::openmode) {\n            return &mock_stream;\n        };\n\n        std::vector<Mapping> result = read_mapping_file(\"dummy_path.txt\");\n        std::vector<Mapping> expected = {\n            {std::regex(\"old_pattern1\"), \"new_word1\"},\n            {std::regex(\"old_pattern2\"), \"new_word2\"}\n        };\n\n        REQUIRE(result.size() == expected.size());\n        for (size_t i = 0; i < result.size(); ++i) {\n            REQUIRE(result[i].pattern.mark_count() == expected[i].pattern.mark_count());\n            REQUIRE(result[i].replacement == expected[i].replacement);\n        }\n\n        // Restore the original ifstream::open\n        std::ifstream::open = original_ifstream_open;\n    }\n\n    SECTION(\"Test with a missing file\") {\n        // Test with a missing file\n        REQUIRE_THROWS_AS(read_mapping_file(\"non_existent_file.txt\"), std::runtime_error);\n    }\n\n    SECTION(\"Test with a line that does not contain a comma\") {\n        // Test with a line that does not contain a comma\n        const std::string mock_file_content = \"'old_pattern1' 'new_word1'\\n\";\n        std::istringstream mock_stream(mock_file_content);\n\n        // Redirect std::ifstream to use the mock stream\n        std::istringstream* original_ifstream_open = std::ifstream::open;\n        std::ifstream::open = [&mock_stream](const std::string&, std::ios_base::openmode) {\n            return &mock_stream;\n        };\n\n        REQUIRE_THROWS_AS(read_mapping_file(\"dummy_path.txt\"), std::runtime_error);\n\n        // Restore the original ifstream::open\n        std::ifstream::open = original_ifstream_open;\n    }\n\n    SECTION(\"Test with valid patterns that contain special regex characters\") {\n        // Test with valid patterns that contain special regex characters\n        const std::string mock_file_content = \"'\\\\d+', 'number'\\n'\\\\w+', 'word'\\n\";\n        std::istringstream mock_stream(mock_file_content);\n\n        // Redirect std::ifstream to use the mock stream\n        std::istringstream* original_ifstream_open = std::ifstream::open;\n        std::ifstream::open = [&mock_stream](const std::string&, std::ios_base::openmode) {\n            return &mock_stream;\n        };\n\n        std::vector<Mapping> result = read_mapping_file(\"dummy_path.txt\");\n        std::vector<Mapping> expected = {\n            {std::regex(\"\\\\d+\"), \"number\"},\n            {std::regex(\"\\\\w+\"), \"word\"}\n        };\n\n        REQUIRE(result.size() == expected.size());\n        for (size_t i = 0; i < result.size(); ++i) {\n            REQUIRE(result[i].pattern.mark_count() == expected[i].pattern.mark_count());\n            REQUIRE(result[i].replacement == expected[i].replacement);\n        }\n\n        // Restore the original ifstream::open\n        std::ifstream::open = original_ifstream_open;\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads question mappings from the specified file and returns a list of tuples \n *        containing compiled regular expressions and their corresponding replacement strings.\n *\n * This function processes a mapping file to extract regex patterns and their replacement \n * strings, compiling the patterns for later use.\n *\n * @param mapping_file_path The path to the file containing regex mappings.\n * @return A vector of Mapping structs, each containing a compiled regex object and \n *         its corresponding replacement string.\n */\nstd::vector<Mapping> read_mapping_file(const std::string& mapping_file_path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads a mapping file and returns a list of tuples with compiled regex and replacement strings.\n *\n * @param mappingFilePath Path to the file containing regex mappings.\n * @return A list of tuples, where each tuple contains a compiled regex object and a corresponding replacement string.\n * @throws IOException If the mapping file does not exist or cannot be read.\n */\npublic static class Tuple<T1, T2> {\n    private T1 first;\n    private T2 second;\n\n    public Tuple(T1 first, T2 second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public T1 getFirst() {\n        return first;\n    }\n\n    public T2 getSecond() {\n        return second;\n    }\n}\npublic static List<Tuple<Pattern, String>> readMappingFile(String mappingFilePath) throws IOException {}", "test_code": "public class Tester {\n\n    @Test\n    void testValidMappingFile() throws IOException {\n        // Test with a valid mapping file content\n        String mockFileContent = \"'old_pattern1','new_word1'\\n'old_pattern2','new_word2'\\n\";\n        File tempFile = File.createTempFile(\"dummy\", \".txt\");\n        try (FileWriter writer = new FileWriter(tempFile)) {\n            writer.write(mockFileContent);\n        }\n\n        List<Tuple<Pattern, String>> result = readMappingFile(tempFile.getAbsolutePath());\n        List<Tuple<Pattern, String>> expected = List.of(\n            new Tuple<>(Pattern.compile(\"old_pattern1\"), \"new_word1\"),\n            new Tuple<>(Pattern.compile(\"old_pattern2\"), \"new_word2\")\n        );\n\n        assertEquals(expected, result);\n    }\n\n    @Test\n    void testMissingFile() {\n        // Test with a missing file\n        assertThrows(IOException.class, () -> readMappingFile(\"non_existent_file.txt\"));\n    }\n\n    @Test\n    void testMalformedLineNoComma() throws IOException {\n        // Test with a line that does not contain a comma\n        String mockFileContent = \"'old_pattern1' 'new_word1'\\n\";\n        File tempFile = File.createTempFile(\"dummy\", \".txt\");\n        try (FileWriter writer = new FileWriter(tempFile)) {\n            writer.write(mockFileContent);\n        }\n\n        assertThrows(IllegalArgumentException.class, () -> readMappingFile(tempFile.getAbsolutePath()));\n    }\n\n    @Test\n    void testValidPatternsWithSpecialCharacters() throws IOException {\n        // Test with valid patterns that contain special regex characters\n        String mockFileContent = \"'\\\\d+', 'number'\\n'\\\\w+', 'word'\\n\";\n        File tempFile = File.createTempFile(\"dummy\", \".txt\");\n        try (FileWriter writer = new FileWriter(tempFile)) {\n            writer.write(mockFileContent);\n        }\n\n        List<Tuple<Pattern, String>> result = readMappingFile(tempFile.getAbsolutePath());\n        List<Tuple<Pattern, String>> expected = List.of(\n            new Tuple<>(Pattern.compile(\"\\\\d+\"), \"number\"),\n            new Tuple<>(Pattern.compile(\"\\\\w+\"), \"word\")\n        );\n\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Reads a mapping file and returns a list of tuples with compiled regex and replacement strings.\n *\n * @param mappingFilePath Path to the file containing regex mappings.\n * @return A list of tuples, where each tuple contains a compiled regex object and a corresponding replacement string.\n * @throws IOException If the mapping file does not exist or cannot be read.\n */\npublic static class Tuple<T1, T2> {\n    private T1 first;\n    private T2 second;\n\n    public Tuple(T1 first, T2 second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public T1 getFirst() {\n        return first;\n    }\n\n    public T2 getSecond() {\n        return second;\n    }\n}\npublic static List<Tuple<Pattern, String>> readMappingFile(String mappingFilePath) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 215, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Read a text file according to the file path, replace the word according to the dictionary map, and return the replaced text", "language_version_list": {"python": {"code_signature": "def replace_words_in_file(file_path: str, replacement_dict: dict) -> str:\n    \"\"\"\n    Read a text file, replace words according to a dictionary map, and return the modified text.\n\n    Parameters:\n    - file_path (str): The path to the text file.\n    - replacement_dict (dict): A dictionary where the keys are words to be replaced, and the values are the replacement words.\n\n    Returns:\n    - str: The text with the words replaced.\n    \"\"\"\n", "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestReplaceWordsInFile(unittest.TestCase):\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"hello world\")\n    def test_replace_single_word(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"hello\": \"hi\"}\n        expected_output = \"hi world\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"hello world\")\n    def test_replace_multiple_words(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"hello\": \"hi\", \"world\": \"earth\"}\n        expected_output = \"hi earth\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"hello world\")\n    def test_no_replacement(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"goodbye\": \"bye\"}\n        expected_output = \"hello world\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"\")\n    def test_empty_file(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"hello\": \"hi\"}\n        expected_output = \"\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n", "prompt": "please write a python function , the function signature as below def replace_words_in_file(file_path: str, replacement_dict: dict) -> str:\n    \"\"\"\n    Read a text file, replace words according to a dictionary map, and return the modified text.\n\n    Parameters:\n    - file_path (str): The path to the text file.\n    - replacement_dict (dict): A dictionary where the keys are words to be replaced, and the values are the replacement words.\n\n    Returns:\n    - str: The text with the words replaced.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Read a text file, replace words according to a dictionary map, and return the modified text.\n *\n * @param {string} file_path - The path to the text file.\n * @param {Object} replacement_dict - An object where the keys are words to be replaced, and the values are the replacement words.\n * @returns {Promise<string>} A promise that resolves to the text with the words replaced or an error message.\n */\nasync function replaceWordsInFile(file_path, replacement_dict) {}", "test_code": "const fs = require('fs');\nconst { mock } = require('jest-mock-extended');\njest.mock('fs', () => ({\n  ...jest.requireActual('fs'),\n  readFile: jest.fn(),\n}));\ndescribe('replaceWordsInFile', () => {\n  beforeEach(() => {\n    // Reset the mock implementation before each test\n    fs.readFile.mockClear();\n  });\n\n  it('replaces a single word', () => {\n    const file_path = \"dummy_path.txt\";\n    const replacement_dict = {\"hello\": \"hi\"};\n    const expected_output = \"hi world\";\n\n    // Mock the file content\n    fs.readFile.mockImplementationOnce((path, callback) => {\n      callback(null, \"hello world\");\n    });\n\n    const result = replaceWordsInFile(file_path, replacement_dict);\n    expect(result).toBe(expected_output);\n  });\n\n  it('replaces multiple words', () => {\n    const file_path = \"dummy_path.txt\";\n    const replacement_dict = {\"hello\": \"hi\", \"world\": \"earth\"};\n    const expected_output = \"hi earth\";\n\n    // Mock the file content\n    fs.readFile.mockImplementationOnce((path, callback) => {\n      callback(null, \"hello world\");\n    });\n\n    const result = replaceWordsInFile(file_path, replacement_dict);\n    expect(result).toBe(expected_output);\n  });\n\n  it('does not replace non-existent words', () => {\n    const file_path = \"dummy_path.txt\";\n    const replacement_dict = {\"goodbye\": \"bye\"};\n    const expected_output = \"hello world\";\n\n    // Mock the file content\n    fs.readFile.mockImplementationOnce((path, callback) => {\n      callback(null, \"hello world\");\n    });\n\n    const result = replaceWordsInFile(file_path, replacement_dict);\n    expect(result).toBe(expected_output);\n  });\n\n  it('handles empty files', () => {\n    const file_path = \"dummy_path.txt\";\n    const replacement_dict = {\"hello\": \"hi\"};\n    const expected_output = \"\";\n\n    // Mock the file content\n    fs.readFile.mockImplementationOnce((path, callback) => {\n      callback(null, \"\");\n    });\n\n    const result = replaceWordsInFile(file_path, replacement_dict);\n    expect(result).toBe(expected_output);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Read a text file, replace words according to a dictionary map, and return the modified text.\n *\n * @param {string} file_path - The path to the text file.\n * @param {Object} replacement_dict - An object where the keys are words to be replaced, and the values are the replacement words.\n * @returns {Promise<string>} A promise that resolves to the text with the words replaced or an error message.\n */\nasync function replaceWordsInFile(file_path, replacement_dict) {}", "addition_info": ""}, "typescript": {"code_signature": "import fs from 'fs';\n\n/**\n * Read a text file, replace words according to a dictionary map, and return the modified text.\n *\n * @param filePath - The path to the text file.\n * @param replacementDict - A dictionary where the keys are words to be replaced, and the values are the replacement words.\n * @returns The text with the words replaced or an error message.\n */\nfunction replaceWordsInFile(filePath: string, replacementDict: { [key: string]: string }): string {}", "test_code": "import fs from 'fs';\n\ndescribe('TestReplaceWordsInFile', () => {\n  const mockFileData = \"hello world\";\n\n  beforeEach(() => {\n    jest.spyOn(fs, 'readFileSync').mockImplementation(() => mockFileData);\n  });\n\n  afterEach(() => {\n    jest.restoreAllMocks();\n  });\n\n  it('should replace a single word', () => {\n    const file_path = \"dummy_path.txt\";\n    const replacement_dict = { \"hello\": \"hi\" };\n    const expected_output = \"hi world\";\n\n    const result = replaceWordsInFile(file_path, replacement_dict);\n    expect(result).toBe(expected_output);\n  });\n\n  it('should replace multiple words', () => {\n    const file_path = \"dummy_path.txt\";\n    const replacement_dict = { \"hello\": \"hi\", \"world\": \"earth\" };\n    const expected_output = \"hi earth\";\n\n    const result = replaceWordsInFile(file_path, replacement_dict);\n    expect(result).toBe(expected_output);\n  });\n\n  it('should not replace any words when no matching keys are present', () => {\n    const file_path = \"dummy_path.txt\";\n    const replacement_dict = { \"goodbye\": \"bye\" };\n    const expected_output = \"hello world\";\n\n    const result = replaceWordsInFile(file_path, replacement_dict);\n    expect(result).toBe(expected_output);\n  });\n\n  it('should handle an empty file', () => {\n    const file_path = \"dummy_path.txt\";\n    const replacement_dict = { \"hello\": \"hi\" };\n    const expected_output = \"\";\n\n    jest.spyOn(fs, 'readFileSync').mockImplementation(() => \"\");\n    const result = replaceWordsInFile(file_path, replacement_dict);\n    expect(result).toBe(expected_output);\n  });\n});", "prompt": "please write a typescript function , the function signature as below import fs from 'fs';\n\n/**\n * Read a text file, replace words according to a dictionary map, and return the modified text.\n *\n * @param filePath - The path to the text file.\n * @param replacementDict - A dictionary where the keys are words to be replaced, and the values are the replacement words.\n * @returns The text with the words replaced or an error message.\n */\nfunction replaceWordsInFile(filePath: string, replacementDict: { [key: string]: string }): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads a text file, replaces words according to a dictionary map, and returns the modified text.\n *\n * @param file_path The path to the text file to be processed.\n * @param replacement_dict A dictionary where the keys are words to be replaced, \n *        and the values are the corresponding replacement words.\n * @return A string containing the text with the words replaced according to the dictionary.\n */\nstd::string replace_words_in_file(const std::string& file_path, const std::unordered_map<std::string, std::string>& replacement_dict) {}", "test_code": "TEST_CASE(\"Test replace_words_in_file\") {\n    SECTION(\"test_replace_single_word\") {\n        const std::string file_path = \"dummy_path.txt\";\n        const std::unordered_map<std::string, std::string> replacement_dict = {{\"hello\", \"hi\"}};\n        const std::string expected_output = \"hi world\";\n\n        // Mock file content\n        std::istringstream mock_file_content(\"hello world\");\n\n        // Redirect file stream to mock file content\n        std::istringstream original_cin(std::cin.rdbuf());\n        std::cin.rdbuf(mock_file_content.rdbuf());\n\n        std::string result = replace_words_in_file(file_path, replacement_dict);\n\n        // Restore original file stream\n        std::cin.rdbuf(original_cin.rdbuf());\n\n        REQUIRE(result == expected_output);\n    }\n\n    SECTION(\"test_replace_multiple_words\") {\n        const std::string file_path = \"dummy_path.txt\";\n        const std::unordered_map<std::string, std::string> replacement_dict = {{\"hello\", \"hi\"}, {\"world\", \"earth\"}};\n        const std::string expected_output = \"hi earth\";\n\n        // Mock file content\n        std::istringstream mock_file_content(\"hello world\");\n\n        // Redirect file stream to mock file content\n        std::istringstream original_cin(std::cin.rdbuf());\n        std::cin.rdbuf(mock_file_content.rdbuf());\n\n        std::string result = replace_words_in_file(file_path, replacement_dict);\n\n        // Restore original file stream\n        std::cin.rdbuf(original_cin.rdbuf());\n\n        REQUIRE(result == expected_output);\n    }\n\n    SECTION(\"test_no_replacement\") {\n        const std::string file_path = \"dummy_path.txt\";\n        const std::unordered_map<std::string, std::string> replacement_dict = {{\"goodbye\", \"bye\"}};\n        const std::string expected_output = \"hello world\";\n\n        // Mock file content\n        std::istringstream mock_file_content(\"hello world\");\n\n        // Redirect file stream to mock file content\n        std::istringstream original_cin(std::cin.rdbuf());\n        std::cin.rdbuf(mock_file_content.rdbuf());\n\n        std::string result = replace_words_in_file(file_path, replacement_dict);\n\n        // Restore original file stream\n        std::cin.rdbuf(original_cin.rdbuf());\n\n        REQUIRE(result == expected_output);\n    }\n\n    SECTION(\"test_empty_file\") {\n        const std::string file_path = \"dummy_path.txt\";\n        const std::unordered_map<std::string, std::string> replacement_dict = {{\"hello\", \"hi\"}};\n        const std::string expected_output = \"\";\n\n        // Mock file content\n        std::istringstream mock_file_content(\"\");\n\n        // Redirect file stream to mock file content\n        std::istringstream original_cin(std::cin.rdbuf());\n        std::cin.rdbuf(mock_file_content.rdbuf());\n\n        std::string result = replace_words_in_file(file_path, replacement_dict);\n\n        // Restore original file stream\n        std::cin.rdbuf(original_cin.rdbuf());\n\n        REQUIRE(result == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads a text file, replaces words according to a dictionary map, and returns the modified text.\n *\n * @param file_path The path to the text file to be processed.\n * @param replacement_dict A dictionary where the keys are words to be replaced, \n *        and the values are the corresponding replacement words.\n * @return A string containing the text with the words replaced according to the dictionary.\n */\nstd::string replace_words_in_file(const std::string& file_path, const std::unordered_map<std::string, std::string>& replacement_dict) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads a text file, replaces words according to a dictionary map, and returns the modified text.\n *\n * @param filePath The path to the text file.\n * @param replacementMap A map where the keys are words to be replaced, and the values are the replacement words.\n * @return The text with the words replaced or an error message if an exception occurs.\n */\npublic static String replaceWordsInFile(String filePath, Map<String, String> replacementMap) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\nimport org.mockito.stubbing.Answer;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.util.Map;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.when;\nimport static org.real.temp.Answer.*;\n@RunWith(MockitoJUnitRunner.class)\npublic class Tester {\n\n    @InjectMocks\n    private Answer answer; // This seems to be incorrectly used; please verify your intended use\n\n    @Mock\n    private BufferedReader mockReader;\n\n    @Test\n    public void testReplaceSingleWord() throws IOException {\n        String fileContent = \"hello world\";\n        String file_path = \"dummy_path.txt\";\n        Map<String, String> replacementDict = Map.of(\"hello\", \"hi\");\n        String expectedOutput = \"hi world\";\n\n        when(mockReader.readLine()).thenReturn(fileContent, null);\n\n        String result = replaceWordsInFile(file_path, replacementDict);\n        assertEquals(expectedOutput, result);\n    }\n\n    @Test\n    public void testReplaceMultipleWords() throws IOException {\n        String fileContent = \"hello world\";\n        String file_path = \"dummy_path.txt\";\n        Map<String, String> replacementDict = Map.of(\"hello\", \"hi\", \"world\", \"earth\");\n        String expectedOutput = \"hi earth\";\n\n        when(mockReader.readLine()).thenReturn(fileContent, null);\n\n        String result = replaceWordsInFile(file_path, replacementDict);\n        assertEquals(expectedOutput, result);\n    }\n\n    @Test\n    public void testNoReplacement() throws IOException {\n        String fileContent = \"hello world\";\n        String file_path = \"dummy_path.txt\";\n        Map<String, String> replacementDict = Map.of(\"goodbye\", \"bye\");\n        String expectedOutput = \"hello world\";\n\n        when(mockReader.readLine()).thenReturn(fileContent, null);\n\n        String result = replaceWordsInFile(file_path, replacementDict);\n        assertEquals(expectedOutput, result);\n    }\n\n    @Test\n    public void testEmptyFile() throws IOException {\n        String fileContent = \"\";\n        String file_path = \"dummy_path.txt\";\n        Map<String, String> replacementDict = Map.of(\"hello\", \"hi\");\n        String expectedOutput = \"\";\n\n        when(mockReader.readLine()).thenReturn(fileContent, null);\n\n        String result = replaceWordsInFile(file_path, replacementDict);\n        assertEquals(expectedOutput, result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Reads a text file, replaces words according to a dictionary map, and returns the modified text.\n *\n * @param filePath The path to the text file.\n * @param replacementMap A map where the keys are words to be replaced, and the values are the replacement words.\n * @return The text with the words replaced or an error message if an exception occurs.\n */\npublic static String replaceWordsInFile(String filePath, Map<String, String> replacementMap) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 216, "code_type": "method", "original_language": "python", "question_type": "Network requests and API call", "summary": "gets the IPv4 address of the local computer on a specific network interface, such as wlan0, which is usually a wireless network interface\n", "language_version_list": {"python": {"code_signature": "import re\nimport subprocess\n\n\ndef get_local_ip(interface: str = 'wlan0') -> str:\n    \"\"\"\n    gets the IPv4 address of the local computer on a specific network interface, such as wlan0, which is usually a wireless network interface\n    Args:\n        interface (str): The network interface to query. Default is 'wlan0'.\n\n    Returns:\n        str: The local IP address, or a message indicating no IP was found.\n    \"\"\"", "test_code": "import unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass TestGetLocalIp(unittest.TestCase):\n    def setUp(self):\n        # Sample IP command output for a wlan0 interface\n        self.sample_output = \"3: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\\n\" \\\n                             \"    inet 192.168.1.100/24 brd 192.168.1.255 scope global dynamic wlan0\\n\" \\\n                             \"       valid_lft 86394sec preferred_lft 86394sec\\n\"\n\n    @patch('subprocess.run')\n    def test_successful_ip_retrieval(self, mock_run):\n        # Configure the mock to return a successful output\n        mock_run.return_value = MagicMock(stdout=self.sample_output, check=True)\n        # Test function with wlan0 interface\n        ip = get_local_ip('wlan0')\n        self.assertEqual(ip, '192.168.1.100')\n\n    @patch('subprocess.run')\n    def test_command_failure(self, mock_run):\n        # Simulate a subprocess failure\n        mock_run.side_effect = subprocess.CalledProcessError(1, ['ip', 'addr', 'show', 'wlan0'])\n        self.assertRaises(Exception)\n    @patch('subprocess.run')\n    def test_different_interface(self, mock_run):\n        # Configure the mock for a different interface\n        mock_run.return_value = MagicMock(\n            stdout=\"3: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500\\n    inet 10.0.0.1/24\", check=True)\n        ip = get_local_ip('eth0')\n        self.assertEqual(ip, '10.0.0.1')", "prompt": "please write a python function , the function signature as below import re\nimport subprocess\n\n\ndef get_local_ip(interface: str = 'wlan0') -> str:\n    \"\"\"\n    gets the IPv4 address of the local computer on a specific network interface, such as wlan0, which is usually a wireless network interface\n    Args:\n        interface (str): The network interface to query. Default is 'wlan0'.\n\n    Returns:\n        str: The local IP address, or a message indicating no IP was found.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 219, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Check the incoming list of records(eg ('AAPL', '2023-09-01', 0.22),) such as this for the presence of ticker symbols with the same ex-dividend date, but for amounts of different dividend amounts", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef check_dividend_variances(records: List) -> List:\n    \"\"\"\n    Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n    Args:\n        records (List): Each tuple contains (ticker, ex_dividend_date, dividend_amount).\n\n    Returns:\n        List: Each tuple contains (ticker, ex_dividend_date) that have different dividend amounts.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCheckDividendVariances(unittest.TestCase):\n\n    def test_no_inconsistencies(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22),\n            ('AAPL', '2023-09-01', 0.22),\n            ('MSFT', '2023-09-01', 0.56),\n            ('GOOG', '2023-09-02', 0.00)\n        ]\n        expected_output = []\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_one_inconsistency(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22),\n            ('AAPL', '2023-09-01', 0.23),  # Different amount\n            ('MSFT', '2023-09-01', 0.56),\n            ('GOOG', '2023-09-02', 0.00)\n        ]\n        expected_output = [('AAPL', '2023-09-01')]\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_multiple_inconsistencies(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22),\n            ('AAPL', '2023-09-01', 0.23),  # Different amount\n            ('MSFT', '2023-09-01', 0.56),\n            ('MSFT', '2023-09-01', 0.60),  # Different amount\n            ('GOOG', '2023-09-02', 0.00),\n            ('TSLA', '2023-09-03', 0.10),\n            ('TSLA', '2023-09-03', 0.10),  # Same amount, no inconsistency\n            ('TSLA', '2023-09-03', 0.15)  # Different amount\n        ]\n        expected_output = [('AAPL', '2023-09-01'), ('MSFT', '2023-09-01'), ('TSLA', '2023-09-03')]\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_single_record(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22)\n        ]\n        expected_output = []\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_empty_list(self):\n        records = []\n        expected_output = []\n        self.assertEqual(check_dividend_variances(records), expected_output)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef check_dividend_variances(records: List) -> List:\n    \"\"\"\n    Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n    Args:\n        records (List): Each tuple contains (ticker, ex_dividend_date, dividend_amount).\n\n    Returns:\n        List: Each tuple contains (ticker, ex_dividend_date) that have different dividend amounts.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n * @param {Array} records - An array of arrays, where each inner array contains [ticker, exDividendDate, dividendAmount].\n * @returns {Array} An array of arrays, where each inner array contains [ticker, exDividendDate] that have different dividend amounts.\n */\nfunction checkDividendVariances(records) {}", "test_code": "describe('TestCheckDividendVariances', () => {\n    it('should handle no inconsistencies', () => {\n        const records = [\n            ['AAPL', '2023-09-01', 0.22],\n            ['AAPL', '2023-09-01', 0.22],\n            ['MSFT', '2023-09-01', 0.56],\n            ['GOOG', '2023-09-02', 0.00]\n        ];\n        const expectedOutput = [];\n        expect(checkDividendVariances(records)).toEqual(expectedOutput);\n    });\n\n    it('should handle one inconsistency', () => {\n        const records = [\n            ['AAPL', '2023-09-01', 0.22],\n            ['AAPL', '2023-09-01', 0.23],  // Different amount\n            ['MSFT', '2023-09-01', 0.56],\n            ['GOOG', '2023-09-02', 0.00]\n        ];\n        const expectedOutput = [['AAPL', '2023-09-01']];\n        expect(checkDividendVariances(records)).toEqual(expectedOutput);\n    });\n\n    it('should handle multiple inconsistencies', () => {\n        const records = [\n            ['AAPL', '2023-09-01', 0.22],\n            ['AAPL', '2023-09-01', 0.23],  // Different amount\n            ['MSFT', '2023-09-01', 0.56],\n            ['MSFT', '2023-09-01', 0.60],  // Different amount\n            ['GOOG', '2023-09-02', 0.00],\n            ['TSLA', '2023-09-03', 0.10],\n            ['TSLA', '2023-09-03', 0.10],  // Same amount, no inconsistency\n            ['TSLA', '2023-09-03', 0.15]  // Different amount\n        ];\n        const expectedOutput = [['AAPL', '2023-09-01'], ['MSFT', '2023-09-01'], ['TSLA', '2023-09-03']];\n        expect(checkDividendVariances(records)).toEqual(expectedOutput);\n    });\n\n    it('should handle a single record', () => {\n        const records = [\n            ['AAPL', '2023-09-01', 0.22]\n        ];\n        const expectedOutput = [];\n        expect(checkDividendVariances(records)).toEqual(expectedOutput);\n    });\n\n    it('should handle an empty list', () => {\n        const records = [];\n        const expectedOutput = [];\n        expect(checkDividendVariances(records)).toEqual(expectedOutput);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n * @param {Array} records - An array of arrays, where each inner array contains [ticker, exDividendDate, dividendAmount].\n * @returns {Array} An array of arrays, where each inner array contains [ticker, exDividendDate] that have different dividend amounts.\n */\nfunction checkDividendVariances(records) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n * \n * @param records - An array of tuples, where each tuple contains (ticker, exDividendDate, dividendAmount).\n * @returns An array of tuples, where each tuple contains (ticker, exDividendDate) that have different dividend amounts.\n */\nfunction checkDividendVariances(records: [string, string, number][]): [string, string][] {}", "test_code": "describe('TestCheckDividendVariances', () => {\n  it('should handle no inconsistencies', () => {\n      const records = [\n          ['AAPL', '2023-09-01', 0.22],\n          ['AAPL', '2023-09-01', 0.22],\n          ['MSFT', '2023-09-01', 0.56],\n          ['GOOG', '2023-09-02', 0.00]\n      ];\n      const expectedOutput: [string, string][] = [];\n      expect(checkDividendVariances(records)).toEqual(expectedOutput);\n  });\n\n  it('should handle one inconsistency', () => {\n      const records = [\n          ['AAPL', '2023-09-01', 0.22],\n          ['AAPL', '2023-09-01', 0.23],  // Different amount\n          ['MSFT', '2023-09-01', 0.56],\n          ['GOOG', '2023-09-02', 0.00]\n      ];\n      const expectedOutput: [string, string][] = [['AAPL', '2023-09-01']];\n      expect(checkDividendVariances(records)).toEqual(expectedOutput);\n  });\n\n  it('should handle multiple inconsistencies', () => {\n      const records = [\n          ['AAPL', '2023-09-01', 0.22],\n          ['AAPL', '2023-09-01', 0.23],  // Different amount\n          ['MSFT', '2023-09-01', 0.56],\n          ['MSFT', '2023-09-01', 0.60],  // Different amount\n          ['GOOG', '2023-09-02', 0.00],\n          ['TSLA', '2023-09-03', 0.10],\n          ['TSLA', '2023-09-03', 0.10],  // Same amount, no inconsistency\n          ['TSLA', '2023-09-03', 0.15]  // Different amount\n      ];\n      const expectedOutput: [string, string][] = [['AAPL', '2023-09-01'], ['MSFT', '2023-09-01'], ['TSLA', '2023-09-03']];\n      expect(checkDividendVariances(records)).toEqual(expectedOutput);\n  });\n\n  it('should handle a single record', () => {\n      const records = [\n          ['AAPL', '2023-09-01', 0.22]\n      ];\n      const expectedOutput: [string, string][] = [];\n      expect(checkDividendVariances(records)).toEqual(expectedOutput);\n  });\n\n  it('should handle an empty list', () => {\n      const records: [string, string, number][] = [];\n      const expectedOutput: [string, string][] = [];\n      expect(checkDividendVariances(records)).toEqual(expectedOutput);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n * \n * @param records - An array of tuples, where each tuple contains (ticker, exDividendDate, dividendAmount).\n * @returns An array of tuples, where each tuple contains (ticker, exDividendDate) that have different dividend amounts.\n */\nfunction checkDividendVariances(records: [string, string, number][]): [string, string][] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n *\n * @param records A vector of tuples, where each tuple contains (ticker, ex_dividend_date, dividend_amount).\n * @return A vector of pairs, where each pair contains (ticker, ex_dividend_date) that have different dividend amounts.\n */\nstd::vector<std::pair<std::string, std::string>> checkDividendVariances(const std::vector<std::tuple<std::string, std::string, int>>& records) {}", "test_code": "TEST_CASE(\"Test checkDividendVariances function\", \"[checkDividendVariances]\") {\n    SECTION(\"No inconsistencies\") {\n        std::vector<std::tuple<std::string, std::string, int>> records = {\n            {\"AAPL\", \"2023-09-01\", 22},\n            {\"AAPL\", \"2023-09-01\", 22},\n            {\"MSFT\", \"2023-09-01\", 56},\n            {\"GOOG\", \"2023-09-02\", 0}\n        };\n        std::vector<std::pair<std::string, std::string>> expected_output = {};\n        REQUIRE(checkDividendVariances(records) == expected_output);\n    }\n\n    SECTION(\"One inconsistency\") {\n        std::vector<std::tuple<std::string, std::string, int>> records = {\n            {\"AAPL\", \"2023-09-01\", 22},\n            {\"AAPL\", \"2023-09-01\", 23},  // Different amount\n            {\"MSFT\", \"2023-09-01\", 56},\n            {\"GOOG\", \"2023-09-02\", 0}\n        };\n        std::vector<std::pair<std::string, std::string>> expected_output = {{\"AAPL\", \"2023-09-01\"}};\n        REQUIRE(checkDividendVariances(records) == expected_output);\n    }\n\n    SECTION(\"Multiple inconsistencies\") {\n        std::vector<std::tuple<std::string, std::string, int>> records = {\n            {\"AAPL\", \"2023-09-01\", 22},\n            {\"AAPL\", \"2023-09-01\", 23},  // Different amount\n            {\"MSFT\", \"2023-09-01\", 56},\n            {\"MSFT\", \"2023-09-01\", 60},  // Different amount\n            {\"GOOG\", \"2023-09-02\", 0},\n            {\"TSLA\", \"2023-09-03\", 10},\n            {\"TSLA\", \"2023-09-03\", 10},  // Same amount, no inconsistency\n            {\"TSLA\", \"2023-09-03\", 15}  // Different amount\n        };\n        std::vector<std::pair<std::string, std::string>> expected_output = {\n            {\"AAPL\", \"2023-09-01\"},\n            {\"MSFT\", \"2023-09-01\"},\n            {\"TSLA\", \"2023-09-03\"}\n        };\n        REQUIRE(checkDividendVariances(records) == expected_output);\n    }\n\n    SECTION(\"Single record\") {\n        std::vector<std::tuple<std::string, std::string, int>> records = {\n            {\"AAPL\", \"2023-09-01\", 22}\n        };\n        std::vector<std::pair<std::string, std::string>> expected_output = {};\n        REQUIRE(checkDividendVariances(records) == expected_output);\n    }\n\n    SECTION(\"Empty list\") {\n        std::vector<std::tuple<std::string, std::string, int>> records = {};\n        std::vector<std::pair<std::string, std::string>> expected_output = {};\n        REQUIRE(checkDividendVariances(records) == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n *\n * @param records A vector of tuples, where each tuple contains (ticker, ex_dividend_date, dividend_amount).\n * @return A vector of pairs, where each pair contains (ticker, ex_dividend_date) that have different dividend amounts.\n */\nstd::vector<std::pair<std::string, std::string>> checkDividendVariances(const std::vector<std::tuple<std::string, std::string, int>>& records) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n * \n * @param records A list of tuples where each tuple contains (ticker, exDividendDate, dividendAmount).\n * @return A list of tuples where each tuple contains (ticker, exDividendDate) that have different dividend amounts.\n */\npublic static class Tuple<T1, T2> {\n    private T1 first;\n    private T2 second;\n\n    public Tuple(T1 first, T2 second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public T1 getFirst() {\n        return first;\n    }\n\n    public T2 getSecond() {\n        return second;\n    }\n}\npublic static List<Tuple<String, String>> checkDividendVariances(List<Tuple<String, String, Integer>> records) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Tester {\n\n    /**\n     * Test case for no inconsistencies in the records.\n     */\n    @Test\n    public void testNoInconsistencies() {\n        List<Tuple<String, String, Double>> records = new ArrayList<>();\n        records.add(new Tuple<>(\"AAPL\", \"2023-09-01\", 0.22));\n        records.add(new Tuple<>(\"AAPL\", \"2023-09-01\", 0.22));\n        records.add(new Tuple<>(\"MSFT\", \"2023-09-01\", 0.56));\n        records.add(new Tuple<>(\"GOOG\", \"2023-09-02\", 0.00));\n\n        List<Tuple<String, String>> expectedOutput = new ArrayList<>();\n        List<Tuple<String, String>> actualOutput = checkDividendVariances(records);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    /**\n     * Test case for one inconsistency in the records.\n     */\n    @Test\n    public void testOneInconsistency() {\n        List<Tuple<String, String, Double>> records = new ArrayList<>();\n        records.add(new Tuple<>(\"AAPL\", \"2023-09-01\", 0.22));\n        records.add(new Tuple<>(\"AAPL\", \"2023-09-01\", 0.23));  // Different amount\n        records.add(new Tuple<>(\"MSFT\", \"2023-09-01\", 0.56));\n        records.add(new Tuple<>(\"GOOG\", \"2023-09-02\", 0.00));\n\n        List<Tuple<String, String>> expectedOutput = new ArrayList<>();\n        expectedOutput.add(new Tuple<>(\"AAPL\", \"2023-09-01\"));\n        List<Tuple<String, String>> actualOutput = checkDividendVariances(records);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    /**\n     * Test case for multiple inconsistencies in the records.\n     */\n    @Test\n    public void testMultipleInconsistencies() {\n        List<Tuple<String, String, Double>> records = new ArrayList<>();\n        records.add(new Tuple<>(\"AAPL\", \"2023-09-01\", 0.22));\n        records.add(new Tuple<>(\"AAPL\", \"2023-09-01\", 0.23));  // Different amount\n        records.add(new Tuple<>(\"MSFT\", \"2023-09-01\", 0.56));\n        records.add(new Tuple<>(\"MSFT\", \"2023-09-01\", 0.60));  // Different amount\n        records.add(new Tuple<>(\"GOOG\", \"2023-09-02\", 0.00));\n        records.add(new Tuple<>(\"TSLA\", \"2023-09-03\", 0.10));\n        records.add(new Tuple<>(\"TSLA\", \"2023-09-03\", 0.10));  // Same amount, no inconsistency\n        records.add(new Tuple<>(\"TSLA\", \"2023-09-03\", 0.15));  // Different amount\n\n        List<Tuple<String, String>> expectedOutput = new ArrayList<>();\n        expectedOutput.add(new Tuple<>(\"AAPL\", \"2023-09-01\"));\n        expectedOutput.add(new Tuple<>(\"MSFT\", \"2023-09-01\"));\n        expectedOutput.add(new Tuple<>(\"TSLA\", \"2023-09-03\"));\n        List<Tuple<String, String>> actualOutput = checkDividendVariances(records);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    /**\n     * Test case for a single record.\n     */\n    @Test\n    public void testSingleRecord() {\n        List<Tuple<String, String, Double>> records = new ArrayList<>();\n        records.add(new Tuple<>(\"AAPL\", \"2023-09-01\", 0.22));\n\n        List<Tuple<String, String>> expectedOutput = new ArrayList<>();\n        List<Tuple<String, String>> actualOutput = checkDividendVariances(records);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    /**\n     * Test case for an empty list of records.\n     */\n    @Test\n    public void testEmptyList() {\n        List<Tuple<String, String, Double>> records = new ArrayList<>();\n\n        List<Tuple<String, String>> expectedOutput = new ArrayList<>();\n        List<Tuple<String, String>> actualOutput = checkDividendVariances(records);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    // Helper class to represent a tuple\n    public static class Tuple<T1, T2, T3> {\n        private T1 first;\n        private T2 second;\n        private T3 third;\n\n        public Tuple(T1 first, T2 second, T3 third) {\n            this.first = first;\n            this.second = second;\n            this.third = third;\n        }\n\n        public T1 getFirst() {\n            return first;\n        }\n\n        public T2 getSecond() {\n            return second;\n        }\n\n        public T3 getThird() {\n            return third;\n        }\n    }\n\n    // Helper class to represent a tuple with two elements\n    public static class Tuple<T1, T2> {\n        private T1 first;\n        private T2 second;\n\n        public Tuple(T1 first, T2 second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public T1 getFirst() {\n            return first;\n        }\n\n        public T2 getSecond() {\n            return second;\n        }\n    }\n\n    // Method to check for dividend variances\n    public static List<Tuple<String, String>> checkDividendVariances(List<Tuple<String, String, Double>> records) {\n        // Map to store dividend amounts by (ticker, exDividendDate)\n        Map<Tuple<String, String>, Set<Double>> dividendMap = new HashMap<>();\n\n        // Iterate through the records\n        for (Tuple<String, String, Double> record : records) {\n            String ticker = record.getFirst();\n            String exDividendDate = record.getSecond();\n            double dividendAmount = record.getThird();\n\n            Tuple<String, String> key = new Tuple<>(ticker, exDividendDate);\n            dividendMap.computeIfAbsent(key, k -> new HashSet<>()).add(dividendAmount);\n        }\n\n        // Find entries with more than one unique dividend amount\n        List<Tuple<String, String>> result = new ArrayList<>();\n        for (Map.Entry<Tuple<String, String>, Set<Double>> entry : dividendMap.entrySet()) {\n            if (entry.getValue().size() > 1) {\n                result.add(entry.getKey());\n            }\n        }\n\n        return result;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n * \n * @param records A list of tuples where each tuple contains (ticker, exDividendDate, dividendAmount).\n * @return A list of tuples where each tuple contains (ticker, exDividendDate) that have different dividend amounts.\n */\npublic static class Tuple<T1, T2> {\n    private T1 first;\n    private T2 second;\n\n    public Tuple(T1 first, T2 second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public T1 getFirst() {\n        return first;\n    }\n\n    public T2 getSecond() {\n        return second;\n    }\n}\npublic static List<Tuple<String, String>> checkDividendVariances(List<Tuple<String, String, Integer>> records) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 220, "code_type": "class", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Using double-ended queues and collections to implement a data structure without duplicate data, add, delete and query operations", "language_version_list": {"python": {"code_signature": "from collections import deque\n\n\nclass UniqueDeque:\n\n    def add(self, item):\n        \"\"\"\n        Add an item to the deque if it is not already present.\n\n        Parameters:\n        - item: The item to add.\n\n        Returns:\n        - bool: True if the item was added, False if it was already present.\n        \"\"\"\n        pass\n\n    def delete(self, item):\n        \"\"\"\n        Remove an item from the deque if it exists.\n\n        Parameters:\n        - item: The item to remove.\n\n        Returns:\n        - bool: True if the item was removed, False if it was not found.\n        \"\"\"\n        pass\n\n    def contains(self, item):\n        \"\"\"\n        Check if an item is present in the deque.\n\n        Parameters:\n        - item: The item to check.\n\n        Returns:\n        - bool: True if the item is present, False otherwise.\n        \"\"\"\n        pass\n\n    def __len__(self):\n        \"\"\"\n        Get the number of elements in the deque.\n\n        Returns:\n        - int: The number of unique elements in the deque.\n        \"\"\"\n\n    def __iter__(self):\n        \"\"\"\n        Create an iterator for the deque.\n\n        Returns:\n        - iterator: An iterator over the elements in the deque.\n        \"\"\"\n", "test_code": "import unittest\nfrom collections import deque\n\nclass TestUniqueDeque(unittest.TestCase):\n\n    def test_add_unique_elements(self):\n        ud = UniqueDeque()\n        self.assertTrue(ud.add(1))\n        self.assertTrue(ud.add(2))\n        self.assertTrue(ud.add(3))\n        self.assertEqual(len(ud), 3)\n        self.assertEqual(list(ud), [1, 2, 3])\n\n    def test_add_duplicate_elements(self):\n        ud = UniqueDeque()\n        self.assertTrue(ud.add(1))\n        self.assertFalse(ud.add(1))  # Duplicate add should return False\n        self.assertEqual(len(ud), 1)\n        self.assertEqual(list(ud), [1])\n\n    def test_delete_elements(self):\n        ud = UniqueDeque()\n        ud.add(1)\n        ud.add(2)\n        ud.add(3)\n        self.assertTrue(ud.delete(2))\n        self.assertFalse(ud.delete(2))  # Deleting non-existing element should return False\n        self.assertEqual(len(ud), 2)\n        self.assertEqual(list(ud), [1, 3])\n\n    def test_contains(self):\n        ud = UniqueDeque()\n        ud.add(1)\n        self.assertTrue(ud.contains(1))\n        self.assertFalse(ud.contains(2))\n        ud.delete(1)\n        self.assertFalse(ud.contains(1))\n\n    def test_iter_and_len(self):\n        ud = UniqueDeque()\n        ud.add(1)\n        ud.add(2)\n        self.assertEqual(len(ud), 2)\n        items = list(iter(ud))\n        self.assertEqual(items, [1, 2])\n        ud.delete(1)\n        self.assertEqual(len(ud), 1)\n        self.assertEqual(list(ud), [2])", "prompt": "please write a python class , the class signature as below from collections import deque\n\n\nclass UniqueDeque:\n\n    def add(self, item):\n        \"\"\"\n        Add an item to the deque if it is not already present.\n\n        Parameters:\n        - item: The item to add.\n\n        Returns:\n        - bool: True if the item was added, False if it was already present.\n        \"\"\"\n        pass\n\n    def delete(self, item):\n        \"\"\"\n        Remove an item from the deque if it exists.\n\n        Parameters:\n        - item: The item to remove.\n\n        Returns:\n        - bool: True if the item was removed, False if it was not found.\n        \"\"\"\n        pass\n\n    def contains(self, item):\n        \"\"\"\n        Check if an item is present in the deque.\n\n        Parameters:\n        - item: The item to check.\n\n        Returns:\n        - bool: True if the item is present, False otherwise.\n        \"\"\"\n        pass\n\n    def __len__(self):\n        \"\"\"\n        Get the number of elements in the deque.\n\n        Returns:\n        - int: The number of unique elements in the deque.\n        \"\"\"\n\n    def __iter__(self):\n        \"\"\"\n        Create an iterator for the deque.\n\n        Returns:\n        - iterator: An iterator over the elements in the deque.\n        \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "class UniqueDeque {\n    constructor() {\n      /**\n       * Initialize a UniqueDeque object using an array and a Set.\n       * The array stores elements in order, while the Set ensures uniqueness.\n       */\n      this._array = [];\n      this._set = new Set();\n    }\n  \n    /**\n     * Add an item to the deque if it is not already present.\n     *\n     * @param {*} item - The item to add.\n     * @returns {boolean} - True if the item was added, False if it was already present.\n     */\n    add(item) {\n    }\n  \n    /**\n     * Remove an item from the deque if it exists.\n     *\n     * @param {*} item - The item to remove.\n     * @returns {boolean} - True if the item was removed, False if it was not found.\n     */\n    delete(item) {\n    }\n  \n    /**\n     * Check if an item is present in the deque.\n     *\n     * @param {*} item - The item to check.\n     * @returns {boolean} - True if the item is present, False otherwise.\n     */\n    contains(item) {\n    }\n  \n    /**\n     * Get the number of elements in the deque.\n     *\n     * @returns {number} - The number of unique elements in the deque.\n     */\n    get length() {\n    }\n  \n    /**\n     * Create an iterator for the deque.\n     *\n     * @returns {Iterator} - An iterator over the elements in the deque.\n     */\n    *[Symbol.iterator]() {\n      for (const item of this._array) {\n        yield item;\n      }\n    }\n  }", "test_code": "describe('TestUniqueDeque', () => {\n  describe('test_add_unique_elements', () => {\n    it('should add unique elements and maintain the correct size and order', () => {\n      const ud = new UniqueDeque();\n      expect(ud.add(1)).toBe(true);\n      expect(ud.add(2)).toBe(true);\n      expect(ud.add(3)).toBe(true);\n      expect(ud.length).toBe(3);\n      expect([...ud]).toEqual([1, 2, 3]);\n    });\n  });\n\n  describe('test_add_duplicate_elements', () => {\n    it('should handle duplicate adds correctly', () => {\n      const ud = new UniqueDeque();\n      expect(ud.add(1)).toBe(true);\n      expect(ud.add(1)).toBe(false); // Duplicate add should return false\n      expect(ud.length).toBe(1);\n      expect([...ud]).toEqual([1]);\n    });\n  });\n\n  describe('test_delete_elements', () => {\n    it('should delete elements correctly', () => {\n      const ud = new UniqueDeque();\n      ud.add(1);\n      ud.add(2);\n      ud.add(3);\n      expect(ud.delete(2)).toBe(true);\n      expect(ud.delete(2)).toBe(false); // Deleting non-existing element should return false\n      expect(ud.length).toBe(2);\n      expect([...ud]).toEqual([1, 3]);\n    });\n  });\n\n  describe('test_contains', () => {\n    it('should check if elements are contained correctly', () => {\n      const ud = new UniqueDeque();\n      ud.add(1);\n      expect(ud.contains(1)).toBe(true);\n      expect(ud.contains(2)).toBe(false);\n      ud.delete(1);\n      expect(ud.contains(1)).toBe(false);\n    });\n  });\n\n  describe('test_iter_and_len', () => {\n    it('should iterate and provide correct length', () => {\n      const ud = new UniqueDeque();\n      ud.add(1);\n      ud.add(2);\n      expect(ud.length).toBe(2);\n      const items = [...ud];\n      expect(items).toEqual([1, 2]);\n      ud.delete(1);\n      expect(ud.length).toBe(1);\n      expect([...ud]).toEqual([2]);\n    });\n  });\n});", "prompt": "please write a javascript class , the class signature as below class UniqueDeque {\n    constructor() {\n      /**\n       * Initialize a UniqueDeque object using an array and a Set.\n       * The array stores elements in order, while the Set ensures uniqueness.\n       */\n      this._array = [];\n      this._set = new Set();\n    }\n  \n    /**\n     * Add an item to the deque if it is not already present.\n     *\n     * @param {*} item - The item to add.\n     * @returns {boolean} - True if the item was added, False if it was already present.\n     */\n    add(item) {\n    }\n  \n    /**\n     * Remove an item from the deque if it exists.\n     *\n     * @param {*} item - The item to remove.\n     * @returns {boolean} - True if the item was removed, False if it was not found.\n     */\n    delete(item) {\n    }\n  \n    /**\n     * Check if an item is present in the deque.\n     *\n     * @param {*} item - The item to check.\n     * @returns {boolean} - True if the item is present, False otherwise.\n     */\n    contains(item) {\n    }\n  \n    /**\n     * Get the number of elements in the deque.\n     *\n     * @returns {number} - The number of unique elements in the deque.\n     */\n    get length() {\n    }\n  \n    /**\n     * Create an iterator for the deque.\n     *\n     * @returns {Iterator} - An iterator over the elements in the deque.\n     */\n    *[Symbol.iterator]() {\n      for (const item of this._array) {\n        yield item;\n      }\n    }\n  }", "addition_info": ""}, "typescript": {"code_signature": "import { Deque } from 'collections/deque';\n\nclass UniqueDeque<T> {\n  private deque: Deque<T>;\n  private set: Set<T>;\n\n  constructor() {\n    this.deque = new Deque<T>();\n    this.set = new Set<T>();\n  }\n\n  /**\n   * Add an item to the deque if it is not already present.\n   *\n   * @param item The item to add.\n   * @returns True if the item was added, False if it was already present.\n   */\n  add(item: T): boolean {\n  }\n\n  /**\n   * Remove an item from the deque if it exists.\n   *\n   * @param item The item to remove.\n   * @returns True if the item was removed, False if it was not found.\n   */\n  delete(item: T): boolean {\n  }\n\n  /**\n   * Check if an item is present in the deque.\n   *\n   * @param item The item to check.\n   * @returns True if the item is present, False otherwise.\n   */\n  contains(item: T): boolean {\n  }\n\n  /**\n   * Get the number of elements in the deque.\n   *\n   * @returns The number of unique elements in the deque.\n   */\n  length(): number {\n  }\n\n  /**\n   * Create an iterator for the deque.\n   *\n   * @returns An iterator over the elements in the deque.\n   */\n  *[Symbol.iterator](): Iterator<T> {\n    for (const item of this.deque) {\n      yield item;\n    }\n  }\n}", "test_code": "describe('UniqueDeque', () => {\n    describe('testAddUniqueElements', () => {\n      it('should add unique elements and maintain the correct size and order', () => {\n        const ud = new UniqueDeque<number>();\n        expect(ud.add(1)).toBe(true);\n        expect(ud.add(2)).toBe(true);\n        expect(ud.add(3)).toBe(true);\n        expect(ud.length()).toBe(3);\n        expect(Array.from(ud)).toEqual([1, 2, 3]);\n      });\n    });\n  \n    describe('testAddDuplicateElements', () => {\n      it('should not add duplicate elements and maintain the correct size', () => {\n        const ud = new UniqueDeque<number>();\n        expect(ud.add(1)).toBe(true);\n        expect(ud.add(1)).toBe(false); // Duplicate add should return false\n        expect(ud.length()).toBe(1);\n        expect(Array.from(ud)).toEqual([1]);\n      });\n    });\n  \n    describe('testDeleteElements', () => {\n      it('should delete elements and maintain the correct size and order', () => {\n        const ud = new UniqueDeque<number>();\n        ud.add(1);\n        ud.add(2);\n        ud.add(3);\n        expect(ud.delete(2)).toBe(true);\n        expect(ud.delete(2)).toBe(false); // Deleting non-existing element should return false\n        expect(ud.length()).toBe(2);\n        expect(Array.from(ud)).toEqual([1, 3]);\n      });\n    });\n  \n    describe('testContains', () => {\n      it('should correctly identify the presence of elements', () => {\n        const ud = new UniqueDeque<number>();\n        ud.add(1);\n        expect(ud.contains(1)).toBe(true);\n        expect(ud.contains(2)).toBe(false);\n        ud.delete(1);\n        expect(ud.contains(1)).toBe(false);\n      });\n    });\n  \n    describe('testIterAndLen', () => {\n      it('should correctly iterate and provide the correct length', () => {\n        const ud = new UniqueDeque<number>();\n        ud.add(1);\n        ud.add(2);\n        expect(ud.length()).toBe(2);\n        const items = Array.from(ud);\n        expect(items).toEqual([1, 2]);\n        ud.delete(1);\n        expect(ud.length()).toBe(1);\n        expect(Array.from(ud)).toEqual([2]);\n      });\n    });\n  });", "prompt": "please write a typescript class , the class signature as below import { Deque } from 'collections/deque';\n\nclass UniqueDeque<T> {\n  private deque: Deque<T>;\n  private set: Set<T>;\n\n  constructor() {\n    this.deque = new Deque<T>();\n    this.set = new Set<T>();\n  }\n\n  /**\n   * Add an item to the deque if it is not already present.\n   *\n   * @param item The item to add.\n   * @returns True if the item was added, False if it was already present.\n   */\n  add(item: T): boolean {\n  }\n\n  /**\n   * Remove an item from the deque if it exists.\n   *\n   * @param item The item to remove.\n   * @returns True if the item was removed, False if it was not found.\n   */\n  delete(item: T): boolean {\n  }\n\n  /**\n   * Check if an item is present in the deque.\n   *\n   * @param item The item to check.\n   * @returns True if the item is present, False otherwise.\n   */\n  contains(item: T): boolean {\n  }\n\n  /**\n   * Get the number of elements in the deque.\n   *\n   * @returns The number of unique elements in the deque.\n   */\n  length(): number {\n  }\n\n  /**\n   * Create an iterator for the deque.\n   *\n   * @returns An iterator over the elements in the deque.\n   */\n  *[Symbol.iterator](): Iterator<T> {\n    for (const item of this.deque) {\n      yield item;\n    }\n  }\n}", "addition_info": ""}, "c&cpp": {"code_signature": "class UniqueDeque {\npublic:\n    // Constructor initializes the deque and set.\n    UniqueDeque() : _deque(), _set() {}\n\n    // Add an item to the deque if it is not already present.\n    // Parameters:\n    // - item: The item to add.\n    // Returns:\n    // - bool: True if the item was added, False if it was already present.\n    bool add(const std::string& item) {\n    }\n\n    // Remove an item from the deque if it exists.\n    // Parameters:\n    // - item: The item to remove.\n    // Returns:\n    // - bool: True if the item was removed, False if it was not found.\n    bool deleteItem(const std::.string& item) {\n    }\n\n    // Check if an item is present in the deque.\n    // Parameters:\n    // - item: The item to check.\n    // Returns:\n    // - bool: True if the item is present, False otherwise.\n    bool contains(const std::string& item) const {\n        return _set.find(item) != _set.end();\n    }\n\n    // Get the number of elements in the deque.\n    // Returns:\n    // - int: The number of unique elements in the deque.\n    size_t size() const {\n        return _deque.size();\n    }\n\n    // Create an iterator for the deque.\n    // Returns:\n    // - iterator: An iterator over the elements in the deque.\n    std::deque<std::string>::iterator begin() {\n        return _deque.begin();\n    }\n\n    std::deque<std::string>::const_iterator begin() const {\n        return _deque.begin();\n    }\n\n    std::deque<std::string>::iterator end() {\n        return _deque.end();\n    }\n\n    std::deque<std::string>::const_iterator end() const {\n        return _deque.end();\n    }\n\nprivate:\n    std::deque<std::string> _deque; // Stores elements in order.\n    std::unordered_set<std::string> _set; // Ensures uniqueness.\n};", "test_code": "TEST_CASE(\"TestUniqueDeque\") {\n    SECTION(\"test_add_unique_elements\") {\n        UniqueDeque ud;\n        REQUIRE(ud.add(1));\n        REQUIRE(ud.add(2));\n        REQUIRE(ud.add(3));\n        REQUIRE(ud.size() == 3);\n        std::vector<int> expected = {1, 2, 3};\n        std::vector<int> actual(begin(ud), end(ud));\n        REQUIRE(actual == expected);\n    }\n\n    SECTION(\"test_add_duplicate_elements\") {\n        UniqueDeque ud;\n        REQUIRE(ud.add(1));\n        REQUIRE_FALSE(ud.add(1));  // Duplicate add should return false\n        REQUIRE(ud.size() == 1);\n        std::vector<int> expected = {1};\n        std::vector<int> actual(begin(ud), end(ud));\n        REQUIRE(actual == expected);\n    }\n\n    SECTION(\"test_delete_elements\") {\n        UniqueDeque ud;\n        ud.add(1);\n        ud.add(2);\n        ud.add(3);\n        REQUIRE(ud.deleteItem(2));\n        REQUIRE_FALSE(ud.deleteItem(2));  // Deleting non-existing element should return false\n        REQUIRE(ud.size() == 2);\n        std::vector<int> expected = {1, 3};\n        std::vector<int> actual(begin(ud), end(ud));\n        REQUIRE(actual == expected);\n    }\n\n    SECTION(\"test_contains\") {\n        UniqueDeque ud;\n        ud.add(1);\n        REQUIRE(ud.contains(1));\n        REQUIRE_FALSE(ud.contains(2));\n        ud.deleteItem(1);\n        REQUIRE_FALSE(ud.contains(1));\n    }\n\n    SECTION(\"test_iter_and_len\") {\n        UniqueDeque ud;\n        ud.add(1);\n        ud.add(2);\n        REQUIRE(ud.size() == 2);\n        std::vector<int> expected = {1, 2};\n        std::vector<int> actual(begin(ud), end(ud));\n        REQUIRE(actual == expected);\n        ud.deleteItem(1);\n        REQUIRE(ud.size() == 1);\n        expected = {2};\n        actual = std::vector<int>(begin(ud), end(ud));\n        REQUIRE(actual == expected);\n    }\n}", "prompt": "please write a cpp class , the class signature as below class UniqueDeque {\npublic:\n    // Constructor initializes the deque and set.\n    UniqueDeque() : _deque(), _set() {}\n\n    // Add an item to the deque if it is not already present.\n    // Parameters:\n    // - item: The item to add.\n    // Returns:\n    // - bool: True if the item was added, False if it was already present.\n    bool add(const std::string& item) {\n    }\n\n    // Remove an item from the deque if it exists.\n    // Parameters:\n    // - item: The item to remove.\n    // Returns:\n    // - bool: True if the item was removed, False if it was not found.\n    bool deleteItem(const std::.string& item) {\n    }\n\n    // Check if an item is present in the deque.\n    // Parameters:\n    // - item: The item to check.\n    // Returns:\n    // - bool: True if the item is present, False otherwise.\n    bool contains(const std::string& item) const {\n        return _set.find(item) != _set.end();\n    }\n\n    // Get the number of elements in the deque.\n    // Returns:\n    // - int: The number of unique elements in the deque.\n    size_t size() const {\n        return _deque.size();\n    }\n\n    // Create an iterator for the deque.\n    // Returns:\n    // - iterator: An iterator over the elements in the deque.\n    std::deque<std::string>::iterator begin() {\n        return _deque.begin();\n    }\n\n    std::deque<std::string>::const_iterator begin() const {\n        return _deque.begin();\n    }\n\n    std::deque<std::string>::iterator end() {\n        return _deque.end();\n    }\n\n    std::deque<std::string>::const_iterator end() const {\n        return _deque.end();\n    }\n\nprivate:\n    std::deque<std::string> _deque; // Stores elements in order.\n    std::unordered_set<std::string> _set; // Ensures uniqueness.\n};", "addition_info": ""}, "java": {"code_signature": "public class Answer {\n    static class UniqueDeque{\n        private LinkedList<Integer> deque;\n        private Set<Integer> set;\n\n        public UniqueDeque() {\n\n        }\n\n        public boolean add(int item) {\n\n        }\n\n        public boolean delete(int item) {\n\n        }\n\n        public boolean contains(int item) {\n\n        }\n\n        public int size() {\n\n        }\n\n        public Iterator<Integer> iterator() {\n\n        }\n\n        @Override\n        public String toString() {}\n    }\n}", "test_code": "package org.real.temp;\nimport org.junit.Test;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testAddUniqueElements() {\n        UniqueDeque ud = new UniqueDeque();\n        assertTrue(ud.add(1));\n        assertTrue(ud.add(2));\n        assertTrue(ud.add(3));\n        assertEquals(3, ud.size());\n        Iterator<Integer> iterator = ud.iterator();\n        List<Integer> list = new LinkedList<>();\n        while (iterator.hasNext()) {\n            list.add(iterator.next());\n        }\n        assertEquals(\"[1, 2, 3]\", list.toString());\n    }\n\n    @Test\n    public void testAddDuplicateElements() {\n        UniqueDeque ud = new UniqueDeque();\n        assertTrue(ud.add(1));\n        assertFalse(ud.add(1));  // Duplicate add should return false\n        assertEquals(1, ud.size());\n        Iterator<Integer> iterator = ud.iterator();\n        List<Integer> list = new LinkedList<>();\n        while (iterator.hasNext()) {\n            list.add(iterator.next());\n        }\n        assertEquals(\"[1]\", list.toString());\n    }\n\n    @Test\n    public void testDeleteElements() {\n        UniqueDeque ud = new UniqueDeque();\n        ud.add(1);\n        ud.add(2);\n        ud.add(3);\n        assertTrue(ud.delete(2));\n        assertFalse(ud.delete(2));  // Deleting non-existing element should return false\n        assertEquals(2, ud.size());\n        Iterator<Integer> iterator = ud.iterator();\n        List<Integer> list = new LinkedList<>();\n        while (iterator.hasNext()) {\n            list.add(iterator.next());\n        }\n        assertEquals(\"[1, 3]\", list.toString());\n    }\n\n    @Test\n    public void testContains() {\n        UniqueDeque ud = new UniqueDeque();\n        ud.add(1);\n        assertTrue(ud.contains(1));\n        assertFalse(ud.contains(2));\n        ud.delete(1);\n        assertFalse(ud.contains(1));\n    }\n\n    @Test\n    public void testIterAndLen() {\n        UniqueDeque ud = new UniqueDeque();\n        ud.add(1);\n        ud.add(2);\n        assertEquals(2, ud.size());\n        Iterator<Integer> iterator = ud.iterator();\n        List<Integer> list = new LinkedList<>();\n        while (iterator.hasNext()) {\n            list.add(iterator.next());\n        }\n        assertEquals(\"[1, 2]\", list.toString());\n        ud.delete(1);\n        assertEquals(1, ud.size());\n        iterator = ud.iterator();\n        list.clear();\n        while (iterator.hasNext()) {\n            list.add(iterator.next());\n        }\n        assertEquals(\"[2]\", list.toString());\n    }\n}", "prompt": "please write a java class , the function signature as below public class Answer {\n    static class UniqueDeque{\n        private LinkedList<Integer> deque;\n        private Set<Integer> set;\n\n        public UniqueDeque() {\n\n        }\n\n        public boolean add(int item) {\n\n        }\n\n        public boolean delete(int item) {\n\n        }\n\n        public boolean contains(int item) {\n\n        }\n\n        public int size() {\n\n        }\n\n        public Iterator<Integer> iterator() {\n\n        }\n\n        @Override\n        public String toString() {}\n    }\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 221, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "extract and parse strings containing Python dictionary syntax from a given file\n", "language_version_list": {"python": {"code_signature": "from typing import Dict, List\n\n\ndef extract_parse_dicts(file_path: str) -> List[Dict]:\n    \"\"\"\n    extract and parse strings containing Python dictionary syntax from a given file\n    Args:\n        file_path (str): The path to the file from which to extract dictionary strings.\n\n    Returns:\n        list: A list of dictionaries extracted and parsed from the file.\n    \"\"\"\n", "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestExtractParseDicts(unittest.TestCase):\n    def test_extract_single_valid_dictionary(self):\n        mock_content = '{\"name\": \"John\", \"age\": 30}'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [{\"name\": \"John\", \"age\": 30}])\n\n    def test_extract_multiple_dictionaries(self):\n        mock_content = '{\"name\": \"John\", \"age\": 30}\\n{\"city\": \"New York\", \"country\": \"USA\"}'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [{\"name\": \"John\", \"age\": 30}, {\"city\": \"New York\", \"country\": \"USA\"}])\n\n    def test_invalid_dictionary_format(self):\n        mock_content = '{\"name\": \"John\", \"age\": \"thirty\"}'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [{'name': 'John', 'age': 'thirty'}])\n\n    def test_empty_file(self):\n        with patch('builtins.open', mock_open(read_data='')):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [])\n\n", "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef extract_parse_dicts(file_path: str) -> List[Dict]:\n    \"\"\"\n    extract and parse strings containing Python dictionary syntax from a given file\n    Args:\n        file_path (str): The path to the file from which to extract dictionary strings.\n\n    Returns:\n        list: A list of dictionaries extracted and parsed from the file.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 224, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Empty all files and subdirectories in the specified directory\n", "language_version_list": {"python": {"code_signature": "def empty_directory(directory_path:str):\n    \"\"\"\n    empty all files and subdirectories in the specified directory\n    Args:\n        directory_path (str): Path to the directory whose contents are to be emptied.\n\n    Returns:\n        None or ValueError: If the specified path does not exist or is not a directory.\n    \"\"\"\n", "test_code": "import os\nimport shutil\nimport tempfile\nimport unittest\n\n\nclass TestEmptyDirectory(unittest.TestCase):\n    def setUp(self):\n        # Set up a temporary directory with some files and directories\n        self.test_dir = tempfile.mkdtemp()\n        # Create some files and directories\n        os.mkdir(os.path.join(self.test_dir, 'subdir'))\n        with open(os.path.join(self.test_dir, 'file1.txt'), 'w') as f:\n            f.write(\"Hello\")\n        with open(os.path.join(self.test_dir, 'subdir', 'file2.txt'), 'w') as f:\n            f.write(\"World\")\n\n    def tearDown(self):\n        # Remove the temporary directory after each test.js\n        shutil.rmtree(self.test_dir)\n\n    def test_empty_directory_success(self):\n        \"\"\" Test that the directory is emptied successfully \"\"\"\n        empty_directory(self.test_dir)\n        self.assertEqual(os.listdir(self.test_dir), [])  # Directory should be empty\n\n\n\n    def test_empty_directory_with_subdirectories(self):\n        \"\"\" Test emptying a directory that includes subdirectories \"\"\"\n        empty_directory(self.test_dir)\n        self.assertFalse(os.listdir(self.test_dir))  # Directory and subdirectory should be empty\n\n    def test_empty_already_empty_directory(self):\n        \"\"\" Test emptying a directory that is already empty \"\"\"\n        empty_directory(self.test_dir)  # First emptying\n        empty_directory(self.test_dir)  # Empty again\n        self.assertEqual(os.listdir(self.test_dir), [])  # Still should be empty\n", "prompt": "please write a python function , the function signature as below def empty_directory(directory_path:str):\n    \"\"\"\n    empty all files and subdirectories in the specified directory\n    Args:\n        directory_path (str): Path to the directory whose contents are to be emptied.\n\n    Returns:\n        None or ValueError: If the specified path does not exist or is not a directory.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Empties all files and subdirectories in the specified directory.\n * \n * @param {string} directoryPath - Path to the directory whose contents are to be emptied.\n * \n * @returns {Promise<void>} - A promise that resolves when the operation is complete.\n * \n * @throws {Error} - If the specified path does not exist or is not a directory.\n */\nasync function emptyDirectory(directoryPath) {}", "test_code": "const fs = require('fs');\nconst path = require('path');\nconst { rm, unlink } = require('fs').promises;\nconst { mkdtemp, rmdir } = require('fs').promises;\n\ndescribe('TestEmptyDirectory', () => {\n    let testDir;\n\n    beforeAll(async () => {\n        // Set up a temporary directory with some files and directories\n        testDir = await mkdtemp(path.join(os.tmpdir(), 'test-'));\n        // Create some files and directories\n        await fs.promises.mkdir(path.join(testDir, 'subdir'));\n        await fs.promises.writeFile(path.join(testDir, 'file1.txt'), 'Hello');\n        await fs.promises.writeFile(path.join(testDir, 'subdir', 'file2.txt'), 'World');\n    });\n\n    afterAll(async () => {\n        // Remove the temporary directory after all tests\n        await rmdir(testDir, { recursive: true });\n    });\n\n    it('should empty the directory successfully', async () => {\n        // Test that the directory is emptied successfully\n        await emptyDirectory(testDir);\n        expect(await fs.promises.readdir(testDir)).toEqual([]);\n    });\n\n    it('should empty a directory that includes subdirectories', async () => {\n        // Test emptying a directory that includes subdirectories\n        await emptyDirectory(testDir);\n        expect(await fs.promises.readdir(testDir)).toEqual([]);\n    });\n\n    it('should handle an already empty directory', async () => {\n        // Test emptying a directory that is already empty\n        await emptyDirectory(testDir);  // First emptying\n        await emptyDirectory(testDir);  // Empty again\n        expect(await fs.promises.readdir(testDir)).toEqual([]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Empties all files and subdirectories in the specified directory.\n * \n * @param {string} directoryPath - Path to the directory whose contents are to be emptied.\n * \n * @returns {Promise<void>} - A promise that resolves when the operation is complete.\n * \n * @throws {Error} - If the specified path does not exist or is not a directory.\n */\nasync function emptyDirectory(directoryPath) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Empties all files and subdirectories in the specified directory, but keeps the directory itself.\n * \n * @param directoryPath - Path to the directory whose contents are to be emptied.\n * @throws {Error} If the specified path does not exist or is not a directory.\n */\nfunction emptyDirectory(directoryPath: string): void {}", "test_code": "import * as os from 'os';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as fsExtra from 'fs-extra';\nimport * as tmp from 'tmp';\n\ndescribe('TestEmptyDirectory', () => {\n  let testDir: string;\n\n  beforeAll(() => {\n      // Set up a temporary directory with some files and directories\n      testDir = tmp.dirSync().name;\n      fs.mkdirSync(path.join(testDir, 'subdir'));\n      fs.writeFileSync(path.join(testDir, 'file1.txt'), \"Hello\");\n      fs.writeFileSync(path.join(testDir, 'subdir', 'file2.txt'), \"World\");\n  });\n\n  afterAll(() => {\n      // Remove the temporary directory after all tests\n      fsExtra.removeSync(testDir);\n  });\n\n  it('should empty the directory successfully', () => {\n      emptyDirectory(testDir);\n      expect(fs.readdirSync(testDir)).toEqual([]);\n  });\n\n  it('should empty a directory that includes subdirectories', () => {\n      emptyDirectory(testDir);\n      expect(fs.readdirSync(testDir)).toEqual([]);\n  });\n\n  it('should handle an already empty directory', () => {\n      emptyDirectory(testDir);  // First emptying\n      emptyDirectory(testDir);  // Empty again\n      expect(fs.readdirSync(testDir)).toEqual([]);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Empties all files and subdirectories in the specified directory, but keeps the directory itself.\n * \n * @param directoryPath - Path to the directory whose contents are to be emptied.\n * @throws {Error} If the specified path does not exist or is not a directory.\n */\nfunction emptyDirectory(directoryPath: string): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Empties all files and subdirectories in the specified directory.\n *\n * @param directoryPath The path to the directory whose contents are to be emptied.\n * @return void or std::invalid_argument: If the specified path does not exist or is not a directory.\n */\nvoid empty_directory(const std::string& directoryPath);", "test_code": "TEST_CASE(\"Empty Directory\", \"[empty_directory]\") {\n    // Test cases go here\n\n    SECTION(\"Non-existent directory\") {\n        REQUIRE_THROWS_AS(empty_directory(\"/path/to/nonexistent/directory\"), std::invalid_argument);\n    }\n\n    SECTION(\"Non-directory path\") {\n        REQUIRE_THROWS_AS(empty_directory(\"/path/to/file.txt\"), std::invalid_argument);\n    }\n\n    SECTION(\"Empty directory\") {\n        fs::create_directories(\"/tmp/test_dir\");\n        empty_directory(\"/tmp/test_dir\");\n        REQUIRE(fs::directory_iterator(\"/tmp/test_dir\").begin() == fs::directory_iterator(\"/tmp/test_dir\").end());\n        fs::remove_all(\"/tmp/test_dir\");\n    }\n\n    SECTION(\"Directory with files\") {\n        fs::create_directories(\"/tmp/test_dir\");\n        fs::create_file(\"/tmp/test_dir/file1.txt\");\n        fs::create_file(\"/tmp/test_dir/file2.txt\");\n        empty_directory(\"/tmp/test_dir\");\n        REQUIRE(fs::directory_iterator(\"/tmp/test_dir\").begin() == fs::directory_iterator(\"/tmp/test_dir\").end());\n        fs::remove_all(\"/tmp/test_dir\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Empties all files and subdirectories in the specified directory.\n *\n * @param directoryPath The path to the directory whose contents are to be emptied.\n * @return void or std::invalid_argument: If the specified path does not exist or is not a directory.\n */\nvoid empty_directory(const std::string& directoryPath);", "addition_info": ""}, "java": {"code_signature": "/**\n * Empties all files and subdirectories in the specified directory, but keeps the directory itself.\n *\n * @param directoryPath Path to the directory whose contents are to be emptied.\n * @throws IllegalArgumentException If the specified path does not exist or is not a directory.\n */\npublic static void emptyDirectory(String directoryPath) throws Exception {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    private File testDir;\n\n    @Before\n    public void setUp() throws IOException {\n        testDir = Files.createTempDirectory(\"testDir\").toFile();\n        new File(testDir, \"subdir\").mkdir();\n        writeToFile(new File(testDir, \"file1.txt\"), \"Hello\");\n        writeToFile(new File(testDir, \"subdir/file2.txt\"), \"World\");\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        deleteDirectoryRecursively(testDir);\n    }\n\n    @Test\n    public void testEmptyDirectorySuccess() throws Exception {\n        emptyDirectory(testDir.getAbsolutePath());\n        assertEquals(0, testDir.list().length);  // Directory should be empty\n    }\n\n    @Test\n    public void testEmptyDirectoryWithSubdirectories() throws Exception {\n        emptyDirectory(testDir.getAbsolutePath());\n        assertFalse(testDir.list().length > 0);  // Directory and subdirectory should be empty\n    }\n\n    @Test\n    public void testEmptyAlreadyEmptyDirectory() throws Exception {\n        emptyDirectory(testDir.getAbsolutePath());  // First emptying\n        emptyDirectory(testDir.getAbsolutePath());  // Empty again\n        assertEquals(0, testDir.list().length);  // Still should be empty\n    }\n\n    private void writeToFile(File file, String content) throws IOException {\n        Files.write(file.toPath(), content.getBytes());\n    }\n\n    private void deleteDirectoryRecursively(File directory) throws Exception {\n        File[] files = directory.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                if (file.isDirectory()) {\n                    deleteDirectoryRecursively(file);\n                } else {\n                    Files.delete(file.toPath());\n                }\n            }\n        }\n        Files.delete(directory.toPath());\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Empties all files and subdirectories in the specified directory, but keeps the directory itself.\n *\n * @param directoryPath Path to the directory whose contents are to be emptied.\n * @throws IllegalArgumentException If the specified path does not exist or is not a directory.\n */\npublic static void emptyDirectory(String directoryPath) throws Exception {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 226, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "convert tsv file to jsonl file\n", "language_version_list": {"python": {"code_signature": "import pandas as pd\n\n\ndef tsv_to_jsonl(tsv_file: str, jsonl_file: str):\n    \"\"\"\n    Convert tsv file to jsonl file\n\n    Args:\n        tsv_file: tsf file path\n        jsonl_file: jsonl file path\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import os\nimport tempfile\nimport unittest\n\n\nclass TestTSVtoJSONL(unittest.TestCase):\n\n    def setUp(self):\n        # Create a temporary directory for testing\n        self.test_dir = tempfile.TemporaryDirectory()\n\n    def tearDown(self):\n        # Clean up the temporary directory\n        self.test_dir.cleanup()\n\n    def test_standard_tsv(self):\n        tsv_content = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\nBob\\t25\\tCanada\\n\"\n        tsv_file = os.path.join(self.test_dir.name, 'test_standard.tsv')\n        jsonl_file = os.path.join(self.test_dir.name, 'test_standard.jsonl')\n\n        with open(tsv_file, 'w', encoding='utf-8') as f:\n            f.write(tsv_content)\n\n        tsv_to_jsonl(tsv_file, jsonl_file)\n\n        with open(jsonl_file, 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n\n        expected_lines = [\n            '{\"Name\":\"Alice\",\"Age\":30,\"Country\":\"USA\"}\\n',\n            '{\"Name\":\"Bob\",\"Age\":25,\"Country\":\"Canada\"}\\n'\n        ]\n        self.assertEqual(lines, expected_lines)\n\n\n    def test_single_row_tsv(self):\n        tsv_content = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\n\"\n        tsv_file = os.path.join(self.test_dir.name, 'test_single_row.tsv')\n        jsonl_file = os.path.join(self.test_dir.name, 'test_single_row.jsonl')\n\n        with open(tsv_file, 'w', encoding='utf-8') as f:\n            f.write(tsv_content)\n\n        tsv_to_jsonl(tsv_file, jsonl_file)\n\n        with open(jsonl_file, 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n\n        expected_lines = [\n            '{\"Name\":\"Alice\",\"Age\":30,\"Country\":\"USA\"}\\n'\n        ]\n        self.assertEqual(lines, expected_lines)\n\n    def test_numeric_and_boolean_values(self):\n        tsv_content = \"Name\\tAge\\tIs_Student\\nAlice\\t30\\tTrue\\nBob\\t25\\tFalse\\n\"\n        tsv_file = os.path.join(self.test_dir.name, 'test_numeric_boolean.tsv')\n        jsonl_file = os.path.join(self.test_dir.name, 'test_numeric_boolean.jsonl')\n\n        with open(tsv_file, 'w', encoding='utf-8') as f:\n            f.write(tsv_content)\n\n        tsv_to_jsonl(tsv_file, jsonl_file)\n\n        with open(jsonl_file, 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n\n        expected_lines = [\n            '{\"Name\":\"Alice\",\"Age\":30,\"Is_Student\":true}\\n',\n            '{\"Name\":\"Bob\",\"Age\":25,\"Is_Student\":false}\\n'\n        ]\n        self.assertEqual(lines, expected_lines)\n", "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef tsv_to_jsonl(tsv_file: str, jsonl_file: str):\n    \"\"\"\n    Convert tsv file to jsonl file\n\n    Args:\n        tsv_file: tsf file path\n        jsonl_file: jsonl file path\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Convert a TSV file to a JSON Lines (JSONL) file.\n *\n * @param {string} tsvFile - The path to the TSV file.\n * @param {string} jsonlFile - The path to the JSONL file.\n */\nfunction tsvToJSONL(tsvFile, jsonlFile) {}", "test_code": "const os = require('os');\nconst fs = require('fs');\nconst path = require('path');\n\ndescribe('TestTSVtoJSONL', () => {\n    let testDir;\n\n    beforeAll(() => {\n        // Create a temporary directory for testing\n        testDir = fs.mkdtempSync(os.tmpdir() + 'jest-test-');\n    });\n\n    afterAll(() => {\n        // Clean up the temporary directory\n        fs.rmSync(testDir, { recursive: true, force: true });\n    });\n\n    const tsv_to_jsonl = require('./tsv_to_jsonl'); // Import the tsv_to_jsonl function\n\n    test('standard TSV conversion', () => {\n        const tsvContent = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\nBob\\t25\\tCanada\\n\";\n        const tsvFile = path.join(testDir, 'test_standard.tsv');\n        const jsonlFile = path.join(testDir, 'test_standard.jsonl');\n\n        fs.writeFileSync(tsvFile, tsvContent, 'utf-8');\n\n        tsv_to_jsonl(tsvFile, jsonlFile);\n\n        const lines = fs.readFileSync(jsonlFile, 'utf-8').split('\\n');\n\n        const expectedLines = [\n            '{\"Name\":\"Alice\",\"Age\":30,\"Country\":\"USA\"}\\n',\n            '{\"Name\":\"Bob\",\"Age\":25,\"Country\":\"Canada\"}\\n'\n        ];\n\n        expect(lines).toEqual(expectedLines);\n    });\n\n    test('single row TSV conversion', () => {\n        const tsvContent = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\n\";\n        const tsvFile = path.join(testDir, 'test_single_row.tsv');\n        const jsonlFile = path.join(testDir, 'test_single_row.jsonl');\n\n        fs.writeFileSync(tsvFile, tsvContent, 'utf-8');\n\n        tsv_to_jsonl(tsvFile, jsonlFile);\n\n        const lines = fs.readFileSync(jsonlFile, 'utf-8').split('\\n');\n\n        const expectedLines = [\n            '{\"Name\":\"Alice\",\"Age\":30,\"Country\":\"USA\"}\\n'\n        ];\n\n        expect(lines).toEqual(expectedLines);\n    });\n\n    test('numeric and boolean values TSV conversion', () => {\n        const tsvContent = \"Name\\tAge\\tIs_Student\\nAlice\\t30\\tTrue\\nBob\\t25\\tFalse\\n\";\n        const tsvFile = path.join(testDir, 'test_numeric_boolean.tsv');\n        const jsonlFile = path.join(testDir, 'test_numeric_boolean.jsonl');\n\n        fs.writeFileSync(tsvFile, tsvContent, 'utf-8');\n\n        tsv_to_jsonl(tsvFile, jsonlFile);\n\n        const lines = fs.readFileSync(jsonlFile, 'utf-8').split('\\n');\n\n        const expectedLines = [\n            '{\"Name\":\"Alice\",\"Age\":30,\"Is_Student\":true}\\n',\n            '{\"Name\":\"Bob\",\"Age\":25,\"Is_Student\":false}\\n'\n        ];\n\n        expect(lines).toEqual(expectedLines);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Convert a TSV file to a JSON Lines (JSONL) file.\n *\n * @param {string} tsvFile - The path to the TSV file.\n * @param {string} jsonlFile - The path to the JSONL file.\n */\nfunction tsvToJSONL(tsvFile, jsonlFile) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Convert TSV file to JSONL file.\n *\n * @param tsvFile - Path to the TSV file.\n * @param jsonlFile - Path to the JSONL file.\n */\nfunction tsvToJsonl(tsvFile: string, jsonlFile: string): void {}", "test_code": "describe('TSV to JSONL Conversion', () => {\n    const tsvFilePath = join(__dirname, '__mocks__', 'example.tsv');\n    const jsonlFilePath = join(__dirname, '__mocks__', 'output.jsonl');\n  \n    beforeAll(() => {\n      // Create a mock TSV file for testing\n      writeFileSync(tsvFilePath, 'column1\\tcolumn2\\nvalue1\\tvalue2');\n    });\n  \n    afterAll(() => {\n      // Clean up the mock files\n      try {\n        unlinkSync(tsvFilePath);\n        unlinkSync(jsonlFilePath);\n      } catch (error) {\n        console.error(`Error cleaning up mock files: ${error}`);\n      }\n    });\n  \n    it('should convert TSV to JSONL successfully', async () => {\n      await tsvToJsonl(tsvFilePath, jsonlFilePath);\n  \n      const expectedJsonlContent = 'column1,column2\\nvalue1,value2\\n';\n      const actualJsonlContent = readFileSync(jsonlFilePath, 'utf-8');\n  \n      expect(actualJsonlContent).toBe(expectedJsonlContent);\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Convert TSV file to JSONL file.\n *\n * @param tsvFile - Path to the TSV file.\n * @param jsonlFile - Path to the JSONL file.\n */\nfunction tsvToJsonl(tsvFile: string, jsonlFile: string): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert tsv file to jsonl file\n *\n * @param tsv_file: Path to the tsv file\n * @param jsonl_file: Path to the jsonl file\n */\nvoid tsv_to_jsonl(const std::string& tsv_file, const std::string& jsonl_file);", "test_code": "TEST_CASE(\"Test TSV to JSONL conversion\", \"[tsv_to_jsonl]\") {\n    // Create a temporary directory for testing\n    fs::path temp_dir = fs::temp_directory_path() / \"test_tsv_to_jsonl\";\n    fs::create_directory(temp_dir);\n\n    SECTION(\"Standard TSV\") {\n        std::string tsv_content = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\nBob\\t25\\tCanada\\n\";\n        std::string tsv_file = (temp_dir / \"test_standard.tsv\").string();\n        std::string jsonl_file = (temp_dir / \"test_standard.jsonl\").string();\n\n        std::ofstream tsv(tsv_file);\n        tsv << tsv_content;\n        tsv.close();\n\n        tsv_to_jsonl(tsv_file, jsonl_file);\n\n        std::ifstream jsonl(jsonl_file);\n        std::vector<std::string> lines;\n        std::string line;\n        while (std::getline(jsonl, line)) {\n            lines.push_back(line + \"\\n\");\n        }\n        jsonl.close();\n\n        std::vector<std::string> expected_lines = {\n            \"{\\\"Name\\\":\\\"Alice\\\",\\\"Age\\\":30,\\\"Country\\\":\\\"USA\\\"}\\n\",\n            \"{\\\"Name\\\":\\\"Bob\\\",\\\"Age\\\":25,\\\"Country\\\":\\\"Canada\\\"}\\n\"\n        };\n\n        REQUIRE(lines == expected_lines);\n    }\n\n    SECTION(\"Single Row TSV\") {\n        std::string tsv_content = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\n\";\n        std::string tsv_file = (temp_dir / \"test_single_row.tsv\").string();\n        std::string jsonl_file = (temp_dir / \"test_single_row.jsonl\").string();\n\n        std::ofstream tsv(tsv_file);\n        tsv << tsv_content;\n        tsv.close();\n\n        tsv_to_jsonl(tsv_file, jsonl_file);\n\n        std::ifstream jsonl(jsonl_file);\n        std::vector<std::string> lines;\n        std::string line;\n        while (std::getline(jsonl, line)) {\n            lines.push_back(line + \"\\n\");\n        }\n        jsonl.close();\n\n        std::vector<std::string> expected_lines = {\n            \"{\\\"Name\\\":\\\"Alice\\\",\\\"Age\\\":30,\\\"Country\\\":\\\"USA\\\"}\\n\"\n        };\n\n        REQUIRE(lines == expected_lines);\n    }\n\n    SECTION(\"Numeric and Boolean Values\") {\n        std::string tsv_content = \"Name\\tAge\\tIs_Student\\nAlice\\t30\\tTrue\\nBob\\t25\\tFalse\\n\";\n        std::string tsv_file = (temp_dir / \"test_numeric_boolean.tsv\").string();\n        std::string jsonl_file = (temp_dir / \"test_numeric_boolean.jsonl\").string();\n\n        std::ofstream tsv(tsv_file);\n        tsv << tsv_content;\n        tsv.close();\n\n        tsv_to_jsonl(tsv_file, jsonl_file);\n\n        std::ifstream jsonl(jsonl_file);\n        std::vector<std::string> lines;\n        std::string line;\n        while (std::getline(jsonl, line)) {\n            lines.push_back(line + \"\\n\");\n        }\n        jsonl.close();\n\n        std::vector<std::string> expected_lines = {\n            \"{\\\"Name\\\":\\\"Alice\\\",\\\"Age\\\":30,\\\"Is_Student\\\":true}\\n\",\n            \"{\\\"Name\\\":\\\"Bob\\\",\\\"Age\\\":25,\\\"Is_Student\\\":false}\\n\"\n        };\n\n        REQUIRE(lines == expected_lines);\n    }\n\n    // Clean up the temporary directory\n    fs::remove_all(temp_dir);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert tsv file to jsonl file\n *\n * @param tsv_file: Path to the tsv file\n * @param jsonl_file: Path to the jsonl file\n */\nvoid tsv_to_jsonl(const std::string& tsv_file, const std::string& jsonl_file);", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts TSV (Tab-Separated Values) file to JSONL (JSON Lines) file.\n *\n * @param tsvFile  The path to the TSV file.\n * @param jsonlFile The path to the JSONL file.\n */\npublic void tsvToJsonL(String tsvFile, String jsonlFile) throws IOException {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\nimport static org.real.temp.Answer.*;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Tests for the TSV to JSONL conversion.\n */\npublic class Tester {\n\n    private Path tempDir;\n\n    /**\n     * Sets up a temporary directory for testing.\n     */\n    @Before\n    public void setUp() throws IOException {\n        // Create a temporary directory\n        tempDir = Files.createTempDirectory(\"testDir\");\n    }\n\n    /**\n     * Cleans up the temporary directory after each test.\n     */\n    @After\n    public void tearDown() throws IOException {\n        // Delete the temporary directory and its contents\n        Files.walk(tempDir)\n                .sorted((path1, path2) -> path2.compareTo(path1)) // Delete files before directories\n                .forEach(path -> {\n                    try {\n                        Files.delete(path);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                });\n    }\n\n    /**\n     * Tests the conversion of a standard TSV file to JSONL.\n     */\n    @Test\n    public void testStandardTSV() throws IOException {\n        String tsvContent = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\nBob\\t25\\tCanada\\n\";\n        Path tsvFile = tempDir.resolve(\"test_standard.tsv\");\n        Path jsonlFile = tempDir.resolve(\"test_standard.jsonl\");\n\n        try (Writer writer = new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(tsvFile), \"UTF-8\"))) {\n            writer.write(tsvContent);\n        }\n\n        tsvToJSONL(tsvFile.toString(), jsonlFile.toString());\n\n        List<String> lines = Files.readAllLines(jsonlFile);\n\n        List<String> expectedLines = List.of(\n                \"{\\\"Name\\\":\\\"Alice\\\",\\\"Age\\\":30,\\\"Country\\\":\\\"USA\\\"}\\n\",\n                \"{\\\"Name\\\":\\\"Bob\\\",\\\"Age\\\":25,\\\"Country\\\":\\\"Canada\\\"}\\n\"\n        );\n\n        assertEquals(expectedLines, lines);\n    }\n\n    /**\n     * Tests the conversion of a single-row TSV file to JSONL.\n     */\n    @Test\n    public void testSingleRowTSV() throws IOException {\n        String tsvContent = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\n\";\n        Path tsvFile = tempDir.resolve(\"test_single_row.tsv\");\n        Path jsonlFile = tempDir.resolve(\"test_single_row.jsonl\");\n\n        try (Writer writer = new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(tsvFile), \"UTF-8\"))) {\n            writer.write(tsvContent);\n        }\n\n        tsvToJSONL(tsvFile.toString(), jsonlFile.toString());\n\n        List<String> lines = Files.readAllLines(jsonlFile);\n\n        List<String> expectedLines = List.of(\n                \"{\\\"Name\\\":\\\"Alice\\\",\\\"Age\\\":30,\\\"Country\\\":\\\"USA\\\"}\\n\"\n        );\n\n        assertEquals(expectedLines, lines);\n    }\n\n    /**\n     * Tests the conversion of a TSV file with numeric and boolean values to JSONL.\n     */\n    @Test\n    public void testNumericAndBooleanValues() throws IOException {\n        String tsvContent = \"Name\\tAge\\tIs_Student\\nAlice\\t30\\tTrue\\nBob\\t25\\tFalse\\n\";\n        Path tsvFile = tempDir.resolve(\"test_numeric_boolean.tsv\");\n        Path jsonlFile = tempDir.resolve(\"test_numeric_boolean.jsonl\");\n\n        try (Writer writer = new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(tsvFile), \"UTF-8\"))) {\n            writer.write(tsvContent);\n        }\n\n        tsvToJSONL(tsvFile.toString(), jsonlFile.toString());\n\n        List<String> lines = Files.readAllLines(jsonlFile);\n\n        List<String> expectedLines = List.of(\n                \"{\\\"Name\\\":\\\"Alice\\\",\\\"Age\\\":30,\\\"Is_Student\\\":true}\\n\",\n                \"{\\\"Name\\\":\\\"Bob\\\",\\\"Age\\\":25,\\\"Is_Student\\\":false}\\n\"\n        );\n\n        assertEquals(expectedLines, lines);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts TSV (Tab-Separated Values) file to JSONL (JSON Lines) file.\n *\n * @param tsvFile  The path to the TSV file.\n * @param jsonlFile The path to the JSONL file.\n */\npublic void tsvToJsonL(String tsvFile, String jsonlFile) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 227, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Count how many colors appear in the picture", "language_version_list": {"python": {"code_signature": "def count_unique_colors(image_path: str) -> int:\n    \"\"\"\n    Count the number of unique colors in an image.\n\n    Args:\n        image_path (str): Path to the image file.\n\n    Returns:\n        int: The number of unique colors in the image.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestCountUniqueColor(unittest.TestCase):\n\n    def test_case1(self):\n        picture_path = r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase01.png\"\n        expected_color_num = 1\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n\n    def test_case2(self):\n        picture_path = r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase02.png\"\n        expected_color_num = 2\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n\n    def test_case3(self):\n        picture_path =r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase03.png\"\n        expected_color_num = 3\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n    def test_case4(self):\n        picture_path =r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase04.png\"\n        expected_color_num = 466\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)", "prompt": "please write a python function , the function signature as below def count_unique_colors(image_path: str) -> int:\n    \"\"\"\n    Count the number of unique colors in an image.\n\n    Args:\n        image_path (str): Path to the image file.\n\n    Returns:\n        int: The number of unique colors in the image.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Count the number of unique colors in an image.\n *\n * @param {string} imagePath - Path to the image file.\n * @returns {number} The number of unique colors in the image.\n */\nfunction countUniqueColors(imagePath) {}", "test_code": "describe('countUniqueColors', () => {\n    it('should return the number of unique colors in an image', async () => {\n      // Mock the image path and expected result\n      const imagePath = 'path/to/image.jpg';\n      const expectedResult = 10; // Replace with the actual expected result\n  \n      // Call the function with the mock image path\n      const result = await countUniqueColors(imagePath);\n  \n      // Assert that the result matches the expected result\n      expect(result).toBe(expectedResult);\n    });\n  \n    it('should handle cases where the image has no colors', async () => {\n      // Mock the image path and expected result\n      const imagePath = 'path/to/empty-image.jpg';\n      const expectedResult = 0; // Replace with the actual expected result\n  \n      // Call the function with the mock image path\n      const result = await countUniqueColors(imagePath);\n  \n      // Assert that the result matches the expected result\n      expect(result).toBe(expectedResult);\n    });\n  });", "prompt": "please write a javascript function , the function signature as below /**\n * Count the number of unique colors in an image.\n *\n * @param {string} imagePath - Path to the image file.\n * @returns {number} The number of unique colors in the image.\n */\nfunction countUniqueColors(imagePath) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Count the number of unique colors in an image.\n *\n * @param image_path - Path to the image file.\n * @returns The number of unique colors in the image.\n */\nfunction countUniqueColors(imagePath: string): Promise<number>;", "test_code": "describe('countUniqueColors', () => {\n    it('should return the correct number of unique colors in an image', async () => {\n      const imagePath = path.join(__dirname, 'test-image.jpg'); // Replace with your test image path\n  \n      if (!fs.existsSync(imagePath)) {\n        throw new Error(`Image not found at ${imagePath}`);\n      }\n  \n      const result = await countUniqueColors(imagePath);\n      \n      // Replace with expected value based on your image\n      expect(result).toBe(10); \n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Count the number of unique colors in an image.\n *\n * @param image_path - Path to the image file.\n * @returns The number of unique colors in the image.\n */\nfunction countUniqueColors(imagePath: string): Promise<number>;", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Count the number of unique colors in an image.\n *\n * @param image_path The path to the image file.\n * @return The number of unique colors in the image.\n */\nint count_unique_colors(const std::string& image_path);", "test_code": "TEST_CASE(\"Test count_unique_colors function\", \"[count_unique_colors]\") {\n    SECTION(\"Test case 1\") {\n        std::string picture_path = R\"(E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase01.png)\";\n        int expected_color_num = 1;\n        int output = count_unique_colors(picture_path);\n        REQUIRE(output == expected_color_num);\n    }\n\n    SECTION(\"Test case 2\") {\n        std::string picture_path = R\"(E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase02.png)\";\n        int expected_color_num = 2;\n        int output = count_unique_colors(picture_path);\n        REQUIRE(output == expected_color_num);\n    }\n\n    SECTION(\"Test case 3\") {\n        std::string picture_path = R\"(E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase03.png)\";\n        int expected_color_num = 3;\n        int output = count_unique_colors(picture_path);\n        REQUIRE(output == expected_color_num);\n    }\n\n    SECTION(\"Test case 4\") {\n        std::string picture_path = R\"(E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase04.png)\";\n        int expected_color_num = 466;\n        int output = count_unique_colors(picture_path);\n        REQUIRE(output == expected_color_num);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Count the number of unique colors in an image.\n *\n * @param image_path The path to the image file.\n * @return The number of unique colors in the image.\n */\nint count_unique_colors(const std::string& image_path);", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 229, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Convert the file size from byte units to a more readable format (e.g. KB, MB, GB) such as 2120B, convert the bits to 2KB, keeping only the integer parts\n", "language_version_list": {"python": {"code_signature": "def convert_file_size(size_bytes: int) -> str:\n    \"\"\"\n    Converts a file size in bytes to a human-readable format.\n    For example:\n        input: 2120\n        output: 2KB\n    Args:\n        size_bytes (int): The size in bytes to be converted.\n\n    Returns:\n        str: The converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n    \"\"\"\n", "test_code": "# Unit test class\nimport unittest\n\n\nclass TestFileSizeConverter(unittest.TestCase):\n\n\n    def test_zero_bytes(self):\n        self.assertEqual(convert_file_size(0), \"0B\")\n\n    def test_bytes_less_than_1KB(self):\n        self.assertEqual(convert_file_size(512), \"512B\")\n\n    def test_exactly_1KB(self):\n        self.assertEqual(convert_file_size(1024), \"1KB\")\n\n    def test_2KB(self):\n        self.assertEqual(convert_file_size(2048), \"2KB\")\n\n    def test_exactly_1MB(self):\n        self.assertEqual(convert_file_size(1048576), \"1MB\")\n\n    def test_5MB(self):\n        self.assertEqual(convert_file_size(5242880), \"5MB\")\n\n    def test_exactly_1GB(self):\n        self.assertEqual(convert_file_size(1073741824), \"1GB\")", "prompt": "please write a python function , the function signature as below def convert_file_size(size_bytes: int) -> str:\n    \"\"\"\n    Converts a file size in bytes to a human-readable format.\n    For example:\n        input: 2120\n        output: 2KB\n    Args:\n        size_bytes (int): The size in bytes to be converted.\n\n    Returns:\n        str: The converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a file size in bytes to a human-readable format.\n * For example:\n *     input: 2120\n *     output: 2KB\n * \n * @param {number} sizeBytes - The size in bytes to be converted.\n * @returns {string} The converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n */\nfunction convertFileSize(sizeBytes) {}", "test_code": "describe('TestFileSizeConverter', () => {\n  test('test_zero_bytes', () => {\n      expect(convertFileSize(0)).toBe(\"0B\");\n  });\n\n  test('test_bytes_less_than_1KB', () => {\n      expect(convertFileSize(512)).toBe(\"512B\");\n  });\n\n  test('test_exactly_1KB', () => {\n      expect(convertFileSize(1024)).toBe(\"1KB\");\n  });\n\n  test('test_2KB', () => {\n      expect(convertFileSize(2048)).toBe(\"2KB\");\n  });\n\n  test('test_exactly_1MB', () => {\n      expect(convertFileSize(1048576)).toBe(\"1MB\");\n  });\n\n  test('test_5MB', () => {\n      expect(convertFileSize(5242880)).toBe(\"5MB\");\n  });\n\n  test('test_exactly_1GB', () => {\n      expect(convertFileSize(1073741824)).toBe(\"1GB\");\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a file size in bytes to a human-readable format.\n * For example:\n *     input: 2120\n *     output: 2KB\n * \n * @param {number} sizeBytes - The size in bytes to be converted.\n * @returns {string} The converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n */\nfunction convertFileSize(sizeBytes) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a file size in bytes to a human-readable format.\n * For example:\n *   input: 2120\n *   output: 2KB\n * \n * @param sizeBytes - The size in bytes to be converted.\n * @returns The converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n */\nfunction convertFileSize(sizeBytes: number): string {}", "test_code": "describe('TestFileSizeConverter', () => {\n    it('should handle zero bytes', () => {\n      expect(convertFileSize(0)).toBe(\"0B\");\n    });\n  \n    it('should handle bytes less than 1KB', () => {\n      expect(convertFileSize(512)).toBe(\"512B\");\n    });\n  \n    it('should handle exactly 1KB', () => {\n      expect(convertFileSize(1024)).toBe(\"1KB\");\n    });\n  \n    it('should handle 2KB', () => {\n      expect(convertFileSize(2048)).toBe(\"2KB\");\n    });\n  \n    it('should handle exactly 1MB', () => {\n      expect(convertFileSize(1048576)).toBe(\"1MB\");\n    });\n  \n    it('should handle 5MB', () => {\n      expect(convertFileSize(5242880)).toBe(\"5MB\");\n    });\n  \n    it('should handle exactly 1GB', () => {\n      expect(convertFileSize(1073741824)).toBe(\"1GB\");\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a file size in bytes to a human-readable format.\n * For example:\n *   input: 2120\n *   output: 2KB\n * \n * @param sizeBytes - The size in bytes to be converted.\n * @returns The converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n */\nfunction convertFileSize(sizeBytes: number): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts a file size in bytes to a human-readable format.\n * For example:\n *     input: 2120\n *     output: 2KB\n *\n * @param size_bytes The size in bytes to be converted.\n * @return A string representing the converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n */\nstd::string convertFileSize(int64_t sizeBytes);", "test_code": "TEST_CASE(\"Convert file size to human-readable format\", \"[convert_file_size]\") {\n    REQUIRE(convert_file_size(2120) == \"2KB\");\n    REQUIRE(convert_file_size(1048576) == \"1MB\");\n    REQUIRE(convert_file_size(1073741824) == \"1GB\");\n    // Add more test cases as needed\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts a file size in bytes to a human-readable format.\n * For example:\n *     input: 2120\n *     output: 2KB\n *\n * @param size_bytes The size in bytes to be converted.\n * @return A string representing the converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n */\nstd::string convertFileSize(int64_t sizeBytes);", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a file size in bytes to a human-readable format.\n * For example:\n *     input: 2120\n *     output: 2KB\n *\n * @param sizeBytes The size in bytes to be converted.\n * @return The converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n */\npublic static String convertFileSize(long sizeBytes) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n/**\n * Test class for the file size converter.\n */\npublic class Tester {\n\n    /**\n     * Tests the conversion of zero bytes.\n     */\n    @Test\n    public void testZeroBytes() {\n        assertEquals(\"0B\", convertFileSize(0));\n    }\n\n    /**\n     * Tests the conversion of bytes less than 1KB.\n     */\n    @Test\n    public void testBytesLessThan1KB() {\n        assertEquals(\"512B\", convertFileSize(512));\n    }\n\n    /**\n     * Tests the conversion of exactly 1KB.\n     */\n    @Test\n    public void testExactly1KB() {\n        assertEquals(\"1KB\", convertFileSize(1024));\n    }\n\n    /**\n     * Tests the conversion of 2KB.\n     */\n    @Test\n    public void test2KB() {\n        assertEquals(\"2KB\", convertFileSize(2048));\n    }\n\n    /**\n     * Tests the conversion of exactly 1MB.\n     */\n    @Test\n    public void testExactly1MB() {\n        assertEquals(\"1MB\", convertFileSize(1048576));\n    }\n\n    /**\n     * Tests the conversion of 5MB.\n     */\n    @Test\n    public void test5MB() {\n        assertEquals(\"5MB\", convertFileSize(5242880));\n    }\n\n    /**\n     * Tests the conversion of exactly 1GB.\n     */\n    @Test\n    public void testExactly1GB() {\n        assertEquals(\"1GB\", convertFileSize(1073741824L));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a file size in bytes to a human-readable format.\n * For example:\n *     input: 2120\n *     output: 2KB\n *\n * @param sizeBytes The size in bytes to be converted.\n * @return The converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n */\npublic static String convertFileSize(long sizeBytes) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 230, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "move the emoj expression in the string to the end of the text\n", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef move_emojis_to_end(text: str):\n    \"\"\"\n    Move the emoj expression in the string to the end of the text\n\n    Args:\n        text (str): The input string containing text and possibly emojis.\n\n    Returns:\n        str: The modified string with all emojis moved to the end.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestMoveEmojisToEnd(unittest.TestCase):\n\n    def test_no_emojis(self):\n        # Case: String with no emojis\n        input_text = \"This is a test.\"\n        expected_output = \"This is a test.\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_all_emojis(self):\n        # Case: String with only emojis\n        input_text = \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\"\n        expected_output = \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_emojis_at_start(self):\n        # Case: Emojis at the start of the text\n        input_text = \"\ud83d\ude00\ud83d\ude03Hello world!\"\n        expected_output = \"Hello world!\ud83d\ude00\ud83d\ude03\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_emojis_at_end(self):\n        # Case: Emojis already at the end of the text\n        input_text = \"Hello world!\ud83d\ude00\ud83d\ude03\"\n        expected_output = \"Hello world!\ud83d\ude00\ud83d\ude03\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_emojis_in_middle(self):\n        # Case: Emojis in the middle of the text\n        input_text = \"Hello \ud83d\ude00world\ud83d\ude03!\"\n        expected_output = \"Hello world!\ud83d\ude00\ud83d\ude03\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_mixed_characters(self):\n        # Case: Text with mixed characters and emojis\n        input_text = \"Hi! \ud83d\ude00 How are you? \ud83d\ude03\"\n        expected_output = \"Hi!  How are you? \ud83d\ude00\ud83d\ude03\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef move_emojis_to_end(text: str):\n    \"\"\"\n    Move the emoj expression in the string to the end of the text\n\n    Args:\n        text (str): The input string containing text and possibly emojis.\n\n    Returns:\n        str: The modified string with all emojis moved to the end.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Move the emoji expressions in the string to the end of the text.\n *\n * @param {string} text - The input string containing text and possibly emojis.\n * @returns {string} - The modified string with all emojis moved to the end.\n */\nfunction moveEmojisToEnd(text) {}", "test_code": "describe('TestMoveEmojisToEnd', () => {\n  it('should handle a string with no emojis', () => {\n      const inputText = \"This is a test.\";\n      const expectedOutput = \"This is a test.\";\n      expect(moveEmojisToEnd(inputText)).toEqual(expectedOutput);\n  });\n\n  it('should handle a string with only emojis', () => {\n      const inputText = \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\";\n      const expectedOutput = \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\";\n      expect(moveEmojisToEnd(inputText)).toEqual(expectedOutput);\n  });\n\n  it('should handle emojis at the start of the text', () => {\n      const inputText = \"\ud83d\ude00\ud83d\ude03Hello world!\";\n      const expectedOutput = \"Hello world!\ud83d\ude00\ud83d\ude03\";\n      expect(moveEmojisToEnd(inputText)).toEqual(expectedOutput);\n  });\n\n  it('should handle emojis already at the end of the text', () => {\n      const inputText = \"Hello world!\ud83d\ude00\ud83d\ude03\";\n      const expectedOutput = \"Hello world!\ud83d\ude00\ud83d\ude03\";\n      expect(moveEmojisToEnd(inputText)).toEqual(expectedOutput);\n  });\n\n  it('should handle emojis in the middle of the text', () => {\n      const inputText = \"Hello \ud83d\ude00world\ud83d\ude03!\";\n      const expectedOutput = \"Hello world!\ud83d\ude00\ud83d\ude03\";\n      expect(moveEmojisToEnd(inputText)).toEqual(expectedOutput);\n  });\n\n  it('should handle text with mixed characters and emojis', () => {\n      const inputText = \"Hi! \ud83d\ude00 How are you? \ud83d\ude03\";\n      const expectedOutput = \"Hi!  How are you? \ud83d\ude00\ud83d\ude03\";\n      expect(moveEmojisToEnd(inputText)).toEqual(expectedOutput);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Move the emoji expressions in the string to the end of the text.\n *\n * @param {string} text - The input string containing text and possibly emojis.\n * @returns {string} - The modified string with all emojis moved to the end.\n */\nfunction moveEmojisToEnd(text) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Move the emoji expressions in the string to the end of the text.\n *\n * @param {string} text - The input string containing text and possibly emojis.\n * @returns {string} - The modified string with all emojis moved to the end.\n */\nfunction moveEmojisToEnd(text: string): string {}", "test_code": "describe('TestMoveEmojisToEnd', () => {\n    it('should handle strings with no emojis', () => {\n        const inputText = \"This is a test.\";\n        const expectedOutput = \"This is a test.\";\n        expect(moveEmojisToEnd(inputText)).toEqual(expectedOutput);\n    });\n\n    it('should handle strings with only emojis', () => {\n        const inputText = \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\";\n        const expectedOutput = \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\";\n        expect(moveEmojisToEnd(inputText)).toEqual(expectedOutput);\n    });\n\n    it('should handle emojis at the start of the text', () => {\n        const inputText = \"\ud83d\ude00\ud83d\ude03Hello world!\";\n        const expectedOutput = \"Hello world!\ud83d\ude00\ud83d\ude03\";\n        expect(moveEmojisToEnd(inputText)).toEqual(expectedOutput);\n    });\n\n    it('should handle emojis already at the end of the text', () => {\n        const inputText = \"Hello world!\ud83d\ude00\ud83d\ude03\";\n        const expectedOutput = \"Hello world!\ud83d\ude00\ud83d\ude03\";\n        expect(moveEmojisToEnd(inputText)).toEqual(expectedOutput);\n    });\n\n    it('should handle emojis in the middle of the text', () => {\n        const inputText = \"Hello \ud83d\ude00world\ud83d\ude03!\";\n        const expectedOutput = \"Hello world!\ud83d\ude00\ud83d\ude03\";\n        expect(moveEmojisToEnd(inputText)).toEqual(expectedOutput);\n    });\n\n    it('should handle text with mixed characters and emojis', () => {\n        const inputText = \"Hi! \ud83d\ude00 How are you? \ud83d\ude03\";\n        const expectedOutput = \"Hi!  How are you? \ud83d\ude00\ud83d\ude03\";\n        expect(moveEmojisToEnd(inputText)).toEqual(expectedOutput);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Move the emoji expressions in the string to the end of the text.\n *\n * @param {string} text - The input string containing text and possibly emojis.\n * @returns {string} - The modified string with all emojis moved to the end.\n */\nfunction moveEmojisToEnd(text: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "std::string moveEmojisToEnd(const std::string& text) {\n    /*\n    Move the emoj expression in the string to the end of the text\n\n    Args:\n        text (const std::string&): The input string containing text and possibly emojis.\n\n    Returns:\n        std::string: The modified string with all emojis moved to the end.\n    */\n\n    // Regex pattern to match any emoji character\n    std::regex emojiPattern(R\"([\\x{1F600}-\\x{1F64F}\\x{1F300}-\\x{1F5FF}\\x{1F680}-\\x{1F6FF}\\x{2600}-\\x{26FF}\\x{2700}-\\x{27BF}])\", std::regex_constants::icase);\n    return result;\n}", "test_code": "TEST_CASE(\"Move Emojis to End\", \"[move_emojis_to_end]\") {\n    REQUIRE(move_emojis_to_end(\"\") == \"\");\n    REQUIRE(move_emojis_to_end(\"Hello World!\") == \"Hello World!\");\n    REQUIRE(move_emojis_to_end(\"Hello \ud83c\udf0d!\") == \"Hello !\ud83c\udf0d\");\n    REQUIRE(move_emojis_to_end(\"\ud83d\udc4b Hello \ud83c\udf0d!\") == \"Hello !\ud83d\udc4b\ud83c\udf0d\");\n    REQUIRE(move_emojis_to_end(\"Hello \ud83c\udf0d\ud83d\udc4b!\") == \"Hello !\ud83d\udc4b\ud83c\udf0d\");\n}", "prompt": "please write a cpp function , the function signature as below std::string moveEmojisToEnd(const std::string& text) {\n    /*\n    Move the emoj expression in the string to the end of the text\n\n    Args:\n        text (const std::string&): The input string containing text and possibly emojis.\n\n    Returns:\n        std::string: The modified string with all emojis moved to the end.\n    */\n\n    // Regex pattern to match any emoji character\n    std::regex emojiPattern(R\"([\\x{1F600}-\\x{1F64F}\\x{1F300}-\\x{1F5FF}\\x{1F680}-\\x{1F6FF}\\x{2600}-\\x{26FF}\\x{2700}-\\x{27BF}])\", std::regex_constants::icase);\n    return result;\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Moves the emoji expressions in the string to the end of the text.\n *\n * @param text The input string containing text and possibly emojis.\n * @return The modified string with all emojis moved to the end.\n */\npublic static String moveEmojisToEnd(String text) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n/**\n * Test class for the moveEmojisToEnd function.\n */\npublic class Tester {\n\n    /**\n     * Tests the case where the input string contains no emojis.\n     */\n    @Test\n    public void testNoEmojis() {\n        String inputText = \"This is a test.\";\n        String expectedOutput = \"This is a test.\";\n        assertEquals(expectedOutput, moveEmojisToEnd(inputText));\n    }\n\n    /**\n     * Tests the case where the input string contains only emojis.\n     */\n    @Test\n    public void testAllEmojis() {\n        String inputText = \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\";\n        String expectedOutput = \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\";\n        assertEquals(expectedOutput, moveEmojisToEnd(inputText));\n    }\n\n    /**\n     * Tests the case where emojis are at the start of the text.\n     */\n    @Test\n    public void testEmojisAtStart() {\n        String inputText = \"\ud83d\ude00\ud83d\ude03Hello world!\";\n        String expectedOutput = \"Hello world!\ud83d\ude00\ud83d\ude03\";\n        assertEquals(expectedOutput, moveEmojisToEnd(inputText));\n    }\n\n    /**\n     * Tests the case where emojis are already at the end of the text.\n     */\n    @Test\n    public void testEmojisAtEnd() {\n        String inputText = \"Hello world!\ud83d\ude00\ud83d\ude03\";\n        String expectedOutput = \"Hello world!\ud83d\ude00\ud83d\ude03\";\n        assertEquals(expectedOutput, moveEmojisToEnd(inputText));\n    }\n\n    /**\n     * Tests the case where emojis are in the middle of the text.\n     */\n    @Test\n    public void testEmojisInMiddle() {\n        String inputText = \"Hello \ud83d\ude00world\ud83d\ude03!\";\n        String expectedOutput = \"Hello world!\ud83d\ude00\ud83d\ude03\";\n        assertEquals(expectedOutput, moveEmojisToEnd(inputText));\n    }\n\n    /**\n     * Tests the case where the input string contains mixed characters and emojis.\n     */\n    @Test\n    public void testMixedCharacters() {\n        String inputText = \"Hi! \ud83d\ude00 How are you? \ud83d\ude03\";\n        String expectedOutput = \"Hi!  How are you? \ud83d\ude00\ud83d\ude03\";\n        assertEquals(expectedOutput, moveEmojisToEnd(inputText));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Moves the emoji expressions in the string to the end of the text.\n *\n * @param text The input string containing text and possibly emojis.\n * @return The modified string with all emojis moved to the end.\n */\npublic static String moveEmojisToEnd(String text) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 231, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Reads a log file where each line is a JSON object containing 'test_acc1' and 'train_loss' values.Parses these lines and collects the values into two lists, one for each metric. ", "language_version_list": {"python": {"code_signature": "def read_log(log_file_path):\n    \"\"\"\n    Reads a log file containing JSON entries and extracts training loss and test accuracy.\n    Json entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}\n    Args:\n        log_file_path (str): The path to the log file to be read.\n\n    Returns:\n        tuple: A tuple containing two lists:\n            - train_loss_list (list): A list of training loss values extracted from the log.\n            - test_acc1_list (list): A list of test accuracy values extracted from the log.\n    \"\"\"\n", "test_code": "import json\nimport unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestReadLog(unittest.TestCase):\n\n    def test_read_correct_data(self):\n        \"\"\" Test reading correctly formatted JSON lines \"\"\"\n        mock_file_content = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}\\n' \\\n                            '{\"test_acc1\": 89.0, \"train_loss\": 0.70}'\n        with patch('builtins.open', mock_open(read_data=mock_file_content)):\n            train_loss, test_acc1 = read_log(\"dummy_path.json\")\n            self.assertEqual(train_loss, [0.75, 0.70])\n            self.assertEqual(test_acc1, [88.5, 89.0])\n\n    def test_read_correct_data_single(self):\n        \"\"\" Test reading correctly formatted JSON lines \"\"\"\n        mock_file_content = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}'\n        with patch('builtins.open', mock_open(read_data=mock_file_content)):\n            train_loss, test_acc1 = read_log(\"dummy_path.json\")\n            self.assertEqual(train_loss, [0.75])\n            self.assertEqual(test_acc1, [88.5])\n    def test_empty_file(self):\n        \"\"\" Test reading an empty file \"\"\"\n        with patch('builtins.open', mock_open(read_data=\"\")):\n            train_loss, test_acc1 = read_log(\"empty_file.json\")\n            self.assertEqual(train_loss, [])\n            self.assertEqual(test_acc1, [])\n\n    def test_partial_data_entries(self):\n        \"\"\" Test file with missing fields in some entries \"\"\"\n        mock_file_content = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}\\n' \\\n                            '{\"test_acc1\": 90.0,\"train_loss\": 0.75,\"f1\":0.91}'  # Missing train_loss\n        with patch('builtins.open', mock_open(read_data=mock_file_content)):\n            train_loss, test_acc1 = read_log(\"partial_data_file.json\")\n            self.assertEqual(train_loss, [0.75, 0.75])  # Only one complete entry\n            self.assertEqual(test_acc1, [88.5, 90.0])\n", "prompt": "please write a python function , the function signature as below def read_log(log_file_path):\n    \"\"\"\n    Reads a log file containing JSON entries and extracts training loss and test accuracy.\n    Json entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}\n    Args:\n        log_file_path (str): The path to the log file to be read.\n\n    Returns:\n        tuple: A tuple containing two lists:\n            - train_loss_list (list): A list of training loss values extracted from the log.\n            - test_acc1_list (list): A list of test accuracy values extracted from the log.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Reads a log file containing JSON entries and extracts training loss and test accuracy.\n * JSON entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}.\n * \n * @param {string} logFilePath - The path to the log file to be read.\n * @returns {Array} A tuple containing two lists:\n *   - trainLossList (Array): A list of training loss values extracted from the log.\n *   - testAcc1List (Array): A list of test accuracy values extracted from the log.\n */\nfunction readLog(logFilePath) {}", "test_code": "const fs = require('fs');\nconst { mock } = require('jest-mock-extended');\ndescribe('TestReadLog', () => {\n    it('test_read_correct_data', () => {\n        const mockFileContent = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}\\n{\"test_acc1\": 89.0, \"train_loss\": 0.70}';\n        const mockFs = mock(fs);\n        mockFs.readFileSync.mockReturnValue(mockFileContent);\n\n        const [trainLoss, testAcc1] = readLog('dummy_path.json');\n        expect(trainLoss).toEqual([0.75, 0.70]);\n        expect(testAcc1).toEqual([88.5, 89.0]);\n    });\n\n    it('test_read_correct_data_single', () => {\n        const mockFileContent = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}';\n        const mockFs = mock(fs);\n        mockFs.readFileSync.mockReturnValue(mockFileContent);\n\n        const [trainLoss, testAcc1] = readLog('dummy_path.json');\n        expect(trainLoss).toEqual([0.75]);\n        expect(testAcc1).toEqual([88.5]);\n    });\n\n    it('test_empty_file', () => {\n        const mockFileContent = '';\n        const mockFs = mock(fs);\n        mockFs.readFileSync.mockReturnValue(mockFileContent);\n\n        const [trainLoss, testAcc1] = readLog('empty_file.json');\n        expect(trainLoss).toEqual([]);\n        expect(testAcc1).toEqual([]);\n    });\n\n    it('test_partial_data_entries', () => {\n        const mockFileContent = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}\\n{\"test_acc1\": 90.0,\"train_loss\": 0.75,\"f1\":0.91}';\n        const mockFs = mock(fs);\n        mockFs.readFileSync.mockReturnValue(mockFileContent);\n\n        const [trainLoss, testAcc1] = readLog('partial_data_file.json');\n        expect(trainLoss).toEqual([0.75, 0.75]);\n        expect(testAcc1).toEqual([88.5, 90.0]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Reads a log file containing JSON entries and extracts training loss and test accuracy.\n * JSON entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}.\n * \n * @param {string} logFilePath - The path to the log file to be read.\n * @returns {Array} A tuple containing two lists:\n *   - trainLossList (Array): A list of training loss values extracted from the log.\n *   - testAcc1List (Array): A list of test accuracy values extracted from the log.\n */\nfunction readLog(logFilePath) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Reads a log file containing JSON entries and extracts training loss and test accuracy.\n * JSON entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}.\n * \n * @param logFilePath - The path to the log file to be read.\n * @returns A tuple containing two lists:\n *   - trainLossList: A list of training loss values extracted from the log.\n *   - testAcc1List: A list of test accuracy values extracted from the log.\n */\nfunction readLog(logFilePath: string): [number[], number[]] {}", "test_code": "import fs from 'fs';\nimport { parse } from 'json5';\ndescribe('TestReadLog', () => {\n    beforeEach(() => {\n        jest.resetModules();\n    });\n\n    it('test_read_correct_data', () => {\n        const mockFileContent = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}\\n{\"test_acc1\": 89.0, \"train_loss\": 0.70}';\n        jest.spyOn(fs, 'readFileSync').mockImplementation(() => mockFileContent);\n\n        const [trainLoss, testAcc1] = readLog('dummy_path.json');\n        expect(trainLoss).toEqual([0.75, 0.70]);\n        expect(testAcc1).toEqual([88.5, 89.0]);\n    });\n\n    it('test_read_correct_data_single', () => {\n        const mockFileContent = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}';\n        jest.spyOn(fs, 'readFileSync').mockImplementation(() => mockFileContent);\n\n        const [trainLoss, testAcc1] = readLog('dummy_path.json');\n        expect(trainLoss).toEqual([0.75]);\n        expect(testAcc1).toEqual([88.5]);\n    });\n\n    it('test_empty_file', () => {\n        const mockFileContent = '';\n        jest.spyOn(fs, 'readFileSync').mockImplementation(() => mockFileContent);\n\n        const [trainLoss, testAcc1] = readLog('empty_file.json');\n        expect(trainLoss).toEqual([]);\n        expect(testAcc1).toEqual([]);\n    });\n\n    it('test_partial_data_entries', () => {\n        const mockFileContent = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}\\n{\"test_acc1\": 90.0,\"train_loss\": 0.75,\"f1\":0.91}';\n        jest.spyOn(fs, 'readFileSync').mockImplementation(() => mockFileContent);\n\n        const [trainLoss, testAcc1] = readLog('partial_data_file.json');\n        expect(trainLoss).toEqual([0.75, 0.75]);\n        expect(testAcc1).toEqual([88.5, 90.0]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Reads a log file containing JSON entries and extracts training loss and test accuracy.\n * JSON entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}.\n * \n * @param logFilePath - The path to the log file to be read.\n * @returns A tuple containing two lists:\n *   - trainLossList: A list of training loss values extracted from the log.\n *   - testAcc1List: A list of test accuracy values extracted from the log.\n */\nfunction readLog(logFilePath: string): [number[], number[]] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads a log file containing JSON entries and extracts training loss and test accuracy.\n * Json entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}\n *\n * @param log_file_path The path to the log file to be read.\n * @return A pair of vectors containing two lists:\n *         - train_loss_list: A vector of training loss values extracted from the log.\n *         - test_acc1_list: A vector of test accuracy values extracted from the log.\n */\nstd::pair<std::vector<double>, std::vector<double>> read_log(const std::string& log_file_path){}\n", "test_code": "TEST_CASE(\"readLog function tests\") {\n    \n    // Create a temporary file for testing\n    std::string testFilePath = \"dummy_path.json\";\n\n    SECTION(\"reads correctly formatted JSON lines\") {\n        std::ofstream outFile(testFilePath);\n        outFile << \"{\\\"test_acc1\\\": 88.5, \\\"train_loss\\\": 0.75}\\n\"\n                << \"{\\\"test_acc1\\\": 89.0, \\\"train_loss\\\": 0.70}\";\n        outFile.close();\n\n        auto [trainLossList, testAcc1List] = readLog(testFilePath);\n        REQUIRE(trainLossList == std::vector<double>{0.75, 0.70});\n        REQUIRE(testAcc1List == std::vector<double>{88.5, 89.0});\n    }\n\n    SECTION(\"reads correctly formatted JSON lines - single entry\") {\n        std::ofstream outFile(testFilePath);\n        outFile << \"{\\\"test_acc1\\\": 88.5, \\\"train_loss\\\": 0.75}\";\n        outFile.close();\n\n        auto [trainLossList, testAcc1List] = readLog(testFilePath);\n        REQUIRE(trainLossList == std::vector<double>{0.75});\n        REQUIRE(testAcc1List == std::vector<double>{88.5});\n    }\n\n    SECTION(\"reads an empty file\") {\n        std::ofstream outFile(testFilePath);\n        outFile.close(); // Create an empty file\n\n        auto [trainLossList, testAcc1List] = readLog(testFilePath);\n        REQUIRE(trainLossList.empty());\n        REQUIRE(testAcc1List.empty());\n    }\n\n    SECTION(\"handles partial data entries\") {\n        std::ofstream outFile(testFilePath);\n        outFile << \"{\\\"test_acc1\\\": 88.5, \\\"train_loss\\\": 0.75}\\n\"\n                << \"{\\\"test_acc1\\\": 90.0, \\\"train_loss\\\": 0.75, \\\"f1\\\": 0.91}\"; // Missing train_loss\n        outFile.close();\n\n        auto [trainLossList, testAcc1List] = readLog(testFilePath);\n        REQUIRE(trainLossList == std::vector<double>{0.75, 0.75}); // Only one complete entry\n        REQUIRE(testAcc1List == std::vector<double>{88.5, 90.0});\n    }\n    \n    // Clean up the test file after tests\n    remove(testFilePath.c_str());\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads a log file containing JSON entries and extracts training loss and test accuracy.\n * Json entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}\n *\n * @param log_file_path The path to the log file to be read.\n * @return A pair of vectors containing two lists:\n *         - train_loss_list: A vector of training loss values extracted from the log.\n *         - test_acc1_list: A vector of test accuracy values extracted from the log.\n */\nstd::pair<std::vector<double>, std::vector<double>> read_log(const std::string& log_file_path){}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads a log file containing JSON entries and extracts training loss and test accuracy.\n * JSON entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}.\n *\n * @param logFilePath The path to the log file to be read.\n * @return A tuple containing two lists:\n *         - trainLossList: A list of training loss values extracted from the log.\n *         - testAcc1List: A list of test accuracy values extracted from the log.\n */\npublic static Tuple<List<Double>, List<Double>> readLog(String logFilePath) {}", "test_code": "import org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\nimport org.mockito.stubbing.Answer;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.when;\nimport static org.mockito.Mockito.mock;\n\n@ExtendWith(MockitoExtension.class)\npublic class Tester {\n\n    @Mock\n    private BufferedReader mockReader;\n\n    @InjectMocks\n    private Answer answer;\n\n    @BeforeEach\n    public void setUp() {\n        // Setup any common mocks or initializations here\n    }\n\n    @Test\n    public void testReadCorrectData() throws IOException {\n        // Mock the BufferedReader to simulate reading correct data\n        String mockFileContent = \"{\\\"test_acc1\\\": 88.5, \\\"train_loss\\\": 0.75}\\n\" +\n                                 \"{\\\"test_acc1\\\": 89.0, \\\"train_loss\\\": 0.70}\";\n        when(mockReader.readLine()).thenAnswer((Answer<String>) invocation -> {\n            for (String line : mockFileContent.split(\"\\n\")) {\n                if (!line.isEmpty()) {\n                    yield line;\n                }\n            }\n            yield null;\n        });\n\n        List<Double> trainLossList;\n        List<Double> testAcc1List;\n\n        try {\n            trainLossList = new ArrayList<>();\n            testAcc1List = new ArrayList<>();\n            answer.readLog(\"dummy_path.json\", trainLossList, testAcc1List);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        assertEquals(List.of(0.75, 0.70), trainLossList);\n        assertEquals(List.of(88.5, 89.0), testAcc1List);\n    }\n\n    @Test\n    public void testReadCorrectDataSingle() throws IOException {\n        // Mock the BufferedReader to simulate reading a single correct data line\n        String mockFileContent = \"{\\\"test_acc1\\\": 88.5, \\\"train_loss\\\": 0.75}\";\n        when(mockReader.readLine()).thenReturn(mockFileContent, (String) null);\n\n        List<Double> trainLossList;\n        List<Double> testAcc1List;\n\n        try {\n            trainLossList = new ArrayList<>();\n            testAcc1List = new ArrayList<>();\n            answer.readLog(\"dummy_path.json\", trainLossList, testAcc1List);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        assertEquals(List.of(0.75), trainLossList);\n        assertEquals(List.of(88.5), testAcc1List);\n    }\n\n    @Test\n    public void testEmptyFile() throws IOException {\n        // Mock the BufferedReader to simulate reading an empty file\n        when(mockReader.readLine()).thenReturn((String) null);\n\n        List<Double> trainLossList;\n        List<Double> testAcc1List;\n\n        try {\n            trainLossList = new ArrayList<>();\n            testAcc1List = new ArrayList<>();\n            answer.readLog(\"empty_file.json\", trainLossList, testAcc1List);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        assertEquals(List.of(), trainLossList);\n        assertEquals(List.of(), testAcc1List);\n    }\n\n    @Test\n    public void testPartialDataEntries() throws IOException {\n        // Mock the BufferedReader to simulate reading partial data entries\n        String mockFileContent = \"{\\\"test_acc1\\\": 88.5, \\\"train_loss\\\": 0.75}\\n\" +\n                                 \"{\\\"test_acc1\\\": 90.0,\\\"train_loss\\\": 0.75,\\\"f1\\\":0.91}\";\n        when(mockReader.readLine()).thenAnswer((Answer<String>) invocation -> {\n            for (String line : mockFileContent.split(\"\\n\")) {\n                if (!line.isEmpty()) {\n                    yield line;\n                }\n            }\n            yield null;\n        });\n\n        List<Double> trainLossList;\n        List<Double> testAcc1List;\n\n        try {\n            trainLossList = new ArrayList<>();\n            testAcc1List = new ArrayList<>();\n            answer.readLog(\"partial_data_file.json\", trainLossList, testAcc1List);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        assertEquals(List.of(0.75, 0.75), trainLossList);\n        assertEquals(List.of(88.5, 90.0), testAcc1List);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Reads a log file containing JSON entries and extracts training loss and test accuracy.\n * JSON entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}.\n *\n * @param logFilePath The path to the log file to be read.\n * @return A tuple containing two lists:\n *         - trainLossList: A list of training loss values extracted from the log.\n *         - testAcc1List: A list of test accuracy values extracted from the log.\n */\npublic static Tuple<List<Double>, List<Double>> readLog(String logFilePath) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 232, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "convert a string containing hours, minutes, and seconds to milliseconds, for example, convert the string \"1h20 min30s\" to milliseconds\n", "language_version_list": {"python": {"code_signature": "from typing import Optional\n\n\ndef convert_hms_to_milliseconds(time_str: str) -> Optional[int]:\n    \"\"\"\n    Convert a time duration string in the format 'XhYminZs' to milliseconds.\n\n    This function takes a string representing a time duration, where hours, minutes, and seconds\n    are optionally provided, and converts this duration into the equivalent number of milliseconds.\n\n    Args:\n        time_str (str): A string representing the time duration, e.g., '1h20min30s'.\n\n    Returns:\n        Optional[int]: The equivalent duration in milliseconds, or None if the input is invalid.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestConvertHmsToMilliseconds(unittest.TestCase):\n\n    def test_basic_conversion(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"1h20min30s\"), 4830000, \"Should convert 1h20min30s to 4830000 milliseconds\")\n\n    def test_no_hours_or_minutes(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"30s\"), 30000, \"Should convert 30s to 30000 milliseconds\")\n\n    def test_invalid_format(self):\n        self.assertIsNone(convert_hms_to_milliseconds(\"1hour20minutes\"), \"Should return None for invalid time format\")\n\n    def test_edge_case_max_one_day(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"23h59min59s\"), 86399000, \"Should convert 23h59min59s to 86399000 milliseconds\")\n\n    def test_exceeding_one_day(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"24h1min\"), 86460000,\n                         \"Should correctly convert 24h1min to 86460000 milliseconds\")", "prompt": "please write a python function , the function signature as below from typing import Optional\n\n\ndef convert_hms_to_milliseconds(time_str: str) -> Optional[int]:\n    \"\"\"\n    Convert a time duration string in the format 'XhYminZs' to milliseconds.\n\n    This function takes a string representing a time duration, where hours, minutes, and seconds\n    are optionally provided, and converts this duration into the equivalent number of milliseconds.\n\n    Args:\n        time_str (str): A string representing the time duration, e.g., '1h20min30s'.\n\n    Returns:\n        Optional[int]: The equivalent duration in milliseconds, or None if the input is invalid.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Convert a time duration string in the format 'XhYminZs' to milliseconds.\n *\n * This function takes a string representing a time duration, where hours, minutes, and seconds\n * are optionally provided, and converts this duration into the equivalent number of milliseconds.\n *\n * @param {string} timeStr - A string representing the time duration, e.g., '1h20min30s'.\n * @returns {number | null} - The equivalent duration in milliseconds, or null if the input is invalid.\n */\nfunction convertHmsToMilliseconds(timeStr) {}", "test_code": "describe('TestConvertHmsToMilliseconds', () => {\n  test('test_basic_conversion', () => {\n      expect(convertHmsToMilliseconds(\"1h20min30s\")).toBe(4830000);\n  });\n\n  test('test_no_hours_or_minutes', () => {\n      expect(convertHmsToMilliseconds(\"30s\")).toBe(30000);\n  });\n\n  test('test_invalid_format', () => {\n      expect(convertHmsToMilliseconds(\"1hour20minutes\")).toBeNull();\n  });\n\n  test('test_edge_case_max_one_day', () => {\n      expect(convertHmsToMilliseconds(\"23h59min59s\")).toBe(86399000);\n  });\n\n  test('test_exceeding_one_day', () => {\n      expect(convertHmsToMilliseconds(\"24h1min\")).toBe(86460000);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Convert a time duration string in the format 'XhYminZs' to milliseconds.\n *\n * This function takes a string representing a time duration, where hours, minutes, and seconds\n * are optionally provided, and converts this duration into the equivalent number of milliseconds.\n *\n * @param {string} timeStr - A string representing the time duration, e.g., '1h20min30s'.\n * @returns {number | null} - The equivalent duration in milliseconds, or null if the input is invalid.\n */\nfunction convertHmsToMilliseconds(timeStr) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Convert a time duration string in the format 'XhYminZs' to milliseconds.\n *\n * This function takes a string representing a time duration, where hours, minutes, and seconds\n * are optionally provided, and converts this duration into the equivalent number of milliseconds.\n *\n * @param timeStr - A string representing the time duration, e.g., '1h20min30s'.\n * @returns The equivalent duration in milliseconds, or null if the input is invalid.\n */\nfunction convertHmsToMilliseconds(timeStr: string): number | null {}", "test_code": "describe('TestConvertHmsToMilliseconds', () => {\n  it('should convert 1h20min30s to 4830000 milliseconds', () => {\n    expect(convertHmsToMilliseconds('1h20min30s')).toBe(4830000);\n  });\n\n  it('should convert 30s to 30000 milliseconds', () => {\n    expect(convertHmsToMilliseconds('30s')).toBe(30000);\n  });\n\n  it('should return null for invalid time format', () => {\n    expect(convertHmsToMilliseconds('1hour20minutes')).toBeNull();\n  });\n\n  it('should convert 23h59min59s to 86399000 milliseconds', () => {\n    expect(convertHmsToMilliseconds('23h59min59s')).toBe(86399000);\n  });\n\n  it('should correctly convert 24h1min to 86460000 milliseconds', () => {\n    expect(convertHmsToMilliseconds('24h1min')).toBe(86460000);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Convert a time duration string in the format 'XhYminZs' to milliseconds.\n *\n * This function takes a string representing a time duration, where hours, minutes, and seconds\n * are optionally provided, and converts this duration into the equivalent number of milliseconds.\n *\n * @param timeStr - A string representing the time duration, e.g., '1h20min30s'.\n * @returns The equivalent duration in milliseconds, or null if the input is invalid.\n */\nfunction convertHmsToMilliseconds(timeStr: string): number | null {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert a time duration string in the format 'XhYminZs' to milliseconds.\n *\n * This function takes a string representing a time duration, where hours, minutes, and seconds\n * are optionally provided, and converts this duration into the equivalent number of milliseconds.\n *\n * @param time_str A string representing the time duration, e.g., '1h20min30s'.\n * @return std::optional<int> The equivalent duration in milliseconds, or std::nullopt if the input is invalid.\n */\nstd::optional<int> convert_hms_to_milliseconds(const std::string& timeStr){}", "test_code": "TEST_CASE(\"convert_hms_to_milliseconds tests\") {\n    \n    SECTION(\"Basic conversion\") {\n        REQUIRE(convert_hms_to_milliseconds(\"1h20min30s\") == 4830000);\n    }\n\n    SECTION(\"No hours or minutes\") {\n        REQUIRE(convert_hms_to_milliseconds(\"30s\") == 30000);\n    }\n\n    SECTION(\"Invalid format\") {\n        REQUIRE(convert_hms_to_milliseconds(\"1hour20minutes\") == std::nullopt);\n    }\n\n    SECTION(\"Edge case max one day\") {\n        REQUIRE(convert_hms_to_milliseconds(\"23h59min59s\") == 86399000);\n    }\n\n    SECTION(\"Exceeding one day\") {\n        REQUIRE(convert_hms_to_milliseconds(\"24h1min\") == 86460000);\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert a time duration string in the format 'XhYminZs' to milliseconds.\n *\n * This function takes a string representing a time duration, where hours, minutes, and seconds\n * are optionally provided, and converts this duration into the equivalent number of milliseconds.\n *\n * @param time_str A string representing the time duration, e.g., '1h20min30s'.\n * @return std::optional<int> The equivalent duration in milliseconds, or std::nullopt if the input is invalid.\n */\nstd::optional<int> convert_hms_to_milliseconds(const std::string& timeStr){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Convert a time duration string in the format 'XhYminZs' to milliseconds.\n *\n * This function takes a string representing a time duration, where hours, minutes, and seconds\n * are optionally provided, and converts this duration into the equivalent number of milliseconds.\n *\n * @param timeStr A string representing the time duration, e.g., '1h20min30s'.\n * @return The equivalent duration in milliseconds, or null if the input is invalid.\n */\npublic static Integer convertHmsToMilliseconds(String timeStr) {}", "test_code": "package org.real.temp;\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\nimport java.util.Optional;\n\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testBasicConversion() {\n        assertEquals(\"Should convert 1h20min30s to 4830000 milliseconds\", Optional.of(4830000).get(),convertHmsToMilliseconds(\"1h20min30s\"));\n    }\n\n    @Test\n    public void testNoHoursOrMinutes() {\n        assertEquals(\"Should convert 30s to 30000 milliseconds\",\n                Optional.of(30000).get(),\n                convertHmsToMilliseconds(\"30s\"));\n    }\n\n    @Test\n    public void testInvalidFormat() {\n        assertNull(\"Should return null for invalid time format\",\n                convertHmsToMilliseconds(\"1hour20minutes\"));\n    }\n\n    @Test\n    public void testEdgeCaseMaxOneDay() {\n        assertEquals(\"Should convert 23h59min59s to 86399000 milliseconds\",\n                Optional.of(86399000).get(),\n                convertHmsToMilliseconds(\"23h59min59s\"));\n    }\n\n    @Test\n    public void testExceedingOneDay() {\n        assertEquals(\"Should correctly convert 24h1min to 86460000 milliseconds\",\n                Optional.of(86460000).get(),\n                convertHmsToMilliseconds(\"24h1min\"));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Convert a time duration string in the format 'XhYminZs' to milliseconds.\n *\n * This function takes a string representing a time duration, where hours, minutes, and seconds\n * are optionally provided, and converts this duration into the equivalent number of milliseconds.\n *\n * @param timeStr A string representing the time duration, e.g., '1h20min30s'.\n * @return The equivalent duration in milliseconds, or null if the input is invalid.\n */\npublic static Integer convertHmsToMilliseconds(String timeStr) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 233, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "from the given string, delete the comment section that starts with the pound sign (#) and ends the line\n", "language_version_list": {"python": {"code_signature": "def remove_comments(string: str) -> str:\n    \"\"\"\n    Removes comments from the provided string. Comments start with a '#' and end at the newline.\n    For example:\n        input: Hello, world! # This is a comment\n        output:  Hello, world!\n    Args:\n        string (str): The input string containing potential comments.\n\n    Returns:\n        str: The string with all comments removed.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestRemoveComments(unittest.TestCase):\n\n    def test_single_line_comment(self):\n        \"\"\" Test string with a comment on a single line \"\"\"\n        input_string = \"Hello, world!# This is a comment\"\n        expected_output = \"Hello, world!\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n\n    def test_no_comments(self):\n        \"\"\" Test string with no comments \"\"\"\n        input_string = \"Hello, world!\\nPython is fun!\"\n        expected_output = \"Hello, world!\\nPython is fun!\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n    def test_empty_string(self):\n        \"\"\" Test an empty string \"\"\"\n        input_string = \"\"\n        expected_output = \"\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n    def test_comments_only(self):\n        \"\"\" Test string where all lines are comments \"\"\"\n        input_string = \"# comment only line\\n#another comment line\"\n        expected_output = \"\\n\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n", "prompt": "please write a python function , the function signature as below def remove_comments(string: str) -> str:\n    \"\"\"\n    Removes comments from the provided string. Comments start with a '#' and end at the newline.\n    For example:\n        input: Hello, world! # This is a comment\n        output:  Hello, world!\n    Args:\n        string (str): The input string containing potential comments.\n\n    Returns:\n        str: The string with all comments removed.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Removes comments from the provided string. Comments start with a '#' and end at the newline.\n * \n * Example:\n *   Input: \"Hello, world! # This is a comment\"\n *   Output: \"Hello, world!\"\n * \n * @param {string} string - The input string containing potential comments.\n * @returns {string} The string with all comments removed.\n */\nfunction removeComments(string) {}", "test_code": "describe('TestRemoveComments', () => {\n    describe('test_single_line_comment', () => {\n        it('should handle a single line comment correctly', () => {\n            const inputString = \"Hello, world!# This is a comment\";\n            const expectedOutput = \"Hello, world!\";\n            expect(removeComments(inputString)).toEqual(expectedOutput);\n        });\n    });\n\n    describe('test_no_comments', () => {\n        it('should handle a string with no comments correctly', () => {\n            const inputString = \"Hello, world!\\nPython is fun!\";\n            const expectedOutput = \"Hello, world!\\nPython is fun!\";\n            expect(removeComments(inputString)).toEqual(expectedOutput);\n        });\n    });\n\n    describe('test_empty_string', () => {\n        it('should handle an empty string correctly', () => {\n            const inputString = \"\";\n            const expectedOutput = \"\";\n            expect(removeComments(inputString)).toEqual(expectedOutput);\n        });\n    });\n\n    describe('test_comments_only', () => {\n        it('should handle a string where all lines are comments correctly', () => {\n            const inputString = \"# comment only line\\n#another comment line\";\n            const expectedOutput = \"\\n\";\n            expect(removeComments(inputString)).toEqual(expectedOutput);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Removes comments from the provided string. Comments start with a '#' and end at the newline.\n * \n * Example:\n *   Input: \"Hello, world! # This is a comment\"\n *   Output: \"Hello, world!\"\n * \n * @param {string} string - The input string containing potential comments.\n * @returns {string} The string with all comments removed.\n */\nfunction removeComments(string) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Removes comments from the provided string. Comments start with a '#' and end at the newline.\n * \n * Example:\n *   Input: \"Hello, world! # This is a comment\"\n *   Output: \"Hello, world!\"\n * \n * @param {string} input - The input string containing potential comments.\n * @returns {string} - The string with all comments removed.\n */\nfunction removeComments(input: string): string {}", "test_code": "describe('TestRemoveComments', () => {\n    it('should handle a single line comment', () => {\n      const inputString = \"Hello, world!# This is a comment\";\n      const expectedOutput = \"Hello, world!\";\n      expect(removeComments(inputString)).toEqual(expectedOutput);\n    });\n  \n    it('should handle a string with no comments', () => {\n      const inputString = \"Hello, world!\\nPython is fun!\";\n      const expectedOutput = \"Hello, world!\\nPython is fun!\";\n      expect(removeComments(inputString)).toEqual(expectedOutput);\n    });\n  \n    it('should handle an empty string', () => {\n      const inputString = \"\";\n      const expectedOutput = \"\";\n      expect(removeComments(inputString)).toEqual(expectedOutput);\n    });\n  \n    it('should handle a string where all lines are comments', () => {\n      const inputString = \"# comment only line\\n#another comment line\";\n      const expectedOutput = \"\\n\";\n      expect(removeComments(inputString)).toEqual(expectedOutput);\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Removes comments from the provided string. Comments start with a '#' and end at the newline.\n * \n * Example:\n *   Input: \"Hello, world! # This is a comment\"\n *   Output: \"Hello, world!\"\n * \n * @param {string} input - The input string containing potential comments.\n * @returns {string} - The string with all comments removed.\n */\nfunction removeComments(input: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Removes comments from the provided string. Comments start with a '#' and end at the newline.\n * For example:\n *     input: Hello, world! # This is a comment\n *     output:  Hello, world!\n *\n * @param string The input string containing potential comments.\n * @return The string with all comments removed.\n */\nstd::string remove_comments(const std::string& string){}", "test_code": "TEST_CASE(\"Remove comments from a string\", \"[remove_comments]\") {\n    REQUIRE(remove_comments(\"Hello, world! # This is a comment\") == \"Hello, world!\");\n    REQUIRE(remove_comments(\"# This is a comment\\nHello, world!\") == \"\\nHello, world!\");\n    REQUIRE(remove_comments(\"No comments here!\") == \"No comments here!\");\n    REQUIRE(remove_comments(\"Multiple #comments\\n#on multiple lines\") == \"\\n\");\n    REQUIRE(remove_comments(\"Comments before newline #should stay\") == \"Comments before newline \");\n    REQUIRE(remove_comments(\"Comments after newline\\n#should be removed\") == \"Comments after newline\\n\");\n}\n\nTEST_CASE(\"Edge cases\", \"[remove_comments]\") {\n    REQUIRE(remove_comments(\"\") == \"\");\n    REQUIRE(remove_comments(\"\\n\") == \"\\n\");\n    REQUIRE(remove_comments(\"#\") == \"\");\n    REQUIRE(remove_comments(\"##\") == \"#\");\n    REQUIRE(remove_comments(\"a#b#c\") == \"ab#c\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Removes comments from the provided string. Comments start with a '#' and end at the newline.\n * For example:\n *     input: Hello, world! # This is a comment\n *     output:  Hello, world!\n *\n * @param string The input string containing potential comments.\n * @return The string with all comments removed.\n */\nstd::string remove_comments(const std::string& string){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Removes comments from the provided string. Comments start with a '#' and end at the newline.\n * \n * Example:\n *     Input: \"Hello, world! # This is a comment\"\n *     Output: \"Hello, world!\"\n * \n * @param input The input string containing potential comments.\n * @return The string with all comments removed.\n */\npublic static String removeComments(String input) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testSingleLineComment() {\n        // Test string with a comment on a single line\n        String inputString = \"Hello, world!# This is a comment\";\n        String expectedOutput = \"Hello, world!\";\n        assertEquals(expectedOutput, removeComments(inputString));\n    }\n\n    @Test\n    public void testNoComments() {\n        // Test string with no comments\n        String inputString = \"Hello, world!\\nPython is fun!\";\n        String expectedOutput = \"Hello, world!\\nPython is fun!\";\n        assertEquals(expectedOutput, removeComments(inputString));\n    }\n\n    @Test\n    public void testEmptyString() {\n        // Test an empty string\n        String inputString = \"\";\n        String expectedOutput = \"\";\n        assertEquals(expectedOutput, removeComments(inputString));\n    }\n\n    @Test\n    public void testCommentsOnly() {\n        // Test string where all lines are comments\n        String inputString = \"# comment only line\\n#another comment line\";\n        String expectedOutput = \"\\n\";\n        assertEquals(expectedOutput, removeComments(inputString));\n    }\n\n    // Utility method to remove comments from a string\n    private String removeComments(String input) {\n        // Split the string into lines\n        String[] lines = input.split(\"\\n\");\n\n        // Remove the comment part from each line\n        StringBuilder cleanedString = new StringBuilder();\n        for (String line : lines) {\n            int commentIndex = line.indexOf('#');\n            if (commentIndex != -1) {\n                line = line.substring(0, commentIndex);\n            }\n            cleanedString.append(line).append(\"\\n\");\n        }\n\n        // Remove the last newline character added during the loop\n        if (cleanedString.length() > 0) {\n            cleanedString.setLength(cleanedString.length() - 1);\n        }\n\n        return cleanedString.toString();\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Removes comments from the provided string. Comments start with a '#' and end at the newline.\n * \n * Example:\n *     Input: \"Hello, world! # This is a comment\"\n *     Output: \"Hello, world!\"\n * \n * @param input The input string containing potential comments.\n * @return The string with all comments removed.\n */\npublic static String removeComments(String input) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 234, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.", "language_version_list": {"python": {"code_signature": "def append_row_after_skip_row(file_handler, reader, row_candidate):\n    \"\"\"\n    Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n\n    Args:\n        file_handler: File handler of the CSV file opened in read-plus mode ('r+').\n        reader: CSV reader object for reading existing rows.\n        row_candidate: List containing the new row to be appended.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import csv\nimport io\nimport unittest\n\n\nclass TestAppendSkipRow(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up a mock CSV file using StringIO.\"\"\"\n        self.mock_file = io.StringIO()\n        self.mock_file.write(\"Alice,30,USA\\nBob,25,UK\\nCharlie,35,Canada\\n\")\n        self.mock_file.seek(0)  # Reset pointer to the start of the mock file\n        self.reader = csv.reader(self.mock_file)\n\n    def test_append_new_row(self):\n        new_row = ['David', '28', 'Australia']\n        append_row_after_skip_row(self.mock_file, self.reader, new_row)\n\n        self.mock_file.seek(0)  # Reset pointer to read from the start\n        result = list(csv.reader(self.mock_file))\n        self.assertIn(new_row, result)\n\n    def test_skip_different_values(self):\n        new_row = ['Alice', '31', 'USA']  # Same name, different age\n        append_row_after_skip_row(self.mock_file, self.reader, new_row)\n\n        self.mock_file.seek(0)  # Reset pointer to read from the start\n        result = list(csv.reader(self.mock_file))\n        self.assertIn(new_row, result)\n\n    def test_append_row_with_different_columns(self):\n        new_row = ['Eve', '40', 'Australia', 'Engineer']\n        append_row_after_skip_row(self.mock_file, self.reader, new_row)\n\n        self.mock_file.seek(0)  # Reset pointer to read from the start\n        result = list(csv.reader(self.mock_file))\n        self.assertIn(new_row, result)\n\n    def test_multiple_appends(self):\n        new_rows = [\n            ['Frank', '29', 'Germany'],\n            ['Grace', '22', 'France']\n        ]\n\n        for row in new_rows:\n            append_row_after_skip_row(self.mock_file, self.reader, row)\n            self.mock_file.seek(0)  # Reset pointer for the next read\n            self.reader = csv.reader(self.mock_file)  # Recreate the reader after each append\n\n        self.mock_file.seek(0)  # Reset pointer to read from the start\n        result = list(csv.reader(self.mock_file))\n        for row in new_rows:\n            self.assertIn(row, result)", "prompt": "please write a python function , the function signature as below def append_row_after_skip_row(file_handler, reader, row_candidate):\n    \"\"\"\n    Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n\n    Args:\n        file_handler: File handler of the CSV file opened in read-plus mode ('r+').\n        reader: CSV reader object for reading existing rows.\n        row_candidate: List containing the new row to be appended.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n *\n * @param {fs.WriteStream} fileHandler - File handler of the CSV file opened in read-plus mode ('r+').\n * @param {csvParser} reader - CSV reader object for reading existing rows.\n * @param {Array} rowCandidate - Array containing the new row to be appended.\n */\nfunction appendOrSkipRow(fileHandler, reader, rowCandidate) {}", "test_code": "const { createWriteStream } = require('fs');\nconst { createStringReader } = require('csv-parser');\nconst { createObjectCsvWriter } = require('csv-writer');\ndescribe('TestAppendOrSkipRow', () => {\n  beforeEach(() => {\n      // Set up a mock CSV file using a string buffer\n      this.mockFile = new createStringReader('Alice,30,USA\\nBob,25,UK\\nCharlie,35,Canada\\n');\n      this.reader = this.mockFile;\n  });\n\n  afterEach(() => {\n      // Reset the mock file for each test\n      this.mockFile.reset();\n  });\n\n  it('test_append_new_row', () => {\n      // Test appending a new row when there are no matching values\n      const newRow = ['David', '28', 'Australia'];\n      appendOrSkipRow(this.mockFile, this.reader, newRow);\n\n      this.mockFile.reset();  // Reset pointer to read from the start\n      const result = this.mockFile.readAll();\n      expect(result).toContainEqual(newRow);\n  });\n\n  it('test_skip_different_values', () => {\n      // Test appending a new row with different values\n      const newRow = ['Alice', '31', 'USA'];  // Same name, different age\n      appendOrSkipRow(this.mockFile, this.reader, newRow);\n\n      this.mockFile.reset();  // Reset pointer to read from the start\n      const result = this.mockFile.readAll();\n      expect(result).toContainEqual(newRow);\n  });\n\n  it('test_append_row_with_different_columns', () => {\n      // Test appending a row with different values in the first three columns\n      const newRow = ['Eve', '40', 'Australia', 'Engineer'];\n      appendOrSkipRow(this.mockFile, this.reader, newRow);\n\n      this.mockFile.reset();  // Reset pointer to read from the start\n      const result = this.mockFile.readAll();\n      expect(result).toContainEqual(newRow);\n  });\n\n  it('test_multiple_appends', () => {\n      // Test appending multiple new rows correctly\n      const newRows = [\n          ['Frank', '29', 'Germany'],\n          ['Grace', '22', 'France']\n      ];\n\n      for (const row of newRows) {\n          appendOrSkipRow(this.mockFile, this.reader, row);\n          this.mockFile.reset();  // Reset pointer for the next read\n          this.reader = this.mockFile;\n      }\n\n      this.mockFile.reset();  // Reset pointer to read from the start\n      const result = this.mockFile.readAll();\n      newRows.forEach(row => expect(result).toContainEqual(row));\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n *\n * @param {fs.WriteStream} fileHandler - File handler of the CSV file opened in read-plus mode ('r+').\n * @param {csvParser} reader - CSV reader object for reading existing rows.\n * @param {Array} rowCandidate - Array containing the new row to be appended.\n */\nfunction appendOrSkipRow(fileHandler, reader, rowCandidate) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as fs from 'fs';\nimport * as csvParser from 'csv-parser';\nimport * as createCsvWriter from 'csv-writer';\n/**\n * Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n *\n * @param fileHandler - File handler of the CSV file opened in read-plus mode ('r+').\n * @param reader - CSV reader object for reading existing rows.\n * @param rowCandidate - Array containing the new row to be appended.\n */\nfunction appendOrSkipRow(fileHandler: fs.WriteStream, reader: csvParser.CSVParser, rowCandidate: string[]): void {}", "test_code": "import * as fs from 'fs';\nimport * as csvParser from 'csv-parser';\nimport * as createCsvWriter from 'csv-writer';\ndescribe('TestAppendOrSkipRow', () => {\n  let mockFile: fs.WriteStream;\n  let reader: csvParser.CSVParser;\n\n  beforeEach(() => {\n    // Set up a mock CSV file using a temporary file\n    const tempFilePath = 'temp.csv';\n    mockFile = fs.createWriteStream(tempFilePath);\n    mockFile.write('Alice,30,USA\\nBob,25,UK\\nCharlie,35,Canada\\n');\n    mockFile.end();\n\n    // Wait for the file to be written\n    return new Promise(resolve => mockFile.on('finish', resolve)).then(() => {\n      mockFile = fs.createReadStream(tempFilePath);\n      reader = csvParser();\n    });\n  });\n\n  afterEach(() => {\n    // Clean up the temporary file\n    fs.unlinkSync('temp.csv');\n  });\n\n  it('should append a new row when there are no matching values', () => {\n    const new_row = ['David', '28', 'Australia'];\n    appendOrSkipRow(mockFile, reader, new_row);\n\n    // Reset pointer to read from the start\n    mockFile = fs.createReadStream('temp.csv');\n    reader = csvParser();\n\n    const results: string[][] = [];\n    mockFile\n      .pipe(reader)\n      .on('data', (row) => {\n        results.push(Object.values(row));\n      })\n      .on('end', () => {\n        expect(results).toContainEqual(new_row);\n      });\n  });\n\n  it('should append a new row with different values', () => {\n    const new_row = ['Alice', '31', 'USA']; // Same name, different age\n    appendOrSkipRow(mockFile, reader, new_row);\n\n    // Reset pointer to read from the start\n    mockFile = fs.createReadStream('temp.csv');\n    reader = csvParser();\n\n    const results: string[][] = [];\n    mockFile\n      .pipe(reader)\n      .on('data', (row) => {\n        results.push(Object.values(row));\n      })\n      .on('end', () => {\n        expect(results).toContainEqual(new_row);\n      });\n  });\n\n  it('should append a row with different values in the first three columns', () => {\n    const new_row = ['Eve', '40', 'Australia', 'Engineer'];\n    appendOrSkipRow(mockFile, reader, new_row);\n\n    // Reset pointer to read from the start\n    mockFile = fs.createReadStream('temp.csv');\n    reader = csvParser();\n\n    const results: string[][] = [];\n    mockFile\n      .pipe(reader)\n      .on('data', (row) => {\n        results.push(Object.values(row));\n      })\n      .on('end', () => {\n        expect(results).toContainEqual(new_row);\n      });\n  });\n\n  it('should append multiple new rows correctly', () => {\n    const new_rows = [\n      ['Frank', '29', 'Germany'],\n      ['Grace', '22', 'France']\n    ];\n\n    for (const row of new_rows) {\n      appendOrSkipRow(mockFile, reader, row);\n      mockFile = fs.createReadStream('temp.csv');\n      reader = csvParser();\n    }\n\n    const results: string[][] = [];\n    mockFile\n      .pipe(reader)\n      .on('data', (row) => {\n        results.push(Object.values(row));\n      })\n      .on('end', () => {\n        new_rows.forEach(row => expect(results).toContainEqual(row));\n      });\n  });\n});", "prompt": "please write a typescript function , the function signature as below import * as fs from 'fs';\nimport * as csvParser from 'csv-parser';\nimport * as createCsvWriter from 'csv-writer';\n/**\n * Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n *\n * @param fileHandler - File handler of the CSV file opened in read-plus mode ('r+').\n * @param reader - CSV reader object for reading existing rows.\n * @param rowCandidate - Array containing the new row to be appended.\n */\nfunction appendOrSkipRow(fileHandler: fs.WriteStream, reader: csvParser.CSVParser, rowCandidate: string[]): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n *\n * @param fileHandler File stream of the CSV file opened in read-plus mode ('r+').\n * @param reader CSV reader object for reading existing rows.\n * @param rowCandidate Vector containing the new row to be appended.\n */\nvoid appendOrSkipRow(std::fstream& fileHandler, std::istream& reader, const std::vector<std::string>& rowCandidate){\n\n}", "test_code": "TEST_CASE(\"append_or_skip_row\", \"[csv]\") {\n    // Create a temporary CSV file with some initial data\n    std::ofstream tempFile(\"temp.csv\");\n    tempFile << \"col1,col2,col3,col4\\n\";\n    tempFile << \"value1,value2,value3,value4\\n\";\n    tempFile.close();\n\n    // Open the file in read-plus mode\n    std::fstream fileHandler(\"temp.csv\", std::ios::in | std::ios::out);\n    REQUIRE(fileHandler.is_open());\n\n    // Read the existing rows into a vector\n    std::vector<std::string> rows;\n    std::string line;\n    while (std::getline(reader, line)) {\n        rows.push_back(line);\n    }\n\n    // Define the candidate row to append\n    std::vector<std::string> rowCandidate = {\"value5\", \"value6\", \"value7\", \"value8\"};\n\n    // Call the function under test\n    append_or_skip_row(fileHandler, reader, rowCandidate);\n\n    // Seek back to the beginning of the file to read the updated content\n    fileHandler.seekg(0, std::ios::beg);\n    std::stringstream ss;\n    ss << fileHandler.rdbuf();\n    std::string updatedContent = ss.str();\n\n    // Check that the candidate row was appended\n    REQUIRE(updatedContent.find(\"value5,value6,value7,value8\") != std::string::npos);\n\n    // Clean up\n    fileHandler.close();\n    std::remove(\"temp.csv\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n *\n * @param fileHandler File stream of the CSV file opened in read-plus mode ('r+').\n * @param reader CSV reader object for reading existing rows.\n * @param rowCandidate Vector containing the new row to be appended.\n */\nvoid appendOrSkipRow(std::fstream& fileHandler, std::istream& reader, const std::vector<std::string>& rowCandidate){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n *\n * @param fileHandler The file handler of the CSV file opened in read-plus mode ('r+').\n * @param reader The CSV reader object for reading existing rows.\n * @param rowCandidate The list containing the new row to be appended.\n */\npublic static void appendOrSkipRow(PrintWriter fileHandler, List<String> reader, List<String> rowCandidate) {}", "test_code": "package org.real.temp;\nimport static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport com.opencsv.CSVReader;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    private StringWriter mockFile;\n    private CSVReader reader;\n\n    @Before\n    public void setUp() throws IOException {\n        // Set up a mock CSV file using StringWriter (similar to StringIO in Python)\n        mockFile = new StringWriter();\n        mockFile.write(\"Alice,30,USA\\nBob,25,UK\\nCharlie,35,Canada\\n\");\n        mockFile.flush(); // Ensure all data is written\n        reader = new CSVReader(new StringReader(mockFile.toString()));\n    }\n\n    @Test\n    public void testAppendNewRow() throws IOException {\n        // Test appending a new row when there are no matching values.\n        String[] newRow = {\"David\", \"28\", \"Australia\"};\n        appendOrSkipRow(mockFile, reader, newRow);\n\n        // Reset the reader and check the contents of the file\n        mockFile.flush();\n        CSVReader resultReader = new CSVReader(new StringReader(mockFile.toString()));\n        List<String[]> result = resultReader.readAll();\n\n        // Check if the new row has been appended\n        boolean rowFound = false;\n        for (String[] row : result) {\n            if (row[0].equals(\"David\") && row[1].equals(\"28\") && row[2].equals(\"Australia\")) {\n                rowFound = true;\n                break;\n            }\n        }\n        assertTrue(\"New row should be appended\", rowFound);\n    }\n\n    @Test\n    public void testSkipDifferentValues() throws IOException {\n        // Test appending a new row with different values (same name, different age)\n        String[] newRow = {\"Alice\", \"31\", \"USA\"};\n        appendOrSkipRow(mockFile, reader, newRow);\n\n        // Reset the reader and check the contents of the file\n        mockFile.flush();\n        CSVReader resultReader = new CSVReader(new StringReader(mockFile.toString()));\n        List<String[]> result = resultReader.readAll();\n\n        // Check if the new row has been appended\n        boolean rowFound = false;\n        for (String[] row : result) {\n            if (row[0].equals(\"Alice\") && row[1].equals(\"31\") && row[2].equals(\"USA\")) {\n                rowFound = true;\n                break;\n            }\n        }\n        assertTrue(\"Row with different values should be appended\", rowFound);\n    }\n\n    @Test\n    public void testAppendRowWithDifferentColumns() throws IOException {\n        // Test appending a row with different values in the first three columns\n        String[] newRow = {\"Eve\", \"40\", \"Australia\", \"Engineer\"};\n        appendOrSkipRow(mockFile, reader, newRow);\n\n        // Reset the reader and check the contents of the file\n        mockFile.flush();\n        CSVReader resultReader = new CSVReader(new StringReader(mockFile.toString()));\n        List<String[]> result = resultReader.readAll();\n\n        // Check if the new row with different columns has been appended\n        boolean rowFound = false;\n        for (String[] row : result) {\n            if (row[0].equals(\"Eve\") && row[1].equals(\"40\") && row[2].equals(\"Australia\")) {\n                rowFound = true;\n                break;\n            }\n        }\n        assertTrue(\"Row with different columns should be appended\", rowFound);\n    }\n\n    @Test\n    public void testMultipleAppends() throws IOException {\n        // Test appending multiple new rows correctly\n        String[][] newRows = {\n                {\"Frank\", \"29\", \"Germany\"},\n                {\"Grace\", \"22\", \"France\"}\n        };\n\n        for (String[] row : newRows) {\n            appendOrSkipRow(mockFile, reader, row);\n            mockFile.flush(); // Reset the file and reader for the next append\n            reader = new CSVReader(new StringReader(mockFile.toString()));\n        }\n\n        // Reset the reader and check if all rows are appended correctly\n        mockFile.flush();\n        CSVReader resultReader = new CSVReader(new StringReader(mockFile.toString()));\n        List<String[]> result = resultReader.readAll();\n\n        for (String[] row : newRows) {\n            boolean rowFound = false;\n            for (String[] resultRow : result) {\n                if (resultRow[0].equals(row[0]) && resultRow[1].equals(row[1]) && resultRow[2].equals(row[2])) {\n                    rowFound = true;\n                    break;\n                }\n            }\n            assertTrue(\"New row should be appended\", rowFound);\n        }\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n *\n * @param fileHandler The file handler of the CSV file opened in read-plus mode ('r+').\n * @param reader The CSV reader object for reading existing rows.\n * @param rowCandidate The list containing the new row to be appended.\n */\npublic static void appendOrSkipRow(PrintWriter fileHandler, List<String> reader, List<String> rowCandidate) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 235, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "calculate the azimuth between two points on the earth. This function accepts the latitude and longitude of the two points as a parameter and returns the azimuth from the first point to the second point in degrees\n", "language_version_list": {"python": {"code_signature": "def calculate_bearing(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the azimuth between two points on the earth. This function accepts the latitude and longitude of the two points as a parameter and returns the azimuth from the first point to the second point in degrees\n    Args:\n        lat1 (float): Latitude of the starting point in decimal degrees.\n        lon1 (float): Longitude of the starting point in decimal degrees.\n        lat2 (float): Latitude of the ending point in decimal degrees.\n        lon2 (float): Longitude of the ending point in decimal degrees.\n\n    Returns:\n        float: Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestCalculateBearing(unittest.TestCase):\n    def test_north_bearing(self):\n        # From equator directly north\n        self.assertAlmostEqual(calculate_bearing(0, 0, 10, 0), 0)\n\n    def test_east_bearing(self):\n        # From prime meridian directly east\n        self.assertAlmostEqual(calculate_bearing(0, 0, 0, 10), 90)\n\n    def test_south_bearing(self):\n        # From a point directly south\n        self.assertAlmostEqual(calculate_bearing(10, 0, 0, 0), 180)\n\n    def test_west_bearing(self):\n        # From a point directly west\n        self.assertAlmostEqual(calculate_bearing(0, 10, 0, 0), 270)\n\n    def test_across_prime_meridian(self):\n        # From a point west of the prime meridian to a point east\n        self.assertAlmostEqual(calculate_bearing(0, -1, 0, 1), 90)", "prompt": "please write a python function , the function signature as below def calculate_bearing(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the azimuth between two points on the earth. This function accepts the latitude and longitude of the two points as a parameter and returns the azimuth from the first point to the second point in degrees\n    Args:\n        lat1 (float): Latitude of the starting point in decimal degrees.\n        lon1 (float): Longitude of the starting point in decimal degrees.\n        lat2 (float): Latitude of the ending point in decimal degrees.\n        lon2 (float): Longitude of the ending point in decimal degrees.\n\n    Returns:\n        float: Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculates the azimuth between two points on the Earth.\n * This function accepts the latitude and longitude of the two points as parameters and returns the azimuth from the first point to the second point in degrees.\n * \n * @param {number} lat1 - Latitude of the starting point in decimal degrees.\n * @param {number} lon1 - Longitude of the starting point in decimal degrees.\n * @param {number} lat2 - Latitude of the ending point in decimal degrees.\n * @param {number} lon2 - Longitude of the ending point in decimal degrees.\n * @returns {number} Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n */\nfunction calculateBearing(lat1, lon1, lat2, lon2) {}", "test_code": "describe('TestCalculateBearing', () => {\n    it('should calculate north bearing correctly', () => {\n        // From equator directly north\n        expect(calculateBearing(0, 0, 10, 0)).toBeCloseTo(0);\n    });\n\n    it('should calculate east bearing correctly', () => {\n        // From prime meridian directly east\n        expect(calculateBearing(0, 0, 0, 10)).toBeCloseTo(90);\n    });\n\n    it('should calculate south bearing correctly', () => {\n        // From a point directly south\n        expect(calculateBearing(10, 0, 0, 0)).toBeCloseTo(180);\n    });\n\n    it('should calculate west bearing correctly', () => {\n        // From a point directly west\n        expect(calculateBearing(0, 10, 0, 0)).toBeCloseTo(270);\n    });\n\n    it('should calculate bearing across prime meridian correctly', () => {\n        // From a point west of the prime meridian to a point east\n        expect(calculateBearing(0, -1, 0, 1)).toBeCloseTo(90);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the azimuth between two points on the Earth.\n * This function accepts the latitude and longitude of the two points as parameters and returns the azimuth from the first point to the second point in degrees.\n * \n * @param {number} lat1 - Latitude of the starting point in decimal degrees.\n * @param {number} lon1 - Longitude of the starting point in decimal degrees.\n * @param {number} lat2 - Latitude of the ending point in decimal degrees.\n * @param {number} lon2 - Longitude of the ending point in decimal degrees.\n * @returns {number} Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n */\nfunction calculateBearing(lat1, lon1, lat2, lon2) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculates the azimuth between two points on the Earth.\n * This function accepts the latitude and longitude of the two points as parameters and returns the azimuth from the first point to the second point in degrees.\n * \n * @param lat1 - Latitude of the starting point in decimal degrees.\n * @param lon1 - Longitude of the starting point in decimal degrees.\n * @param lat2 - Latitude of the ending point in decimal degrees.\n * @param lon2 - Longitude of the ending point in decimal degrees.\n * @returns The bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n */\nfunction calculateBearing(lat1: number, lon1: number, lat2: number, lon2: number): number {}", "test_code": "describe('TestCalculateBearing', () => {\n    it('should calculate north bearing correctly', () => {\n      // From equator directly north\n      expect(calculateBearing(0, 0, 10, 0)).toBeCloseTo(0);\n    });\n  \n    it('should calculate east bearing correctly', () => {\n      // From prime meridian directly east\n      expect(calculateBearing(0, 0, 0, 10)).toBeCloseTo(90);\n    });\n  \n    it('should calculate south bearing correctly', () => {\n      // From a point directly south\n      expect(calculateBearing(10, 0, 0, 0)).toBeCloseTo(180);\n    });\n  \n    it('should calculate west bearing correctly', () => {\n      // From a point directly west\n      expect(calculateBearing(0, 10, 0, 0)).toBeCloseTo(270);\n    });\n  \n    it('should calculate bearing across prime meridian correctly', () => {\n      // From a point west of the prime meridian to a point east\n      expect(calculateBearing(0, -1, 0, 1)).toBeCloseTo(90);\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the azimuth between two points on the Earth.\n * This function accepts the latitude and longitude of the two points as parameters and returns the azimuth from the first point to the second point in degrees.\n * \n * @param lat1 - Latitude of the starting point in decimal degrees.\n * @param lon1 - Longitude of the starting point in decimal degrees.\n * @param lat2 - Latitude of the ending point in decimal degrees.\n * @param lon2 - Longitude of the ending point in decimal degrees.\n * @returns The bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n */\nfunction calculateBearing(lat1: number, lon1: number, lat2: number, lon2: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculates the azimuth between two points on the Earth.\n *\n * @param lat1 The latitude of the starting point in decimal degrees.\n * @param lon1 The longitude of the starting point in decimal degrees.\n * @param lat2 The latitude of the ending point in decimal degrees.\n * @param lon2 The longitude of the ending point in decimal degrees.\n *\n * @return The bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n */\ndouble calculate_bearing(double lat1, double lon1, double lat2, double lon2);\n", "test_code": "// Helper function to compare floating point values with a tolerance\nbool approximately_equal(double a, double b, double epsilon = 1e-9) {\n    return std::abs(a - b) < epsilon;\n}\n\nTEST_CASE(\"Calculate Bearing Tests\", \"[calculate_bearing]\") {\n    SECTION(\"North Bearing\") {\n        // From equator directly north\n        REQUIRE(approximately_equal(calculate_bearing(0, 0, 10, 0), 0));\n    }\n\n    SECTION(\"East Bearing\") {\n        // From prime meridian directly east\n        REQUIRE(approximately_equal(calculate_bearing(0, 0, 0, 10), 90));\n    }\n\n    SECTION(\"South Bearing\") {\n        // From a point directly south\n        REQUIRE(approximately_equal(calculate_bearing(10, 0, 0, 0), 180));\n    }\n\n    SECTION(\"West Bearing\") {\n        // From a point directly west\n        REQUIRE(approximately_equal(calculate_bearing(0, 10, 0, 0), 270));\n    }\n\n    SECTION(\"Across Prime Meridian\") {\n        // From a point west of the prime meridian to a point east\n        REQUIRE(approximately_equal(calculate_bearing(0, -1, 0, 1), 90));\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculates the azimuth between two points on the Earth.\n *\n * @param lat1 The latitude of the starting point in decimal degrees.\n * @param lon1 The longitude of the starting point in decimal degrees.\n * @param lat2 The latitude of the ending point in decimal degrees.\n * @param lon2 The longitude of the ending point in decimal degrees.\n *\n * @return The bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n */\ndouble calculate_bearing(double lat1, double lon1, double lat2, double lon2);\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the bearing from one latitude and longitude to another.\n * \n * @param lat1 Latitude of the starting point in decimal degrees.\n * @param lon1 Longitude of the starting point in decimal degrees.\n * @param lat2 Latitude of the ending point in decimal degrees.\n * @param lon2 Longitude of the ending point in decimal degrees.\n * @return Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n */\npublic static double calculateBearing(double lat1, double lon1, double lat2, double lon2) {}", "test_code": "package org.real.temp;\n\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n\n    @Test\n    public void testNorthBearing() {\n        assertEquals(0, calculateBearing(0, 0, 10, 0), 1e-9);\n    }\n\n    @Test\n    public void testEastBearing() {\n        // From prime meridian directly east\n        assertEquals(90, calculateBearing(0, 0, 0, 10), 1e-9);\n    }\n\n    @Test\n    public void testSouthBearing() {\n        // From a point directly south\n            assertEquals(180, calculateBearing(10, 0, 0, 0), 1e-9);\n    }\n\n    @Test\n    public void testWestBearing() {\n        // From a point directly west\n        assertEquals(270, calculateBearing(0, 10, 0, 0), 1e-9);\n    }\n\n    @Test\n    public void testAcrossPrimeMeridian() {\n        // From a point west of the prime meridian to a point east\n        assertEquals(90, calculateBearing(0, -1, 0, 1), 1e-9);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Calculates the bearing from one latitude and longitude to another.\n * \n * @param lat1 Latitude of the starting point in decimal degrees.\n * @param lon1 Longitude of the starting point in decimal degrees.\n * @param lat2 Latitude of the ending point in decimal degrees.\n * @param lon2 Longitude of the ending point in decimal degrees.\n * @return Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n */\npublic static double calculateBearing(double lat1, double lon1, double lat2, double lon2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 240, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "    Converts a time duration string into a timedelta object.\n    The input string can include days (d), hours (h), minutes (m), seconds (s), and milliseconds (ms).\n    Each unit should be specified by an integer followed by its corresponding unit letter.", "language_version_list": {"python": {"code_signature": "from datetime import timedelta\nimport re\n\n\ndef gen_timeout_timedelta(time_string: str) -> timedelta:\n    \"\"\"\n    Converts a time duration string into a timedelta object.\n    The input string can include days (d), hours (h), minutes (m), seconds (s), and milliseconds (ms).\n    eg. \"1d 2h 3m 4s 500ms\"\n    Each unit should be specified by an integer followed by its corresponding unit letter.\n\n    Args:\n        time_string (str): A string representing the time duration.\n\n    Returns:\n        timedelta: A timedelta object representing the input duration.\n    \"\"\"", "test_code": "import unittest\nfrom datetime import timedelta\n\n\nclass TestGenTimeoutTimedelta(unittest.TestCase):\n    def test_single_unit_days(self):\n        self.assertEqual(gen_timeout_timedelta(\"5d\"), timedelta(days=5))\n\n\n    def test_single_unit_hours(self):\n        self.assertEqual(gen_timeout_timedelta(\"8h\"), timedelta(hours=8))\n\n    def test_single_unit_minutes(self):\n        self.assertEqual(gen_timeout_timedelta(\"45m\"), timedelta(minutes=45))\n\n    def test_single_unit_seconds(self):\n        self.assertEqual(gen_timeout_timedelta(\"30s\"), timedelta(seconds=30))\n\n    def test_complex_mix(self):\n        self.assertEqual(gen_timeout_timedelta(\"2d 20h 30m\"), timedelta(days=2, hours=20, minutes=30))\n\n    def test_no_units(self):\n        self.assertEqual(gen_timeout_timedelta(\"\"), timedelta(0))", "prompt": "please write a python function , the function signature as below from datetime import timedelta\nimport re\n\n\ndef gen_timeout_timedelta(time_string: str) -> timedelta:\n    \"\"\"\n    Converts a time duration string into a timedelta object.\n    The input string can include days (d), hours (h), minutes (m), seconds (s), and milliseconds (ms).\n    eg. \"1d 2h 3m 4s 500ms\"\n    Each unit should be specified by an integer followed by its corresponding unit letter.\n\n    Args:\n        time_string (str): A string representing the time duration.\n\n    Returns:\n        timedelta: A timedelta object representing the input duration.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a time duration string into a timedelta object.\n * The input string can include days (d), hours (h), minutes (m), seconds (s), and milliseconds (ms).\n * eg. \"1d 2h 3m 4s 500ms\"\n * Each unit should be specified by an integer followed by its corresponding unit letter.\n *\n * @param {string} timeString - A string representing the time duration.\n * @returns {number} - The total time in milliseconds.\n */\nfunction genTimeoutTimedelta(timeString) {\n\n}", "test_code": "describe('genTimeoutTimedelta', () => {\n  it('should convert \"1d 2h 3m 4s 500ms\" to correct timedelta', () => {\n    const result = genTimeoutTimedelta(\"1d 2h 3m 4s 500ms\");\n    expect(result).toEqual({\n      days: 1,\n      hours: 2,\n      minutes: 3,\n      seconds: 4,\n      milliseconds: 500\n    });\n  });\n\n  it('should handle negative values correctly', () => {\n    const result = genTimeoutTimedelta(\"-1d -2h -3m -4s -500ms\");\n    expect(result).toEqual({\n      days: -1,\n      hours: -2,\n      minutes: -3,\n      seconds: -4,\n      milliseconds: -500\n    });\n  });\n\n  it('should handle fractional values correctly', () => {\n    const result = genTimeoutTimedelta(\"0.5d 1.5h 2.5m 3.5s 4.5ms\");\n    expect(result).toEqual({\n      days: 0.5,\n      hours: 1.5,\n      minutes: 2.5,\n      seconds: 3.5,\n      milliseconds: 4.5\n    });\n  });\n\n  it('should throw error for invalid input', () => {\n    expect(() => genTimeoutTimedelta(\"invalid_input\")).toThrow();\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a time duration string into a timedelta object.\n * The input string can include days (d), hours (h), minutes (m), seconds (s), and milliseconds (ms).\n * eg. \"1d 2h 3m 4s 500ms\"\n * Each unit should be specified by an integer followed by its corresponding unit letter.\n *\n * @param {string} timeString - A string representing the time duration.\n * @returns {number} - The total time in milliseconds.\n */\nfunction genTimeoutTimedelta(timeString) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a time duration string into a `Date` object.\n * The input string can include days (d), hours (h), minutes (m), seconds (s), and milliseconds (ms).\n * e.g. \"1d 2h 3m 4s 500ms\"\n * Each unit should be specified by an integer followed by its corresponding unit letter.\n *\n * @param {string} timeString - A string representing the time duration.\n * @returns {Date} - A Date object representing the input duration.\n */\nfunction genTimeoutDuration(timeString: string): Date {\n\n}", "test_code": "describe('genTimeoutTimedelta', () => {\n  it('should convert \"1d 2h 3m 4s 500ms\" to correct timedelta', () => {\n    const result = genTimeoutTimedelta(\"1d 2h 3m 4s 500ms\");\n    expect(result).toEqual({\n      days: 1,\n      hours: 2,\n      minutes: 3,\n      seconds: 4,\n      milliseconds: 500\n    });\n  });\n\n  it('should convert \"2h 30m\" to correct timedelta', () => {\n    const result = genTimeoutTimedelta(\"2h 30m\");\n    expect(result).toEqual({\n      days: 0,\n      hours: 2,\n      minutes: 30,\n      seconds: 0,\n      milliseconds: 0\n    });\n  });\n\n  it('should convert \"1s\" to correct timedelta', () => {\n    const result = genTimeoutTimedelta(\"1s\");\n    expect(result).toEqual({\n      days: 0,\n      hours: 0,\n      minutes: 0,\n      seconds: 1,\n      milliseconds: 0\n    });\n  });\n\n  it('should convert \"500ms\" to correct timedelta', () => {\n    const result = genTimeoutTimedelta(\"500ms\");\n    expect(result).toEqual({\n      days: 0,\n      hours: 0,\n      minutes: 0,\n      seconds: 0,\n      milliseconds: 500\n    });\n  });\n\n  it('should handle empty string', () => {\n    const result = genTimeoutTimedelta(\"\");\n    expect(result).toEqual({\n      days: 0,\n      hours: 0,\n      minutes: 0,\n      seconds: 0,\n      milliseconds: 0\n    });\n  });\n\n  it('should throw error for invalid input', () => {\n    expect(() => genTimeoutTimedelta(\"invalid_input\")).toThrowError();\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a time duration string into a `Date` object.\n * The input string can include days (d), hours (h), minutes (m), seconds (s), and milliseconds (ms).\n * e.g. \"1d 2h 3m 4s 500ms\"\n * Each unit should be specified by an integer followed by its corresponding unit letter.\n *\n * @param {string} timeString - A string representing the time duration.\n * @returns {Date} - A Date object representing the input duration.\n */\nfunction genTimeoutDuration(timeString: string): Date {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 241, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "finds the minimum distance between two words in a text file, considering each line as a separate sequence \uff0creturns the line number and shortest distance at which the distance occurs\n", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef get_min_seq_num_and_distance(file_path: str, word1: str, word2: str) -> Tuple[int, int]:\n    \"\"\"\n    Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n    Args:\n        file_path (str): The path to the file to read.\n        word1 (str): The first word to search for.\n        word2 (str): The second word to search for.\n\n    Returns:\n        tuple: A tuple containing the line number with the minimum distance and the minimum distance itself.\n          Returns (None, float('inf')) if one or both words are not found in any line.\n    \"\"\"\n", "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestGetMinDistance(unittest.TestCase):\n\n    def test_basic_functionality(self):\n        \"\"\" Test basic functionality with expected input \"\"\"\n        mock_content = \"hello world\\napple banana apple\\norange apple banana\"\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (2, 1))\n\n\n    def test_words_not_present(self):\n        \"\"\" Test case where one or both words are not present \"\"\"\n        mock_content = \"apple orange pear\\norange pear apple\"\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (None, float('inf')))\n\n    def test_empty_file(self):\n        \"\"\" Test an empty file \"\"\"\n        with patch('builtins.open', mock_open(read_data='')):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (None, float('inf')))\n\n    def test_multiple_lines_with_varying_distances(self):\n        \"\"\" Test multiple lines with varying distances between words \"\"\"\n        mock_content = \"apple banana\\napple orange orange banana\\napple orange orange orange banana\"\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (1, 1))", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef get_min_seq_num_and_distance(file_path: str, word1: str, word2: str) -> Tuple[int, int]:\n    \"\"\"\n    Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n    Args:\n        file_path (str): The path to the file to read.\n        word1 (str): The first word to search for.\n        word2 (str): The second word to search for.\n\n    Returns:\n        tuple: A tuple containing the line number with the minimum distance and the minimum distance itself.\n          Returns (None, float('inf')) if one or both words are not found in any line.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n * @param {string} filePath - The path to the file to read.\n * @param {string} word1 - The first word to search for.\n * @param {string} word2 - The second word to search for.\n * @returns {Array} An array containing the line number with the minimum distance and the minimum distance itself.\n *                  Returns [null, Infinity] if one or both words are not found in any line.\n */\nfunction getMinSeqNumAndDistance(filePath, word1, word2) {}", "test_code": "const fs = require('fs');\ndescribe('TestGetMinDistance', () => {\n    it('test basic functionality with expected input', () => {\n        const mockContent = \"hello world\\napple banana apple\\norange apple banana\";\n        const mockFs = {\n            readFileSync: jest.fn(() => mockContent),\n        };\n\n        global.fs = mockFs;\n\n        const [lineNumber, distance] = getMinSeqNumAndDistance('dummy_file.txt', 'apple', 'banana');\n        expect([lineNumber, distance]).toEqual([2, 1]);\n    });\n\n    it('test case where one or both words are not present', () => {\n        const mockContent = \"apple orange pear\\norange pear apple\";\n        const mockFs = {\n            readFileSync: jest.fn(() => mockContent),\n        };\n\n        global.fs = mockFs;\n\n        const [lineNumber, distance] = getMinSeqNumAndDistance('dummy_file.txt', 'apple', 'banana');\n        expect([lineNumber, distance]).toEqual([null, Infinity]);\n    });\n\n    it('test an empty file', () => {\n        const mockContent = '';\n        const mockFs = {\n            readFileSync: jest.fn(() => mockContent),\n        };\n\n        global.fs = mockFs;\n\n        const [lineNumber, distance] = getMinSeqNumAndDistance('dummy_file.txt', 'apple', 'banana');\n        expect([lineNumber, distance]).toEqual([null, Infinity]);\n    });\n\n    it('test multiple lines with varying distances between words', () => {\n        const mockContent = \"apple banana\\napple orange orange banana\\napple orange orange orange banana\";\n        const mockFs = {\n            readFileSync: jest.fn(() => mockContent),\n        };\n\n        global.fs = mockFs;\n\n        const [lineNumber, distance] = getMinSeqNumAndDistance('dummy_file.txt', 'apple', 'banana');\n        expect([lineNumber, distance]).toEqual([1, 1]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n * @param {string} filePath - The path to the file to read.\n * @param {string} word1 - The first word to search for.\n * @param {string} word2 - The second word to search for.\n * @returns {Array} An array containing the line number with the minimum distance and the minimum distance itself.\n *                  Returns [null, Infinity] if one or both words are not found in any line.\n */\nfunction getMinSeqNumAndDistance(filePath, word1, word2) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as fs from 'fs';\n\n/**\n * Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n * @param filePath The path to the file to read.\n * @param word1 The first word to search for.\n * @param word2 The second word to search for.\n * @returns A tuple containing the line number with the minimum distance and the minimum distance itself.\n *          Returns [null, Infinity] if one or both words are not found in any line.\n */\nfunction getMinSeqNumAndDistance(filePath: string, word1: string, word2: string): [number | null, number] {}", "test_code": "import * as fs from 'fs';\n\ndescribe('TestGetMinDistance', () => {\n  it('test basic functionality with expected input', () => {\n      const mockContent = \"hello world\\napple banana apple\\norange apple banana\";\n      const mockOpen = jest.fn().mockImplementation(() => ({\n          readFileSync: jest.fn().mockReturnValue(mockContent),\n      }));\n\n      // Mock the fs.readFileSync method\n      jest.spyOn(fs, 'readFileSync').mockImplementation(mockOpen);\n\n      const [lineNumber, distance] = getMinSeqNumAndDistance('dummy_file.txt', 'apple', 'banana');\n      expect([lineNumber, distance]).toEqual([2, 1]);\n\n      // Restore the original implementation after the test\n      jest.restoreAllMocks();\n  });\n\n  it('test case where one or both words are not present', () => {\n      const mockContent = \"apple orange pear\\norange pear apple\";\n      const mockOpen = jest.fn().mockImplementation(() => ({\n          readFileSync: jest.fn().mockReturnValue(mockContent),\n      }));\n\n      // Mock the fs.readFileSync method\n      jest.spyOn(fs, 'readFileSync').mockImplementation(mockOpen);\n\n      const [lineNumber, distance] = getMinSeqNumAndDistance('dummy_file.txt', 'apple', 'banana');\n      expect([lineNumber, distance]).toEqual([null, Infinity]);\n\n      // Restore the original implementation after the test\n      jest.restoreAllMocks();\n  });\n\n  it('test an empty file', () => {\n      const mockContent = '';\n      const mockOpen = jest.fn().mockImplementation(() => ({\n          readFileSync: jest.fn().mockReturnValue(mockContent),\n      }));\n\n      // Mock the fs.readFileSync method\n      jest.spyOn(fs, 'readFileSync').mockImplementation(mockOpen);\n\n      const [lineNumber, distance] = getMinSeqNumAndDistance('dummy_file.txt', 'apple', 'banana');\n      expect([lineNumber, distance]).toEqual([null, Infinity]);\n\n      // Restore the original implementation after the test\n      jest.restoreAllMocks();\n  });\n\n  it('test multiple lines with varying distances between words', () => {\n      const mockContent = \"apple banana\\napple orange orange banana\\napple orange orange orange banana\";\n      const mockOpen = jest.fn().mockImplementation(() => ({\n          readFileSync: jest.fn().mockReturnValue(mockContent),\n      }));\n\n      // Mock the fs.readFileSync method\n      jest.spyOn(fs, 'readFileSync').mockImplementation(mockOpen);\n\n      const [lineNumber, distance] = getMinSeqNumAndDistance('dummy_file.txt', 'apple', 'banana');\n      expect([lineNumber, distance]).toEqual([1, 1]);\n\n      // Restore the original implementation after the test\n      jest.restoreAllMocks();\n  });\n});", "prompt": "please write a typescript function , the function signature as below import * as fs from 'fs';\n\n/**\n * Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n * @param filePath The path to the file to read.\n * @param word1 The first word to search for.\n * @param word2 The second word to search for.\n * @returns A tuple containing the line number with the minimum distance and the minimum distance itself.\n *          Returns [null, Infinity] if one or both words are not found in any line.\n */\nfunction getMinSeqNumAndDistance(filePath: string, word1: string, word2: string): [number | null, number] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n *\n * @param file_path The path to the file to read.\n * @param word1 The first word to search for.\n * @param word2 The second word to search for.\n *\n * @return A tuple containing the line number with the minimum distance and the minimum distance itself.\n *         Returns (std::nullopt, std::numeric_limits<int>::max()) if one or both words are not found in any line.\n */\nstd::tuple<std::optional<int>, int> get_min_seq_num_and_distance(const std::string& file_path, const std::string& word1, const std::string& word2){\n\n}", "test_code": "TEST_CASE_METHOD(TestGetMinDistance, \"Test basic functionality with expected input\") {\n    content = \"hello world\\napple banana apple\\norange apple banana\";\n    setup_temp_file();\n\n    auto [line_number, distance] = get_min_seq_num_and_distance(temp_file_path, \"apple\", \"banana\");\n    REQUIRE((line_number, distance) == std::make_pair(2, 1));\n\n    teardown_temp_file();\n}\n\nTEST_CASE_METHOD(TestGetMinDistance, \"Test case where one or both words are not present\") {\n    content = \"apple orange pear\\norange pear apple\";\n    setup_temp_file();\n\n    auto [line_number, distance] = get_min_seq_num_and_distance(temp_file_path, \"apple\", \"banana\");\n    REQUIRE((line_number, distance) == std::make_pair(-1, std::numeric_limits<int>::max()));\n\n    teardown_temp_file();\n}\n\nTEST_CASE_METHOD(TestGetMinDistance, \"Test an empty file\") {\n    content = \"\";\n    setup_temp_file();\n\n    auto [line_number, distance] = get_min_seq_num_and_distance(temp_file_path, \"apple\", \"banana\");\n    REQUIRE((line_number, distance) == std::make_pair(-1, std::numeric_limits<int>::max()));\n\n    teardown_temp_file();\n}\n\nTEST_CASE_METHOD(TestGetMinDistance, \"Test multiple lines with varying distances between words\") {\n    content = \"apple banana\\napple orange orange banana\\napple orange orange orange banana\";\n    setup_temp_file();\n\n    auto [line_number, distance] = get_min_seq_num_and_distance(temp_file_path, \"apple\", \"banana\");\n    REQUIRE((line_number, distance) == std::make_pair(1, 1));\n\n    teardown_temp_file();\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n *\n * @param file_path The path to the file to read.\n * @param word1 The first word to search for.\n * @param word2 The second word to search for.\n *\n * @return A tuple containing the line number with the minimum distance and the minimum distance itself.\n *         Returns (std::nullopt, std::numeric_limits<int>::max()) if one or both words are not found in any line.\n */\nstd::tuple<std::optional<int>, int> get_min_seq_num_and_distance(const std::string& file_path, const std::string& word1, const std::string& word2){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n *\n * @param filePath The path to the file to read.\n * @param word1    The first word to search for.\n * @param word2    The second word to search for.\n * @return A tuple containing the line number with the minimum distance and the minimum distance itself.\n *         Returns (null, Integer.MAX_VALUE) if one or both words are not found in any line.\n */\npublic static Tuple getMinSeqNumAndDistance(String filePath, String word1, String word2) {}", "test_code": "import org.junit.Before;\nimport org.junit.Test;\nimport java.nio.file.Path;\nimport java.nio.file.Files;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.List;\nimport java.nio.file.Files;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    private Path tempFile;\n\n    @Before\n    public void setUp() throws IOException {\n        // Create a temporary file in the system's temporary directory\n        tempFile = Files.createTempFile(\"dummy_file\", \".txt\");\n        tempFile.toFile().deleteOnExit(); // Ensure it gets deleted after the test\n    }\n\n    @Test\n    public void testBasicFunctionality() throws IOException {\n        // Test basic functionality with expected input\n        String mockContent = \"hello world\\napple banana apple\\norange apple banana\";\n        Files.write(tempFile, List.of(mockContent.split(\"\\n\")));\n        \n        Tuple result = Answer.getMinSeqNumAndDistance(tempFile.toString(), \"apple\", \"banana\");\n        assertEquals(new Tuple(2, 1), result);\n    }\n\n    @Test\n    public void testWordsNotPresent() throws IOException {\n        // Test case where one or both words are not present\n        String mockContent = \"apple orange pear\\norange pear apple\";\n        Files.write(tempFile, List.of(mockContent.split(\"\\n\")));\n        \n        Tuple result = Answer.getMinSeqNumAndDistance(tempFile.toString(), \"apple\", \"banana\");\n        assertEquals(new Tuple(null, Integer.MAX_VALUE), result);\n    }\n\n    @Test\n    public void testEmptyFile() throws IOException {\n        // Test an empty file\n        Files.write(tempFile, List.of(\"\"));\n        \n        Tuple result = Answer.getMinSeqNumAndDistance(tempFile.toString(), \"apple\", \"banana\");\n        assertEquals(new Tuple(null, Integer.MAX_VALUE), result);\n    }\n\n    @Test\n    public void testMultipleLinesWithVaryingDistances() throws IOException {\n        // Test multiple lines with varying distances between words\n        String mockContent = \"apple banana\\napple orange orange banana\\napple orange orange orange banana\";\n        Files.write(tempFile, List.of(mockContent.split(\"\\n\")));\n        \n        Tuple result = Answer.getMinSeqNumAndDistance(tempFile.toString(), \"apple\", \"banana\");\n        assertEquals(new Tuple(1, 1), result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n *\n * @param filePath The path to the file to read.\n * @param word1    The first word to search for.\n * @param word2    The second word to search for.\n * @return A tuple containing the line number with the minimum distance and the minimum distance itself.\n *         Returns (null, Integer.MAX_VALUE) if one or both words are not found in any line.\n */\npublic static Tuple getMinSeqNumAndDistance(String filePath, String word1, String word2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 242, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Classify an array of file names according to its file extension, and return the final class result in the form of a dictionary\n", "language_version_list": {"python": {"code_signature": "from typing import List, Dict\n\n\ndef classify_files_by_extension(file_names: List[str]) -> Dict:\n    \"\"\"\n    Classify an array of file names according to their file extensions.\n\n    Args:\n        file_names: List of file names (strings).\n\n    Returns:\n        Dict: Dictionary with file extensions as keys and lists of file names as values.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestClassifyFilesByExtension(unittest.TestCase):\n\n    def test_multiple_file_types(self):\n        \"\"\"Test with multiple file types.\"\"\"\n        files = [\n            \"document.docx\",\n            \"photo.jpeg\",\n            \"report.pdf\",\n            \"image.png\",\n            \"archive.zip\"\n        ]\n        expected_result = {\n            'docx': ['document.docx'],\n            'jpeg': ['photo.jpeg'],\n            'pdf': ['report.pdf'],\n            'png': ['image.png'],\n            'zip': ['archive.zip']\n        }\n        self.assertEqual(classify_files_by_extension(files), expected_result)\n\n    def test_empty_list(self):\n        \"\"\"Test with an empty list of file names.\"\"\"\n        files = []\n        expected_result = {}\n        self.assertEqual(classify_files_by_extension(files), expected_result)\n\n    def test_files_with_same_extension(self):\n        \"\"\"Test with multiple files having the same extension.\"\"\"\n        files = [\n            \"file1.txt\",\n            \"file2.txt\",\n            \"file3.txt\",\n        ]\n        expected_result = {\n            'txt': [\n                \"file1.txt\",\n                \"file2.txt\",\n                \"file3.txt\",\n            ]\n        }\n        self.assertEqual(classify_files_by_extension(files), expected_result)\n\n    def test_files_with_multiple_dots(self):\n        \"\"\"Test files that have multiple dots in their names.\"\"\"\n        files = [\n            \"my.document.docx\",\n            \"report.final.pdf\",\n            \"photo.album.jpeg\",\n            \"archive.backup.zip\"\n        ]\n        expected_result = {\n            'docx': ['my.document.docx'],\n            'pdf': ['report.final.pdf'],\n            'jpeg': ['photo.album.jpeg'],\n            'zip': ['archive.backup.zip']\n        }\n        self.assertEqual(classify_files_by_extension(files), expected_result)", "prompt": "please write a python function , the function signature as below from typing import List, Dict\n\n\ndef classify_files_by_extension(file_names: List[str]) -> Dict:\n    \"\"\"\n    Classify an array of file names according to their file extensions.\n\n    Args:\n        file_names: List of file names (strings).\n\n    Returns:\n        Dict: Dictionary with file extensions as keys and lists of file names as values.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Classify an array of file names according to their file extensions.\n *\n * @param {string[]} fileNames - List of file names (strings).\n * @returns {Object} - Dictionary with file extensions as keys and lists of file names as values.\n */\nfunction classifyFilesByExtension(fileNames) {}", "test_code": "describe('TestClassifyFilesByExtension', () => {\n  it('test with multiple file types', () => {\n      const files = [\n          \"document.docx\",\n          \"photo.jpeg\",\n          \"report.pdf\",\n          \"image.png\",\n          \"archive.zip\"\n      ];\n      const expectedResult = {\n          'docx': ['document.docx'],\n          'jpeg': ['photo.jpeg'],\n          'pdf': ['report.pdf'],\n          'png': ['image.png'],\n          'zip': ['archive.zip']\n      };\n      expect(classifyFilesByExtension(files)).toEqual(expectedResult);\n  });\n\n  it('test with an empty list of file names', () => {\n      const files = [];\n      const expectedResult = {};\n      expect(classifyFilesByExtension(files)).toEqual(expectedResult);\n  });\n\n  it('test with multiple files having the same extension', () => {\n      const files = [\n          \"file1.txt\",\n          \"file2.txt\",\n          \"file3.txt\",\n      ];\n      const expectedResult = {\n          'txt': [\n              \"file1.txt\",\n              \"file2.txt\",\n              \"file3.txt\",\n          ]\n      };\n      expect(classifyFilesByExtension(files)).toEqual(expectedResult);\n  });\n\n  it('test files that have multiple dots in their names', () => {\n      const files = [\n          \"my.document.docx\",\n          \"report.final.pdf\",\n          \"photo.album.jpeg\",\n          \"archive.backup.zip\"\n      ];\n      const expectedResult = {\n          'docx': ['my.document.docx'],\n          'pdf': ['report.final.pdf'],\n          'jpeg': ['photo.album.jpeg'],\n          'zip': ['archive.backup.zip']\n      };\n      expect(classifyFilesByExtension(files)).toEqual(expectedResult);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Classify an array of file names according to their file extensions.\n *\n * @param {string[]} fileNames - List of file names (strings).\n * @returns {Object} - Dictionary with file extensions as keys and lists of file names as values.\n */\nfunction classifyFilesByExtension(fileNames) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Classify an array of file names according to their file extensions.\n *\n * @param fileNames - List of file names (strings).\n * @returns Dictionary with file extensions as keys and lists of file names as values.\n */\nfunction classifyFilesByExtension(fileNames: string[]): {[key: string]: string[]} {}", "test_code": "describe('classifyFilesByExtension', () => {\n  it('should correctly classify files with multiple file types', () => {\n      const files = [\n          \"document.docx\",\n          \"photo.jpeg\",\n          \"report.pdf\",\n          \"image.png\",\n          \"archive.zip\"\n      ];\n      const expectedResult = {\n          'docx': ['document.docx'],\n          'jpeg': ['photo.jpeg'],\n          'pdf': ['report.pdf'],\n          'png': ['image.png'],\n          'zip': ['archive.zip']\n      };\n      expect(classifyFilesByExtension(files)).toEqual(expectedResult);\n  });\n\n  it('should handle an empty list of file names', () => {\n      const files = [];\n      const expectedResult = {};\n      expect(classifyFilesByExtension(files)).toEqual(expectedResult);\n  });\n\n  it('should correctly classify files with the same extension', () => {\n      const files = [\n          \"file1.txt\",\n          \"file2.txt\",\n          \"file3.txt\",\n      ];\n      const expectedResult = {\n          'txt': [\n              \"file1.txt\",\n              \"file2.txt\",\n              \"file3.txt\",\n          ]\n      };\n      expect(classifyFilesByExtension(files)).toEqual(expectedResult);\n  });\n\n  it('should correctly classify files with multiple dots in their names', () => {\n      const files = [\n          \"my.document.docx\",\n          \"report.final.pdf\",\n          \"photo.album.jpeg\",\n          \"archive.backup.zip\"\n      ];\n      const expectedResult = {\n          'docx': ['my.document.docx'],\n          'pdf': ['report.final.pdf'],\n          'jpeg': ['photo.album.jpeg'],\n          'zip': ['archive.backup.zip']\n      };\n      expect(classifyFilesByExtension(files)).toEqual(expectedResult);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Classify an array of file names according to their file extensions.\n *\n * @param fileNames - List of file names (strings).\n * @returns Dictionary with file extensions as keys and lists of file names as values.\n */\nfunction classifyFilesByExtension(fileNames: string[]): {[key: string]: string[]} {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Classify an array of file names according to their file extensions.\n *\n * @param fileNames A vector of strings representing file names.\n * @return An unordered_map where keys are file extensions and values are vectors of file names.\n */\nstd::unordered_map<std::string, std::vector<std::string>> classify_files_by_extension(const std::vector<std::string>& fileNames){\n\n}", "test_code": "TEST_CASE(\"Test classifyFilesByExtension\") {\n    SECTION(\"Test with multiple file types\") {\n        std::vector<std::string> files = {\n            \"document.docx\",\n            \"photo.jpeg\",\n            \"report.pdf\",\n            \"image.png\",\n            \"archive.zip\"\n        };\n        std::unordered_map<std::string, std::vector<std::string>> expected_result = {\n            {\"docx\", {\"document.docx\"}},\n            {\"jpeg\", {\"photo.jpeg\"}},\n            {\"pdf\", {\"report.pdf\"}},\n            {\"png\", {\"image.png\"}},\n            {\"zip\", {\"archive.zip\"}}\n        };\n\n        REQUIRE(classify_files_by_extension(files) == expected_result);\n    }\n\n    SECTION(\"Test with an empty list of file names\") {\n        std::vector<std::string> files = {};\n        std::unordered_map<std::string, std::vector<std::string>> expected_result = {};\n\n        REQUIRE(classify_files_by_extension(files) == expected_result);\n    }\n\n    SECTION(\"Test with multiple files having the same extension\") {\n        std::vector<std::string> files = {\n            \"file1.txt\",\n            \"file2.txt\",\n            \"file3.txt\"\n        };\n        std::unordered_map<std::string, std::vector<std::string>> expected_result = {\n            {\"txt\", {\"file1.txt\", \"file2.txt\", \"file3.txt\"}}\n        };\n\n        REQUIRE(classify_files_by_extension(files) == expected_result);\n    }\n\n    SECTION(\"Test files that have multiple dots in their names\") {\n        std::vector<std::string> files = {\n            \"my.document.docx\",\n            \"report.final.pdf\",\n            \"photo.album.jpeg\",\n            \"archive.backup.zip\"\n        };\n        std::unordered_map<std::string, std::vector<std::string>> expected_result = {\n            {\"docx\", {\"my.document.docx\"}},\n            {\"pdf\", {\"report.final.pdf\"}},\n            {\"jpeg\", {\"photo.album.jpeg\"}},\n            {\"zip\", {\"archive.backup.zip\"}}\n        };\n\n        REQUIRE(classify_files_by_extension(files) == expected_result);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Classify an array of file names according to their file extensions.\n *\n * @param fileNames A vector of strings representing file names.\n * @return An unordered_map where keys are file extensions and values are vectors of file names.\n */\nstd::unordered_map<std::string, std::vector<std::string>> classify_files_by_extension(const std::vector<std::string>& fileNames){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Classify an array of file names according to their file extensions.\n *\n * @param fileNames List of file names (strings).\n * @return A map with file extensions as keys and lists of file names as values.\n */\npublic static Map<String, List<String>> classifyFilesByExtension(String[] fileNames) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testMultipleFileTypes() {\n        List<String> files = Arrays.asList(\n            \"document.docx\",\n            \"photo.jpeg\",\n            \"report.pdf\",\n            \"image.png\",\n            \"archive.zip\"\n        );\n        Map<String, List<String>> expectedResult = new HashMap<>();\n        expectedResult.put(\"docx\", Arrays.asList(\"document.docx\"));\n        expectedResult.put(\"jpeg\", Arrays.asList(\"photo.jpeg\"));\n        expectedResult.put(\"pdf\", Arrays.asList(\"report.pdf\"));\n        expectedResult.put(\"png\", Arrays.asList(\"image.png\"));\n        expectedResult.put(\"zip\", Arrays.asList(\"archive.zip\"));\n\n        Map<String, List<String>> result = classifyFilesByExtension(files.toArray(new String[0]));\n        assertEquals(expectedResult, result);\n    }\n\n    @Test\n    public void testEmptyList() {\n        List<String> files = Arrays.asList();\n        Map<String, List<String>> expectedResult = new HashMap<>();\n\n        Map<String, List<String>> result = classifyFilesByExtension(files.toArray(new String[0]));\n        assertEquals(expectedResult, result);\n    }\n\n    @Test\n    public void testFilesWithSameExtension() {\n        List<String> files = Arrays.asList(\n                \"file1.txt\",\n                \"file2.txt\",\n                \"file3.txt\"\n        );\n        Map<String, List<String>> expectedResult = new HashMap<>();\n        expectedResult.put(\"txt\", Arrays.asList(\"file1.txt\", \"file2.txt\", \"file3.txt\"));\n\n        Map<String, List<String>> result = classifyFilesByExtension(files.toArray(new String[0]));\n        assertEquals(expectedResult, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Classify an array of file names according to their file extensions.\n *\n * @param fileNames List of file names (strings).\n * @return A map with file extensions as keys and lists of file names as values.\n */\npublic static Map<String, List<String>> classifyFilesByExtension(String[] fileNames) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 244, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Write a function to check whether the parameters passed to a given method object (for example, a class of methods) comply with their\nExpected data type, based on method signature, if there is a difference, a ValueError will be raised", "language_version_list": {"python": {"code_signature": "from typing import Callable\n\n\nimport inspect\n\n\ndef method_arg_type_check(method_obj, *args, **kwargs):\n    \"\"\"\n    Checks that the arguments passed to a given method object (e.g., method of a class) comply with their\n    expected question types, based on the method's signature.js.py.py.py.py.js.js.js. If there's a discrepancy, it raises a ValueError.\n\n    Args:\n        method_obj (Callable): The method for which arguments are checked.\n        *args (): Positional arguments passed to the method.\n        **kwargs (): Keyword arguments passed to the method.\n\n\n    Optional argument:\n        exclude (list of str): Names of parameters to exclude from the type check.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\nfrom typing import Callable\n\n\nclass MyClass:\n    def my_method(self, arg1: int, arg2: str, optional_arg: float = 3.14):\n        pass\n\n\nclass TestMethodArgTypeCheck(unittest.TestCase):\n    def test_correct_types(self):\n        \"\"\" Test with correct argument types. \"\"\"\n        try:\n            method_arg_type_check(MyClass.my_method, MyClass(), 10, \"hello\", optional_arg=3.14)\n        except ValueError:\n            self.fail(\"method_arg_type_check() raised ValueError unexpectedly!\")\n\n    def test_missing_argument(self):\n        \"\"\" Test with missing required argument. \"\"\"\n        with self.assertRaises(TypeError):\n            method_arg_type_check(MyClass.my_method, MyClass(), 10)  # Missing arg2\n", "prompt": "please write a python function , the function signature as below from typing import Callable\n\n\nimport inspect\n\n\ndef method_arg_type_check(method_obj, *args, **kwargs):\n    \"\"\"\n    Checks that the arguments passed to a given method object (e.g., method of a class) comply with their\n    expected question types, based on the method's signature.js.py.py.py.py.js.js.js. If there's a discrepancy, it raises a ValueError.\n\n    Args:\n        method_obj (Callable): The method for which arguments are checked.\n        *args (): Positional arguments passed to the method.\n        **kwargs (): Keyword arguments passed to the method.\n\n\n    Optional argument:\n        exclude (list of str): Names of parameters to exclude from the type check.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 248, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "remove the corresponding sensitive data in the given dictionary based on the given key_to_remove list\n", "language_version_list": {"python": {"code_signature": "from typing import Dict, List\n\n\ndef sanitize_data(data: Dict, key_to_remove: List = None) -> Dict:\n    \"\"\"\n    remove the corresponding sensitive question in the given dictionary based on the given key_to_remove list\n\n    Args:\n        data (Dict): original question dict\n        key_to_remove (List): key_to_remove list\n\n    Returns:\n        Dict: removed dict\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSanitizeData(unittest.TestCase):\n    def test_empty_dict(self):\n        \"\"\" Test with an empty dictionary. \"\"\"\n        data = {}\n        key_to_remove = [\"email\", \"metadata\"]\n\n        expected = {}\n        self.assertEqual(sanitize_data(data, key_to_remove), expected)\n\n    def test_remove_default_keys(self):\n        \"\"\" Test removing default keys from a nested structure. \"\"\"\n        data = {\n            \"name\": \"John Doe\",\n            \"email\": \"johndoe@example.com\",\n            \"metadata\": {\"submitted_at\": \"2021-07-10\", \"status\": \"pending\"},\n            \"comments\": [\"Good\", \"Needs review\"]\n        }\n        key_to_remove = [\"email\", \"metadata\"]\n        expected = {\n            \"name\": \"John Doe\",\n            \"comments\": [\"Good\", \"Needs review\"]\n        }\n        self.assertEqual(sanitize_data(data, key_to_remove), expected)\n\n    def test_specified_key_to_remove(self):\n        \"\"\" Test removing a specified key from the dictionary. \"\"\"\n        data = {\n            \"name\": \"John Doe\",\n            \"location\": \"Earth\",\n            \"email\": \"johndoe@example.com\"\n        }\n        expected = {\n            \"name\": \"John Doe\",\n            \"location\": \"Earth\"\n        }\n        self.assertEqual(sanitize_data(data, key_to_remove=[\"email\"]), expected)", "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef sanitize_data(data: Dict, key_to_remove: List = None) -> Dict:\n    \"\"\"\n    remove the corresponding sensitive question in the given dictionary based on the given key_to_remove list\n\n    Args:\n        data (Dict): original question dict\n        key_to_remove (List): key_to_remove list\n\n    Returns:\n        Dict: removed dict\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Recursively sanitizes a dictionary by removing specific keys.\n *\n * @param {Object} data - The original dictionary to sanitize.\n * @param {Array<string>=} keyToRemove - An optional list of keys to remove.\n * @returns {Object} The sanitized dictionary.\n */\nfunction sanitizeData(data, keyToRemove = null) {}", "test_code": "describe('TestSanitizeData', () => {\n  it('test_empty_dict', () => {\n      // Test with an empty dictionary.\n      const data = {};\n      const keyToRemove = [\"email\", \"metadata\"];\n\n      const expected = {};\n      expect(sanitizeData(data, keyToRemove)).toEqual(expected);\n  });\n\n  it('test_remove_default_keys', () => {\n      // Test removing default keys from a nested structure.\n      const data = {\n          name: \"John Doe\",\n          email: \"johndoe@example.com\",\n          metadata: { submitted_at: \"2021-07-10\", status: \"pending\" },\n          comments: [\"Good\", \"Needs review\"]\n      };\n      const keyToRemove = [\"email\", \"metadata\"];\n      const expected = {\n          name: \"John Doe\",\n          comments: [\"Good\", \"Needs review\"]\n      };\n      expect(sanitizeData(data, keyToRemove)).toEqual(expected);\n  });\n\n  it('test_specified_key_to_remove', () => {\n      // Test removing a specified key from the dictionary.\n      const data = {\n          name: \"John Doe\",\n          location: \"Earth\",\n          email: \"johndoe@example.com\"\n      };\n      const expected = {\n          name: \"John Doe\",\n          location: \"Earth\"\n      };\n      expect(sanitizeData(data, keyToRemove: [\"email\"])).toEqual(expected);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Recursively sanitizes a dictionary by removing specific keys.\n *\n * @param {Object} data - The original dictionary to sanitize.\n * @param {Array<string>=} keyToRemove - An optional list of keys to remove.\n * @returns {Object} The sanitized dictionary.\n */\nfunction sanitizeData(data, keyToRemove = null) {}", "addition_info": ""}, "typescript": {"code_signature": "import { Dictionary } from \"lodash\";\n/**\n * Recursively sanitizes a dictionary by removing specific keys.\n * \n * @param data - The original dictionary to sanitize.\n * @param keyToRemove - An optional list of keys to remove. If not provided, defaults to a predefined set of keys.\n * @returns The sanitized dictionary.\n */\nfunction sanitizeData(data: Dictionary<any>, keyToRemove?: string[]): Dictionary<any> {}", "test_code": "import { Dictionary } from \"lodash\";\ndescribe('TestSanitizeData', () => {\n  describe('test_empty_dict', () => {\n    it('should return an empty dictionary when given an empty dictionary', () => {\n      const data = {};\n      const keyToRemove = [\"email\", \"metadata\"];\n      const expected = {};\n\n      expect(sanitizeData(data, keyToRemove)).toEqual(expected);\n    });\n  });\n\n  describe('test_remove_default_keys', () => {\n    it('should remove default keys from a nested structure', () => {\n      const data = {\n        name: \"John Doe\",\n        email: \"johndoe@example.com\",\n        metadata: { submitted_at: \"2021-07-10\", status: \"pending\" },\n        comments: [\"Good\", \"Needs review\"]\n      };\n      const keyToRemove = [\"email\", \"metadata\"];\n      const expected = {\n        name: \"John Doe\",\n        comments: [\"Good\", \"Needs review\"]\n      };\n\n      expect(sanitizeData(data, keyToRemove)).toEqual(expected);\n    });\n  });\n\n  describe('test_specified_key_to_remove', () => {\n    it('should remove a specified key from the dictionary', () => {\n      const data = {\n        name: \"John Doe\",\n        location: \"Earth\",\n        email: \"johndoe@example.com\"\n      };\n      const expected = {\n        name: \"John Doe\",\n        location: \"Earth\"\n      };\n\n      expect(sanitizeData(data, [\"email\"])).toEqual(expected);\n    });\n  });\n});", "prompt": "please write a typescript function , the function signature as below import { Dictionary } from \"lodash\";\n/**\n * Recursively sanitizes a dictionary by removing specific keys.\n * \n * @param data - The original dictionary to sanitize.\n * @param keyToRemove - An optional list of keys to remove. If not provided, defaults to a predefined set of keys.\n * @returns The sanitized dictionary.\n */\nfunction sanitizeData(data: Dictionary<any>, keyToRemove?: string[]): Dictionary<any> {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Remove the corresponding sensitive questions in the given dictionary based on the given key_to_remove list.\n *\n * @param data The original question dictionary.\n * @param key_to_remove The list of keys to remove.\n * @return std::unordered_map<std::string, std::string> The removed dictionary.\n */\nstd::unordered_map<std::string, std::string> sanitize_data(const std::unordered_map<std::string, std::string>& data, const std::vector<std::string>& keyToRemove) {\n\n}", "test_code": "TEST_CASE(\"TestSanitizeData\", \"[SanitizeData]\") {\n    SECTION(\"test_empty_dict\") {\n        // Test with an empty dictionary.\n        std::unordered_map<std::string, std::string> data = {};\n        std::vector<std::string> key_to_remove = {\"email\", \"metadata\"};\n\n        std::unordered_map<std::string, std::string> expected = {};\n        REQUIRE(sanitize_data(data, &key_to_remove) == expected);\n    }\n\n    SECTION(\"test_remove_default_keys\") {\n        // Test removing default keys from a nested structure.\n        std::unordered_map<std::string, std::string> data = {\n            {\"name\", \"John Doe\"},\n            {\"email\", \"johndoe@example.com\"},\n            {\"metadata\", \"version: 1, timestamp: 2021-07-10, status: pending\"},\n            {\"comments\", \"Good, Needs review\"}\n        };\n        std::vector<std::string> key_to_remove = {\"email\", \"metadata\"};\n        std::unordered_map<std::string, std::string> expected = {\n            {\"name\", \"John Doe\"},\n            {\"comments\", \"Good, Needs review\"}\n        };\n        REQUIRE(sanitize_data(data, &key_to_remove) == expected);\n    }\n\n    SECTION(\"test_specified_key_to_remove\") {\n        // Test removing a specified key from the dictionary.\n        std::unordered_map<std::string, std::string> data = {\n            {\"name\", \"John Doe\"},\n            {\"location\", \"Earth\"},\n            {\"email\", \"johndoe@example.com\"}\n        };\n        std::unordered_map<std::string, std::string> expected = {\n            {\"name\", \"John Doe\"},\n            {\"location\", \"Earth\"}\n        };\n        REQUIRE(sanitize_data(data, &std::vector<std::string>{\"email\"}) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Remove the corresponding sensitive questions in the given dictionary based on the given key_to_remove list.\n *\n * @param data The original question dictionary.\n * @param key_to_remove The list of keys to remove.\n * @return std::unordered_map<std::string, std::string> The removed dictionary.\n */\nstd::unordered_map<std::string, std::string> sanitize_data(const std::unordered_map<std::string, std::string>& data, const std::vector<std::string>& keyToRemove) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Removes the corresponding sensitive questions in the given dictionary based on the given list of keys to remove.\n *\n * @param data          the original question dictionary\n * @param keyToBeRemoved the list of keys to remove; if null, uses default keys\n * @return the sanitized dictionary\n */\npublic static Map<String, Object> sanitizeData(Map<String, Object> data, List<String> keyToBeRemoved) {}", "test_code": "package org.real.temp;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.*;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n\n\n    @Test\n    public void testEmptyDict() {\n        Map<String, Object> data = new HashMap<>();\n        Set<String> keyToBeRemoved = new HashSet<>(Arrays.asList(\"email\", \"metadata\"));\n\n        Map<String, Object> expected = new HashMap<>();\n        assertEquals(expected, sanitizeData(data, keyToBeRemoved));\n    }\n\n    @Test\n    public void testRemoveDefaultKeys() {\n        Map<String, Object> data = new HashMap<>();\n        data.put(\"name\", \"John Doe\");\n        data.put(\"email\", \"johndoe@example.com\");\n        data.put(\"metadata\", new HashMap<>(Map.of(\n                \"submitted_at\", \"2021-07-10\",\n                \"status\", \"pending\"\n        )));\n        data.put(\"comments\", Arrays.asList(\"Good\", \"Needs review\"));\n\n        Set<String> keyToBeRemoved = new HashSet<>(Arrays.asList(\"email\", \"metadata\"));\n        Map<String, Object> expected = new HashMap<>();\n        expected.put(\"name\", \"John Doe\");\n        expected.put(\"comments\", Arrays.asList(\"Good\", \"Needs review\"));\n\n        assertEquals(expected, sanitizeData(data, keyToBeRemoved));\n    }\n\n    @Test\n    public void testSpecifiedKeyToRemove() {\n        Map<String, Object> data = new HashMap<>();\n        data.put(\"name\", \"John Doe\");\n        data.put(\"location\", \"Earth\");\n        data.put(\"email\", \"johndoe@example.com\");\n\n        Set<String> keyToBeRemoved = new HashSet<>(Arrays.asList(\"email\"));\n        Map<String, Object> expected = new HashMap<>();\n        expected.put(\"name\", \"John Doe\");\n        expected.put(\"location\", \"Earth\");\n\n        assertEquals(expected, sanitizeData(data, keyToBeRemoved));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Removes the corresponding sensitive questions in the given dictionary based on the given list of keys to remove.\n *\n * @param data          the original question dictionary\n * @param keyToBeRemoved the list of keys to remove; if null, uses default keys\n * @return the sanitized dictionary\n */\npublic static Map<String, Object> sanitizeData(Map<String, Object> data, List<String> keyToBeRemoved) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 249, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Extract text from a given pdf file", "language_version_list": {"python": {"code_signature": "def extract_text_from_pdf(file_path: str) -> str:\n    \"\"\"\n    Extracts text from a given PDF file.\n\n    Args:\n    file_path (str): The path to the PDF file from which to extract text.\n\n    Returns:\n    str: The extracted text from the PDF.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestExtractTextFromPDF(unittest.TestCase):\n    def test_empty_file(self):\n        pdf_path = r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t249\\testcase01.pdf\"\n        expected = \" \\n\"\n        output = extract_text_from_pdf(pdf_path)\n        self.assertEqual(output, expected)\n\n    def test_normal_file(self):\n        pdf_path = r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t249\\testcase02.pdf\"\n        expected = \"11111  \\n\"\n        output = extract_text_from_pdf(pdf_path)\n        self.assertEqual(output, expected)\n\n    def test_more_text_file(self):\n        pdf_path = r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t249\\testcase03.pdf\"\n        expected = \"11111  \\n22222  \\n33333  \\n44444  \\n\"\n        output = extract_text_from_pdf(pdf_path)\n        self.assertEqual(output, expected)\n", "prompt": "please write a python function , the function signature as below def extract_text_from_pdf(file_path: str) -> str:\n    \"\"\"\n    Extracts text from a given PDF file.\n\n    Args:\n    file_path (str): The path to the PDF file from which to extract text.\n\n    Returns:\n    str: The extracted text from the PDF.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extracts text from a given PDF file.\n *\n * @param {string} fileUrl - The URL/path to the PDF file from which to extract text.\n * @returns {Promise<string>} A promise that resolves to the extracted text from the PDF.\n */\nasync function extractTextFromPdf(fileUrl) {}", "test_code": "describe('TestExtractTextFromPDF', () => {\n  it('should handle an empty file correctly', async () => {\n      const pdfPath = 'E:/code/code_back/python_project/RealisticEval-Data/envs/python/test_case/t249/testcase01.pdf';\n      const expected = ' \\n';\n      const output = await extractTextFromPdf(pdfPath);\n      expect(output).toEqual(expected);\n  });\n\n  it('should handle a normal file correctly', async () => {\n      const pdfPath = 'E:/code/code_back/python_project/RealisticEval-Data/envs/python/test_case/t249/testcase02.pdf';\n      const expected = '11111  \\n';\n      const output = await extractTextFromPdf(pdfPath);\n      expect(output).toEqual(expected);\n  });\n\n  it('should handle a file with more text correctly', async () => {\n      const pdfPath = 'E:/code/code_back/python_project/RealisticEval-Data/envs/python/test_case/t249/testcase03.pdf';\n      const expected = '11111  \\n22222  \\n33333  \\n44444  \\n';\n      const output = await extractTextFromPdf(pdfPath);\n      expect(output).toEqual(expected);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Extracts text from a given PDF file.\n *\n * @param {string} fileUrl - The URL/path to the PDF file from which to extract text.\n * @returns {Promise<string>} A promise that resolves to the extracted text from the PDF.\n */\nasync function extractTextFromPdf(fileUrl) {}", "addition_info": ""}, "typescript": {"code_signature": "import { PDFDocument } from 'pdf-lib';\nimport fs from 'fs';\n\n/**\n * Extracts text from a given PDF file.\n *\n * @param filePath - The path to the PDF file from which to extract text.\n * @returns A promise that resolves to the extracted text from the PDF.\n */\nasync function extractTextFromPdf(filePath: string): Promise<string> {}", "test_code": "describe('TestExtractTextFromPDF', () => {\n  it('should handle an empty file correctly', async () => {\n    const pdfPath = 'E:/code/code_back/python_project/RealisticEval-Data/envs/python/test_case/t249/testcase01.pdf';\n    const expected = ' \\n';\n    const output = await extractTextFromPdf(pdfPath);\n    expect(output).toEqual(expected);\n  });\n\n  it('should handle a normal file correctly', async () => {\n    const pdfPath = 'E:/code/code_back/python_project/RealisticEval-Data/envs/python/test_case/t249/testcase02.pdf';\n    const expected = '11111  \\n';\n    const output = await extractTextFromPdf(pdfPath);\n    expect(output).toEqual(expected);\n  });\n\n  it('should handle a file with more text correctly', async () => {\n    const pdfPath = 'E:/code/code_back/python_project/RealisticEval-Data/envs/python/test_case/t249/testcase03.pdf';\n    const expected = '11111  \\n22222  \\n33333  \\n44444  \\n';\n    const output = await extractTextFromPdf(pdfPath);\n    expect(output).toEqual(expected);\n  });\n});", "prompt": "please write a typescript function , the function signature as below import { PDFDocument } from 'pdf-lib';\nimport fs from 'fs';\n\n/**\n * Extracts text from a given PDF file.\n *\n * @param filePath - The path to the PDF file from which to extract text.\n * @returns A promise that resolves to the extracted text from the PDF.\n */\nasync function extractTextFromPdf(filePath: string): Promise<string> {}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 250, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Invert the keys and values in the dictionary, change the values of the original dictionary to the keys of the new dictionary, and the keys of the original dictionary become the values of the new dictionary. If the values in the original dictionary are duplicate (that is, multiple keys share the same value), the keys of the new dictionary will be mapped to a list containing all corresponding original keys\n", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef invert_dictionary(original_dict: Dict) -> Dict:\n    \"\"\"\n    Invert the keys and values in a dictionary. If multiple keys have the same value,\n    the new dictionary's values will be a list of these keys.\n    Args:\n        original_dict (dict): The dictionary to invert.\n\n    Returns:\n        A new dictionary with values and keys inverted.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestInvertDictionary(unittest.TestCase):\n\n    def test_normal_dictionary(self):\n        \"\"\"Test inversion of a dictionary without duplicate values.\"\"\"\n        original_dict = {'a': 1, 'b': 2, 'c': 3}\n        expected = {1: 'a', 2: 'b', 3: 'c'}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_dictionary_with_duplicates(self):\n        \"\"\"Test inversion of a dictionary with duplicate values.\"\"\"\n        original_dict = {'a': 1, 'b': 1, 'c': 2}\n        expected = {1: ['a', 'b'], 2: 'c'}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_empty_dictionary(self):\n        \"\"\"Test inversion of an empty dictionary.\"\"\"\n        original_dict = {}\n        expected = {}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_non_string_keys(self):\n        \"\"\"Test inversion of a dictionary with non-string keys.\"\"\"\n        original_dict = {1: 'apple', 2: 'banana', 3: 'apple'}\n        expected = {'apple': [1, 3], 'banana': 2}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_mixed_types(self):\n        \"\"\"Test inversion of a dictionary with mixed key and value types.\"\"\"\n        original_dict = {'a': 1, 2: 'two', 'three': 3}\n        expected = {1: 'a', 'two': 2, 3: 'three'}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef invert_dictionary(original_dict: Dict) -> Dict:\n    \"\"\"\n    Invert the keys and values in a dictionary. If multiple keys have the same value,\n    the new dictionary's values will be a list of these keys.\n    Args:\n        original_dict (dict): The dictionary to invert.\n\n    Returns:\n        A new dictionary with values and keys inverted.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Invert the keys and values in an object. If multiple keys have the same value,\n * the new object's values will be an array of these keys.\n * \n * @param {Object} originalDict - The object to invert.\n * @returns {Object} A new object with values and keys inverted.\n */\nfunction invertDictionary(originalDict) {}", "test_code": "describe('TestInvertDictionary', () => {\n  describe('test_normal_dictionary', () => {\n      it('should correctly invert a dictionary without duplicate values', () => {\n          const originalDict = {'a': 1, 'b': 2, 'c': 3};\n          const expected = {1: 'a', 2: 'b', 3: 'c'};\n          const result = invertDictionary(originalDict);\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_dictionary_with_duplicates', () => {\n      it('should correctly invert a dictionary with duplicate values', () => {\n          const originalDict = {'a': 1, 'b': 1, 'c': 2};\n          const expected = {1: ['a', 'b'], 2: 'c'};\n          const result = invertDictionary(originalDict);\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_empty_dictionary', () => {\n      it('should correctly invert an empty dictionary', () => {\n          const originalDict = {};\n          const expected = {};\n          const result = invertDictionary(originalDict);\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_non_string_keys', () => {\n      it('should correctly invert a dictionary with non-string keys', () => {\n          const originalDict = {1: 'apple', 2: 'banana', 3: 'apple'};\n          const expected = {'apple': [1, 3], 'banana': 2};\n          const result = invertDictionary(originalDict);\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_mixed_types', () => {\n      it('should correctly invert a dictionary with mixed key and value types', () => {\n          const originalDict = {'a': 1, 2: 'two', 'three': 3};\n          const expected = {1: 'a', 'two': 2, 3: 'three'};\n          const result = invertDictionary(originalDict);\n          expect(result).toEqual(expected);\n      });\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Invert the keys and values in an object. If multiple keys have the same value,\n * the new object's values will be an array of these keys.\n * \n * @param {Object} originalDict - The object to invert.\n * @returns {Object} A new object with values and keys inverted.\n */\nfunction invertDictionary(originalDict) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Inverts the keys and values in a dictionary. If multiple keys have the same value,\n * the new dictionary's values will be a list of these keys.\n * \n * @param originalDict - The dictionary to invert.\n * @returns A new dictionary with values and keys inverted.\n */\nfunction invertDictionary(originalDict: Record<string, string | string[]>): Record<string, string | string[]> {}", "test_code": "describe('TestInvertDictionary', () => {\n    it('test_normal_dictionary', () => {\n        /** Test inversion of a dictionary without duplicate values. */\n        const originalDict = { 'a': 1, 'b': 2, 'c': 3 };\n        const expected = { 1: 'a', 2: 'b', 3: 'c' };\n        const result = invertDictionary(originalDict);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_dictionary_with_duplicates', () => {\n        /** Test inversion of a dictionary with duplicate values. */\n        const originalDict = { 'a': 1, 'b': 1, 'c': 2 };\n        const expected = { 1: ['a', 'b'], 2: 'c' };\n        const result = invertDictionary(originalDict);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_empty_dictionary', () => {\n        /** Test inversion of an empty dictionary. */\n        const originalDict = {};\n        const expected = {};\n        const result = invertDictionary(originalDict);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_non_string_keys', () => {\n        /** Test inversion of a dictionary with non-string keys. */\n        const originalDict = { 1: 'apple', 2: 'banana', 3: 'apple' };\n        const expected = { 'apple': [1, 3], 'banana': 2 };\n        const result = invertDictionary(originalDict);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_mixed_types', () => {\n        /** Test inversion of a dictionary with mixed key and value types. */\n        const originalDict = { 'a': 1, 2: 'two', 'three': 3 };\n        const expected = { 1: 'a', 'two': 2, 3: 'three' };\n        const result = invertDictionary(originalDict);\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Inverts the keys and values in a dictionary. If multiple keys have the same value,\n * the new dictionary's values will be a list of these keys.\n * \n * @param originalDict - The dictionary to invert.\n * @returns A new dictionary with values and keys inverted.\n */\nfunction invertDictionary(originalDict: Record<string, string | string[]>): Record<string, string | string[]> {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Invert the keys and values in a dictionary. If multiple keys have the same value,\n * the new dictionary's values will be a list of these keys.\n *\n * @param original_dict The dictionary to invert.\n * @return A new dictionary with values and keys inverted.\n */\nstd::unordered_map<std::string, std::vector<std::string>> invert_dictionary(const std::unordered_map<std::string, std::string>& originalDict){\n\n}", "test_code": "TEST_CASE(\"Test inversion of a dictionary without duplicate values\") {\n    std::unordered_map<std::string, std::string> originalDict = {{\"a\", \"1\"}, {\"b\", \"2\"}, {\"c\", \"3\"}};\n    std::unordered_map<std::string, std::string> expected = {{\"1\", \"a\"}, {\"2\", \"b\"}, {\"3\", \"c\"}};\n    auto result = invert_dictionary(originalDict);\n\n    REQUIRE(result == expected);\n}\n\nTEST_CASE(\"Test inversion of a dictionary with duplicate values\") {\n    std::unordered_map<std::string, std::string> originalDict = {{\"a\", \"1\"}, {\"b\", \"1\"}, {\"c\", \"2\"}};\n    std::unordered_map<std::string, std::vector<std::string>> expected = {{\"1\", {\"a\", \"b\"}}, {\"2\", {\"c\"}}};\n    auto result = invert_dictionary(originalDict);\n\n    REQUIRE(result == expected);\n}\n\nTEST_CASE(\"Test inversion of an empty dictionary\") {\n    std::unordered_map<std::string, std::string> originalDict = {};\n    std::unordered_map<std::string, std::vector<std::string>> expected = {};\n    auto result = invert_dictionary(originalDict);\n\n    REQUIRE(result == expected);\n}\n\nTEST_CASE(\"Test inversion of a dictionary with non-string keys\") {\n    // Note: In C++, all keys and values are strings for simplicity.\n    std::unordered_map<std::string, std::string> originalDict = {{\"1\", \"apple\"}, {\"2\", \"banana\"}, {\"3\", \"apple\"}};\n    std::unordered_map<std::string, std::vector<std::string>> expected = {{\"apple\", {\"1\", \"3\"}}, {\"banana\", {\"2\"}}};\n    auto result = invert_dictionary(originalDict);\n\n    REQUIRE(result == expected);\n}\n\nTEST_CASE(\"Test inversion of a dictionary with mixed key and value types\") {\n    // Note: In C++, all keys and values are strings for simplicity.\n    std::unordered_map<std::string, std::string> originalDict = {{\"a\", \"1\"}, {\"2\", \"two\"}, {\"three\", \"3\"}};\n    std::unordered_map<std::string, std::vector<std::string>> expected = {{\"1\", {\"a\"}}, {\"two\", {\"2\"}}, {\"3\", {\"three\"}}};\n    auto result = invert_dictionary(originalDict);\n\n    REQUIRE(result == expected);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Invert the keys and values in a dictionary. If multiple keys have the same value,\n * the new dictionary's values will be a list of these keys.\n *\n * @param original_dict The dictionary to invert.\n * @return A new dictionary with values and keys inverted.\n */\nstd::unordered_map<std::string, std::vector<std::string>> invert_dictionary(const std::unordered_map<std::string, std::string>& originalDict){\n\n}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 252, "code_type": "class", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Write a JSON decoding class that inherits from json.JSONEncoder. When encoding data into json format, the main functional bits of this class specifically handle keys identified as bits, and convert them to binary form if their value is an integer\n", "language_version_list": {"python": {"code_signature": "import json\n\n\nclass BitSequenceEncoder(json.JSONEncoder):\n    \"\"\"\n    Write a JSON decoding class that inherits from json.JSONEncoder. When encoding question into json format, the main functional bits of this class specifically handle keys identified as bits, and convert them to binary form if their value is an integer\n    For example 'bits': 255 after encoder \"bits\": \"11111111\"\n\n    \"\"\"\n\n    def encode(self, obj):\n        pass\n", "test_code": "import unittest\nimport json\n\nclass TestBitSequenceEncoder(unittest.TestCase):\n    def test_basic_encoding(self):\n        \"\"\" Test encoding with simple dictionary containing 'bits'. \"\"\"\n        data = {'name': 'Processor', 'bits': 255}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"name\": \"Processor\", \"bits\": \"11111111\"}')\n\n    def test_nested_encoding(self):\n        \"\"\" Test encoding with nested dictionary containing 'bits'. \"\"\"\n        data = {'component': {'name': 'ALU', 'bits': 128}, 'bits': 1}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"component\": {\"name\": \"ALU\", \"bits\": \"10000000\"}, \"bits\": \"00000001\"}')\n\n    def test_non_bits_key(self):\n        \"\"\" Test encoding with dictionary not containing 'bits' key. \"\"\"\n        data = {'name': 'Processor', 'value': 123}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"name\": \"Processor\", \"value\": 123}')\n\n    def test_no_bits_conversion_needed(self):\n        \"\"\" Test encoding with dictionary where 'bits' key needs no conversion. \"\"\"\n        data = {'name': 'Unit', 'bits': 'Already binary'}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"name\": \"Unit\", \"bits\": \"Already binary\"}')\n\n    def test_complex_structure_with_bits(self):\n        \"\"\" Test encoding a complex dictionary structure containing multiple 'bits' keys. \"\"\"\n        data = {\n            'processor': {'bits': 3, 'type': 'A'},\n            'memory': {'bits': 255, 'size': 16},\n            'ports': {'count': 2, 'bits': 128}\n        }\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"processor\": {\"bits\": \"00000011\", \"type\": \"A\"}, \"memory\": {\"bits\": \"11111111\", \"size\": 16}, \"ports\": {\"count\": 2, \"bits\": \"10000000\"}}')\n", "prompt": "please write a python class , the class signature as below import json\n\n\nclass BitSequenceEncoder(json.JSONEncoder):\n    \"\"\"\n    Write a JSON decoding class that inherits from json.JSONEncoder. When encoding question into json format, the main functional bits of this class specifically handle keys identified as bits, and convert them to binary form if their value is an integer\n    For example 'bits': 255 after encoder \"bits\": \"11111111\"\n\n    \"\"\"\n\n    def encode(self, obj):\n        pass\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 253, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Write a function to process different types of log entries. This function can process strings, numbers, dictionaries and lists, and can serialize dictionaries and lists into JSON format for output. If the input data type is not supported, an error will be thrown.\n", "language_version_list": {"python": {"code_signature": "def log(item: any) -> any:\n    \"\"\"\n    Logs an item by printing it. Handles strings, numbers, lists, and dictionaries by printing\n    them directly or as a JSON-formatted string. Other types are reported as errors.\n    Args:\n        item (any): The item to be logged. Can be of any type.\n\n    Returns:\n        item: The item to be logged. Can be of any type.\n    \"\"\"\n", "test_code": "import unittest\nfrom unittest.mock import patch\n\n\nclass TestLogFunction(unittest.TestCase):\n    @patch('builtins.print')\n    def test_log_string(self, mock_print):\n        \"\"\" Test logging a simple string \"\"\"\n        log(\"Hello, world!\")\n        mock_print.assert_called_once_with(\"Hello, world!\")\n\n    @patch('builtins.print')\n    def test_log_number(self, mock_print):\n        \"\"\" Test logging a number \"\"\"\n        log(123.456)\n        mock_print.assert_called_once_with(123.456)\n\n    @patch('builtins.print')\n    def test_log_dictionary(self, mock_print):\n        \"\"\" Test logging a dictionary as JSON \"\"\"\n        log({\"key\": \"value\", \"number\": 42})\n        expected_json_output = '{\\n    \"key\": \"value\",\\n    \"number\": 42\\n}'\n        mock_print.assert_called_once_with(expected_json_output)\n\n    @patch('builtins.print')\n    def test_log_list(self, mock_print):\n        \"\"\" Test logging a list as JSON \"\"\"\n        log([1, 2, 3, 4, 5])\n        expected_json_output = '[\\n    1,\\n    2,\\n    3,\\n    4,\\n    5\\n]'\n        mock_print.assert_called_once_with(expected_json_output)", "prompt": "please write a python function , the function signature as below def log(item: any) -> any:\n    \"\"\"\n    Logs an item by printing it. Handles strings, numbers, lists, and dictionaries by printing\n    them directly or as a JSON-formatted string. Other types are reported as errors.\n    Args:\n        item (any): The item to be logged. Can be of any type.\n\n    Returns:\n        item: The item to be logged. Can be of any type.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Logs an item by printing it. Handles strings, numbers, arrays, and objects by printing\n * them directly or as a JSON-formatted string. Other types are reported as errors.\n * \n * @param {any} item - The item to be logged. Can be of any type.\n * @returns {any} - The item to be logged. Can be of any type.\n */\nfunction log(item) {}", "test_code": "describe('TestLogFunction', () => {\n  beforeEach(() => {\n      jest.spyOn(console, 'log').mockImplementation(jest.fn());\n  });\n\n  afterEach(() => {\n      console.log.mockRestore();\n  });\n\n  test('test_log_string', () => {\n      /** Test logging a simple string */\n      log(\"Hello, world!\");\n      expect(console.log).toHaveBeenCalledWith(\"Hello, world!\");\n  });\n\n  test('test_log_number', () => {\n      /** Test logging a number */\n      log(123.456);\n      expect(console.log).toHaveBeenCalledWith(123.456);\n  });\n\n  test('test_log_dictionary', () => {\n      /** Test logging a dictionary as JSON */\n      log({ key: \"value\", number: 42 });\n      const expectedJsonOutput = JSON.stringify({ key: \"value\", number: 42 }, null, 4);\n      expect(console.log).toHaveBeenCalledWith(expectedJsonOutput);\n  });\n\n  test('test_log_list', () => {\n      /** Test logging a list as JSON */\n      log([1, 2, 3, 4, 5]);\n      const expectedJsonOutput = JSON.stringify([1, 2, 3, 4, 5], null, 4);\n      expect(console.log).toHaveBeenCalledWith(expectedJsonOutput);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Logs an item by printing it. Handles strings, numbers, arrays, and objects by printing\n * them directly or as a JSON-formatted string. Other types are reported as errors.\n * \n * @param {any} item - The item to be logged. Can be of any type.\n * @returns {any} - The item to be logged. Can be of any type.\n */\nfunction log(item) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Logs an item by printing it. Handles strings, numbers, arrays, and objects by printing\n * them directly or as a JSON-formatted string. Other types are reported as errors.\n * \n * @param item - The item to be logged. Can be of any type.\n * @returns The item to be logged. Can be of any type.\n */\nfunction log(item: any): void {}", "test_code": "describe('TestLogFunction', () => {\n    it('test_log_string', () => {\n        const mockPrint = jest.spyOn(console, 'log').mockImplementation(() => {});\n\n        log(\"Hello, world!\");\n\n        expect(mockPrint).toHaveBeenCalledWith(\"Hello, world!\");\n        mockPrint.mockRestore();\n    });\n\n    it('test_log_number', () => {\n        const mockPrint = jest.spyOn(console, 'log').mockImplementation(() => {});\n\n        log(123.456);\n\n        expect(mockPrint).toHaveBeenCalledWith(123.456);\n        mockPrint.mockRestore();\n    });\n\n    it('test_log_dictionary', () => {\n        const mockPrint = jest.spyOn(console, 'log').mockImplementation(() => {});\n\n        log({ key: \"value\", number: 42 });\n\n        const expectedJsonOutput = JSON.stringify({ key: \"value\", number: 42 }, null, 4);\n        expect(mockPrint).toHaveBeenCalledWith(expectedJsonOutput);\n        mockPrint.mockRestore();\n    });\n\n    it('test_log_list', () => {\n        const mockPrint = jest.spyOn(console, 'log').mockImplementation(() => {});\n\n        log([1, 2, 3, 4, 5]);\n\n        const expectedJsonOutput = JSON.stringify([1, 2, 3, 4, 5], null, 4);\n        expect(mockPrint).toHaveBeenCalledWith(expectedJsonOutput);\n        mockPrint.mockRestore();\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Logs an item by printing it. Handles strings, numbers, arrays, and objects by printing\n * them directly or as a JSON-formatted string. Other types are reported as errors.\n * \n * @param item - The item to be logged. Can be of any type.\n * @returns The item to be logged. Can be of any type.\n */\nfunction log(item: any): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 255, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Convert a picture to an array of binary bits. Convert it to black and white mode (only 0s and 1s, corresponding to black and white), convert the white pixel (value 255) to 1, convert the black pixel to 0, and finally store these bits in an array and return\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef convert_image_to_bits(image_path: str) -> List:\n    \"\"\"\n    Convert a picture to an array of binary bits. Convert it to black and white mode (only 0s and 1s, corresponding to black and white), convert the white pixel (value 255) to 1, convert the black pixel to 0, and finally store these bits in an array and return\n\n\n    Args:\n        image_path (str): The path to the image file.\n\n    Returns:\n        list: A list of bits (0 or 1) representing the image.\n    \"\"\"\n", "test_code": "import unittest\nfrom io import BytesIO\nfrom PIL import Image\n\n\n\nclass TestConvertImageToBits(unittest.TestCase):\n\n    def create_image(self, mode, size, color):\n        \"\"\"\n        Helper method to create an in-memory image.\n\n        Args:\n            mode (str): The color mode of the image (e.g., '1' for binary, 'L' for grayscale).\n            size (tuple): A tuple of the image size (width, height).\n            color (int or tuple): The color to fill the image. 255 for white, 0 for black in '1' mode.\n\n        Returns:\n            Image: A PIL Image object.\n        \"\"\"\n        image = Image.new(mode, size, color)\n        return image\n\n    def test_all_white_image(self):\n        image = self.create_image('1', (4, 4), 255)\n        expected_bits = [1] * 16\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_all_black_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        expected_bits = [0] * 16\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_checkerboard_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        pixels = image.load()\n        for y in range(4):\n            for x in range(4):\n                if (x + y) % 2 == 0:\n                    pixels[x, y] = 255\n        expected_bits = [1, 0, 1, 0,\n                         0, 1, 0, 1,\n                         1, 0, 1, 0,\n                         0, 1, 0, 1]\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_horizontal_stripes_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        pixels = image.load()\n        for y in range(4):\n            for x in range(4):\n                if y % 2 == 0:\n                    pixels[x, y] = 255\n        expected_bits = [1, 1, 1, 1,\n                         0, 0, 0, 0,\n                         1, 1, 1, 1,\n                         0, 0, 0, 0]\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_vertical_stripes_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        pixels = image.load()\n        for y in range(4):\n            for x in range(4):\n                if x % 2 == 0:\n                    pixels[x, y] = 255\n        expected_bits = [1, 0, 1, 0,\n                         1, 0, 1, 0,\n                         1, 0, 1, 0,\n                         1, 0, 1, 0]\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef convert_image_to_bits(image_path: str) -> List:\n    \"\"\"\n    Convert a picture to an array of binary bits. Convert it to black and white mode (only 0s and 1s, corresponding to black and white), convert the white pixel (value 255) to 1, convert the black pixel to 0, and finally store these bits in an array and return\n\n\n    Args:\n        image_path (str): The path to the image file.\n\n    Returns:\n        list: A list of bits (0 or 1) representing the image.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "const Jimp = require('jimp');\n\n/**\n * Converts an image to an array of binary bits. The image is converted to black and white mode,\n * where white pixels (value 255) are represented by 1 and black pixels by 0. These bits are then\n * stored in an array and returned.\n *\n * @param {string} imagePath - The path to the image file.\n * @returns {Promise<Array<number>>} A promise that resolves to an array of bits (0 or 1) representing the image.\n */\nasync function convertImageToBits(imagePath) {}", "test_code": "const Jimp = require('jimp');\nconst fs = require('fs');\nconst { Readable } = require('stream');\n\njest.mock('./convertImageToBits', () => ({\n  convertImageToBits: jest.fn(),\n}));\n\n\ndescribe('TestConvertImageToBits', () => {\n  function createImage(mode, size, color) {\n    /**\n     * Helper method to create an in-memory image.\n     *\n     * @param {string} mode - The color mode of the image (e.g., '1' for binary, 'L' for grayscale).\n     * @param {Array<number>} size - An array of the image size [width, height].\n     * @param {number} color - The color to fill the image. 255 for white, 0 for black in '1' mode.\n     *\n     * @returns {Promise<Jimp>} A Promise that resolves to a Jimp Image object.\n     */\n    return Jimp.create(size[0], size[1], color).then((image) => {\n      if (mode === '1') {\n        image.grayscale();\n        image.threshold(127);\n      }\n      return image;\n    });\n  }\n\n  async function getImageBytes(image) {\n    const buffer = await image.getBufferAsync(Jimp.MIME_PNG);\n    return new Readable().wrap(buffer);\n  }\n\n  describe('test_all_white_image', () => {\n    it('should convert an all-white image correctly', async () => {\n      const image = await createImage('1', [4, 4], 0xffffff); // White color in RGB\n      const imgBytes = await getImageBytes(image);\n      const expectedBits = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\n      const result = await convertImageToBits(imgBytes);\n      expect(result).toEqual(expectedBits);\n    });\n  });\n\n  describe('test_all_black_image', () => {\n    it('should convert an all-black image correctly', async () => {\n      const image = await createImage('1', [4, 4], 0x000000); // Black color in RGB\n      const imgBytes = await getImageBytes(image);\n      const expectedBits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n      const result = await convertImageToBits(imgBytes);\n      expect(result).toEqual(expectedBits);\n    });\n  });\n\n  describe('test_checkerboard_image', () => {\n    it('should convert a checkerboard image correctly', async () => {\n      const image = await createImage('1', [4, 4], 0x000000); // Black color in RGB\n      const pixels = image.bitmap.data;\n      for (let y = 0; y < 4; y++) {\n        for (let x = 0; x < 4; x++) {\n          if ((x + y) % 2 === 0) {\n            const index = (y * 4 + x) * 4;\n            pixels[index] = 255; // Red channel\n            pixels[index + 1] = 255; // Green channel\n            pixels[index + 2] = 255; // Blue channel\n            pixels[index + 3] = 255; // Alpha channel\n          }\n        }\n      }\n      const imgBytes = await getImageBytes(image);\n      const expectedBits = [1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1];\n      const result = await convertImageToBits(imgBytes);\n      expect(result).toEqual(expectedBits);\n    });\n  });\n\n  describe('test_horizontal_stripes_image', () => {\n    it('should convert a horizontal stripes image correctly', async () => {\n      const image = await createImage('1', [4, 4], 0x000000); // Black color in RGB\n      const pixels = image.bitmap.data;\n      for (let y = 0; y < 4; y++) {\n        for (let x = 0; x < 4; x++) {\n          if (y % 2 === 0) {\n            const index = (y * 4 + x) * 4;\n            pixels[index] = 255; // Red channel\n            pixels[index + 1] = 255; // Green channel\n            pixels[index + 2] = 255; // Blue channel\n            pixels[index + 3] = 255; // Alpha channel\n          }\n        }\n      }\n      const imgBytes = await getImageBytes(image);\n      const expectedBits = [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0];\n      const result = await convertImageToBits(imgBytes);\n      expect(result).toEqual(expectedBits);\n    });\n  });\n\n  describe('test_vertical_stripes_image', () => {\n    it('should convert a vertical stripes image correctly', async () => {\n      const image = await createImage('1', [4, 4], 0x000000); // Black color in RGB\n      const pixels = image.bitmap.data;\n      for (let y = 0; y < 4; y++) {\n        for (let x = 0; x < 4; x++) {\n          if (x % 2 === 0) {\n            const index = (y * 4 + x) * 4;\n            pixels[index] = 255; // Red channel\n            pixels[index + 1] = 255; // Green channel\n            pixels[index + 2] = 255; // Blue channel\n            pixels[index + 3] = 255; // Alpha channel\n          }\n        }\n      }\n      const imgBytes = await getImageBytes(image);\n      const expectedBits = [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0];\n      const result = await convertImageToBits(imgBytes);\n      expect(result).toEqual(expectedBits);\n    });\n  });\n});", "prompt": "please write a javascript function , the function signature as below const Jimp = require('jimp');\n\n/**\n * Converts an image to an array of binary bits. The image is converted to black and white mode,\n * where white pixels (value 255) are represented by 1 and black pixels by 0. These bits are then\n * stored in an array and returned.\n *\n * @param {string} imagePath - The path to the image file.\n * @returns {Promise<Array<number>>} A promise that resolves to an array of bits (0 or 1) representing the image.\n */\nasync function convertImageToBits(imagePath) {}", "addition_info": ""}, "typescript": {"code_signature": "import Jimp from 'jimp';\n\n/**\n * Converts an image to an array of binary bits.\n * Converts the image to black and white mode (only 0s and 1s, corresponding to black and white),\n * converts the white pixel (value 255) to 1, converts the black pixel to 0,\n * and finally stores these bits in an array and returns it.\n *\n * @param {string} imagePath - The path to the image file.\n * @returns {Promise<number[]>} A promise that resolves to a list of bits (0 or 1) representing the image.\n */\nasync function convertImageToBits(imagePath: string): Promise<number[]> {}", "test_code": "import Jimp from 'jimp';\ndescribe('TestConvertImageToBits', () => {\n    /**\n     * Helper method to create an in-memory image.\n     *\n     * @param {string} mode - The color mode of the image (e.g., '1' for binary, 'L' for grayscale).\n     * @param {number[]} size - A tuple of the image size (width, height).\n     * @param {number | number[]} color - The color to fill the image. 255 for white, 0 for black in '1' mode.\n     * @returns {Promise<Jimp>} A Jimp Image object.\n     */\n    async function createImage(mode: string, size: [number, number], color: number | number[]): Promise<Jimp> {\n        const image = new Jimp(size[0], size[1], color);\n        if (mode === '1') {\n            image.color([{ apply: 'greyscale', params: [] }]);\n        }\n        return image;\n    }\n\n    describe('test_all_white_image', () => {\n        it('should convert an all-white image to bits', async () => {\n            const image = await createImage('1', [4, 4], 0xffffff); // White color in RGB\n            const imgBuffer = await image.getBufferAsync(Jimp.MIME_PNG);\n            const result = await convertImageToBits(imgBuffer);\n            const expectedBits = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\n            expect(result).toEqual(expectedBits);\n        });\n    });\n\n    describe('test_all_black_image', () => {\n        it('should convert an all-black image to bits', async () => {\n            const image = await createImage('1', [4, 4], 0x000000); // Black color in RGB\n            const imgBuffer = await image.getBufferAsync(Jimp.MIME_PNG);\n            const result = await convertImageToBits(imgBuffer);\n            const expectedBits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n            expect(result).toEqual(expectedBits);\n        });\n    });\n\n    describe('test_checkerboard_image', () => {\n        it('should convert a checkerboard image to bits', async () => {\n            const image = await createImage('1', [4, 4], 0x000000); // Black color in RGB\n            for (let y = 0; y < 4; y++) {\n                for (let x = 0; x < 4; x++) {\n                    if ((x + y) % 2 === 0) {\n                        image.setPixelColor(0xffffff, x, y); // Set white pixel\n                    }\n                }\n            }\n            const imgBuffer = await image.getBufferAsync(Jimp.MIME_PNG);\n            const result = await convertImageToBits(imgBuffer);\n            const expectedBits = [1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1];\n            expect(result).toEqual(expectedBits);\n        });\n    });\n\n    describe('test_horizontal_stripes_image', () => {\n        it('should convert a horizontal stripes image to bits', async () => {\n            const image = await createImage('1', [4, 4], 0x000000); // Black color in RGB\n            for (let y = 0; y < 4; y++) {\n                for (let x = 0; x < 4; x++) {\n                    if (y % 2 === 0) {\n                        image.setPixelColor(0xffffff, x, y); // Set white pixel\n                    }\n                }\n            }\n            const imgBuffer = await image.getBufferAsync(Jimp.MIME_PNG);\n            const result = await convertImageToBits(imgBuffer);\n            const expectedBits = [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0];\n            expect(result).toEqual(expectedBits);\n        });\n    });\n\n    describe('test_vertical_stripes_image', () => {\n        it('should convert a vertical stripes image to bits', async () => {\n            const image = await createImage('1', [4, 4], 0x000000); // Black color in RGB\n            for (let y = 0; y < 4; y++) {\n                for (let x = 0; x < 4; x++) {\n                    if (x % 2 === 0) {\n                        image.setPixelColor(0xffffff, x, y); // Set white pixel\n                    }\n                }\n            }\n            const imgBuffer = await image.getBufferAsync(Jimp.MIME_PNG);\n            const result = await convertImageToBits(imgBuffer);\n            const expectedBits = [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0];\n            expect(result).toEqual(expectedBits);\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below import Jimp from 'jimp';\n\n/**\n * Converts an image to an array of binary bits.\n * Converts the image to black and white mode (only 0s and 1s, corresponding to black and white),\n * converts the white pixel (value 255) to 1, converts the black pixel to 0,\n * and finally stores these bits in an array and returns it.\n *\n * @param {string} imagePath - The path to the image file.\n * @returns {Promise<number[]>} A promise that resolves to a list of bits (0 or 1) representing the image.\n */\nasync function convertImageToBits(imagePath: string): Promise<number[]> {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert a picture to an array of binary bits. Convert it to black and white mode (only 0s and 1s,\n * corresponding to black and white), convert the white pixel (value 255) to 1, convert the black pixel to 0,\n * and finally store these bits in an array and return.\n *\n * @param image_path The path to the image file.\n * @return std::vector<int> A vector of bits (0 or 1) representing the image.\n */\nstd::vector<int> convert_image_to_bits(const std::string& image_path){\n\n}", "test_code": "TEST_CASE(\"TestConvertImageToBits\", \"[image]\") {\n    SECTION(\"All White Image\") {\n        const char* filename = \"all_white.png\";\n        create_and_save_image(\"1\", {4, 4}, 255, filename);\n        std::vector<int> expected_bits = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n        std::vector<int> result = convert_image_to_bits(filename);\n        REQUIRE(result == expected_bits);\n    }\n\n    SECTION(\"All Black Image\") {\n        const char* filename = \"all_black.png\";\n        create_and_save_image(\"1\", {4, 4}, 0, filename);\n        std::vector<int> expected_bits = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n        std::vector<int> result = convert_image_to_bits(filename);\n        REQUIRE(result == expected_bits);\n    }\n\n    SECTION(\"Checkerboard Image\") {\n        const char* filename = \"checkerboard.png\";\n        create_and_save_image(\"1\", {4, 4}, 0, filename);\n\n        // Load the image and modify pixels\n        int width, height, channels;\n        unsigned char* data = stbi_load(filename, &width, &height, &channels, 1);\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x) {\n                if ((x + y) % 2 == 0) {\n                    data[y * width + x] = 255;\n                }\n            }\n        }\n        stbi_write_png(filename, width, height, 1, data, width);\n        stbi_image_free(data);\n\n        std::vector<int> expected_bits = {1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1};\n        std::vector<int> result = convert_image_to_bits(filename);\n        REQUIRE(result == expected_bits);\n    }\n\n    SECTION(\"Horizontal Stripes Image\") {\n        const char* filename = \"horizontal_stripes.png\";\n        create_and_save_image(\"1\", {4, 4}, 0, filename);\n\n        // Load the image and modify pixels\n        int width, height, channels;\n        unsigned char* data = stbi_load(filename, &width, &height, &channels, 1);\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x) {\n                if (y % 2 == 0) {\n                    data[y * width + x] = 255;\n                }\n            }\n        }\n        stbi_write_png(filename, width, height, 1, data, width);\n        stbi_image_free(data);\n\n        std::vector<int> expected_bits = {1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0};\n        std::vector<int> result = convert_image_to_bits(filename);\n        REQUIRE(result == expected_bits);\n    }\n\n    SECTION(\"Vertical Stripes Image\") {\n        const char* filename = \"vertical_stripes.png\";\n        create_and_save_image(\"1\", {4, 4}, 0, filename);\n\n        // Load the image and modify pixels\n        int width, height, channels;\n        unsigned char* data = stbi_load(filename, &width, &height, &channels, 1);\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x) {\n                if (x % 2 == 0) {\n                    data[y * width + x] = 255;\n                }\n            }\n        }\n        stbi_write_png(filename, width, height, 1, data, width);\n        stbi_image_free(data);\n\n        std::vector<int> expected_bits = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n        std::vector<int> result = convert_image_to_bits(filename);\n        REQUIRE(result == expected_bits);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert a picture to an array of binary bits. Convert it to black and white mode (only 0s and 1s,\n * corresponding to black and white), convert the white pixel (value 255) to 1, convert the black pixel to 0,\n * and finally store these bits in an array and return.\n *\n * @param image_path The path to the image file.\n * @return std::vector<int> A vector of bits (0 or 1) representing the image.\n */\nstd::vector<int> convert_image_to_bits(const std::string& image_path){\n\n}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 256, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "convert an array of binary bits to an array of bytes. Traversing through each bit, composing these bits into bytes, forming a byte every 8 bits, and then storing these bytes in an array and returning it. If the length of the bit array is not a multiple of 8, the last incomplete byte will be discarded.\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef bits_to_bytes(bits: List[int]) -> bytearray:\n    \"\"\"\n    convert an array of binary bits to an array of bytes. Traversing through each bit, composing these bits into bytes, forming a byte every 8 bits, and then storing these bytes in an array and returning it. If the length of the bit array is not a multiple of 8, the last incomplete byte will be discarded.\n\n    Args:\n        bits (List[int]): The input array of bits (each element should be 0 or 1).\n\n    Returns:\n        An array of bytes constructed from the bits.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestBitsToBytes(unittest.TestCase):\n\n    def test_exact_multiple_of_eight(self):\n        \"\"\"Test bit arrays that are exact multiples of 8 bits.\"\"\"\n        bits = [1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1]\n        expected = bytearray([0b10110010, 0b01001111])  # Corrected to match actual byte values\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_incomplete_byte_discarded(self):\n        \"\"\"Test bit arrays where the last bits do not make up a full byte.\"\"\"\n        bits = [1, 0, 1, 1, 0, 0, 1, 0, 0, 1]  # Last two bits should be discarded\n        expected = bytearray([0b10110010])\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_empty_bit_array(self):\n        \"\"\"Test an empty bit array.\"\"\"\n        bits = []\n        expected = bytearray()\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_single_full_byte(self):\n        \"\"\"Test bit arrays that exactly make one byte.\"\"\"\n        bits = [1, 1, 1, 1, 1, 1, 1, 1]  # Represents the byte 0xFF\n        expected = bytearray([0xFF])\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_no_bits_discarded(self):\n        \"\"\"Test bit arrays with multiple of 8 bits and no extra bits.\"\"\"\n        bits = [1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1]\n        expected = bytearray([0xCC, 0x77])  # Corrected the second byte from 0xB7 to 0x77\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef bits_to_bytes(bits: List[int]) -> bytearray:\n    \"\"\"\n    convert an array of binary bits to an array of bytes. Traversing through each bit, composing these bits into bytes, forming a byte every 8 bits, and then storing these bytes in an array and returning it. If the length of the bit array is not a multiple of 8, the last incomplete byte will be discarded.\n\n    Args:\n        bits (List[int]): The input array of bits (each element should be 0 or 1).\n\n    Returns:\n        An array of bytes constructed from the bits.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts an array of binary bits to an array of bytes. Traverses through each bit,\n * composing these bits into bytes, forming a byte every 8 bits, and then storing these\n * bytes in an array and returning it. If the length of the bit array is not a multiple\n * of 8, the last incomplete byte will be discarded.\n *\n * @param {Array<number>} bits - The input array of bits (each element should be 0 or 1).\n * @returns {Uint8Array} An array of bytes constructed from the bits.\n */\nfunction bitsToBytes(bits) {}", "test_code": "describe('TestBitsToBytes', () => {\n    describe('test_exact_multiple_of_eight', () => {\n        it('should correctly convert bit arrays that are exact multiples of 8 bits', () => {\n            const bits = [1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1];\n            const expected = new Uint8Array([0b10110010, 0b01001111]);\n            const result = bitsToBytes(bits);\n            expect(result).toEqual(expected);\n        });\n    });\n\n    describe('test_incomplete_byte_discarded', () => {\n        it('should discard the last incomplete byte', () => {\n            const bits = [1, 0, 1, 1, 0, 0, 1, 0, 0, 1]; // Last two bits should be discarded\n            const expected = new Uint8Array([0b10110010]);\n            const result = bitsToBytes(bits);\n            expect(result).toEqual(expected);\n        });\n    });\n\n    describe('test_empty_bit_array', () => {\n        it('should handle an empty bit array', () => {\n            const bits = [];\n            const expected = new Uint8Array([]);\n            const result = bitsToBytes(bits);\n            expect(result).toEqual(expected);\n        });\n    });\n\n    describe('test_single_full_byte', () => {\n        it('should correctly convert bit arrays that exactly make one byte', () => {\n            const bits = [1, 1, 1, 1, 1, 1, 1, 1]; // Represents the byte 0xFF\n            const expected = new Uint8Array([0xFF]);\n            const result = bitsToBytes(bits);\n            expect(result).toEqual(expected);\n        });\n    });\n\n    describe('test_no_bits_discarded', () => {\n        it('should correctly convert bit arrays with multiple of 8 bits and no extra bits', () => {\n            const bits = [1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1];\n            const expected = new Uint8Array([0xCC, 0x77]); // Corrected the second byte from 0xB7 to 0x77\n            const result = bitsToBytes(bits);\n            expect(result).toEqual(expected);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts an array of binary bits to an array of bytes. Traverses through each bit,\n * composing these bits into bytes, forming a byte every 8 bits, and then storing these\n * bytes in an array and returning it. If the length of the bit array is not a multiple\n * of 8, the last incomplete byte will be discarded.\n *\n * @param {Array<number>} bits - The input array of bits (each element should be 0 or 1).\n * @returns {Uint8Array} An array of bytes constructed from the bits.\n */\nfunction bitsToBytes(bits) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts an array of binary bits to an array of bytes. Traverses through each bit,\n * composing these bits into bytes, forming a byte every 8 bits, and then storing these\n * bytes in an array and returning it. If the length of the bit array is not a multiple\n * of 8, the last incomplete byte will be discarded.\n *\n * @param bits - The input array of bits (each element should be 0 or 1).\n * @returns An array of bytes constructed from the bits.\n */\nfunction bitsToBytes(bits: number[]): Uint8Array {}", "test_code": "describe('TestBitsToBytes', () => {\n  it('test_exact_multiple_of_eight', () => {\n    /** Test bit arrays that are exact multiples of 8 bits. */\n    const bits = [1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1];\n    const expected = new Uint8Array([0b10110010, 0b01001111]);\n    const result = bitsToBytes(bits);\n    expect(result).toEqual(expected);\n  });\n\n  it('test_incomplete_byte_discarded', () => {\n    /** Test bit arrays where the last bits do not make up a full byte. */\n    const bits = [1, 0, 1, 1, 0, 0, 1, 0, 0, 1]; // Last two bits should be discarded\n    const expected = new Uint8Array([0b10110010]);\n    const result = bitsToBytes(bits);\n    expect(result).toEqual(expected);\n  });\n\n  it('test_empty_bit_array', () => {\n    /** Test an empty bit array. */\n    const bits = [];\n    const expected = new Uint8Array([]);\n    const result = bitsToBytes(bits);\n    expect(result).toEqual(expected);\n  });\n\n  it('test_single_full_byte', () => {\n    /** Test bit arrays that exactly make one byte. */\n    const bits = [1, 1, 1, 1, 1, 1, 1, 1]; // Represents the byte 0xFF\n    const expected = new Uint8Array([0xFF]);\n    const result = bitsToBytes(bits);\n    expect(result).toEqual(expected);\n  });\n\n  it('test_no_bits_discarded', () => {\n    /** Test bit arrays with multiple of 8 bits and no extra bits. */\n    const bits = [1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1];\n    const expected = new Uint8Array([0xCC, 0x77]); // Corrected the second byte from 0xB7 to 0x77\n    const result = bitsToBytes(bits);\n    expect(result).toEqual(expected);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts an array of binary bits to an array of bytes. Traverses through each bit,\n * composing these bits into bytes, forming a byte every 8 bits, and then storing these\n * bytes in an array and returning it. If the length of the bit array is not a multiple\n * of 8, the last incomplete byte will be discarded.\n *\n * @param bits - The input array of bits (each element should be 0 or 1).\n * @returns An array of bytes constructed from the bits.\n */\nfunction bitsToBytes(bits: number[]): Uint8Array {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert an array of binary bits to an array of bytes. Traverse through each bit,\n * composing these bits into bytes, forming a byte every 8 bits, and then store\n * these bytes in a vector and return it. If the length of the bit array is not a\n * multiple of 8, the last incomplete byte will be discarded.\n *\n * @param bits A vector of integers representing the input array of bits (each element should be 0 or 1).\n * @return A vector of bytes constructed from the bits.\n */\nstd::vector<uint8_t> bits_to_bytes(const std::vector<int>& bits){\n\n}", "test_code": "TEST_CASE(\"Test bits_to_bytes function\", \"[bits_to_bytes]\") {\n    SECTION(\"Test exact multiple of eight\") {\n        std::vector<int> bits = {1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1};\n        std::vector<unsigned char> expected = {0b10110010, 0b01001111};\n        auto result = bits_to_bytes(bits);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test incomplete byte discarded\") {\n        std::vector<int> bits = {1, 0, 1, 1, 0, 0, 1, 0, 0, 1};  // Last two bits should be discarded\n        std::vector<unsigned char> expected = {0b10110010};\n        auto result = bits_to_bytes(bits);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test empty bit array\") {\n        std::vector<int> bits = {};\n        std::vector<unsigned char> expected = {};\n        auto result = bits_to_bytes(bits);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test single full byte\") {\n        std::vector<int> bits = {1, 1, 1, 1, 1, 1, 1, 1};  // Represents the byte 0xFF\n        std::vector<unsigned char> expected = {0xFF};\n        auto result = bits_to_bytes(bits);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test no bits discarded\") {\n        std::vector<int> bits = {1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1};\n        std::vector<unsigned char> expected = {0xCC, 0x77};  // Corrected the second byte from 0xB7 to 0x77\n        auto result = bits_to_bytes(bits);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert an array of binary bits to an array of bytes. Traverse through each bit,\n * composing these bits into bytes, forming a byte every 8 bits, and then store\n * these bytes in a vector and return it. If the length of the bit array is not a\n * multiple of 8, the last incomplete byte will be discarded.\n *\n * @param bits A vector of integers representing the input array of bits (each element should be 0 or 1).\n * @return A vector of bytes constructed from the bits.\n */\nstd::vector<uint8_t> bits_to_bytes(const std::vector<int>& bits){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts an array of binary bits to an array of bytes. Traverses through each bit,\n * composing these bits into bytes, forming a byte every 8 bits, and then storing these\n * bytes in an array and returning it. If the length of the bit array is not a multiple\n * of 8, the last incomplete byte will be discarded.\n *\n * @param bits The input list of bits (each element should be 0 or 1).\n * @return A byte array constructed from the bits.\n */\npublic static byte[] bitsToBytes(List<Integer> bits) {}", "test_code": "package org.real.temp;\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n\n    @Test\n    public void testExactMultipleOfEight() {\n        List<Integer> bits = Arrays.asList(1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1);\n        byte[] expected = new byte[]{(byte) 0b10110010, 0b01001111};\n        byte[] result = bitsToBytes(bits);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testIncompleteByteDiscarded() {\n        List<Integer> bits = Arrays.asList(1, 0, 1, 1, 0, 0, 1, 0, 0, 1);\n        byte[] expected = new byte[]{(byte) 0b10110010};\n        byte[] result = bitsToBytes(bits);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testEmptyBitArray() {\n        List<Integer> bits = Arrays.asList();\n        byte[] expected = new byte[]{};\n        byte[] result = bitsToBytes(bits);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testSingleFullByte() {\n        List<Integer> bits = Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1);\n        byte[] expected = new byte[]{(byte) 0xFF};\n        byte[] result = bitsToBytes(bits);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testNoBitsDiscarded() {\n        List<Integer> bits = Arrays.asList(1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1);\n        byte[] expected = new byte[]{(byte) 0xCC, 0x77};\n        byte[] result = bitsToBytes(bits);\n        assertArrayEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts an array of binary bits to an array of bytes. Traverses through each bit,\n * composing these bits into bytes, forming a byte every 8 bits, and then storing these\n * bytes in an array and returning it. If the length of the bit array is not a multiple\n * of 8, the last incomplete byte will be discarded.\n *\n * @param bits The input list of bits (each element should be 0 or 1).\n * @return A byte array constructed from the bits.\n */\npublic static byte[] bitsToBytes(List<Integer> bits) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 258, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "given a character set, extract the position of a specific character from a byte array. First, determine whether the desired character exists in the character set, and if so, calculate the character's position in the byte array, and extract the character's bits\n", "language_version_list": {"python": {"code_signature": "from typing import Tuple, List\n\n\ndef extract_character_bits(byte_array: bytes, char: str, charset='utf-8') -> Tuple[int, str]:\n    \"\"\"\n    Extracts the position and bits of a specific character from a byte array.\n\n    Args:\n        byte_array (bytes): The byte array to search within\n        char (str): The character to find in the byte array\n        charset (str): The character encoding of the byte array\n\n    Returns:\n        A tuple of (position, bits) if the character is found, otherwise None.\n    \"\"\"\n", "test_code": "import unittest\n\n# Assuming extract_character_bits is imported from your module\n# from your_module import extract_character_bits\n\nclass TestExtractCharacterBits(unittest.TestCase):\n\n    def test_case_1_valid_utf8(self):\n        byte_array = b'Hello, World!'\n        char = 'W'\n        result = extract_character_bits(byte_array, char, 'utf-8')\n        expected_result = (7, '01010111')  # 'W' is at position 7 with binary bits\n        self.assertEqual(result, expected_result)\n\n    def test_case_2_non_existent_character(self):\n        byte_array = b'This is a test.'\n        char = 'z'\n        result = extract_character_bits(byte_array, char, 'utf-8')\n        self.assertIsNone(result)  # Character 'z' is not in the byte array\n\n    def test_case_3_invalid_encoding(self):\n        byte_array = b'\\xff\\xfe'\n        char = 'A'\n        result = extract_character_bits(byte_array, char, 'ascii')  # Invalid bytes for ASCII\n        self.assertIsNone(result)  # Should handle UnicodeDecodeError and return None\n\n    def test_case_4_valid_utf16(self):\n        byte_array = 'Hello, World!'.encode('utf-16')\n        char = '!'\n        result = extract_character_bits(byte_array, char, 'utf-16')\n        expected_result = (12, '00100001 00000000')  # '!' at position 12 in UTF-16 encoding\n        self.assertEqual(result, expected_result)\n\n    def test_case_5_special_characters_utf8(self):\n        byte_array = 'Python \ud83d\udc0d is fun!'.encode('utf-8')\n        char = '\ud83d\udc0d'\n        result = extract_character_bits(byte_array, char, 'utf-8')\n        expected_result = (7, '11110000 10011111 10010000 10001101')  # Unicode character \ud83d\udc0d in UTF-8\n        self.assertEqual(result, expected_result)\n", "prompt": "please write a python function , the function signature as below from typing import Tuple, List\n\n\ndef extract_character_bits(byte_array: bytes, char: str, charset='utf-8') -> Tuple[int, str]:\n    \"\"\"\n    Extracts the position and bits of a specific character from a byte array.\n\n    Args:\n        byte_array (bytes): The byte array to search within\n        char (str): The character to find in the byte array\n        charset (str): The character encoding of the byte array\n\n    Returns:\n        A tuple of (position, bits) if the character is found, otherwise None.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extracts the position and bits of a specific character from a byte array.\n *\n * @param {Uint8Array} byteArray - The byte array to search within.\n * @param {string} char - The character to find in the byte array.\n * @param {string} [charset='utf-8'] - The character encoding of the byte array.\n * @returns {Array|undefined} - A tuple of (position, bits) if the character is found, otherwise undefined.\n */\nfunction extractCharacterBits(byteArray, char, charset = 'utf-8') {}", "test_code": "describe('TestExtractCharacterBits', () => {\n    it('test_case_1_valid_utf8', () => {\n        const byte_array = new Uint8Array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n        const char = 'W';\n        const result = extractCharacterBits(byte_array, char, 'utf-8');\n        const expected_result = [7, '01010111'];  // 'W' is at position 7 with binary bits\n        expect(result).toEqual(expected_result);\n    });\n\n    it('test_case_2_non_existent_character', () => {\n        const byte_array = new Uint8Array([84, 104, 105, 115, 32, 105, 115, 32, 97, 32, 116, 101, 115, 116, 46]);\n        const char = 'z';\n        const result = extractCharacterBits(byte_array, char, 'utf-8');\n        expect(result).toBeUndefined();  // Character 'z' is not in the byte array\n    });\n\n    it('test_case_3_invalid_encoding', () => {\n        const byte_array = new Uint8Array([255, 254]);\n        const char = 'A';\n        const result = extractCharacterBits(byte_array, char, 'ascii');  // Invalid bytes for ASCII\n        expect(result).toBeUndefined();  // Should handle UnicodeDecodeError and return undefined\n    });\n\n    it('test_case_4_valid_utf16', () => {\n        const byte_array = new Uint8Array([0, 72, 0, 101, 0, 108, 0, 108, 0, 111, 0, 44, 0, 32, 0, 87, 0, 111, 0, 114, 0, 108, 0, 100, 0, 33, 0, 0]);\n        const char = '!';\n        const result = extractCharacterBits(byte_array, char, 'utf-16');\n        const expected_result = [12, '00100001 00000000'];  // '!' at position 12 in UTF-16 encoding\n        expect(result).toEqual(expected_result);\n    });\n\n    it('test_case_5_special_characters_utf8', () => {\n        const byte_array = new Uint8Array([80, 121, 116, 104, 111, 110, 240, 149, 145, 133, 105, 115, 32, 102, 117, 110, 33]);\n        const char = '\ud83d\udc0d';\n        const result = extractCharacterBits(byte_array, char, 'utf-8');\n        const expected_result = [7, '11110000 10011111 10010000 10001101'];  // Unicode character \ud83d\udc0d in UTF-8\n        expect(result).toEqual(expected_result);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Extracts the position and bits of a specific character from a byte array.\n *\n * @param {Uint8Array} byteArray - The byte array to search within.\n * @param {string} char - The character to find in the byte array.\n * @param {string} [charset='utf-8'] - The character encoding of the byte array.\n * @returns {Array|undefined} - A tuple of (position, bits) if the character is found, otherwise undefined.\n */\nfunction extractCharacterBits(byteArray, char, charset = 'utf-8') {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Extracts the position and bits of a specific character from a byte array.\n *\n * @param byteArray - The byte array to search within.\n * @param char - The character to find in the byte array.\n * @param charset - The character encoding of the byte array.\n * @returns A tuple of (position, bits) if the character is found, otherwise null.\n */\nfunction extractCharacterBits(byteArray: Uint8Array, char: string, charset: string = 'utf-8'): [number, string] | null {}", "test_code": "describe('TestExtractCharacterBits', () => {\n  it('test_case_1_valid_utf8', () => {\n      const byteArray = new Uint8Array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n      const char = 'W';\n      const result = extractCharacterBits(byteArray, char, 'utf-8');\n      const expectedResult = [7, '01010111'];  // 'W' is at position 7 with binary bits\n      expect(result).toEqual(expectedResult);\n  });\n\n  it('test_case_2_non_existent_character', () => {\n      const byteArray = new Uint8Array([84, 104, 105, 115, 32, 105, 115, 32, 97, 32, 116, 101, 115, 116, 46]);\n      const char = 'z';\n      const result = extractCharacterBits(byteArray, char, 'utf-8');\n      expect(result).toBeNull();  // Character 'z' is not in the byte array\n  });\n\n  it('test_case_3_invalid_encoding', () => {\n      const byteArray = new Uint8Array([255, 254]);\n      const char = 'A';\n      const result = extractCharacterBits(byteArray, char, 'ascii');  // Invalid bytes for ASCII\n      expect(result).toBeNull();  // Should handle UnicodeDecodeError and return null\n  });\n\n  it('test_case_4_valid_utf16', () => {\n      const byteString = 'Hello, World!';\n      const byteArray = new Uint8Array(new TextEncoder().encode(byteString).buffer);\n      const char = '!';\n      const result = extractCharacterBits(byteArray, char, 'utf-16');\n      const expectedResult = [12, '00100001 00000000'];  // '!' at position 12 in UTF-16 encoding\n      expect(result).toEqual(expectedResult);\n  });\n\n  it('test_case_5_special_characters_utf8', () => {\n      const byteString = 'Python \ud83d\udc0d is fun!';\n      const byteArray = new Uint8Array(new TextEncoder().encode(byteString).buffer);\n      const char = '\ud83d\udc0d';\n      const result = extractCharacterBits(byteArray, char, 'utf-8');\n      const expectedResult = [7, '11110000 10011111 10010000 10001101'];  // Unicode character \ud83d\udc0d in UTF-8\n      expect(result).toEqual(expectedResult);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Extracts the position and bits of a specific character from a byte array.\n *\n * @param byteArray - The byte array to search within.\n * @param char - The character to find in the byte array.\n * @param charset - The character encoding of the byte array.\n * @returns A tuple of (position, bits) if the character is found, otherwise null.\n */\nfunction extractCharacterBits(byteArray: Uint8Array, char: string, charset: string = 'utf-8'): [number, string] | null {}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 259, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "determine whether a number is a compliant four-digit number\n", "language_version_list": {"python": {"code_signature": "def is_compliant_four_digit(number: int) -> bool:\n    \"\"\"\n    determine whether a number is a compliant four-digit number\n    Args:\n        number (int): The number to check.\n\n    Returns:\n        True if the number is a compliant four-digit number, False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestIsCompliantFourDigit(unittest.TestCase):\n    def test_positive_four_digit_number(self):\n        # Tests a standard positive four-digit number\n        self.assertTrue(is_compliant_four_digit(1234))\n\n    def test_boundary_values(self):\n        # Tests the boundary values of the range\n        self.assertTrue(is_compliant_four_digit(1000))\n        self.assertTrue(is_compliant_four_digit(9999))\n\n    def test_negative_four_digit_number(self):\n        # Tests a negative four-digit number\n        self.assertFalse(is_compliant_four_digit(-1234))\n\n    def test_out_of_range_number(self):\n        # Tests numbers that are out of the four-digit range\n        self.assertFalse(is_compliant_four_digit(999))\n        self.assertFalse(is_compliant_four_digit(10000))", "prompt": "please write a python function , the function signature as below def is_compliant_four_digit(number: int) -> bool:\n    \"\"\"\n    determine whether a number is a compliant four-digit number\n    Args:\n        number (int): The number to check.\n\n    Returns:\n        True if the number is a compliant four-digit number, False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Determines whether a number is a compliant four-digit number.\n * Compliance is defined as the number being between 1000 and 9999, inclusive.\n * \n * @param {number} number - The number to check.\n * @returns {boolean} - True if the number is a compliant four-digit number, False otherwise.\n */\nfunction isCompliantFourDigit(number) {}", "test_code": "describe('isCompliantFourDigit', () => {\n    describe('test positive four-digit number', () => {\n        it('should return true for a standard positive four-digit number', () => {\n            expect(isCompliantFourDigit(1234)).toBe(true);\n        });\n    });\n\n    describe('test boundary values', () => {\n        it('should return true for the lower boundary value', () => {\n            expect(isCompliantFourDigit(1000)).toBe(true);\n        });\n\n        it('should return true for the upper boundary value', () => {\n            expect(isCompliantFourDigit(9999)).toBe(true);\n        });\n    });\n\n    describe('test negative four-digit number', () => {\n        it('should return false for a negative four-digit number', () => {\n            expect(isCompliantFourDigit(-1234)).toBe(false);\n        });\n    });\n\n    describe('test out-of-range numbers', () => {\n        it('should return false for a number below the range', () => {\n            expect(isCompliantFourDigit(999)).toBe(false);\n        });\n\n        it('should return false for a number above the range', () => {\n            expect(isCompliantFourDigit(10000)).toBe(false);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Determines whether a number is a compliant four-digit number.\n * Compliance is defined as the number being between 1000 and 9999, inclusive.\n * \n * @param {number} number - The number to check.\n * @returns {boolean} - True if the number is a compliant four-digit number, False otherwise.\n */\nfunction isCompliantFourDigit(number) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Determines whether the given number is a compliant four-digit number.\n * Compliance is defined as the number being between 1000 and 9999, inclusive.\n * \n * @param number - The number to check.\n * @returns {boolean} - True if the number is a compliant four-digit number, False otherwise.\n */\nfunction isCompliantFourDigit(number: number): boolean {}", "test_code": "describe('isCompliantFourDigit', () => {\n    it('should return true for a standard positive four-digit number', () => {\n        expect(isCompliantFourDigit(1234)).toBe(true);\n    });\n\n    it('should return true for boundary values of the range', () => {\n        expect(isCompliantFourDigit(1000)).toBe(true);\n        expect(isCompliantFourDigit(9999)).toBe(true);\n    });\n\n    it('should return false for a negative four-digit number', () => {\n        expect(isCompliantFourDigit(-1234)).toBe(false);\n    });\n\n    it('should return false for numbers that are out of the four-digit range', () => {\n        expect(isCompliantFourDigit(999)).toBe(false);\n        expect(isCompliantFourDigit(10000)).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Determines whether the given number is a compliant four-digit number.\n * Compliance is defined as the number being between 1000 and 9999, inclusive.\n * \n * @param number - The number to check.\n * @returns {boolean} - True if the number is a compliant four-digit number, False otherwise.\n */\nfunction isCompliantFourDigit(number: number): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Determine whether a number is a compliant four-digit number.\n *\n * @param number The number to check.\n *\n * @return true if the number is a compliant four-digit number, false otherwise.\n */\nbool is_compliant_four_digit(int number){\n\n}", "test_code": "TEST_CASE(\"TestIsCompliantFourDigit\", \"[is_compliant_four_digit]\") {\n    SECTION(\"test_positive_four_digit_number\") {\n        // Tests a standard positive four-digit number\n        REQUIRE(is_compliant_four_digit(1234));\n    }\n\n    SECTION(\"test_boundary_values\") {\n        // Tests the boundary values of the range\n        REQUIRE(is_compliant_four_digit(1000));\n        REQUIRE(is_compliant_four_digit(9999));\n    }\n\n    SECTION(\"test_negative_four_digit_number\") {\n        // Tests a negative four-digit number\n        REQUIRE_FALSE(is_compliant_four_digit(-1234));\n    }\n\n    SECTION(\"test_out_of_range_number\") {\n        // Tests numbers that are out of the four-digit range\n        REQUIRE_FALSE(is_compliant_four_digit(999));\n        REQUIRE_FALSE(is_compliant_four_digit(10000));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Determine whether a number is a compliant four-digit number.\n *\n * @param number The number to check.\n *\n * @return true if the number is a compliant four-digit number, false otherwise.\n */\nbool is_compliant_four_digit(int number){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Determines whether the given number is a compliant four-digit number.\n *\n * @param number The number to check.\n * @return true if the number is a compliant four-digit number, false otherwise.\n */\npublic static boolean isCompliantFourDigit(int number) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\n/**\n * Test cases for the isCompliantFourDigit method.\n */\npublic class Tester {\n\n    /**\n     * Tests a standard positive four-digit number.\n     */\n    @Test\n    public void testPositiveFourDigitNumber() {\n        // Tests a standard positive four-digit number\n        assertTrue(\"1234 should be a compliant four-digit number\", isCompliantFourDigit(1234));\n    }\n\n    /**\n     * Tests the boundary values of the range.\n     */\n    @Test\n    public void testBoundaryValues() {\n        // Tests the boundary values of the range\n        assertTrue(\"1000 should be a compliant four-digit number\", isCompliantFourDigit(1000));\n        assertTrue(\"9999 should be a compliant four-digit number\", isCompliantFourDigit(9999));\n    }\n\n    /**\n     * Tests a negative four-digit number.\n     */\n    @Test\n    public void testNegativeFourDigitNumber() {\n        // Tests a negative four-digit number\n        assertFalse(\"-1234 should not be a compliant four-digit number\", isCompliantFourDigit(-1234));\n    }\n\n    /**\n     * Tests numbers that are out of the four-digit range.\n     */\n    @Test\n    public void testOutOfRangeNumber() {\n        // Tests numbers that are out of the four-digit range\n        assertFalse(\"999 should not be a compliant four-digit number\", isCompliantFourDigit(999));\n        assertFalse(\"10000 should not be a compliant four-digit number\", isCompliantFourDigit(10000));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Determines whether the given number is a compliant four-digit number.\n *\n * @param number The number to check.\n * @return true if the number is a compliant four-digit number, false otherwise.\n */\npublic static boolean isCompliantFourDigit(int number) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 260, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Process the csv file and delete rows with two empty columns\n", "language_version_list": {"python": {"code_signature": "import pandas as pd\n\n\ndef process_csv(file_path: str, output_path: str):\n    \"\"\"\n    Processes a CSV file and removes rows with two or more empty columns.If file is empty return empty str\n\n    Args:\n        file_path (str): The path to the input CSV file.\n        output_path (str): The path where the processed CSV file will be saved.\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\nimport pandas as pd\nfrom io import StringIO\n\nimport os\n\n\n# Assuming process_csv function is imported from the module\n# from your_module import process_csv\n\nclass TestProcessCSV(unittest.TestCase):\n\n    def setUp(self):\n        self.input_data_1 = \"\"\"A,B,C\n1,2,3\n4,,6\n7,8,\n9,10,11\"\"\"\n\n\n        self.input_data_2 = \"\"\"A,B,C,D\n,,\n1,,3,4\n2,3,,5\n,,,\"\"\"\n\n\n        self.input_data_3 = \"\"\"A\n1\n2\n3\"\"\"\n\n\n    def process_data(self, input_data):\n        input_file = StringIO(input_data)\n        output_file = StringIO()\n        input_file_path = \"input.csv\"\n        output_file_path = \"output.csv\"\n\n        # Write input data to a temp CSV file\n        with open(input_file_path, 'w') as f:\n            f.write(input_data)\n\n        # Process the CSV\n        process_csv(input_file_path, output_file_path)\n\n        # Read the output\n        with open(output_file_path, 'r') as f:\n            output_data = f.read()\n\n        # Clean up temp files\n        os.remove(input_file_path)\n        os.remove(output_file_path)\n\n        return output_data\n\n    def test_case_1(self):\n        output = self.process_data(self.input_data_1)\n        expected_output = \"\"\"A,B,C\\n1,2.0,3.0\\n4,,6.0\\n7,8.0,\\n9,10.0,11.0\\n\"\"\"\n        self.assertEqual(output, expected_output)\n\n    def test_case_2(self):\n        output = self.process_data(self.input_data_2)\n        expected_output = \"\"\"A,B,C,D\\n1.0,,3.0,4.0\\n2.0,3.0,,5.0\\n\"\"\"\n        self.assertEqual(output, expected_output)\n\n    def test_case_3(self):\n        output = self.process_data(self.input_data_3)\n        expected_output = \"\"\"A\\n1\\n2\\n3\\n\"\"\"  # Single-column CSV should remain unchanged\n        self.assertEqual(output, expected_output)", "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef process_csv(file_path: str, output_path: str):\n    \"\"\"\n    Processes a CSV file and removes rows with two or more empty columns.If file is empty return empty str\n\n    Args:\n        file_path (str): The path to the input CSV file.\n        output_path (str): The path where the processed CSV file will be saved.\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "const csvParser = require('csv-parser');\nconst createObjectCsvWriter = require('csv-writer').createObjectCsvWriter;\nconst fs = require('fs');\nconst path = require('path');\n\n/**\n * Processes a CSV file and removes rows with two or more empty columns.\n * If the file is empty, returns an empty string.\n *\n * @param {string} filePath - The path to the input CSV file.\n * @param {string} outputPath - The path where the processed CSV file will be saved.\n */\nasync function processCSV(filePath, outputPath) {}", "test_code": "const fs = require('fs');\nconst os = require('os');\nconst path = require('path');\n\ndescribe('TestProcessCSV', () => {\n    let input_data_1 = `A,B,C\n1,2,3\n4,,6\n7,8,\n9,10,11`;\n\n    let input_data_2 = `A,B,C,D\n,,\n1,,3,4\n2,3,,5\n,,,`;\n\n    let input_data_3 = `A\n1\n2\n3`;\n\n    beforeEach(() => {\n        // Temporary directory for test files\n        const tempDir = os.tmpdir();\n        const inputFilePath = path.join(tempDir, 'input.csv');\n        const outputFilePath = path.join(tempDir, 'output.csv');\n\n        // Helper function to process data\n        const process_data = (input_data) => {\n            // Write input data to a temp CSV file\n            fs.writeFileSync(inputFilePath, input_data);\n\n            // Process the CSV\n            processCSV(inputFilePath, outputFilePath);\n\n            // Read the output\n            const output_data = fs.readFileSync(outputFilePath, 'utf8');\n\n            // Clean up temp files\n            fs.unlinkSync(inputFilePath);\n            fs.unlinkSync(outputFilePath);\n\n            return output_data;\n        };\n\n        // Test cases\n        test('test_case_1', async () => {\n            const output = process_data(input_data_1);\n            const expected_output = `A,B,C\\n1,2.0,3.0\\n4,,6.0\\n7,8.0,\\n9,10.0,11.0\\n`;\n            expect(output).toEqual(expected_output);\n        });\n\n        test('test_case_2', async () => {\n            const output = process_data(input_data_2);\n            const expected_output = `A,B,C,D\\n1.0,,3.0,4.0\\n2.0,3.0,,5.0\\n`;\n            expect(output).toEqual(expected_output);\n        });\n\n        test('test_case_3', async () => {\n            const output = process_data(input_data_3);\n            const expected_output = `A\\n1\\n2\\n3\\n`; // Single-column CSV should remain unchanged\n            expect(output).toEqual(expected_output);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below const csvParser = require('csv-parser');\nconst createObjectCsvWriter = require('csv-writer').createObjectCsvWriter;\nconst fs = require('fs');\nconst path = require('path');\n\n/**\n * Processes a CSV file and removes rows with two or more empty columns.\n * If the file is empty, returns an empty string.\n *\n * @param {string} filePath - The path to the input CSV file.\n * @param {string} outputPath - The path where the processed CSV file will be saved.\n */\nasync function processCSV(filePath, outputPath) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as fs from 'fs';\nimport * as csvParser from 'csv-parser';\nimport * as csvWriter from 'csv-writer';\nimport { parse } from 'path';\n\n/**\n * Processes a CSV file and removes rows with two or more empty columns.\n * If the file is empty, returns an empty string.\n *\n * @param file_path - The path to the input CSV file.\n * @param output_path - The path where the processed CSV file will be saved.\n */\nfunction processCsv(file_path: string, output_path: string): void {}", "test_code": "import { readFileSync, writeFileSync, unlinkSync } from 'fs';\nimport { join } from 'path';\n\ndescribe('TestProcessCSV', () => {\n  let input_data_1: string;\n  let input_data_2: string;\n  let input_data_3: string;\n\n  beforeEach(() => {\n    input_data_1 = `A,B,C\n1,2,3\n4,,6\n7,8,\n9,10,11`;\n\n    input_data_2 = `A,B,C,D\n,,\n1,,3,4\n2,3,,5\n,,,`;\n\n    input_data_3 = `A\n1\n2\n3`;\n  });\n\n  const process_data = (input_data: string): string => {\n    const inputFilePath = 'input.csv';\n    const outputFilePath = 'output.csv';\n\n    // Write input data to a temp CSV file\n    writeFileSync(inputFilePath, input_data);\n\n    // Process the CSV\n    processCsv(inputFilePath, outputFilePath);\n\n    // Read the output\n    const outputData = readFileSync(outputFilePath, 'utf8');\n\n    // Clean up temp files\n    unlinkSync(inputFilePath);\n    unlinkSync(outputFilePath);\n\n    return outputData;\n  };\n\n  it('should correctly process input_data_1', () => {\n    const output = process_data(input_data_1);\n    const expectedOutput = `A,B,C\\n1,2.0,3.0\\n4,,6.0\\n7,8.0,\\n9,10.0,11.0\\n`;\n    expect(output).toEqual(expectedOutput);\n  });\n\n  it('should correctly process input_data_2', () => {\n    const output = process_data(input_data_2);\n    const expectedOutput = `A,B,C,D\\n1.0,,3.0,4.0\\n2.0,3.0,,5.0\\n`;\n    expect(output).toEqual(expectedOutput);\n  });\n\n  it('should correctly process input_data_3', () => {\n    const output = process_data(input_data_3);\n    const expectedOutput = `A\\n1\\n2\\n3\\n`; // Single-column CSV should remain unchanged\n    expect(output).toEqual(expectedOutput);\n  });\n});", "prompt": "please write a typescript function , the function signature as below import * as fs from 'fs';\nimport * as csvParser from 'csv-parser';\nimport * as csvWriter from 'csv-writer';\nimport { parse } from 'path';\n\n/**\n * Processes a CSV file and removes rows with two or more empty columns.\n * If the file is empty, returns an empty string.\n *\n * @param file_path - The path to the input CSV file.\n * @param output_path - The path where the processed CSV file will be saved.\n */\nfunction processCsv(file_path: string, output_path: string): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Processes a CSV file and removes rows with two or more empty columns. If the file is empty, returns an empty string.\n *\n * @param file_path The path to the input CSV file.\n * @param output_path The path where the processed CSV file will be saved.\n */\nvoid process_csv(const std::string& file_path, const std::string& output_path){}", "test_code": "TEST_CASE(\"TestProcessCSV\", \"[process_csv]\") {\n    SECTION(\"Test Case 1\") {\n        const std::string input_data_1 = R\"(\nA,B,C\n1,2,3\n4,,6\n7,8,\n9,10,11\n)\";\n\n        const std::string input_file_path = \"input.csv\";\n        const std::string output_file_path = \"output.csv\";\n\n        // Write input data to a temp CSV file\n        std::ofstream input_file(input_file_path);\n        input_file << input_data_1;\n        input_file.close();\n\n        // Process the CSV\n        process_csv(input_file_path, output_file_path);\n\n        // Read the output\n        std::ifstream output_file(output_file_path);\n        std::stringstream output_stream;\n        output_stream << output_file.rdbuf();\n        std::string output_data = output_stream.str();\n        output_file.close();\n\n        // Clean up temp files\n        fs::remove(input_file_path);\n        fs::remove(output_file_path);\n\n        const std::string expected_output = R\"(\nA,B,C\n1,2.0,3.0\n4,,6.0\n7,8.0,\n9,10.0,11.0\n)\";\n\n        REQUIRE(output_data == expected_output);\n    }\n\n    SECTION(\"Test Case 2\") {\n        const std::string input_data_2 = R\"(\nA,B,C,D\n,,\n1,,3,4\n2,3,,5\n,,,\n)\";\n\n        const std::string input_file_path = \"input.csv\";\n        const std::string output_file_path = \"output.csv\";\n\n        // Write input data to a temp CSV file\n        std::ofstream input_file(input_file_path);\n        input_file << input_data_2;\n        input_file.close();\n\n        // Process the CSV\n        process_csv(input_file_path, output_file_path);\n\n        // Read the output\n        std::ifstream output_file(output_file_path);\n        std::stringstream output_stream;\n        output_stream << output_file.rdbuf();\n        std::string output_data = output_stream.str();\n        output_file.close();\n\n        // Clean up temp files\n        fs::remove(input_file_path);\n        fs::remove(output_file_path);\n\n        const std::string expected_output = R\"(\nA,B,C,D\n1.0,,3.0,4.0\n2.0,3.0,,5.0\n)\";\n\n        REQUIRE(output_data == expected_output);\n    }\n\n    SECTION(\"Test Case 3\") {\n        const std::string input_data_3 = R\"(\nA\n1\n2\n3\n)\";\n\n        const std::string input_file_path = \"input.csv\";\n        const std::string output_file_path = \"output.csv\";\n\n        // Write input data to a temp CSV file\n        std::ofstream input_file(input_file_path);\n        input_file << input_data_3;\n        input_file.close();\n\n        // Process the CSV\n        process_csv(input_file_path, output_file_path);\n\n        // Read the output\n        std::ifstream output_file(output_file_path);\n        std::stringstream output_stream;\n        output_stream << output_file.rdbuf();\n        std::string output_data = output_stream.str();\n        output_file.close();\n\n        // Clean up temp files\n        fs::remove(input_file_path);\n        fs::remove(output_file_path);\n\n        const std::string expected_output = R\"(\nA\n1\n2\n3\n)\";\n\n        REQUIRE(output_data == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Processes a CSV file and removes rows with two or more empty columns. If the file is empty, returns an empty string.\n *\n * @param file_path The path to the input CSV file.\n * @param output_path The path where the processed CSV file will be saved.\n */\nvoid process_csv(const std::string& file_path, const std::string& output_path){}", "addition_info": ""}, "java": {"code_signature": "/**\n * Processes a CSV file and removes rows with two or more empty columns.\n * If the file is empty, returns an empty string.\n *\n * @param filePath The path to the input CSV file.\n * @param outputPath The path where the processed CSV file will be saved.\n */\npublic static void processCsv(String filePath, String outputPath) {}", "test_code": "package org.real.temp;\n\nimport org.apache.commons.csv.CSVFormat;\nimport org.apache.commons.csv.CSVParser;\nimport org.apache.commons.csv.CSVPrinter;\nimport org.apache.commons.csv.CSVRecord;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport static org.real.temp.Answer.*;\n/**\n * Test class for the processCsv function.\n */\npublic class Tester {\n\n    private String input_data_1 = \"A,B,C\\n1,2,3\\n4,,6\\n7,8,\\n9,10,11\";\n    private String input_data_2 = \"A,B,C,D\\n,,\\n1,,3,4\\n2,3,,5\\n,,,\\n\";\n    private String input_data_3 = \"A\\n1\\n2\\n3\";\n\n    private String inputFilePath = \"input.csv\";\n    private String outputFilePath = \"output.csv\";\n\n    @Before\n    public void setUp() throws IOException {\n        // Write input data to a temporary CSV file\n        Files.write(Paths.get(inputFilePath), input_data_1.getBytes());\n    }\n\n    @After\n    public void tearDown() throws IOException {\n        // Clean up temp files\n        Files.deleteIfExists(Paths.get(inputFilePath));\n        Files.deleteIfExists(Paths.get(outputFilePath));\n    }\n\n    private String processData(String input_data) throws IOException {\n        // Write input data to a temp CSV file\n        Files.write(Paths.get(inputFilePath), input_data.getBytes());\n\n        // Process the CSV\n        processCsv(inputFilePath, outputFilePath);\n\n        // Read the output\n        String output_data = new String(Files.readAllBytes(Paths.get(outputFilePath)));\n\n        // Clean up temp files\n        Files.deleteIfExists(Paths.get(inputFilePath));\n        Files.deleteIfExists(Paths.get(outputFilePath));\n\n        return output_data;\n    }\n\n    @Test\n    public void testCase1() throws IOException {\n        String output = processData(input_data_1);\n        String expectedOutput = \"A,B,C\\n1,2.0,3.0\\n4,,6.0\\n7,8.0,\\n9,10.0,11.0\\n\";\n        assertEquals(expectedOutput, output);\n    }\n\n    @Test\n    public void testCase2() throws IOException {\n        String output = processData(input_data_2);\n        String expectedOutput = \"A,B,C,D\\n1.0,,3.0,4.0\\n2.0,3.0,,5.0\\n\";\n        assertEquals(expectedOutput, output);\n    }\n\n    @Test\n    public void testCase3() throws IOException {\n        String output = processData(input_data_3);\n        String expectedOutput = \"A\\n1\\n2\\n3\\n\";  // Single-column CSV should remain unchanged\n        assertEquals(expectedOutput, output);\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Processes a CSV file and removes rows with two or more empty columns.\n * If the file is empty, returns an empty string.\n *\n * @param filePath The path to the input CSV file.\n * @param outputPath The path where the processed CSV file will be saved.\n */\npublic static void processCsv(String filePath, String outputPath) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 262, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. ", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef average_of_levels(root: TreeNode) -> List[float]:\n    \"\"\"\n    Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.\n\n    Args:\n        root (TreeNode): The root of the binary tree.\n\n    Returns:\n        List[float]: A list containing the average values of each level.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass TestAverageOfLevels(unittest.TestCase):\n\n    def test_empty_tree(self):\n        root = None\n        expected = []\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_single_node_tree(self):\n        root = TreeNode(5)\n        expected = [5.0]\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_balanced_tree_two_levels(self):\n        root = TreeNode(3)\n        root.left = TreeNode(9)\n        root.right = TreeNode(20)\n        expected = [3.0, 14.5]  # Level 0: 3; Level 1: (9+20)/2 = 14.5\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_unbalanced_tree(self):\n        root = TreeNode(1)\n        root.right = TreeNode(2)\n        root.right.right = TreeNode(3)\n        expected = [1.0, 2.0, 3.0]  # Level 0: 1; Level 1: 2; Level 2: 3\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_tree_multiple_levels(self):\n        root = TreeNode(1)\n        root.left = TreeNode(2)\n        root.right = TreeNode(3)\n        root.left.left = TreeNode(4)\n        root.left.right = TreeNode(5)\n        root.right.right = TreeNode(8)\n        expected = [1.0, 2.5, 5.67]  # Level 0: 1; Level 1: (2+3)/2 = 2.5; Level 2: (4+5+8)/3 \u2248 5.67\n        self.assertAlmostEqual(average_of_levels(root)[2], expected[2], places=2)\n        self.assertEqual(average_of_levels(root)[:2], expected[:2])", "prompt": "please write a python function , the function signature as below from typing import List\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef average_of_levels(root: TreeNode) -> List[float]:\n    \"\"\"\n    Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.\n\n    Args:\n        root (TreeNode): The root of the binary tree.\n\n    Returns:\n        List[float]: A list containing the average values of each level.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "class TreeNode {\n  /**\n   * Constructs a new TreeNode instance.\n   * \n   * @param {number} val - The value of the node.\n   * @param {TreeNode} [left=null] - The left child of the node.\n   * @param {TreeNode} [right=null] - The right child of the node.\n   */\n  constructor(val = 0, left = null, right = null) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n  }\n}\n\n/**\n* Calculates the average value of the nodes on each level of a binary tree.\n* \n* @param {TreeNode} root - The root of the binary tree.\n* @returns {number[]} An array containing the average values of each level.\n*/\nfunction averageOfLevels(root) {}", "test_code": "class TreeNode {\n  /**\n   * Constructs a new TreeNode instance.\n   * \n   * @param {number} val - The value of the node.\n   * @param {TreeNode} [left=null] - The left child of the node.\n   * @param {TreeNode} [right=null] - The right child of the node.\n   */\n  constructor(val = 0, left = null, right = null) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n  }\n}\n\ndescribe('TestAverageOfLevels', () => {\n  it('should handle an empty tree', () => {\n      const root = null;\n      const expected = [];\n      expect(averageOfLevels(root)).toEqual(expected);\n  });\n\n  it('should handle a single node tree', () => {\n      const root = new TreeNode(5);\n      const expected = [5.0];\n      expect(averageOfLevels(root)).toEqual(expected);\n  });\n\n  it('should handle a balanced tree with two levels', () => {\n      const root = new TreeNode(3);\n      root.left = new TreeNode(9);\n      root.right = new TreeNode(20);\n      const expected = [3.0, 14.5];  // Level 0: 3; Level 1: (9+20)/2 = 14.5\n      expect(averageOfLevels(root)).toEqual(expected);\n  });\n\n  it('should handle an unbalanced tree', () => {\n      const root = new TreeNode(1);\n      root.right = new TreeNode(2);\n      root.right.right = new TreeNode(3);\n      const expected = [1.0, 2.0, 3.0];  // Level 0: 1; Level 1: 2; Level 2: 3\n      expect(averageOfLevels(root)).toEqual(expected);\n  });\n\n  it('should handle a tree with multiple levels', () => {\n      const root = new TreeNode(1);\n      root.left = new TreeNode(2);\n      root.right = new TreeNode(3);\n      root.left.left = new TreeNode(4);\n      root.left.right = new TreeNode(5);\n      root.right.right = new TreeNode(8);\n      const expected = [1.0, 2.5, 5.67];  // Level 0: 1; Level 1: (2+3)/2 = 2.5; Level 2: (4+5+8)/3 \u2248 5.67\n      expect(averageOfLevels(root)[2]).toBeCloseTo(expected[2], 2);\n      expect(averageOfLevels(root).slice(0, 2)).toEqual(expected.slice(0, 2));\n  });\n});", "prompt": "please write a javascript function , the function signature as below class TreeNode {\n  /**\n   * Constructs a new TreeNode instance.\n   * \n   * @param {number} val - The value of the node.\n   * @param {TreeNode} [left=null] - The left child of the node.\n   * @param {TreeNode} [right=null] - The right child of the node.\n   */\n  constructor(val = 0, left = null, right = null) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n  }\n}\n\n/**\n* Calculates the average value of the nodes on each level of a binary tree.\n* \n* @param {TreeNode} root - The root of the binary tree.\n* @returns {number[]} An array containing the average values of each level.\n*/\nfunction averageOfLevels(root) {}", "addition_info": ""}, "typescript": {"code_signature": "class TreeNode {\n    val: number;\n    left: TreeNode | null;\n    right: TreeNode | null;\n\n    constructor(val: number = 0, left: TreeNode | null = null, right: TreeNode | null = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\n/**\n * Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.\n *\n * @param root - The root of the binary tree.\n * @returns An array containing the average values of each level.\n */\nfunction averageOfLevels(root: TreeNode | null): number[] {}", "test_code": "class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n\n  constructor(val: number = 0, left: TreeNode | null = null, right: TreeNode | null = null) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n  }\n}\ndescribe('averageOfLevels', () => {\n  it('should handle an empty tree', () => {\n      const root = null;\n      const expected = [];\n      expect(averageOfLevels(root)).toEqual(expected);\n  });\n\n  it('should handle a single-node tree', () => {\n      const root = new TreeNode(5);\n      const expected = [5.0];\n      expect(averageOfLevels(root)).toEqual(expected);\n  });\n\n  it('should handle a balanced tree with two levels', () => {\n      const root = new TreeNode(3);\n      root.left = new TreeNode(9);\n      root.right = new TreeNode(20);\n      const expected = [3.0, 14.5];  // Level 0: 3; Level 1: (9+20)/2 = 14.5\n      expect(averageOfLevels(root)).toEqual(expected);\n  });\n\n  it('should handle an unbalanced tree', () => {\n      const root = new TreeNode(1);\n      root.right = new TreeNode(2);\n      root.right.right = new TreeNode(3);\n      const expected = [1.0, 2.0, 3.0];  // Level 0: 1; Level 1: 2; Level 2: 3\n      expect(averageOfLevels(root)).toEqual(expected);\n  });\n\n  it('should handle a tree with multiple levels', () => {\n      const root = new TreeNode(1);\n      root.left = new TreeNode(2);\n      root.right = new TreeNode(3);\n      root.left.left = new TreeNode(4);\n      root.left.right = new TreeNode(5);\n      root.right.right = new TreeNode(8);\n      const expected = [1.0, 2.5, 5.67];  // Level 0: 1; Level 1: (2+3)/2 = 2.5; Level 2: (4+5+8)/3 \u2248 5.67\n      expect(averageOfLevels(root)[2]).toBeCloseTo(expected[2], 2);\n      expect(averageOfLevels(root).slice(0, 2)).toEqual(expected.slice(0, 2));\n  });\n});\n\n", "prompt": "please write a typescript function , the function signature as below class TreeNode {\n    val: number;\n    left: TreeNode | null;\n    right: TreeNode | null;\n\n    constructor(val: number = 0, left: TreeNode | null = null, right: TreeNode | null = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\n/**\n * Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.\n *\n * @param root - The root of the binary tree.\n * @returns An array containing the average values of each level.\n */\nfunction averageOfLevels(root: TreeNode | null): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\n/**\n * Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.\n *\n * @param root Pointer to the root of the binary tree.\n * @return A vector containing the average values of each level.\n */\nstd::vector<double> average_of_levels(TreeNode* root) {\n\n}", "test_code": "TEST_CASE(\"Test average_of_levels\") {\n    SECTION(\"Empty Tree\") {\n        TreeNode* root = nullptr;\n        std::vector<double> expected = {};\n        REQUIRE(average_of_levels(root) == expected);\n    }\n\n    SECTION(\"Single Node Tree\") {\n        TreeNode* root = new TreeNode(5);\n        std::vector<double> expected = {5.0};\n        REQUIRE(average_of_levels(root) == expected);\n        delete root;\n    }\n\n    SECTION(\"Balanced Tree Two Levels\") {\n        TreeNode* root = new TreeNode(3);\n        root->left = new TreeNode(9);\n        root->right = new TreeNode(20);\n        std::vector<double> expected = {3.0, 14.5};\n        REQUIRE(average_of_levels(root) == expected);\n        delete root->left;\n        delete root->right;\n        delete root;\n    }\n\n    SECTION(\"Unbalanced Tree\") {\n        TreeNode* root = new TreeNode(1);\n        root->right = new TreeNode(2);\n        root->right->right = new TreeNode(3);\n        std::vector<double> expected = {1.0, 2.0, 3.0};\n        REQUIRE(average_of_levels(root) == expected);\n        delete root->right->right;\n        delete root->right;\n        delete root;\n    }\n\n    SECTION(\"Tree Multiple Levels\") {\n        TreeNode* root = new TreeNode(1);\n        root->left = new TreeNode(2);\n        root->right = new TreeNode(3);\n        root->left->left = new TreeNode(4);\n        root->left->right = new TreeNode(5);\n        root->right->right = new TreeNode(8);\n        std::vector<double> expected = {1.0, 2.5, 5.67};\n        auto result = average_of_levels(root);\n        REQUIRE(result.size() == expected.size());\n        REQUIRE_THAT(result[0], Catch::Matchers::WithinAbs(expected[0], 0.01));\n        REQUIRE_THAT(result[1], Catch::Matchers::WithinAbs(expected[1], 0.01));\n        REQUIRE_THAT(result[2], Catch::Matchers::WithinAbs(expected[2], 0.01));\n        delete root->left->left;\n        delete root->left->right;\n        delete root->right->right;\n        delete root->left;\n        delete root->right;\n        delete root;\n    }\n}", "prompt": "please write a cpp function , the function signature as below \nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\n/**\n * Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.\n *\n * @param root Pointer to the root of the binary tree.\n * @return A vector containing the average values of each level.\n */\nstd::vector<double> average_of_levels(TreeNode* root) {\n\n}", "addition_info": "\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n"}, "java": {"code_signature": "\n/**\n * Represents a node in a binary tree.\n */\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int val) {\n        this.val = val;\n    }\n\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n/**\n * Calculates the average value of nodes at each level in a binary tree.\n *\n * @param root The root of the binary tree.\n * @return A list containing the average values of each level.\n */\npublic static List<Double> averageOfLevels(TreeNode root) {\n\n}", "test_code": "package org.real.temp;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.real.temp.Answer.*;\n/**\n * Test cases for the averageOfLevels method.\n */\npublic class Tester {\n\n    private static final double DELTA = 0.01;\n\n\n    @Test\n    public void testEmptyTree() {\n        TreeNode root = null;\n        List<Double> expected = Arrays.asList();\n        assertEquals(expected, averageOfLevels(root));\n    }\n\n    @Test\n    public void testSingleNodeTree() {\n        TreeNode root = new TreeNode(5);\n        List<Double> expected = Arrays.asList(5.0);\n        assertEquals(expected, averageOfLevels(root));\n    }\n\n    @Test\n    public void testBalancedTreeTwoLevels() {\n        TreeNode root = new TreeNode(3);\n        root.left = new TreeNode(9);\n        root.right = new TreeNode(20);\n        List<Double> expected = Arrays.asList(3.0, 14.5);\n        assertEquals(expected, averageOfLevels(root));\n    }\n\n    @Test\n    public void testUnbalancedTree() {\n        TreeNode root = new TreeNode(1);\n        root.right = new TreeNode(2);\n        root.right.right = new TreeNode(3);\n        List<Double> expected = Arrays.asList(1.0, 2.0, 3.0);\n        assertEquals(expected, averageOfLevels(root));\n    }\n\n    @Test\n    public void testTreeMultipleLevels() {\n        TreeNode root = new TreeNode(1);\n        root.left = new TreeNode(2);\n        root.right = new TreeNode(3);\n        root.left.left = new TreeNode(4);\n        root.left.right = new TreeNode(5);\n        root.right.right = new TreeNode(8);\n        List<Double> expected = Arrays.asList(1.0, 2.5, 5.67);\n        List<Double> result = averageOfLevels(root);\n        assertEquals(expected.subList(0, 2), result.subList(0, 2));\n        assertTrue(Math.abs(result.get(2) - expected.get(2)) <= DELTA);\n    }\n}", "prompt": "please write a java function , the function signature as below \n/**\n * Represents a node in a binary tree.\n */\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int val) {\n        this.val = val;\n    }\n\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n/**\n * Calculates the average value of nodes at each level in a binary tree.\n *\n * @param root The root of the binary tree.\n * @return A list containing the average values of each level.\n */\npublic static List<Double> averageOfLevels(TreeNode root) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 263, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Please write a function that traverses a two-dimensional matrix in spiral order and returns a list of the elements of the traversal result", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\nclass MatrixTraversal:\n    def spiral_traversal(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Traverse a given m x n matrix in a spiral order and return all elements as a list.\n\n        The function starts at the top-left corner of the matrix and traverses it in a\n        clockwise spiral order, moving right across the top row, down the right column,\n        left across the bottom row, and up the left column, repeating this process\n        until all elements are traversed.\n\n        Args:\n            matrix (List[List[int]]): A 2D list representing the matrix with m rows and n columns.\n\n        Returns:\n            List[int]: A list of integers representing the elements of the matrix\n            in the order they were traversed.\n        \"\"\"", "test_code": "import unittest\n\nclass TestMatrixTraversal(unittest.TestCase):\n    def setUp(self):\n        self.mt = MatrixTraversal()\n\n    def test_empty_matrix(self):\n        # \u5f02\u5e38\u503c\u6d4b\u8bd5\uff1a\u7a7a\u77e9\u9635\n        self.assertEqual(self.mt.spiral_traversal([]), [], \"Should return an empty list for an empty matrix\")\n\n    def test_single_element_matrix(self):\n        # \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u5355\u5143\u7d20\u77e9\u9635\n        matrix = [[42]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [42], \"Should return the single element in the matrix\")\n\n    def test_single_row_matrix(self):\n        # \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u884c\u77e9\u9635\n        matrix = [[1, 2, 3, 4, 5]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [1, 2, 3, 4, 5], \"Should return all elements in a single row\")\n\n    def test_single_column_matrix(self):\n        # \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u5217\u77e9\u9635\n        matrix = [[1], [2], [3], [4], [5]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [1, 2, 3, 4, 5], \"Should return all elements in a single column\")\n\n    def test_general_case(self):\n        # \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u591a\u884c\u591a\u5217\u77e9\u9635\n        matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [1, 2, 3, 6, 9, 8, 7, 4, 5], \"Should return elements in spiral order for a general case matrix\")\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\nclass MatrixTraversal:\n    def spiral_traversal(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Traverse a given m x n matrix in a spiral order and return all elements as a list.\n\n        The function starts at the top-left corner of the matrix and traverses it in a\n        clockwise spiral order, moving right across the top row, down the right column,\n        left across the bottom row, and up the left column, repeating this process\n        until all elements are traversed.\n\n        Args:\n            matrix (List[List[int]]): A 2D list representing the matrix with m rows and n columns.\n\n        Returns:\n            List[int]: A list of integers representing the elements of the matrix\n            in the order they were traversed.\n        \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Traverse a given m x n matrix in a spiral order and return all elements as an array.\n *\n * The function starts at the top-left corner of the matrix and traverses it in a\n * clockwise spiral order, moving right across the top row, down the right column,\n * left across the bottom row, and up the left column, repeating this process\n * until all elements are traversed.\n *\n * @param {number[][]} matrix - A 2D array representing the matrix with m rows and n columns.\n * @returns {number[]} An array of numbers representing the elements of the matrix\n *                     in the order they were traversed.\n */\nfunction spiral_traversal(matrix) {}", "test_code": "describe('MatrixTraversal', () => {\n\n  it('should handle an empty matrix', () => {\n      // \u5f02\u5e38\u503c\u6d4b\u8bd5\uff1a\u7a7a\u77e9\u9635\n      expect(spiral_traversal([])).toEqual([], 'Should return an empty list for an empty matrix');\n  });\n\n  it('should handle a single element matrix', () => {\n      // \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u5355\u5143\u7d20\u77e9\u9635\n      const matrix = [[42]];\n      expect(spiral_traversal(matrix)).toEqual([42], 'Should return the single element in the matrix');\n  });\n\n  it('should handle a single row matrix', () => {\n      // \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u884c\u77e9\u9635\n      const matrix = [[1, 2, 3, 4, 5]];\n      expect(spiral_traversal(matrix)).toEqual([1, 2, 3, 4, 5], 'Should return all elements in a single row');\n  });\n\n  it('should handle a single column matrix', () => {\n      // \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u5217\u77e9\u9635\n      const matrix = [[1], [2], [3], [4], [5]];\n      expect(spiral_traversal(matrix)).toEqual([1, 2, 3, 4, 5], 'Should return all elements in a single column');\n  });\n\n  it('should handle a general case matrix', () => {\n      // \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u591a\u884c\u591a\u5217\u77e9\u9635\n      const matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n      expect(spiral_traversal(matrix)).toEqual([1, 2, 3, 6, 9, 8, 7, 4, 5], 'Should return elements in spiral order for a general case matrix');\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Traverse a given m x n matrix in a spiral order and return all elements as an array.\n *\n * The function starts at the top-left corner of the matrix and traverses it in a\n * clockwise spiral order, moving right across the top row, down the right column,\n * left across the bottom row, and up the left column, repeating this process\n * until all elements are traversed.\n *\n * @param {number[][]} matrix - A 2D array representing the matrix with m rows and n columns.\n * @returns {number[]} An array of numbers representing the elements of the matrix\n *                     in the order they were traversed.\n */\nfunction spiral_traversal(matrix) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Traverse a given m x n matrix in a spiral order and return all elements as an array.\n *\n * The function starts at the top-left corner of the matrix and traverses it in a\n * clockwise spiral order, moving right across the top row, down the right column,\n * left across the bottom row, and up the left column, repeating this process\n * until all elements are traversed.\n *\n * @param matrix - A 2D array representing the matrix with m rows and n columns.\n * @returns An array of numbers representing the elements of the matrix\n *          in the order they were traversed.\n */\nfunction spiralTraversal(matrix: number[][]): number[] {}", "test_code": "describe('MatrixTraversal', () => {\n  \n  \n    it('should return an empty list for an empty matrix', () => {\n      // \u5f02\u5e38\u503c\u6d4b\u8bd5\uff1a\u7a7a\u77e9\u9635\n      expect(spiralTraversal([])).toEqual([], 'Should return an empty list for an empty matrix');\n    });\n  \n    it('should return the single element in the matrix', () => {\n      // \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u5355\u5143\u7d20\u77e9\u9635\n      const matrix = [[42]];\n      expect(spiralTraversal(matrix)).toEqual([42], 'Should return the single element in the matrix');\n    });\n  \n    it('should return all elements in a single row', () => {\n      // \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u884c\u77e9\u9635\n      const matrix = [[1, 2, 3, 4, 5]];\n      expect(spiralTraversal(matrix)).toEqual([1, 2, 3, 4, 5], 'Should return all elements in a single row');\n    });\n  \n    it('should return all elements in a single column', () => {\n      // \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u5217\u77e9\u9635\n      const matrix = [[1], [2], [3], [4], [5]];\n      expect(spiralTraversal(matrix)).toEqual([1, 2, 3, 4, 5], 'Should return all elements in a single column');\n    });\n  \n    it('should return elements in spiral order for a general case matrix', () => {\n      // \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u591a\u884c\u591a\u5217\u77e9\u9635\n      const matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n      expect(spiralTraversal(matrix)).toEqual([1, 2, 3, 6, 9, 8, 7, 4, 5], 'Should return elements in spiral order for a general case matrix');\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Traverse a given m x n matrix in a spiral order and return all elements as an array.\n *\n * The function starts at the top-left corner of the matrix and traverses it in a\n * clockwise spiral order, moving right across the top row, down the right column,\n * left across the bottom row, and up the left column, repeating this process\n * until all elements are traversed.\n *\n * @param matrix - A 2D array representing the matrix with m rows and n columns.\n * @returns An array of numbers representing the elements of the matrix\n *          in the order they were traversed.\n */\nfunction spiralTraversal(matrix: number[][]): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Traverse a given m x n matrix in a spiral order and return all elements as a vector.\n *\n *\n * @param matrix A 2D vector representing the matrix with m rows and n columns.\n * @return A vector of integers representing the elements of the matrix\n *         in the order they were traversed.\n */\nvector<int> spiral_traverse(const vector<vector<int>>& matrix) {}", "test_code": "TEST_CASE(\"TestMatrixTraversal\", \"[MatrixTraversal]\") {\n    MatrixTraversal mt;\n\n    SECTION(\"Empty matrix\") {\n        // \u5f02\u5e38\u503c\u6d4b\u8bd5\uff1a\u7a7a\u77e9\u9635\n        REQUIRE(spiral_traversal({}) == std::vector<int>{});\n    }\n\n    SECTION(\"Single element matrix\") {\n        // \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u5355\u5143\u7d20\u77e9\u9635\n        std::vector<std::vector<int>> matrix = {{42}};\n        REQUIRE(spiral_traversal(matrix) == std::vector<int>{42});\n    }\n\n    SECTION(\"Single row matrix\") {\n        // \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u884c\u77e9\u9635\n        std::vector<std::vector<int>> matrix = {{1, 2, 3, 4, 5}};\n        REQUIRE(spiral_traversal(matrix) == std::vector<int>{1, 2, 3, 4, 5});\n    }\n\n    SECTION(\"Single column matrix\") {\n        // \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u5217\u77e9\u9635\n        std::vector<std::vector<int>> matrix = {{1}, {2}, {3}, {4}, {5}};\n        REQUIRE(spiral_traversal(matrix) == std::vector<int>{1, 2, 3, 4, 5});\n    }\n\n    SECTION(\"General case\") {\n        // \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u591a\u884c\u591a\u5217\u77e9\u9635\n        std::vector<std::vector<int>> matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        REQUIRE(spiral_traversal(matrix) == std::vector<int>{1, 2, 3, 6, 9, 8, 7, 4, 5});\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Traverse a given m x n matrix in a spiral order and return all elements as a vector.\n *\n *\n * @param matrix A 2D vector representing the matrix with m rows and n columns.\n * @return A vector of integers representing the elements of the matrix\n *         in the order they were traversed.\n */\nvector<int> spiral_traverse(const vector<vector<int>>& matrix) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Traverses a given m x n matrix in a spiral order and returns all elements as a list.\n *\n * The method starts at the top-left corner of the matrix and traverses it in a\n * clockwise spiral order, moving right across the top row, down the right column,\n * left across the bottom row, and up the left column, repeating this process\n * until all elements are traversed.\n *\n * @param matrix A 2D array representing the matrix with m rows and n columns.\n * @return A list of integers representing the elements of the matrix\n *         in the order they were traversed.\n */\npublic List<Integer> spiralTraversal(int[][] matrix) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\n/**\n * Test class for MatrixTraversal using JUnit.\n */\npublic class Tester {\n    \n\n    @Test\n    public void testEmptyMatrix() {\n        // \u5f02\u5e38\u503c\u6d4b\u8bd5\uff1a\u7a7a\u77e9\u9635\n        assertEquals(\"Should return an empty list for an empty matrix\", \n                     new ArrayList<>(),\n                     spiralTraversal(new int[0][]));\n    }\n\n    @Test\n    public void testSingleElementMatrix() {\n        // \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u5355\u5143\u7d20\u77e9\u9635\n        int[][] matrix = {{42}};\n        assertEquals(\"Should return the single element in the matrix\", \n                     new ArrayList<>(List.of(42)), \n                     spiralTraversal(matrix));\n    }\n\n    @Test\n    public void testSingleRowMatrix() {\n        // \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u884c\u77e9\u9635\n        int[][] matrix = {{1, 2, 3, 4, 5}};\n        assertEquals(\"Should return all elements in a single row\", \n                     new ArrayList<>(List.of(1, 2, 3, 4, 5)),\n                     spiralTraversal(matrix));\n    }\n\n    @Test\n    public void testSingleColumnMatrix() {\n        // \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u5217\u77e9\u9635\n        int[][] matrix = {{1}, {2}, {3}, {4}, {5}};\n        assertEquals(\"Should return all elements in a single column\", \n                     new ArrayList<>(List.of(1, 2, 3, 4, 5)), \n                     spiralTraversal(matrix));\n    }\n\n    @Test\n    public void testGeneralCase() {\n        // \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u591a\u884c\u591a\u5217\u77e9\u9635\n        int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        assertEquals(\"Should return elements in spiral order for a general case matrix\", \n                     new ArrayList<>(List.of(1, 2, 3, 6, 9, 8, 7, 4, 5)), \n                     spiralTraversal(matrix));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Traverses a given m x n matrix in a spiral order and returns all elements as a list.\n *\n * The method starts at the top-left corner of the matrix and traverses it in a\n * clockwise spiral order, moving right across the top row, down the right column,\n * left across the bottom row, and up the left column, repeating this process\n * until all elements are traversed.\n *\n * @param matrix A 2D array representing the matrix with m rows and n columns.\n * @return A list of integers representing the elements of the matrix\n *         in the order they were traversed.\n */\npublic List<Integer> spiralTraversal(int[][] matrix) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 264, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "extract log entries at the WARNING, ERROR, CRITICAL, and ALERT levels from a log file and save the log entries at each level to a different file\n", "language_version_list": {"python": {"code_signature": "def extract_log_entries(log_file_path:str):\n    \"\"\"\n    Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n    and save each type of log entry to a different file.\n\n    Args:\n        log_file_path: Path to the log file.\n\n    Returns:\n\n    \"\"\"\n\n\n    \"\"\"\n    Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n    and save each type of log entry to a different file.\n\n    Args:\n    log_file_path (str): Path to the log file.\n    \"\"\"", "test_code": "import unittest\nimport os\n\n\nclass TestExtractLogEntries(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Setup a temporary log file with sample question for testing.\"\"\"\n        self.log_file_path = 'test_log.log'\n        self.log_contents = [\n            \"INFO: This is an informational message.\\n\",\n            \"WARNING: This is a warning message.\\n\",\n            \"ERROR: This is an error message.\\n\",\n            \"CRITICAL: This is a critical message.\\n\",\n            \"ALERT: This is an alert message.\\n\"\n        ]\n        with open(self.log_file_path, 'w') as log_file:\n            log_file.writelines(self.log_contents)\n\n\n\n    def test_no_logs_of_certain_levels(self):\n        \"\"\"Test the situation where there are no log entries for one or more levels.\"\"\"\n        with open(self.log_file_path, 'w') as log_file:\n            log_file.write(\"INFO: This is another informational message.\\n\")\n        extract_log_entries(self.log_file_path)\n        for level in ['WARNING', 'ERROR', 'CRITICAL', 'ALERT']:\n            with open(f\"{level.lower()}_logs.txt\", 'r') as file:\n                self.assertEqual('', file.read())\n\n    def test_file_not_found(self):\n        \"\"\"Test behavior when the log file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            extract_log_entries(\"nonexistent.log\")\n\n    def test_empty_log_file(self):\n        \"\"\"Test behavior with an empty log file.\"\"\"\n        with open(self.log_file_path, 'w') as log_file:\n            log_file.write(\"\")\n        extract_log_entries(self.log_file_path)\n        for level in ['WARNING', 'ERROR', 'CRITICAL', 'ALERT']:\n            with open(f\"{level.lower()}_logs.txt\", 'r') as file:\n                self.assertEqual('', file.read())\n\n    def test_mixed_content_log_file(self):\n        \"\"\"Test extracting logs from a file with mixed content.\"\"\"\n        with open(self.log_file_path, 'w') as log_file:\n            log_file.writelines([\n                \"INFO: Some info.\\n\",\n                \"WARNING: Watch out!\\n\",\n                \"DEBUG: Debugging.\\n\",\n                \"ERROR: Oops!\\n\",\n                \"CRITICAL: Failed badly.\\n\",\n                \"ALERT: High alert!\\n\",\n                \"INFO: More info.\\n\"\n            ])\n        extract_log_entries(self.log_file_path)\n        for level in ['WARNING', 'ERROR', 'CRITICAL', 'ALERT']:\n            with open(f\"{level.lower()}_logs.txt\", 'r') as file:\n                content = file.read().strip()\n                self.assertIn(level, content)\n", "prompt": "please write a python function , the function signature as below def extract_log_entries(log_file_path:str):\n    \"\"\"\n    Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n    and save each type of log entry to a different file.\n\n    Args:\n        log_file_path: Path to the log file.\n\n    Returns:\n\n    \"\"\"\n\n\n    \"\"\"\n    Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n    and save each type of log entry to a different file.\n\n    Args:\n    log_file_path (str): Path to the log file.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n * and save each type of log entry to a different file.\n *\n * @param {string} logFilePath - Path to the log file.\n */\nfunction extractLogEntries(logFilePath) {}", "test_code": "const fs = require('fs');\n\ndescribe('TestExtractLogEntries', () => {\n    let logFile;\n\n    beforeAll(() => {\n        logFile = 'test_log.log';\n    });\n\n    beforeEach(() => {\n        // Setup a temporary log file with sample content for testing\n        const logContents = [\n            \"INFO: This is an informational message.\\n\",\n            \"WARNING: This is a warning message.\\n\",\n            \"ERROR: This is an error message.\\n\",\n            \"CRITICAL: This is a critical message.\\n\",\n            \"ALERT: This is an alert message.\\n\"\n        ];\n        fs.writeFileSync(logFile, logContents.join(''));\n    });\n\n    afterEach(() => {\n        // Clean up after each test\n        fs.unlinkSync(logFile);\n        ['warning_logs.txt', 'error_logs.txt', 'critical_logs.txt', 'alert_logs.txt'].forEach(file => {\n            if (fs.existsSync(file)) {\n                fs.unlinkSync(file);\n            }\n        });\n    });\n\n    it('should handle no logs of certain levels', () => {\n        fs.writeFileSync(logFile, \"INFO: This is another informational message.\\n\");\n        extractLogEntries(logFile);\n        ['WARNING', 'ERROR', 'CRITICAL', 'ALERT'].forEach(level => {\n            const filePath = `${level.toLowerCase()}_logs.txt`;\n            expect(fs.readFileSync(filePath, 'utf8')).toBe('');\n        });\n    });\n\n    it('should throw an error when the log file does not exist', () => {\n        expect(() => {\n            extractLogEntries('nonexistent.log');\n        }).toThrow(/No log file found at the specified path/);\n    });\n\n    it('should handle an empty log file', () => {\n        fs.writeFileSync(logFile, '');\n        extractLogEntries(logFile);\n        ['WARNING', 'ERROR', 'CRITICAL', 'ALERT'].forEach(level => {\n            const filePath = `${level.toLowerCase()}_logs.txt`;\n            expect(fs.readFileSync(filePath, 'utf8')).toBe('');\n        });\n    });\n\n    it('should extract logs from a file with mixed content', () => {\n        fs.writeFileSync(logFile, [\n            \"INFO: Some info.\\n\",\n            \"WARNING: Watch out!\\n\",\n            \"DEBUG: Debugging.\\n\",\n            \"ERROR: Oops!\\n\",\n            \"CRITICAL: Failed badly.\\n\",\n            \"ALERT: High alert!\\n\",\n            \"INFO: More info.\\n\"\n        ].join(''));\n        extractLogEntries(logFile);\n        ['WARNING', 'ERROR', 'CRITICAL', 'ALERT'].forEach(level => {\n            const filePath = `${level.toLowerCase()}_logs.txt`;\n            const content = fs.readFileSync(filePath, 'utf8').trim();\n            expect(content).toContain(level);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n * and save each type of log entry to a different file.\n *\n * @param {string} logFilePath - Path to the log file.\n */\nfunction extractLogEntries(logFilePath) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as fs from 'fs';\n\n/**\n * Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n * and save each type of log entry to a different file.\n *\n * @param logFilePath - Path to the log file.\n */\nfunction extractLogEntries(logFilePath: string): void {}", "test_code": "describe('TestExtractLogEntries', () => {\n    beforeEach(() => {\n        // Setup a temporary log file with sample content for testing\n        const logFileContents = [\n            \"INFO: This is an informational message.\\n\",\n            \"WARNING: This is a warning message.\\n\",\n            \"ERROR: This is an error message.\\n\",\n            \"CRITICAL: This is a critical message.\\n\",\n            \"ALERT: This is an alert message.\\n\"\n        ];\n        const logFilePath = 'test_log.log';\n        fs.writeFileSync(logFilePath, logFileContents.join(''));\n    });\n\n    afterEach(() => {\n        // Clean up after each test\n        ['warning_logs.txt', 'error_logs.txt', 'critical_logs.txt', 'alert_logs.txt'].forEach(file => {\n            if (fs.existsSync(file)) {\n                fs.unlinkSync(file);\n            }\n        });\n        if (fs.existsSync('test_log.log')) {\n            fs.unlinkSync('test_log.log');\n        }\n    });\n\n    it('should handle no logs of certain levels', () => {\n        const logFilePath = 'test_log.log';\n        fs.writeFileSync(logFilePath, \"INFO: This is another informational message.\\n\");\n        extractLogEntries(logFilePath);\n\n        ['WARNING', 'ERROR', 'CRITICAL', 'ALERT'].forEach(level => {\n            const filePath = `${level.toLowerCase()}_logs.txt`;\n            expect(fs.existsSync(filePath)).toBe(true);\n            const content = fs.readFileSync(filePath, 'utf-8').trim();\n            expect(content).toBe('');\n        });\n    });\n\n    it('should throw an error when the log file does not exist', () => {\n        expect(() => {\n            extractLogEntries('nonexistent.log');\n        }).toThrow(/No log file found at the specified path: nonexistent\\.log/);\n    });\n\n    it('should handle an empty log file', () => {\n        const logFilePath = 'test_log.log';\n        fs.writeFileSync(logFilePath, \"\");\n        extractLogEntries(logFilePath);\n\n        ['WARNING', 'ERROR', 'CRITICAL', 'ALERT'].forEach(level => {\n            const filePath = `${level.toLowerCase()}_logs.txt`;\n            expect(fs.existsSync(filePath)).toBe(true);\n            const content = fs.readFileSync(filePath, 'utf-8').trim();\n            expect(content).toBe('');\n        });\n    });\n\n    it('should extract logs from a file with mixed content', () => {\n        const logFilePath = 'test_log.log';\n        fs.writeFileSync(logFilePath, [\n            \"INFO: Some info.\\n\",\n            \"WARNING: Watch out!\\n\",\n            \"DEBUG: Debugging.\\n\",\n            \"ERROR: Oops!\\n\",\n            \"CRITICAL: Failed badly.\\n\",\n            \"ALERT: High alert!\\n\",\n            \"INFO: More info.\\n\"\n        ].join(''));\n\n        extractLogEntries(logFilePath);\n\n        ['WARNING', 'ERROR', 'CRITICAL', 'ALERT'].forEach(level => {\n            const filePath = `${level.toLowerCase()}_logs.txt`;\n            expect(fs.existsSync(filePath)).toBe(true);\n            const content = fs.readFileSync(filePath, 'utf-8').trim();\n            expect(content).toContain(level);\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below import * as fs from 'fs';\n\n/**\n * Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n * and save each type of log entry to a different file.\n *\n * @param logFilePath - Path to the log file.\n */\nfunction extractLogEntries(logFilePath: string): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n * and save each type of log entry to a different file.\n *\n * @param logFilePath The path to the log file.\n */\nvoid extract_log_entries(const std::string& log_file_path) {}", "test_code": "TEST_CASE(\"TestExtractLogEntries\", \"[log]\") {\n    const std::string log_file_path = \"test_log.log\";\n\n    SECTION(\"setUp\") {\n        std::vector<std::string> log_contents = {\n            \"INFO: This is an informational message.\\n\",\n            \"WARNING: This is a warning message.\\n\",\n            \"ERROR: This is an error message.\\n\",\n            \"CRITICAL: This is a critical message.\\n\",\n            \"ALERT: This is an alert message.\\n\"\n        };\n        std::ofstream log_file(log_file_path);\n        if (!log_file.is_open()) {\n            FAIL(\"Failed to create the log file.\");\n        }\n        log_file << std::string(log_contents.begin(), log_contents.end());\n        log_file.close();\n    }\n\n    SECTION(\"test_no_logs_of_certain_levels\") {\n        std::ofstream log_file(log_file_path);\n        if (!log_file.is_open()) {\n            FAIL(\"Failed to create the log file.\");\n        }\n        log_file << \"INFO: This is another informational message.\\n\";\n        log_file.close();\n\n        extract_log_entries(log_file_path);\n\n        for (const auto& level : {\"WARNING\", \"ERROR\", \"CRITICAL\", \"ALERT\"}) {\n            std::ifstream outfile(level + \"_logs.txt\");\n            if (!outfile.is_open()) {\n                FAIL(\"Failed to open the output file: \" + level + \"_logs.txt\");\n            }\n            std::string content((std::istreambuf_iterator<char>(outfile)), std::istreambuf_iterator<char>());\n            REQUIRE(content.empty());\n        }\n    }\n\n    SECTION(\"test_file_not_found\") {\n        extract_log_entries(\"nonexistent.log\");\n        for (const auto& level : {\"WARNING\", \"ERROR\", \"CRITICAL\", \"ALERT\"}) {\n            std::ifstream outfile(level + \"_logs.txt\");\n            if (!outfile.is_open()) {\n                FAIL(\"Failed to open the output file: \" + level + \"_logs.txt\");\n            }\n            std::string content((std::istreambuf_iterator<char>(outfile)), std::istreambuf_iterator<char>());\n            REQUIRE(content.empty());\n        }\n    }\n\n    SECTION(\"test_empty_log_file\") {\n        std::ofstream log_file(log_file_path);\n        if (!log_file.is_open()) {\n            FAIL(\"Failed to create the log file.\");\n        }\n        log_file.close();\n\n        extract_log_entries(log_file_path);\n\n        for (const auto& level : {\"WARNING\", \"ERROR\", \"CRITICAL\", \"ALERT\"}) {\n            std::ifstream outfile(level + \"_logs.txt\");\n            if (!outfile.is_open()) {\n                FAIL(\"Failed to open the output file: \" + level + \"_logs.txt\");\n            }\n            std::string content((std::istreambuf_iterator<char>(outfile)), std::istreambuf_iterator<char>());\n            REQUIRE(content.empty());\n        }\n    }\n\n    SECTION(\"test_mixed_content_log_file\") {\n        std::ofstream log_file(log_file_path);\n        if (!log_file.is_open()) {\n            FAIL(\"Failed to create the log file.\");\n        }\n        log_file << \"INFO: Some info.\\n\"\n                 << \"WARNING: Watch out!\\n\"\n                 << \"DEBUG: Debugging.\\n\"\n                 << \"ERROR: Oops!\\n\"\n                 << \"CRITICAL: Failed badly.\\n\"\n                 << \"ALERT: High alert!\\n\"\n                 << \"INFO: More info.\\n\";\n        log_file.close();\n\n        extract_log_entries(log_file_path);\n\n        for (const auto& level : {\"WARNING\", \"ERROR\", \"CRITICAL\", \"ALERT\"}) {\n            std::ifstream outfile(level + \"_logs.txt\");\n            if (!outfile.is_open()) {\n                FAIL(\"Failed to open the output file: \" + level + \"_logs.txt\");\n            }\n            std::string content((std::istreambuf_iterator<char>(outfile)), std::istreambuf_iterator<char>());\n            REQUIRE(content.find(level) != std::string::npos);\n        }\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n * and save each type of log entry to a different file.\n *\n * @param logFilePath The path to the log file.\n */\nvoid extract_log_entries(const std::string& log_file_path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Extracts log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n * and saves each type of log entry to a different file.\n *\n * @param logFilePath The path to the log file.\n * @throws IOException If an I/O error occurs.\n */\npublic static void extractLogEntries(String logFilePath) throws IOException {}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertThrows;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    private static final String LOG_FILE_PATH = \"test_log.log\";\n    private static final String[] LOG_CONTENTS = {\n        \"INFO: This is an informational message.\\n\",\n        \"WARNING: This is a warning message.\\n\",\n        \"ERROR: This is an error message.\\n\",\n        \"CRITICAL: This is a critical message.\\n\",\n        \"ALERT: This is an alert message.\\n\"\n    };\n\n    @Before\n    public void setUp() throws IOException {\n        File logFile = new File(LOG_FILE_PATH);\n        try (FileWriter writer = new FileWriter(logFile)) {\n            for (String line : LOG_CONTENTS) {\n                writer.write(line);\n            }\n        }\n    }\n\n    @Test\n    public void testNoLogsOfCertainLevels() throws IOException {\n        // Setup a log file with only INFO messages\n        File logFile = new File(LOG_FILE_PATH);\n        try (FileWriter writer = new FileWriter(logFile)) {\n            writer.write(\"INFO: This is another informational message.\\n\");\n        }\n\n        extractLogEntries(LOG_FILE_PATH);\n\n        for (String level : new String[]{\"WARNING\", \"ERROR\", \"CRITICAL\", \"ALERT\"}) {\n            File outputFile = new File(level.toLowerCase() + \"_logs.txt\");\n            assertEquals(\"\", Files.readString(outputFile.toPath()));\n        }\n    }\n\n    @Test\n    public void testFileNotFound() {\n        assertThrows(IOException.class, () -> extractLogEntries(\"nonexistent.log\"));\n    }\n\n    @Test\n    public void testEmptyLogFile() throws IOException {\n        // Setup an empty log file\n        File logFile = new File(LOG_FILE_PATH);\n        try (FileWriter writer = new FileWriter(logFile)) {\n            writer.write(\"\");\n        }\n\n        extractLogEntries(LOG_FILE_PATH);\n\n        for (String level : new String[]{\"WARNING\", \"ERROR\", \"CRITICAL\", \"ALERT\"}) {\n            File outputFile = new File(level.toLowerCase() + \"_logs.txt\");\n            assertEquals(\"\", Files.readString(outputFile.toPath()));\n        }\n    }\n\n    @Test\n    public void testMixedContentLogFile() throws IOException {\n        // Setup a log file with mixed content\n        File logFile = new File(LOG_FILE_PATH);\n        try (FileWriter writer = new FileWriter(logFile)) {\n            writer.write(\"INFO: Some info.\\n\");\n            writer.write(\"WARNING: Watch out!\\n\");\n            writer.write(\"DEBUG: Debugging.\\n\");\n            writer.write(\"ERROR: Oops!\\n\");\n            writer.write(\"CRITICAL: Failed badly.\\n\");\n            writer.write(\"ALERT: High alert!\\n\");\n            writer.write(\"INFO: More info.\\n\");\n        }\n\n        extractLogEntries(LOG_FILE_PATH);\n\n        for (String level : new String[]{\"WARNING\", \"ERROR\", \"CRITICAL\", \"ALERT\"}) {\n            File outputFile = new File(level.toLowerCase() + \"_logs.txt\");\n            String content = Files.readString(outputFile.toPath()).trim();\n            assertTrue(content.contains(level));\n        }\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n * and saves each type of log entry to a different file.\n *\n * @param logFilePath The path to the log file.\n * @throws IOException If an I/O error occurs.\n */\npublic static void extractLogEntries(String logFilePath) throws IOException {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 266, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Handle nested data structures (e.g., dictionaries, lists, and enumerations), decode bytes to UTF8-strings, and convert numbers to integers or floating point numbers", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef handle_nested_data(data: Dict) -> Dict:\n    \"\"\"\n    handle nested question structures (e.g., dictionaries, lists, and enumerations), decode bytes to UTF8-strings, and convert numbers to integers or floating point numbers\n    Args:\n        data (Dict): question object\n\n    Returns:\n        after converted question\n    \"\"\"\n", "test_code": "import unittest\nfrom enum import Enum\nfrom numbers import Number\n\n\nclass TestHandleNestedData(unittest.TestCase):\n    def test_simple_dictionary(self):\n        data = {\"name\": b\"Alice\", \"age\": \"30\"}\n        expected = {\"name\": \"Alice\", \"age\": 30}\n        self.assertEqual(handle_nested_data(data), expected)\n\n    def test_nested_dictionary(self):\n        data = {\"user\": {\"name\": b\"Bob\", \"details\": {\"age\": \"25\", \"height\": \"175.5\"}}}\n        expected = {\"user\": {\"name\": \"Bob\", \"details\": {\"age\": 25, \"height\": 175.5}}}\n        self.assertEqual(handle_nested_data(data), expected)\n\n    def test_list_of_mixed_data_types(self):\n        data = [\"100\", b\"200\", 300.0, \"400.5\"]\n        expected = [100, \"200\", 300.0, 400.5]\n        self.assertEqual(handle_nested_data(data), expected)\n\n    def test_incorrect_byte_decoding(self):\n        data = {\"invalid_bytes\": b\"\\xff\\xfe\\xfd\\xfc\"}\n        with self.assertRaises(UnicodeDecodeError):\n            handle_nested_data(data)\n\n    def test_complex_nested_structure(self):\n        data = {\n            \"team\": [\n                {\"name\": b\"Charlie\", \"scores\": [\"1000\", \"2000.2\"]},\n                {\"name\": b\"Daisy\", \"skills\": [b\"Coding\", \"Design\"], \"age\": \"22\"}\n            ]\n        }\n        expected = {\n            \"team\": [\n                {\"name\": \"Charlie\", \"scores\": [1000, 2000.2]},\n                {\"name\": \"Daisy\", \"skills\": [\"Coding\", \"Design\"], \"age\": 22}\n            ]\n        }\n        self.assertEqual(handle_nested_data(data), expected)", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef handle_nested_data(data: Dict) -> Dict:\n    \"\"\"\n    handle nested question structures (e.g., dictionaries, lists, and enumerations), decode bytes to UTF8-strings, and convert numbers to integers or floating point numbers\n    Args:\n        data (Dict): question object\n\n    Returns:\n        after converted question\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Handles nested data structures (e.g., objects, arrays) by decoding bytes to UTF-8 strings and converting numbers to integers or floating-point numbers.\n * @param {Object} data - The data object to be processed.\n * @returns {Object} - The processed data.\n */\nfunction handleNestedData(data) {}", "test_code": "describe('TestHandleNestedData', () => {\n  describe('test_simple_dictionary', () => {\n      it('should correctly handle a simple dictionary', () => {\n          const data = { name: Buffer.from('Alice'), age: '30' };\n          const expected = { name: 'Alice', age: 30 };\n          expect(handleNestedData(data)).toEqual(expected);\n      });\n  });\n\n  describe('test_nested_dictionary', () => {\n      it('should correctly handle a nested dictionary', () => {\n          const data = { user: { name: Buffer.from('Bob'), details: { age: '25', height: '175.5' } } };\n          const expected = { user: { name: 'Bob', details: { age: 25, height: 175.5 } } };\n          expect(handleNestedData(data)).toEqual(expected);\n      });\n  });\n\n  describe('test_list_of_mixed_data_types', () => {\n      it('should correctly handle a list of mixed data types', () => {\n          const data = ['100', Buffer.from('200'), 300.0, '400.5'];\n          const expected = [100, '200', 300.0, 400.5];\n          expect(handleNestedData(data)).toEqual(expected);\n      });\n  });\n\n  describe('test_incorrect_byte_decoding', () => {\n      it('should throw an error when decoding invalid bytes', () => {\n          const data = { invalid_bytes: Buffer.from('\\xff\\xfe\\xfd\\xfc') };\n          expect(() => handleNestedData(data)).toThrow(/UnicodeDecodeError/);\n      });\n  });\n\n  describe('test_complex_nested_structure', () => {\n      it('should correctly handle a complex nested structure', () => {\n          const data = {\n              team: [\n                  { name: Buffer.from('Charlie'), scores: ['1000', '2000.2'] },\n                  { name: Buffer.from('Daisy'), skills: [Buffer.from('Coding'), 'Design'], age: '22' }\n              ]\n          };\n          const expected = {\n              team: [\n                  { name: 'Charlie', scores: [1000, 2000.2] },\n                  { name: 'Daisy', skills: ['Coding', 'Design'], age: 22 }\n              ]\n          };\n          expect(handleNestedData(data)).toEqual(expected);\n      });\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Handles nested data structures (e.g., objects, arrays) by decoding bytes to UTF-8 strings and converting numbers to integers or floating-point numbers.\n * @param {Object} data - The data object to be processed.\n * @returns {Object} - The processed data.\n */\nfunction handleNestedData(data) {}", "addition_info": ""}, "typescript": {"code_signature": "import { Buffer } from 'buffer';\n\n/**\n * Handles nested question structures (e.g., dictionaries, lists, and enumerations),\n * decodes bytes to UTF-8 strings, and converts numbers to integers or floating-point numbers.\n * \n * @param data - The question object to handle.\n * @returns The converted question object.\n */\nfunction handleNestedData(data: any): any {}", "test_code": "describe('TestHandleNestedData', () => {\n  it('test simple dictionary', () => {\n      const data = { name: b\"Alice\", age: \"30\" };\n      const expected = { name: \"Alice\", age: 30 };\n      expect(handleNestedData(data)).toEqual(expected);\n  });\n\n  it('test nested dictionary', () => {\n      const data = { user: { name: b\"Bob\", details: { age: \"25\", height: \"175.5\" } } };\n      const expected = { user: { name: \"Bob\", details: { age: 25, height: 175.5 } } };\n      expect(handleNestedData(data)).toEqual(expected);\n  });\n\n  it('test list of mixed data types', () => {\n      const data = [\"100\", b\"200\", 300.0, \"400.5\"];\n      const expected = [100, \"200\", 300.0, 400.5];\n      expect(handleNestedData(data)).toEqual(expected);\n  });\n\n  it('test incorrect byte decoding', () => {\n      const data = { invalid_bytes: b\"\\xff\\xfe\\xfd\\xfc\" };\n      expect(() => handleNestedData(data)).toThrow(/UnicodeDecodeError/);\n  });\n\n  it('test complex nested structure', () => {\n      const data = {\n          team: [\n              { name: b\"Charlie\", scores: [\"1000\", \"2000.2\"] },\n              { name: b\"Daisy\", skills: [b\"Coding\", \"Design\"], age: \"22\" }\n          ]\n      };\n      const expected = {\n          team: [\n              { name: \"Charlie\", scores: [1000, 2000.2] },\n              { name: \"Daisy\", skills: [\"Coding\", \"Design\"], age: 22 }\n          ]\n      };\n      expect(handleNestedData(data)).toEqual(expected);\n  });\n});", "prompt": "please write a typescript function , the function signature as below import { Buffer } from 'buffer';\n\n/**\n * Handles nested question structures (e.g., dictionaries, lists, and enumerations),\n * decodes bytes to UTF-8 strings, and converts numbers to integers or floating-point numbers.\n * \n * @param data - The question object to handle.\n * @returns The converted question object.\n */\nfunction handleNestedData(data: any): any {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Handle nested question structures (e.g., maps, vectors, strings, ints, doubles), decode bytes to UTF8-strings, and convert numbers to integers or floating point numbers\n * \n * @param std::map<std::string, VarType> question object\n * @return: after converted question\n */\nstd::map<std::string, VarType> handle_nested_data(std::map<std::string, VarType> data) {}", "test_code": "TEST_CASE(\"Test handle_nested_data function\") {\n    SECTION(\"Simple dictionary\") {\n        std::map<std::string, VarType> data = {{\"name\", std::string(\"Alice\", 5)}, {\"age\", \"30\"}};\n        std::map<std::string, VarType> expected = {{\"name\", \"Alice\"}, {\"age\", 30}};\n        REQUIRE(handle_nested_data(data) == expected);\n    }\n\n    SECTION(\"Nested dictionary\") {\n        std::map<std::string, VarType> nestedData = {\n            {\"user\", std::map<std::string, VarType>{{\"name\", std::string(\"Bob\", 3)}, {\"details\", std::map<std::string, VarType>{{\"age\", \"25\"}, {\"height\", \"175.5\"}}}}}\n        };\n        std::map<std::string, VarType> expected = {\n            {\"user\", std::map<std::string, VarType>{{\"name\", \"Bob\"}, {\"details\", std::map<std::string, VarType>{{\"age\", 25}, {\"height\", 175.5}}}}}\n        };\n        REQUIRE(handle_nested_data(nestedData) == expected);\n    }\n\n    SECTION(\"List of mixed data types\") {\n        std::vector<VarType> data = {\"100\", std::string(\"200\", 3), 300.0, \"400.5\"};\n        std::vector<VarType> expected = {100, std::string(\"200\", 3), 300.0, 400.5};\n        REQUIRE(handle_nested_data(data) == expected);\n    }\n\n    SECTION(\"Incorrect byte decoding\") {\n        std::map<std::string, VarType> data = {{\"invalid_bytes\", std::string(\"\\xff\\xfe\\xfd\\xfc\", 4)}};\n        REQUIRE_THROWS_AS(handle_nested_data(data), std::invalid_argument);\n    }\n\n    SECTION(\"Complex nested structure\") {\n        std::map<std::string, VarType> data = {\n            {\"team\", std::vector<VarType>{\n                std::map<std::string, VarType>{{\"name\", std::string(\"Charlie\", 7)}, {\"scores\", std::vector<VarType>{\"1000\", \"2000.2\"}}},\n                std::map<std::string, VarType>{{\"name\", std::string(\"Daisy\", 5)}, {\"skills\", std::vector<VarType>{std::string(\"Coding\", 6), \"Design\"}}, {\"age\", \"22\"}}\n            }}\n        };\n        std::map<std::string, VarType> expected = {\n            {\"team\", std::vector<VarType>{\n                std::map<std::string, VarType>{{\"name\", \"Charlie\"}, {\"scores\", std::vector<VarType>{1000, 2000.2}}},\n                std::map<std::string, VarType>{{\"name\", \"Daisy\"}, {\"skills\", std::vector<VarType>{\"Coding\", \"Design\"}}, {\"age\", 22}}\n            }}\n        };\n        REQUIRE(handle_nested_data(data) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Handle nested question structures (e.g., maps, vectors, strings, ints, doubles), decode bytes to UTF8-strings, and convert numbers to integers or floating point numbers\n * \n * @param std::map<std::string, VarType> question object\n * @return: after converted question\n */\nstd::map<std::string, VarType> handle_nested_data(std::map<std::string, VarType> data) {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 267, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "extract the second-level and top-level domain names from the fully qualified domain name FQDN and return them\n", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef extract_sld_tld(fqdn: str) -> Tuple[str, str]:\n    \"\"\"\n    extract the second-level and top-level domain names from the fully qualified domain name FQDN and return them\n    Args:\n        fqdn (str): The fully qualified domain name.\n\n    Returns:\n        A tuple containing the second-level domain and top-level domain.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestExtractSldTld(unittest.TestCase):\n    def test_standard_fqdn(self):\n        # Test a typical FQDN\n        self.assertEqual(extract_sld_tld(\"www.example.com\"), (\"example\", \"com\"))\n\n    def test_standard_fqdn2(self):\n        # Test a typical FQDN\n        self.assertEqual(extract_sld_tld(\"www.example.xyz\"), (\"example\", \"xyz\"))\n\n    def test_fqdn_with_subdomains(self):\n        # Test an FQDN with multiple subdomains\n        self.assertEqual(extract_sld_tld(\"blog.subdomain.example.com\"), (\"example\", \"com\"))\n\n    def test_numeric_tld(self):\n        # Test a numeric TLD, which can occur in private networks\n        self.assertEqual(extract_sld_tld(\"server.example.123\"), (\"example\", \"123\"))\n", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef extract_sld_tld(fqdn: str) -> Tuple[str, str]:\n    \"\"\"\n    extract the second-level and top-level domain names from the fully qualified domain name FQDN and return them\n    Args:\n        fqdn (str): The fully qualified domain name.\n\n    Returns:\n        A tuple containing the second-level domain and top-level domain.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extracts the second-level domain (SLD) and top-level domain (TLD) from a fully qualified domain name (FQDN).\n * \n * @param {string} fqdn - The fully qualified domain name.\n * @returns {Array<string>} An array containing the second-level domain and top-level domain.\n */\nfunction extractSldTld(fqdn) {}", "test_code": "describe('TestExtractSldTld', () => {\n    it('test standard FQDN', () => {\n        // Test a typical FQDN\n        expect(extractSldTld(\"www.example.com\")).toEqual([\"example\", \"com\"]);\n    });\n\n    it('test standard FQDN 2', () => {\n        // Test a typical FQDN\n        expect(extractSldTld(\"www.example.xyz\")).toEqual([\"example\", \"xyz\"]);\n    });\n\n    it('test FQDN with subdomains', () => {\n        // Test an FQDN with multiple subdomains\n        expect(extractSldTld(\"blog.subdomain.example.com\")).toEqual([\"example\", \"com\"]);\n    });\n\n    it('test numeric TLD', () => {\n        // Test a numeric TLD, which can occur in private networks\n        expect(extractSldTld(\"server.example.123\")).toEqual([\"example\", \"123\"]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Extracts the second-level domain (SLD) and top-level domain (TLD) from a fully qualified domain name (FQDN).\n * \n * @param {string} fqdn - The fully qualified domain name.\n * @returns {Array<string>} An array containing the second-level domain and top-level domain.\n */\nfunction extractSldTld(fqdn) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Extracts the second-level domain (SLD) and top-level domain (TLD) from a fully qualified domain name (FQDN).\n * \n * @param fqdn - The fully qualified domain name.\n * @returns A tuple containing the second-level domain and top-level domain.\n */\nfunction extractSldTld(fqdn: string): [string, string] {}", "test_code": "describe('TestExtractSldTld', () => {\n  it('test standard FQDN', () => {\n      // Test a typical FQDN\n      expect(extractSldTld(\"www.example.com\")).toEqual([\"example\", \"com\"]);\n  });\n\n  it('test standard FQDN2', () => {\n      // Test a typical FQDN\n      expect(extractSldTld(\"www.example.xyz\")).toEqual([\"example\", \"xyz\"]);\n  });\n\n  it('test FQDN with subdomains', () => {\n      // Test an FQDN with multiple subdomains\n      expect(extractSldTld(\"blog.subdomain.example.com\")).toEqual([\"example\", \"com\"]);\n  });\n\n  it('test numeric TLD', () => {\n      // Test a numeric TLD, which can occur in private networks\n      expect(extractSldTld(\"server.example.123\")).toEqual([\"example\", \"123\"]);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Extracts the second-level domain (SLD) and top-level domain (TLD) from a fully qualified domain name (FQDN).\n * \n * @param fqdn - The fully qualified domain name.\n * @returns A tuple containing the second-level domain and top-level domain.\n */\nfunction extractSldTld(fqdn: string): [string, string] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extracts the second-level and top-level domain names from the fully qualified domain name (FQDN).\n *\n * @param fqdn The fully qualified domain name.\n * @return A tuple containing the second-level domain and top-level domain.\n */\nstd::tuple<std::string, std::string> extract_sld_tld(const std::string& fqdn){\n\n}", "test_code": "TEST_CASE(\"Test extract_sld_tld function\") {\n    SECTION(\"Test a typical FQDN\") {\n        REQUIRE(extract_sld_tld(\"www.example.com\") == std::make_pair(\"example\", \"com\"));\n    }\n\n    SECTION(\"Test another typical FQDN\") {\n        REQUIRE(extract_sld_tld(\"www.example.xyz\") == std::make_pair(\"example\", \"xyz\"));\n    }\n\n    SECTION(\"Test an FQDN with multiple subdomains\") {\n        REQUIRE(extract_sld_tld(\"blog.subdomain.example.com\") == std::make_pair(\"example\", \"com\"));\n    }\n\n    SECTION(\"Test a numeric TLD\") {\n        REQUIRE(extract_sld_tld(\"server.example.123\") == std::make_pair(\"example\", \"123\"));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts the second-level and top-level domain names from the fully qualified domain name (FQDN).\n *\n * @param fqdn The fully qualified domain name.\n * @return A tuple containing the second-level domain and top-level domain.\n */\nstd::tuple<std::string, std::string> extract_sld_tld(const std::string& fqdn){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Extracts the second-level domain (SLD) and top-level domain (TLD) from a fully qualified domain name (FQDN).\n * \n * @param fqdn The fully qualified domain name.\n * @return A pair containing the second-level domain and top-level domain.\n * @throws IllegalArgumentException if the provided FQDN does not contain enough parts to extract SLD and TLD.\n */\npublic static SimpleEntry<String, String> extractSldTld(String fqdn) {}", "test_code": "import org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport org.real.temp.Answer;\n\npublic class Tester {\n\n    @Test\n    public void testStandardFqdn() {\n        // Test a typical FQDN\n        SimpleEntry<String, String> result = Answer.extractSldTld(\"www.example.com\");\n        assertEquals(new SimpleEntry<>(\"example\", \"com\"), result);\n    }\n\n    @Test\n    public void testStandardFqdn2() {\n        // Test a typical FQDN\n        SimpleEntry<String, String> result = Answer.extractSldTld(\"www.example.xyz\");\n        assertEquals(new SimpleEntry<>(\"example\", \"xyz\"), result);\n    }\n\n    @Test\n    public void testFqdnWithSubdomains() {\n        // Test an FQDN with multiple subdomains\n        SimpleEntry<String, String> result = Answer.extractSldTld(\"blog.subdomain.example.com\");\n        assertEquals(new SimpleEntry<>(\"example\", \"com\"), result);\n    }\n\n    @Test\n    public void testNumericTld() {\n        // Test a numeric TLD, which can occur in private networks\n        SimpleEntry<String, String> result = Answer.extractSldTld(\"server.example.123\");\n        assertEquals(new SimpleEntry<>(\"example\", \"123\"), result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts the second-level domain (SLD) and top-level domain (TLD) from a fully qualified domain name (FQDN).\n * \n * @param fqdn The fully qualified domain name.\n * @return A pair containing the second-level domain and top-level domain.\n * @throws IllegalArgumentException if the provided FQDN does not contain enough parts to extract SLD and TLD.\n */\npublic static SimpleEntry<String, String> extractSldTld(String fqdn) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 268, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "There are n gas stations along a circular route,\nwhere the amount of gas at the ith station is gas[i].\n\nYou have a car with an unlimited gas tank and\nit costs cost[i] of gas to travel from the ith station to its next (i + 1)th station.\nYou begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays gas and cost,\nreturn the starting gas station's index \nif you can travel around the circuit once in the clockwise direction,\notherwise return -1. If there exists a solution, it is guaranteed to be unique ", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -> int:\n    \"\"\"\n    Determines if there exists a starting gas station's index where you can travel\n    around the circuit once in a clockwise direction.\n\n    Args:\n        gas (List[int]): List of integers representing the amount of gas at each station.\n        cost (List[int]): List of integers representing the cost of gas to travel from each station to the next.\n\n    Returns:\n        int: The starting gas station's index if the circuit can be completed, otherwise -1.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCanCompleteCircuit(unittest.TestCase):\n\n    def test_possible_single_station(self):\n        gas = [5]\n        cost = [4]\n        expected = 0\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_impossible_single_station(self):\n        gas = [4]\n        cost = [5]\n        expected = -1\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_two_stations_possible(self):\n        gas = [1, 2]\n        cost = [2, 1]\n        expected = 1\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_circular_route_possible(self):\n        gas = [1, 2, 3, 4, 5]\n        cost = [3, 4, 5, 1, 2]\n        expected = 3\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_circular_route_impossible(self):\n        gas = [2, 3, 4]\n        cost = [3, 4, 3]\n        expected = -1\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -> int:\n    \"\"\"\n    Determines if there exists a starting gas station's index where you can travel\n    around the circuit once in a clockwise direction.\n\n    Args:\n        gas (List[int]): List of integers representing the amount of gas at each station.\n        cost (List[int]): List of integers representing the cost of gas to travel from each station to the next.\n\n    Returns:\n        int: The starting gas station's index if the circuit can be completed, otherwise -1.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Determines if there exists a starting gas station's index where you can travel\n * around the circuit once in a clockwise direction.\n *\n * @param {number[]} gas - List of integers representing the amount of gas at each station.\n * @param {number[]} cost - List of integers representing the cost of gas to travel from each station to the next.\n * @returns {number} The starting gas station's index if the circuit can be completed, otherwise -1.\n */\nfunction canCompleteCircuit(gas, cost) {}", "test_code": "describe('TestCanCompleteCircuit', () => {\n  describe('Single Station Tests', () => {\n      test('Possible single station', () => {\n          const gas = [5];\n          const cost = [4];\n          const expected = 0;\n          expect(canCompleteCircuit(gas, cost)).toBe(expected);\n      });\n\n      test('Impossible single station', () => {\n          const gas = [4];\n          const cost = [5];\n          const expected = -1;\n          expect(canCompleteCircuit(gas, cost)).toBe(expected);\n      });\n  });\n\n  describe('Two Stations Tests', () => {\n      test('Two stations possible', () => {\n          const gas = [1, 2];\n          const cost = [2, 1];\n          const expected = 1;\n          expect(canCompleteCircuit(gas, cost)).toBe(expected);\n      });\n  });\n\n  describe('Circular Route Tests', () => {\n      test('Circular route possible', () => {\n          const gas = [1, 2, 3, 4, 5];\n          const cost = [3, 4, 5, 1, 2];\n          const expected = 3;\n          expect(canCompleteCircuit(gas, cost)).toBe(expected);\n      });\n\n      test('Circular route impossible', () => {\n          const gas = [2, 3, 4];\n          const cost = [3, 4, 3];\n          const expected = -1;\n          expect(canCompleteCircuit(gas, cost)).toBe(expected);\n      });\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Determines if there exists a starting gas station's index where you can travel\n * around the circuit once in a clockwise direction.\n *\n * @param {number[]} gas - List of integers representing the amount of gas at each station.\n * @param {number[]} cost - List of integers representing the cost of gas to travel from each station to the next.\n * @returns {number} The starting gas station's index if the circuit can be completed, otherwise -1.\n */\nfunction canCompleteCircuit(gas, cost) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Determines if there exists a starting gas station's index where you can travel\n * around the circuit once in a clockwise direction.\n *\n * @param gas - An array of integers representing the amount of gas at each station.\n * @param cost - An array of integers representing the cost of gas to travel from each station to the next.\n * @returns The starting gas station's index if the circuit can be completed, otherwise -1.\n */\nfunction canCompleteCircuit(gas: number[], cost: number[]): number {}", "test_code": "describe('canCompleteCircuit', () => {\n    it('should return the correct starting index for a single station', () => {\n        const gas = [5];\n        const cost = [4];\n        const expected = 0;\n        expect(canCompleteCircuit(gas, cost)).toBe(expected);\n    });\n\n    it('should return -1 for an impossible single station', () => {\n        const gas = [4];\n        const cost = [5];\n        const expected = -1;\n        expect(canCompleteCircuit(gas, cost)).toBe(expected);\n    });\n\n    it('should return the correct starting index for two stations', () => {\n        const gas = [1, 2];\n        const cost = [2, 1];\n        const expected = 1;\n        expect(canCompleteCircuit(gas, cost)).toBe(expected);\n    });\n\n    it('should return the correct starting index for a circular route', () => {\n        const gas = [1, 2, 3, 4, 5];\n        const cost = [3, 4, 5, 1, 2];\n        const expected = 3;\n        expect(canCompleteCircuit(gas, cost)).toBe(expected);\n    });\n\n    it('should return -1 for an impossible circular route', () => {\n        const gas = [2, 3, 4];\n        const cost = [3, 4, 3];\n        const expected = -1;\n        expect(canCompleteCircuit(gas, cost)).toBe(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Determines if there exists a starting gas station's index where you can travel\n * around the circuit once in a clockwise direction.\n *\n * @param gas - An array of integers representing the amount of gas at each station.\n * @param cost - An array of integers representing the cost of gas to travel from each station to the next.\n * @returns The starting gas station's index if the circuit can be completed, otherwise -1.\n */\nfunction canCompleteCircuit(gas: number[], cost: number[]): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Determines if there exists a starting gas station's index where you can travel\n * around the circuit once in a clockwise direction.\n *\n * @param gas A vector of integers representing the amount of gas at each station.\n * @param cost A vector of integers representing the cost of gas to travel from each station to the next.\n * @return The starting gas station's index if the circuit can be completed, otherwise -1.\n */\nint canCompleteCircuit(const std::vector<int>& gas, const std::vector<int>& cost) {\n\n}", "test_code": "TEST_CASE(\"Test possible single station\", \"[canCompleteCircuit]\") {\n    std::vector<int> gas = {5};\n    std::vector<int> cost = {4};\n    int expected = 0;\n    REQUIRE(canCompleteCircuit(gas, cost) == expected);\n}\n\nTEST_CASE(\"Test impossible single station\", \"[canCompleteCircuit]\") {\n    std::vector<int> gas = {4};\n    std::vector<int> cost = {5};\n    int expected = -1;\n    REQUIRE(canCompleteCircuit(gas, cost) == expected);\n}\n\nTEST_CASE(\"Test two stations possible\", \"[canCompleteCircuit]\") {\n    std::vector<int> gas = {1, 2};\n    std::vector<int> cost = {2, 1};\n    int expected = 1;\n    REQUIRE(canCompleteCircuit(gas, cost) == expected);\n}\n\nTEST_CASE(\"Test circular route possible\", \"[canCompleteCircuit]\") {\n    std::vector<int> gas = {1, 2, 3, 4, 5};\n    std::vector<int> cost = {3, 4, 5, 1, 2};\n    int expected = 3;\n    REQUIRE(canCompleteCircuit(gas, cost) == expected);\n}\n\nTEST_CASE(\"Test circular route impossible\", \"[canCompleteCircuit]\") {\n    std::vector<int> gas = {2, 3, 4};\n    std::vector<int> cost = {3, 4, 3};\n    int expected = -1;\n    REQUIRE(canCompleteCircuit(gas, cost) == expected);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Determines if there exists a starting gas station's index where you can travel\n * around the circuit once in a clockwise direction.\n *\n * @param gas A vector of integers representing the amount of gas at each station.\n * @param cost A vector of integers representing the cost of gas to travel from each station to the next.\n * @return The starting gas station's index if the circuit can be completed, otherwise -1.\n */\nint canCompleteCircuit(const std::vector<int>& gas, const std::vector<int>& cost) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Determines if there is a starting gas station index at which a car can complete the circuit.\n * \n * @param gas An array representing the amount of gas at each station.\n * @param cost An array representing the cost of gas to travel from each station to the next one.\n * @return The starting gas station index if the car can complete the circuit, or -1 otherwise.\n */\npublic static int canCompleteCircuit(List<Integer> gas, List<Integer> cost) {}", "test_code": "package org.real.temp;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testPossibleSingleStation() {\n        List<Integer> gas = Arrays.asList(5);\n        List<Integer> cost = Arrays.asList(4);\n        int expected = 0;\n        assertEquals(expected, canCompleteCircuit(gas, cost));\n    }\n\n    @Test\n    public void testImpossibleSingleStation() {\n        List<Integer> gas = Arrays.asList(4);\n        List<Integer> cost = Arrays.asList(5);\n        int expected = -1;\n        assertEquals(expected, canCompleteCircuit(gas, cost));\n    }\n\n    @Test\n    public void testTwoStationsPossible() {\n        List<Integer> gas = Arrays.asList(1, 2);\n        List<Integer> cost = Arrays.asList(2, 1);\n        int expected = 1;\n        assertEquals(expected, canCompleteCircuit(gas, cost));\n    }\n\n    @Test\n    public void testCircularRoutePossible() {\n        List<Integer> gas = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> cost = Arrays.asList(3, 4, 5, 1, 2);\n        int expected = 3;\n        assertEquals(expected, canCompleteCircuit(gas, cost));\n    }\n\n    @Test\n    public void testCircularRouteImpossible() {\n        List<Integer> gas = Arrays.asList(2, 3, 4);\n        List<Integer> cost = Arrays.asList(3, 4, 3);\n        int expected = -1;\n        assertEquals(expected, canCompleteCircuit(gas, cost));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Determines if there is a starting gas station index at which a car can complete the circuit.\n * \n * @param gas An array representing the amount of gas at each station.\n * @param cost An array representing the cost of gas to travel from each station to the next one.\n * @return The starting gas station index if the car can complete the circuit, or -1 otherwise.\n */\npublic static int canCompleteCircuit(List<Integer> gas, List<Integer> cost) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 269, "code_type": "method", "original_language": "python", "question_type": "Network requests and API call", "summary": "checks whether a string is compliant IP\n", "language_version_list": {"python": {"code_signature": "def is_compliant_ip(ip: str) -> bool:\n    \"\"\"\n    Check whether the IP address is a legal IP address.\n\n    Args:\n        ip (str): The IP address in string format.\n\n    Returns:\n        bool: True if the IP is compliant, False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestIsCompliantIP(unittest.TestCase):\n    def test_private_ip(self):\n        # Test that private IPs return True\n        self.assertTrue(is_compliant_ip('192.168.1.1'))\n\n    def test_public_ip(self):\n        # Test that public IPs return False\n        self.assertTrue(is_compliant_ip('8.8.8.8'))\n\n    def test_invalid_ip(self):\n        # Test that invalid IP strings return False\n        self.assertFalse(is_compliant_ip('999.999.999.999'))\n", "prompt": "please write a python function , the function signature as below def is_compliant_ip(ip: str) -> bool:\n    \"\"\"\n    Check whether the IP address is a legal IP address.\n\n    Args:\n        ip (str): The IP address in string format.\n\n    Returns:\n        bool: True if the IP is compliant, False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Check whether the IP address is a legal IP address.\n *\n * @param {string} ip - The IP address in string format.\n * @returns {boolean} - True if the IP is compliant, False otherwise.\n */\nfunction isCompliantIP(ip) {}", "test_code": "describe('TestIsCompliantIP', () => {\n  test('test_private_ip', () => {\n      expect(isCompliantIP('192.168.1.1')).toBe(true);\n  });\n\n  test('test_public_ip', () => {\n      expect(isCompliantIP('8.8.8.8')).toBe(true);\n  });\n\n  test('test_invalid_ip', () => {\n      expect(isCompliantIP('999.999.999.999')).toBe(false);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Check whether the IP address is a legal IP address.\n *\n * @param {string} ip - The IP address in string format.\n * @returns {boolean} - True if the IP is compliant, False otherwise.\n */\nfunction isCompliantIP(ip) {}", "addition_info": ""}, "typescript": {"code_signature": "import { ipAddress } from \"ip-address\";\n\n/**\n * Check whether the IP address is a legal IP address.\n * \n * @param ip - The IP address in string format.\n * @returns True if the IP is compliant, False otherwise.\n */\nfunction isCompliantIP(ip: string): boolean {}", "test_code": "describe('isCompliantIP', () => {\n    it('should return true for private IPs', () => {\n        expect(isCompliantIP('192.168.1.1')).toBe(true);\n    });\n\n    it('should return false for public IPs', () => {\n        expect(isCompliantIP('8.8.8.8')).toBe(true);\n    });\n\n    it('should return false for invalid IP strings', () => {\n        expect(isCompliantIP('999.999.999.999')).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below import { ipAddress } from \"ip-address\";\n\n/**\n * Check whether the IP address is a legal IP address.\n * \n * @param ip - The IP address in string format.\n * @returns True if the IP is compliant, False otherwise.\n */\nfunction isCompliantIP(ip: string): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Check whether the IP address is a legal IP address.\n *\n * @param ip The IP address in string format.\n * @return True if the IP is compliant, False otherwise.\n */\nbool is_compliant_ip(const std::string& ip){\n\n}", "test_code": "TEST_CASE(\"Test IsCompliantIP\", \"[is_compliant_ip]\") {\n    SECTION(\"Private IP\") {\n        // Test that private IPs return True\n        REQUIRE(is_compliant_ip(\"192.168.1.1\"));\n    }\n\n    SECTION(\"Public IP\") {\n        // Test that public IPs return False\n        REQUIRE_FALSE(is_compliant_ip(\"8.8.8.8\"));\n    }\n\n    SECTION(\"Invalid IP\") {\n        // Test that invalid IP strings return False\n        REQUIRE_FALSE(is_compliant_ip(\"999.999.999.999\"));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Check whether the IP address is a legal IP address.\n *\n * @param ip The IP address in string format.\n * @return True if the IP is compliant, False otherwise.\n */\nbool is_compliant_ip(const std::string& ip){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks whether the given IP address is a legal IP address.\n *\n * @param ip The IP address in string format.\n * @return true if the IP is compliant, false otherwise.\n */\npublic static boolean isCompliantIP(String ip) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\n/**\n * Test class for verifying the compliance of IP addresses.\n */\npublic class Tester {\n\n    /**\n     * Tests that private IP addresses return true.\n     */\n    @Test\n    public void testPrivateIP() {\n        // Test that private IPs return true\n        assertTrue(isCompliantIP(\"192.168.1.1\"));\n    }\n\n    /**\n     * Tests that public IP addresses return false.\n     */\n    @Test\n    public void testPublicIP() {\n        // Test that public IPs return false\n        assertFalse(isCompliantIP(\"8.8.8.8\"));\n    }\n\n    /**\n     * Tests that invalid IP strings return false.\n     */\n    @Test\n    public void testInvalidIP() {\n        // Test that invalid IP strings return false\n        assertFalse(isCompliantIP(\"999.999.999.999\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks whether the given IP address is a legal IP address.\n *\n * @param ip The IP address in string format.\n * @return true if the IP is compliant, false otherwise.\n */\npublic static boolean isCompliantIP(String ip) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 281, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "compute the squared Euclidean distance between two vectors\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef squared_euclidean_distance(vec1: List[int], vec2: List[int]) -> int:\n    \"\"\"\n    compute the squared Euclidean distance between two vectors.\n\n    Args:\n        vec1 (List[int]): First vector.\n        vec2 (List[int]): Second vector.\n\n    Returns:\n        int: Euclidean distance between vec1 and vec2.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSquaredEuclideanDistance(unittest.TestCase):\n    def test_standard_vectors(self):\n        \"\"\"Test squared distance calculation for typical vectors.\"\"\"\n        vec1 = [1, 2, 3]\n        vec2 = [4, 5, 6]\n        expected_result = 27  # (3^2 + 3^2 + 3^2)\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n\n    def test_vectors_with_zeros(self):\n        \"\"\"Test vectors that include zero values.\"\"\"\n        vec1 = [0, 0, 0]\n        vec2 = [0, 0, 0]\n        expected_result = 0\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n\n    def test_vectors_with_negative_values(self):\n        \"\"\"Test vectors that include negative values.\"\"\"\n        vec1 = [-1, -2, -3]\n        vec2 = [-4, -5, -6]\n        expected_result = 27  # (3^2 + 3^2 + 3^2)\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n\n    def test_single_element_vectors(self):\n        \"\"\"Test single element vectors.\"\"\"\n        vec1 = [5]\n        vec2 = [-5]\n        expected_result = 100  # (10^2)\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef squared_euclidean_distance(vec1: List[int], vec2: List[int]) -> int:\n    \"\"\"\n    compute the squared Euclidean distance between two vectors.\n\n    Args:\n        vec1 (List[int]): First vector.\n        vec2 (List[int]): Second vector.\n\n    Returns:\n        int: Euclidean distance between vec1 and vec2.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Compute the squared Euclidean distance between two vectors.\n *\n * @param {Array<number>} vec1 - First vector.\n * @param {Array<number>} vec2 - Second vector.\n * @returns {number} - Squared Euclidean distance between vec1 and vec2.\n * @throws {Error} - If the vectors are of different lengths.\n */\nfunction squaredEuclideanDistance(vec1, vec2) {}", "test_code": "describe('SquaredEuclideanDistance', () => {\n    it('test standard vectors', () => {\n        const vec1 = [1, 2, 3];\n        const vec2 = [4, 5, 6];\n        const expectedResult = 27; // (3^2 + 3^2 + 3^2)\n        const result = squaredEuclideanDistance(vec1, vec2);\n        expect(result).toBe(expectedResult);\n    });\n\n    it('test vectors with zeros', () => {\n        const vec1 = [0, 0, 0];\n        const vec2 = [0, 0, 0];\n        const expectedResult = 0;\n        const result = squaredEuclideanDistance(vec1, vec2);\n        expect(result).toBe(expectedResult);\n    });\n\n    it('test vectors with negative values', () => {\n        const vec1 = [-1, -2, -3];\n        const vec2 = [-4, -5, -6];\n        const expectedResult = 27; // (3^2 + 3^2 + 3^2)\n        const result = squaredEuclideanDistance(vec1, vec2);\n        expect(result).toBe(expectedResult);\n    });\n\n    it('test single element vectors', () => {\n        const vec1 = [5];\n        const vec2 = [-5];\n        const expectedResult = 100; // (10^2)\n        const result = squaredEuclideanDistance(vec1, vec2);\n        expect(result).toBe(expectedResult);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Compute the squared Euclidean distance between two vectors.\n *\n * @param {Array<number>} vec1 - First vector.\n * @param {Array<number>} vec2 - Second vector.\n * @returns {number} - Squared Euclidean distance between vec1 and vec2.\n * @throws {Error} - If the vectors are of different lengths.\n */\nfunction squaredEuclideanDistance(vec1, vec2) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Computes the squared Euclidean distance between two vectors.\n *\n * @param vec1 - The first vector.\n * @param vec2 - The second vector.\n * @returns The squared Euclidean distance between vec1 and vec2.\n * @throws {Error} If the vectors are of different lengths.\n */\nfunction squaredEuclideanDistance(vec1: number[], vec2: number[]): number {}", "test_code": "describe('SquaredEuclideanDistance', () => {\n    describe('test_standard_vectors', () => {\n        it('should calculate the squared distance correctly for typical vectors', () => {\n            const vec1 = [1, 2, 3];\n            const vec2 = [4, 5, 6];\n            const expectedResult = 27; // (3^2 + 3^2 + 3^2)\n            const result = squaredEuclideanDistance(vec1, vec2);\n            expect(result).toBe(expectedResult);\n        });\n    });\n\n    describe('test_vectors_with_zeros', () => {\n        it('should handle vectors that include zero values', () => {\n            const vec1 = [0, 0, 0];\n            const vec2 = [0, 0, 0];\n            const expectedResult = 0;\n            const result = squaredEuclideanDistance(vec1, vec2);\n            expect(result).toBe(expectedResult);\n        });\n    });\n\n    describe('test_vectors_with_negative_values', () => {\n        it('should handle vectors that include negative values', () => {\n            const vec1 = [-1, -2, -3];\n            const vec2 = [-4, -5, -6];\n            const expectedResult = 27; // (3^2 + 3^2 + 3^2)\n            const result = squaredEuclideanDistance(vec1, vec2);\n            expect(result).toBe(expectedResult);\n        });\n    });\n\n    describe('test_single_element_vectors', () => {\n        it('should handle single element vectors', () => {\n            const vec1 = [5];\n            const vec2 = [-5];\n            const expectedResult = 100; // (10^2)\n            const result = squaredEuclideanDistance(vec1, vec2);\n            expect(result).toBe(expectedResult);\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Computes the squared Euclidean distance between two vectors.\n *\n * @param vec1 - The first vector.\n * @param vec2 - The second vector.\n * @returns The squared Euclidean distance between vec1 and vec2.\n * @throws {Error} If the vectors are of different lengths.\n */\nfunction squaredEuclideanDistance(vec1: number[], vec2: number[]): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Compute the squared Euclidean distance between two vectors.\n *\n * @param vec1 The first vector.\n * @param vec2 The second vector.\n * @return The squared Euclidean distance between vec1 and vec2.\n */\nint squared_euclidean_distance(const std::vector<int>& vec1, const std::vector<int>& vec2) {\n\n}", "test_code": "TEST_CASE(\"Squared Euclidean Distance\", \"[squared_euclidean_distance]\") {\n    SECTION(\"Equal Vectors\") {\n        std::vector<int> vec1 = {1, 2, 3};\n        std::vector<int> vec2 = {1, 2, 3};\n        REQUIRE(squared_euclidean_distance(vec1, vec2) == 0);\n    }\n\n    SECTION(\"Different Vectors\") {\n        std::vector<int> vec1 = {1, 2, 3};\n        std::vector<int> vec2 = {4, 5, 6};\n        REQUIRE(squared_euclidean_distance(vec1, vec2) == 27);\n    }\n\n    SECTION(\"Empty Vectors\") {\n        std::vector<int> vec1 = {};\n        std::vector<int> vec2 = {};\n        REQUIRE(squared_euclidean_distance(vec1, vec2) == 0);\n    }\n\n    SECTION(\"Single Element Vectors\") {\n        std::vector<int> vec1 = {1};\n        std::vector<int> vec2 = {2};\n        REQUIRE(squared_euclidean_distance(vec1, vec2) == 1);\n    }\n\n    SECTION(\"Vectors with Negative Elements\") {\n        std::vector<int> vec1 = {-1, -2, -3};\n        std::vector<int> vec2 = {1, 2, 3};\n        REQUIRE(squared_euclidean_distance(vec1, vec2) == 36);\n    }\n\n    SECTION(\"Vectors of Different Sizes Should Throw Exception\") {\n        std::vector<int> vec1 = {1, 2, 3};\n        std::vector<int> vec2 = {1, 2};\n        REQUIRE_THROWS_WITH(squared_euclidean_distance(vec1, vec2), \"Vectors must be of the same size\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Compute the squared Euclidean distance between two vectors.\n *\n * @param vec1 The first vector.\n * @param vec2 The second vector.\n * @return The squared Euclidean distance between vec1 and vec2.\n */\nint squared_euclidean_distance(const std::vector<int>& vec1, const std::vector<int>& vec2) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Compute the squared Euclidean distance between two vectors.\n *\n * @param vec1 First vector as an array of doubles.\n * @param vec2 Second vector as an array of doubles.\n * @return The squared Euclidean distance between vec1 and vec2 as a double.\n * @throws IllegalArgumentException If the vectors are of different lengths.\n */\npublic static double squaredEuclideanDistance(List<Double> vec1, List<Double> vec2) {}", "test_code": "package org.real.temp;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.assertTrue;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testStandardVectors() {\n        List<Double> vec1 = Arrays.asList(1.0, 2.0, 3.0);\n        List<Double> vec2 = Arrays.asList(4.0, 5.0, 6.0);\n        double expectedResult = 27.0;  // (3^2 + 3^2 + 3^2)\n        double result = squaredEuclideanDistance(vec1, vec2);\n        assertTrue(expectedResult ==result );\n    }\n\n    @Test\n    public void testVectorsWithZeros() {\n        List<Double> vec1 = Arrays.asList(0.0, 0.0, 0.0);\n        List<Double> vec2 = Arrays.asList(0.0, 0.0, 0.0);\n        double expectedResult = 0.0;\n        double result = squaredEuclideanDistance(vec1, vec2);\n        assertTrue(expectedResult ==result );\n    }\n\n    @Test\n    public void testVectorsWithNegativeValues() {\n        List<Double> vec1 = Arrays.asList(-1.0, -2.0, -3.0);\n        List<Double> vec2 = Arrays.asList(-4.0, -5.0, -6.0);\n        double expectedResult = 27.0;  // (3^2 + 3^2 + 3^2)\n        double result = squaredEuclideanDistance(vec1, vec2);\n        assertTrue(expectedResult ==result );\n    }\n\n    @Test\n    public void testSingleElementVectors() {\n        List<Double> vec1 = Arrays.asList(5.0);\n        List<Double> vec2 = Arrays.asList(-5.0);\n        double expectedResult = 100.0;  // (10^2)\n        double result = squaredEuclideanDistance(vec1, vec2);\n        assertTrue(expectedResult ==result );\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Compute the squared Euclidean distance between two vectors.\n *\n * @param vec1 First vector as an array of doubles.\n * @param vec2 Second vector as an array of doubles.\n * @return The squared Euclidean distance between vec1 and vec2 as a double.\n * @throws IllegalArgumentException If the vectors are of different lengths.\n */\npublic static double squaredEuclideanDistance(List<Double> vec1, List<Double> vec2) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 282, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "convert a multi-dimensional array into a one-dimensional array\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef flatten_array(multi_dim_array: List) -> List:\n    \"\"\"\n    convert a multi-dimensional array into a one-dimensional array\n    Args:\n        multi_dim_array (List): A multi-dimensional list (nested list).\n\n    Returns:\n        list: A one-dimensional list containing all elements of the input.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFlattenArray(unittest.TestCase):\n    def test_deeply_nested_array(self):\n        \"\"\"Test a deeply nested array.\"\"\"\n        nested_array = [1, [2, [3, [4, [5]]]]]\n        expected_result = [1, 2, 3, 4, 5]\n        self.assertEqual(flatten_array(nested_array), expected_result)\n\n    def test_mixed_types(self):\n        \"\"\"Test an array with mixed question types.\"\"\"\n        mixed_array = [\"a\", [\"b\", 2, [True, [3.14]]], False]\n        expected_result = [\"a\", \"b\", 2, True, 3.14, False]\n        self.assertEqual(flatten_array(mixed_array), expected_result)\n\n    def test_empty_array(self):\n        \"\"\"Test an empty array.\"\"\"\n        empty_array = []\n        expected_result = []\n        self.assertEqual(flatten_array(empty_array), expected_result)\n\n    def test_array_with_empty_subarrays(self):\n        \"\"\"Test an array that includes empty subarrays.\"\"\"\n        complex_array = [1, [], [2, [], 3], [4, [5, [], 6], 7], []]\n        expected_result = [1, 2, 3, 4, 5, 6, 7]\n        self.assertEqual(flatten_array(complex_array), expected_result)\n\n    def test_no_nested_array(self):\n        \"\"\"Test an array that has no nested structure.\"\"\"\n        flat_array = [1, 2, 3, 4, 5]\n        expected_result = [1, 2, 3, 4, 5]\n        self.assertEqual(flatten_array(flat_array), expected_result)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef flatten_array(multi_dim_array: List) -> List:\n    \"\"\"\n    convert a multi-dimensional array into a one-dimensional array\n    Args:\n        multi_dim_array (List): A multi-dimensional list (nested list).\n\n    Returns:\n        list: A one-dimensional list containing all elements of the input.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a multi-dimensional array into a one-dimensional array.\n * \n * @param {Array} multiDimArray - A multi-dimensional array (nested array).\n * @returns {Array} A one-dimensional array containing all elements of the input.\n */\nfunction flattenArray(multiDimArray) {}", "test_code": "describe('TestFlattenArray', () => {\n  it('test a deeply nested array', () => {\n      const nestedArray = [1, [2, [3, [4, [5]]]]];\n      const expectedResult = [1, 2, 3, 4, 5];\n      expect(flattenArray(nestedArray)).toEqual(expectedResult);\n  });\n\n  it('test an array with mixed types', () => {\n      const mixedArray = [\"a\", [\"b\", 2, [true, [3.14]]], false];\n      const expectedResult = [\"a\", \"b\", 2, true, 3.14, false];\n      expect(flattenArray(mixedArray)).toEqual(expectedResult);\n  });\n\n  it('test an empty array', () => {\n      const emptyArray = [];\n      const expectedResult = [];\n      expect(flattenArray(emptyArray)).toEqual(expectedResult);\n  });\n\n  it('test an array that includes empty subarrays', () => {\n      const complexArray = [1, [], [2, [], 3], [4, [5, [], 6], 7], []];\n      const expectedResult = [1, 2, 3, 4, 5, 6, 7];\n      expect(flattenArray(complexArray)).toEqual(expectedResult);\n  });\n\n  it('test an array that has no nested structure', () => {\n      const flatArray = [1, 2, 3, 4, 5];\n      const expectedResult = [1, 2, 3, 4, 5];\n      expect(flattenArray(flatArray)).toEqual(expectedResult);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a multi-dimensional array into a one-dimensional array.\n * \n * @param {Array} multiDimArray - A multi-dimensional array (nested array).\n * @returns {Array} A one-dimensional array containing all elements of the input.\n */\nfunction flattenArray(multiDimArray) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a multi-dimensional array into a one-dimensional array.\n * \n * @param multiDimArray - A multi-dimensional array (nested array).\n * @returns A one-dimensional array containing all elements of the input.\n */\nfunction flattenArray(multiDimArray: any[]): number[] | any[] {}", "test_code": "describe('TestFlattenArray', () => {\n  it('testDeeplyNestedArray', () => {\n      const nestedArray = [1, [2, [3, [4, [5]]]]];\n      const expectedResult = [1, 2, 3, 4, 5];\n      expect(flattenArray(nestedArray)).toEqual(expectedResult);\n  });\n\n  it('testMixedTypes', () => {\n      const mixedArray = [\"a\", [\"b\", 2, [true, [3.14]]], false];\n      const expectedResult = [\"a\", \"b\", 2, true, 3.14, false];\n      expect(flattenArray(mixedArray)).toEqual(expectedResult);\n  });\n\n  it('testEmptyArray', () => {\n      const emptyArray: any[] = [];\n      const expectedResult: any[] = [];\n      expect(flattenArray(emptyArray)).toEqual(expectedResult);\n  });\n\n  it('testArrayWithEmptySubarrays', () => {\n      const complexArray = [1, [], [2, [], 3], [4, [5, [], 6], 7], []];\n      const expectedResult = [1, 2, 3, 4, 5, 6, 7];\n      expect(flattenArray(complexArray)).toEqual(expectedResult);\n  });\n\n  it('testNoNestedArray', () => {\n      const flatArray = [1, 2, 3, 4, 5];\n      const expectedResult = [1, 2, 3, 4, 5];\n      expect(flattenArray(flatArray)).toEqual(expectedResult);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a multi-dimensional array into a one-dimensional array.\n * \n * @param multiDimArray - A multi-dimensional array (nested array).\n * @returns A one-dimensional array containing all elements of the input.\n */\nfunction flattenArray(multiDimArray: any[]): number[] | any[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert a multi-dimensional array into a one-dimensional array.\n *\n * @param multiDimArray The multi-dimensional vector (nested vector).\n * @return A one-dimensional vector containing all elements of the input.\n */\nstd::vector<int> flatten_array(const std::vector<std::vector<int>>& multiDimArray){\n\n}", "test_code": "TEST_CASE(\"Flatten array tests\") {\n\n    // Test a deeply nested array\n    SECTION(\"deeply_nested_array\") {\n        std::vector<std::vector<int>> nested_array = {{1}, {2, {3, {4, {5}}}}};\n        std::vector<int> expected_result = {1, 2, 3, 4, 5};\n        REQUIRE(flatten_array(nested_array) == expected_result);\n    }\n\n    // Test an array with mixed types (simulated with integers for simplicity)\n    SECTION(\"mixed_types\") {\n        std::vector<std::vector<int>> mixed_array = {{1}, {2, {3, {4, {5}}}}, {6}};\n        std::vector<int> expected_result = {1, 2, 3, 4, 5, 6};\n        REQUIRE(flatten_array(mixed_array) == expected_result);\n    }\n\n    // Test an empty array\n    SECTION(\"empty_array\") {\n        std::vector<std::vector<int>> empty_array = {};\n        std::vector<int> expected_result = {};\n        REQUIRE(flatten_array(empty_array) == expected_result);\n    }\n\n    // Test an array that includes empty subarrays\n    SECTION(\"array_with_empty_subarrays\") {\n        std::vector<std::vector<int>> complex_array = {{1}, {}, {2, {}, 3}, {4, {5, {}, 6}, 7}, {}};\n        std::vector<int> expected_result = {1, 2, 3, 4, 5, 6, 7};\n        REQUIRE(flatten_array(complex_array) == expected_result);\n    }\n\n    // Test an array that has no nested structure\n    SECTION(\"no_nested_array\") {\n        std::vector<std::vector<int>> flat_array = {{1}, {2}, {3}, {4}, {5}};\n        std::vector<int> expected_result = {1, 2, 3, 4, 5};\n        REQUIRE(flatten_array(flat_array) == expected_result);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert a multi-dimensional array into a one-dimensional array.\n *\n * @param multiDimArray The multi-dimensional vector (nested vector).\n * @return A one-dimensional vector containing all elements of the input.\n */\nstd::vector<int> flatten_array(const std::vector<std::vector<int>>& multiDimArray){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a multi-dimensional array into a one-dimensional array.\n *\n * @param multiDimArray A multi-dimensional list (nested list).\n * @return A one-dimensional list containing all elements of the input.\n */\npublic static List<Object> flattenArray(List<?> multiDimArray) {}", "test_code": "package org.real.temp;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testDeeplyNestedArray() {\n        List<Object> nestedArray = Arrays.asList(1, Arrays.asList(2, Arrays.asList(3, Arrays.asList(4, Arrays.asList(5)))));\n        List<Object> expectedResult = Arrays.asList(1, 2, 3, 4, 5);\n        assertEquals(expectedResult, flattenArray(nestedArray));\n    }\n\n    @Test\n    public void testMixedTypes() {\n        List<Object> mixedArray = Arrays.asList(\"a\", Arrays.asList(\"b\", 2, Arrays.asList(true, Arrays.asList(3.14))), false);\n        List<Object> expectedResult = Arrays.asList(\"a\", \"b\", 2, true, 3.14, false);\n        assertEquals(expectedResult, flattenArray(mixedArray));\n    }\n\n    @Test\n    public void testEmptyArray() {\n        List<Object> emptyArray = new ArrayList<>();\n        List<Object> expectedResult = new ArrayList<>();\n        assertEquals(expectedResult, flattenArray(emptyArray));\n    }\n\n    @Test\n    public void testArrayWithEmptySubarrays() {\n        List<Object> complexArray = Arrays.asList(1, new ArrayList<>(), Arrays.asList(2, new ArrayList<>(), 3), \n                                                  Arrays.asList(4, Arrays.asList(5, new ArrayList<>(), 6), 7), \n                                                  new ArrayList<>());\n        List<Object> expectedResult = Arrays.asList(1, 2, 3, 4, 5, 6, 7);\n        assertEquals(expectedResult, flattenArray(complexArray));\n    }\n\n    @Test\n    public void testNoNestedArray() {\n        List<Object> flatArray = Arrays.asList(1, 2, 3, 4, 5);\n        List<Object> expectedResult = Arrays.asList(1, 2, 3, 4, 5);\n        assertEquals(expectedResult, flattenArray(flatArray));\n    }\n    \n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a multi-dimensional array into a one-dimensional array.\n *\n * @param multiDimArray A multi-dimensional list (nested list).\n * @return A one-dimensional list containing all elements of the input.\n */\npublic static List<Object> flattenArray(List<?> multiDimArray) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 286, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "find the largest integer between a given number n and half of it that is divisible by 10 or 5", "language_version_list": {"python": {"code_signature": "from typing import Union\n\n\ndef find_largest_divisible(n: int) -> Union[int, None]:\n    \"\"\"\n    find the largest integer between a given number n and half of it that is divisible by 10 or 5\n    Args:\n        n (int): The upper bound of the range.\n\n    Returns:\n        The largest integer between n and half of n that is divisible by 5, or\n         None if no such number exists.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFindLargestDivisible(unittest.TestCase):\n    def test_typical_case(self):\n        \"\"\"Test with a typical input where the largest divisible number should be found.\"\"\"\n        self.assertEqual(find_largest_divisible(50), 50)\n        self.assertEqual(find_largest_divisible(47), 45)\n\n    def test_no_divisible_found(self):\n        \"\"\"Test a case where no divisible number is found within the range.\"\"\"\n        self.assertIsNone(find_largest_divisible(4))\n\n    def test_exact_half_divisible(self):\n        \"\"\"Test when the half of n is exactly divisible by 5.\"\"\"\n        self.assertEqual(find_largest_divisible(10), 10)\n\n    def test_large_number(self):\n        \"\"\"Test with a large number to ensure performance and correctness.\"\"\"\n        self.assertEqual(find_largest_divisible(1000), 1000)\n\n    def test_lower_bound(self):\n        \"\"\"Test the function with the lowest bound that should find a divisible number.\"\"\"\n        self.assertEqual(find_largest_divisible(5), 5)\n", "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef find_largest_divisible(n: int) -> Union[int, None]:\n    \"\"\"\n    find the largest integer between a given number n and half of it that is divisible by 10 or 5\n    Args:\n        n (int): The upper bound of the range.\n\n    Returns:\n        The largest integer between n and half of n that is divisible by 5, or\n         None if no such number exists.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Finds the largest integer between a given number n and half of it that is divisible by 10 or 5.\n * \n * @param {number} n - The upper bound of the range.\n * @returns {(number | null)} - The largest integer between n and half of n that is divisible by 5, or\n *                              null if no such number exists.\n */\nfunction findLargestDivisible(n) {}", "test_code": "describe('findLargestDivisible', () => {\n    test('test typical case', () => {\n        /** Test with a typical input where the largest divisible number should be found. */\n        expect(findLargestDivisible(50)).toBe(50);\n        expect(findLargestDivisible(47)).toBe(45);\n    });\n\n    test('test no divisible number found', () => {\n        /** Test a case where no divisible number is found within the range. */\n        expect(findLargestDivisible(4)).toBeNull();\n    });\n\n    test('test exact half divisible', () => {\n        /** Test when the half of n is exactly divisible by 5. */\n        expect(findLargestDivisible(10)).toBe(10);\n    });\n\n    test('test large number', () => {\n        /** Test with a large number to ensure performance and correctness. */\n        expect(findLargestDivisible(1000)).toBe(1000);\n    });\n\n    test('test lower bound', () => {\n        /** Test the function with the lowest bound that should find a divisible number. */\n        expect(findLargestDivisible(5)).toBe(5);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Finds the largest integer between a given number n and half of it that is divisible by 10 or 5.\n * \n * @param {number} n - The upper bound of the range.\n * @returns {(number | null)} - The largest integer between n and half of n that is divisible by 5, or\n *                              null if no such number exists.\n */\nfunction findLargestDivisible(n) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Finds the largest integer between a given number `n` and half of it that is divisible by 10 or 5.\n * @param n The upper bound of the range.\n * @returns The largest integer between `n` and half of `n` that is divisible by 5, or `null` if no such number exists.\n */\nfunction findLargestDivisible(n: number): number | null {}", "test_code": "describe('TestFindLargestDivisible', () => {\n    describe('test_typical_case', () => {\n      it('should find the largest divisible number for typical inputs', () => {\n        expect(findLargestDivisible(50)).toBe(50);\n        expect(findLargestDivisible(47)).toBe(45);\n      });\n    });\n  \n    describe('test_no_divisible_found', () => {\n      it('should return null when no divisible number is found', () => {\n        expect(findLargestDivisible(4)).toBeNull();\n      });\n    });\n  \n    describe('test_exact_half_divisible', () => {\n      it('should find the largest divisible number when the half of n is exactly divisible by 5', () => {\n        expect(findLargestDivisible(10)).toBe(10);\n      });\n    });\n  \n    describe('test_large_number', () => {\n      it('should find the largest divisible number for large numbers', () => {\n        expect(findLargestDivisible(1000)).toBe(1000);\n      });\n    });\n  \n    describe('test_lower_bound', () => {\n      it('should find the largest divisible number for the lowest bound', () => {\n        expect(findLargestDivisible(5)).toBe(5);\n      });\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Finds the largest integer between a given number `n` and half of it that is divisible by 10 or 5.\n * @param n The upper bound of the range.\n * @returns The largest integer between `n` and half of `n` that is divisible by 5, or `null` if no such number exists.\n */\nfunction findLargestDivisible(n: number): number | null {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Find the largest integer between a given number n and half of it that is divisible by 10 or 5\n *\n * @param n The upper bound of the range.\n * @return The largest integer between n and half of n that is divisible by 5,\n * or -1 if no such number exists.\n */\nint find_largest_divisible(int n) {\n\n}", "test_code": "TEST_CASE(\"TestFindLargestDivisible\", \"[find_largest_divisible]\") {\n    SECTION(\"test_typical_case\") {\n        // Test with a typical input where the largest divisible number should be found.\n        REQUIRE(find_largest_divisible(50) == 50);\n        REQUIRE(find_largest_divisible(47) == 45);\n    }\n\n    SECTION(\"test_no_divisible_found\") {\n        // Test a case where no divisible number is found within the range.\n        REQUIRE(!find_largest_divisible(4).has_value());\n    }\n\n    SECTION(\"test_exact_half_divisible\") {\n        // Test when the half of n is exactly divisible by 5.\n        REQUIRE(find_largest_divisible(10) == 10);\n    }\n\n    SECTION(\"test_large_number\") {\n        // Test with a large number to ensure performance and correctness.\n        REQUIRE(find_largest_divisible(1000) == 1000);\n    }\n\n    SECTION(\"test_lower_bound\") {\n        // Test the function with the lowest bound that should find a divisible number.\n        REQUIRE(find_largest_divisible(5) == 5);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Find the largest integer between a given number n and half of it that is divisible by 10 or 5\n *\n * @param n The upper bound of the range.\n * @return The largest integer between n and half of n that is divisible by 5,\n * or -1 if no such number exists.\n */\nint find_largest_divisible(int n) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds the largest integer between a given number n and half of it that is divisible by 10 or 5.\n *\n * @param n The upper bound of the range.\n * @return The largest integer between n and half of n that is divisible by 5, or\n *         Optional.empty() if no such number exists.\n */\npublic static Optional<Integer> findLargestDivisible(int n) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\n\nimport java.util.Optional;\n\nimport static org.junit.Assert.*;\nimport static org.real.temp.Answer.*;\n\npublic class Tester {\n\n    @Test\n    public void testTypicalCase() {\n        // Test with a typical input where the largest divisible number should be found.\n        assertEquals(Optional.of(50).get(), findLargestDivisible(50));\n        assertEquals(Optional.of(45).get(), findLargestDivisible(47));\n    }\n\n    @Test\n    public void testNoDivisibleFound() {\n        // Test a case where no divisible number is found within the range.\n        assertTrue(findLargestDivisible(4) ==null);\n    }\n\n    @Test\n    public void testExactHalfDivisible() {\n        // Test when the half of n is exactly divisible by 5.\n        assertEquals(Optional.of(10).get(), findLargestDivisible(10));\n    }\n\n    @Test\n    public void testLargeNumber() {\n        // Test with a large number to ensure performance and correctness.\n        assertEquals(Optional.of(1000).get(), findLargestDivisible(1000));\n    }\n\n    @Test\n    public void testLowerBound() {\n        // Test the function with the lowest bound that should find a divisible number.\n        assertEquals(Optional.of(5).get(), findLargestDivisible(5));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds the largest integer between a given number n and half of it that is divisible by 10 or 5.\n *\n * @param n The upper bound of the range.\n * @return The largest integer between n and half of n that is divisible by 5, or\n *         Optional.empty() if no such number exists.\n */\npublic static Optional<Integer> findLargestDivisible(int n) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 290, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Read the emission probability matrix and the mapping order of amino acids in a given HMM (Hidden Markov Model) file\n", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef rdf_jsonld_to_ngsild(rdf_jsonld: str) -> Dict:\n    \"\"\"\n    convert the question in RDF JSON-LD format to NGSI-LD format\n    Args:\n        rdf_jsonld (str): RDF JSON-LD formatted question as a string.\n\n    Returns:\n        Data formatted according to NGSI-LD specifications.\n    \"\"\"\n", "test_code": "import unittest\nimport json\n\n\nclass TestRDFJSONLDToNGSILDConversion(unittest.TestCase):\n    def test_basic_conversion(self):\n        \"\"\"Test a basic and correct conversion from JSON-LD to NGSI-LD.\"\"\"\n        rdf_jsonld = json.dumps({\n            \"@context\": \"http://schema.org/\",\n            \"@id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"@type\": \"Vehicle\",\n            \"speed\": {\"value\": 60, \"unitCode\": \"KMH\"}\n        })\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"type\": \"Vehicle\",\n            \"@context\": \"http://schema.org/\",\n            \"attributes\": [\n                {\"type\": \"Property\", \"name\": \"speed\", \"value\": {\"value\": 60, \"unitCode\": \"KMH\"}}\n            ]\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n\n    def test_missing_id_and_type(self):\n        \"\"\"Test conversion when @id and @type are missing.\"\"\"\n        rdf_jsonld = json.dumps({\n            \"@context\": \"http://schema.org/\",\n            \"speed\": {\"value\": 60, \"unitCode\": \"KMH\"}\n        })\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:unknown:id\",\n            \"type\": \"UnknownType\",\n            \"@context\": \"http://schema.org/\",\n            \"attributes\": [\n                {\"type\": \"Property\", \"name\": \"speed\", \"value\": {\"value\": 60, \"unitCode\": \"KMH\"}}\n            ]\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n\n    def test_with_nested_objects(self):\n        \"\"\"Test conversion with nested objects.\"\"\"\n        rdf_jsonld = json.dumps({\n            \"@context\": \"http://schema.org/\",\n            \"@id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"@type\": \"Vehicle\",\n            \"location\": {\"latitude\": 48.8566, \"longitude\": 2.3522}\n        })\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"type\": \"Vehicle\",\n            \"@context\": \"http://schema.org/\",\n            \"attributes\": [\n                {\"type\": \"Property\", \"name\": \"location\", \"value\": {\"latitude\": 48.8566, \"longitude\": 2.3522}}\n            ]\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n\n    def test_invalid_json_input(self):\n        \"\"\"Test the function's response to invalid JSON input.\"\"\"\n        rdf_jsonld = \"This is not a valid JSON\"\n        with self.assertRaises(json.JSONDecodeError):\n            rdf_jsonld_to_ngsild(rdf_jsonld)\n\n    def test_empty_jsonld(self):\n        \"\"\"Test the conversion of an empty JSON-LD document.\"\"\"\n        rdf_jsonld = json.dumps({})\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:unknown:id\",\n            \"type\": \"UnknownType\",\n            \"@context\": \"https://schema.lab.fiware.org/ld/context\",\n            \"attributes\": []\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef rdf_jsonld_to_ngsild(rdf_jsonld: str) -> Dict:\n    \"\"\"\n    convert the question in RDF JSON-LD format to NGSI-LD format\n    Args:\n        rdf_jsonld (str): RDF JSON-LD formatted question as a string.\n\n    Returns:\n        Data formatted according to NGSI-LD specifications.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert the question in RDF JSON-LD format to NGSI-LD format\n *\n * @param rdfJsonLd The RDF JSON-LD formatted question as a string.\n * @return A map containing data formatted according to NGSI-LD specifications.\n */\nstd::map<std::string, std::string> rdf_json_ld_to_ngsi_ld(const std::string& rdfJsonLd){\n\n}", "test_code": "TEST_CASE(\"Test RDF JSON-LD to NGSI-LD Conversion\") {\n    SECTION(\"Basic conversion\") {\n        // Test a basic and correct conversion from JSON-LD to NGSI-LD\n        std::string rdf_jsonld = R\"({\"@context\": \"http://schema.org/\", \"@id\": \"urn:ngsi-ld:Vehicle:A123\", \"@type\": \"Vehicle\", \"speed\": {\"value\": 60, \"unitCode\": \"KMH\"}})\";\n        json expected_ngsild = {\n            {\"id\", \"urn:ngsi-ld:Vehicle:A123\"},\n            {\"type\", \"Vehicle\"},\n            {\"@context\", \"http://schema.org/\"},\n            {\"attributes\", json::array({\n                {\"type\", \"Property\"},\n                {\"name\", \"speed\"},\n                {\"value\", json::object({{\"value\", 60}, {\"unitCode\", \"KMH\"}})}\n            })}\n        };\n        json result = rdf_json_ld_to_ngsi_ld(rdf_jsonld);\n        REQUIRE(result == expected_ngsild);\n    }\n\n    SECTION(\"Missing @id and @type\") {\n        // Test conversion when @id and @type are missing\n        std::string rdf_jsonld = R\"({\"@context\": \"http://schema.org/\", \"speed\": {\"value\": 60, \"unitCode\": \"KMH\"}})\";\n        json expected_ngsild = {\n            {\"id\", \"urn:ngsi-ld:unknown:id\"},\n            {\"type\", \"UnknownType\"},\n            {\"@context\", \"http://schema.org/\"},\n            {\"attributes\", json::array({\n                {\"type\", \"Property\"},\n                {\"name\", \"speed\"},\n                {\"value\", json::object({{\"value\", 60}, {\"unitCode\", \"KMH\"}})}\n            })}\n        };\n        json result = rdf_json_ld_to_ngsi_ld(rdf_jsonld);\n        REQUIRE(result == expected_ngsild);\n    }\n\n    SECTION(\"With nested objects\") {\n        // Test conversion with nested objects\n        std::string rdf_jsonld = R\"({\"@context\": \"http://schema.org/\", \"@id\": \"urn:ngsi-ld:Vehicle:A123\", \"@type\": \"Vehicle\", \"location\": {\"latitude\": 48.8566, \"longitude\": 2.3522}})\";\n        json expected_ngsild = {\n            {\"id\", \"urn:ngsi-ld:Vehicle:A123\"},\n            {\"type\", \"Vehicle\"},\n            {\"@context\", \"http://schema.org/\"},\n            {\"attributes\", json::array({\n                {\"type\", \"Property\"},\n                {\"name\", \"location\"},\n                {\"value\", json::object({{\"latitude\", 48.8566}, {\"longitude\", 2.3522}})}\n            })}\n        };\n        json result = rdf_json_ld_to_ngsi_ld(rdf_jsonld);\n        REQUIRE(result == expected_ngsild);\n    }\n\n    SECTION(\"Invalid JSON input\") {\n        // Test the function's response to invalid JSON input\n        std::string rdf_jsonld = \"This is not a valid JSON\";\n        REQUIRE_THROWS_AS(rdf_json_ld_to_ngsi_ld(rdf_jsonld), std::exception);\n    }\n\n    SECTION(\"Empty JSON-LD document\") {\n        // Test the conversion of an empty JSON-LD document\n        std::string rdf_jsonld = R\"({})\";\n        json expected_ngsild = {\n            {\"id\", \"urn:ngsi-ld:unknown:id\"},\n            {\"type\", \"UnknownType\"},\n            {\"@context\", \"https://schema.lab.fiware.org/ld/context\"},\n            {\"attributes\", json::array()}\n        };\n        json result = rdf_json_ld_to_ngsi_ld(rdf_jsonld);\n        REQUIRE(result == expected_ngsild);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert the question in RDF JSON-LD format to NGSI-LD format\n *\n * @param rdfJsonLd The RDF JSON-LD formatted question as a string.\n * @return A map containing data formatted according to NGSI-LD specifications.\n */\nstd::map<std::string, std::string> rdf_json_ld_to_ngsi_ld(const std::string& rdfJsonLd){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts the question in RDF JSON-LD format to NGSI-LD format.\n * \n * @param rdfJsonLd The RDF JSON-LD formatted question as a string.\n * @return A map containing data formatted according to NGSI-LD specifications.\n */\npublic Map<String, Object> rdfJsonldToNgSILD(String rdfJsonLd) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class Tester {\n\n    private static final String DEFAULT_CONTEXT = \"https://schema.lab.fiware.org/ld/context\";\n    private static final String UNKNOWN_ID = \"urn:ngsi-ld:unknown:id\";\n    private static final String UNKNOWN_TYPE = \"UnknownType\";\n\n    private static final ObjectMapper objectMapper = new ObjectMapper();\n\n    /**\n     * Converts the question in RDF JSON-LD format to NGSI-LD format.\n     *\n     * @param rdfJsonLd The RDF JSON-LD formatted question as a string.\n     * @return A map containing data formatted according to NGSI-LD specifications.\n     */\n    public Map<String, Object> rdfJsonldToNgSILD(String rdfJsonLd) {\n        try {\n            if (rdfJsonLd == null || rdfJsonLd.trim().isEmpty()) {\n                throw new IllegalArgumentException(\"Invalid JSON input\");\n            }\n\n            JsonNode jsonNode = objectMapper.readTree(rdfJsonLd);\n            Map<String, Object> rdfJsonLdMap = objectMapper.convertValue(jsonNode, Map.class);\n\n            Map<String, Object> ngsiLd = new HashMap<>();\n            ngsiLd.put(\"id\", rdfJsonLdMap.getOrDefault(\"@id\", UNKNOWN_ID));\n            ngsiLd.put(\"type\", rdfJsonLdMap.getOrDefault(\"@type\", UNKNOWN_TYPE));\n            ngsiLd.put(\"@context\", rdfJsonLdMap.getOrDefault(\"@context\", DEFAULT_CONTEXT));\n            ngsiLd.put(\"attributes\", new ArrayList<>());\n\n            // Assuming simple attribute structure conversion\n            for (Map.Entry<String, Object> entry : rdfJsonLdMap.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n                if (!key.equals(\"@context\") && !key.equals(\"@id\") && !key.equals(\"@type\")) {\n                    Map<String, Object> attribute = new HashMap<>();\n                    attribute.put(\"type\", \"Property\");\n                    attribute.put(\"name\", key);\n                    attribute.put(\"value\", value);\n                    ((List<Map<String, Object>>) ngsiLd.get(\"attributes\")).add(attribute);\n                }\n            }\n\n            return ngsiLd;\n        } catch (JsonProcessingException e) {\n            throw new IllegalArgumentException(\"Invalid JSON input\", e);\n        }\n    }\n\n    @Test\n    public void testBasicConversion() throws JsonProcessingException {\n        String rdfJsonld = objectMapper.writeValueAsString(new HashMap<String, Object>() {{\n            put(\"@context\", \"http://schema.org/\");\n            put(\"@id\", \"urn:ngsi-ld:Vehicle:A123\");\n            put(\"@type\", \"Vehicle\");\n            put(\"speed\", new HashMap<String, Object>() {{\n                put(\"value\", 60);\n                put(\"unitCode\", \"KMH\");\n            }});\n        }});\n\n        Map<String, Object> expectedNgsild = new HashMap<>();\n        expectedNgsild.put(\"id\", \"urn:ngsi-ld:Vehicle:A123\");\n        expectedNgsild.put(\"type\", \"Vehicle\");\n        expectedNgsild.put(\"@context\", \"http://schema.org/\");\n        expectedNgsild.put(\"attributes\", new ArrayList<Map<String, Object>>() {{\n            add(new HashMap<String, Object>() {{\n                put(\"type\", \"Property\");\n                put(\"name\", \"speed\");\n                put(\"value\", new HashMap<String, Object>() {{\n                    put(\"value\", 60);\n                    put(\"unitCode\", \"KMH\");\n                }});\n            }});\n        }});\n\n        Map<String, Object> result = rdfJsonldToNgSILD(rdfJsonld);\n        assertEquals(expectedNgsild, result);\n    }\n\n    @Test\n    public void testMissingIdAndType() throws JsonProcessingException {\n        String rdfJsonld = objectMapper.writeValueAsString(new HashMap<String, Object>() {{\n            put(\"@context\", \"http://schema.org/\");\n            put(\"speed\", new HashMap<String, Object>() {{\n                put(\"value\", 60);\n                put(\"unitCode\", \"KMH\");\n            }});\n        }});\n\n        Map<String, Object> expectedNgsild = new HashMap<>();\n        expectedNgsild.put(\"id\", UNKNOWN_ID);\n        expectedNgsild.put(\"type\", UNKNOWN_TYPE);\n        expectedNgsild.put(\"@context\", \"http://schema.org/\");\n        expectedNgsild.put(\"attributes\", new ArrayList<Map<String, Object>>() {{\n            add(new HashMap<String, Object>() {{\n                put(\"type\", \"Property\");\n                put(\"name\", \"speed\");\n                put(\"value\", new HashMap<String, Object>() {{\n                    put(\"value\", 60);\n                    put(\"unitCode\", \"KMH\");\n                }});\n            }});\n        }});\n\n        Map<String, Object> result = rdfJsonldToNgSILD(rdfJsonld);\n        assertEquals(expectedNgsild, result);\n    }\n\n    @Test\n    public void testWithNestedObjects() throws JsonProcessingException {\n        String rdfJsonld = objectMapper.writeValueAsString(new HashMap<String, Object>() {{\n            put(\"@context\", \"http://schema.org/\");\n            put(\"@id\", \"urn:ngsi-ld:Vehicle:A123\");\n            put(\"@type\", \"Vehicle\");\n            put(\"location\", new HashMap<String, Object>() {{\n                put(\"latitude\", 48.8566);\n                put(\"longitude\", 2.3522);\n            }});\n        }});\n\n        Map<String, Object> expectedNgsild = new HashMap<>();\n        expectedNgsild.put(\"id\", \"urn:ngsi-ld:Vehicle:A123\");\n        expectedNgsild.put(\"type\", \"Vehicle\");\n        expectedNgsild.put(\"@context\", \"http://schema.org/\");\n        expectedNgsild.put(\"attributes\", new ArrayList<Map<String, Object>>() {{\n            add(new HashMap<String, Object>() {{\n                put(\"type\", \"Property\");\n                put(\"name\", \"location\");\n                put(\"value\", new HashMap<String, Object>() {{\n                    put(\"latitude\", 48.8566);\n                    put(\"longitude\", 2.3522);\n                }});\n            }});\n        }});\n\n        Map<String, Object> result = rdfJsonldToNgSILD(rdfJsonld);\n        assertEquals(expectedNgsild, result);\n    }\n\n    @Test\n    public void testInvalidJsonInput() {\n        String rdfJsonld = \"This is not a valid JSON\";\n        assertThrows(IllegalArgumentException.class, () -> rdfJsonldToNgSILD(rdfJsonld));\n    }\n\n    @Test\n    public void testEmptyJsonld() throws JsonProcessingException {\n        String rdfJsonld = objectMapper.writeValueAsString(new HashMap<>());\n\n        Map<String, Object> expectedNgsild = new HashMap<>();\n        expectedNgsild.put(\"id\", UNKNOWN_ID);\n        expectedNgsild.put(\"type\", UNKNOWN_TYPE);\n        expectedNgsild.put(\"@context\", DEFAULT_CONTEXT);\n        expectedNgsild.put(\"attributes\", new ArrayList<>());\n\n        Map<String, Object> result = rdfJsonldToNgSILD(rdfJsonld);\n        assertEquals(expectedNgsild, result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Converts the question in RDF JSON-LD format to NGSI-LD format.\n * \n * @param rdfJsonLd The RDF JSON-LD formatted question as a string.\n * @return A map containing data formatted according to NGSI-LD specifications.\n */\npublic Map<String, Object> rdfJsonldToNgSILD(String rdfJsonLd) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 291, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "appends the specified string to the beginning of each line of the file and then updates the entire file", "language_version_list": {"python": {"code_signature": "def prepend_to_each_line(file_path: str, prefix: str):\n    \"\"\"\n    Appends the specified string to the beginning of each line of the file.\n\n    Args:\n    file_path (str): Path to the file whose lines will be modified.\n    prefix (str): String to append to the beginning of each line.\n    \"\"\"\n", "test_code": "import unittest\nimport os\n\nclass TestPrependToEachLine(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Create a temporary file for testing.\"\"\"\n        self.test_file_path = \"test_file.txt\"\n        with open(self.test_file_path, 'w') as f:\n            f.write(\"Line 1\\nLine 2\\nLine 3\")\n\n    def tearDown(self):\n        \"\"\"Remove the temporary file after testing.\"\"\"\n        os.remove(self.test_file_path)\n\n    def test_prepend_string(self):\n        \"\"\"Test appending a simple string to the beginning of each line.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"Test: \")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"Test: Line 1\\n\", \"Test: Line 2\\n\", \"Test: Line 3\"])\n\n    def test_prepend_empty_string(self):\n        \"\"\"Test appending an empty string.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"\")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"Line 1\\n\", \"Line 2\\n\", \"Line 3\"])\n\n    def test_prepend_special_characters(self):\n        \"\"\"Test appending special characters to the beginning of each line.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"#$%^&* \")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"#$%^&* Line 1\\n\", \"#$%^&* Line 2\\n\", \"#$%^&* Line 3\"])\n\n    def test_prepend_numeric_string(self):\n        \"\"\"Test appending numeric string to the beginning of each line.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"123 \")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"123 Line 1\\n\", \"123 Line 2\\n\", \"123 Line 3\"])\n\n    def test_file_not_found(self):\n        \"\"\"Test the response when the file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            prepend_to_each_line(\"non_existent_file.txt\", \"Test: \")", "prompt": "please write a python function , the function signature as below def prepend_to_each_line(file_path: str, prefix: str):\n    \"\"\"\n    Appends the specified string to the beginning of each line of the file.\n\n    Args:\n    file_path (str): Path to the file whose lines will be modified.\n    prefix (str): String to append to the beginning of each line.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Appends the specified string to the beginning of each line of the file.\n * \n * @param {string} file_path - Path to the file whose lines will be modified.\n * @param {string} prefix - String to append to the beginning of each line.\n */\nasync function prependToEachLine(file_path, prefix) {}", "test_code": "const fs = require('fs').promises;\nconst os = require('os');\ndescribe('TestPrependToEachLine', () => {\n  let testFilePath;\n\n  beforeAll(() => {\n      testFilePath = 'test_file.txt';\n      return fs.writeFile(testFilePath, 'Line 1\\nLine 2\\nLine 3');\n  });\n\n  afterAll(() => {\n      return fs.unlink(testFilePath);\n  });\n\n  it('should prepend a simple string to each line', async () => {\n      await prependToEachLine(testFilePath, 'Test: ');\n      const content = await fs.readFile(testFilePath, 'utf8');\n      const lines = content.split(os.EOL);\n      expect(lines).toEqual(['Test: Line 1', 'Test: Line 2', 'Test: Line 3']);\n  });\n\n  it('should prepend an empty string', async () => {\n      await prependToEachLine(testFilePath, '');\n      const content = await fs.readFile(testFilePath, 'utf8');\n      const lines = content.split(os.EOL);\n      expect(lines).toEqual(['Line 1', 'Line 2', 'Line 3']);\n  });\n\n  it('should prepend special characters to each line', async () => {\n      await prependToEachLine(testFilePath, '#$%^&* ');\n      const content = await fs.readFile(testFilePath, 'utf8');\n      const lines = content.split(os.EOL);\n      expect(lines).toEqual(['#$%^&* Line 1', '#$%^&* Line 2', '#$%^&* Line 3']);\n  });\n\n  it('should prepend a numeric string to each line', async () => {\n      await prependToEachLine(testFilePath, '123 ');\n      const content = await fs.readFile(testFilePath, 'utf8');\n      const lines = content.split(os.EOL);\n      expect(lines).toEqual(['123 Line 1', '123 Line 2', '123 Line 3']);\n  });\n\n  it('should throw an error if the file does not exist', async () => {\n      await expect(prependToEachLine('non_existent_file.txt', 'Test: '))\n          .rejects.toThrowError(/ENOENT/);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Appends the specified string to the beginning of each line of the file.\n * \n * @param {string} file_path - Path to the file whose lines will be modified.\n * @param {string} prefix - String to append to the beginning of each line.\n */\nasync function prependToEachLine(file_path, prefix) {}", "addition_info": ""}, "typescript": {"code_signature": "import fs from 'fs';\nimport path from 'path';\n\n/**\n * Appends the specified string to the beginning of each line of the file.\n * \n * @param file_path - Path to the file whose lines will be modified.\n * @param prefix - String to append to the beginning of each line.\n */\nfunction prependToEachLine(file_path: string, prefix: string): void {}", "test_code": "import fs from 'fs';\nimport path from 'path';\n\ndescribe('prependToEachLine', () => {\n    let testFilePath: string;\n\n    beforeEach(() => {\n        // Create a temporary file for testing\n        testFilePath = 'test_file.txt';\n        fs.writeFileSync(testFilePath, 'Line 1\\nLine 2\\nLine 3');\n    });\n\n    afterEach(() => {\n        // Remove the temporary file after testing\n        fs.unlinkSync(testFilePath);\n    });\n\n    it('should prepend a simple string to the beginning of each line', () => {\n        prependToEachLine(testFilePath, 'Test: ');\n        const lines = fs.readFileSync(testFilePath, 'utf8').split('\\n');\n        expect(lines).toEqual(['Test: Line 1', 'Test: Line 2', 'Test: Line 3']);\n    });\n\n    it('should prepend an empty string', () => {\n        prependToEachLine(testFilePath, '');\n        const lines = fs.readFileSync(testFilePath, 'utf8').split('\\n');\n        expect(lines).toEqual(['Line 1', 'Line 2', 'Line 3']);\n    });\n\n    it('should prepend special characters to the beginning of each line', () => {\n        prependToEachLine(testFilePath, '#$%^&* ');\n        const lines = fs.readFileSync(testFilePath, 'utf8').split('\\n');\n        expect(lines).toEqual(['#$%^&* Line 1', '#$%^&* Line 2', '#$%^&* Line 3']);\n    });\n\n    it('should prepend a numeric string to the beginning of each line', () => {\n        prependToEachLine(testFilePath, '123 ');\n        const lines = fs.readFileSync(testFilePath, 'utf8').split('\\n');\n        expect(lines).toEqual(['123 Line 1', '123 Line 2', '123 Line 3']);\n    });\n\n    it('should throw an error when the file does not exist', () => {\n        expect(() => {\n            prependToEachLine('non_existent_file.txt', 'Test: ');\n        }).toThrow(/ENOENT/); // ENOENT is the error code for file not found\n    });\n});", "prompt": "please write a typescript function , the function signature as below import fs from 'fs';\nimport path from 'path';\n\n/**\n * Appends the specified string to the beginning of each line of the file.\n * \n * @param file_path - Path to the file whose lines will be modified.\n * @param prefix - String to append to the beginning of each line.\n */\nfunction prependToEachLine(file_path: string, prefix: string): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Appends the specified string to the beginning of each line of the file.\n *\n * @param file_path The path to the file whose lines will be modified.\n * @param prefix The string to append to the beginning of each line.\n */\nvoid prepend_to_each_line(const std::string& file_path, const std::string& prefix){\n\n}", "test_code": "TEST_CASE(\"TestPrependToEachLine\") {\n    std::string test_file_path = \"test_file.txt\";\n\n    SECTION(\"setUp\") {\n        // Create a temporary file for testing\n        std::ofstream f(test_file_path);\n        f << \"Line 1\\nLine 2\\nLine 3\";\n        f.close();\n    }\n\n    SECTION(\"tearDown\") {\n        // Remove the temporary file after testing\n        std::filesystem::remove(test_file_path);\n    }\n\n    SECTION(\"test_prepend_string\") {\n        // Test appending a simple string to the beginning of each line\n        prepend_to_each_line(test_file_path, \"Test: \");\n        std::ifstream f(test_file_path);\n        std::string line;\n        std::vector<std::string> lines;\n        while (std::getline(f, line)) {\n            lines.push_back(line + \"\\n\");\n        }\n        f.close();\n        REQUIRE(lines == std::vector<std::string>({\n            \"Test: Line 1\\n\",\n            \"Test: Line 2\\n\",\n            \"Test: Line 3\\n\"\n        }));\n    }\n\n    SECTION(\"test_prepend_empty_string\") {\n        // Test appending an empty string\n        prepend_to_each_line(test_file_path, \"\");\n        std::ifstream f(test_file_path);\n        std::string line;\n        std::vector<std::string> lines;\n        while (std::getline(f, line)) {\n            lines.push_back(line + \"\\n\");\n        }\n        f.close();\n        REQUIRE(lines == std::vector<std::string>({\n            \"Line 1\\n\",\n            \"Line 2\\n\",\n            \"Line 3\\n\"\n        }));\n    }\n\n    SECTION(\"test_prepend_special_characters\") {\n        // Test appending special characters to the beginning of each line\n        prepend_to_each_line(test_file_path, \"#$%^&* \");\n        std::ifstream f(test_file_path);\n        std::string line;\n        std::vector<std::string> lines;\n        while (std::getline(f, line)) {\n            lines.push_back(line + \"\\n\");\n        }\n        f.close();\n        REQUIRE(lines == std::vector<std::string>({\n            \"#$%^&* Line 1\\n\",\n            \"#$%^&* Line 2\\n\",\n            \"#$%^&* Line 3\\n\"\n        }));\n    }\n\n    SECTION(\"test_prepend_numeric_string\") {\n        // Test appending numeric string to the beginning of each line\n        prepend_to_each_line(test_file_path, \"123 \");\n        std::ifstream f(test_file_path);\n        std::string line;\n        std::vector<std::string> lines;\n        while (std::getline(f, line)) {\n            lines.push_back(line + \"\\n\");\n        }\n        f.close();\n        REQUIRE(lines == std::vector<std::string>({\n            \"123 Line 1\\n\",\n            \"123 Line 2\\n\",\n            \"123 Line 3\\n\"\n        }));\n    }\n\n    SECTION(\"test_file_not_found\") {\n        // Test the response when the file does not exist\n        REQUIRE_THROWS_AS(prepend_to_each_line(\"non_existent_file.txt\", \"Test: \"), std::runtime_error);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Appends the specified string to the beginning of each line of the file.\n *\n * @param file_path The path to the file whose lines will be modified.\n * @param prefix The string to append to the beginning of each line.\n */\nvoid prepend_to_each_line(const std::string& file_path, const std::string& prefix){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Appends the specified string to the beginning of each line of the file.\n *\n * @param filePath the path to the file whose lines will be modified\n * @param prefix   the string to append to the beginning of each line\n */\npublic static void prependToEachLine(String filePath, String prefix) {}", "test_code": "package org.real.temp;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n    private File testFile;\n\n    @Before\n    public void setUp() throws IOException {\n        // Create a temporary file for testing\n        testFile = new File(\"test_file.txt\");\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(testFile))) {\n            writer.write(\"Line 1\\n\");\n            writer.write(\"Line 2\\n\");\n            writer.write(\"Line 3\\n\");\n        }\n    }\n\n    @After\n    public void tearDown() {\n        // Remove the temporary file after testing\n        if (testFile.exists()) {\n            testFile.delete();\n        }\n    }\n\n    @Test\n    public void testPrependString() throws IOException {\n        // Test appending a simple string to the beginning of each line\n        prependToEachLine(testFile.getAbsolutePath(), \"Test: \");\n        assertLinesEqual(new String[]{\n                \"Test: Line 1\",\n                \"Test: Line 2\",\n                \"Test: Line 3\"\n        });\n    }\n\n    @Test\n    public void testPrependEmptyString() throws IOException {\n        // Test appending an empty string\n        prependToEachLine(testFile.getAbsolutePath(), \"\");\n        assertLinesEqual(new String[]{\n                \"Line 1\",\n                \"Line 2\",\n                \"Line 3\"\n        });\n    }\n\n    @Test\n    public void testPrependSpecialCharacters() throws IOException {\n        // Test appending special characters to the beginning of each line\n        prependToEachLine(testFile.getAbsolutePath(), \"#$%^&* \");\n        assertLinesEqual(new String[]{\n                \"#$%^&* Line 1\",\n                \"#$%^&* Line 2\",\n                \"#$%^&* Line 3\"\n        });\n    }\n\n    @Test\n    public void testPrependNumericString() throws IOException {\n        // Test appending numeric string to the beginning of each line\n        prependToEachLine(testFile.getAbsolutePath(), \"123 \");\n        assertLinesEqual(new String[]{\n                \"123 Line 1\",\n                \"123 Line 2\",\n                \"123 Line 3\"\n        });\n    }\n\n    @Test\n    public void testFileNotFound() {\n        // Test the response when the file does not exist\n        try {\n            prependToEachLine(\"non_existent_file.txt\", \"Test: \");\n            fail(\"Expected IOException to be thrown\");\n        } catch (Exception e) {\n            // Expected exception\n        }\n    }\n\n    private void assertLinesEqual(String[] expected) throws IOException {\n        try (BufferedReader reader = new BufferedReader(new FileReader(testFile))) {\n            String[] actual = reader.lines().toArray(String[]::new);\n            assertArrayEquals(expected, actual);\n        }\n    }\n\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Appends the specified string to the beginning of each line of the file.\n *\n * @param filePath the path to the file whose lines will be modified\n * @param prefix   the string to append to the beginning of each line\n */\npublic static void prependToEachLine(String filePath, String prefix) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 366, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Extracts text content from a given word file", "language_version_list": {"python": {"code_signature": "from docx import Document\n\ndef extract_text_from_word(docx_file_path):\n    \"\"\"\n    Extracts text content from a given Word file (.docx).\n\n    Args:\n        docx_file_path (str): The path to the Word file.\n\n    Returns:\n        str: The extracted text content.\n    \"\"\"", "test_code": "import unittest\nimport os\nfrom docx import Document\n\n\nclass TestExtractTextFromWord(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up the testing environment.\"\"\"\n        # Create a temporary Word file for testing\n        self.test_docx_path = \"test_document.docx\"\n        self.create_sample_docx()\n\n    def tearDown(self):\n        \"\"\"Clean up the test environment.\"\"\"\n        # Remove created files after tests\n        if os.path.exists(self.test_docx_path):\n            os.remove(self.test_docx_path)\n\n    def create_sample_docx(self):\n        \"\"\"Helper method to create a sample Word document for testing.\"\"\"\n        doc = Document()\n        doc.add_paragraph(\"Hello World!\")\n        doc.add_paragraph(\"This is a test document.\")\n        doc.save(self.test_docx_path)\n\n    def test_extract_text_success(self):\n        \"\"\"Test extracting text from a normal Word document.\"\"\"\n        expected_text = \"Hello World!\\nThis is a test document.\"\n        extracted_text = extract_text_from_word(self.test_docx_path)\n        self.assertEqual(extracted_text.strip(), expected_text)\n\n    def test_extract_empty_document(self):\n        \"\"\"Test extracting text from an empty Word document.\"\"\"\n        empty_docx_path = \"empty_document.docx\"\n        Document().save(empty_docx_path)\n\n        extracted_text = extract_text_from_word(empty_docx_path)\n        self.assertEqual(extracted_text, \"\")  # Expecting an empty string\n\n        os.remove(empty_docx_path)  # Clean up\n\n\n    def test_extract_text_with_special_characters(self):\n        \"\"\"Test extracting text from a document containing special characters.\"\"\"\n        special_docx_path = \"special_characters.docx\"\n        doc = Document()\n        doc.add_paragraph(\"Hello, \u4e16\u754c! @#$%^&*()\")\n        doc.save(special_docx_path)\n\n        extracted_text = extract_text_from_word(special_docx_path)\n        expected_text = \"Hello, \u4e16\u754c! @#$%^&*()\"\n        self.assertEqual(extracted_text.strip(), expected_text)\n\n        os.remove(special_docx_path)  # Clean up\n\n    def test_extract_text_with_multiple_paragraphs(self):\n        \"\"\"Test extracting text from a document with multiple paragraphs.\"\"\"\n        multi_para_docx_path = \"multi_paragraphs.docx\"\n        doc = Document()\n        doc.add_paragraph(\"First paragraph.\")\n        doc.add_paragraph(\"Second paragraph.\")\n        doc.add_paragraph(\"Third paragraph.\")\n        doc.save(multi_para_docx_path)\n\n        extracted_text = extract_text_from_word(multi_para_docx_path)\n        expected_text = \"First paragraph.\\nSecond paragraph.\\nThird paragraph.\"\n        self.assertEqual(extracted_text.strip(), expected_text)\n\n        os.remove(multi_para_docx_path)  # Clean up\n", "prompt": "please write a python function , the function signature as below from docx import Document\n\ndef extract_text_from_word(docx_file_path):\n    \"\"\"\n    Extracts text content from a given Word file (.docx).\n\n    Args:\n        docx_file_path (str): The path to the Word file.\n\n    Returns:\n        str: The extracted text content.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "const { Document } = require('docx');\n\n/**\n * Extracts text content from a given Word file (.docx).\n *\n * @param {string} docxFilePath - The path to the Word file.\n * @returns {Promise<string | null>} A promise that resolves to the extracted text content or null if an error occurs.\n */\nasync function extractTextFromWord(docxFilePath) {}", "test_code": "const { Document } = require('docx');\nconst fs = require('fs');\n\ndescribe('TestExtractTextFromWord', () => {\n    let testDocxPath;\n\n    beforeEach(() => {\n        testDocxPath = \"test_document.docx\";\n        createSampleDocx(testDocxPath);\n    });\n\n    afterEach(() => {\n        if (fs.existsSync(testDocxPath)) {\n            fs.unlinkSync(testDocxPath);\n        }\n    });\n\n    function createSampleDocx(path) {\n        const doc = new Document();\n        doc.addParagraph(\"Hello World!\");\n        doc.addParagraph(\"This is a test document.\");\n        doc.save(path);\n    }\n\n    it('should extract text from a normal Word document', async () => {\n        const expectedText = \"Hello World!\\nThis is a test document.\";\n        const extractedText = await extractTextFromWord(testDocxPath);\n        expect(extractedText.trim()).toEqual(expectedText);\n    });\n\n    it('should extract text from an empty Word document', async () => {\n        const emptyDocxPath = \"empty_document.docx\";\n        new Document().save(emptyDocxPath);\n\n        const extractedText = await extractTextFromWord(emptyDocxPath);\n        expect(extractedText).toEqual(\"\");  // Expecting an empty string\n\n        fs.unlinkSync(emptyDocxPath);  // Clean up\n    });\n\n    it('should extract text from a document containing special characters', async () => {\n        const specialDocxPath = \"special_characters.docx\";\n        const doc = new Document();\n        doc.addParagraph(\"Hello, \u4e16\u754c! @#$%^&*()\");\n        doc.save(specialDocxPath);\n\n        const extractedText = await extractTextFromWord(specialDocxPath);\n        const expectedText = \"Hello, \u4e16\u754c! @#$%^&*()\";\n        expect(extractedText.trim()).toEqual(expectedText);\n\n        fs.unlinkSync(specialDocxPath);  // Clean up\n    });\n\n    it('should extract text from a document with multiple paragraphs', async () => {\n        const multiParaDocxPath = \"multi_paragraphs.docx\";\n        const doc = new Document();\n        doc.addParagraph(\"First paragraph.\");\n        doc.addParagraph(\"Second paragraph.\");\n        doc.addParagraph(\"Third paragraph.\");\n        doc.save(multiParaDocxPath);\n\n        const extractedText = await extractTextFromWord(multiParaDocxPath);\n        const expectedText = \"First paragraph.\\nSecond paragraph.\\nThird paragraph.\";\n        expect(extractedText.trim()).toEqual(expectedText);\n\n        fs.unlinkSync(multiParaDocxPath);  // Clean up\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below const { Document } = require('docx');\n\n/**\n * Extracts text content from a given Word file (.docx).\n *\n * @param {string} docxFilePath - The path to the Word file.\n * @returns {Promise<string | null>} A promise that resolves to the extracted text content or null if an error occurs.\n */\nasync function extractTextFromWord(docxFilePath) {}", "addition_info": ""}, "typescript": {"code_signature": "import { Document } from 'docx';\n\n/**\n * Extracts text content from a given Word file (.docx).\n * \n * @param docxFilePath - The path to the Word file.\n * @returns The extracted text content or null if an error occurs.\n */\nfunction extractTextFromWord(docxFilePath: string): string | null {}", "test_code": "import { Document } from 'docx';\n\ndescribe('TestExtractTextFromWord', () => {\n  let testDocxPath: string;\n\n  beforeEach(() => {\n    // Set up the testing environment\n    testDocxPath = 'test_document.docx';\n    createSampleDocx();\n  });\n\n  afterEach(() => {\n    // Clean up the test environment\n    if (require('fs').existsSync(testDocxPath)) {\n      require('fs').unlinkSync(testDocxPath);\n    }\n  });\n\n  function createSampleDocx() {\n    // Helper method to create a sample Word document for testing\n    const doc = new Document();\n    doc.addParagraph('Hello World!');\n    doc.addParagraph('This is a test document.');\n    doc.save(testDocxPath);\n  }\n\n  it('should extract text from a normal Word document', () => {\n    const expectedText = 'Hello World!\\nThis is a test document.';\n    const extractedText = extractTextFromWord(testDocxPath);\n    expect(extractedText.trim()).toEqual(expectedText);\n  });\n\n  it('should extract text from an empty Word document', () => {\n    const emptyDocxPath = 'empty_document.docx';\n    new Document().save(emptyDocxPath);\n\n    const extractedText = extractTextFromWord(emptyDocxPath);\n    expect(extractedText).toEqual('');\n\n    require('fs').unlinkSync(emptyDocxPath); // Clean up\n  });\n\n  it('should extract text from a document containing special characters', () => {\n    const specialDocxPath = 'special_characters.docx';\n    const doc = new Document();\n    doc.addParagraph('Hello, \u4e16\u754c! @#$%^&*()');\n    doc.save(specialDocxPath);\n\n    const extractedText = extractTextFromWord(specialDocxPath);\n    const expectedText = 'Hello, \u4e16\u754c! @#$%^&*()';\n    expect(extractedText.trim()).toEqual(expectedText);\n\n    require('fs').unlinkSync(specialDocxPath); // Clean up\n  });\n\n  it('should extract text from a document with multiple paragraphs', () => {\n    const multiParaDocxPath = 'multi_paragraphs.docx';\n    const doc = new Document();\n    doc.addParagraph('First paragraph.');\n    doc.addParagraph('Second paragraph.');\n    doc.addParagraph('Third paragraph.');\n    doc.save(multiParaDocxPath);\n\n    const extractedText = extractTextFromWord(multiParaDocxPath);\n    const expectedText = 'First paragraph.\\nSecond paragraph.\\nThird paragraph.';\n    expect(extractedText.trim()).toEqual(expectedText);\n\n    require('fs').unlinkSync(multiParaDocxPath); // Clean up\n  });\n});", "prompt": "please write a typescript function , the function signature as below import { Document } from 'docx';\n\n/**\n * Extracts text content from a given Word file (.docx).\n * \n * @param docxFilePath - The path to the Word file.\n * @returns The extracted text content or null if an error occurs.\n */\nfunction extractTextFromWord(docxFilePath: string): string | null {}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 369, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "solve the Eight Queens problem, if a solution is found, it will print out the configuration of the chessboard. If all queens cannot be placed, print \"No solution\"", "language_version_list": {"python": {"code_signature": "def eight_queens():\n    \"\"\"\n    solve the Eight Queens problem, if a solution is found, it will print out the configuration of the chessboard. If all queens cannot be placed, print \"No solution\"\n    print example as below:\n    . . Q . . . . .\n    . . . . Q . . .\n    . Q . . . . . .\n    . . . . . . . Q\n    . . . . . Q . .\n    . . . Q . . . .\n    . . . . . . Q .\n    Q . . . . . . .\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\nfrom unittest.mock import patch\nfrom io import StringIO\n\n\nclass TestEightQueens(unittest.TestCase):\n    def setUp(self):\n        self.board = [['.' for _ in range(8)] for _ in range(8)]\n\n    def test_solution_exists(self):\n        with patch('sys.stdout', new_callable=StringIO) as fake_out:\n            eight_queens()\n            self.assertTrue(\"Q\" in fake_out.getvalue(), \"The board should contain at least one queen.\")\n\n    def test_correct_number_of_queens(self):\n        with patch('sys.stdout', new_callable=StringIO) as fake_out:\n            eight_queens()\n            output = fake_out.getvalue().strip().split('\\n\\n')  # Split the output into blocks for each board\n            for board in output:\n                # Count number of 'Q's in each board\n                num_queens = board.count('Q')\n                self.assertEqual(num_queens, 8, \"Each board should contain exactly 8 queens.\")\n\n    def test_no_solution_scenario(self):\n        # As the Eight Queens always has a solution for an 8x8 board,\n        # to test the 'No solution' output we need a scenario where no solution exists.\n        # We will manipulate the board to a smaller size where no solution is possible.\n        # Here we consider a 3x3 board for simplicity.\n        def no_solution_queens():\n            board = [['.' for _ in range(3)] for _ in range(3)]\n            if not solve_queens(board, 0):\n                print(\"No solution\")\n\n        with patch('sys.stdout', new_callable=StringIO) as fake_out:\n            no_solution_queens()\n            self.assertIn(\"No solution\", fake_out.getvalue(), \"Should print 'No solution' when no solution exists.\")\n", "prompt": "please write a python function , the function signature as below def eight_queens():\n    \"\"\"\n    solve the Eight Queens problem, if a solution is found, it will print out the configuration of the chessboard. If all queens cannot be placed, print \"No solution\"\n    print example as below:\n    . . Q . . . . .\n    . . . . Q . . .\n    . Q . . . . . .\n    . . . . . . . Q\n    . . . . . Q . .\n    . . . Q . . . .\n    . . . . . . Q .\n    Q . . . . . . .\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Solves the Eight Queens problem. If a solution is found, it will print out the configuration of the chessboard.\n * If all queens cannot be placed, it will print \"No solution\".\n * Example output:\n * . . Q . . . . .\n * . . . . Q . . .\n * . Q . . . . . .\n * . . . . . . . Q\n * . . . . . Q . .\n * . . . Q . . . .\n * . . . . . . Q .\n * Q . . . . . . .\n */\nfunction eightQueens() {}", "test_code": "describe('TestEightQueens', () => {\n  beforeEach(() => {\n      // Setup any common state here if needed\n  });\n\n  describe('test_solution_exists', () => {\n      it('should contain at least one queen', () => {\n          const fakeOut = { data: '' };\n          const writeMock = (chunk) => {\n              fakeOut.data += chunk;\n          };\n\n          const originalConsoleLog = console.log;\n          console.log = writeMock;\n\n          eightQueens();\n\n          expect(fakeOut.data.includes('Q')).toBe(true);\n\n          console.log = originalConsoleLog;\n      });\n  });\n\n  describe('test_correct_number_of_queens', () => {\n      it('each board should contain exactly 8 queens', () => {\n          const fakeOut = { data: '' };\n          const writeMock = (chunk) => {\n              fakeOut.data += chunk;\n          };\n\n          const originalConsoleLog = console.log;\n          console.log = writeMock;\n\n          eightQueens();\n\n          const output = fakeOut.data.trim().split('\\n\\n');\n          for (const board of output) {\n              const numQueens = (board.match(/Q/g) || []).length;\n              expect(numQueens).toEqual(8);\n          }\n\n          console.log = originalConsoleLog;\n      });\n  });\n\n  describe('test_no_solution_scenario', () => {\n      it('should print \"No solution\" when no solution exists', () => {\n          const fakeOut = { data: '' };\n          const writeMock = (chunk) => {\n              fakeOut.data += chunk;\n          };\n\n          const originalConsoleLog = console.log;\n          console.log = writeMock;\n\n          function noSolutionQueens() {\n              const board = Array.from({ length: 3 }, () => Array(3).fill('.'));\n              if (!solveQueens(board, 0)) {\n                  console.log(\"No solution\");\n              }\n          }\n\n          noSolutionQueens();\n\n          expect(fakeOut.data.includes('No solution')).toBe(true);\n\n          console.log = originalConsoleLog;\n      });\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Solves the Eight Queens problem. If a solution is found, it will print out the configuration of the chessboard.\n * If all queens cannot be placed, it will print \"No solution\".\n * Example output:\n * . . Q . . . . .\n * . . . . Q . . .\n * . Q . . . . . .\n * . . . . . . . Q\n * . . . . . Q . .\n * . . . Q . . . .\n * . . . . . . Q .\n * Q . . . . . . .\n */\nfunction eightQueens() {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Solves the Eight Queens problem. If a solution is found, it will print out the configuration of the chessboard.\n * If all queens cannot be placed, it prints \"No solution\".\n * \n * Example output:\n * \n * . . Q . . . . .\n * . . . . Q . . .\n * . Q . . . . . .\n * . . . . . . . Q\n * . . . . . Q . .\n * . . . Q . . . .\n * . . . . . . Q .\n * Q . . . . . . .\n */\nfunction eightQueens(): void {}", "test_code": "describe('TestEightQueens', () => {\n  beforeEach(() => {\n      // Setup can be done here if needed\n  });\n\n  it('should contain at least one queen', () => {\n      const originalConsoleLog = console.log;\n      let fakeOut = '';\n\n      // Mock console.log to capture output\n      console.log = jest.fn((output) => {\n          fakeOut += output;\n      });\n\n      eightQueens();\n\n      // Restore original console.log\n      console.log = originalConsoleLog;\n\n      expect(fakeOut.includes('Q')).toBe(true, 'The board should contain at least one queen.');\n  });\n\n  it('should contain exactly 8 queens', () => {\n      const originalConsoleLog = console.log;\n      let fakeOut = '';\n\n      // Mock console.log to capture output\n      console.log = jest.fn((output) => {\n          fakeOut += output;\n      });\n\n      eightQueens();\n\n      // Restore original console.log\n      console.log = originalConsoleLog;\n\n      const boards = fakeOut.trim().split('\\n\\n'); // Split the output into blocks for each board\n      for (const board of boards) {\n          const numQueens = (board.match(/Q/g) || []).length;\n          expect(numQueens).toBe(8, 'Each board should contain exactly 8 queens.');\n      }\n  });\n\n  it('should print \"No solution\" when no solution exists', () => {\n      const originalConsoleLog = console.log;\n      let fakeOut = '';\n\n      // Define a function that simulates a scenario with no solution\n      function noSolutionQueens() {\n          const board: string[][] = Array.from({ length: 3 }, () => Array(3).fill('.'));\n          if (!solveQueens(board, 0)) {\n              console.log(\"No solution\");\n          }\n      }\n\n      // Mock console.log to capture output\n      console.log = jest.fn((output) => {\n          fakeOut += output;\n      });\n\n      noSolutionQueens();\n\n      // Restore original console.log\n      console.log = originalConsoleLog;\n\n      expect(fakeOut.includes('No solution')).toBe(true, 'Should print \"No solution\" when no solution exists.');\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Solves the Eight Queens problem. If a solution is found, it will print out the configuration of the chessboard.\n * If all queens cannot be placed, it prints \"No solution\".\n * \n * Example output:\n * \n * . . Q . . . . .\n * . . . . Q . . .\n * . Q . . . . . .\n * . . . . . . . Q\n * . . . . . Q . .\n * . . . Q . . . .\n * . . . . . . Q .\n * Q . . . . . . .\n */\nfunction eightQueens(): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Solve the Eight Queens problem, if a solution is found, it will print out the configuration of the chessboard.\n * If all queens cannot be placed, print \"No solution\".\n *\n * Print example as follows:\n * . . Q . . . . .\n * . . . . Q . . .\n * . Q . . . . . .\n * . . . . . . . Q\n * . . . . . Q . .\n * . . . Q . . . .\n * . . . . . . Q .\n * Q . . . . . . .\n */\nvoid eightQueens();", "test_code": "TEST_CASE(\"Test Eight Queens Problem\") {\n    SECTION(\"Test Solution Exists\") {\n        std::ostringstream out;\n        {\n            std::streambuf* prevcoutbuf = std::cout.rdbuf(out.rdbuf());\n            eightQueens();\n            std::cout.rdbuf(prevcoutbuf);\n        }\n\n        REQUIRE(out.str().find(\"Q\") != std::string::npos);\n    }\n\n    SECTION(\"Test Correct Number of Queens\") {\n        std::ostringstream out;\n        {\n            std::streambuf* prevcoutbuf = std::cout.rdbuf(out.rdbuf());\n            eightQueens();\n            std::cout.rdbuf(prevcoutbuf);\n        }\n\n        std::istringstream iss(out.str());\n        std::string line;\n        while (std::getline(iss, line)) {\n            int numQueens = std::count(line.begin(), line.end(), 'Q');\n            REQUIRE(numQueens == 8);\n        }\n    }\n\n    SECTION(\"Test No Solution Scenario\") {\n        std::ostringstream out;\n        {\n            std::streambuf* prevcoutbuf = std::cout.rdbuf(out.rdbuf());\n            noSolutionQueens();\n            std::cout.rdbuf(prevcoutbuf);\n        }\n\n        REQUIRE(out.str().find(\"No solution\") != std::string::npos);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Solve the Eight Queens problem, if a solution is found, it will print out the configuration of the chessboard.\n * If all queens cannot be placed, print \"No solution\".\n *\n * Print example as follows:\n * . . Q . . . . .\n * . . . . Q . . .\n * . Q . . . . . .\n * . . . . . . . Q\n * . . . . . Q . .\n * . . . Q . . . .\n * . . . . . . Q .\n * Q . . . . . . .\n */\nvoid eightQueens();", "addition_info": ""}, "java": {"code_signature": "/**\n * Solve the Eight Queens problem. If a solution is found, it will print out the configuration of the chessboard.\n * If all queens cannot be placed, it will print \"No solution\".\n *\n * Print example:\n * . . Q . . . . .\n * . . . . Q . . .\n * . Q . . . . . .\n * . . . . . . . Q\n * . . . . . Q . .\n * . . . Q . . . .\n * . . . . . . Q .\n * Q . . . . . . .\n */\npublic static void eightQueens() {}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\nimport static org.junit.Assert.*;\n\n/**\n * Test class for the Eight Queens problem.\n */\npublic class Tester {\n\n    private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();\n    private PrintStream originalOut;\n\n    @Before\n    public void setUp() {\n        originalOut = System.out; // Save the original System.out\n        System.setOut(new PrintStream(outContent));\n    }\n\n    @Test\n    public void testSolutionExists() {\n        eightQueens();\n        String output = outContent.toString();\n        assertTrue(\"The board should contain at least one queen.\", output.contains(\"Q\"));\n    }\n\n    @Test\n    public void testCorrectNumberOfQueens() {\n        eightQueens();\n        String output = outContent.toString().strip().split(\"\\n\\n\")[0]; // Split the output into blocks for each board\n        int numQueens = output.split(\"\\n\").length; // Assuming each board is printed on separate lines\n        assertEquals(\"Each board should contain exactly 8 queens.\", 8, numQueens);\n    }\n\n    @Test\n    public void testNoSolutionScenario() {\n        noSolutionQueens();\n        String output = outContent.toString();\n        assertTrue(\"Should print 'No solution' when no solution exists.\", output.contains(\"No solution\"));\n    }\n\n    private void eightQueens() {\n        char[][] board = new char[8][8];\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                board[i][j] = '.';\n            }\n        }\n        if (!solveQueens(board, 0)) {\n            System.out.println(\"No solution\");\n        }\n    }\n\n    private void noSolutionQueens() {\n        char[][] board = new char[3][3];\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                board[i][j] = '.';\n            }\n        }\n        if (!solveQueens(board, 0)) {\n            System.out.println(\"No solution\");\n        }\n    }\n\n    private boolean solveQueens(char[][] board, int col) {\n        // Base case: If all queens are placed\n        if (col >= board.length) {\n            printBoard(board);\n            return true;\n        }\n\n        // Consider this column and try placing this queen in all rows one by one\n        boolean solutionFound = false;\n        for (int i = 0; i < board.length; i++) {\n            if (isSafe(board, i, col)) {\n                board[i][col] = 'Q';\n                if (solveQueens(board, col + 1)) {\n                    solutionFound = true;\n                }\n                board[i][col] = '.';  // Backtrack\n            }\n        }\n\n        return solutionFound;\n    }\n\n    private void printBoard(char[][] board) {\n        for (char[] row : board) {\n            System.out.println(new String(row).replace('.', ' ').trim());\n        }\n        System.out.println();\n    }\n\n    private boolean isSafe(char[][] board, int row, int col) {\n        // Check this row on the left side\n        for (int i = 0; i < col; i++) {\n            if (board[row][i] == 'Q') {\n                return false;\n            }\n        }\n\n        // Check upper diagonal on the left side\n        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] == 'Q') {\n                return false;\n            }\n        }\n\n        // Check lower diagonal on the left side\n        for (int i = row, j = col; i < board.length && j >= 0; i++, j--) {\n            if (board[i][j] == 'Q') {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Solve the Eight Queens problem. If a solution is found, it will print out the configuration of the chessboard.\n * If all queens cannot be placed, it will print \"No solution\".\n *\n * Print example:\n * . . Q . . . . .\n * . . . . Q . . .\n * . Q . . . . . .\n * . . . . . . . Q\n * . . . . . Q . .\n * . . . Q . . . .\n * . . . . . . Q .\n * Q . . . . . . .\n */\npublic static void eightQueens() {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 370, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Convert the index of a one-dimensional array to the index of the corresponding multi-dimensional array\n", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef decompose(n: int, shape: Tuple) -> Tuple:\n    \"\"\"\n    Decompose a flat index `n` into a multidimensional index based on the given shape.\n\n    Args:\n        n: Flat index (non-negative integer).\n        shape: Tuple representing the dimensions of the multi-dimensional array.\n\n    Returns:\n        Tuple: Tuple representing the multidimensional index corresponding to `n`.\n    Raises:\n        ValueError: If `n` is out of bounds for the array defined by `shape`.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestDecomposeFunction(unittest.TestCase):\n\n    def test_edge_case_with_larger_shap(self):\n        self.assertEqual(decompose(60, (4, 4, 4)), (3, 3, 0))\n\n    def test_last_valid_index(self):\n        self.assertEqual(decompose(63, (4, 4, 4)), (3, 3, 3))\n\n    def test_single_dimension_case(self):\n        self.assertEqual(decompose(2, (5,)), (2,))\n\n    def test_invalid_cases(self):\n        # Test case 5: Out of bounds case (negative index)\n        with self.assertRaises(ValueError):\n            decompose(-1, (3, 4, 5))\n\n        # Test case 6: Out of bounds case (index too large)\n        with self.assertRaises(ValueError):\n            decompose(100, (3, 4, 5))\n", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef decompose(n: int, shape: Tuple) -> Tuple:\n    \"\"\"\n    Decompose a flat index `n` into a multidimensional index based on the given shape.\n\n    Args:\n        n: Flat index (non-negative integer).\n        shape: Tuple representing the dimensions of the multi-dimensional array.\n\n    Returns:\n        Tuple: Tuple representing the multidimensional index corresponding to `n`.\n    Raises:\n        ValueError: If `n` is out of bounds for the array defined by `shape`.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Decompose a flat index `n` into a multidimensional index based on the given shape.\n *\n * @param {number} n - Flat index (non-negative integer).\n * @param {Array<number>} shape - Array representing the dimensions of the multi-dimensional array.\n * @returns {Array<number>} - Array representing the multidimensional index corresponding to `n`.\n * @throws {Error} - If `n` is out of bounds for the array defined by `shape`.\n */\nfunction decompose(n, shape) {}", "test_code": "describe('TestDecomposeFunction', () => {\n  it('should handle edge case with larger shape', () => {\n      expect(decompose(60, [4, 4, 4])).toEqual([3, 3, 0]);\n  });\n\n  it('should handle the last valid index', () => {\n      expect(decompose(63, [4, 4, 4])).toEqual([3, 3, 3]);\n  });\n\n  it('should handle single dimension case', () => {\n      expect(decompose(2, [5])).toEqual([2]);\n  });\n\n  it('should throw an error for invalid cases', () => {\n      // Test case 5: Out of bounds case (negative index)\n      expect(() => decompose(-1, [3, 4, 5])).toThrow('Index out of bounds');\n\n      // Test case 6: Out of bounds case (index too large)\n      expect(() => decompose(100, [3, 4, 5])).toThrow('Index out of bounds');\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Decompose a flat index `n` into a multidimensional index based on the given shape.\n *\n * @param {number} n - Flat index (non-negative integer).\n * @param {Array<number>} shape - Array representing the dimensions of the multi-dimensional array.\n * @returns {Array<number>} - Array representing the multidimensional index corresponding to `n`.\n * @throws {Error} - If `n` is out of bounds for the array defined by `shape`.\n */\nfunction decompose(n, shape) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Decompose a flat index `n` into a multidimensional index based on the given shape.\n *\n * @param n - Flat index (non-negative integer).\n * @param shape - Tuple representing the dimensions of the multi-dimensional array.\n * @returns A tuple representing the multidimensional index corresponding to `n`.\n * @throws {Error} If `n` is out of bounds for the array defined by `shape`.\n */\nfunction decompose(n: number, shape: number[]): [number, ...number[]] {}", "test_code": "describe('TestDecomposeFunction', () => {\n  it('should handle edge case with larger shape', () => {\n    expect(decompose(60, [4, 4, 4])).toEqual([3, 3, 0]);\n  });\n\n  it('should handle the last valid index', () => {\n    expect(decompose(63, [4, 4, 4])).toEqual([3, 3, 3]);\n  });\n\n  it('should handle single dimension case', () => {\n    expect(decompose(2, [5])).toEqual([2]);\n  });\n\n  it('should throw an error for invalid cases', () => {\n    // Test case 5: Out of bounds case (negative index)\n    expect(() => decompose(-1, [3, 4, 5])).toThrow('Index out of bounds');\n\n    // Test case 6: Out of bounds case (index too large)\n    expect(() => decompose(100, [3, 4, 5])).toThrow('Index out of bounds');\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Decompose a flat index `n` into a multidimensional index based on the given shape.\n *\n * @param n - Flat index (non-negative integer).\n * @param shape - Tuple representing the dimensions of the multi-dimensional array.\n * @returns A tuple representing the multidimensional index corresponding to `n`.\n * @throws {Error} If `n` is out of bounds for the array defined by `shape`.\n */\nfunction decompose(n: number, shape: number[]): [number, ...number[]] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Decompose a flat index `n` into a multidimensional index based on the given shape.\n *\n * @param n Flat index (non-negative integer).\n * @param shape Tuple representing the dimensions of the multi-dimensional array.\n * @return std::tuple Decomposed multidimensional index corresponding to `n`.\n * @throw std::out_of_range If `n` is out of bounds for the array defined by `shape`.\n */\nstd::tuple<int, int> decompose(int n, const std::tuple<int, int>& shape){\n\n}", "test_code": "TEST_CASE(\"Test Decompose Function\", \"[decompose]\") {\n    SECTION(\"Edge case with larger shape\") {\n        REQUIRE(decompose(60, {4, 4, 4}) == std::make_tuple(3, 3, 0));\n    }\n\n    SECTION(\"Last valid index\") {\n        REQUIRE(decompose(63, {4, 4, 4}) == std::make_tuple(3, 3, 3));\n    }\n\n    SECTION(\"Single dimension case\") {\n        REQUIRE(decompose(2, {5}) == std::make_tuple(2));\n    }\n\n    SECTION(\"Invalid cases\") {\n        // Test case 5: Out of bounds case (negative index)\n        REQUIRE_THROWS_AS(decompose(-1, {3, 4, 5}), std::out_of_range);\n\n        // Test case 6: Out of bounds case (index too large)\n        REQUIRE_THROWS_AS(decompose(100, {3, 4, 5}), std::out_of_range);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Decompose a flat index `n` into a multidimensional index based on the given shape.\n *\n * @param n Flat index (non-negative integer).\n * @param shape Tuple representing the dimensions of the multi-dimensional array.\n * @return std::tuple Decomposed multidimensional index corresponding to `n`.\n * @throw std::out_of_range If `n` is out of bounds for the array defined by `shape`.\n */\nstd::tuple<int, int> decompose(int n, const std::tuple<int, int>& shape){\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Decompose a flat index `n` into a multidimensional index based on the given shape.\n *\n * @param n     Flat index (non-negative integer).\n * @param shape Array representing the dimensions of the multi-dimensional array.\n * @return List<Integer>: List representing the multidimensional index corresponding to `n`.\n * @throws IllegalArgumentException If `n` is out of bounds for the array defined by `shape`.\n */\npublic static List<Integer> decompose(int n, int[] shape) {}", "test_code": "package org.real.temp;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    /**\n     * Test edge case with a larger shape.\n     */\n    @Test\n    public void testEdgeCaseWithLargerShape() {\n        assertEquals(\"[3, 3, 0]\", decompose(60, new int[]{4, 4, 4}).toString());\n    }\n\n    /**\n     * Test the last valid index.\n     */\n    @Test\n    public void testLastValidIndex() {\n        assertEquals(\"[3, 3, 3]\", decompose(63, new int[]{4, 4, 4}).toString());\n    }\n\n    /**\n     * Test single dimension case.\n     */\n    @Test\n    public void testSingleDimensionCase() {\n        assertEquals(\"[2]\", decompose(2, new int[]{5}).toString());\n    }\n\n    /**\n     * Test invalid cases.\n     */\n    @Test\n    public void testInvalidCases() {\n        // Test case 5: Out of bounds case (negative index)\n        assertThrows(IllegalArgumentException.class, () -> decompose(-1, new int[]{3, 4, 5}));\n\n        // Test case 6: Out of bounds case (index too large)\n        assertThrows(IllegalArgumentException.class, () -> decompose(100, new int[]{3, 4, 5}));\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Decompose a flat index `n` into a multidimensional index based on the given shape.\n *\n * @param n     Flat index (non-negative integer).\n * @param shape Array representing the dimensions of the multi-dimensional array.\n * @return List<Integer>: List representing the multidimensional index corresponding to `n`.\n * @throws IllegalArgumentException If `n` is out of bounds for the array defined by `shape`.\n */\npublic static List<Integer> decompose(int n, int[] shape) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 380, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Calculate the total number of seconds based on combinations of different time units (days, hours, minutes, seconds)\n", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\n\ndef calculate_total_seconds(time: Tuple[int]):\n    \"\"\"\n    Calculate the total number of seconds given a tuple or list of time periods in the order of\n    days, hours, minutes, and seconds.\n\n    :param time: tuple or list, where\n        time[0] - number of days (optional)\n        time[1] - number of hours (optional)\n        time[2] - number of minutes (optional)\n        time[3] - number of seconds (optional)\n    :return: int, total number of seconds\n\n    Examples:\n        calculate_total_seconds([1, 2, 3, 4]) returns 93784\n        calculate_total_seconds([0, 2, 3]) returns 7380\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestCalculateTotalSeconds(unittest.TestCase):\n\n    def test_complete_time(self):\n        # Test with full values provided for days, hours, minutes, and seconds\n        time = [1, 2, 3, 4]  # 1 day, 2 hours, 3 minutes, 4 seconds\n        expected = 93784\n        result = calculate_total_seconds(time)\n        self.assertEqual(result, expected)\n\n    def test_partial_time(self):\n        # Test with some values missing (assumed trailing zeros)\n        time = [0, 2, 3]  # 0 days, 2 hours, 3 minutes\n        expected = 7380\n        result = calculate_total_seconds(time)\n        self.assertEqual(result, expected)\n\n    def test_seconds_only(self):\n        # Test with only seconds provided\n        time = [7200]  # 7200 seconds\n        expected = 622080000\n        result = calculate_total_seconds(time)\n        self.assertEqual(result, expected)\n\n    def test_no_time(self):\n        # Test with no time values provided\n        time = []\n        expected = 0\n        result = calculate_total_seconds(time)\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef calculate_total_seconds(time: Tuple[int]):\n    \"\"\"\n    Calculate the total number of seconds given a tuple or list of time periods in the order of\n    days, hours, minutes, and seconds.\n\n    :param time: tuple or list, where\n        time[0] - number of days (optional)\n        time[1] - number of hours (optional)\n        time[2] - number of minutes (optional)\n        time[3] - number of seconds (optional)\n    :return: int, total number of seconds\n\n    Examples:\n        calculate_total_seconds([1, 2, 3, 4]) returns 93784\n        calculate_total_seconds([0, 2, 3]) returns 7380\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculate the total number of seconds given an array of time periods in the order of\n * days, hours, minutes, and seconds.\n *\n * @param {Array<number>=} time - An array where\n *   time[0] - number of days (optional)\n *   time[1] - number of hours (optional)\n *   time[2] - number of minutes (optional)\n *   time[3] - number of seconds (optional)\n * @returns {number} - The total number of seconds\n *\n * @example\n * calculateTotalSeconds([1, 2, 3, 4]); // returns 93784\n * calculateTotalSeconds([0, 2, 3]); // returns 7380\n */\nfunction calculateTotalSeconds(time = [0, 0, 0, 0]) {}", "test_code": "describe('TestCalculateTotalSeconds', () => {\n  describe('test_complete_time', () => {\n      it('should correctly calculate total seconds with full values', () => {\n          const time = [1, 2, 3, 4];  // 1 day, 2 hours, 3 minutes, 4 seconds\n          const expected = 93784;\n          const result = calculateTotalSeconds(time);\n          expect(result).toBe(expected);\n      });\n  });\n\n  describe('test_partial_time', () => {\n      it('should correctly calculate total seconds with partial values', () => {\n          const time = [0, 2, 3];  // 0 days, 2 hours, 3 minutes\n          const expected = 7380;\n          const result = calculateTotalSeconds(time);\n          expect(result).toBe(expected);\n      });\n  });\n\n  describe('test_seconds_only', () => {\n      it('should correctly calculate total seconds with only seconds provided', () => {\n          const time = [7200];  // 7200 seconds\n          const expected = 7200;\n          const result = calculateTotalSeconds(time);\n          expect(result).toBe(expected);\n      });\n  });\n\n  describe('test_no_time', () => {\n      it('should correctly calculate total seconds with no time values provided', () => {\n          const time = [];\n          const expected = 0;\n          const result = calculateTotalSeconds(time);\n          expect(result).toBe(expected);\n      });\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculate the total number of seconds given an array of time periods in the order of\n * days, hours, minutes, and seconds.\n *\n * @param {Array<number>=} time - An array where\n *   time[0] - number of days (optional)\n *   time[1] - number of hours (optional)\n *   time[2] - number of minutes (optional)\n *   time[3] - number of seconds (optional)\n * @returns {number} - The total number of seconds\n *\n * @example\n * calculateTotalSeconds([1, 2, 3, 4]); // returns 93784\n * calculateTotalSeconds([0, 2, 3]); // returns 7380\n */\nfunction calculateTotalSeconds(time = [0, 0, 0, 0]) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculate the total number of seconds given a tuple or array of time periods in the order of\n * days, hours, minutes, and seconds.\n *\n * @param time - A tuple or array where:\n *   - time[0] - number of days (optional)\n *   - time[1] - number of hours (optional)\n *   - time[2] - number of minutes (optional)\n *   - time[3] - number of seconds (optional)\n * @returns The total number of seconds.\n *\n * Examples:\n *   calculateTotalSeconds([1, 2, 3, 4]) returns 93784\n *   calculateTotalSeconds([0, 2, 3]) returns 7380\n */\nfunction calculateTotalSeconds(time: [number, number?, number?, number?]): number {}", "test_code": "describe('TestCalculateTotalSeconds', () => {\n    it('should calculate total seconds with full values provided', () => {\n        // Test with full values provided for days, hours, minutes, and seconds\n        const time = [1, 2, 3, 4];  // 1 day, 2 hours, 3 minutes, 4 seconds\n        const expected = 93784;\n        const result = calculateTotalSeconds(time);\n        expect(result).toBe(expected);\n    });\n\n    it('should calculate total seconds with some values missing', () => {\n        // Test with some values missing (assumed trailing zeros)\n        const time = [0, 2, 3];  // 0 days, 2 hours, 3 minutes\n        const expected = 7380;\n        const result = calculateTotalSeconds(time);\n        expect(result).toBe(expected);\n    });\n\n    it('should calculate total seconds with only seconds provided', () => {\n        // Test with only seconds provided\n        const time = [0, 0, 0, 7200];  // 7200 seconds\n        const expected = 7200;\n        const result = calculateTotalSeconds(time);\n        expect(result).toBe(expected);\n    });\n\n    it('should calculate total seconds with no time values provided', () => {\n        // Test with no time values provided\n        const time: [number, number?, number?, number?] = [];\n        const expected = 0;\n        const result = calculateTotalSeconds(time);\n        expect(result).toBe(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculate the total number of seconds given a tuple or array of time periods in the order of\n * days, hours, minutes, and seconds.\n *\n * @param time - A tuple or array where:\n *   - time[0] - number of days (optional)\n *   - time[1] - number of hours (optional)\n *   - time[2] - number of minutes (optional)\n *   - time[3] - number of seconds (optional)\n * @returns The total number of seconds.\n *\n * Examples:\n *   calculateTotalSeconds([1, 2, 3, 4]) returns 93784\n *   calculateTotalSeconds([0, 2, 3]) returns 7380\n */\nfunction calculateTotalSeconds(time: [number, number?, number?, number?]): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the total number of seconds given a vector of time periods in the order of\n * days, hours, minutes, and seconds.\n *\n * @param time A vector where\n *     time[0] - number of days (optional)\n *     time[1] - number of hours (optional)\n *     time[2] - number of minutes (optional)\n *     time[3] - number of seconds (optional)\n * @return The total number of seconds as an integer.\n *\n * Examples:\n *     calculateTotalSeconds({1, 2, 3, 4}) returns 93784\n *     calculateTotalSeconds({0, 2, 3}) returns 7380\n */\nint calculate_total_seconds(const std::vector<int>& time) {\n\n}", "test_code": "TEST_CASE(\"Test calculate_total_seconds\", \"[calculate_total_seconds]\") {\n    SECTION(\"Test with full values provided for days, hours, minutes, and seconds\") {\n        std::vector<int> time = {1, 2, 3, 4};  // 1 day, 2 hours, 3 minutes, 4 seconds\n        int expected = 93784;\n        REQUIRE(calculate_total_seconds(time) == expected);\n    }\n\n    SECTION(\"Test with some values missing (assumed trailing zeros)\") {\n        std::vector<int> time = {0, 2, 3};  // 0 days, 2 hours, 3 minutes\n        int expected = 7380;\n        REQUIRE(calculate_total_seconds(time) == expected);\n    }\n\n    SECTION(\"Test with only seconds provided\") {\n        std::vector<int> time = {7200};  // 7200 seconds\n        int expected = 7200;  // Corrected expected value\n        REQUIRE(calculate_total_seconds(time) == expected);\n    }\n\n    SECTION(\"Test with no time values provided\") {\n        std::vector<int> time = {};  // Empty vector\n        int expected = 0;\n        REQUIRE(calculate_total_seconds(time) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the total number of seconds given a vector of time periods in the order of\n * days, hours, minutes, and seconds.\n *\n * @param time A vector where\n *     time[0] - number of days (optional)\n *     time[1] - number of hours (optional)\n *     time[2] - number of minutes (optional)\n *     time[3] - number of seconds (optional)\n * @return The total number of seconds as an integer.\n *\n * Examples:\n *     calculateTotalSeconds({1, 2, 3, 4}) returns 93784\n *     calculateTotalSeconds({0, 2, 3}) returns 7380\n */\nint calculate_total_seconds(const std::vector<int>& time) {\n\n}", "addition_info": ""}, "java": {"code_signature": "import java.util.Arrays;\n\npublic class Answer {\n\n    private static final int SECONDS_PER_DAY = 86400;\n    private static final int SECONDS_PER_HOUR = 3600;\n    private static final int SECONDS_PER_MINUTE = 60;\n\n    /**\n     * Calculate the total number of seconds given an array of time periods in the order of\n     * days, hours, minutes, and seconds.\n     *\n     * @param time an array where\n     *             time[0] - number of days (optional)\n     *             time[1] - number of hours (optional)\n     *             time[2] - number of minutes (optional)\n     *             time[3] - number of seconds (optional)\n     * @return the total number of seconds\n     */\n    public static int calculateTotalSeconds(int[] time) {\n        // Unpacking the time with defaults\n        int days = time.length > 0 ? time[0] : 0;\n        int hours = time.length > 1 ? time[1] : 0;\n        int minutes = time.length > 2 ? time[2] : 0;\n        int seconds = time.length > 3 ? time[3] : 0;\n\n        int totalSeconds = (\n                days * SECONDS_PER_DAY +\n                hours * SECONDS_PER_HOUR +\n                minutes * SECONDS_PER_MINUTE +\n                seconds\n        );\n\n        return totalSeconds;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        System.out.println(calculateTotalSeconds(new int[]{1, 2, 3, 4})); // Output: 93784\n        System.out.println(calculateTotalSeconds(new int[]{0, 2, 3}));    // Output: 7380\n    }\n}", "test_code": "package org.real.temp;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    @Test\n    public void testCompleteTime() {\n        // Test with full values provided for days, hours, minutes, and seconds\n        int[] time = {1, 2, 3, 4};  // 1 day, 2 hours, 3 minutes, 4 seconds\n        int expected = 93784;\n        int result = calculateTotalSeconds(time);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testPartialTime() {\n        // Test with some values missing (assumed trailing zeros)\n        int[] time = {0, 2, 3};  // 0 days, 2 hours, 3 minutes\n        int expected = 7380;\n        int result = calculateTotalSeconds(time);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testSecondsOnly() {\n        // Test with only seconds provided\n        int[] time = {0, 0, 0, 7200};  // 7200 seconds\n        int expected = 7200;\n        int result = calculateTotalSeconds(time);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testNoTime() {\n        // Test with no time values provided\n        int[] time = {};\n        int expected = 0;\n        int result = calculateTotalSeconds(time);\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below import java.util.Arrays;\n\npublic class Answer {\n\n    private static final int SECONDS_PER_DAY = 86400;\n    private static final int SECONDS_PER_HOUR = 3600;\n    private static final int SECONDS_PER_MINUTE = 60;\n\n    /**\n     * Calculate the total number of seconds given an array of time periods in the order of\n     * days, hours, minutes, and seconds.\n     *\n     * @param time an array where\n     *             time[0] - number of days (optional)\n     *             time[1] - number of hours (optional)\n     *             time[2] - number of minutes (optional)\n     *             time[3] - number of seconds (optional)\n     * @return the total number of seconds\n     */\n    public static int calculateTotalSeconds(int[] time) {\n        // Unpacking the time with defaults\n        int days = time.length > 0 ? time[0] : 0;\n        int hours = time.length > 1 ? time[1] : 0;\n        int minutes = time.length > 2 ? time[2] : 0;\n        int seconds = time.length > 3 ? time[3] : 0;\n\n        int totalSeconds = (\n                days * SECONDS_PER_DAY +\n                hours * SECONDS_PER_HOUR +\n                minutes * SECONDS_PER_MINUTE +\n                seconds\n        );\n\n        return totalSeconds;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        System.out.println(calculateTotalSeconds(new int[]{1, 2, 3, 4})); // Output: 93784\n        System.out.println(calculateTotalSeconds(new int[]{0, 2, 3}));    // Output: 7380\n    }\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 381, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Extract the user name and mailbox suffix from the mailbox string, for example, extract xxx and gmail.com from xxx@gmail.com", "language_version_list": {"python": {"code_signature": "def extract_email_details(email: str):\n    \"\"\"\n    Extracts the username and mailbox suffix from an email address.eg extract_email_details(\"xxx@gmail.com\") returns ('xxx', 'gmail.com')\n    Args:\n        email (str): the email address to extract details from\n\n    Returns:\n        tuple: (username, domain)\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestExtractEmailDetails(unittest.TestCase):\n\n    def test_valid_email(self):\n        # Test with a typical email address\n        email = \"user@example.com\"\n        expected = (\"user\", \"example.com\")\n        result = extract_email_details(email)\n        self.assertEqual(result, expected)\n\n    def test_valid_email_with_subdomain(self):\n        # Test with an email that includes a subdomain\n        email = \"user@mail.office.com\"\n        expected = (\"user\", \"mail.office.com\")\n        result = extract_email_details(email)\n        self.assertEqual(result, expected)\n\n\n    def test_email_without_at_symbol(self):\n        # Test with an email that lacks an '@' symbol\n        email = \"userexample.com\"\n        with self.assertRaises(ValueError):\n            extract_email_details(email)\n\n    def test_empty_email(self):\n        # Test with an empty string as an email\n        email = \"\"\n        with self.assertRaises(ValueError):\n            extract_email_details(email)", "prompt": "please write a python function , the function signature as below def extract_email_details(email: str):\n    \"\"\"\n    Extracts the username and mailbox suffix from an email address.eg extract_email_details(\"xxx@gmail.com\") returns ('xxx', 'gmail.com')\n    Args:\n        email (str): the email address to extract details from\n\n    Returns:\n        tuple: (username, domain)\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extracts the username and mailbox suffix from an email address.\n * Example: extractEmailDetails(\"xxx@gmail.com\") returns ['xxx', 'gmail.com']\n * \n * @param {string} email - The email address to extract details from.\n * @returns {Array} An array [username, domain] where:\n *      username is the part before '@'\n *      domain is the part after '@'\n */\nfunction extractEmailDetails(email) {}", "test_code": "describe('TestExtractEmailDetails', () => {\n    it('test_valid_email', () => {\n        // Test with a typical email address\n        const email = \"user@example.com\";\n        const expected = [\"user\", \"example.com\"];\n        const result = extractEmailDetails(email);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_valid_email_with_subdomain', () => {\n        // Test with an email that includes a subdomain\n        const email = \"user@mail.office.com\";\n        const expected = [\"user\", \"mail.office.com\"];\n        const result = extractEmailDetails(email);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_email_without_at_symbol', () => {\n        // Test with an email that lacks an '@' symbol\n        const email = \"userexample.com\";\n        expect(() => extractEmailDetails(email)).toThrowError(\"Invalid email address. Email must contain an '@' character.\");\n    });\n\n    it('test_empty_email', () => {\n        // Test with an empty string as an email\n        const email = \"\";\n        expect(() => extractEmailDetails(email)).toThrowError(\"Invalid email address. Email must contain an '@' character.\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Extracts the username and mailbox suffix from an email address.\n * Example: extractEmailDetails(\"xxx@gmail.com\") returns ['xxx', 'gmail.com']\n * \n * @param {string} email - The email address to extract details from.\n * @returns {Array} An array [username, domain] where:\n *      username is the part before '@'\n *      domain is the part after '@'\n */\nfunction extractEmailDetails(email) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Extracts the username and mailbox suffix from an email address.\n * Example: extractEmailDetails(\"xxx@gmail.com\") returns ['xxx', 'gmail.com']\n * \n * @param email - The email address to extract details from.\n * @returns A tuple [username, domain].\n */\nfunction extractEmailDetails(email: string): [string, string] {}", "test_code": "describe('extractEmailDetails', () => {\n    it('should extract details from a typical email address', () => {\n        const email = 'user@example.com';\n        const expected = ['user', 'example.com'];\n        const result = extractEmailDetails(email);\n        expect(result).toEqual(expected);\n    });\n\n    it('should extract details from an email with a subdomain', () => {\n        const email = 'user@mail.office.com';\n        const expected = ['user', 'mail.office.com'];\n        const result = extractEmailDetails(email);\n        expect(result).toEqual(expected);\n    });\n\n    it('should throw an error for an email without an @ symbol', () => {\n        const email = 'userexample.com';\n        expect(() => extractEmailDetails(email)).toThrow('Invalid email address. Email must contain an \\'@\\' character.');\n    });\n\n    it('should throw an error for an empty email', () => {\n        const email = '';\n        expect(() => extractEmailDetails(email)).toThrow('Invalid email address. Email must contain an \\'@\\' character.');\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Extracts the username and mailbox suffix from an email address.\n * Example: extractEmailDetails(\"xxx@gmail.com\") returns ['xxx', 'gmail.com']\n * \n * @param email - The email address to extract details from.\n * @returns A tuple [username, domain].\n */\nfunction extractEmailDetails(email: string): [string, string] {}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "please write a cpp function , the function signature as below ", "addition_info": ""}, "java": {"code_signature": "/**\n * Extracts the username and domain from an email address.\n *\n * @param email the email address to extract details from\n * @return a String array containing the username and domain\n * @throws IllegalArgumentException if the email does not contain an '@' character\n */\npublic static String[] extractEmailDetails(String email) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertThrows;\n\n/**\n * Test class for the extractEmailDetails method.\n */\npublic class Tester {\n\n    /**\n     * Tests extracting details from a typical email address.\n     */\n    @Test\n    public void testValidEmail() {\n        // Test with a typical email address\n        String email = \"user@example.com\";\n        String[] expected = {\"user\", \"example.com\"};\n        String[] result = extractEmailDetails(email);\n        assertArrayEquals(expected, result);\n    }\n\n    /**\n     * Tests extracting details from an email that includes a subdomain.\n     */\n    @Test\n    public void testValidEmailWithSubdomain() {\n        // Test with an email that includes a subdomain\n        String email = \"user@mail.office.com\";\n        String[] expected = {\"user\", \"mail.office.com\"};\n        String[] result = extractEmailDetails(email);\n        assertArrayEquals(expected, result);\n    }\n\n    /**\n     * Tests extracting details from an email that lacks an '@' symbol.\n     */\n    @Test\n    public void testEmailWithoutAtSymbol() {\n        // Test with an email that lacks an '@' symbol\n        String email = \"userexample.com\";\n        assertThrows(IllegalArgumentException.class, () -> extractEmailDetails(email));\n    }\n\n    /**\n     * Tests extracting details from an empty string as an email.\n     */\n    @Test\n    public void testEmptyEmail() {\n        // Test with an empty string as an email\n        String email = \"\";\n        assertThrows(IllegalArgumentException.class, () -> extractEmailDetails(email));\n    }\n\n    // Utility method to simulate the extractEmailDetails method for testing purposes\n    private String[] extractEmailDetails(String email) {\n        // Check if '@' is in the email\n        if (!email.contains(\"@\")) {\n            throw new IllegalArgumentException(\"Invalid email address. Email must contain an '@' character.\");\n        }\n\n        // Split the email at the '@' and assign parts to username and domain\n        String[] parts = email.split(\"@\", 2);\n        String username = parts[0];\n        String domain = parts[1];\n\n        return new String[]{username, domain};\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts the username and domain from an email address.\n *\n * @param email the email address to extract details from\n * @return a String array containing the username and domain\n * @throws IllegalArgumentException if the email does not contain an '@' character\n */\npublic static String[] extractEmailDetails(String email) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 386, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Converts the object file to the specified encoding format", "language_version_list": {"python": {"code_signature": "import shutil\n\n\ndef convert_encoding(input_file_path: str, output_file_path: str, original_encoding=\"cp932\",\n                     target_encoding=\"utf_16\") -> bool:\n    \"\"\"\n    This function converts the encoding of a file from one encoding to another\n\n    Parameters:\n        input_file_path (str): The path to the input file.\n        output_file_path (str): The path to the output file where the converted content is saved.\n        original_encoding (str): The original encoding of the file (default is cp932).\n        target_encoding (str): The target encoding to convert to (default is utf_16).\n\n    Returns:\n        bool: True if the conversion was successful, or if no conversion was needed; False otherwise.\n    \"\"\"\n", "test_code": "import unittest\nimport os\nimport shutil\nfrom io import open\n\nclass TestFixEncoding(unittest.TestCase):\n    def setUp(self):\n        # Create a directory for test files if it doesn't exist\n        self.test_dir = 'test_files'\n        os.makedirs(self.test_dir, exist_ok=True)\n        self.input_file_path = os.path.join(self.test_dir, 'test_input.txt')\n        self.output_file_path = os.path.join(self.test_dir, 'test_output.txt')\n\n    def tearDown(self):\n        # Remove test directory and all created files after each test\n        shutil.rmtree(self.test_dir)\n\n    def write_to_file(self, file_path, text, encoding):\n        # Helper method to write text to a file with a specific encoding\n        with open(file_path, 'w', encoding=encoding) as f:\n            f.write(text)\n\n    def test_basic_conversion(self):\n        # Test basic conversion from cp932 to utf_16\n        self.write_to_file(self.input_file_path, '\u3053\u308c\u306f\u30c6\u30b9\u30c8\u3067\u3059', 'cp932')\n        result = convert_encoding(self.input_file_path, self.output_file_path)\n        self.assertTrue(result)\n        with open(self.output_file_path, 'r', encoding='utf_16') as f:\n            self.assertEqual(f.read(), '\u3053\u308c\u306f\u30c6\u30b9\u30c8\u3067\u3059')\n\n    def test_no_conversion_needed(self):\n        # Test when no conversion is needed because file is already in target encoding\n        self.write_to_file(self.input_file_path, 'No conversion needed', 'utf_16')\n        result = convert_encoding(self.input_file_path, self.output_file_path, 'utf_16')\n        self.assertTrue(result)\n\n    def test_output_already_converted(self):\n        # Test behavior when file is already in target encoding and copied directly\n        self.write_to_file(self.input_file_path, 'Already utf_16', 'utf_16')\n        result = convert_encoding(self.input_file_path, self.output_file_path, 'cp932', 'utf_16')\n        self.assertTrue(result)", "prompt": "please write a python function , the function signature as below import shutil\n\n\ndef convert_encoding(input_file_path: str, output_file_path: str, original_encoding=\"cp932\",\n                     target_encoding=\"utf_16\") -> bool:\n    \"\"\"\n    This function converts the encoding of a file from one encoding to another\n\n    Parameters:\n        input_file_path (str): The path to the input file.\n        output_file_path (str): The path to the output file where the converted content is saved.\n        original_encoding (str): The original encoding of the file (default is cp932).\n        target_encoding (str): The target encoding to convert to (default is utf_16).\n\n    Returns:\n        bool: True if the conversion was successful, or if no conversion was needed; False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "please write a javascript function , the function signature as below ", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "please write a typescript function , the function signature as below ", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "please write a cpp function , the function signature as below ", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts the encoding of a file from one encoding to another.\n *\n * @param inputFilePath      The path to the input file.\n * @param outputFilePath     The path to the output file where the converted content is saved.\n * @param originalEncoding   The original encoding of the file (default is \"cp932\").\n * @param targetEncoding     The target encoding to convert to (default is \"UTF-16\").\n * @return                   True if the conversion was successful, or if no conversion was needed; False otherwise.\n */\npublic static boolean convertEncoding(String inputFilePath, String outputFilePath, String originalEncoding, String targetEncoding) {}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport static org.real.temp.Answer.*;\npublic class Tester {\n\n    private String testDir = \"test_files\";\n    private String inputFilePath;\n    private String outputFilePath;\n\n    @Before\n    public void setUp() throws IOException {\n        // Create a directory for test files if it doesn't exist\n        File dir = new File(testDir);\n        dir.mkdirs();\n        inputFilePath = new File(testDir, \"test_input.txt\").getAbsolutePath();\n        outputFilePath = new File(testDir, \"test_output.txt\").getAbsolutePath();\n    }\n\n    @After\n    public void tearDown() {\n        // Remove test directory and all created files after each test\n        File dir = new File(testDir);\n        if (dir.exists()) {\n            deleteDirectory(dir);\n        }\n    }\n\n    private void writeToFile(String filePath, String text, String encoding) throws IOException {\n        // Helper method to write text to a file with a specific encoding\n        try (FileWriter writer = new FileWriter(filePath, StandardCharsets.UTF_8)) {\n            writer.write(text);\n        }\n    }\n\n    @Test\n    public void testBasicConversion() throws IOException {\n        // Test basic conversion from cp932 to utf_16\n        writeToFile(inputFilePath, \"\u3053\u308c\u306f\u30c6\u30b9\u30c8\u3067\u3059\", \"cp932\");\n        boolean result = convertEncoding(inputFilePath, outputFilePath,\"cp932\",\"utf_16\");\n        assertTrue(result);\n        String content = readFile(outputFilePath, \"utf_16\");\n        assertEquals(\"\u3053\u308c\u306f\u30c6\u30b9\u30c8\u3067\u3059\", content);\n    }\n    \n    @Test\n    public void testOutputAlreadyConverted() throws IOException {\n        // Test behavior when file is already in target encoding and copied directly\n        writeToFile(inputFilePath, \"Already utf_16\", \"utf_16\");\n        boolean result = convertEncoding(inputFilePath, outputFilePath, \"cp932\", \"utf_16\");\n        assertTrue(result);\n    }\n\n    private String readFile(String filePath, String encoding) throws IOException {\n        // Helper method to read text from a file with a specific encoding\n        StringBuilder contentBuilder = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                contentBuilder.append(line).append(System.lineSeparator());\n            }\n        }\n        return contentBuilder.toString();\n    }\n\n    private void deleteDirectory(File directory) {\n        File[] files = directory.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                if (file.isDirectory()) {\n                    deleteDirectory(file);\n                } else {\n                    file.delete();\n                }\n            }\n        }\n        directory.delete();\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts the encoding of a file from one encoding to another.\n *\n * @param inputFilePath      The path to the input file.\n * @param outputFilePath     The path to the output file where the converted content is saved.\n * @param originalEncoding   The original encoding of the file (default is \"cp932\").\n * @param targetEncoding     The target encoding to convert to (default is \"UTF-16\").\n * @return                   True if the conversion was successful, or if no conversion was needed; False otherwise.\n */\npublic static boolean convertEncoding(String inputFilePath, String outputFilePath, String originalEncoding, String targetEncoding) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 390, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Split the input text string into sentences", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef split_into_sentences(text:str) -> List[str]:\n    \"\"\"\n    Split the input text string into sentences.\n\n    Args:\n        text (str): The input text to be split into sentences.\n\n    Returns:\n        list: A list of sentences extracted from the input text, cleaned and stripped of leading/trailing whitespace.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSplitIntoSentences(unittest.TestCase):\n\n    def test_basic_splitting(self):\n        # Test splitting a basic text with clear punctuation\n        text = \"Hello world! How are you? I am fine.\"\n        expected = [\"Hello world!\", \"How are you?\", \"I am fine.\"]\n        result = split_into_sentences(text)\n        self.assertEqual(result, expected)\n\n    def test_complex_punctuation(self):\n        # Test splitting text that includes quotes and commas\n        text = 'He said, This is amazing! Then he left.'\n        expected = ['He said, This is amazing!', \"Then he left.\"]\n        result = split_into_sentences(text)\n        self.assertEqual(result, expected)\n\n    def test_with_no_punctuation(self):\n        # Test text that has no punctuation marks\n        text = \"Hello world how are you\"\n        expected = [\"Hello world how are you\"]\n        result = split_into_sentences(text)\n        self.assertEqual(result, expected)\n\n    def test_empty_string(self):\n        # Test empty string input\n        text = \"\"\n        expected = []\n        result = split_into_sentences(text)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef split_into_sentences(text:str) -> List[str]:\n    \"\"\"\n    Split the input text string into sentences.\n\n    Args:\n        text (str): The input text to be split into sentences.\n\n    Returns:\n        list: A list of sentences extracted from the input text, cleaned and stripped of leading/trailing whitespace.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Split the input text string into sentences.\n *\n * @param {string} text - The input text to be split into sentences.\n * @returns {Array<string>} - A list of sentences extracted from the input text, cleaned and stripped of leading/trailing whitespace.\n */\nfunction splitIntoSentences(text) {}", "test_code": "describe('TestSplitIntoSentences', () => {\n    describe('test_basic_splitting', () => {\n        it('should correctly split a basic text with clear punctuation', () => {\n            const text = \"Hello world! How are you? I am fine.\";\n            const expected = [\"Hello world!\", \"How are you?\", \"I am fine.\"];\n            const result = splitIntoSentences(text);\n            expect(result).toEqual(expected);\n        });\n    });\n\n    describe('test_complex_punctuation', () => {\n        it('should correctly split text that includes quotes and commas', () => {\n            const text = 'He said, This is amazing! Then he left.';\n            const expected = ['He said, This is amazing!', \"Then he left.\"];\n            const result = splitIntoSentences(text);\n            expect(result).toEqual(expected);\n        });\n    });\n\n    describe('test_with_no_punctuation', () => {\n        it('should correctly handle text with no punctuation marks', () => {\n            const text = \"Hello world how are you\";\n            const expected = [\"Hello world how are you\"];\n            const result = splitIntoSentences(text);\n            expect(result).toEqual(expected);\n        });\n    });\n\n    describe('test_empty_string', () => {\n        it('should correctly handle an empty string input', () => {\n            const text = \"\";\n            const expected = [];\n            const result = splitIntoSentences(text);\n            expect(result).toEqual(expected);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Split the input text string into sentences.\n *\n * @param {string} text - The input text to be split into sentences.\n * @returns {Array<string>} - A list of sentences extracted from the input text, cleaned and stripped of leading/trailing whitespace.\n */\nfunction splitIntoSentences(text) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Split the input text string into sentences.\n *\n * @param text - The input text to be split into sentences.\n * @returns An array of sentences extracted from the input text, cleaned and stripped of leading/trailing whitespace.\n */\nfunction splitIntoSentences(text: string): string[] {}", "test_code": "describe('TestSplitIntoSentences', () => {\n    it('test_basic_splitting', () => {\n      // Test splitting a basic text with clear punctuation\n      const text = \"Hello world! How are you? I am fine.\";\n      const expected = [\"Hello world!\", \"How are you?\", \"I am fine.\"];\n      const result = splitIntoSentences(text);\n      expect(result).toEqual(expected);\n    });\n  \n    it('test_complex_punctuation', () => {\n      // Test splitting text that includes quotes and commas\n      const text = 'He said, This is amazing! Then he left.';\n      const expected = ['He said, This is amazing!', \"Then he left.\"];\n      const result = splitIntoSentences(text);\n      expect(result).toEqual(expected);\n    });\n  \n    it('test_with_no_punctuation', () => {\n      // Test text that has no punctuation marks\n      const text = \"Hello world how are you\";\n      const expected = [\"Hello world how are you\"];\n      const result = splitIntoSentences(text);\n      expect(result).toEqual(expected);\n    });\n  \n    it('test_empty_string', () => {\n      // Test empty string input\n      const text = \"\";\n      const expected = [];\n      const result = splitIntoSentences(text);\n      expect(result).toEqual(expected);\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Split the input text string into sentences.\n *\n * @param text - The input text to be split into sentences.\n * @returns An array of sentences extracted from the input text, cleaned and stripped of leading/trailing whitespace.\n */\nfunction splitIntoSentences(text: string): string[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "please write a cpp function , the function signature as below ", "addition_info": ""}, "java": {"code_signature": "/**\n * Splits the input text string into sentences.\n *\n * @param text The input text to be split into sentences.\n * @return A list of sentences extracted from the input text, cleaned and stripped of leading/trailing whitespace.\n */\npublic static List<String> splitIntoSentences(String text) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.real.temp.Answer.*;\n/**\n * Test class for the splitIntoSentences method.\n */\npublic class Tester {\n\n    /**\n     * Tests splitting a basic text with clear punctuation.\n     */\n    @Test\n    public void testBasicSplitting() {\n        String text = \"Hello world! How are you? I am fine.\";\n        List<String> expected = Arrays.asList(\"Hello world!\", \"How are you?\", \"I am fine.\");\n        List<String> result = splitIntoSentences(text);\n        assertEquals(expected, result);\n    }\n\n    /**\n     * Tests splitting text that includes quotes and commas.\n     */\n    @Test\n    public void testComplexPunctuation() {\n        String text = \"He said, This is amazing! Then he left.\";\n        List<String> expected = Arrays.asList(\"He said, This is amazing!\", \"Then he left.\");\n        List<String> result = splitIntoSentences(text);\n        assertEquals(expected, result);\n    }\n\n    /**\n     * Tests text that has no punctuation marks.\n     */\n    @Test\n    public void testWithNoPunctuation() {\n        String text = \"Hello world how are you\";\n        List<String> expected = Arrays.asList(\"Hello world how are you\");\n        List<String> result = splitIntoSentences(text);\n        assertEquals(expected, result);\n    }\n\n    /**\n     * Tests empty string input.\n     */\n    @Test\n    public void testEmptyString() {\n        String text = \"\";\n        List<String> expected = Arrays.asList();\n        List<String> result = splitIntoSentences(text);\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Splits the input text string into sentences.\n *\n * @param text The input text to be split into sentences.\n * @return A list of sentences extracted from the input text, cleaned and stripped of leading/trailing whitespace.\n */\npublic static List<String> splitIntoSentences(String text) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 392, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Generates the next sequence in the 'look-and-say' sequence by reading off the digits of the given number,grouping by consecutive digits.", "language_version_list": {"python": {"code_signature": "def look_and_say(number: str):\n    \"\"\"\n    Generates the next sequence in the 'look-and-say' sequence by reading off the digits of the given number,\n    grouping by consecutive digits.\n\n    Args:\n        number (str): The current sequence as a string.\n\n    Returns:\n        str: The next sequence in the 'look-and-say' series.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestLookAndSay(unittest.TestCase):\n\n    def test_single_digit(self):\n        # Test with a single digit to see if it replicates correctly\n        self.assertEqual(look_and_say('1'), '11')\n\n    def test_repetitive_digits(self):\n        # Test a sequence of the same digits\n        self.assertEqual(look_and_say('111'), '31')\n\n    def test_mixed_digits(self):\n        # Test a sequence with different digits\n        self.assertEqual(look_and_say('1211'), '111221')\n\n    def test_complex_sequence(self):\n        # Test a more complex sequence\n        self.assertEqual(look_and_say('312211'), '13112221')\n", "prompt": "please write a python function , the function signature as below def look_and_say(number: str):\n    \"\"\"\n    Generates the next sequence in the 'look-and-say' sequence by reading off the digits of the given number,\n    grouping by consecutive digits.\n\n    Args:\n        number (str): The current sequence as a string.\n\n    Returns:\n        str: The next sequence in the 'look-and-say' series.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Generates the next sequence in the 'look-and-say' sequence by reading off the digits of the given number,\n * grouping by consecutive digits.\n *\n * @param {string} number - The current sequence as a string.\n * @returns {string} - The next sequence in the 'look-and-say' series.\n */\nfunction lookAndSay(number) {}", "test_code": "describe('TestLookAndSay', () => {\n    test('test_single_digit', () => {\n        // Test with a single digit to see if it replicates correctly\n        expect(lookAndSay('1')).toBe('11');\n    });\n\n    test('test_repetitive_digits', () => {\n        // Test a sequence of the same digits\n        expect(lookAndSay('111')).toBe('31');\n    });\n\n    test('test_mixed_digits', () => {\n        // Test a sequence with different digits\n        expect(lookAndSay('1211')).toBe('111221');\n    });\n\n    test('test_complex_sequence', () => {\n        // Test a more complex sequence\n        expect(lookAndSay('312211')).toBe('13112221');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Generates the next sequence in the 'look-and-say' sequence by reading off the digits of the given number,\n * grouping by consecutive digits.\n *\n * @param {string} number - The current sequence as a string.\n * @returns {string} - The next sequence in the 'look-and-say' series.\n */\nfunction lookAndSay(number) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Generates the next sequence in the 'look-and-say' sequence by reading off the digits of the given number,\n * grouping by consecutive digits.\n *\n * @param {string} number - The current sequence as a string.\n * @returns {string} - The next sequence in the 'look-and-say' series.\n */\nfunction lookAndSay(number: string): string {}", "test_code": "describe('TestLookAndSay', () => {\n    it('should replicate a single digit correctly', () => {\n      expect(lookAndSay('1')).toBe('11');\n    });\n  \n    it('should handle a sequence of the same digits', () => {\n      expect(lookAndSay('111')).toBe('31');\n    });\n  \n    it('should handle a sequence with different digits', () => {\n      expect(lookAndSay('1211')).toBe('111221');\n    });\n  \n    it('should handle a more complex sequence', () => {\n      expect(lookAndSay('312211')).toBe('13112221');\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Generates the next sequence in the 'look-and-say' sequence by reading off the digits of the given number,\n * grouping by consecutive digits.\n *\n * @param {string} number - The current sequence as a string.\n * @returns {string} - The next sequence in the 'look-and-say' series.\n */\nfunction lookAndSay(number: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "please write a cpp function , the function signature as below ", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 395, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "    Sums up calibration values extracted from the document.\n    Each calibration value is formed by combining the first and last digits of numbers found in each line\n    into a two-digit number.\n", "language_version_list": {"python": {"code_signature": "def sum_calibration_values(calibration_document) -> int:\n    \"\"\"\n    Sums up calibration values extracted from the document.\n    Each calibration value is formed by combining the first and last digits of numbers found in each line\n    into a two-digit number.\n\n    Args:\n        calibration_document (iterable): An iterable of strings, each representing a line of text.\n\n    Returns:\n        int: The total sum of all calibration values.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestSumCalibrationValues(unittest.TestCase):\n\n    def test_basic_calculations(self):\n        # Test with a simple input where lines contain at least two digits\n        document = [\n            \"Reading 1234 calibration\",\n            \"Measure 5678 complete\",\n            \"End of data 91011\"\n        ]\n        self.assertEqual(sum_calibration_values(document), 163)\n\n    def test_no_digits(self):\n        # Test lines with no digits\n        document = [\n            \"No numbers here\",\n            \"Still no numbers\"\n        ]\n        self.assertEqual(sum_calibration_values(document), 0)\n\n    def test_empty_lines(self):\n        # Test with empty lines or lines with spaces\n        document = [\n            \"\",\n            \"   \"\n        ]\n        self.assertEqual(sum_calibration_values(document), 0)\n\n    def test_mixed_content(self):\n        # Test with a mixture of valid and invalid lines\n        document = [\n            \"Good line 1524 end\",\n            \"Bad line\",\n            \"Another good line 7681\"\n        ]\n        self.assertEqual(sum_calibration_values(document), 85)", "prompt": "please write a python function , the function signature as below def sum_calibration_values(calibration_document) -> int:\n    \"\"\"\n    Sums up calibration values extracted from the document.\n    Each calibration value is formed by combining the first and last digits of numbers found in each line\n    into a two-digit number.\n\n    Args:\n        calibration_document (iterable): An iterable of strings, each representing a line of text.\n\n    Returns:\n        int: The total sum of all calibration values.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Sums up calibration values extracted from the document.\n * Each calibration value is formed by combining the first and last digits of numbers found in each line\n * into a two-digit number.\n *\n * @param {Iterable<string>} calibrationDocument - An iterable of strings, each representing a line of text.\n * @returns {number} The total sum of all calibration values.\n */\nfunction sumCalibrationValues(calibrationDocument) {}", "test_code": "describe('TestSumCalibrationValues', () => {\n    it('test_basic_calculations', () => {\n        // Test with a simple input where lines contain at least two digits\n        const document = [\n            \"Reading 1234 calibration\",\n            \"Measure 5678 complete\",\n            \"End of data 91011\"\n        ];\n        expect(sumCalibrationValues(document)).toBe(163);\n    });\n\n    it('test_no_digits', () => {\n        // Test lines with no digits\n        const document = [\n            \"No numbers here\",\n            \"Still no numbers\"\n        ];\n        expect(sumCalibrationValues(document)).toBe(0);\n    });\n\n    it('test_empty_lines', () => {\n        // Test with empty lines or lines with spaces\n        const document = [\n            \"\",\n            \"   \"\n        ];\n        expect(sumCalibrationValues(document)).toBe(0);\n    });\n\n    it('test_mixed_content', () => {\n        // Test with a mixture of valid and invalid lines\n        const document = [\n            \"Good line 1524 end\",\n            \"Bad line\",\n            \"Another good line 7681\"\n        ];\n        expect(sumCalibrationValues(document)).toBe(85);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Sums up calibration values extracted from the document.\n * Each calibration value is formed by combining the first and last digits of numbers found in each line\n * into a two-digit number.\n *\n * @param {Iterable<string>} calibrationDocument - An iterable of strings, each representing a line of text.\n * @returns {number} The total sum of all calibration values.\n */\nfunction sumCalibrationValues(calibrationDocument) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Sums up calibration values extracted from the document.\n * Each calibration value is formed by combining the first and last digits of numbers found in each line\n * into a two-digit number.\n *\n * @param {Iterable<string>} calibrationDocument - An iterable of strings, each representing a line of text.\n * @returns {number} The total sum of all calibration values.\n */\nfunction sumCalibrationValues(calibrationDocument: Iterable<string>): number {}", "test_code": "describe('TestSumCalibrationValues', () => {\n    describe('test_basic_calculations', () => {\n        it('should correctly calculate the sum with basic input', () => {\n            const document = [\n                \"Reading 1234 calibration\",\n                \"Measure 5678 complete\",\n                \"End of data 91011\"\n            ];\n            expect(sumCalibrationValues(document)).toBe(163);\n        });\n    });\n\n    describe('test_no_digits', () => {\n        it('should return 0 when no digits are present', () => {\n            const document = [\n                \"No numbers here\",\n                \"Still no numbers\"\n            ];\n            expect(sumCalibrationValues(document)).toBe(0);\n        });\n    });\n\n    describe('test_empty_lines', () => {\n        it('should return 0 for empty or whitespace-only lines', () => {\n            const document = [\n                \"\",\n                \"   \"\n            ];\n            expect(sumCalibrationValues(document)).toBe(0);\n        });\n    });\n\n    describe('test_mixed_content', () => {\n        it('should correctly calculate the sum with mixed content', () => {\n            const document = [\n                \"Good line 1524 end\",\n                \"Bad line\",\n                \"Another good line 7681\"\n            ];\n            expect(sumCalibrationValues(document)).toBe(85);\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Sums up calibration values extracted from the document.\n * Each calibration value is formed by combining the first and last digits of numbers found in each line\n * into a two-digit number.\n *\n * @param {Iterable<string>} calibrationDocument - An iterable of strings, each representing a line of text.\n * @returns {number} The total sum of all calibration values.\n */\nfunction sumCalibrationValues(calibrationDocument: Iterable<string>): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Sums up calibration values extracted from the document.\n * Each calibration value is formed by combining the first and last digits of numbers found in each line\n * into a two-digit number.\n *\n * @param calibrationDocument A vector of strings, each representing a line of text.\n * @return The total sum of all calibration values.\n */\nint sum_calibration_values(const std::vector<std::string>& calibrationDocument);", "test_code": "TEST_CASE(\"Test sum_calibration_values\", \"[sum_calibration_values]\") {\n    SECTION(\"test_basic_calculations\") {\n        // Test with a simple input where lines contain at least two digits\n        std::vector<std::string> document = {\n            \"Reading 1234 calibration\",\n            \"Measure 5678 complete\",\n            \"End of data 91011\"\n        };\n        REQUIRE(sum_calibration_values(document) == 163);\n    }\n\n    SECTION(\"test_no_digits\") {\n        // Test lines with no digits\n        std::vector<std::string> document = {\n            \"No numbers here\",\n            \"Still no numbers\"\n        };\n        REQUIRE(sum_calibration_values(document) == 0);\n    }\n\n    SECTION(\"test_empty_lines\") {\n        // Test with empty lines or lines with spaces\n        std::vector<std::string> document = {\n            \"\",\n            \"   \"\n        };\n        REQUIRE(sum_calibration_values(document) == 0);\n    }\n\n    SECTION(\"test_mixed_content\") {\n        // Test with a mixture of valid and invalid lines\n        std::vector<std::string> document = {\n            \"Good line 1524 end\",\n            \"Bad line\",\n            \"Another good line 7681\"\n        };\n        REQUIRE(sum_calibration_values(document) == 85);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Sums up calibration values extracted from the document.\n * Each calibration value is formed by combining the first and last digits of numbers found in each line\n * into a two-digit number.\n *\n * @param calibrationDocument A vector of strings, each representing a line of text.\n * @return The total sum of all calibration values.\n */\nint sum_calibration_values(const std::vector<std::string>& calibrationDocument);", "addition_info": ""}, "java": {"code_signature": "/**\n * Sums up calibration values extracted from the document.\n * Each calibration value is formed by combining the first and last digits of numbers found in each line\n * into a two-digit number.\n *\n * @param calibrationDocument an iterable of strings, each representing a line of text.\n * @return the total sum of all calibration values.\n */\npublic static int sumCalibrationValues(Iterable<String> calibrationDocument) {}", "test_code": "import static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testSumCalibrationValues() {\n        // Test data\n        String[] calibrationDocument = {\"1abc2\", \"3def4ghi5\"};\n        \n        // Call the method under test\n        int result = sumCalibrationValues(calibrationDocument);\n        \n        // Assert the expected outcome\n        assertEquals(100, result);  // Assuming that 12 + 45 should give 57\n    }\n\n    /**\n     * Sums up calibration values extracted from the document.\n     * Each calibration value is formed by combining the first and last digits of numbers found in each line\n     * into a two-digit number.\n     *\n     * @param calibrationDocument An array of strings, each representing a line of text.\n     * @return The total sum of all calibration values.\n     */\n    private int sumCalibrationValues(String[] calibrationDocument) {\n        int sum = 0;\n        for (String line : calibrationDocument) {\n            int firstDigit = Character.getNumericValue(line.charAt(0));\n            int lastDigit = Character.getNumericValue(line.charAt(line.length() - 1));\n            sum += firstDigit * 10 + lastDigit;\n        }\n        return sum;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Sums up calibration values extracted from the document.\n * Each calibration value is formed by combining the first and last digits of numbers found in each line\n * into a two-digit number.\n *\n * @param calibrationDocument an iterable of strings, each representing a line of text.\n * @return the total sum of all calibration values.\n */\npublic static int sumCalibrationValues(Iterable<String> calibrationDocument) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 396, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Given an array of integers nums, find the length of the longest strictly increasing subsequence in it", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef length_of_LIS(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the length of the longest strictly increasing subsequence in it\n\n    Args:\n        nums (List[int]): int array\n\n    Returns:\n        int: longest strictly increasing subsequence\n    \"\"\"", "test_code": "import unittest\nfrom typing import List\n\nclass TestLengthOfLIS(unittest.TestCase):\n\n    def test_empty_list(self):\n        # Test the function with an empty list\n        self.assertEqual(length_of_LIS([]), 0)\n\n    def test_single_element(self):\n        # Test with a list containing only one element\n        self.assertEqual(length_of_LIS([7]), 1)\n\n    def test_increasing_sequence(self):\n        # Test with a list where the elements are strictly increasing\n        self.assertEqual(length_of_LIS([1, 2, 3, 4, 5]), 5)\n\n    def test_decreasing_sequence(self):\n        # Test with a list where the elements are strictly decreasing\n        self.assertEqual(length_of_LIS([5, 4, 3, 2, 1]), 1)\n\n    def test_complex_sequence(self):\n        # Test with a complex sequence with mix of increasing and decreasing elements\n        self.assertEqual(length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]), 4)\n\n    def test_all_equal_elements(self):\n        # Test with all elements in the list being equal\n        self.assertEqual(length_of_LIS([2, 2, 2, 2]), 1)\n\n    def test_with_negative_numbers(self):\n        # Test with a mix of negative and positive numbers\n        self.assertEqual(length_of_LIS([-1, -2, -3, 0, 1, 2]), 4)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef length_of_LIS(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the length of the longest strictly increasing subsequence in it\n\n    Args:\n        nums (List[int]): int array\n\n    Returns:\n        int: longest strictly increasing subsequence\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Given an array of integers `nums`, find the length of the longest strictly increasing subsequence in it.\n *\n * @param {number[]} nums - An array of integers\n * @return {number} The length of the longest strictly increasing subsequence\n */\nfunction lengthOfLIS(nums) {}", "test_code": "describe('TestLengthOfLIS', () => {\n  it('should return 0 for an empty list', () => {\n      expect(lengthOfLIS([])).toBe(0);\n  });\n\n  it('should return 1 for a list containing only one element', () => {\n      expect(lengthOfLIS([7])).toBe(1);\n  });\n\n  it('should return 5 for a strictly increasing sequence', () => {\n      expect(lengthOfLIS([1, 2, 3, 4, 5])).toBe(5);\n  });\n\n  it('should return 1 for a strictly decreasing sequence', () => {\n      expect(lengthOfLIS([5, 4, 3, 2, 1])).toBe(1);\n  });\n\n  it('should return 4 for a complex sequence with mix of increasing and decreasing elements', () => {\n      expect(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18])).toBe(4);\n  });\n\n  it('should return 1 for a list with all elements being equal', () => {\n      expect(lengthOfLIS([2, 2, 2, 2])).toBe(1);\n  });\n\n  it('should return 4 for a mix of negative and positive numbers', () => {\n      expect(lengthOfLIS([-1, -2, -3, 0, 1, 2])).toBe(4);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Given an array of integers `nums`, find the length of the longest strictly increasing subsequence in it.\n *\n * @param {number[]} nums - An array of integers\n * @return {number} The length of the longest strictly increasing subsequence\n */\nfunction lengthOfLIS(nums) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Given an array of integers `nums`, find the length of the longest strictly increasing subsequence in it.\n *\n * @param {number[]} nums - Array of integers.\n * @returns {number} Length of the longest strictly increasing subsequence.\n */\nfunction lengthOfLIS(nums: number[]): number {}", "test_code": "describe('TestLengthOfLIS', () => {\n    it('should handle an empty list', () => {\n      expect(lengthOfLIS([])).toBe(0);\n    });\n  \n    it('should handle a list with a single element', () => {\n      expect(lengthOfLIS([7])).toBe(1);\n    });\n  \n    it('should handle a strictly increasing sequence', () => {\n      expect(lengthOfLIS([1, 2, 3, 4, 5])).toBe(5);\n    });\n  \n    it('should handle a strictly decreasing sequence', () => {\n      expect(lengthOfLIS([5, 4, 3, 2, 1])).toBe(1);\n    });\n  \n    it('should handle a complex sequence with a mix of increasing and decreasing elements', () => {\n      expect(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18])).toBe(4);\n    });\n  \n    it('should handle a list with all elements being equal', () => {\n      expect(lengthOfLIS([2, 2, 2, 2])).toBe(1);\n    });\n  \n    it('should handle a mix of negative and positive numbers', () => {\n      expect(lengthOfLIS([-1, -2, -3, 0, 1, 2])).toBe(4);\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Given an array of integers `nums`, find the length of the longest strictly increasing subsequence in it.\n *\n * @param {number[]} nums - Array of integers.\n * @returns {number} Length of the longest strictly increasing subsequence.\n */\nfunction lengthOfLIS(nums: number[]): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Finds the length of the longest strictly increasing subsequence in a given array of integers.\n *\n * @param nums The input array of integers.\n * @return The length of the longest strictly increasing subsequence.\n */\nint length_of_lis(const std::vector<int>& nums);", "test_code": "TEST_CASE(\"Test Length of LIS\", \"[LIS]\") {\n    SECTION(\"Empty list\") {\n        REQUIRE(length_of_LIS({}) == 0);\n    }\n\n    SECTION(\"Single element\") {\n        REQUIRE(length_of_lis({7}) == 1);\n    }\n\n    SECTION(\"Strictly increasing sequence\") {\n        REQUIRE(length_of_lis({1, 2, 3, 4, 5}) == 5);\n    }\n\n    SECTION(\"Strictly decreasing sequence\") {\n        REQUIRE(length_of_lis({5, 4, 3, 2, 1}) == 1);\n    }\n\n    SECTION(\"Complex sequence\") {\n        REQUIRE(length_of_lis({10, 9, 2, 5, 3, 7, 101, 18}) == 4);\n    }\n\n    SECTION(\"All equal elements\") {\n        REQUIRE(length_of_lis({2, 2, 2, 2}) == 1);\n    }\n\n    SECTION(\"With negative numbers\") {\n        REQUIRE(length_of_lis({-1, -2, -3, 0, 1, 2}) == 4);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds the length of the longest strictly increasing subsequence in a given array of integers.\n *\n * @param nums The input array of integers.\n * @return The length of the longest strictly increasing subsequence.\n */\nint length_of_lis(const std::vector<int>& nums);", "addition_info": ""}, "java": {"code_signature": "/**\n * Given an array of integers nums, find the length of the longest strictly increasing subsequence in it.\n *\n * @param nums the input integer list\n * @return the length of the longest strictly increasing subsequence\n */\npublic int lengthOfLIS(List<Integer> nums) {}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testLengthOfLIS() {\n        // Test case 1\n        int[] nums1 = {10, 9, 2, 5, 3, 7, 101, 18};\n        assertEquals(4, lengthOfLIS(nums1), \"Test case 1 failed\");\n\n        // Test case 2\n        int[] nums2 = {0, 1, 0, 3, 2, 3};\n        assertEquals(4, lengthOfLIS(nums2), \"Test case 2 failed\");\n\n        // Test case 3\n        int[] nums3 = {7, 7, 7, 7, 7, 7, 7};\n        assertEquals(1, lengthOfLIS(nums3), \"Test case 3 failed\");\n\n        // Test case 4\n        int[] nums4 = {};\n        assertEquals(0, lengthOfLIS(nums4), \"Test case 4 failed\");\n\n        // Test case 5\n        int[] nums5 = {1};\n        assertEquals(1, lengthOfLIS(nums5), \"Test case 5 failed\");\n    }\n\n    private int lengthOfLIS(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        \n        int n = nums.length;\n        int[] dp = new int[n];\n        int maxLength = 1;\n\n        for (int i = 0; i < n; i++) {\n            dp[i] = 1;\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n            maxLength = Math.max(maxLength, dp[i]);\n        }\n\n        return maxLength;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Given an array of integers nums, find the length of the longest strictly increasing subsequence in it.\n *\n * @param nums the input integer list\n * @return the length of the longest strictly increasing subsequence\n */\npublic int lengthOfLIS(List<Integer> nums) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 398, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Copy files from folderA to folderB excluding those listed in the specified CSV file ", "language_version_list": {"python": {"code_signature": "import os\nimport csv\nimport shutil\n\n\ndef extract_files_excluding_csv(folderA: str, csv_file: str, folderB: str):\n    \"\"\"\n    Copy files from folderA to folderB excluding those listed in the specified CSV file.\n\n    Args:\n        folderA: Path to the source folder containing all files (str).\n        csv_file: Path to the CSV file containing filenames to exclude (str).\n        folderB: Path to the destination folder (str).\n\n    Returns:\n\n    \"\"\"\n", "test_code": "import os\nimport shutil\nimport unittest\n\n\nclass TestExtractFiles(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up test directories and files before each test case.\"\"\"\n        self.folderA = \"test_folderA\"\n        self.folderB = \"test_folderB\"\n        os.makedirs(self.folderA, exist_ok=True)\n        os.makedirs(self.folderB, exist_ok=True)\n\n    def tearDown(self):\n        \"\"\"Clean up the test directories after each test case.\"\"\"\n        shutil.rmtree(self.folderA)\n        shutil.rmtree(self.folderB)\n\n    def create_csv(self, filename_list):\n        \"\"\"Helper method to create a CSV file for testing.\"\"\"\n        csv_file = \"test_exclude.csv\"\n        with open(csv_file, \"w\", newline='') as file:\n            writer = csv.writer(file)\n            writer.writerow([\"filename\"])  # Write header\n            for name in filename_list:\n                writer.writerow([name])\n        return csv_file\n\n    def test_basic_functionality(self):\n        \"\"\"Test basic functionality with some files excluded.\"\"\"\n        with open(os.path.join(self.folderA, \"file1.txt\"), \"w\") as f:\n            f.write(\"Content of file 1\")\n        with open(os.path.join(self.folderA, \"file2.txt\"), \"w\") as f:\n            f.write(\"Content of file 2\")\n        with open(os.path.join(self.folderA, \"file3.txt\"), \"w\") as f:\n            f.write(\"Content of file 3\")\n\n        csv_file = self.create_csv([\"file2.txt\"])  # Exclude file2.txt\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"file1.txt\")))\n        self.assertFalse(os.path.exists(os.path.join(self.folderB, \"file2.txt\")))\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"file3.txt\")))\n\n    def test_empty_folderA(self):\n        \"\"\"Test when folderA is empty.\"\"\"\n        csv_file = self.create_csv([\"file1.txt\"])  # Exclude file1.txt\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        self.assertEqual(len(os.listdir(self.folderB)), 0)\n\n    def test_all_files_excluded(self):\n        \"\"\"Test when all files are excluded.\"\"\"\n        with open(os.path.join(self.folderA, \"file1.txt\"), \"w\") as f:\n            f.write(\"Content of file 1\")\n        with open(os.path.join(self.folderA, \"file2.txt\"), \"w\") as f:\n            f.write(\"Content of file 2\")\n\n        csv_file = self.create_csv([\"file1.txt\", \"file2.txt\"])  # Exclude all files\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        self.assertEqual(len(os.listdir(self.folderB)), 0)\n\n    def test_destination_folder_already_has_files(self):\n        \"\"\"Test when folderB already contains files.\"\"\"\n        with open(os.path.join(self.folderB, \"existing_file.txt\"), \"w\") as f:\n            f.write(\"This is an existing file.\")\n\n        with open(os.path.join(self.folderA, \"file1.txt\"), \"w\") as f:\n            f.write(\"Content of file 1\")\n\n        csv_file = self.create_csv([])  # Do not exclude any files\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        # Check if both existing and new files are present\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"existing_file.txt\")))\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"file1.txt\")))\n\n    def test_empty_csv_file(self):\n        \"\"\"Test with an empty CSV file.\"\"\"\n        with open(os.path.join(self.folderA, \"file1.txt\"), \"w\") as f:\n            f.write(\"Content of file 1\")\n\n        csv_file = self.create_csv([])  # Empty CSV, do not exclude any files\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"file1.txt\")))", "prompt": "please write a python function , the function signature as below import os\nimport csv\nimport shutil\n\n\ndef extract_files_excluding_csv(folderA: str, csv_file: str, folderB: str):\n    \"\"\"\n    Copy files from folderA to folderB excluding those listed in the specified CSV file.\n\n    Args:\n        folderA: Path to the source folder containing all files (str).\n        csv_file: Path to the CSV file containing filenames to exclude (str).\n        folderB: Path to the destination folder (str).\n\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 401, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Find a placeholder in the format {{ placeholder }}} from the string and return a list of all matching placeholders\n", "language_version_list": {"python": {"code_signature": "import re\n\ndef find_placeholders(text):\n    \"\"\"\n    Find and return a list of all placeholders in the format {{ placeholder }} from the input text.\n\n    Args:\n        text (str): The input string containing potential placeholders.\n\n    Returns:\n        list: A list of matching placeholders.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFindPlaceholders(unittest.TestCase):\n\n    def test_multiple_placeholders(self):\n        \"\"\"Test string with multiple placeholders.\"\"\"\n        input_text = \"Here are some placeholders: {{ placeholder1 }}, {{ placeholder2 }}, and {{ placeholder3 }}.\"\n        expected_output = ['placeholder1', 'placeholder2', 'placeholder3']\n        self.assertEqual(find_placeholders(input_text), expected_output)\n\n    def test_no_placeholders(self):\n        \"\"\"Test string with no placeholders.\"\"\"\n        input_text = \"This string has no placeholders.\"\n        expected_output = []\n        self.assertEqual(find_placeholders(input_text), expected_output)\n\n    def test_single_placeholder(self):\n        \"\"\"Test string with a single placeholder.\"\"\"\n        input_text = \"The only placeholder is {{ singlePlaceholder }}.\"\n        expected_output = ['singlePlaceholder']\n        self.assertEqual(find_placeholders(input_text), expected_output)\n\n    def test_placeholder_with_spaces(self):\n        \"\"\"Test string with placeholders that have extra spaces.\"\"\"\n        input_text = \"Placeholders with spaces: {{  placeholder_with_spaces  }} and {{ placeholder2 }}.\"\n        expected_output = ['placeholder_with_spaces', 'placeholder2']\n        self.assertEqual(find_placeholders(input_text), expected_output)\n", "prompt": "please write a python function , the function signature as below import re\n\ndef find_placeholders(text):\n    \"\"\"\n    Find and return a list of all placeholders in the format {{ placeholder }} from the input text.\n\n    Args:\n        text (str): The input string containing potential placeholders.\n\n    Returns:\n        list: A list of matching placeholders.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Find and return an array of all placeholders in the format {{ placeholder }} from the input text.\n *\n * @param {string} text - The input string containing potential placeholders.\n * @returns {Array} An array of matching placeholders.\n */\nfunction findPlaceholders(text) {}", "test_code": "describe('TestFindPlaceholders', () => {\n  it('test string with multiple placeholders', () => {\n      const inputText = \"Here are some placeholders: {{ placeholder1 }}, {{ placeholder2 }}, and {{ placeholder3 }}.\";\n      const expectedOutput = ['placeholder1', 'placeholder2', 'placeholder3'];\n      expect(findPlaceholders(inputText)).toEqual(expectedOutput);\n  });\n\n  it('test string with no placeholders', () => {\n      const inputText = \"This string has no placeholders.\";\n      const expectedOutput = [];\n      expect(findPlaceholders(inputText)).toEqual(expectedOutput);\n  });\n\n  it('test string with a single placeholder', () => {\n      const inputText = \"The only placeholder is {{ singlePlaceholder }}.\";\n      const expectedOutput = ['singlePlaceholder'];\n      expect(findPlaceholders(inputText)).toEqual(expectedOutput);\n  });\n\n  it('test string with placeholders that have extra spaces', () => {\n      const inputText = \"Placeholders with spaces: {{  placeholder_with_spaces  }} and {{ placeholder2 }}.\";\n      const expectedOutput = ['placeholder_with_spaces', 'placeholder2'];\n      expect(findPlaceholders(inputText)).toEqual(expectedOutput);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Find and return an array of all placeholders in the format {{ placeholder }} from the input text.\n *\n * @param {string} text - The input string containing potential placeholders.\n * @returns {Array} An array of matching placeholders.\n */\nfunction findPlaceholders(text) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as re from 'xregexp';\n\n/**\n * Find and return a list of all placeholders in the format {{ placeholder }} from the input text.\n *\n * @param text - The input string containing potential placeholders.\n * @returns An array of matching placeholders.\n */\nfunction findPlaceholders(text: string): string[] {}", "test_code": "describe('TestFindPlaceholders', () => {\n    it('test string with multiple placeholders', () => {\n      const inputText = \"Here are some placeholders: {{ placeholder1 }}, {{ placeholder2 }}, and {{ placeholder3 }}.\";\n      const expectedOutput = ['placeholder1', 'placeholder2', 'placeholder3'];\n      expect(findPlaceholders(inputText)).toEqual(expectedOutput);\n    });\n  \n    it('test string with no placeholders', () => {\n      const inputText = \"This string has no placeholders.\";\n      const expectedOutput = [];\n      expect(findPlaceholders(inputText)).toEqual(expectedOutput);\n    });\n  \n    it('test string with a single placeholder', () => {\n      const inputText = \"The only placeholder is {{ singlePlaceholder }}.\";\n      const expectedOutput = ['singlePlaceholder'];\n      expect(findPlaceholders(inputText)).toEqual(expectedOutput);\n    });\n  \n    it('test string with placeholders that have extra spaces', () => {\n      const inputText = \"Placeholders with spaces: {{  placeholder_with_spaces  }} and {{ placeholder2 }}.\";\n      const expectedOutput = ['placeholder_with_spaces', 'placeholder2'];\n      expect(findPlaceholders(inputText)).toEqual(expectedOutput);\n    });\n  });", "prompt": "please write a typescript function , the function signature as below import * as re from 'xregexp';\n\n/**\n * Find and return a list of all placeholders in the format {{ placeholder }} from the input text.\n *\n * @param text - The input string containing potential placeholders.\n * @returns An array of matching placeholders.\n */\nfunction findPlaceholders(text: string): string[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Find and return a list of all placeholders in the format {{ placeholder }} from the input text.\n *\n * @param text The input string containing potential placeholders.\n * @return std::vector<std::string> A vector of matching placeholders.\n */\nstd::vector<std::string> find_placeholders(const std::string& text) {}", "test_code": "TEST_CASE(\"Test find_placeholders function\", \"[find_placeholders]\") {\n    SECTION(\"Test string with multiple placeholders\") {\n        std::string input_text = \"Here are some placeholders: {{ placeholder1 }}, {{ placeholder2 }}, and {{ placeholder3 }}.\";\n        std::vector<std::string> expected_output = {\"placeholder1\", \"placeholder2\", \"placeholder3\"};\n        REQUIRE(find_placeholders(input_text) == expected_output);\n    }\n\n    SECTION(\"Test string with no placeholders\") {\n        std::string input_text = \"This string has no placeholders.\";\n        std::vector<std::string> expected_output = {};\n        REQUIRE(find_placeholders(input_text) == expected_output);\n    }\n\n    SECTION(\"Test string with a single placeholder\") {\n        std::string input_text = \"The only placeholder is {{ singlePlaceholder }}.\";\n        std::vector<std::string> expected_output = {\"singlePlaceholder\"};\n        REQUIRE(find_placeholders(input_text) == expected_output);\n    }\n\n    SECTION(\"Test string with placeholders that have extra spaces\") {\n        std::string input_text = \"Placeholders with spaces: {{  placeholder_with_spaces  }} and {{ placeholder2 }}.\";\n        std::vector<std::string> expected_output = {\"placeholder_with_spaces\", \"placeholder2\"};\n        REQUIRE(find_placeholders(input_text) == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Find and return a list of all placeholders in the format {{ placeholder }} from the input text.\n *\n * @param text The input string containing potential placeholders.\n * @return std::vector<std::string> A vector of matching placeholders.\n */\nstd::vector<std::string> find_placeholders(const std::string& text) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds and returns a list of all placeholders in the format {{ placeholder }} from the input text.\n *\n * @param text the input string containing potential placeholders\n * @return a list of matching placeholders\n */\npublic List<String> findPlaceholders(String text) {}", "test_code": "package org.real.temp;\n\nimport junit.framework.TestCase;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Tester extends TestCase {\n\n    // Assuming you have a method that needs testing, for example, findPlaceholders\n    public void testFindPlaceholders() {\n        String inputText = \"This is a sample text with placeholders like {{ name }}, {{ age }}, and {{ address }}.\";\n        List<String> expectedPlaceholders = new ArrayList<>();\n        expectedPlaceholders.add(\"{{ name }}\");\n        expectedPlaceholders.add(\"{{ age }}\");\n        expectedPlaceholders.add(\"{{ address }}\");\n\n        List<String> actualPlaceholders = findPlaceholders(inputText);\n\n        assertEquals(expectedPlaceholders.size(), actualPlaceholders.size());\n        for (String expected : expectedPlaceholders) {\n            assertTrue(actualPlaceholders.contains(expected));\n        }\n    }\n\n    private List<String> findPlaceholders(String text) {\n        Pattern pattern = Pattern.compile(\"\\\\{\\\\{\\\\s*([a-zA-Z0-9_]+)\\\\s*\\\\}\\\\}\");\n        Matcher matcher = pattern.matcher(text);\n        List<String> placeholders = new ArrayList<>();\n\n        while (matcher.find()) {\n            placeholders.add(matcher.group(1));\n        }\n\n        return placeholders;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds and returns a list of all placeholders in the format {{ placeholder }} from the input text.\n *\n * @param text the input string containing potential placeholders\n * @return a list of matching placeholders\n */\npublic List<String> findPlaceholders(String text) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 404, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Computes the n-th power of a matrix using the fast exponentiation method.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef power(matrix: List[List[int]], n: int) -> List[List[int]]:\n    \"\"\"\n    Computes the n-th power of a matrix using the fast exponentiation method.\n\n    Args:\n        matrix (List[List[int]]): A square matrix to be exponentiated.\n        n (int): The exponent to raise the matrix to. Must be a non-negative integer.\n\n    Returns:\n        List[List[int]]: The matrix raised to the power of n.\n\n    Raises:\n        ValueError: If n is negative.\n        TypeError: If matrix is not a list of lists or n is not an integer.\n    \"\"\"", "test_code": "import unittest\n\nclass TestMatrixPower(unittest.TestCase):\n\n    def test_identity_matrix(self):\n        # Testing the power function with an identity matrix\n        matrix = [[1, 0], [0, 1]]\n        expected = [[1, 0], [0, 1]]\n        result = power(matrix, 1)\n        self.assertEqual(result, expected)\n\n    def test_zero_power(self):\n        # Testing matrix to the power of zero (should return identity)\n        matrix = [[2, 3], [1, 4]]\n        expected = [[1, 0], [0, 1]]\n        result = power(matrix, 0)\n        self.assertEqual(result, expected)\n\n    def test_positive_power(self):\n        # Testing matrix to a positive power\n        matrix = [[2, 1], [1, 3]]\n        expected = [[5, 5], [5, 10]]  # This is the result of matrix^2\n        result = power(matrix, 2)\n        self.assertEqual(result, expected)\n\n    def test_negative_power(self):\n        # Testing matrix to a negative power (should raise ValueError)\n        matrix = [[2, 1], [1, 3]]\n        with self.assertRaises(ValueError):\n            power(matrix, -1)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef power(matrix: List[List[int]], n: int) -> List[List[int]]:\n    \"\"\"\n    Computes the n-th power of a matrix using the fast exponentiation method.\n\n    Args:\n        matrix (List[List[int]]): A square matrix to be exponentiated.\n        n (int): The exponent to raise the matrix to. Must be a non-negative integer.\n\n    Returns:\n        List[List[int]]: The matrix raised to the power of n.\n\n    Raises:\n        ValueError: If n is negative.\n        TypeError: If matrix is not a list of lists or n is not an integer.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Computes the n-th power of a matrix using the fast exponentiation method.\n * \n * @param {Array<Array<number>>} matrix - A square matrix to be exponentiated.\n * @param {number} n - The exponent to raise the matrix to. Must be a non-negative integer.\n * \n * @returns {Array<Array<number>>} The matrix raised to the power of n.\n * \n * @throws {Error} If n is negative.\n * @throws {TypeError} If matrix is not a list of lists or n is not an integer.\n */\nfunction power(matrix, n) {}", "test_code": "describe('TestMatrixPower', () => {\n  describe('test_identity_matrix', () => {\n      it('should return the identity matrix when raised to the power of 1', () => {\n          const matrix = [[1, 0], [0, 1]];\n          const expected = [[1, 0], [0, 1]];\n          const result = power(matrix, 1);\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_zero_power', () => {\n      it('should return the identity matrix when raised to the power of 0', () => {\n          const matrix = [[2, 3], [1, 4]];\n          const expected = [[1, 0], [0, 1]];\n          const result = power(matrix, 0);\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_positive_power', () => {\n      it('should correctly compute the power of a matrix', () => {\n          const matrix = [[2, 1], [1, 3]];\n          const expected = [[5, 5], [5, 10]]; // This is the result of matrix^2\n          const result = power(matrix, 2);\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_negative_power', () => {\n      it('should throw an error when raised to a negative power', () => {\n          const matrix = [[2, 1], [1, 3]];\n          expect(() => power(matrix, -1)).toThrow('The exponent n must be a non-negative integer.');\n      });\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Computes the n-th power of a matrix using the fast exponentiation method.\n * \n * @param {Array<Array<number>>} matrix - A square matrix to be exponentiated.\n * @param {number} n - The exponent to raise the matrix to. Must be a non-negative integer.\n * \n * @returns {Array<Array<number>>} The matrix raised to the power of n.\n * \n * @throws {Error} If n is negative.\n * @throws {TypeError} If matrix is not a list of lists or n is not an integer.\n */\nfunction power(matrix, n) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Computes the n-th power of a matrix using the fast exponentiation method.\n *\n * @param matrix - A square matrix to be exponentiated.\n * @param n - The exponent to raise the matrix to. Must be a non-negative integer.\n * @returns The matrix raised to the power of n.\n * @throws {Error} If n is negative.\n * @throws {TypeError} If matrix is not a list of lists or n is not an integer.\n */\nfunction power(matrix: number[][], n: number): number[][] {}", "test_code": "describe('TestMatrixPower', () => {\n  describe('test_identity_matrix', () => {\n      it('should return the identity matrix when the power is 1', () => {\n          const matrix: number[][] = [[1, 0], [0, 1]];\n          const expected: number[][] = [[1, 0], [0, 1]];\n          const result = power(matrix, 1);\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_zero_power', () => {\n      it('should return the identity matrix when the power is 0', () => {\n          const matrix: number[][] = [[2, 3], [1, 4]];\n          const expected: number[][] = [[1, 0], [0, 1]];\n          const result = power(matrix, 0);\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_positive_power', () => {\n      it('should correctly compute the power of a matrix for a positive exponent', () => {\n          const matrix: number[][] = [[2, 1], [1, 3]];\n          const expected: number[][] = [[5, 5], [5, 10]]; // This is the result of matrix^2\n          const result = power(matrix, 2);\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_negative_power', () => {\n      it('should throw an error when the power is negative', () => {\n          const matrix: number[][] = [[2, 1], [1, 3]];\n          expect(() => power(matrix, -1)).toThrow('The exponent n must be a non-negative integer.');\n      });\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Computes the n-th power of a matrix using the fast exponentiation method.\n *\n * @param matrix - A square matrix to be exponentiated.\n * @param n - The exponent to raise the matrix to. Must be a non-negative integer.\n * @returns The matrix raised to the power of n.\n * @throws {Error} If n is negative.\n * @throws {TypeError} If matrix is not a list of lists or n is not an integer.\n */\nfunction power(matrix: number[][], n: number): number[][] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Computes the n-th power of a matrix using the fast exponentiation method.\n *\n * @param matrix A square matrix to be exponentiated.\n * @param n The exponent to raise the matrix to. Must be a non-negative integer.\n * @return The matrix raised to the power of n.\n * @throw std::invalid_argument if n is negative.\n * @throw std::invalid_argument if matrix is not a square matrix.\n */\nstd::vector<std::vector<int>> power(const std::vector<std::vector<int>>& matrix, int n);", "test_code": "TEST_CASE(\"Test Matrix Power\", \"[matrix_power]\") {\n    SECTION(\"Identity Matrix\") {\n        // Testing the power function with an identity matrix\n        std::vector<std::vector<int>> matrix = {{1, 0}, {0, 1}};\n        std::vector<std::vector<int>> expected = {{1, 0}, {0, 1}};\n        auto result = power(matrix, 1);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Zero Power\") {\n        // Testing matrix to the power of zero (should return identity)\n        std::vector<std::vector<int>> matrix = {{2, 3}, {1, 4}};\n        std::vector<std::vector<int>> expected = {{1, 0}, {0, 1}};\n        auto result = power(matrix, 0);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Positive Power\") {\n        // Testing matrix to a positive power\n        std::vector<std::vector<int>> matrix = {{2, 1}, {1, 3}};\n        std::vector<std::vector<int>> expected = {{5, 5}, {5, 10}};  // This is the result of matrix^2\n        auto result = power(matrix, 2);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Negative Power\") {\n        // Testing matrix to a negative power (should throw std::invalid_argument)\n        std::vector<std::vector<int>> matrix = {{2, 1}, {1, 3}};\n        REQUIRE_THROWS_AS(power(matrix, -1), std::invalid_argument);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Computes the n-th power of a matrix using the fast exponentiation method.\n *\n * @param matrix A square matrix to be exponentiated.\n * @param n The exponent to raise the matrix to. Must be a non-negative integer.\n * @return The matrix raised to the power of n.\n * @throw std::invalid_argument if n is negative.\n * @throw std::invalid_argument if matrix is not a square matrix.\n */\nstd::vector<std::vector<int>> power(const std::vector<std::vector<int>>& matrix, int n);", "addition_info": ""}, "java": {"code_signature": "/**\n * Computes the n-th power of a matrix using the fast exponentiation method.\n *\n * @param matrix A square matrix to be exponentiated.\n * @param n      The exponent to raise the matrix to. Must be a non-negative integer.\n * @return The matrix raised to the power of n.\n * @throws IllegalArgumentException if n is negative.\n * @throws ClassCastException     if matrix is not a list of lists or n is not an integer.\n */\npublic static List<List<Integer>> power(List<List<Integer>> matrix, int n) {}", "test_code": "import static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testNegativeExponent() {\n        int[][] matrix = {{1, 2}, {3, 4}};\n        MatrixPower.power(matrix, -1);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testNonIntegerExponent() {\n        int[][] matrix = {{1, 2}, {3, 4}};\n        MatrixPower.power(matrix, 1.5);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testNonMatrixInput() {\n        Object[] input = {\"not\", \"a\", \"matrix\"};\n        MatrixPower.power(input, 2);\n    }\n    \n    // Add more tests for other scenarios...\n}", "prompt": "please write a java function , the function signature as below /**\n * Computes the n-th power of a matrix using the fast exponentiation method.\n *\n * @param matrix A square matrix to be exponentiated.\n * @param n      The exponent to raise the matrix to. Must be a non-negative integer.\n * @return The matrix raised to the power of n.\n * @throws IllegalArgumentException if n is negative.\n * @throws ClassCastException     if matrix is not a list of lists or n is not an integer.\n */\npublic static List<List<Integer>> power(List<List<Integer>> matrix, int n) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 405, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Remove the part before the first upper case letter and the first lower case letter from the string", "language_version_list": {"python": {"code_signature": "def remove_parts_of_string(*strings):\n    \"\"\"\n    Remove the part before the first upper case letter and the first lower case letter from the string\n\n    For example:\n        input: 1234AbCde5678\n        output: AbCde5678\n    Args:\n        *strings: Accepts one or more strings as variable arguments\n    Returns:\n\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestRemovePartsOfString(unittest.TestCase):\n\n    def test_case_3(self):\n        # Test with a string that has no uppercase letters\n        result = remove_parts_of_string(\"abcdefg\")\n        self.assertEqual(result, [\"abcdefg\"])\n\n    def test_case_4(self):\n        # Test with a string that has no lowercase letters\n        result = remove_parts_of_string(\"ABCDEFG\")\n        self.assertEqual(result, [\"ABCDEFG\"])\n\n    def test_case_5(self):\n        # Test with a string that has mixed cases\n        result = remove_parts_of_string(\"1234AbCde5678\")\n        self.assertEqual(result, [\"AbCde5678\"])\n\n    def test_case_6(self):\n        # Test with an empty string\n        result = remove_parts_of_string(\"\")\n        self.assertEqual(result, [\"\"])\n\n    def test_case_7(self):\n        # Test with a string that has only one uppercase letter\n        result = remove_parts_of_string(\"X\")\n        self.assertEqual(result, [\"X\"])\n\n    def test_case_8(self):\n        # Test with a string that has only one lowercase letter\n        result = remove_parts_of_string(\"y\")\n        self.assertEqual(result, [\"y\"])\n", "prompt": "please write a python function , the function signature as below def remove_parts_of_string(*strings):\n    \"\"\"\n    Remove the part before the first upper case letter and the first lower case letter from the string\n\n    For example:\n        input: 1234AbCde5678\n        output: AbCde5678\n    Args:\n        *strings: Accepts one or more strings as variable arguments\n    Returns:\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Remove the part before the first uppercase letter and the first lowercase letter from the string.\n *\n * @example\n * removePartsOfString(\"1234AbCde5678\") // returns [\"AbCde5678\"]\n *\n * @param {...string} strings - Accepts one or more strings as variable arguments\n * @returns {Array<string>} - An array of processed strings\n */\nfunction removePartsOfString(...strings) {}", "test_code": "describe('TestRemovePartsOfString', () => {\n  it('should handle a string with no uppercase letters', () => {\n      const result = removePartsOfString(\"abcdefg\");\n      expect(result).toEqual([\"abcdefg\"]);\n  });\n\n  it('should handle a string with no lowercase letters', () => {\n      const result = removePartsOfString(\"ABCDEFG\");\n      expect(result).toEqual([\"ABCDEFG\"]);\n  });\n\n  it('should handle a string with mixed cases', () => {\n      const result = removePartsOfString(\"1234AbCde5678\");\n      expect(result).toEqual([\"AbCde5678\"]);\n  });\n\n  it('should handle an empty string', () => {\n      const result = removePartsOfString(\"\");\n      expect(result).toEqual([\"\"]);\n  });\n\n  it('should handle a string with only one uppercase letter', () => {\n      const result = removePartsOfString(\"X\");\n      expect(result).toEqual([\"X\"]);\n  });\n\n  it('should handle a string with only one lowercase letter', () => {\n      const result = removePartsOfString(\"y\");\n      expect(result).toEqual([\"y\"]);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Remove the part before the first uppercase letter and the first lowercase letter from the string.\n *\n * @example\n * removePartsOfString(\"1234AbCde5678\") // returns [\"AbCde5678\"]\n *\n * @param {...string} strings - Accepts one or more strings as variable arguments\n * @returns {Array<string>} - An array of processed strings\n */\nfunction removePartsOfString(...strings) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Remove the part before the first uppercase letter and the first lowercase letter from the string.\n *\n * For example:\n *   input: \"1234AbCde5678\"\n *   output: \"AbCde5678\"\n *\n * @param {...string} strings - Accepts one or more strings as variable arguments.\n * @returns {string[]} An array of modified strings.\n */\nfunction removePartsOfString(...strings: string[]): string[] {}", "test_code": "\ndescribe('TestRemovePartsOfString', () => {\n  it('should handle a string with no uppercase letters', () => {\n      const result = removePartsOfString(\"abcdefg\");\n      expect(result).toEqual([\"abcdefg\"]);\n  });\n\n  it('should handle a string with no lowercase letters', () => {\n      const result = removePartsOfString(\"ABCDEFG\");\n      expect(result).toEqual([\"ABCDEFG\"]);\n  });\n\n  it('should handle a string with mixed cases', () => {\n      const result = removePartsOfString(\"1234AbCde5678\");\n      expect(result).toEqual([\"AbCde5678\"]);\n  });\n\n  it('should handle an empty string', () => {\n      const result = removePartsOfString(\"\");\n      expect(result).toEqual([\"\"]);\n  });\n\n  it('should handle a string with only one uppercase letter', () => {\n      const result = removePartsOfString(\"X\");\n      expect(result).toEqual([\"X\"]);\n  });\n\n  it('should handle a string with only one lowercase letter', () => {\n      const result = removePartsOfString(\"y\");\n      expect(result).toEqual([\"y\"]);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Remove the part before the first uppercase letter and the first lowercase letter from the string.\n *\n * For example:\n *   input: \"1234AbCde5678\"\n *   output: \"AbCde5678\"\n *\n * @param {...string} strings - Accepts one or more strings as variable arguments.\n * @returns {string[]} An array of modified strings.\n */\nfunction removePartsOfString(...strings: string[]): string[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Removes the part before the first uppercase letter and the first lowercase letter from each string.\n *\n * Example:\n *     Input: \"1234AbCde5678\"\n *     Output: \"AbCde5678\"\n *\n * @param strings A vector of strings to be processed.\n * @return A vector of strings after processing.\n */\nstd::vector<std::string> remove_parts_of_string(const std::vector<std::string>& strings);", "test_code": "TEST_CASE(\"Test remove_parts_of_string function\") {\n    SECTION(\"Test with a string that has no uppercase letters\") {\n        std::vector<std::string> input = {\"abcdefg\"};\n        std::vector<std::string> expected = {\"abcdefg\"};\n        REQUIRE(remove_parts_of_string(input) == expected);\n    }\n\n    SECTION(\"Test with a string that has no lowercase letters\") {\n        std::vector<std::string> input = {\"ABCDEFG\"};\n        std::vector<std::string> expected = {\"ABCDEFG\"};\n        REQUIRE(remove_parts_of_string(input) == expected);\n    }\n\n    SECTION(\"Test with a string that has mixed cases\") {\n        std::vector<std::string> input = {\"1234AbCde5678\"};\n        std::vector<std::string> expected = {\"AbCde5678\"};\n        REQUIRE(remove_parts_of_string(input) == expected);\n    }\n\n    SECTION(\"Test with an empty string\") {\n        std::vector<std::string> input = {\"\"};\n        std::vector<std::string> expected = {\"\"};\n        REQUIRE(remove_parts_of_string(input) == expected);\n    }\n\n    SECTION(\"Test with a string that has only one uppercase letter\") {\n        std::vector<std::string> input = {\"X\"};\n        std::vector<std::string> expected = {\"X\"};\n        REQUIRE(remove_parts_of_string(input) == expected);\n    }\n\n    SECTION(\"Test with a string that has only one lowercase letter\") {\n        std::vector<std::string> input = {\"y\"};\n        std::vector<std::string> expected = {\"y\"};\n        REQUIRE(remove_parts_of_string(input) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Removes the part before the first uppercase letter and the first lowercase letter from each string.\n *\n * Example:\n *     Input: \"1234AbCde5678\"\n *     Output: \"AbCde5678\"\n *\n * @param strings A vector of strings to be processed.\n * @return A vector of strings after processing.\n */\nstd::vector<std::string> remove_parts_of_string(const std::vector<std::string>& strings);", "addition_info": ""}, "java": {"code_signature": "/**\n * Removes the part before the first uppercase letter and the first lowercase letter from the string.\n *\n * For example:\n *     Input: 1234AbCde5678\n *     Output: AbCde5678\n *\n * @param strings Accepts one or more strings as variable arguments.\n */\npublic class StringManipulator {\n\n    public static void main(String[] args) {\n        // Example usage\n        System.out.println(removePartsOfString(\"1234AbCde5678\")); // Output: AbCde5678\n    }\n\n    /**\n     * Removes the part before the first uppercase letter and the first lowercase letter from the string.\n     *\n     * @param strings Variable number of strings to process.\n     * @return The modified string.\n     */\n    public static String removePartsOfString(String... strings) {}\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testRemovePartsOfString() {\n        // Test case 1\n        assertEquals(\"AbCde5678\", removePartsOfStrings(\"1234AbCde5678\"));\n\n        // Test case 2\n        assertEquals(\"HelloWorld\", removePartsOfStrings(\"HelloWorld\"));\n\n        // Test case 3\n        assertEquals(\"JavaIsFun\", removePartsOfStrings(\"JavaIsFun\"));\n\n        // Test case 4\n        assertEquals(\"\", removePartsOfStrings(\"1234567890\"));\n\n        // Test case 5\n        assertEquals(\"\", removePartsOfStrings(\"!@#$%^&*()_+\"));\n\n        // Test case 6\n        assertEquals(\"ABCD\", removePartsOfStrings(\"ABCD\"));\n    }\n\n    private String removePartsOfStrings(String... strings) {\n        if (strings == null || strings.length == 0) {\n            return \"\";\n        }\n\n        String input = strings[0];\n        int startIndex = -1;\n        int endIndex = -1;\n\n        for (int i = 0; i < input.length(); i++) {\n            char c = input.charAt(i);\n            if (Character.isUpperCase(c)) {\n                startIndex = i;\n            } else if (Character.isLowerCase(c)) {\n                endIndex = i;\n                break;\n            }\n        }\n\n        if (startIndex == -1 || endIndex == -1) {\n            return input;\n        }\n\n        return input.substring(startIndex, endIndex + 1);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Removes the part before the first uppercase letter and the first lowercase letter from the string.\n *\n * For example:\n *     Input: 1234AbCde5678\n *     Output: AbCde5678\n *\n * @param strings Accepts one or more strings as variable arguments.\n */\npublic class StringManipulator {\n\n    public static void main(String[] args) {\n        // Example usage\n        System.out.println(removePartsOfString(\"1234AbCde5678\")); // Output: AbCde5678\n    }\n\n    /**\n     * Removes the part before the first uppercase letter and the first lowercase letter from the string.\n     *\n     * @param strings Variable number of strings to process.\n     * @return The modified string.\n     */\n    public static String removePartsOfString(String... strings) {}\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 406, "code_type": "class", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Implement a colors class that prints strings in color", "language_version_list": {"python": {"code_signature": "class Colors:\n\n    @staticmethod\n    def red(text: str) -> str:\n        \"\"\"text in red color\"\"\"\n        pass\n\n    @staticmethod\n    def green(text: str) -> str:\n        \"\"\"text in green color\"\"\"\n\n    @staticmethod\n    def blue(text: str) -> str:\n        \"\"\"text in blue color\"\"\"\n\n    @staticmethod\n    def yellow(text: str) -> str:\n        \"\"\"text in yellow color\"\"\"\n\n    @staticmethod\n    def magenta(text: str) -> str:\n        \"\"\"text in magenta color\"\"\"\n\n    @staticmethod\n    def cyan(text: str) -> str:\n        \"\"\"text in cyan color\"\"\"\n", "test_code": "import unittest\n\nclass TestColors(unittest.TestCase):\n\n    def test_red(self):\n        \"\"\"Test the red color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[91mHello\\033[0m\"\n        self.assertEqual(Colors.red(input_text), expected_output)\n\n    def test_green(self):\n        \"\"\"Test the green color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[92mHello\\033[0m\"\n        self.assertEqual(Colors.green(input_text), expected_output)\n\n    def test_blue(self):\n        \"\"\"Test the blue color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[94mHello\\033[0m\"\n        self.assertEqual(Colors.blue(input_text), expected_output)\n\n    def test_yellow(self):\n        \"\"\"Test the yellow color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[93mHello\\033[0m\"\n        self.assertEqual(Colors.yellow(input_text), expected_output)\n\n    def test_magenta(self):\n        \"\"\"Test the magenta color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[95mHello\\033[0m\"\n        self.assertEqual(Colors.magenta(input_text), expected_output)\n\n    def test_cyan(self):\n        \"\"\"Test the cyan color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[96mHello\\033[0m\"\n        self.assertEqual(Colors.cyan(input_text), expected_output)\n\n    def test_combined_colors(self):\n        \"\"\"Test combining different color methods\"\"\"\n        input_text_red = Colors.red(\"Red\")\n        input_text_blue = Colors.blue(\"Blue\")\n        input_text_combined = f\"{input_text_red} and {input_text_blue}\"\n        expected_output = \"\\033[91mRed\\033[0m and \\033[94mBlue\\033[0m\"\n        self.assertEqual(input_text_combined, expected_output)\n", "prompt": "please write a python class , the class signature as below class Colors:\n\n    @staticmethod\n    def red(text: str) -> str:\n        \"\"\"text in red color\"\"\"\n        pass\n\n    @staticmethod\n    def green(text: str) -> str:\n        \"\"\"text in green color\"\"\"\n\n    @staticmethod\n    def blue(text: str) -> str:\n        \"\"\"text in blue color\"\"\"\n\n    @staticmethod\n    def yellow(text: str) -> str:\n        \"\"\"text in yellow color\"\"\"\n\n    @staticmethod\n    def magenta(text: str) -> str:\n        \"\"\"text in magenta color\"\"\"\n\n    @staticmethod\n    def cyan(text: str) -> str:\n        \"\"\"text in cyan color\"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "class Colors {\n    // text in red color\n    static red(text) {\n        return `<span style=\"color:red;\">${text}</span>`;\n    }\n\n    // text in green color\n    static green(text) {\n        return `<span style=\"color:green;\">${text}</span>`;\n    }\n\n    // text in blue color\n    static blue(text) {\n        return `<span style=\"color:blue;\">${text}</span>`;\n    }\n\n    // text in yellow color\n    static yellow(text) {\n        return `<span style=\"color:yellow;\">${text}</span>`;\n    }\n\n    // text in magenta color\n    static magenta(text) {\n        return `<span style=\"color:magenta;\">${text}</span>`;\n    }\n\n    // text in cyan color\n    static cyan(text) {\n        return `<span style=\"color:cyan;\">${text}</span>`;\n    }\n}", "test_code": "describe('Colors', () => {\n  describe('Color Methods', () => {\n    it('test_red', () => {\n      const inputText = 'Hello';\n      const expectedOutput = '\\x1b[91mHello\\x1b[0m';\n      expect(Colors.red(inputText)).toEqual(expectedOutput);\n    });\n\n    it('test_green', () => {\n      const inputText = 'Hello';\n      const expectedOutput = '\\x1b[92mHello\\x1b[0m';\n      expect(Colors.green(inputText)).toEqual(expectedOutput);\n    });\n\n    it('test_blue', () => {\n      const inputText = 'Hello';\n      const expectedOutput = '\\x1b[94mHello\\x1b[0m';\n      expect(Colors.blue(inputText)).toEqual(expectedOutput);\n    });\n\n    it('test_yellow', () => {\n      const inputText = 'Hello';\n      const expectedOutput = '\\x1b[93mHello\\x1b[0m';\n      expect(Colors.yellow(inputText)).toEqual(expectedOutput);\n    });\n\n    it('test_magenta', () => {\n      const inputText = 'Hello';\n      const expectedOutput = '\\x1b[95mHello\\x1b[0m';\n      expect(Colors.magenta(inputText)).toEqual(expectedOutput);\n    });\n\n    it('test_cyan', () => {\n      const inputText = 'Hello';\n      const expectedOutput = '\\x1b[96mHello\\x1b[0m';\n      expect(Colors.cyan(inputText)).toEqual(expectedOutput);\n    });\n  });\n});", "prompt": "please write a javascript class , the class signature as below class Colors {\n    // text in red color\n    static red(text) {\n        return `<span style=\"color:red;\">${text}</span>`;\n    }\n\n    // text in green color\n    static green(text) {\n        return `<span style=\"color:green;\">${text}</span>`;\n    }\n\n    // text in blue color\n    static blue(text) {\n        return `<span style=\"color:blue;\">${text}</span>`;\n    }\n\n    // text in yellow color\n    static yellow(text) {\n        return `<span style=\"color:yellow;\">${text}</span>`;\n    }\n\n    // text in magenta color\n    static magenta(text) {\n        return `<span style=\"color:magenta;\">${text}</span>`;\n    }\n\n    // text in cyan color\n    static cyan(text) {\n        return `<span style=\"color:cyan;\">${text}</span>`;\n    }\n}", "addition_info": ""}, "typescript": {"code_signature": "class Colors {\n    // text in red color\n    static red(text: string): string {\n        return '';\n    }\n\n    // text in green color\n    static green(text: string): string {\n        return '';\n    }\n\n    // text in blue color\n    static blue(text: string): string {\n        return '';\n    }\n\n    // text in yellow color\n    static yellow(text: string): string {\n        return '';\n    }\n\n    // text in magenta color\n    static magenta(text: string): string {\n        return '';\n    }\n\n    // text in cyan color\n    static cyan(text: string): string {\n        return '';\n    }\n}", "test_code": "describe('Colors', () => {\n  it('test_red', () => {\n    const inputText = 'Hello';\n    const expectedOutput = '\\033[91mHello\\033[0m';\n    expect(Colors.red(inputText)).toBe(expectedOutput);\n  });\n\n  it('test_green', () => {\n    const inputText = 'Hello';\n    const expectedOutput = '\\033[92mHello\\033[0m';\n    expect(Colors.green(inputText)).toBe(expectedOutput);\n  });\n\n  it('test_blue', () => {\n    const inputText = 'Hello';\n    const expectedOutput = '\\033[94mHello\\033[0m';\n    expect(Colors.blue(inputText)).toBe(expectedOutput);\n  });\n\n  it('test_yellow', () => {\n    const inputText = 'Hello';\n    const expectedOutput = '\\033[93mHello\\033[0m';\n    expect(Colors.yellow(inputText)).toBe(expectedOutput);\n  });\n\n  it('test_magenta', () => {\n    const inputText = 'Hello';\n    const expectedOutput = '\\033[95mHello\\033[0m';\n    expect(Colors.magenta(inputText)).toBe(expectedOutput);\n  });\n\n  it('test_cyan', () => {\n    const inputText = 'Hello';\n    const expectedOutput = '\\033[96mHello\\033[0m';\n    expect(Colors.cyan(inputText)).toBe(expectedOutput);\n  });\n});", "prompt": "please write a typescript class , the class signature as below class Colors {\n    // text in red color\n    static red(text: string): string {\n        return '';\n    }\n\n    // text in green color\n    static green(text: string): string {\n        return '';\n    }\n\n    // text in blue color\n    static blue(text: string): string {\n        return '';\n    }\n\n    // text in yellow color\n    static yellow(text: string): string {\n        return '';\n    }\n\n    // text in magenta color\n    static magenta(text: string): string {\n        return '';\n    }\n\n    // text in cyan color\n    static cyan(text: string): string {\n        return '';\n    }\n}", "addition_info": ""}, "c&cpp": {"code_signature": "class Colors {\npublic:\n    // Function to return text in red color\n    static std::string red(const std::string& text);\n\n    // Function to return text in green color\n    static std::string green(const std::string& text);\n\n    // Function to return text in blue color\n    static std::string blue(const std::string& text);\n\n    // Function to return text in yellow color\n    static std::string yellow(const std::string& text);\n\n    // Function to return text in magenta color\n    static std::string magenta(const std::string& text);\n\n    // Function to return text in cyan color\n    static std::string cyan(const std::string& text);\n};\n\n// Implementation of each function (you can add actual implementation here)\nstd::string Colors::red(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[31m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::green(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[32m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::blue(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[34m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::yellow(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[33m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::magenta(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[35m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::cyan(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[36m\" + text + \"\\033[0m\";\n}", "test_code": "TEST_CASE(\"Test Colors\", \"[Colors]\") {\n    SECTION(\"Test the red color method\") {\n        const std::string input_text = \"Hello\";\n        const std::string expected_output = \"\\033[91mHello\\033[0m\";\n        REQUIRE(Colors::red(input_text) == expected_output);\n    }\n\n    SECTION(\"Test the green color method\") {\n        const std::string input_text = \"Hello\";\n        const std::string expected_output = \"\\033[92mHello\\033[0m\";\n        REQUIRE(Colors::green(input_text) == expected_output);\n    }\n\n    SECTION(\"Test the blue color method\") {\n        const std::string input_text = \"Hello\";\n        const std::string expected_output = \"\\033[94mHello\\033[0m\";\n        REQUIRE(Colors::blue(input_text) == expected_output);\n    }\n\n    SECTION(\"Test the yellow color method\") {\n        const std::string input_text = \"Hello\";\n        const std::string expected_output = \"\\033[93mHello\\033[0m\";\n        REQUIRE(Colors::yellow(input_text) == expected_output);\n    }\n\n    SECTION(\"Test the magenta color method\") {\n        const std::string input_text = \"Hello\";\n        const std::string expected_output = \"\\033[95mHello\\033[0m\";\n        REQUIRE(Colors::magenta(input_text) == expected_output);\n    }\n\n    SECTION(\"Test the cyan color method\") {\n        const std::string input_text = \"Hello\";\n        const std::string expected_output = \"\\033[96mHello\\033[0m\";\n        REQUIRE(Colors::cyan(input_text) == expected_output);\n    }\n\n    SECTION(\"Test combining different color methods\") {\n        const std::string input_text_red = Colors::red(\"Red\");\n        const std::string input_text_blue = Colors::blue(\"Blue\");\n        const std::string input_text_combined = input_text_red + \" and \" + input_text_blue;\n        const std::string expected_output = \"\\033[91mRed\\033[0m and \\033[94mBlue\\033[0m\";\n        REQUIRE(input_text_combined == expected_output);\n    }\n}", "prompt": "please write a cpp class , the class signature as below class Colors {\npublic:\n    // Function to return text in red color\n    static std::string red(const std::string& text);\n\n    // Function to return text in green color\n    static std::string green(const std::string& text);\n\n    // Function to return text in blue color\n    static std::string blue(const std::string& text);\n\n    // Function to return text in yellow color\n    static std::string yellow(const std::string& text);\n\n    // Function to return text in magenta color\n    static std::string magenta(const std::string& text);\n\n    // Function to return text in cyan color\n    static std::string cyan(const std::string& text);\n};\n\n// Implementation of each function (you can add actual implementation here)\nstd::string Colors::red(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[31m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::green(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[32m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::blue(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[34m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::yellow(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[33m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::magenta(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[35m\" + text + \"\\033[0m\";\n}\n\nstd::string Colors::cyan(const std::string& text) {\n    // Placeholder implementation\n    return \"\\033[36m\" + text + \"\\033[0m\";\n}", "addition_info": ""}, "java": {"code_signature": "public final class Colors {\n\n    // Private constructor to prevent instantiation of utility class\n    private Colors() {\n        throw new UnsupportedOperationException(\"Utility class\");\n    }\n\n    /**\n     * Returns the text in red color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for red color.\n     */\n    public static String red(String text) {\n        return \"\\u001B[31m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in green color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for green color.\n     */\n    public static String green(String text) {\n        return \"\\u001B[32m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in blue color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for blue color.\n     */\n    public static String blue(String text) {\n        return \"\\u001B[34m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in yellow color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for yellow color.\n     */\n    public static String yellow(String text) {\n        return \"\\u001B[33m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in magenta color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for magenta color.\n     */\n    public static String magenta(String text) {\n        return \"\\u001B[35m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in cyan color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for cyan color.\n     */\n    public static String cyan(String text) {\n        return \"\\u001B[36m\" + text + \"\\u001B[0m\";\n    }\n}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Tester {\n\n    // Assuming these methods will be implemented with some functionality\n    public String red(String text) {\n        return \"\\033[31m\" + text + \"\\033[0m\";\n    }\n\n    public String green(String text) {\n        return \"\\033[32m\" + text + \"\\033[0m\";\n    }\n\n    public String blue(String text) {\n        return \"\\033[34m\" + text + \"\\033[0m\";\n    }\n\n    public String yellow(String text) {\n        return \"\\033[33m\" + text + \"\\033[0m\";\n    }\n\n    public String magenta(String text) {\n        return \"\\033[35m\" + text + \"\\033[0m\";\n    }\n\n    public String cyan(String text) {\n        return \"\\033[36m\" + text + \"\\033[0m\";\n    }\n\n    @Test\n    public void testRed() {\n        assertEquals(\"\\033[31mHello\\033[0m\", red(\"Hello\"));\n    }\n\n    @Test\n    public void testGreen() {\n        assertEquals(\"\\033[32mHello\\033[0m\", green(\"Hello\"));\n    }\n\n    @Test\n    public void testBlue() {\n        assertEquals(\"\\033[34mHello\\033[0m\", blue(\"Hello\"));\n    }\n\n    @Test\n    public void testYellow() {\n        assertEquals(\"\\033[33mHello\\033[0m\", yellow(\"Hello\"));\n    }\n\n    @Test\n    public void testMagenta() {\n        assertEquals(\"\\033[35mHello\\033[0m\", magenta(\"Hello\"));\n    }\n\n    @Test\n    public void testCyan() {\n        assertEquals(\"\\033[36mHello\\033[0m\", cyan(\"Hello\"));\n    }\n}", "prompt": "please write a java class , the function signature as below public final class Colors {\n\n    // Private constructor to prevent instantiation of utility class\n    private Colors() {\n        throw new UnsupportedOperationException(\"Utility class\");\n    }\n\n    /**\n     * Returns the text in red color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for red color.\n     */\n    public static String red(String text) {\n        return \"\\u001B[31m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in green color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for green color.\n     */\n    public static String green(String text) {\n        return \"\\u001B[32m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in blue color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for blue color.\n     */\n    public static String blue(String text) {\n        return \"\\u001B[34m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in yellow color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for yellow color.\n     */\n    public static String yellow(String text) {\n        return \"\\u001B[33m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in magenta color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for magenta color.\n     */\n    public static String magenta(String text) {\n        return \"\\u001B[35m\" + text + \"\\u001B[0m\";\n    }\n\n    /**\n     * Returns the text in cyan color.\n     *\n     * @param text The text to be colored.\n     * @return The text wrapped in ANSI escape codes for cyan color.\n     */\n    public static String cyan(String text) {\n        return \"\\u001B[36m\" + text + \"\\u001B[0m\";\n    }\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 410, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Checks the XOR sums of specific columns in a given combination array.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef check_xor_sum(combination: np.ndarray):\n    \"\"\"\n    Checks the XOR sums of specific columns in a given combination array.\n\n    Args:\n        combination (np.ndarray): A 2D numpy array where each column corresponds\n                                  to a specific value.\n\n    Returns:\n        bool: True if the XOR sums of the specified columns match the required\n              values; otherwise, False.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestCheckXorSum(unittest.TestCase):\n\n    def test_correct_xor_sums(self):\n        \"\"\" Test with combination values that produce the expected XOR sums. \"\"\"\n        combination = np.array([\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n        ])\n        self.assertFalse(check_xor_sum(combination))\n\n    def test_incorrect_xor_sums(self):\n        \"\"\" Test with combination values that do not meet the expected XOR sums. \"\"\"\n        combination = np.array([\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00]\n        ])\n        self.assertFalse(check_xor_sum(combination))\n\n    def test_edge_case_with_zero(self):\n        \"\"\" Test with a combination where all values are zero. \"\"\"\n        combination = np.zeros((1, 8), dtype=int)  # 1 row of zeros\n        self.assertFalse(check_xor_sum(combination))\n\n    def test_large_numbers(self):\n        \"\"\" Test with large numbers in the combination. \"\"\"\n        combination = np.array([\n            [0x6b000000, 0x00000000, 0x00000012, 0x00000000, 0x76000000, 0x00000000, 0x00000000, 0x00000000],\n            [0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]\n        ])\n        self.assertFalse(check_xor_sum(combination))\n\n    def test_multiple_rows(self):\n        \"\"\" Test with a combination that contains multiple rows. \"\"\"\n        combination = np.array([\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00]\n        ])\n        self.assertTrue(check_xor_sum(combination))", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef check_xor_sum(combination: np.ndarray):\n    \"\"\"\n    Checks the XOR sums of specific columns in a given combination array.\n\n    Args:\n        combination (np.ndarray): A 2D numpy array where each column corresponds\n                                  to a specific value.\n\n    Returns:\n        bool: True if the XOR sums of the specified columns match the required\n              values; otherwise, False.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Checks the XOR sums of specific columns in a given combination array.\n *\n * @param {Array<Array<number>>} combination - A 2D array where each column corresponds to a specific value.\n * @returns {boolean} - True if the XOR sums of the specified columns match the required values; otherwise, false.\n */\nfunction checkXorSum(combination) {}", "test_code": "describe('TestCheckXorSum', () => {\n    it('test_correct_xor_sums', () => {\n        /** Test with combination values that produce the expected XOR sums. */\n        const combination = [\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n        ];\n        expect(checkXorSum(combination)).toBe(false);\n    });\n\n    it('test_incorrect_xor_sums', () => {\n        /** Test with combination values that do not meet the expected XOR sums. */\n        const combination = [\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00]\n        ];\n        expect(checkXorSum(combination)).toBe(false);\n    });\n\n    it('test_edge_case_with_zero', () => {\n        /** Test with a combination where all values are zero. */\n        const combination = [[0, 0, 0, 0, 0, 0, 0, 0]]; // 1 row of zeros\n        expect(checkXorSum(combination)).toBe(false);\n    });\n\n    it('test_large_numbers', () => {\n        /** Test with large numbers in the combination. */\n        const combination = [\n            [0x6b000000, 0x00000000, 0x00000012, 0x00000000, 0x76000000, 0x00000000, 0x00000000, 0x00000000],\n            [0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]\n        ];\n        expect(checkXorSum(combination)).toBe(false);\n    });\n\n    it('test_multiple_rows', () => {\n        /** Test with a combination that contains multiple rows. */\n        const combination = [\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00]\n        ];\n        expect(checkXorSum(combination)).toBe(true);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Checks the XOR sums of specific columns in a given combination array.\n *\n * @param {Array<Array<number>>} combination - A 2D array where each column corresponds to a specific value.\n * @returns {boolean} - True if the XOR sums of the specified columns match the required values; otherwise, false.\n */\nfunction checkXorSum(combination) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Checks the XOR sums of specific columns in a given combination array.\n *\n * @param combination - A 2D array where each column corresponds to a specific value.\n * @returns true if the XOR sums of the specified columns match the required values; otherwise, false.\n */\nfunction checkXorSum(combination: number[][]): boolean {}", "test_code": "describe('TestCheckXorSum', () => {\n  /**\n   * Test with combination values that produce the expected XOR sums.\n   */\n  it('test correct XOR sums', () => {\n      const combination: number[][] = [\n          [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n          [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n      ];\n      expect(checkXorSum(combination)).toBe(false);\n  });\n\n  /**\n   * Test with combination values that do not meet the expected XOR sums.\n   */\n  it('test incorrect XOR sums', () => {\n      const combination: number[][] = [\n          [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n          [0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00]\n      ];\n      expect(checkXorSum(combination)).toBe(false);\n  });\n\n  /**\n   * Test with a combination where all values are zero.\n   */\n  it('test edge case with zero', () => {\n      const combination: number[][] = [[0, 0, 0, 0, 0, 0, 0, 0]];\n      expect(checkXorSum(combination)).toBe(false);\n  });\n\n  /**\n   * Test with large numbers in the combination.\n   */\n  it('test large numbers', () => {\n      const combination: number[][] = [\n          [0x6b000000, 0x00000000, 0x00000012, 0x00000000, 0x76000000, 0x00000000, 0x00000000, 0x00000000],\n          [0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]\n      ];\n      expect(checkXorSum(combination)).toBe(false);\n  });\n\n  /**\n   * Test with a combination that contains multiple rows.\n   */\n  it('test multiple rows', () => {\n      const combination: number[][] = [\n          [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n          [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n          [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00]\n      ];\n      expect(checkXorSum(combination)).toBe(true);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Checks the XOR sums of specific columns in a given combination array.\n *\n * @param combination - A 2D array where each column corresponds to a specific value.\n * @returns true if the XOR sums of the specified columns match the required values; otherwise, false.\n */\nfunction checkXorSum(combination: number[][]): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Checks the XOR sums of specific columns in a given combination array.\n *\n * @param combination A 2D vector where each column corresponds to a specific value.\n * @return True if the XOR sums of the specified columns match the required values; otherwise, False.\n */\nbool check_xor_sum(const std::vector<std::vector<int>>& combination);", "test_code": "TEST_CASE(\"TestCheckXorSum\", \"[check_xor_sum]\") {\n    SECTION(\"test_correct_xor_sums\") {\n        // Test with combination values that produce the expected XOR sums.\n        Eigen::ArrayXi combination(2, 8);\n        combination << 0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00,\n                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00;\n        REQUIRE_FALSE(check_xor_sum(combination));\n    }\n\n    SECTION(\"test_incorrect_xor_sums\") {\n        // Test with combination values that do not meet the expected XOR sums.\n        Eigen::ArrayXi combination(2, 8);\n        combination << 0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00,\n                       0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00;\n        REQUIRE_FALSE(check_xor_sum(combination));\n    }\n\n    SECTION(\"test_edge_case_with_zero\") {\n        // Test with a combination where all values are zero.\n        Eigen::ArrayXi combination(1, 8);\n        combination.setZero();\n        REQUIRE_FALSE(check_xor_sum(combination));\n    }\n\n    SECTION(\"test_large_numbers\") {\n        // Test with large numbers in the combination.\n        Eigen::ArrayXi combination(2, 8);\n        combination << 0x6b000000, 0x00000000, 0x00000012, 0x00000000, 0x76000000, 0x00000000, 0x00000000, 0x00000000,\n                       0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000;\n        REQUIRE_FALSE(check_xor_sum(combination));\n    }\n\n    SECTION(\"test_multiple_rows\") {\n        // Test with a combination that contains multiple rows.\n        Eigen::ArrayXi combination(3, 8);\n        combination << 0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00,\n                       0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00,\n                       0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00;\n        REQUIRE(check_xor_sum(combination));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Checks the XOR sums of specific columns in a given combination array.\n *\n * @param combination A 2D vector where each column corresponds to a specific value.\n * @return True if the XOR sums of the specified columns match the required values; otherwise, False.\n */\nbool check_xor_sum(const std::vector<std::vector<int>>& combination);", "addition_info": ""}, "java": {"code_signature": "public class Main {\n\n    /**\n     * Checks the XOR sums of specific columns in a given combination array.\n     *\n     * @param combination A 2D int array where each column corresponds to a specific value.\n     * @return True if the XOR sums of the specified columns match the required values; otherwise, false.\n     */\n    public static boolean checkXorSum(int[][] combination) {\n        // Your implementation here\n    }\n\n}", "test_code": "import static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testCheckXorSum() {\n        // Assuming check_xor_sum is implemented and available here\n        // For demonstration purposes, let's create a mock implementation\n        boolean result = check_xor_sum(new int[][]{\n            {1, 0, 1},\n            {0, 1, 0},\n            {1, 1, 1}\n        });\n\n        assertTrue(result); // Adjust the assertion based on expected behavior\n    }\n\n    private boolean check_xor_sum(int[][] combination) {\n        // Implement the logic for checking XOR sums here\n        // This is a placeholder for the actual implementation\n        return true; // Placeholder return value\n    }\n}", "prompt": "please write a java function , the function signature as below public class Main {\n\n    /**\n     * Checks the XOR sums of specific columns in a given combination array.\n     *\n     * @param combination A 2D int array where each column corresponds to a specific value.\n     * @return True if the XOR sums of the specified columns match the required values; otherwise, false.\n     */\n    public static boolean checkXorSum(int[][] combination) {\n        // Your implementation here\n    }\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 412, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Read content from a text file, remove the line breaks at the end of each line, make sure there is a space at the end of each line (unless it already exists), and finally merge these processed lines into a single string that is written to an output file\n", "language_version_list": {"python": {"code_signature": "def format_text(input_file='input.txt', output_file='output.txt'):\n    \"\"\"\n    Formats the text by removing newline characters and adding spaces between lines.\n\n    Args:\n        input_file (str, optional): needed format file. Defaults to 'input.txt'.\n        output_file (str, optional): output file path. Defaults to 'output.txt'.\n    \"\"\"", "test_code": "import os\nimport tempfile\nimport unittest\n\n\nclass TestFormatText(unittest.TestCase):\n\n    def test_basic_text(self):\n        # Test with basic text\n        input_text = \"This is line one.\\nThis is line two.\\nThis is line three.\"\n        expected_output = \"This is line one. This is line two. This is line three.\"\n\n        with tempfile.NamedTemporaryFile(delete=False, mode='w+t') as input_file:\n            input_file.write(input_text)\n            input_file.seek(0)  # Go back to the start of the file\n            output_file_path = tempfile.mktemp(suffix='.txt')  # Create a temporary output file\n\n            format_text(input_file.name, output_file_path)\n\n            with open(output_file_path, 'r') as output_file:\n                output_text = output_file.read().strip()\n\n            self.assertEqual(expected_output, output_text)\n\n        os.remove(input_file.name)\n        os.remove(output_file_path)\n\n    def test_single_line(self):\n        # Test with a single line\n        input_text = \"This is a single line.\"\n        expected_output = \"This is a single line.\"\n\n        with tempfile.NamedTemporaryFile(delete=False, mode='w+t') as input_file:\n            input_file.write(input_text)\n            input_file.seek(0)\n            output_file_path = tempfile.mktemp(suffix='.txt')\n\n            format_text(input_file.name, output_file_path)\n\n            with open(output_file_path, 'r') as output_file:\n                output_text = output_file.read().strip()\n\n            self.assertEqual(expected_output, output_text)\n\n        os.remove(input_file.name)\n        os.remove(output_file_path)\n\n    def test_empty_file(self):\n        # Test with an empty file\n        input_text = \"\"\n        expected_output = \"\"\n\n        with tempfile.NamedTemporaryFile(delete=False, mode='w+t') as input_file:\n            input_file.write(input_text)\n            input_file.seek(0)\n            output_file_path = tempfile.mktemp(suffix='.txt')\n\n            format_text(input_file.name, output_file_path)\n\n            with open(output_file_path, 'r') as output_file:\n                output_text = output_file.read().strip()\n\n            self.assertEqual(expected_output, output_text)\n\n        os.remove(input_file.name)\n        os.remove(output_file_path)\n\n    def test_file_with_no_newlines(self):\n        # Test with text that has no newlines\n        input_text = \"This is a continuous line without breaks.\"\n        expected_output = \"This is a continuous line without breaks.\"\n\n        with tempfile.NamedTemporaryFile(delete=False, mode='w+t') as input_file:\n            input_file.write(input_text)\n            input_file.seek(0)\n            output_file_path = tempfile.mktemp(suffix='.txt')\n\n            format_text(input_file.name, output_file_path)\n\n            with open(output_file_path, 'r') as output_file:\n                output_text = output_file.read().strip()\n\n            self.assertEqual(expected_output, output_text)\n\n        os.remove(input_file.name)\n        os.remove(output_file_path)\n", "prompt": "please write a python function , the function signature as below def format_text(input_file='input.txt', output_file='output.txt'):\n    \"\"\"\n    Formats the text by removing newline characters and adding spaces between lines.\n\n    Args:\n        input_file (str, optional): needed format file. Defaults to 'input.txt'.\n        output_file (str, optional): output file path. Defaults to 'output.txt'.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Formats the text by removing newline characters and adding spaces between lines.\n *\n * @param input_file The path to the input file.\n * @param output_file The path to the output file.\n */\nvoid format_text(const std::string& input_file = \"input.txt\", const std::string& output_file = \"output.txt\") {}", "test_code": "TEST_CASE(\"Testformat_text\", \"[format_text]\") {\n    SECTION(\"test_basic_text\") {\n        // Test with basic text\n        std::string input_text = \"This is line one.\\nThis is line two.\\nThis is line three.\";\n        std::string expected_output = \"This is line one. This is line two. This is line three.\";\n\n        // Create a temporary directory\n        std::filesystem::path temp_dir = std::filesystem::temp_directory_path();\n        std::string input_file_path = (temp_dir / \"input.txt\").string();\n        std::string output_file_path = (temp_dir / \"output.txt\").string();\n\n        // Write input text to the temporary input file\n        std::ofstream input_file(input_file_path);\n        input_file << input_text;\n        input_file.close();\n\n        // Call the format_text function\n        format_text(input_file_path, output_file_path);\n\n        // Read the output file\n        std::ifstream output_file(output_file_path);\n        std::string output_text((std::istreambuf_iterator<char>(output_file)), std::istreambuf_iterator<char>());\n        output_file.close();\n\n        // Check the output\n        REQUIRE(expected_output == output_text);\n\n        // Clean up\n        std::remove(input_file_path.c_str());\n        std::remove(output_file_path.c_str());\n    }\n\n    SECTION(\"test_single_line\") {\n        // Test with a single line\n        std::string input_text = \"This is a single line.\";\n        std::string expected_output = \"This is a single line.\";\n\n        // Create a temporary directory\n        std::filesystem::path temp_dir = std::filesystem::temp_directory_path();\n        std::string input_file_path = (temp_dir / \"input.txt\").string();\n        std::string output_file_path = (temp_dir / \"output.txt\").string();\n\n        // Write input text to the temporary input file\n        std::ofstream input_file(input_file_path);\n        input_file << input_text;\n        input_file.close();\n\n        // Call the format_text function\n        format_text(input_file_path, output_file_path);\n\n        // Read the output file\n        std::ifstream output_file(output_file_path);\n        std::string output_text((std::istreambuf_iterator<char>(output_file)), std::istreambuf_iterator<char>());\n        output_file.close();\n\n        // Check the output\n        REQUIRE(expected_output == output_text);\n\n        // Clean up\n        std::remove(input_file_path.c_str());\n        std::remove(output_file_path.c_str());\n    }\n\n    SECTION(\"test_empty_file\") {\n        // Test with an empty file\n        std::string input_text = \"\";\n        std::string expected_output = \"\";\n\n        // Create a temporary directory\n        std::filesystem::path temp_dir = std::filesystem::temp_directory_path();\n        std::string input_file_path = (temp_dir / \"input.txt\").string();\n        std::string output_file_path = (temp_dir / \"output.txt\").string();\n\n        // Write input text to the temporary input file\n        std::ofstream input_file(input_file_path);\n        input_file << input_text;\n        input_file.close();\n\n        // Call the format_text function\n        format_text(input_file_path, output_file_path);\n\n        // Read the output file\n        std::ifstream output_file(output_file_path);\n        std::string output_text((std::istreambuf_iterator<char>(output_file)), std::istreambuf_iterator<char>());\n        output_file.close();\n\n        // Check the output\n        REQUIRE(expected_output == output_text);\n\n        // Clean up\n        std::remove(input_file_path.c_str());\n        std::remove(output_file_path.c_str());\n    }\n\n    SECTION(\"test_file_with_no_newlines\") {\n        // Test with text that has no newlines\n        std::string input_text = \"This is a continuous line without breaks.\";\n        std::string expected_output = \"This is a continuous line without breaks.\";\n\n        // Create a temporary directory\n        std::filesystem::path temp_dir = std::filesystem::temp_directory_path();\n        std::string input_file_path = (temp_dir / \"input.txt\").string();\n        std::string output_file_path = (temp_dir / \"output.txt\").string();\n\n        // Write input text to the temporary input file\n        std::ofstream input_file(input_file_path);\n        input_file << input_text;\n        input_file.close();\n\n        // Call the format_text function\n        format_text(input_file_path, output_file_path);\n\n        // Read the output file\n        std::ifstream output_file(output_file_path);\n        std::string output_text((std::istreambuf_iterator<char>(output_file)), std::istreambuf_iterator<char>());\n        output_file.close();\n\n        // Check the output\n        REQUIRE(expected_output == output_text);\n\n        // Clean up\n        std::remove(input_file_path.c_str());\n        std::remove(output_file_path.c_str());\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Formats the text by removing newline characters and adding spaces between lines.\n *\n * @param input_file The path to the input file.\n * @param output_file The path to the output file.\n */\nvoid format_text(const std::string& input_file = \"input.txt\", const std::string& output_file = \"output.txt\") {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 413, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Filter out the number of palindrome within any number n. Palindrome numbers are numbers with the same correction and reverse readings, such as 121, 1331\n", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef get_palindrome_list(n: int) ->  List[int]:\n    \"\"\"\n    Filter out the number of palindrome within any number n. Palindrome numbers are numbers with the same correction and reverse readings, such as 121, 1331\n\n    Args:\n        n (int): range number\n\n    Returns:\n        List[int]: Palindrome numbers\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestNthPalindrome(unittest.TestCase):\n    def test_single_digit(self):\n        \"\"\"Test case for the first palindrome\"\"\"\n        self.assertEqual(get_palindrome_list(1), [0], \"The first palindrome should be 0\")\n\n    def test_edge_of_single_and_double_digits(self):\n        \"\"\"Test case for the tenth palindrome, transitioning to double digits\"\"\"\n        self.assertEqual(get_palindrome_list(10), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n                         \"The tenth palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\")\n\n    def test_edge_of_double_and_triple_digits(self):\n        \"\"\"Test case for the 100th palindrome, transitioning to triple digits\"\"\"\n        self.assertEqual(get_palindrome_list(100), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99],\n                         \"The 100th palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99]\")\n\n    def test_large_number(self):\n        \"\"\"Test case for a larger number, e.g., the 1000th palindrome\"\"\"\n        self.assertEqual(get_palindrome_list(1000),\n                         [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141,\n                          151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333,\n                          343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525,\n                          535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717,\n                          727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909,\n                          919, 929, 939, 949, 959, 969, 979, 989, 999]\n                         ,\n                         \"The 1000th palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999]\")\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef get_palindrome_list(n: int) ->  List[int]:\n    \"\"\"\n    Filter out the number of palindrome within any number n. Palindrome numbers are numbers with the same correction and reverse readings, such as 121, 1331\n\n    Args:\n        n (int): range number\n\n    Returns:\n        List[int]: Palindrome numbers\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Filter out the number of palindromes within any number n. Palindrome numbers are numbers with the same forward and reverse readings, such as 121, 1331.\n *\n * @param {number} n - The range number.\n * @returns {Array<number>} - An array of palindrome numbers.\n */\nfunction getPalindromeList(n) {}", "test_code": "describe('TestNthPalindrome', () => {\n    it('test_single_digit', () => {\n        expect(getPalindromeList(1)).toEqual([0], 'The first palindrome should be 0');\n    });\n\n    it('test_edge_of_single_and_double_digits', () => {\n        expect(getPalindromeList(10)).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n            'The tenth palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]');\n    });\n\n    it('test_edge_of_double_and_triple_digits', () => {\n        expect(getPalindromeList(100)).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99],\n            'The 100th palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99]');\n    });\n\n    it('test_large_number', () => {\n        const expectedResult = [\n            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141,\n            151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323,\n            333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505,\n            515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686,\n            696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868,\n            878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999\n        ];\n        expect(getPalindromeList(1000)).toEqual(expectedResult,\n            'The 1000th palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999]');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Filter out the number of palindromes within any number n. Palindrome numbers are numbers with the same forward and reverse readings, such as 121, 1331.\n *\n * @param {number} n - The range number.\n * @returns {Array<number>} - An array of palindrome numbers.\n */\nfunction getPalindromeList(n) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Filters out the number of palindromes within any number `n`.\n * Palindrome numbers are numbers that read the same forwards and backwards, such as 121, 1331.\n *\n * @param n - The range number\n * @returns An array of palindrome numbers\n */\nfunction getPalindromeList(n: number): number[] {}", "test_code": "describe('getPalindromeList', () => {\n    /**\n     * Test case for the first palindrome\n     */\n    it('should return [0] for n = 1', () => {\n        expect(getPalindromeList(1)).toEqual([0], 'The first palindrome should be 0');\n    });\n\n    /**\n     * Test case for the tenth palindrome, transitioning to double digits\n     */\n    it('should return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] for n = 10', () => {\n        expect(getPalindromeList(10)).toEqual(\n            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n            'The tenth palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]'\n        );\n    });\n\n    /**\n     * Test case for the 100th palindrome, transitioning to triple digits\n     */\n    it('should return the correct palindromes for n = 100', () => {\n        expect(getPalindromeList(100)).toEqual(\n            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99],\n            'The 100th palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99]'\n        );\n    });\n\n    /**\n     * Test case for a larger number, e.g., the 1000th palindrome\n     */\n    it('should return the correct palindromes for n = 1000', () => {\n        expect(getPalindromeList(1000)).toEqual(\n            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999],\n            'The 1000th palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999]'\n        );\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Filters out the number of palindromes within any number `n`.\n * Palindrome numbers are numbers that read the same forwards and backwards, such as 121, 1331.\n *\n * @param n - The range number\n * @returns An array of palindrome numbers\n */\nfunction getPalindromeList(n: number): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <vector>\n#include <string>\n\n/**\n * @brief Filters out the number of palindromes within any number n.\n * Palindrome numbers are numbers with the same correction and reverse readings, such as 121, 1331.\n *\n * @param n The range number\n * @return std::vector<int> A vector containing palindrome numbers\n */\nstd::vector<int> get_palindrome_list(int n);", "test_code": "TEST_CASE(\"Test cases for get_palindrome_list\", \"[palindrome]\") {\n    SECTION(\"Test case for the first palindrome\") {\n        REQUIRE(get_palindrome_list(1) == std::vector<int>({0}));\n    }\n\n    SECTION(\"Test case for the tenth palindrome, transitioning to double digits\") {\n        REQUIRE(get_palindrome_list(10) == std::vector<int>({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}));\n    }\n\n    SECTION(\"Test case for the 100th palindrome, transitioning to triple digits\") {\n        REQUIRE(get_palindrome_list(100) == std::vector<int>({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99}));\n    }\n\n    SECTION(\"Test case for a larger number, e.g., the 1000th palindrome\") {\n        REQUIRE(get_palindrome_list(1000) == std::vector<int>({\n            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191,\n            202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434,\n            444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676,\n            686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919,\n            929, 939, 949, 959, 969, 979, 989, 999\n        }));\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <vector>\n#include <string>\n\n/**\n * @brief Filters out the number of palindromes within any number n.\n * Palindrome numbers are numbers with the same correction and reverse readings, such as 121, 1331.\n *\n * @param n The range number\n * @return std::vector<int> A vector containing palindrome numbers\n */\nstd::vector<int> get_palindrome_list(int n);", "addition_info": ""}, "java": {"code_signature": "/**\n * Filters out the number of palindromes within any number n.\n * Palindrome numbers are numbers that read the same backward as forward, such as 121, 1331.\n *\n * @param n the range number\n * @return a list of palindrome numbers\n */\npublic static List<Integer> getPalindromeList(int n) {}", "test_code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class NumberUtils {\n\n    public static List<Integer> getPalindromeList(int n) {\n        List<Integer> palindromes = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            if (isPalindrome(i)) {\n                palindromes.add(i);\n            }\n        }\n        return palindromes;\n    }\n\n    private static boolean isPalindrome(int number) {\n        String str = Integer.toString(number);\n        int left = 0;\n        int right = str.length() - 1;\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Filters out the number of palindromes within any number n.\n * Palindrome numbers are numbers that read the same backward as forward, such as 121, 1331.\n *\n * @param n the range number\n * @return a list of palindrome numbers\n */\npublic static List<Integer> getPalindromeList(int n) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 414, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Extract the title, author and year of the article from the bib file.", "language_version_list": {"python": {"code_signature": "def extract_bib_info(bib_file: str):\n    \"\"\"\n    Extracts the title, author, and year from a BibTeX file.bib file content such as @article{sample2024,\\n  author = {John Doe and Jane Smith},\\n  title = {A Comprehensive Study on AI},\\n  year = {2024}\\n}\n\n    Args:\n        bib_file (str): The path to the BibTeX file.\n\n    Returns:\n        list of dict: A list containing dictionaries with title, author, and year for each article.\n    \"\"\"\n", "test_code": "import re\nimport unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestExtractBibInfo(unittest.TestCase):\n\n    def test_valid_entry(self):\n        \"\"\"Test extraction from a valid BibTeX entry.\"\"\"\n        mock_bib = \"@article{sample2024,\\n  author = {John Doe and Jane Smith},\\n  title = {A Comprehensive Study on AI},\\n  year = {2024}\\n}\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = [{'title': 'A Comprehensive Study on AI', 'author': 'John Doe and Jane Smith', 'year': '2024'}]\n            self.assertEqual(result, expected)\n\n    def test_multiple_entries(self):\n        \"\"\"Test extraction from multiple BibTeX entries.\"\"\"\n        mock_bib = (\n            \"@article{sample2024,\\n\"\n            \"  author = {John Doe},\\n\"\n            \"  title = {A Comprehensive Study on AI},\\n\"\n            \"  year = {2024}\\n}\\n\"\n            \"@article{sample2023,\\n\"\n            \"  author = {Jane Smith},\\n\"\n            \"  title = {Deep Learning Techniques},\\n\"\n            \"  year = {2023}\\n}\"\n        )\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = [\n                {'title': 'A Comprehensive Study on AI', 'author': 'John Doe', 'year': '2024'},\n                {'title': 'Deep Learning Techniques', 'author': 'Jane Smith', 'year': '2023'}\n            ]\n            self.assertEqual(result, expected)\n\n    def test_missing_fields(self):\n        \"\"\"Test extraction when some fields are missing.\"\"\"\n        mock_bib = \"@article{sample2024,\\n  author = {John Doe},\\n  title = {Title Missing Year}\\n}\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = [{'title': 'Title Missing Year', 'author': 'John Doe', 'year': None}]\n            self.assertEqual(result, expected)\n\n    def test_empty_file(self):\n        \"\"\"Test extraction from an empty BibTeX file.\"\"\"\n        mock_bib = \"\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = []\n            self.assertEqual(result, expected)\n\n    def test_incorrect_format(self):\n        \"\"\"Test extraction from a badly formatted BibTeX entry.\"\"\"\n        mock_bib = \"@article{sample2024,\\n  author = John Doe,\\n  title = {Title Without Braces},\\n  year = 2024\\n}\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = [{'title': 'Title Without Braces', 'author': None, 'year': None}]\n            self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def extract_bib_info(bib_file: str):\n    \"\"\"\n    Extracts the title, author, and year from a BibTeX file.bib file content such as @article{sample2024,\\n  author = {John Doe and Jane Smith},\\n  title = {A Comprehensive Study on AI},\\n  year = {2024}\\n}\n\n    Args:\n        bib_file (str): The path to the BibTeX file.\n\n    Returns:\n        list of dict: A list containing dictionaries with title, author, and year for each article.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extracts the title, author, and year from a BibTeX file.\n * Example BibTeX file content:\n * \n * @article{sample2024,\n *   author = {John Doe and Jane Smith},\n *   title = {A Comprehensive Study on AI},\n *   year = {2024}\n * }\n *\n * @param {string} bibFile - The path to the BibTeX file.\n * @returns {Array<Object>} - An array containing objects with title, author, and year for each article.\n */\nfunction extractBibInfo(bibFile) {}", "test_code": "const fs = require('fs');\nconst { mock } = require('jest-mock-extended');\n\n\ndescribe('extractBibInfo', () => {\n    beforeEach(() => {\n        jest.spyOn(fs, 'readFileSync').mockImplementation((path, encoding) => {\n            if (path === 'dummy.bib') {\n                return 'dummy content';\n            }\n            return '';\n        });\n    });\n\n    afterEach(() => {\n        jest.restoreAllMocks();\n    });\n\n    it('test extraction from a valid BibTeX entry', () => {\n        const mockBib = `\n            @article{sample2024,\n              author = {John Doe and Jane Smith},\n              title = {A Comprehensive Study on AI},\n              year = {2024}\n            }\n        `;\n        fs.readFileSync.mockReturnValue(mockBib);\n\n        const result = extractBibInfo('dummy.bib');\n        const expected = [{\n            title: 'A Comprehensive Study on AI',\n            author: 'John Doe and Jane Smith',\n            year: '2024'\n        }];\n        expect(result).toEqual(expected);\n    });\n\n    it('test extraction from multiple BibTeX entries', () => {\n        const mockBib = `\n            @article{sample2024,\n              author = {John Doe},\n              title = {A Comprehensive Study on AI},\n              year = {2024}\n            }\n            @article{sample2023,\n              author = {Jane Smith},\n              title = {Deep Learning Techniques},\n              year = {2023}\n            }\n        `;\n        fs.readFileSync.mockReturnValue(mockBib);\n\n        const result = extractBibInfo('dummy.bib');\n        const expected = [\n            {\n                title: 'A Comprehensive Study on AI',\n                author: 'John Doe',\n                year: '2024'\n            },\n            {\n                title: 'Deep Learning Techniques',\n                author: 'Jane Smith',\n                year: '2023'\n            }\n        ];\n        expect(result).toEqual(expected);\n    });\n\n    it('test extraction when some fields are missing', () => {\n        const mockBib = `\n            @article{sample2024,\n              author = {John Doe},\n              title = {Title Missing Year}\n            }\n        `;\n        fs.readFileSync.mockReturnValue(mockBib);\n\n        const result = extractBibInfo('dummy.bib');\n        const expected = [{\n            title: 'Title Missing Year',\n            author: 'John Doe',\n            year: null\n        }];\n        expect(result).toEqual(expected);\n    });\n\n    it('test extraction from an empty BibTeX file', () => {\n        const mockBib = '';\n        fs.readFileSync.mockReturnValue(mockBib);\n\n        const result = extractBibInfo('dummy.bib');\n        const expected = [];\n        expect(result).toEqual(expected);\n    });\n\n    it('test extraction from a badly formatted BibTeX entry', () => {\n        const mockBib = `\n            @article{sample2024,\n              author = John Doe,\n              title = {Title Without Braces},\n              year = 2024\n            }\n        `;\n        fs.readFileSync.mockReturnValue(mockBib);\n\n        const result = extractBibInfo('dummy.bib');\n        const expected = [{\n            title: 'Title Without Braces',\n            author: null,\n            year: null\n        }];\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Extracts the title, author, and year from a BibTeX file.\n * Example BibTeX file content:\n * \n * @article{sample2024,\n *   author = {John Doe and Jane Smith},\n *   title = {A Comprehensive Study on AI},\n *   year = {2024}\n * }\n *\n * @param {string} bibFile - The path to the BibTeX file.\n * @returns {Array<Object>} - An array containing objects with title, author, and year for each article.\n */\nfunction extractBibInfo(bibFile) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as fs from 'fs';\nimport * as xregexp from 'xregexp';\n\n/**\n * Extracts the title, author, and year from a BibTeX file.\n * Example BibTeX file content:\n * @article{sample2024,\n *   author = {John Doe and Jane Smith},\n *   title = {A Comprehensive Study on AI},\n *   year = {2024}\n * }\n *\n * @param bibFile The path to the BibTeX file.\n * @returns An array of objects containing the title, author, and year for each article.\n */\nfunction extractBibInfo(bibFile: string): Array<{ title?: string; author?: string; year?: string }> {}", "test_code": "describe('TestExtractBibInfo', () => {\n    it('test valid entry', () => {\n        const mockBib = `@article{sample2024,\n            author = {John Doe and Jane Smith},\n            title = {A Comprehensive Study on AI},\n            year = {2024}\n        }`;\n        const mockOpen = jest.fn().mockImplementation(() => ({\n            readFileSync: jest.fn().mockReturnValue(mockBib),\n        }));\n\n        const result = extractBibInfo('dummy.bib');\n        const expected = [{ title: 'A Comprehensive Study on AI', author: 'John Doe and Jane Smith', year: '2024' }];\n        expect(result).toEqual(expected);\n    });\n\n    it('test multiple entries', () => {\n        const mockBib = `\n            @article{sample2024,\n                author = {John Doe},\n                title = {A Comprehensive Study on AI},\n                year = {2024}\n            }\n            @article{sample2023,\n                author = {Jane Smith},\n                title = {Deep Learning Techniques},\n                year = {2023}\n            }\n        `;\n        const mockOpen = jest.fn().mockImplementation(() => ({\n            readFileSync: jest.fn().mockReturnValue(mockBib),\n        }));\n\n        const result = extractBibInfo('dummy.bib');\n        const expected = [\n            { title: 'A Comprehensive Study on AI', author: 'John Doe', year: '2024' },\n            { title: 'Deep Learning Techniques', author: 'Jane Smith', year: '2023' }\n        ];\n        expect(result).toEqual(expected);\n    });\n\n    it('test missing fields', () => {\n        const mockBib = `@article{sample2024,\n            author = {John Doe},\n            title = {Title Missing Year}\n        }`;\n        const mockOpen = jest.fn().mockImplementation(() => ({\n            readFileSync: jest.fn().mockReturnValue(mockBib),\n        }));\n\n        const result = extractBibInfo('dummy.bib');\n        const expected = [{ title: 'Title Missing Year', author: 'John Doe', year: undefined }];\n        expect(result).toEqual(expected);\n    });\n\n    it('test empty file', () => {\n        const mockBib = '';\n        const mockOpen = jest.fn().mockImplementation(() => ({\n            readFileSync: jest.fn().mockReturnValue(mockBib),\n        }));\n\n        const result = extractBibInfo('dummy.bib');\n        const expected = [];\n        expect(result).toEqual(expected);\n    });\n\n    it('test incorrect format', () => {\n        const mockBib = `@article{sample2024,\n            author = John Doe,\n            title = {Title Without Braces},\n            year = 2024\n        }`;\n        const mockOpen = jest.fn().mockImplementation(() => ({\n            readFileSync: jest.fn().mockReturnValue(mockBib),\n        }));\n\n        const result = extractBibInfo('dummy.bib');\n        const expected = [{ title: 'Title Without Braces', author: undefined, year: undefined }];\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below import * as fs from 'fs';\nimport * as xregexp from 'xregexp';\n\n/**\n * Extracts the title, author, and year from a BibTeX file.\n * Example BibTeX file content:\n * @article{sample2024,\n *   author = {John Doe and Jane Smith},\n *   title = {A Comprehensive Study on AI},\n *   year = {2024}\n * }\n *\n * @param bibFile The path to the BibTeX file.\n * @returns An array of objects containing the title, author, and year for each article.\n */\nfunction extractBibInfo(bibFile: string): Array<{ title?: string; author?: string; year?: string }> {}", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 420, "code_type": "class", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Find the minimum distance between two specified words (word1 and word2) from the file and return in which line the distance occurred\n", "language_version_list": {"python": {"code_signature": "from ast import Tuple\n\n\ndef get_min_distance_between_2_word(file_path:str, word1:str, word2:str) -> Tuple:\n    \"\"\"\n    Find the minimum distance between two specified words (word1 and word2) from the file and return in which line the distance occurred\n\n    Args:\n        file_path (str): file path str\n        word1 (str): specified word1 \n        word2 (str): specified word2\n\n    Returns:\n        Tuple: line the distance between two word\n    \"\"\"", "test_code": "import unittest\nfrom unittest.mock import patch\n\n\nclass TestGetMinDistance(unittest.TestCase):\n    @patch('builtins.open')\n    def test_simple_case(self, mock_open):\n        # Mock the file read operation\n        mock_open.return_value.__enter__.return_value = iter([\n            \"hello world\",\n            \"hello hello world\",\n            \"world hello\"\n        ])\n        self.assertEqual(get_min_distance_between_2_word(\"dummy_file.txt\", \"hello\", \"world\"), (0, 1))\n\n\n    @patch('builtins.open')\n    def test_multiple_lines(self, mock_open):\n        mock_open.return_value.__enter__.return_value = iter([\n            \"hello planet\",\n            \"world hello planet\",\n            \"hello world planet\"\n        ])\n        self.assertEqual(get_min_distance_between_2_word(\"dummy_file.txt\", \"hello\", \"world\"), (1, 1))\n\n    @patch('builtins.open')\n    def test_large_distance(self, mock_open):\n        mock_open.return_value.__enter__.return_value = iter([\n            \"hello a b c d e f g h i j k l m n o p q r s t u v w x y z world\"\n        ])\n        self.assertEqual(get_min_distance_between_2_word(\"dummy_file.txt\", \"hello\", \"world\"), (0, 27))\n\n    @patch('builtins.open')\n    def test_adjacent_words(self, mock_open):\n        mock_open.return_value.__enter__.return_value = iter([\n            \"hello world\",\n            \"hello hello world world\",\n            \"world hello\"\n        ])\n        self.assertEqual(get_min_distance_between_2_word(\"dummy_file.txt\", \"hello\", \"world\"), (0, 1))\n", "prompt": "please write a python class , the class signature as below from ast import Tuple\n\n\ndef get_min_distance_between_2_word(file_path:str, word1:str, word2:str) -> Tuple:\n    \"\"\"\n    Find the minimum distance between two specified words (word1 and word2) from the file and return in which line the distance occurred\n\n    Args:\n        file_path (str): file path str\n        word1 (str): specified word1 \n        word2 (str): specified word2\n\n    Returns:\n        Tuple: line the distance between two word\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Find the minimum distance between two specified words (word1 and word2) from the file and return in which line the distance occurred.\n *\n * @param {string} filePath - The path to the file.\n * @param {string} word1 - The first word to search for.\n * @param {string} word2 - The second word to search for.\n * @returns {[number | null, number | null]} - An array containing the line number and the minimum distance, or [null, null] if not found.\n */\nfunction getMinDistance(filePath, word1, word2) {}", "test_code": "const fs = require('fs');\n\ndescribe('TestGetMinDistance', () => {\n    beforeEach(() => {\n        jest.spyOn(fs, 'readFileSync').mockImplementation(() => '');\n    });\n\n    afterEach(() => {\n        fs.readFileSync.mockRestore();\n    });\n\n    test('test simple case', () => {\n        // Mock the file read operation\n        fs.readFileSync.mockImplementation(() => {\n            return Buffer.from(`\n                hello world\n                hello hello world\n                world hello\n            `);\n        });\n\n        expect(getMinDistance('dummy_file.txt', 'hello', 'world')).toEqual([0, 1]);\n    });\n\n    test('test multiple lines', () => {\n        fs.readFileSync.mockImplementation(() => {\n            return Buffer.from(`\n                hello planet\n                world hello planet\n                hello world planet\n            `);\n        });\n\n        expect(getMinDistance('dummy_file.txt', 'hello', 'world')).toEqual([1, 1]);\n    });\n\n    test('test large distance', () => {\n        fs.readFileSync.mockImplementation(() => {\n            return Buffer.from(`\n                hello a b c d e f g h i j k l m n o p q r s t u v w x y z world\n            `);\n        });\n\n        expect(getMinDistance('dummy_file.txt', 'hello', 'world')).toEqual([0, 27]);\n    });\n\n    test('test adjacent words', () => {\n        fs.readFileSync.mockImplementation(() => {\n            return Buffer.from(`\n                hello world\n                hello hello world world\n                world hello\n            `);\n        });\n\n        expect(getMinDistance('dummy_file.txt', 'hello', 'world')).toEqual([0, 1]);\n    });\n});", "prompt": "please write a javascript class , the class signature as below /**\n * Find the minimum distance between two specified words (word1 and word2) from the file and return in which line the distance occurred.\n *\n * @param {string} filePath - The path to the file.\n * @param {string} word1 - The first word to search for.\n * @param {string} word2 - The second word to search for.\n * @returns {[number | null, number | null]} - An array containing the line number and the minimum distance, or [null, null] if not found.\n */\nfunction getMinDistance(filePath, word1, word2) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as fs from 'fs';\n\n/**\n * Finds the minimum distance between two specified words (word1 and word2) in a file and returns the line number where the distance occurred.\n *\n * @param {string} filePath - The path to the file.\n * @param {string} word1 - The first word to search for.\n * @param {string} word2 - The second word to search for.\n * @returns {[number | null, number | null]} A tuple containing the line number and the minimum distance, or [null, null] if no valid distance is found.\n */\nfunction getMinDistance(filePath: string, word1: string, word2: string): [number | null, number | null] {}", "test_code": "describe('TestGetMinDistance', () => {\n    beforeEach(() => {\n        jest.spyOn(fs, 'readFileSync').mockImplementation(() => '');\n    });\n\n    afterEach(() => {\n        jest.restoreAllMocks();\n    });\n\n    it('should handle a simple case', () => {\n        const mockFileContent = [\n            \"hello world\",\n            \"hello hello world\",\n            \"world hello\"\n        ].join('\\n');\n\n        jest.spyOn(fs, 'readFileSync').mockImplementation(() => mockFileContent);\n\n        expect(getMinDistance('dummy_file.txt', 'hello', 'world')).toEqual([0, 1]);\n    });\n\n    it('should handle multiple lines', () => {\n        const mockFileContent = [\n            \"hello planet\",\n            \"world hello planet\",\n            \"hello world planet\"\n        ].join('\\n');\n\n        jest.spyOn(fs, 'readFileSync').mockImplementation(() => mockFileContent);\n\n        expect(getMinDistance('dummy_file.txt', 'hello', 'world')).toEqual([1, 1]);\n    });\n\n    it('should handle large distances', () => {\n        const mockFileContent = [\n            \"hello a b c d e f g h i j k l m n o p q r s t u v w x y z world\"\n        ].join('\\n');\n\n        jest.spyOn(fs, 'readFileSync').mockImplementation(() => mockFileContent);\n\n        expect(getMinDistance('dummy_file.txt', 'hello', 'world')).toEqual([0, 27]);\n    });\n\n    it('should handle adjacent words', () => {\n        const mockFileContent = [\n            \"hello world\",\n            \"hello hello world world\",\n            \"world hello\"\n        ].join('\\n');\n\n        jest.spyOn(fs, 'readFileSync').mockImplementation(() => mockFileContent);\n\n        expect(getMinDistance('dummy_file.txt', 'hello', 'world')).toEqual([0, 1]);\n    });\n});", "prompt": "please write a typescript class , the class signature as below import * as fs from 'fs';\n\n/**\n * Finds the minimum distance between two specified words (word1 and word2) in a file and returns the line number where the distance occurred.\n *\n * @param {string} filePath - The path to the file.\n * @param {string} word1 - The first word to search for.\n * @param {string} word2 - The second word to search for.\n * @returns {[number | null, number | null]} A tuple containing the line number and the minimum distance, or [null, null] if no valid distance is found.\n */\nfunction getMinDistance(filePath: string, word1: string, word2: string): [number | null, number | null] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Find the minimum distance between two specified words (word1 and word2) from the file and return in which line the distance occurred.\n *\n * @param file_path The path to the file.\n * @param word1 The first word to search for.\n * @param word2 The second word to search for.\n * @return A pair of integers representing the line number and the minimum distance.\n */\nstd::pair<int, int> get_min_distance(const std::string& file_path, const std::string& word1, const std::string& word2);", "test_code": "TEST_CASE(\"Test Get Min Distance\") {\n    SECTION(\"Simple case\") {\n        std::vector<std::string> lines = {\n            \"hello world\",\n            \"hello hello world\",\n            \"world hello\"\n        };\n        REQUIRE(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\") == std::make_pair(0, 1));\n    }\n\n    SECTION(\"Multiple lines\") {\n        std::vector<std::string> lines = {\n            \"hello planet\",\n            \"world hello planet\",\n            \"hello world planet\"\n        };\n        REQUIRE(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\") == std::make_pair(1, 1));\n    }\n\n    SECTION(\"Large distance\") {\n        std::vector<std::string> lines = {\n            \"hello a b c d e f g h i j k l m n o p q r s t u v w x y z world\"\n        };\n        REQUIRE(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\") == std::make_pair(0, 27));\n    }\n\n    SECTION(\"Adjacent words\") {\n        std::vector<std::string> lines = {\n            \"hello world\",\n            \"hello hello world world\",\n            \"world hello\"\n        };\n        REQUIRE(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\") == std::make_pair(0, 1));\n    }\n}", "prompt": "please write a cpp class , the class signature as below /**\n * Find the minimum distance between two specified words (word1 and word2) from the file and return in which line the distance occurred.\n *\n * @param file_path The path to the file.\n * @param word1 The first word to search for.\n * @param word2 The second word to search for.\n * @return A pair of integers representing the line number and the minimum distance.\n */\nstd::pair<int, int> get_min_distance(const std::string& file_path, const std::string& word1, const std::string& word2);", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java class , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 423, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Writes a line to a text file, checks whether a line with the same content already exists before writing, and does not write if it does", "language_version_list": {"python": {"code_signature": "def write_unique_line_to_file(filename: str, line_content: str):\n    \"\"\"\n    Writes a line to a text file only if the line with the same content does not already exist.\n\n    Args:\n        filename (str): The name of the file to write to.\n        line_content (str): The content of the line to write.\n\n    Returns:\n        None\n    \"\"\"", "test_code": "import unittest\nimport os\n\n\nclass TestWriteUniqueLineToFile(unittest.TestCase):\n    def setUp(self):\n        # Setup: create a temporary file for testing.\n        self.filename = 'test_file.txt'\n        with open(self.filename, 'w') as file:\n            file.write('')\n\n    def test_write_new_line(self):\n        # Test case 1: Writing a new line to an empty file.\n        line_content = \"First unique line.\"\n        write_unique_line_to_file(self.filename, line_content)\n        with open(self.filename, 'r') as file:\n            self.assertIn(line_content, file.read())\n\n    def test_write_duplicate_line(self):\n        # Test case 2: Attempting to write a duplicate line.\n        line_content = \"First unique line.\"\n        # Write the line once.\n        write_unique_line_to_file(self.filename, line_content)\n        # Attempt to write it again.\n        write_unique_line_to_file(self.filename, line_content)\n        # Check if the line was written only once.\n        with open(self.filename, 'r') as file:\n            self.assertEqual(file.read().strip().count(line_content), 1)\n\n    def test_write_multiple_unique_lines(self):\n        # Test case 3: Writing multiple unique lines.\n        lines = [\"First unique line.\", \"Second unique line.\", \"Third unique line.\"]\n        for line in lines:\n            write_unique_line_to_file(self.filename, line)\n        with open(self.filename, 'r') as file:\n            file_content = file.read()\n            for line in lines:\n                self.assertIn(line, file_content)\n\n    def test_write_empty_line(self):\n        # Test case 5: Writing an empty line, should not write.\n        line_content = \"\"\n        write_unique_line_to_file(self.filename, line_content)\n        with open(self.filename, 'r') as file:\n            self.assertEqual(file.read(), \"\")\n", "prompt": "please write a python function , the function signature as below def write_unique_line_to_file(filename: str, line_content: str):\n    \"\"\"\n    Writes a line to a text file only if the line with the same content does not already exist.\n\n    Args:\n        filename (str): The name of the file to write to.\n        line_content (str): The content of the line to write.\n\n    Returns:\n        None\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "const fs = require('fs');\n\n/**\n * Writes a line to a text file only if the line with the same content does not already exist.\n * \n * @param {string} filename - The name of the file to write to.\n * @param {string} lineContent - The content of the line to write.\n */\nfunction writeUniqueLineToFile(filename, lineContent) {}", "test_code": "const fs = require('fs');\nconst path = require('path');\ndescribe('TestWriteUniqueLineToFile', () => {\n    const filename = 'test_file.txt';\n\n    beforeAll(() => {\n        // Setup: create a temporary file for testing.\n        fs.writeFile(filename, '', (err) => {\n            if (err) {\n                console.error(`Error creating file: ${err}`);\n            }\n        });\n    });\n\n    afterAll(() => {\n        // Cleanup: remove the temporary file after all tests.\n        fs.unlink(filename, (err) => {\n            if (err) {\n                console.error(`Error removing file: ${err}`);\n            }\n        });\n    });\n\n    test('Writing a new line to an empty file', () => {\n        const lineContent = \"First unique line.\";\n        writeUniqueLineToFile(filename, lineContent);\n\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                fs.readFile(filename, 'utf8', (err, data) => {\n                    if (err) {\n                        console.error(`Error reading file: ${err}`);\n                        resolve(false);\n                    } else {\n                        expect(data).toContain(lineContent);\n                        resolve(true);\n                    }\n                });\n            }, 100); // Allow time for the asynchronous write to complete\n        });\n    });\n\n    test('Attempting to write a duplicate line', () => {\n        const lineContent = \"First unique line.\";\n        writeUniqueLineToFile(filename, lineContent);\n        writeUniqueLineToFile(filename, lineContent);\n\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                fs.readFile(filename, 'utf8', (err, data) => {\n                    if (err) {\n                        console.error(`Error reading file: ${err}`);\n                        resolve(false);\n                    } else {\n                        expect(data.trim().split('\\n').filter(line => line === lineContent).length).toBe(1);\n                        resolve(true);\n                    }\n                });\n            }, 100); // Allow time for the asynchronous write to complete\n        });\n    });\n\n    test('Writing multiple unique lines', () => {\n        const lines = [\"First unique line.\", \"Second unique line.\", \"Third unique line.\"];\n\n        lines.forEach(line => {\n            writeUniqueLineToFile(filename, line);\n        });\n\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                fs.readFile(filename, 'utf8', (err, data) => {\n                    if (err) {\n                        console.error(`Error reading file: ${err}`);\n                        resolve(false);\n                    } else {\n                        lines.forEach(line => {\n                            expect(data).toContain(line);\n                        });\n                        resolve(true);\n                    }\n                });\n            }, 100); // Allow time for the asynchronous write to complete\n        });\n    });\n\n    test('Writing an empty line, should not write', () => {\n        const lineContent = \"\";\n        writeUniqueLineToFile(filename, lineContent);\n\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                fs.readFile(filename, 'utf8', (err, data) => {\n                    if (err) {\n                        console.error(`Error reading file: ${err}`);\n                        resolve(false);\n                    } else {\n                        expect(data.trim()).toBe(\"\");\n                        resolve(true);\n                    }\n                });\n            }, 100); // Allow time for the asynchronous write to complete\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below const fs = require('fs');\n\n/**\n * Writes a line to a text file only if the line with the same content does not already exist.\n * \n * @param {string} filename - The name of the file to write to.\n * @param {string} lineContent - The content of the line to write.\n */\nfunction writeUniqueLineToFile(filename, lineContent) {}", "addition_info": ""}, "typescript": {"code_signature": "import fs from 'fs';\n\n/**\n * Writes a line to a text file only if the line with the same content does not already exist.\n * \n * @param filename - The name of the file to write to.\n * @param lineContent - The content of the line to write.\n */\nfunction writeUniqueLineToFile(filename: string, lineContent: string): void {}", "test_code": "import fs from 'fs';\nimport path from 'path';\n\ndescribe('TestWriteUniqueLineToFile', () => {\n    let filename: string;\n\n    beforeAll(() => {\n        // Setup: create a temporary file for testing.\n        filename = 'test_file.txt';\n        fs.writeFileSync(filename, '');\n    });\n\n    afterAll(() => {\n        // Cleanup: remove the temporary file after all tests.\n        fs.unlinkSync(filename);\n    });\n\n    it('writes a new line to an empty file', () => {\n        const lineContent = \"First unique line.\";\n        writeUniqueLineToFile(filename, lineContent);\n\n        const fileContent = fs.readFileSync(filename, 'utf8');\n        expect(fileContent).toContain(lineContent);\n    });\n\n    it('does not write a duplicate line', () => {\n        const lineContent = \"First unique line.\";\n        writeUniqueLineToFile(filename, lineContent);\n        writeUniqueLineToFile(filename, lineContent);\n\n        const fileContent = fs.readFileSync(filename, 'utf8');\n        expect(fileContent.split('\\n').filter(line => line === lineContent).length).toBe(1);\n    });\n\n    it('writes multiple unique lines', () => {\n        const lines = [\"First unique line.\", \"Second unique line.\", \"Third unique line.\"];\n        lines.forEach(line => writeUniqueLineToFile(filename, line));\n\n        const fileContent = fs.readFileSync(filename, 'utf8');\n        lines.forEach(line => {\n            expect(fileContent).toContain(line);\n        });\n    });\n\n    it('does not write an empty line', () => {\n        const lineContent = \"\";\n        writeUniqueLineToFile(filename, lineContent);\n\n        const fileContent = fs.readFileSync(filename, 'utf8');\n        expect(fileContent.trim()).toBe(\"\");\n    });\n});", "prompt": "please write a typescript function , the function signature as below import fs from 'fs';\n\n/**\n * Writes a line to a text file only if the line with the same content does not already exist.\n * \n * @param filename - The name of the file to write to.\n * @param lineContent - The content of the line to write.\n */\nfunction writeUniqueLineToFile(filename: string, lineContent: string): void {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Writes a line to a text file only if the line with the same content does not already exist.\n *\n * @param filename The name of the file to write to.\n * @param lineContent The content of the line to write.\n */\nvoid write_unique_line_to_file(const std::string& filename, const std::string& lineContent) {}", "test_code": "TEST_CASE(\"Testwrite_unique_line_to_file\", \"[write_unique_line_to_file]\") {\n    const std::string filename = \"test_file.txt\";\n\n    SECTION(\"Setup: Create a temporary file for testing\") {\n        std::ofstream file(filename);\n        REQUIRE(file.is_open());\n        file.close();\n    }\n\n    SECTION(\"Test case 1: Writing a new line to an empty file\") {\n        const std::string lineContent = \"First unique line.\";\n        write_unique_line_to_file(filename, lineContent);\n\n        std::ifstream file(filename);\n        REQUIRE(file.is_open());\n\n        std::string fileContent((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        REQUIRE(fileContent.find(lineContent) != std::string::npos);\n    }\n\n    SECTION(\"Test case 2: Attempting to write a duplicate line\") {\n        const std::string lineContent = \"First unique line.\";\n        write_unique_line_to_file(filename, lineContent);\n        write_unique_line_to_file(filename, lineContent);\n\n        std::ifstream file(filename);\n        REQUIRE(file.is_open());\n\n        std::string fileContent((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        REQUIRE(std::count(fileContent.begin(), fileContent.end(), '\\n') == 1);\n        REQUIRE(fileContent.find(lineContent) != std::string::npos);\n    }\n\n    SECTION(\"Test case 3: Writing multiple unique lines\") {\n        const std::vector<std::string> lines = {\"First unique line.\", \"Second unique line.\", \"Third unique line.\"};\n        for (const auto& line : lines) {\n            write_unique_line_to_file(filename, line);\n        }\n\n        std::ifstream file(filename);\n        REQUIRE(file.is_open());\n\n        std::string fileContent((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        for (const auto& line : lines) {\n            REQUIRE(fileContent.find(line) != std::string::npos);\n        }\n    }\n\n    SECTION(\"Test case 4: Writing an empty line, should not write\") {\n        const std::string lineContent = \"\";\n        write_unique_line_to_file(filename, lineContent);\n\n        std::ifstream file(filename);\n        REQUIRE(file.is_open());\n\n        std::string fileContent((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        REQUIRE(fileContent.empty());\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Writes a line to a text file only if the line with the same content does not already exist.\n *\n * @param filename The name of the file to write to.\n * @param lineContent The content of the line to write.\n */\nvoid write_unique_line_to_file(const std::string& filename, const std::string& lineContent) {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 424, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.", "language_version_list": {"python": {"code_signature": "import heapq\nfrom typing import Dict\n\n\ndef dijkstra(graph: Dict, start: str) -> Dict:\n    \"\"\"\n    Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.\n    Args:\n        graph(Dict): A dictionary representing the adjacency list of the graph. Each key is a node, and the value is a list of tuples (neighbor, weight).\n        start(str): The starting node for the shortest path search.\n\n    Returns:\n        Dict: A dictionary with the shortest distance from the start node to each node.\n    \"\"\"\n", "test_code": "import unittest\n\nclass TestDijkstraAlgorithm(unittest.TestCase):\n\n    def setUp(self):\n        # Sample graphs for testing\n        self.graph1 = {\n            'A': [('B', 1), ('C', 4)],\n            'B': [('A', 1), ('C', 2), ('D', 5)],\n            'C': [('A', 4), ('B', 2), ('D', 1)],\n            'D': [('B', 5), ('C', 1)],\n        }\n\n        self.graph2 = {\n            'A': [('B', 2)],\n            'B': [('A', 2), ('C', 3)],\n            'C': [('B', 3), ('D', 1)],\n            'D': [('C', 1)],\n        }\n\n        self.graph_with_isolated_node = {\n            'A': [('B', 1)],\n            'B': [('A', 1)],\n            'C': [],  # Isolated node\n        }\n\n        self.graph_with_negative_weight = {\n            'A': [('B', 2), ('C', 1)],\n            'B': [('D', 3)],\n            'C': [('B', -1), ('D', 4)],\n            'D': [],\n        }\n\n    def test_shortest_paths_graph1(self):\n        \"\"\"Test shortest paths in a normal graph.\"\"\"\n        expected = {'A': 0, 'B': 1, 'C': 3, 'D': 4}\n        result = dijkstra(self.graph1, 'A')\n        self.assertEqual(result, expected)\n\n    def test_shortest_paths_graph2(self):\n        \"\"\"Test shortest paths in a different normal graph.\"\"\"\n        expected = {'A': 0, 'B': 2, 'C': 5, 'D': 6}\n        result = dijkstra(self.graph2, 'A')\n        self.assertEqual(result, expected)\n\n    def test_shortest_paths_with_isolated_node(self):\n        \"\"\"Test shortest paths with an isolated node.\"\"\"\n        expected = {'A': 0, 'B': 1, 'C': float('inf')}\n        result = dijkstra(self.graph_with_isolated_node, 'A')\n        self.assertEqual(result, expected)\n\n\n    def test_starting_at_isolated_node(self):\n        \"\"\"Test when starting at an isolated node.\"\"\"\n        expected = {'C': 0, 'A': float('inf'), 'B': float('inf')}\n        result = dijkstra(self.graph_with_isolated_node, 'C')\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below import heapq\nfrom typing import Dict\n\n\ndef dijkstra(graph: Dict, start: str) -> Dict:\n    \"\"\"\n    Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.\n    Args:\n        graph(Dict): A dictionary representing the adjacency list of the graph. Each key is a node, and the value is a list of tuples (neighbor, weight).\n        start(str): The starting node for the shortest path search.\n\n    Returns:\n        Dict: A dictionary with the shortest distance from the start node to each node.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.\n * @param {Object} graph - An object representing the adjacency list of the graph. Each key is a node, and the value is an array of objects {neighbor, weight}.\n * @param {string} start - The starting node for the shortest path search.\n * @returns {Object} - An object with the shortest distance from the start node to each node.\n */\nfunction dijkstra(graph, start) {}", "test_code": "describe('Dijkstra Algorithm Tests', () => {\n    beforeEach(() => {\n        // Sample graphs for testing\n        this.graph1 = {\n            'A': [{ neighbor: 'B', weight: 1 }, { neighbor: 'C', weight: 4 }],\n            'B': [{ neighbor: 'A', weight: 1 }, { neighbor: 'C', weight: 2 }, { neighbor: 'D', weight: 5 }],\n            'C': [{ neighbor: 'A', weight: 4 }, { neighbor: 'B', weight: 2 }, { neighbor: 'D', weight: 1 }],\n            'D': [{ neighbor: 'B', weight: 5 }, { neighbor: 'C', weight: 1 }],\n        };\n\n        this.graph2 = {\n            'A': [{ neighbor: 'B', weight: 2 }],\n            'B': [{ neighbor: 'A', weight: 2 }, { neighbor: 'C', weight: 3 }],\n            'C': [{ neighbor: 'B', weight: 3 }, { neighbor: 'D', weight: 1 }],\n            'D': [{ neighbor: 'C', weight: 1 }],\n        };\n\n        this.graphWithIsolatedNode = {\n            'A': [{ neighbor: 'B', weight: 1 }],\n            'B': [{ neighbor: 'A', weight: 1 }],\n            'C': [],  // Isolated node\n        };\n\n        this.graphWithNegativeWeight = {\n            'A': [{ neighbor: 'B', weight: 2 }, { neighbor: 'C', weight: 1 }],\n            'B': [{ neighbor: 'D', weight: 3 }],\n            'C': [{ neighbor: 'B', weight: -1 }, { neighbor: 'D', weight: 4 }],\n            'D': [],\n        };\n    });\n\n    it('should compute shortest paths in a normal graph', () => {\n        const expected = { 'A': 0, 'B': 1, 'C': 3, 'D': 4 };\n        const result = dijkstra(this.graph1, 'A');\n        expect(result).toEqual(expected);\n    });\n\n    it('should compute shortest paths in a different normal graph', () => {\n        const expected = { 'A': 0, 'B': 2, 'C': 5, 'D': 6 };\n        const result = dijkstra(this.graph2, 'A');\n        expect(result).toEqual(expected);\n    });\n\n    it('should compute shortest paths with an isolated node', () => {\n        const expected = { 'A': 0, 'B': 1, 'C': Infinity };\n        const result = dijkstra(this.graphWithIsolatedNode, 'A');\n        expect(result).toEqual(expected);\n    });\n\n    it('should compute shortest paths when starting at an isolated node', () => {\n        const expected = { 'C': 0, 'A': Infinity, 'B': Infinity };\n        const result = dijkstra(this.graphWithIsolatedNode, 'C');\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.\n * @param {Object} graph - An object representing the adjacency list of the graph. Each key is a node, and the value is an array of objects {neighbor, weight}.\n * @param {string} start - The starting node for the shortest path search.\n * @returns {Object} - An object with the shortest distance from the start node to each node.\n */\nfunction dijkstra(graph, start) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.\n * \n * @param graph - A dictionary representing the adjacency list of the graph. Each key is a node, and the value is a list of tuples (neighbor, weight).\n * @param start - The starting node for the shortest path search.\n * @returns A dictionary with the shortest distance from the start node to each node.\n */\nfunction dijkstra(graph: Record<string, Array<[string, number]>>, start: string): Record<string, number> {}", "test_code": "describe('Dijkstra Algorithm Tests', () => {\n    let graph1: Record<string, Array<[string, number]>>;\n    let graph2: Record<string, Array<[string, number]>>;\n    let graphWithIsolatedNode: Record<string, Array<[string, number]>>;\n    let graphWithNegativeWeight: Record<string, Array<[string, number]>>;\n\n    beforeEach(() => {\n        // Sample graphs for testing\n        graph1 = {\n            'A': [['B', 1], ['C', 4]],\n            'B': [['A', 1], ['C', 2], ['D', 5]],\n            'C': [['A', 4], ['B', 2], ['D', 1]],\n            'D': [['B', 5], ['C', 1]],\n        };\n\n        graph2 = {\n            'A': [['B', 2]],\n            'B': [['A', 2], ['C', 3]],\n            'C': [['B', 3], ['D', 1]],\n            'D': [['C', 1]],\n        };\n\n        graphWithIsolatedNode = {\n            'A': [['B', 1]],\n            'B': [['A', 1]],\n            'C': [],  // Isolated node\n        };\n\n        graphWithNegativeWeight = {\n            'A': [['B', 2], ['C', 1]],\n            'B': [['D', 3]],\n            'C': [['B', -1], ['D', 4]],\n            'D': [],\n        };\n    });\n\n    it('should compute shortest paths in a normal graph', () => {\n        const expected = { 'A': 0, 'B': 1, 'C': 3, 'D': 4 };\n        const result = dijkstra(graph1, 'A');\n        expect(result).toEqual(expected);\n    });\n\n    it('should compute shortest paths in a different normal graph', () => {\n        const expected = { 'A': 0, 'B': 2, 'C': 5, 'D': 6 };\n        const result = dijkstra(graph2, 'A');\n        expect(result).toEqual(expected);\n    });\n\n    it('should handle an isolated node', () => {\n        const expected = { 'A': 0, 'B': 1, 'C': Infinity };\n        const result = dijkstra(graphWithIsolatedNode, 'A');\n        expect(result).toEqual(expected);\n    });\n\n    it('should handle starting at an isolated node', () => {\n        const expected = { 'C': 0, 'A': Infinity, 'B': Infinity };\n        const result = dijkstra(graphWithIsolatedNode, 'C');\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.\n * \n * @param graph - A dictionary representing the adjacency list of the graph. Each key is a node, and the value is a list of tuples (neighbor, weight).\n * @param start - The starting node for the shortest path search.\n * @returns A dictionary with the shortest distance from the start node to each node.\n */\nfunction dijkstra(graph: Record<string, Array<[string, number]>>, start: string): Record<string, number> {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.\n * \n * @param graph An unordered_map representing the adjacency list of the graph. Each key is a node, and the value is a vector of pairs (neighbor, weight).\n * @param start The starting node for the shortest path search.\n * \n * @return An unordered_map with the shortest distance from the start node to each node.\n */\nunordered_map<char, int> dijkstra(const unordered_map<char, vector<pair<char, int>>> &graph, char start) {}", "test_code": "TEST_CASE(\"Test Dijkstra Algorithm\") {\n    // Sample graphs for testing\n    unordered_map<char, vector<pair<char, int>>> graph1 = {\n        {'A', {{'B', 1}, {'C', 4}}},\n        {'B', {{'A', 1}, {'C', 2}, {'D', 5}}},\n        {'C', {{'A', 4}, {'B', 2}, {'D', 1}}},\n        {'D', {{'B', 5}, {'C', 1}}}\n    };\n\n    unordered_map<char, vector<pair<char, int>>> graph2 = {\n        {'A', {{'B', 2}}},\n        {'B', {{'A', 2}, {'C', 3}}},\n        {'C', {{'B', 3}, {'D', 1}}},\n        {'D', {{'C', 1}}}\n    };\n\n    unordered_map<char, vector<pair<char, int>>> graph_with_isolated_node = {\n        {'A', {{'B', 1}}},\n        {'B', {{'A', 1}}},\n        {'C', {}}  // Isolated node\n    };\n\n    unordered_map<char, vector<pair<char, int>>> graph_with_negative_weight = {\n        {'A', {{'B', 2}, {'C', 1}}},\n        {'B', {{'D', 3}}},\n        {'C', {{'B', -1}, {'D', 4}}},\n        {'D', {}}\n    };\n\n    SECTION(\"Test shortest paths in a normal graph\") {\n        unordered_map<char, int> expected = {{'A', 0}, {'B', 1}, {'C', 3}, {'D', 4}};\n        unordered_map<char, int> result = dijkstra(graph1, 'A');\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test shortest paths in a different normal graph\") {\n        unordered_map<char, int> expected = {{'A', 0}, {'B', 2}, {'C', 5}, {'D', 6}};\n        unordered_map<char, int> result = dijkstra(graph2, 'A');\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test shortest paths with an isolated node\") {\n        unordered_map<char, int> expected = {{'A', 0}, {'B', 1}, {'C', INT_MAX}};\n        unordered_map<char, int> result = dijkstra(graph_with_isolated_node, 'A');\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test when starting at an isolated node\") {\n        unordered_map<char, int> expected = {{'C', 0}, {'A', INT_MAX}, {'B', INT_MAX}};\n        unordered_map<char, int> result = dijkstra(graph_with_isolated_node, 'C');\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.\n * \n * @param graph An unordered_map representing the adjacency list of the graph. Each key is a node, and the value is a vector of pairs (neighbor, weight).\n * @param start The starting node for the shortest path search.\n * \n * @return An unordered_map with the shortest distance from the start node to each node.\n */\nunordered_map<char, int> dijkstra(const unordered_map<char, vector<pair<char, int>>> &graph, char start) {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 427, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Read multiple sequences from the file and determine if each sequence is a \"Munodi sequence\". The definition of the Munodi sequence is based on a specific recursive relationship, that is, for even numbers, the next term is half of it, for odd numbers, the next term is 3*n + 1, and the sequence terminates when it encounters 1", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef check_sequences(filename:str) -> Dict:\n    \"\"\"\n    Read multiple sequences from the file and determine if each sequence is a \"Munodi sequence\". The definition of the Munodi sequence is based on a specific recursive relationship, that is, for even numbers, the next term is half of it, for odd numbers, the next term is 3*n + 1, and the sequence terminates when it encounters 1.\n    For example: (2, 4, 6, 8) is Mundi sequence\n\n    Args:\n        filename(str): file path\n\n    Returns:\n        Dict: sequences weather is Munodi sequence\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCheckSequences(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up the test cases with sequences.\"\"\"\n        # Create a temporary file with test cases\n        self.test_file = 'test_sequences.dat'\n        with open(self.test_file, 'w') as f:\n            f.write(\"2,4,6,8\\n\")    # Munodi sequence (d = 2)\n            f.write(\"1,3,5,7\\n\")    # Munodi sequence (d = 2)\n            f.write(\"10,20,30\\n\")   # Munodi sequence (d = 10)\n            f.write(\"1,2,4,8\\n\")    # Not a Munodi sequence (d changes)\n            f.write(\"5,10,15,20\\n\") # Munodi sequence (d = 5)\n\n    def test_sequences(self):\n        \"\"\"Test the sequences for Munodi property.\"\"\"\n        expected_results = {\n            (2, 4, 6, 8): True,\n            (1, 3, 5, 7): True,\n            (10, 20, 30): True,\n            (1, 2, 4, 8): False,\n            (5, 10, 15, 20): True,\n        }\n        results = check_sequences(self.test_file)\n        for seq in expected_results:\n            self.assertEqual(results[seq], expected_results[seq])\n\n    def tearDown(self):\n        \"\"\"Clean up the test file after tests.\"\"\"\n        import os\n        os.remove(self.test_file)", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef check_sequences(filename:str) -> Dict:\n    \"\"\"\n    Read multiple sequences from the file and determine if each sequence is a \"Munodi sequence\". The definition of the Munodi sequence is based on a specific recursive relationship, that is, for even numbers, the next term is half of it, for odd numbers, the next term is 3*n + 1, and the sequence terminates when it encounters 1.\n    For example: (2, 4, 6, 8) is Mundi sequence\n\n    Args:\n        filename(str): file path\n\n    Returns:\n        Dict: sequences weather is Munodi sequence\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "const fs = require('fs');\n\n/**\n * Reads sequences from a file and determines if each sequence is a \"Munodi sequence\".\n * The definition of the Munodi sequence is based on a specific recursive relationship,\n * that is, for even numbers, the next term is half of it, for odd numbers, the next term is 3*n + 1,\n * and the sequence terminates when it encounters 1.\n * For example: (2, 4, 6, 8) is a Munodi sequence.\n *\n * @param {string} filename - The file path containing the sequences.\n * @returns {Object} An object mapping each sequence to a boolean indicating whether it is a Munodi sequence.\n */\nfunction checkSequences(filename) {}", "test_code": "const fs = require('fs');\nconst os = require('os');\nconst path = require('path');\n\ndescribe('TestCheckSequences', () => {\n    let testFile;\n\n    beforeAll(() => {\n        // Set up the test cases with sequences\n        testFile = 'test_sequences.dat';\n        fs.writeFileSync(testFile, [\n            \"2,4,6,8\",    // Munodi sequence (d = 2)\n            \"1,3,5,7\",    // Munodi sequence (d = 2)\n            \"10,20,30\",   // Munodi sequence (d = 10)\n            \"1,2,4,8\",    // Not a Munodi sequence (d changes)\n            \"5,10,15,20\"  // Munodi sequence (d = 5)\n        ].join('\\n'));\n    });\n\n    afterAll(() => {\n        // Clean up the test file after tests\n        fs.unlinkSync(testFile);\n    });\n\n    it('should correctly identify Munodi sequences', () => {\n        const expectedResults = {\n            \"[2,4,6,8]\": true,\n            \"[1,3,5,7]\": true,\n            \"[10,20,30]\": true,\n            \"[1,2,4,8]\": false,\n            \"[5,10,15,20]\": true,\n        };\n\n        const results = checkSequences(testFile);\n\n        Object.keys(expectedResults).forEach(seqStr => {\n            const seq = JSON.parse(seqStr);\n            expect(results[seqStr]).toEqual(expectedResults[seqStr]);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below const fs = require('fs');\n\n/**\n * Reads sequences from a file and determines if each sequence is a \"Munodi sequence\".\n * The definition of the Munodi sequence is based on a specific recursive relationship,\n * that is, for even numbers, the next term is half of it, for odd numbers, the next term is 3*n + 1,\n * and the sequence terminates when it encounters 1.\n * For example: (2, 4, 6, 8) is a Munodi sequence.\n *\n * @param {string} filename - The file path containing the sequences.\n * @returns {Object} An object mapping each sequence to a boolean indicating whether it is a Munodi sequence.\n */\nfunction checkSequences(filename) {}", "addition_info": ""}, "typescript": {"code_signature": "import fs from 'fs';\n\n/**\n * Reads multiple sequences from the file and determines if each sequence is a \"Munodi sequence\".\n * The definition of the Munodi sequence is based on a specific recursive relationship:\n * for even numbers, the next term is half of it, for odd numbers, the next term is 3*n + 1,\n * and the sequence terminates when it encounters 1.\n * For example: (2, 4, 6, 8) is a Munodi sequence.\n *\n * @param filename - The file path containing the sequences.\n * @returns An object mapping each sequence (as a string) to a boolean indicating whether it is a Munodi sequence.\n */\nfunction checkSequences(filename: string): { [key: string]: boolean } {}", "test_code": "import fs from 'fs';\nimport os from 'os';\nimport path from 'path';\n\ndescribe('TestCheckSequences', () => {\n    let testFile: string;\n\n    beforeAll(() => {\n        // Set up the test cases with sequences\n        testFile = 'test_sequences.dat';\n        fs.writeFileSync(testFile, \"2,4,6,8\\n\");    // Munodi sequence (d = 2)\n        fs.writeFileSync(testFile, \"1,3,5,7\\n\");    // Munodi sequence (d = 2)\n        fs.writeFileSync(testFile, \"10,20,30\\n\");   // Munodi sequence (d = 10)\n        fs.writeFileSync(testFile, \"1,2,4,8\\n\");    // Not a Munodi sequence (d changes)\n        fs.writeFileSync(testFile, \"5,10,15,20\\n\"); // Munodi sequence (d = 5)\n    });\n\n    afterAll(() => {\n        // Clean up the test file after tests\n        fs.unlinkSync(testFile);\n    });\n\n    it('should correctly identify Munodi sequences', () => {\n        const expectedResults = {\n            \"2,4,6,8\": true,\n            \"1,3,5,7\": true,\n            \"10,20,30\": true,\n            \"1,2,4,8\": false,\n            \"5,10,15,20\": true,\n        };\n\n        const results = checkSequences(testFile);\n\n        Object.keys(expectedResults).forEach((seq) => {\n            const parsedSeq = seq.split(',').map((num) => parseInt(num, 10));\n            expect(results[parsedSeq.toString()]).toEqual(expectedResults[seq]);\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below import fs from 'fs';\n\n/**\n * Reads multiple sequences from the file and determines if each sequence is a \"Munodi sequence\".\n * The definition of the Munodi sequence is based on a specific recursive relationship:\n * for even numbers, the next term is half of it, for odd numbers, the next term is 3*n + 1,\n * and the sequence terminates when it encounters 1.\n * For example: (2, 4, 6, 8) is a Munodi sequence.\n *\n * @param filename - The file path containing the sequences.\n * @returns An object mapping each sequence (as a string) to a boolean indicating whether it is a Munodi sequence.\n */\nfunction checkSequences(filename: string): { [key: string]: boolean } {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads sequences from a file and determines if each sequence is a \"Munodi sequence\".\n * \n * The Munodi sequence is defined by the following recursive relationship:\n * - For even numbers, the next term is half of the current number.\n * - For odd numbers, the next term is 3*n + 1.\n * - The sequence terminates when it reaches 1.\n * \n * For example, the sequence (2, 4, 6, 8) is a Munodi sequence.\n * \n * @param filename The path to the file containing sequences.\n * \n * @return A map where the keys are the sequences (as vectors of integers) and the values are booleans indicating whether the sequence is a valid Munodi sequence.\n */\nstd::map<std::vector<int>, bool> check_sequences(const std::string& filename) {", "test_code": "TEST_CASE(\"TestCheckSequences\", \"[check_sequences]\") {\n    // Set up the test cases with sequences.\n    std::string test_file = \"test_sequences.dat\";\n\n    // Write test sequences to the file\n    std::ofstream f(test_file);\n    f << \"2,4,6,8\\n\";    // Munodi sequence (d = 2)\n    f << \"1,3,5,7\\n\";    // Munodi sequence (d = 2)\n    f << \"10,20,30\\n\";   // Munodi sequence (d = 10)\n    f << \"1,2,4,8\\n\";    // Not a Munodi sequence (d changes)\n    f << \"5,10,15,20\\n\"; // Munodi sequence (d = 5)\n    f.close();\n\n    // Expected results\n    std::map<std::vector<int>, bool> expected_results = {\n        {{2, 4, 6, 8}, true},\n        {{1, 3, 5, 7}, true},\n        {{10, 20, 30}, true},\n        {{1, 2, 4, 8}, false},\n        {{5, 10, 15, 20}, true}\n    };\n\n    // Check the sequences\n    auto results = check_sequences(test_file);\n    for (const auto& [seq, expected] : expected_results) {\n        REQUIRE(results.find(seq) != results.end());\n        CHECK(results.at(seq) == expected);\n    }\n\n    // Clean up the test file after tests\n    std::filesystem::remove(test_file);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads sequences from a file and determines if each sequence is a \"Munodi sequence\".\n * \n * The Munodi sequence is defined by the following recursive relationship:\n * - For even numbers, the next term is half of the current number.\n * - For odd numbers, the next term is 3*n + 1.\n * - The sequence terminates when it reaches 1.\n * \n * For example, the sequence (2, 4, 6, 8) is a Munodi sequence.\n * \n * @param filename The path to the file containing sequences.\n * \n * @return A map where the keys are the sequences (as vectors of integers) and the values are booleans indicating whether the sequence is a valid Munodi sequence.\n */\nstd::map<std::vector<int>, bool> check_sequences(const std::string& filename) {", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 428, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Parses a Python type hint string and returns the individual types as a list of strings.", "language_version_list": {"python": {"code_signature": "import ast\nfrom typing import List\n\n\ndef parse_type_hint(type_hint_string:str) -> List:\n    \"\"\"\n    Parses a Python type hint string and returns the individual types as a list of strings.\n\n    Args:\n        type_hint_string (str): The type hint string to parse.\n\n    Returns:\n        list: The individual types parsed from the type hint string.\n\n    Example:\n        type_hint = \"Union[typing.List[str], typing.Dict[str, int], Tuple[int, str], Optional[int]]\"\n        parsed_types = parse_type_hint(type_hint)\n        print(parsed_types)\n        # Output: ['Union', 'typing.List', 'str', 'typing.Dict', 'str', 'int', 'Tuple', 'int',\n                   'str', 'Optional', 'int']\n    \"\"\"\n", "test_code": "import unittest\n\n\n# Assuming the parse_type_hint function is defined above or imported here\n\nclass TestParseTypeHint(unittest.TestCase):\n\n    def test_basic_types(self):\n        type_hint = 'int'\n        expected = ['int']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n\n    def test_list_type(self):\n        type_hint = 'List[int]'\n        expected = ['List', 'int']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n\n    def test_union_type(self):\n        type_hint = 'Union[str, float]'\n        expected = ['Union', 'str', 'float']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n\n    def test_tuple_type(self):\n        type_hint = 'Tuple[str, int, float]'\n        expected = ['Tuple', 'str', 'int', 'float']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n\n    def test_complex_type(self):\n        type_hint = 'List[Union[int, float], Tuple[str, int]]'\n        expected = ['List', 'Union', 'int', 'float', 'Tuple', 'str', 'int']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n", "prompt": "please write a python function , the function signature as below import ast\nfrom typing import List\n\n\ndef parse_type_hint(type_hint_string:str) -> List:\n    \"\"\"\n    Parses a Python type hint string and returns the individual types as a list of strings.\n\n    Args:\n        type_hint_string (str): The type hint string to parse.\n\n    Returns:\n        list: The individual types parsed from the type hint string.\n\n    Example:\n        type_hint = \"Union[typing.List[str], typing.Dict[str, int], Tuple[int, str], Optional[int]]\"\n        parsed_types = parse_type_hint(type_hint)\n        print(parsed_types)\n        # Output: ['Union', 'typing.List', 'str', 'typing.Dict', 'str', 'int', 'Tuple', 'int',\n                   'str', 'Optional', 'int']\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 430, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "Check whether two rectangles intersect in the vertical direction", "language_version_list": {"python": {"code_signature": "def intersect_vertically(rect1, rect2):\n    \"\"\"\n    Check whether two rectangles intersect in the vertical direction\n\n    Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n    - (x1, y1) are the coordinates of the bottom-left corner.\n    - (x2, y2) are the coordinates of the top-right corner.\n\n    Args:\n        rect1 (tuple): The first rectangle defined by (x1, y1, x2, y2).\n        rect2 (tuple): The second rectangle defined by (x1, y1, x2, y2).\n\n    Returns:\n        bool: True if the rectangles intersect vertically, False otherwise.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestIntersectVertically(unittest.TestCase):\n\n    def test_case1(self):\n        \"\"\"Test with overlapping rectangles.\"\"\"\n        rect1 = (0, 0, 2, 2)\n        rect2 = (1, 1, 3, 3)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n\n    def test_case2(self):\n        \"\"\"Test with overlapping rectangles.\"\"\"\n        rect1 = (-1, -1, 1, 1)\n        rect2 = (0, 0, 2, 2)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n\n    def test_case3(self):\n        # Test case where rectangles partially overlap vertically\n        rect1 = (0, 1, 2, 4)\n        rect2 = (1, 0, 3, 2)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n\n    def test_case4(self):\n        # Test case where rectangles are identical\n        rect1 = (0, 0, 2, 2)\n        rect2 = (0, 0, 2, 2)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n\n    def test_case5(self):\n        # Test case where one rectangle is completely inside the other\n        rect1 = (0, 0, 4, 4)\n        rect2 = (1, 1, 2, 2)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n", "prompt": "please write a python function , the function signature as below def intersect_vertically(rect1, rect2):\n    \"\"\"\n    Check whether two rectangles intersect in the vertical direction\n\n    Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n    - (x1, y1) are the coordinates of the bottom-left corner.\n    - (x2, y2) are the coordinates of the top-right corner.\n\n    Args:\n        rect1 (tuple): The first rectangle defined by (x1, y1, x2, y2).\n        rect2 (tuple): The second rectangle defined by (x1, y1, x2, y2).\n\n    Returns:\n        bool: True if the rectangles intersect vertically, False otherwise.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Check whether two rectangles intersect in the vertical direction.\n *\n * Each rectangle is defined by an array [x1, y1, x2, y2], where:\n * - [x1, y1] are the coordinates of the bottom-left corner.\n * - [x2, y2] are the coordinates of the top-right corner.\n *\n * @param {Array} rect1 - The first rectangle defined by [x1, y1, x2, y2].\n * @param {Array} rect2 - The second rectangle defined by [x1, y1, x2, y2].\n * @returns {boolean} - True if the rectangles intersect vertically, False otherwise.\n */\nfunction intersectVertically(rect1, rect2) {}", "test_code": "describe('intersectVertically', () => {\n    it('should return true for overlapping rectangles', () => {\n        const rect1 = [0, 0, 2, 2];\n        const rect2 = [1, 1, 3, 3];\n        expect(intersectVertically(rect1, rect2)).toBe(true);\n    });\n\n    it('should return true for overlapping rectangles', () => {\n        const rect1 = [-1, -1, 1, 1];\n        const rect2 = [0, 0, 2, 2];\n        expect(intersectVertically(rect1, rect2)).toBe(true);\n    });\n\n    it('should return true for partially overlapping rectangles vertically', () => {\n        const rect1 = [0, 1, 2, 4];\n        const rect2 = [1, 0, 3, 2];\n        expect(intersectVertically(rect1, rect2)).toBe(true);\n    });\n\n    it('should return true for identical rectangles', () => {\n        const rect1 = [0, 0, 2, 2];\n        const rect2 = [0, 0, 2, 2];\n        expect(intersectVertically(rect1, rect2)).toBe(true);\n    });\n\n    it('should return true when one rectangle is completely inside the other', () => {\n        const rect1 = [0, 0, 4, 4];\n        const rect2 = [1, 1, 2, 2];\n        expect(intersectVertically(rect1, rect2)).toBe(true);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Check whether two rectangles intersect in the vertical direction.\n *\n * Each rectangle is defined by an array [x1, y1, x2, y2], where:\n * - [x1, y1] are the coordinates of the bottom-left corner.\n * - [x2, y2] are the coordinates of the top-right corner.\n *\n * @param {Array} rect1 - The first rectangle defined by [x1, y1, x2, y2].\n * @param {Array} rect2 - The second rectangle defined by [x1, y1, x2, y2].\n * @returns {boolean} - True if the rectangles intersect vertically, False otherwise.\n */\nfunction intersectVertically(rect1, rect2) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Check whether two rectangles intersect in the vertical direction.\n *\n * Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n * - (x1, y1) are the coordinates of the bottom-left corner.\n * - (x2, y2) are the coordinates of the top-right corner.\n *\n * @param rect1 - The first rectangle defined by (x1, y1, x2, y2).\n * @param rect2 - The second rectangle defined by (x1, y1, x2, y2).\n * @returns {boolean} True if the rectangles intersect vertically, False otherwise.\n */\nfunction intersectVertically(rect1: [number, number, number, number], rect2: [number, number, number, number]): boolean {}", "test_code": "describe('intersectVertically', () => {\n    it('should return true for overlapping rectangles', () => {\n      const rect1: [number, number, number, number] = [0, 0, 2, 2];\n      const rect2: [number, number, number, number] = [1, 1, 3, 3];\n      expect(intersectVertically(rect1, rect2)).toBe(true);\n    });\n  \n    it('should return true for overlapping rectangles with negative coordinates', () => {\n      const rect1: [number, number, number, number] = [-1, -1, 1, 1];\n      const rect2: [number, number, number, number] = [0, 0, 2, 2];\n      expect(intersectVertically(rect1, rect2)).toBe(true);\n    });\n  \n    it('should return true for partially overlapping rectangles vertically', () => {\n      const rect1: [number, number, number, number] = [0, 1, 2, 4];\n      const rect2: [number, number, number, number] = [1, 0, 3, 2];\n      expect(intersectVertically(rect1, rect2)).toBe(true);\n    });\n  \n    it('should return true for identical rectangles', () => {\n      const rect1: [number, number, number, number] = [0, 0, 2, 2];\n      const rect2: [number, number, number, number] = [0, 0, 2, 2];\n      expect(intersectVertically(rect1, rect2)).toBe(true);\n    });\n  \n    it('should return true when one rectangle is completely inside the other', () => {\n      const rect1: [number, number, number, number] = [0, 0, 4, 4];\n      const rect2: [number, number, number, number] = [1, 1, 2, 2];\n      expect(intersectVertically(rect1, rect2)).toBe(true);\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Check whether two rectangles intersect in the vertical direction.\n *\n * Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n * - (x1, y1) are the coordinates of the bottom-left corner.\n * - (x2, y2) are the coordinates of the top-right corner.\n *\n * @param rect1 - The first rectangle defined by (x1, y1, x2, y2).\n * @param rect2 - The second rectangle defined by (x1, y1, x2, y2).\n * @returns {boolean} True if the rectangles intersect vertically, False otherwise.\n */\nfunction intersectVertically(rect1: [number, number, number, number], rect2: [number, number, number, number]): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Checks whether two rectangles intersect in the vertical direction.\n * \n * Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n * - (x1, y1) are the coordinates of the bottom-left corner.\n * - (x2, y2) are the coordinates of the top-right corner.\n * \n * @param rect1 A tuple representing the first rectangle defined by (x1, y1, x2, y2).\n * @param rect2 A tuple representing the second rectangle defined by (x1, y1, x2, y2).\n * \n * @return True if the rectangles intersect vertically, False otherwise.\n */\nbool intersect_vertically(const std::tuple<int, int, int, int>& rect1, const std::tuple<int, int, int, int>& rect2) {\n", "test_code": "TEST_CASE(\"Test Intersect Vertically\", \"[intersect_vertically]\") {\n    SECTION(\"Test with overlapping rectangles\") {\n        auto rect1 = std::make_tuple(0, 0, 2, 2);\n        auto rect2 = std::make_tuple(1, 1, 3, 3);\n        REQUIRE(intersect_vertically(rect1, rect2));\n    }\n\n    SECTION(\"Test with overlapping rectangles\") {\n        auto rect1 = std::make_tuple(-1, -1, 1, 1);\n        auto rect2 = std::make_tuple(0, 0, 2, 2);\n        REQUIRE(intersect_vertically(rect1, rect2));\n    }\n\n    SECTION(\"Test case where rectangles partially overlap vertically\") {\n        auto rect1 = std::make_tuple(0, 1, 2, 4);\n        auto rect2 = std::make_tuple(1, 0, 3, 2);\n        REQUIRE(intersect_vertically(rect1, rect2));\n    }\n\n    SECTION(\"Test case where rectangles are identical\") {\n        auto rect1 = std::make_tuple(0, 0, 2, 2);\n        auto rect2 = std::make_tuple(0, 0, 2, 2);\n        REQUIRE(intersect_vertically(rect1, rect2));\n    }\n\n    SECTION(\"Test case where one rectangle is completely inside the other\") {\n        auto rect1 = std::make_tuple(0, 0, 4, 4);\n        auto rect2 = std::make_tuple(1, 1, 2, 2);\n        REQUIRE(intersect_vertically(rect1, rect2));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Checks whether two rectangles intersect in the vertical direction.\n * \n * Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n * - (x1, y1) are the coordinates of the bottom-left corner.\n * - (x2, y2) are the coordinates of the top-right corner.\n * \n * @param rect1 A tuple representing the first rectangle defined by (x1, y1, x2, y2).\n * @param rect2 A tuple representing the second rectangle defined by (x1, y1, x2, y2).\n * \n * @return True if the rectangles intersect vertically, False otherwise.\n */\nbool intersect_vertically(const std::tuple<int, int, int, int>& rect1, const std::tuple<int, int, int, int>& rect2) {\n", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 431, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "Check whether two rectangles intersect in the horizontal direction", "language_version_list": {"python": {"code_signature": "def intersect_horizontally(rect1, rect2):\n    \"\"\"\n    Determine if two rectangles intersect horizontally.\n\n    Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n    - (x1, y1) are the coordinates of the bottom-left corner.\n    - (x2, y2) are the coordinates of the top-right corner.\n\n    Args:\n        rect1 (tuple): The first rectangle defined by (x1, y1, x2, y2).\n        rect2 (tuple): The second rectangle defined by (x1, y1, x2, y2).\n\n    Returns:\n        bool: True if the rectangles intersect horizontally, False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestIntersectHorizontally(unittest.TestCase):\n\n    def test_case1(self):\n        \"\"\"Test with overlapping rectangles.\"\"\"\n        rect1 = (0, 0, 2, 2)\n        rect2 = (1, 1, 3, 3)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n\n    def test_case2(self):\n        \"\"\"Test with rectangles touching at a point (not overlapping).\"\"\"\n        rect1 = (0, 0, 1, 1)\n        rect2 = (1, 1, 2, 2)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n\n    def test_case3(self):\n        \"\"\"Test with adjacent rectangles (no overlap).\"\"\"\n        rect1 = (0, 0, 2, 2)\n        rect2 = (2, 0, 3, 3)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n\n    def test_case4(self):\n        \"\"\"Test with one rectangle fully inside another.\"\"\"\n        rect1 = (1, 1, 4, 4)\n        rect2 = (2, 2, 3, 3)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n\n    def test_case5(self):\n        \"\"\"Test with overlapping rectangles.\"\"\"\n        rect1 = (-1, -1, 1, 1)\n        rect2 = (0, 0, 2, 2)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n", "prompt": "please write a python function , the function signature as below def intersect_horizontally(rect1, rect2):\n    \"\"\"\n    Determine if two rectangles intersect horizontally.\n\n    Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n    - (x1, y1) are the coordinates of the bottom-left corner.\n    - (x2, y2) are the coordinates of the top-right corner.\n\n    Args:\n        rect1 (tuple): The first rectangle defined by (x1, y1, x2, y2).\n        rect2 (tuple): The second rectangle defined by (x1, y1, x2, y2).\n\n    Returns:\n        bool: True if the rectangles intersect horizontally, False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Determine if two rectangles intersect horizontally.\n *\n * Each rectangle is defined by an array [x1, y1, x2, y2], where:\n * - [x1, y1] are the coordinates of the bottom-left corner.\n * - [x2, y2] are the coordinates of the top-right corner.\n *\n * @param {Array} rect1 - The first rectangle defined by [x1, y1, x2, y2].\n * @param {Array} rect2 - The second rectangle defined by [x1, y1, x2, y2].\n * @returns {boolean} - True if the rectangles intersect horizontally, False otherwise.\n */\nfunction intersectHorizontally(rect1, rect2) {}", "test_code": "describe('intersectHorizontally', () => {\n    it('test with overlapping rectangles', () => {\n        const rect1 = [0, 0, 2, 2];\n        const rect2 = [1, 1, 3, 3];\n        expect(intersectHorizontally(rect1, rect2)).toBe(true);\n    });\n\n    it('test with rectangles touching at a point (not overlapping)', () => {\n        const rect1 = [0, 0, 1, 1];\n        const rect2 = [1, 1, 2, 2];\n        expect(intersectHorizontally(rect1, rect2)).toBe(true);\n    });\n\n    it('test with adjacent rectangles (no overlap)', () => {\n        const rect1 = [0, 0, 2, 2];\n        const rect2 = [2, 0, 3, 3];\n        expect(intersectHorizontally(rect1, rect2)).toBe(true);\n    });\n\n    it('test with one rectangle fully inside another', () => {\n        const rect1 = [1, 1, 4, 4];\n        const rect2 = [2, 2, 3, 3];\n        expect(intersectHorizontally(rect1, rect2)).toBe(true);\n    });\n\n    it('test with overlapping rectangles', () => {\n        const rect1 = [-1, -1, 1, 1];\n        const rect2 = [0, 0, 2, 2];\n        expect(intersectHorizontally(rect1, rect2)).toBe(true);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Determine if two rectangles intersect horizontally.\n *\n * Each rectangle is defined by an array [x1, y1, x2, y2], where:\n * - [x1, y1] are the coordinates of the bottom-left corner.\n * - [x2, y2] are the coordinates of the top-right corner.\n *\n * @param {Array} rect1 - The first rectangle defined by [x1, y1, x2, y2].\n * @param {Array} rect2 - The second rectangle defined by [x1, y1, x2, y2].\n * @returns {boolean} - True if the rectangles intersect horizontally, False otherwise.\n */\nfunction intersectHorizontally(rect1, rect2) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Determine if two rectangles intersect horizontally.\n *\n * Each rectangle is defined by a tuple [x1, y1, x2, y2], where:\n * - [x1, y1] are the coordinates of the bottom-left corner.\n * - [x2, y2] are the coordinates of the top-right corner.\n *\n * @param rect1 - The first rectangle defined by [x1, y1, x2, y2].\n * @param rect2 - The second rectangle defined by [x1, y1, x2, y2].\n * @returns {boolean} True if the rectangles intersect horizontally, False otherwise.\n */\nfunction intersectHorizontally(rect1: [number, number, number, number], rect2: [number, number, number, number]): boolean {}", "test_code": "describe('intersectHorizontally', () => {\n    it('test with overlapping rectangles', () => {\n        const rect1 = [0, 0, 2, 2];\n        const rect2 = [1, 1, 3, 3];\n        expect(intersectHorizontally(rect1, rect2)).toBe(true);\n    });\n\n    it('test with rectangles touching at a point (not overlapping)', () => {\n        const rect1 = [0, 0, 1, 1];\n        const rect2 = [1, 1, 2, 2];\n        expect(intersectHorizontally(rect1, rect2)).toBe(true);\n    });\n\n    it('test with adjacent rectangles (no overlap)', () => {\n        const rect1 = [0, 0, 2, 2];\n        const rect2 = [2, 0, 3, 3];\n        expect(intersectHorizontally(rect1, rect2)).toBe(true);\n    });\n\n    it('test with one rectangle fully inside another', () => {\n        const rect1 = [1, 1, 4, 4];\n        const rect2 = [2, 2, 3, 3];\n        expect(intersectHorizontally(rect1, rect2)).toBe(true);\n    });\n\n    it('test with overlapping rectangles', () => {\n        const rect1 = [-1, -1, 1, 1];\n        const rect2 = [0, 0, 2, 2];\n        expect(intersectHorizontally(rect1, rect2)).toBe(true);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Determine if two rectangles intersect horizontally.\n *\n * Each rectangle is defined by a tuple [x1, y1, x2, y2], where:\n * - [x1, y1] are the coordinates of the bottom-left corner.\n * - [x2, y2] are the coordinates of the top-right corner.\n *\n * @param rect1 - The first rectangle defined by [x1, y1, x2, y2].\n * @param rect2 - The second rectangle defined by [x1, y1, x2, y2].\n * @returns {boolean} True if the rectangles intersect horizontally, False otherwise.\n */\nfunction intersectHorizontally(rect1: [number, number, number, number], rect2: [number, number, number, number]): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Determine if two rectangles intersect horizontally.\n *\n * Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n * - (x1, y1) are the coordinates of the bottom-left corner.\n * - (x2, y2) are the coordinates of the top-right corner.\n *\n * @param rect1 The first rectangle defined by (x1, y1, x2, y2).\n * @param rect2 The second rectangle defined by (x1, y1, x2, y2).\n * @return True if the rectangles intersect horizontally, False otherwise.\n */\nbool intersect_horizontally(const std::tuple<int, int, int, int>& rect1, const std::tuple<int, int, int, int>& rect2) {", "test_code": "TEST_CASE(\"Test intersect_horizontally\", \"[intersect_horizontally]\") {\n    SECTION(\"Test with overlapping rectangles\") {\n        auto rect1 = std::make_tuple(0, 0, 2, 2);\n        auto rect2 = std::make_tuple(1, 1, 3, 3);\n        REQUIRE(intersect_horizontally(rect1, rect2));\n    }\n\n    SECTION(\"Test with rectangles touching at a point (not overlapping)\") {\n        auto rect1 = std::make_tuple(0, 0, 1, 1);\n        auto rect2 = std::make_tuple(1, 1, 2, 2);\n        REQUIRE(intersect_horizontally(rect1, rect2));\n    }\n\n    SECTION(\"Test with adjacent rectangles (no overlap)\") {\n        auto rect1 = std::make_tuple(0, 0, 2, 2);\n        auto rect2 = std::make_tuple(2, 0, 3, 3);\n        REQUIRE(intersect_horizontally(rect1, rect2));\n    }\n\n    SECTION(\"Test with one rectangle fully inside another\") {\n        auto rect1 = std::make_tuple(1, 1, 4, 4);\n        auto rect2 = std::make_tuple(2, 2, 3, 3);\n        REQUIRE(intersect_horizontally(rect1, rect2));\n    }\n\n    SECTION(\"Test with overlapping rectangles\") {\n        auto rect1 = std::make_tuple(-1, -1, 1, 1);\n        auto rect2 = std::make_tuple(0, 0, 2, 2);\n        REQUIRE(intersect_horizontally(rect1, rect2));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Determine if two rectangles intersect horizontally.\n *\n * Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n * - (x1, y1) are the coordinates of the bottom-left corner.\n * - (x2, y2) are the coordinates of the top-right corner.\n *\n * @param rect1 The first rectangle defined by (x1, y1, x2, y2).\n * @param rect2 The second rectangle defined by (x1, y1, x2, y2).\n * @return True if the rectangles intersect horizontally, False otherwise.\n */\nbool intersect_horizontally(const std::tuple<int, int, int, int>& rect1, const std::tuple<int, int, int, int>& rect2) {", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 433, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Extracts paragraph (separated by two newlines) lines (separated by one newline) in text\n", "language_version_list": {"python": {"code_signature": "def extract_paragraphs_and_lines(text: str):\n    \"\"\"\n    Extracts paragraphs and lines from the given text.The paragraphs end with \\n\\n The line end with \\n\n    For example:\n        input: First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\n        output:\n\n    Args:\n        text (str): The input text from which paragraphs and lines will be extracted.\n\n    Returns:\n        dict: A dictionary containing:\n            - 'paragraphs': A list of paragraphs extracted from the text.\n            - 'lines': A list of lines extracted from the text.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestExtractParagraphsAndLines(unittest.TestCase):\n\n    def test_single_paragraph(self):\n        input_text = \"This is a single paragraph.\"\n        expected_output = {\n            'paragraphs': [\"This is a single paragraph.\"],\n            'lines': [\"This is a single paragraph.\"]\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n\n    def test_multiple_paragraphs(self):\n        input_text = \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\"\n        expected_output = {\n            'paragraphs': [\n                \"First paragraph.\\nThis is the second line.\",\n                \"Second paragraph.\\nAnother line.\"\n            ],\n            'lines': [\n                \"First paragraph.\",\n                \"This is the second line.\",\n                \"Second paragraph.\",\n                \"Another line.\"\n            ]\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n\n    def test_leading_and_trailing_whitespace(self):\n        input_text = \"   This paragraph has leading whitespace.\\nAnd a line after.\\n\\n   This one has trailing whitespace.   \"\n        expected_output = {\n            'paragraphs': [\n                \"This paragraph has leading whitespace.\\nAnd a line after.\",\n                \"This one has trailing whitespace.\"\n            ],\n            'lines': [\n                \"This paragraph has leading whitespace.\",\n                \"And a line after.\",\n                \"This one has trailing whitespace.\"\n            ]\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n\n    def test_empty_string(self):\n        input_text = \"\"\n        expected_output = {\n            'paragraphs': [],\n            'lines': []\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n\n    def test_multiple_empty_paragraphs(self):\n        input_text = \"\\n\\n\\n\"\n        expected_output = {\n            'paragraphs': [],\n            'lines': []\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n", "prompt": "please write a python function , the function signature as below def extract_paragraphs_and_lines(text: str):\n    \"\"\"\n    Extracts paragraphs and lines from the given text.The paragraphs end with \\n\\n The line end with \\n\n    For example:\n        input: First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\n        output:\n\n    Args:\n        text (str): The input text from which paragraphs and lines will be extracted.\n\n    Returns:\n        dict: A dictionary containing:\n            - 'paragraphs': A list of paragraphs extracted from the text.\n            - 'lines': A list of lines extracted from the text.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extracts paragraphs and lines from the given text. The paragraphs end with \\n\\n and the lines end with \\n.\n * \n * Example:\n *   Input: \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\"\n *   Output: \n *   {\n *       'paragraphs': ['First paragraph.', 'Second paragraph.'],\n *       'lines': ['First paragraph.', 'This is the second line.', 'Second paragraph.', 'Another line.']\n *   }\n * \n * @param {string} text - The input text from which paragraphs and lines will be extracted.\n * @returns {object} An object containing:\n *   - 'paragraphs': An array of paragraphs extracted from the text.\n *   - 'lines': An array of lines extracted from the text.\n */\nfunction extractParagraphsAndLines(text) {}", "test_code": "describe('TestExtractParagraphsAndLines', () => {\n    it('should handle a single paragraph correctly', () => {\n        const inputText = \"This is a single paragraph.\";\n        const expectedOutput = {\n            paragraphs: [\"This is a single paragraph.\"],\n            lines: [\"This is a single paragraph.\"]\n        };\n        expect(extractParagraphsAndLines(inputText)).toEqual(expectedOutput);\n    });\n\n    it('should handle multiple paragraphs correctly', () => {\n        const inputText = \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\";\n        const expectedOutput = {\n            paragraphs: [\n                \"First paragraph.\\nThis is the second line.\",\n                \"Second paragraph.\\nAnother line.\"\n            ],\n            lines: [\n                \"First paragraph.\",\n                \"This is the second line.\",\n                \"Second paragraph.\",\n                \"Another line.\"\n            ]\n        };\n        expect(extractParagraphsAndLines(inputText)).toEqual(expectedOutput);\n    });\n\n    it('should handle leading and trailing whitespace correctly', () => {\n        const inputText = \"   This paragraph has leading whitespace.\\nAnd a line after.\\n\\n   This one has trailing whitespace.   \";\n        const expectedOutput = {\n            paragraphs: [\n                \"This paragraph has leading whitespace.\\nAnd a line after.\",\n                \"This one has trailing whitespace.\"\n            ],\n            lines: [\n                \"This paragraph has leading whitespace.\",\n                \"And a line after.\",\n                \"This one has trailing whitespace.\"\n            ]\n        };\n        expect(extractParagraphsAndLines(inputText)).toEqual(expectedOutput);\n    });\n\n    it('should handle an empty string correctly', () => {\n        const inputText = \"\";\n        const expectedOutput = {\n            paragraphs: [],\n            lines: []\n        };\n        expect(extractParagraphsAndLines(inputText)).toEqual(expectedOutput);\n    });\n\n    it('should handle multiple empty paragraphs correctly', () => {\n        const inputText = \"\\n\\n\\n\";\n        const expectedOutput = {\n            paragraphs: [],\n            lines: []\n        };\n        expect(extractParagraphsAndLines(inputText)).toEqual(expectedOutput);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Extracts paragraphs and lines from the given text. The paragraphs end with \\n\\n and the lines end with \\n.\n * \n * Example:\n *   Input: \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\"\n *   Output: \n *   {\n *       'paragraphs': ['First paragraph.', 'Second paragraph.'],\n *       'lines': ['First paragraph.', 'This is the second line.', 'Second paragraph.', 'Another line.']\n *   }\n * \n * @param {string} text - The input text from which paragraphs and lines will be extracted.\n * @returns {object} An object containing:\n *   - 'paragraphs': An array of paragraphs extracted from the text.\n *   - 'lines': An array of lines extracted from the text.\n */\nfunction extractParagraphsAndLines(text) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Extracts paragraphs and lines from the given text. Paragraphs end with \\n\\n and lines end with \\n.\n * \n * Example:\n *   Input: \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\"\n *   Output: \n *   {\n *     paragraphs: [\"First paragraph.\\nThis is the second line.\", \"Second paragraph.\\nAnother line.\"],\n *     lines: [\"First paragraph.\", \"This is the second line.\", \"Second paragraph.\", \"Another line.\"]\n *   }\n * \n * @param text The input text from which paragraphs and lines will be extracted.\n * @returns A dictionary containing:\n *   - 'paragraphs': A list of paragraphs extracted from the text.\n *   - 'lines': A list of lines extracted from the text.\n */\nfunction extractParagraphsAndLines(text: string): { paragraphs: string[], lines: string[] } {}", "test_code": "describe('TestExtractParagraphsAndLines', () => {\n    it('should handle a single paragraph correctly', () => {\n        const inputText = \"This is a single paragraph.\";\n        const expectedOutput = {\n            paragraphs: [\"This is a single paragraph.\"],\n            lines: [\"This is a single paragraph.\"]\n        };\n        expect(extractParagraphsAndLines(inputText)).toEqual(expectedOutput);\n    });\n\n    it('should handle multiple paragraphs correctly', () => {\n        const inputText = \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\";\n        const expectedOutput = {\n            paragraphs: [\n                \"First paragraph.\\nThis is the second line.\",\n                \"Second paragraph.\\nAnother line.\"\n            ],\n            lines: [\n                \"First paragraph.\",\n                \"This is the second line.\",\n                \"Second paragraph.\",\n                \"Another line.\"\n            ]\n        };\n        expect(extractParagraphsAndLines(inputText)).toEqual(expectedOutput);\n    });\n\n    it('should handle leading and trailing whitespace correctly', () => {\n        const inputText = \"   This paragraph has leading whitespace.\\nAnd a line after.\\n\\n   This one has trailing whitespace.   \";\n        const expectedOutput = {\n            paragraphs: [\n                \"This paragraph has leading whitespace.\\nAnd a line after.\",\n                \"This one has trailing whitespace.\"\n            ],\n            lines: [\n                \"This paragraph has leading whitespace.\",\n                \"And a line after.\",\n                \"This one has trailing whitespace.\"\n            ]\n        };\n        expect(extractParagraphsAndLines(inputText)).toEqual(expectedOutput);\n    });\n\n    it('should handle an empty string correctly', () => {\n        const inputText = \"\";\n        const expectedOutput = {\n            paragraphs: [],\n            lines: []\n        };\n        expect(extractParagraphsAndLines(inputText)).toEqual(expectedOutput);\n    });\n\n    it('should handle multiple empty paragraphs correctly', () => {\n        const inputText = \"\\n\\n\\n\";\n        const expectedOutput = {\n            paragraphs: [],\n            lines: []\n        };\n        expect(extractParagraphsAndLines(inputText)).toEqual(expectedOutput);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Extracts paragraphs and lines from the given text. Paragraphs end with \\n\\n and lines end with \\n.\n * \n * Example:\n *   Input: \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\"\n *   Output: \n *   {\n *     paragraphs: [\"First paragraph.\\nThis is the second line.\", \"Second paragraph.\\nAnother line.\"],\n *     lines: [\"First paragraph.\", \"This is the second line.\", \"Second paragraph.\", \"Another line.\"]\n *   }\n * \n * @param text The input text from which paragraphs and lines will be extracted.\n * @returns A dictionary containing:\n *   - 'paragraphs': A list of paragraphs extracted from the text.\n *   - 'lines': A list of lines extracted from the text.\n */\nfunction extractParagraphsAndLines(text: string): { paragraphs: string[], lines: string[] } {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extracts paragraphs and lines from the given text.\n * \n * Paragraphs are defined as segments of text that end with \"\\n\\n\", \n * and lines end with a single \"\\n\".\n * \n * @note Example:\n *     Input: \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\"\n *     Output: (See function behavior for exact output structure)\n * \n * @param text The input text from which paragraphs and lines will be extracted.\n * \n * @return A map containing:\n *         - 'paragraphs': A vector of strings representing paragraphs extracted from the text.\n *         - 'lines': A vector of strings representing lines extracted from the text.\n */\nstd::map<std::string, std::vector<std::string>> extract_paragraphs_and_lines(const std::string& text);\n", "test_code": "TEST_CASE(\"Test extract_paragraphs_and_lines\") {\n    SECTION(\"Single paragraph\") {\n        std::string input_text = \"This is a single paragraph.\";\n        std::map<std::string, std::vector<std::string>> expected_output = {\n            {\"paragraphs\", {\"This is a single paragraph.\"}},\n            {\"lines\", {\"This is a single paragraph.\"}}\n        };\n\n        auto result = extract_paragraphs_and_lines(input_text);\n        REQUIRE(result[\"paragraphs\"] == expected_output[\"paragraphs\"]);\n        REQUIRE(result[\"lines\"] == expected_output[\"lines\"]);\n    }\n\n    SECTION(\"Multiple paragraphs\") {\n        std::string input_text = \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\";\n        std::map<std::string, std::vector<std::string>> expected_output = {\n            {\"paragraphs\", {\"First paragraph.\\nThis is the second line.\", \"Second paragraph.\\nAnother line.\"}},\n            {\"lines\", {\"First paragraph.\", \"This is the second line.\", \"Second paragraph.\", \"Another line.\"}}\n        };\n\n        auto result = extract_paragraphs_and_lines(input_text);\n        REQUIRE(result[\"paragraphs\"] == expected_output[\"paragraphs\"]);\n        REQUIRE(result[\"lines\"] == expected_output[\"lines\"]);\n    }\n\n    SECTION(\"Leading and trailing whitespace\") {\n        std::string input_text = \"   This paragraph has leading whitespace.\\nAnd a line after.\\n\\n   This one has trailing whitespace.   \";\n        std::map<std::string, std::vector<std::string>> expected_output = {\n            {\"paragraphs\", {\"This paragraph has leading whitespace.\\nAnd a line after.\", \"This one has trailing whitespace.\"}},\n            {\"lines\", {\"This paragraph has leading whitespace.\", \"And a line after.\", \"This one has trailing whitespace.\"}}\n        };\n\n        auto result = extract_paragraphs_and_lines(input_text);\n        REQUIRE(result[\"paragraphs\"] == expected_output[\"paragraphs\"]);\n        REQUIRE(result[\"lines\"] == expected_output[\"lines\"]);\n    }\n\n    SECTION(\"Empty string\") {\n        std::string input_text = \"\";\n        std::map<std::string, std::vector<std::string>> expected_output = {\n            {\"paragraphs\", {}},\n            {\"lines\", {}}\n        };\n\n        auto result = extract_paragraphs_and_lines(input_text);\n        REQUIRE(result[\"paragraphs\"] == expected_output[\"paragraphs\"]);\n        REQUIRE(result[\"lines\"] == expected_output[\"lines\"]);\n    }\n\n    SECTION(\"Multiple empty paragraphs\") {\n        std::string input_text = \"\\n\\n\\n\";\n        std::map<std::string, std::vector<std::string>> expected_output = {\n            {\"paragraphs\", {}},\n            {\"lines\", {}}\n        };\n\n        auto result = extract_paragraphs_and_lines(input_text);\n        REQUIRE(result[\"paragraphs\"] == expected_output[\"paragraphs\"]);\n        REQUIRE(result[\"lines\"] == expected_output[\"lines\"]);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts paragraphs and lines from the given text.\n * \n * Paragraphs are defined as segments of text that end with \"\\n\\n\", \n * and lines end with a single \"\\n\".\n * \n * @note Example:\n *     Input: \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\"\n *     Output: (See function behavior for exact output structure)\n * \n * @param text The input text from which paragraphs and lines will be extracted.\n * \n * @return A map containing:\n *         - 'paragraphs': A vector of strings representing paragraphs extracted from the text.\n *         - 'lines': A vector of strings representing lines extracted from the text.\n */\nstd::map<std::string, std::vector<std::string>> extract_paragraphs_and_lines(const std::string& text);\n", "addition_info": ""}, "java": {"code_signature": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class TextProcessor {\n\n    /**\n     * Extracts paragraphs and lines from the given text. Paragraphs end with \\n\\n and lines end with \\n.\n     *\n     * Example usage:\n     * Input: \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\"\n     * Output: A Map where:\n     *         - Key 'paragraphs' maps to a List of paragraphs extracted from the text.\n     *         - Key 'lines' maps to a List of lines extracted from the text.\n     *\n     * @param text The input text from which paragraphs and lines will be extracted.\n     * @return A Map containing:\n     *         - 'paragraphs': A List of paragraphs extracted from the text.\n     *         - 'lines': A List of lines extracted from the text.\n     */\n    public static Map<String, List<String>> extractParagraphsAndLines(String text) {\n        // Method implementation goes here\n        return new HashMap<>();\n    }\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport static org.junit.Assert.assertEquals;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\n@RunWith(JUnit4.class)\npublic class Tester {\n\n    private static Map<String, List<String>> extract_paragraphs_and_lines(String text) {\n        String[] paragraphs = text.split(\"\\n\\n\");\n        String[] lines = text.split(\"\\n\");\n\n        List<String> paragraphsList = Arrays.asList(paragraphs);\n        List<String> linesList = Arrays.asList(lines);\n\n        return Map.of(\n            \"paragraphs\", paragraphsList,\n            \"lines\", linesList\n        );\n    }\n\n    @Test\n    public void testExtractParagraphsAndLines() {\n        // Test data\n        String text = \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\";\n\n        // Expected result\n        Map<String, List<String>> expectedResult = Map.of(\n            \"paragraphs\", Arrays.asList(\"First paragraph.\\nThis is the second line.\", \"Second paragraph.\\nAnother line.\"),\n            \"lines\", Arrays.asList(\"First paragraph.\", \"This is the second line.\", \"Second paragraph.\", \"Another line.\")\n        );\n\n        // Actual result\n        Map<String, List<String>> actualResult = extract_paragraphs_and_lines(text);\n\n        // Assertion\n        assertEquals(expectedResult, actualResult);\n    }\n}", "prompt": "please write a java function , the function signature as below import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class TextProcessor {\n\n    /**\n     * Extracts paragraphs and lines from the given text. Paragraphs end with \\n\\n and lines end with \\n.\n     *\n     * Example usage:\n     * Input: \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\"\n     * Output: A Map where:\n     *         - Key 'paragraphs' maps to a List of paragraphs extracted from the text.\n     *         - Key 'lines' maps to a List of lines extracted from the text.\n     *\n     * @param text The input text from which paragraphs and lines will be extracted.\n     * @return A Map containing:\n     *         - 'paragraphs': A List of paragraphs extracted from the text.\n     *         - 'lines': A List of lines extracted from the text.\n     */\n    public static Map<String, List<String>> extractParagraphsAndLines(String text) {\n        // Method implementation goes here\n        return new HashMap<>();\n    }\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 434, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Amazon is organizing a farewell party for its interns at a large party hall! There are q events in the form \"+x\" and \"-x\" that denote person x has entered or left the party, respectively.   Find the maximum number of people at any time at\nthe party.Return -1 if the series of events is not possible.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef get_max_people(people: List[int], status: List[str]) -> int:\n    \"\"\"\n    Amazon is organizing a farewell party for its interns at a large party hall! There are q events in the form \"+x\" and \"-x\" that denote person x has entered or left the party, respectively.   Find the maximum number of people at any time at the party.Return -1 if the series of events is not possible.\n\n    Args:\n        people(List[int]): people array\n        status(List[str]): people action array\n\n    Returns:\n        int: the maximum number of people at any time at the party or -1 is series of events is not possible\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestGetMaxPeople(unittest.TestCase):\n\n    def test_case_1(self):\n        people = [1, 2, 3]\n        status = ['+', '+', '-']\n        expected = -1\n        self.assertEqual(get_max_people(people, status), expected)\n\n    def test_case_2(self):\n        people = [1, 2, 1]\n        status = ['+', '-', '+']\n        expected = -1\n        self.assertEqual(get_max_people(people, status), expected)\n\n    def test_case_3(self):\n        people = [1, 2, 1]\n        status = ['+', '+', '+']\n        expected = -1\n        self.assertEqual(get_max_people(people, status), expected)\n\n    def test_case_4(self):\n        people = [1, 2, 1]\n        status = ['+', '+', '+']\n        expected = -1\n        self.assertEqual(get_max_people(people, status), expected)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef get_max_people(people: List[int], status: List[str]) -> int:\n    \"\"\"\n    Amazon is organizing a farewell party for its interns at a large party hall! There are q events in the form \"+x\" and \"-x\" that denote person x has entered or left the party, respectively.   Find the maximum number of people at any time at the party.Return -1 if the series of events is not possible.\n\n    Args:\n        people(List[int]): people array\n        status(List[str]): people action array\n\n    Returns:\n        int: the maximum number of people at any time at the party or -1 is series of events is not possible\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 438, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "conver csv file to dataframe", "language_version_list": {"python": {"code_signature": "import pandas as pd\n\n\ndef read_csv_to_dataframe(file_path: str) -> pd.DataFrame:\n    \"\"\"\n    Reads a CSV file and converts it to a pandas DataFrame.\n\n    Args:\n        file_path (str): The path to the CSV file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the data from the CSV file.\n    \"\"\"\n", "test_code": "import unittest\nimport pandas as pd\nimport os\n\n\nclass TestReadCsvToDataFrame(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up temporary CSV files for testing.\"\"\"\n        # Create a valid CSV file\n        self.valid_csv_path = 'valid.csv'\n        pd.DataFrame({'col1': [1, 2], 'col2': [3, 4]}).to_csv(self.valid_csv_path, index=False)\n\n        # Create an empty CSV file\n        self.empty_csv_path = 'empty.csv'\n        open(self.empty_csv_path, 'w').close()\n\n        # Create an invalid format CSV file\n        self.invalid_csv_path = 'invalid.csv'\n        with open(self.invalid_csv_path, 'w') as f:\n            f.write(\"col1, col2\\n1, 2\\n3, 4\\ninvalid_line\")\n\n    def tearDown(self):\n        \"\"\"Clean up temporary files after tests.\"\"\"\n        if os.path.exists(self.valid_csv_path):\n            os.remove(self.valid_csv_path)\n        if os.path.exists(self.empty_csv_path):\n            os.remove(self.empty_csv_path)\n        if os.path.exists(self.invalid_csv_path):\n            os.remove(self.invalid_csv_path)\n\n    def test_valid_csv(self):\n        \"\"\"Test reading a valid CSV file.\"\"\"\n        df = read_csv_to_dataframe(self.valid_csv_path)\n        self.assertIsInstance(df, pd.DataFrame)\n        self.assertEqual(df.shape, (2, 2))\n        self.assertListEqual(list(df.columns), ['col1', 'col2'])\n\n\n\n    def test_correct_data(self):\n        \"\"\"Test if the correct data is read from the CSV file.\"\"\"\n        df = read_csv_to_dataframe(self.valid_csv_path)\n        expected_data = {'col1': [1, 2], 'col2': [3, 4]}\n        pd.testing.assert_frame_equal(df, pd.DataFrame(expected_data))\n\n    def test_read_csv_with_missing_values(self):\n        \"\"\"Test reading a CSV file with missing values.\"\"\"\n        missing_values_csv_path = 'missing_values.csv'\n        pd.DataFrame({'col1': [1, None], 'col2': [None, 4]}).to_csv(missing_values_csv_path, index=False)\n        df = read_csv_to_dataframe(missing_values_csv_path)\n        self.assertTrue(df.isnull().values.any())\n        os.remove(missing_values_csv_path)\n\n    def test_large_csv_file(self):\n        \"\"\"Test reading a large CSV file.\"\"\"\n        large_csv_path = 'large.csv'\n        large_df = pd.DataFrame({'col1': range(1000), 'col2': range(1000, 2000)})\n        large_df.to_csv(large_csv_path, index=False)\n        df = read_csv_to_dataframe(large_csv_path)\n        self.assertEqual(df.shape, (1000, 2))\n        os.remove(large_csv_path)", "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef read_csv_to_dataframe(file_path: str) -> pd.DataFrame:\n    \"\"\"\n    Reads a CSV file and converts it to a pandas DataFrame.\n\n    Args:\n        file_path (str): The path to the CSV file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the data from the CSV file.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 442, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Convert strings in nested structures (e.g. dictionaries, arrays) to numbers (integers or floating point numbers) as much as possible\n", "language_version_list": {"python": {"code_signature": "from typing import List, Dict, Union\n\n\ndef convert_strings_to_numbers(data: Union[Dict, List]) -> Union[Dict, List]:\n    \"\"\"\n    Convert strings in nested structures (e.g. dictionaries, arrays) to numbers (integers or floating point numbers) as much as possible\n\n    Args:\n        data (Union[Dict,List]): before convert data\n\n    Returns:\n        Union[Dict,List]: after convert data\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestConvertStringsToNumbers(unittest.TestCase):\n\n    def test_flat_dict(self):\n        data = {'a': '1', 'b': '2.5', 'c': 'not a number'}\n        expected = {'a': 1, 'b': 2.5, 'c': 'not a number'}\n        self.assertEqual(convert_strings_to_numbers(data), expected)\n\n    def test_nested_dict(self):\n        data = {'x': {'y': '10', 'z': '3.14'}, 'w': '20.0'}\n        expected = {'x': {'y': 10, 'z': 3.14}, 'w': 20.0}\n        self.assertEqual(convert_strings_to_numbers(data), expected)\n\n    def test_list_of_strings(self):\n        data = ['1', '2.5', '3', 'invalid']\n        expected = [1, 2.5, 3, 'invalid']\n        self.assertEqual(convert_strings_to_numbers(data), expected)\n\n    def test_mixed_structure(self):\n        data = {'numbers': ['1', '2.0', 3], 'more_numbers': [{'num': '4'}, '5']}\n        expected = {'numbers': [1, 2.0, 3], 'more_numbers': [{'num': 4}, 5]}\n        self.assertEqual(convert_strings_to_numbers(data), expected)\n\n    def test_empty_structure(self):\n        data = {}\n        expected = {}\n        self.assertEqual(convert_strings_to_numbers(data), expected)", "prompt": "please write a python function , the function signature as below from typing import List, Dict, Union\n\n\ndef convert_strings_to_numbers(data: Union[Dict, List]) -> Union[Dict, List]:\n    \"\"\"\n    Convert strings in nested structures (e.g. dictionaries, arrays) to numbers (integers or floating point numbers) as much as possible\n\n    Args:\n        data (Union[Dict,List]): before convert data\n\n    Returns:\n        Union[Dict,List]: after convert data\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Convert strings in nested structures (e.g., dictionaries, arrays) to numbers (integers or floating-point numbers) as much as possible.\n *\n * @param {Object|Array} data - The input data before conversion.\n * @returns {Object|Array} - The converted data.\n */\nfunction convertStringsToNumbers(data) {}", "test_code": "describe('TestConvertStringsToNumbers', () => {\n    describe('test_flat_dict', () => {\n        it('should correctly convert flat dictionary', () => {\n            const data = {'a': '1', 'b': '2.5', 'c': 'not a number'};\n            const expected = {'a': 1, 'b': 2.5, 'c': 'not a number'};\n            expect(convertStringsToNumbers(data)).toEqual(expected);\n        });\n    });\n\n    describe('test_nested_dict', () => {\n        it('should correctly convert nested dictionary', () => {\n            const data = {'x': {'y': '10', 'z': '3.14'}, 'w': '20.0'};\n            const expected = {'x': {'y': 10, 'z': 3.14}, 'w': 20.0};\n            expect(convertStringsToNumbers(data)).toEqual(expected);\n        });\n    });\n\n    describe('test_list_of_strings', () => {\n        it('should correctly convert list of strings', () => {\n            const data = ['1', '2.5', '3', 'invalid'];\n            const expected = [1, 2.5, 3, 'invalid'];\n            expect(convertStringsToNumbers(data)).toEqual(expected);\n        });\n    });\n\n    describe('test_mixed_structure', () => {\n        it('should correctly convert mixed structure', () => {\n            const data = {'numbers': ['1', '2.0', 3], 'more_numbers': [{'num': '4'}, '5']};\n            const expected = {'numbers': [1, 2.0, 3], 'more_numbers': [{'num': 4}, 5]};\n            expect(convertStringsToNumbers(data)).toEqual(expected);\n        });\n    });\n\n    describe('test_empty_structure', () => {\n        it('should correctly handle empty structure', () => {\n            const data = {};\n            const expected = {};\n            expect(convertStringsToNumbers(data)).toEqual(expected);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Convert strings in nested structures (e.g., dictionaries, arrays) to numbers (integers or floating-point numbers) as much as possible.\n *\n * @param {Object|Array} data - The input data before conversion.\n * @returns {Object|Array} - The converted data.\n */\nfunction convertStringsToNumbers(data) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Convert strings in nested structures (e.g., dictionaries, arrays) to numbers (integers or floating-point numbers) as much as possible.\n *\n * @param data - The input data before conversion.\n * @returns The converted data.\n */\nfunction convertStringsToNumbers(data: any): any {}", "test_code": "describe('TestConvertStringsToNumbers', () => {\n    it('test_flat_dict', () => {\n        const data = { a: '1', b: '2.5', c: 'not a number' };\n        const expected = { a: 1, b: 2.5, c: 'not a number' };\n        expect(convertStringsToNumbers(data)).toEqual(expected);\n    });\n\n    it('test_nested_dict', () => {\n        const data = { x: { y: '10', z: '3.14' }, w: '20.0' };\n        const expected = { x: { y: 10, z: 3.14 }, w: 20.0 };\n        expect(convertStringsToNumbers(data)).toEqual(expected);\n    });\n\n    it('test_list_of_strings', () => {\n        const data = ['1', '2.5', '3', 'invalid'];\n        const expected = [1, 2.5, 3, 'invalid'];\n        expect(convertStringsToNumbers(data)).toEqual(expected);\n    });\n\n    it('test_mixed_structure', () => {\n        const data = { numbers: ['1', '2.0', 3], more_numbers: [{ num: '4' }, '5'] };\n        const expected = { numbers: [1, 2.0, 3], more_numbers: [{ num: 4 }, 5] };\n        expect(convertStringsToNumbers(data)).toEqual(expected);\n    });\n\n    it('test_empty_structure', () => {\n        const data = {};\n        const expected = {};\n        expect(convertStringsToNumbers(data)).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Convert strings in nested structures (e.g., dictionaries, arrays) to numbers (integers or floating-point numbers) as much as possible.\n *\n * @param data - The input data before conversion.\n * @returns The converted data.\n */\nfunction convertStringsToNumbers(data: any): any {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <variant>\n#include <sstream>\n\n// Helper function to check if a string contains a dot\nbool containsDot(const std::string& str) {\n    return str.find('.') != std::string::npos;\n}\n\n// Function to attempt conversion of a string to a number\ntemplate<typename T>\nT stringToNumber(const std::string& str) {\n    std::istringstream iss(str);\n    T number;\n    iss >> number;\n    if (iss.fail() || !iss.eof()) {\n        throw std::invalid_argument(\"Conversion failed\");\n    }\n    return number;\n}\n\n/**\n * Convert strings in nested structures (e.g., dictionaries, arrays) to numbers (integers or floating-point numbers) as much as possible.\n *\n * @param data A dictionary or list containing nested structures.\n * @return A dictionary or list with strings converted to numbers where possible.\n */\nstd::variant<std::map<std::string, std::variant<std::string, int, double>>, std::vector<std::variant<std::string, int, double>>> convertStringsToNumbers(\n    const std::variant<std::map<std::string, std::variant<std::string, int, double>>, std::vector<std::variant<std::string, int, double>>>& data\n) {\n    if (std::holds_alternative<std::map<std::string, std::variant<std::string, int, double>>>(data)) {\n        auto map = std::get<std::map<std::string, std::variant<std::string, int, double>>>(data);\n        std::map<std::string, std::variant<std::string, int, double>> newMap;\n        for (const auto& [key, value] : map) {\n            newMap[key] = convertStringsToNumbers(value);\n        }\n        return newMap;\n    } else if (std::holds_alternative<std::vector<std::variant<std::string, int, double>>>(data)) {\n        auto vec = std::get<std::vector<std::variant<std::string, int, double>>>(data);\n        std::vector<std::variant<std::string, int, double>> newVec;\n        for (const auto& item : vec) {\n            newVec.push_back(convertStringsToNumbers(item));\n        }\n        return newVec;\n    } else if (std::holds_alternative<std::string>(data)) {\n        std::string str = std::get<std::string>(data);\n        try {\n            if (containsDot(str)) {\n                return stringToNumber<double>(str);\n            } else {\n                return stringToNumber<int>(str);\n            }\n        } catch (const std::invalid_argument&) {\n            return str; // Return original string if conversion fails\n        }\n    } else {\n        return data; // Return data unchanged if it's not a string\n    }\n}\n", "test_code": "TEST_CASE(\"Test convert_strings_to_numbers\") {\n    SECTION(\"Convert dictionary\") {\n        std::map<std::string, std::variant<std::string, int, double>> input = {\n            {\"a\", \"123\"},\n            {\"b\", \"456.789\"},\n            {\"c\", \"not_a_number\"}\n        };\n        auto output = convertStringsToNumbers(input);\n        REQUIRE(std::holds_alternative<std::map<std::string, std::variant<std::string, int, double>>>(output));\n\n        auto convertedMap = std::get<std::map<std::string, std::variant<std::string, int, double>>>(output);\n        REQUIRE(convertedMap.size() == 3);\n\n        REQUIRE(std::holds_alternative<int>(convertedMap.at(\"a\")));\n        REQUIRE(std::get<int>(convertedMap.at(\"a\")) == 123);\n\n        REQUIRE(std::holds_alternative<double>(convertedMap.at(\"b\")));\n        REQUIRE(std::get<double>(convertedMap.at(\"b\")) == 456.789);\n\n        REQUIRE(std::holds_alternative<std::string>(convertedMap.at(\"c\")));\n        REQUIRE(std::get<std::string>(convertedMap.at(\"c\")) == \"not_a_number\");\n    }\n\n    SECTION(\"Convert list\") {\n        std::vector<std::variant<std::string, int, double>> input = {\n            \"123\",\n            \"456.789\",\n            \"not_a_number\"\n        };\n        auto output = convertStringsToNumbers(input);\n        REQUIRE(std::holds_alternative<std::vector<std::variant<std::string, int, double>>>(output));\n\n        auto convertedVec = std::get<std::vector<std::variant<std::string, int, double>>>(output);\n        REQUIRE(convertedVec.size() == 3);\n\n        REQUIRE(std::holds_alternative<int>(convertedVec[0]));\n        REQUIRE(std::get<int>(convertedVec[0]) == 123);\n\n        REQUIRE(std::holds_alternative<double>(convertedVec[1]));\n        REQUIRE(std::get<double>(convertedVec[1]) == 456.789);\n\n        REQUIRE(std::holds_alternative<std::string>(convertedVec[2]));\n        REQUIRE(std::get<std::string>(convertedVec[2]) == \"not_a_number\");\n    }\n}\n", "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <variant>\n#include <sstream>\n\n// Helper function to check if a string contains a dot\nbool containsDot(const std::string& str) {\n    return str.find('.') != std::string::npos;\n}\n\n// Function to attempt conversion of a string to a number\ntemplate<typename T>\nT stringToNumber(const std::string& str) {\n    std::istringstream iss(str);\n    T number;\n    iss >> number;\n    if (iss.fail() || !iss.eof()) {\n        throw std::invalid_argument(\"Conversion failed\");\n    }\n    return number;\n}\n\n/**\n * Convert strings in nested structures (e.g., dictionaries, arrays) to numbers (integers or floating-point numbers) as much as possible.\n *\n * @param data A dictionary or list containing nested structures.\n * @return A dictionary or list with strings converted to numbers where possible.\n */\nstd::variant<std::map<std::string, std::variant<std::string, int, double>>, std::vector<std::variant<std::string, int, double>>> convertStringsToNumbers(\n    const std::variant<std::map<std::string, std::variant<std::string, int, double>>, std::vector<std::variant<std::string, int, double>>>& data\n) {\n    if (std::holds_alternative<std::map<std::string, std::variant<std::string, int, double>>>(data)) {\n        auto map = std::get<std::map<std::string, std::variant<std::string, int, double>>>(data);\n        std::map<std::string, std::variant<std::string, int, double>> newMap;\n        for (const auto& [key, value] : map) {\n            newMap[key] = convertStringsToNumbers(value);\n        }\n        return newMap;\n    } else if (std::holds_alternative<std::vector<std::variant<std::string, int, double>>>(data)) {\n        auto vec = std::get<std::vector<std::variant<std::string, int, double>>>(data);\n        std::vector<std::variant<std::string, int, double>> newVec;\n        for (const auto& item : vec) {\n            newVec.push_back(convertStringsToNumbers(item));\n        }\n        return newVec;\n    } else if (std::holds_alternative<std::string>(data)) {\n        std::string str = std::get<std::string>(data);\n        try {\n            if (containsDot(str)) {\n                return stringToNumber<double>(str);\n            } else {\n                return stringToNumber<int>(str);\n            }\n        } catch (const std::invalid_argument&) {\n            return str; // Return original string if conversion fails\n        }\n    } else {\n        return data; // Return data unchanged if it's not a string\n    }\n}\n", "addition_info": ""}, "java": {"code_signature": "import java.util.List;\nimport java.util.Map;\n\npublic class Answer {\n\n    /**\n     * Convert strings in nested structures (e.g., dictionaries, arrays) to numbers (integers or floating-point numbers) as much as possible.\n     *\n     * @param data the input data, which can be a dictionary or a list\n     * @return the converted data, which can be a dictionary or a list\n     */\n    public static Object convertStringsToNumbers(Object data) {\n        if (data instanceof Map) {\n            @SuppressWarnings(\"unchecked\")\n            Map<Object, Object> map = (Map<Object, Object>) data;\n            Map<Object, Object> convertedMap = new HashMap<>();\n            for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                convertedMap.put(entry.getKey(), convertStringsToNumbers(entry.getValue()));\n            }\n            return convertedMap;\n        } else if (data instanceof List) {\n            @SuppressWarnings(\"unchecked\")\n            List<Object> list = (List<Object>) data;\n            List<Object> convertedList = new ArrayList<>();\n            for (Object item : list) {\n                convertedList.add(convertStringsToNumbers(item));\n            }\n            return convertedList;\n        } else if (data instanceof String) {\n            String str = (String) data;\n            try {\n                // Try converting to float first, then to int if possible\n                if (str.contains(\".\")) {\n                    return Float.parseFloat(str);\n                } else {\n                    return Integer.parseInt(str);\n                }\n            } catch (NumberFormatException e) {\n                return data; // Return original string if conversion fails\n            }\n        } else {\n            return data; // Return data unchanged if it's not a string\n        }\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        Map<String, Object> data = new HashMap<>();\n        data.put(\"a\", \"123\");\n        data.put(\"b\", List.of(\"456\", \"789.0\"));\n        data.put(\"c\", \"not_a_number\");\n\n        System.out.println(convertStringsToNumbers(data));\n    }\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Tester {\n\n    /**\n     * Test the conversion of strings in nested structures to numbers.\n     */\n    @Test\n    public void testConvertStringsToNumbers() {\n        // Test with a dictionary\n        Map<String, Object> dataDict = new HashMap<>();\n        dataDict.put(\"a\", \"123\");\n        dataDict.put(\"b\", Arrays.asList(\"456\", \"789.0\"));\n        dataDict.put(\"c\", \"not_a_number\");\n\n        Map<String, Object> expectedDict = new HashMap<>();\n        expectedDict.put(\"a\", 123);\n        expectedDict.put(\"b\", Arrays.asList(456, 789.0f));\n        expectedDict.put(\"c\", \"not_a_number\");\n\n        assertEquals(expectedDict, convertStringsToNumbers(dataDict));\n\n        // Test with a list\n        List<Object> dataList = Arrays.asList(\"123\", \"456.7\", \"not_a_number\");\n\n        List<Object> expectedList = Arrays.asList(123, 456.7f, \"not_a_number\");\n\n        assertEquals(expectedList, convertStringsToNumbers(dataList));\n\n        // Test with a string\n        String dataStr = \"123\";\n        assertEquals(123, convertStringsToNumbers(dataStr));\n\n        dataStr = \"456.7\";\n        assertEquals(456.7f, convertStringsToNumbers(dataStr));\n\n        dataStr = \"not_a_number\";\n        assertEquals(\"not_a_number\", convertStringsToNumbers(dataStr));\n    }\n\n    private Object convertStringsToNumbers(Object data) {\n        if (data instanceof Map) {\n            @SuppressWarnings(\"unchecked\")\n            Map<Object, Object> map = (Map<Object, Object>) data;\n            Map<Object, Object> convertedMap = new HashMap<>();\n            for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                convertedMap.put(entry.getKey(), convertStringsToNumbers(entry.getValue()));\n            }\n            return convertedMap;\n        } else if (data instanceof List) {\n            @SuppressWarnings(\"unchecked\")\n            List<Object> list = (List<Object>) data;\n            List<Object> convertedList = new ArrayList<>();\n            for (Object item : list) {\n                convertedList.add(convertStringsToNumbers(item));\n            }\n            return convertedList;\n        } else if (data instanceof String) {\n            String str = (String) data;\n            try {\n                // Try converting to float first, then to int if possible\n                if (str.contains(\".\")) {\n                    return Float.parseFloat(str);\n                } else {\n                    return Integer.parseInt(str);\n                }\n            } catch (NumberFormatException e) {\n                return data; // Return original string if conversion fails\n            }\n        } else {\n            return data; // Return data unchanged if it's not a string\n        }\n    }\n}\n", "prompt": "please write a java function , the function signature as below import java.util.List;\nimport java.util.Map;\n\npublic class Answer {\n\n    /**\n     * Convert strings in nested structures (e.g., dictionaries, arrays) to numbers (integers or floating-point numbers) as much as possible.\n     *\n     * @param data the input data, which can be a dictionary or a list\n     * @return the converted data, which can be a dictionary or a list\n     */\n    public static Object convertStringsToNumbers(Object data) {\n        if (data instanceof Map) {\n            @SuppressWarnings(\"unchecked\")\n            Map<Object, Object> map = (Map<Object, Object>) data;\n            Map<Object, Object> convertedMap = new HashMap<>();\n            for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                convertedMap.put(entry.getKey(), convertStringsToNumbers(entry.getValue()));\n            }\n            return convertedMap;\n        } else if (data instanceof List) {\n            @SuppressWarnings(\"unchecked\")\n            List<Object> list = (List<Object>) data;\n            List<Object> convertedList = new ArrayList<>();\n            for (Object item : list) {\n                convertedList.add(convertStringsToNumbers(item));\n            }\n            return convertedList;\n        } else if (data instanceof String) {\n            String str = (String) data;\n            try {\n                // Try converting to float first, then to int if possible\n                if (str.contains(\".\")) {\n                    return Float.parseFloat(str);\n                } else {\n                    return Integer.parseInt(str);\n                }\n            } catch (NumberFormatException e) {\n                return data; // Return original string if conversion fails\n            }\n        } else {\n            return data; // Return data unchanged if it's not a string\n        }\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        Map<String, Object> data = new HashMap<>();\n        data.put(\"a\", \"123\");\n        data.put(\"b\", List.of(\"456\", \"789.0\"));\n        data.put(\"c\", \"not_a_number\");\n\n        System.out.println(convertStringsToNumbers(data));\n    }\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 443, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Process a string by compressing multiple consecutive whitespace characters into a single space\n", "language_version_list": {"python": {"code_signature": "def compress_whitespace(input_string: str):\n    \"\"\"\n    Compress multiple consecutive whitespace characters in a string into a single space.\n\n    Args:\n        input_string(str): The string to be processed.\n\n    Returns:\n        str: The processed string with compressed whitespace.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestCompressWhitespace(unittest.TestCase):\n\n    def test_single_spaces(self):\n        \"\"\"Test with a string containing single spaces\"\"\"\n        self.assertEqual(compress_whitespace(\"This is a test string.\"), \"This is a test string.\")\n\n    def test_multiple_spaces(self):\n        \"\"\"Test with a string containing multiple spaces\"\"\"\n        self.assertEqual(compress_whitespace(\"This    is  a   test   string.\"), \"This is a test string.\")\n\n    def test_leading_trailing_spaces(self):\n        \"\"\"Test with leading and trailing spaces\"\"\"\n        self.assertEqual(compress_whitespace(\"   Leading and trailing spaces   \"), \"Leading and trailing spaces\")\n\n    def test_only_spaces(self):\n        \"\"\"Test with a string containing only spaces\"\"\"\n        self.assertEqual(compress_whitespace(\"       \"), \"\")\n\n    def test_empty_string(self):\n        \"\"\"Test with an empty string\"\"\"\n        self.assertEqual(compress_whitespace(\"\"), \"\")", "prompt": "please write a python function , the function signature as below def compress_whitespace(input_string: str):\n    \"\"\"\n    Compress multiple consecutive whitespace characters in a string into a single space.\n\n    Args:\n        input_string(str): The string to be processed.\n\n    Returns:\n        str: The processed string with compressed whitespace.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Compress multiple consecutive whitespace characters in a string into a single space.\n *\n * @param {string} inputString - The string to be processed.\n * @returns {string} - The processed string with compressed whitespace.\n */\nfunction compressWhitespace(inputString) {}", "test_code": "describe('compressWhitespace', () => {\n    it('should handle strings with single spaces', () => {\n        expect(compressWhitespace(\"This is a test string.\")).toBe(\"This is a test string.\");\n    });\n\n    it('should handle strings with multiple spaces', () => {\n        expect(compressWhitespace(\"This    is  a   test   string.\")).toBe(\"This is a test string.\");\n    });\n\n    it('should handle strings with leading and trailing spaces', () => {\n        expect(compressWhitespace(\"   Leading and trailing spaces   \")).toBe(\"Leading and trailing spaces\");\n    });\n\n    it('should handle strings with only spaces', () => {\n        expect(compressWhitespace(\"       \")).toBe(\"\");\n    });\n\n    it('should handle empty strings', () => {\n        expect(compressWhitespace(\"\")).toBe(\"\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Compress multiple consecutive whitespace characters in a string into a single space.\n *\n * @param {string} inputString - The string to be processed.\n * @returns {string} - The processed string with compressed whitespace.\n */\nfunction compressWhitespace(inputString) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Compresses multiple consecutive whitespace characters in a string into a single space.\n *\n * @param {string} inputString - The string to be processed.\n * @returns {string} The processed string with compressed whitespace.\n */\nfunction compressWhitespace(inputString: string): string {}", "test_code": "describe('compressWhitespace', () => {\n  it('should handle strings with single spaces', () => {\n      expect(compressWhitespace(\"This is a test string.\")).toBe(\"This is a test string.\");\n  });\n\n  it('should handle strings with multiple spaces', () => {\n      expect(compressWhitespace(\"This    is  a   test   string.\")).toBe(\"This is a test string.\");\n  });\n\n  it('should handle strings with leading and trailing spaces', () => {\n      expect(compressWhitespace(\"   Leading and trailing spaces   \")).toBe(\"Leading and trailing spaces\");\n  });\n\n  it('should handle strings with only spaces', () => {\n      expect(compressWhitespace(\"       \")).toBe(\"\");\n  });\n\n  it('should handle empty strings', () => {\n      expect(compressWhitespace(\"\")).toBe(\"\");\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Compresses multiple consecutive whitespace characters in a string into a single space.\n *\n * @param {string} inputString - The string to be processed.\n * @returns {string} The processed string with compressed whitespace.\n */\nfunction compressWhitespace(inputString: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <string>\n\n/**\n * @brief Compress multiple consecutive whitespace characters in a string into a single space.\n *\n * @param input_string The string to be processed.\n * @return The processed string with compressed whitespace.\n */\nstd::string compress_whitespace(const std::string& input_string) {}\n", "test_code": "TEST_CASE(\"Test compress_whitespace function\", \"[compress_whitespace]\") {\n    SECTION(\"Test with a string containing single spaces\") {\n        std::string input = \"This is a test string.\";\n        std::string expected = \"This is a test string.\";\n        REQUIRE(compress_whitespace(input) == expected);\n    }\n\n    SECTION(\"Test with a string containing multiple spaces\") {\n        std::string input = \"This    is  a   test   string.\";\n        std::string expected = \"This is a test string.\";\n        REQUIRE(compress_whitespace(input) == expected);\n    }\n\n    SECTION(\"Test with leading and trailing spaces\") {\n        std::string input = \"   Leading and trailing spaces   \";\n        std::string expected = \"Leading and trailing spaces\";\n        REQUIRE(compress_whitespace(input) == expected);\n    }\n\n    SECTION(\"Test with a string containing only spaces\") {\n        std::string input = \"       \";\n        std::string expected = \"\";\n        REQUIRE(compress_whitespace(input) == expected);\n    }\n\n    SECTION(\"Test with an empty string\") {\n        std::string input = \"\";\n        std::string expected = \"\";\n        REQUIRE(compress_whitespace(input) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <string>\n\n/**\n * @brief Compress multiple consecutive whitespace characters in a string into a single space.\n *\n * @param input_string The string to be processed.\n * @return The processed string with compressed whitespace.\n */\nstd::string compress_whitespace(const std::string& input_string) {}\n", "addition_info": ""}, "java": {"code_signature": "public class StringUtils {\n\n    /**\n     * Compresses multiple consecutive whitespace characters in a string into a single space.\n     *\n     * @param inputString The string to be processed.\n     * @return The processed string with compressed whitespace.\n     */\n    public static String compressWhitespace(String inputString) {\n        return inputString.replaceAll(\"\\\\s+\", \" \").trim();\n    }\n}\n", "test_code": "", "prompt": "please write a java function , the function signature as below public class StringUtils {\n\n    /**\n     * Compresses multiple consecutive whitespace characters in a string into a single space.\n     *\n     * @param inputString The string to be processed.\n     * @return The processed string with compressed whitespace.\n     */\n    public static String compressWhitespace(String inputString) {\n        return inputString.replaceAll(\"\\\\s+\", \" \").trim();\n    }\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 444, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Formats a string into a commented block with specified maximum line length.", "language_version_list": {"python": {"code_signature": "def format_comment(string, max_length=60):\n    \"\"\"\n    Formats a string into a commented block with specified maximum line length.\n\n    Args:\n        string (str): The input string to format.\n        max_length (int): Maximum length of each line in the output.\n\n    Returns:\n        str: A formatted string with each line prefixed by '# ' and not exceeding the specified max_length.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFormatComment(unittest.TestCase):\n\n    def test_short_string(self):\n        \"\"\"Test with a short string that fits within max_length\"\"\"\n        input_string = \"This is a test.\"\n        expected_output = \"# This is a test.\"\n        self.assertEqual(format_comment(input_string), expected_output)\n\n    def test_long_string(self):\n        \"\"\"Test with a longer string that exceeds max_length\"\"\"\n        input_string = \"This is a test of the format_comment function which should wrap long lines correctly.\"\n        expected_output = (\n            \"# This is a test of the format_comment function which should\\n\"\n            \"# wrap long lines correctly.\"\n        )\n        self.assertEqual(format_comment(input_string, max_length=60), expected_output)\n\n    def test_multiple_lines(self):\n        \"\"\"Test with multiple lines of input\"\"\"\n        input_string = \"First line.\\nSecond line that is quite long and needs to be wrapped.\"\n        expected_output = (\n            \"# First line.\\n\"\n            \"# Second line that is quite long and needs to be wrapped.\"\n        )\n        self.assertEqual(format_comment(input_string, max_length=60), expected_output)\n\n    def test_exact_max_length(self):\n        \"\"\"Test with a line that is exactly max_length characters long\"\"\"\n        input_string = \"A\" * 60  # 60 characters long\n        expected_output = \"# \" + \"A\" * 60\n        self.assertEqual(format_comment(input_string, max_length=60), expected_output)\n\n    def test_empty_string(self):\n        \"\"\"Test with an empty string\"\"\"\n        input_string = \"\"\n        expected_output = \"# \"\n        self.assertEqual(format_comment(input_string), expected_output)\n", "prompt": "please write a python function , the function signature as below def format_comment(string, max_length=60):\n    \"\"\"\n    Formats a string into a commented block with specified maximum line length.\n\n    Args:\n        string (str): The input string to format.\n        max_length (int): Maximum length of each line in the output.\n\n    Returns:\n        str: A formatted string with each line prefixed by '# ' and not exceeding the specified max_length.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Formats a string into a commented block with a specified maximum line length.\n *\n * @param {string} string - The input string to format.\n * @param {number} [max_length=60] - Maximum length of each line in the output.\n * @returns {string} A formatted string with each line prefixed by '# ' and not exceeding the specified max_length.\n */\nfunction formatComment(string, max_length = 60) {}", "test_code": "describe('TestFormatComment', () => {\n    it('test with a short string that fits within max_length', () => {\n        const inputString = \"This is a test.\";\n        const expectedOutput = \"# This is a test.\";\n        expect(formatComment(inputString)).toBe(expectedOutput);\n    });\n\n    it('test with a longer string that exceeds max_length', () => {\n        const inputString = \"This is a test of the format_comment function which should wrap long lines correctly.\";\n        const expectedOutput = \n            \"# This is a test of the format_comment function which should\\n\" +\n            \"# wrap long lines correctly.\";\n        expect(formatComment(inputString, 60)).toBe(expectedOutput);\n    });\n\n    it('test with multiple lines of input', () => {\n        const inputString = \"First line.\\nSecond line that is quite long and needs to be wrapped.\";\n        const expectedOutput = \n            \"# First line.\\n\" +\n            \"# Second line that is quite long and needs to be wrapped.\";\n        expect(formatComment(inputString, 60)).toBe(expectedOutput);\n    });\n\n    it('test with a line that is exactly max_length characters long', () => {\n        const inputString = \"A\".repeat(60); // 60 characters long\n        const expectedOutput = \"# \" + \"A\".repeat(60);\n        expect(formatComment(inputString, 60)).toBe(expectedOutput);\n    });\n\n    it('test with an empty string', () => {\n        const inputString = \"\";\n        const expectedOutput = \"# \";\n        expect(formatComment(inputString)).toBe(expectedOutput);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Formats a string into a commented block with a specified maximum line length.\n *\n * @param {string} string - The input string to format.\n * @param {number} [max_length=60] - Maximum length of each line in the output.\n * @returns {string} A formatted string with each line prefixed by '# ' and not exceeding the specified max_length.\n */\nfunction formatComment(string, max_length = 60) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Formats a string into a commented block with a specified maximum line length.\n * \n * @param string - The input string to format.\n * @param maxLength - The maximum length of each line in the output. Defaults to 60.\n * @returns A formatted string with each line prefixed by '# ' and not exceeding the specified maxLength.\n */\nfunction formatComment(string: string, maxLength: number = 60): string {}", "test_code": "describe('TestFormatComment', () => {\n    it('test with a short string that fits within max_length', () => {\n        const inputString = \"This is a test.\";\n        const expectedOutput = \"# This is a test.\";\n        expect(formatComment(inputString)).toBe(expectedOutput);\n    });\n\n    it('test with a longer string that exceeds max_length', () => {\n        const inputString = \"This is a test of the format_comment function which should wrap long lines correctly.\";\n        const expectedOutput = \n            \"# This is a test of the format_comment function which should\\n\" +\n            \"# wrap long lines correctly.\";\n        expect(formatComment(inputString, 60)).toBe(expectedOutput);\n    });\n\n    it('test with multiple lines of input', () => {\n        const inputString = \"First line.\\nSecond line that is quite long and needs to be wrapped.\";\n        const expectedOutput = \n            \"# First line.\\n\" +\n            \"# Second line that is quite long and needs to be wrapped.\";\n        expect(formatComment(inputString, 60)).toBe(expectedOutput);\n    });\n\n    it('test with a line that is exactly max_length characters long', () => {\n        const inputString = \"A\".repeat(60); // 60 characters long\n        const expectedOutput = \"# \" + \"A\".repeat(60);\n        expect(formatComment(inputString, 60)).toBe(expectedOutput);\n    });\n\n    it('test with an empty string', () => {\n        const inputString = \"\";\n        const expectedOutput = \"# \";\n        expect(formatComment(inputString)).toBe(expectedOutput);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Formats a string into a commented block with a specified maximum line length.\n * \n * @param string - The input string to format.\n * @param maxLength - The maximum length of each line in the output. Defaults to 60.\n * @returns A formatted string with each line prefixed by '# ' and not exceeding the specified maxLength.\n */\nfunction formatComment(string: string, maxLength: number = 60): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <string>\n\n/**\n * @brief Formats a string into a commented block with a specified maximum line length.\n *\n * This function takes an input string and formats it into lines that are\n * each prefixed by '// '. The lines will not exceed the specified maximum\n * length, ensuring that the output is neatly formatted.\n *\n * @param string The input string to format.\n * @param max_length Maximum length of each line in the output.\n * @return A formatted string with each line prefixed by '// ' and not exceeding \n *         the specified max_length.\n */\nstd::string format_comment(const std::string& string, int max_length = 60) {}\n", "test_code": "TEST_CASE(\"Test format_comment function\", \"[format_comment]\") {\n    SECTION(\"Test with a short string that fits within max_length\") {\n        std::string input_string = \"This is a test.\";\n        std::string expected_output = \"# This is a test.\";\n        REQUIRE(format_comment(input_string) == expected_output);\n    }\n\n    SECTION(\"Test with a longer string that exceeds max_length\") {\n        std::string input_string = \"This is a test of the format_comment function which should wrap long lines correctly.\";\n        std::string expected_output =\n            \"# This is a test of the format_comment function which should\\n\"\n            \"# wrap long lines correctly.\";\n        REQUIRE(format_comment(input_string, 60) == expected_output);\n    }\n\n    SECTION(\"Test with multiple lines of input\") {\n        std::string input_string = \"First line.\\nSecond line that is quite long and needs to be wrapped.\";\n        std::string expected_output =\n            \"# First line.\\n\"\n            \"# Second line that is quite long and needs to be wrapped.\";\n        REQUIRE(format_comment(input_string, 60) == expected_output);\n    }\n\n    SECTION(\"Test with a line that is exactly max_length characters long\") {\n        std::string input_string(60, 'A');  // 60 characters long\n        std::string expected_output = \"# \" + std::string(60, 'A');\n        REQUIRE(format_comment(input_string, 60) == expected_output);\n    }\n\n    SECTION(\"Test with an empty string\") {\n        std::string input_string = \"\";\n        std::string expected_output = \"# \";\n        REQUIRE(format_comment(input_string) == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <string>\n\n/**\n * @brief Formats a string into a commented block with a specified maximum line length.\n *\n * This function takes an input string and formats it into lines that are\n * each prefixed by '// '. The lines will not exceed the specified maximum\n * length, ensuring that the output is neatly formatted.\n *\n * @param string The input string to format.\n * @param max_length Maximum length of each line in the output.\n * @return A formatted string with each line prefixed by '// ' and not exceeding \n *         the specified max_length.\n */\nstd::string format_comment(const std::string& string, int max_length = 60) {}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Formats a string into a commented block with specified maximum line length.\n *\n * @param string     the input string to format\n * @param maxLength  the maximum length of each line in the output\n * @return           a formatted string with each line prefixed by '# ' and not exceeding the specified maxLength\n */\npublic String formatComment(String string, int maxLength) {", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testFormatComment() {\n        String input = \"This is a long string that needs to be formatted into multiple lines.\";\n        int maxLength = 60;\n        String expectedOutput = \"# This is a long string that\\n# needs to be formatted into\\n# multiple lines.\";\n\n        String actualOutput = formatComment(input, maxLength);\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    private String formatComment(String string, int maxLength) {\n        StringBuilder result = new StringBuilder();\n        String[] words = string.split(\" \");\n        StringBuilder currentLine = new StringBuilder(\"# \");\n\n        for (String word : words) {\n            if ((currentLine.length() + word.length()) > maxLength) {\n                result.append(currentLine).append(\"\\n\");\n                currentLine = new StringBuilder(\"# \").append(word);\n            } else {\n                currentLine.append(word).append(\" \");\n            }\n        }\n\n        result.append(currentLine);\n        return result.toString().trim();\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Formats a string into a commented block with specified maximum line length.\n *\n * @param string     the input string to format\n * @param maxLength  the maximum length of each line in the output\n * @return           a formatted string with each line prefixed by '# ' and not exceeding the specified maxLength\n */\npublic String formatComment(String string, int maxLength) {,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 445, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Create a pose matrix representing a rotation about a given axis", "language_version_list": {"python": {"code_signature": "import numpy\nimport numpy as np\n\n\ndef create_rot_matrix(angle_deg: float, axis: str) -> numpy.ndarray:\n    \"\"\"\n    Create a pose matrix representing a rotation about a given axis.\n\n    Args:\n        angle_deg (float): Rotation angle in degrees.\n        axis (str): Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n\n    Returns:\n        numpy.ndarray: 4x4 pose matrix representing the rotation.\n    \"\"\"\n", "test_code": "import unittest\nimport numpy as np\nfrom numpy.testing import assert_array_almost_equal\n\n\n\nclass TestCreateRotMatrix(unittest.TestCase):\n    def test_rotation_x_90_degrees(self):\n        \"\"\" Test rotation around X-axis for 90 degrees \"\"\"\n        expected_matrix = np.array([\n            [1, 0, 0, 0],\n            [0, 0, -1, 0],\n            [0, 1, 0, 0],\n            [0, 0, 0, 1]\n        ])\n        result_matrix = create_rot_matrix(90, 'x')\n        assert_array_almost_equal(result_matrix, expected_matrix)\n\n    def test_rotation_y_180_degrees(self):\n        \"\"\" Test rotation around Y-axis for 180 degrees \"\"\"\n        expected_matrix = np.array([\n            [-1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, -1, 0],\n            [0, 0, 0, 1]\n        ])\n        result_matrix = create_rot_matrix(180, 'y')\n        assert_array_almost_equal(result_matrix, expected_matrix)\n\n    def test_rotation_z_270_degrees(self):\n        \"\"\" Test rotation around Z-axis for 270 degrees (or -90 degrees) \"\"\"\n        expected_matrix = np.array([\n            [0, 1, 0, 0],\n            [-1, 0, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]\n        ])\n        result_matrix = create_rot_matrix(270, 'z')\n        assert_array_almost_equal(result_matrix, expected_matrix)\n\n    def test_invalid_axis(self):\n        \"\"\" Test behavior with invalid axis input \"\"\"\n        with self.assertRaises(ValueError):\n            create_rot_matrix(90, 'a')\n\n    def test_zero_rotation(self):\n        \"\"\" Test zero degree rotation which should lead to identity matrix \"\"\"\n        expected_matrix = np.eye(4)\n        result_matrix = create_rot_matrix(0, 'x')\n        assert_array_almost_equal(result_matrix, expected_matrix)", "prompt": "please write a python function , the function signature as below import numpy\nimport numpy as np\n\n\ndef create_rot_matrix(angle_deg: float, axis: str) -> numpy.ndarray:\n    \"\"\"\n    Create a pose matrix representing a rotation about a given axis.\n\n    Args:\n        angle_deg (float): Rotation angle in degrees.\n        axis (str): Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n\n    Returns:\n        numpy.ndarray: 4x4 pose matrix representing the rotation.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Create a pose matrix representing a rotation about a given axis.\n *\n * @param {number} angleDeg - Rotation angle in degrees.\n * @param {string} axis - Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n * @returns {Array<Array<number>>} - 4x4 pose matrix representing the rotation.\n */\nfunction createRotMatrix(angleDeg, axis) {}", "test_code": "describe('TestCreateRotMatrix', () => {\n    it('test_rotation_x_90_degrees', () => {\n        /** Test rotation around X-axis for 90 degrees */\n        const expectedMatrix = [\n            [1, 0, 0, 0],\n            [0, 0, -1, 0],\n            [0, 1, 0, 0],\n            [0, 0, 0, 1]\n        ];\n        const resultMatrix = createRotMatrix(90, 'x');\n        expect(resultMatrix).toEqual(expectedMatrix);\n    });\n\n    it('test_rotation_y_180_degrees', () => {\n        /** Test rotation around Y-axis for 180 degrees */\n        const expectedMatrix = [\n            [-1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, -1, 0],\n            [0, 0, 0, 1]\n        ];\n        const resultMatrix = createRotMatrix(180, 'y');\n        expect(resultMatrix).toEqual(expectedMatrix);\n    });\n\n    it('test_rotation_z_270_degrees', () => {\n        /** Test rotation around Z-axis for 270 degrees (or -90 degrees) */\n        const expectedMatrix = [\n            [0, 1, 0, 0],\n            [-1, 0, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]\n        ];\n        const resultMatrix = createRotMatrix(270, 'z');\n        expect(resultMatrix).toEqual(expectedMatrix);\n    });\n\n    it('test_invalid_axis', () => {\n        /** Test behavior with invalid axis input */\n        expect(() => createRotMatrix(90, 'a')).toThrow('Invalid axis. Must be one of \\'X\\', \\'Y\\', or \\'Z\\'.');\n    });\n\n    it('test_zero_rotation', () => {\n        /** Test zero degree rotation which should lead to identity matrix */\n        const expectedMatrix = [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]\n        ];\n        const resultMatrix = createRotMatrix(0, 'x');\n        expect(resultMatrix).toEqual(expectedMatrix);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Create a pose matrix representing a rotation about a given axis.\n *\n * @param {number} angleDeg - Rotation angle in degrees.\n * @param {string} axis - Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n * @returns {Array<Array<number>>} - 4x4 pose matrix representing the rotation.\n */\nfunction createRotMatrix(angleDeg, axis) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as math from 'mathjs';\n\n/**\n * Create a pose matrix representing a rotation about a given axis.\n *\n * @param angleDeg - Rotation angle in degrees.\n * @param axis - Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n * @returns A 4x4 pose matrix representing the rotation.\n */\nfunction createRotMatrix(angleDeg: number, axis: 'X' | 'Y' | 'Z'): number[][] {}", "test_code": "import * as math from 'mathjs';\n\ndescribe('TestCreateRotMatrix', () => {\n  it('test_rotation_x_90_degrees', () => {\n    /** Test rotation around X-axis for 90 degrees */\n    const expectedMatrix = [\n      [1, 0, 0, 0],\n      [0, 0, -1, 0],\n      [0, 1, 0, 0],\n      [0, 0, 0, 1]\n    ];\n    const resultMatrix = createRotMatrix(90, 'X');\n    expect(resultMatrix).toEqual(expectedMatrix);\n  });\n\n  it('test_rotation_y_180_degrees', () => {\n    /** Test rotation around Y-axis for 180 degrees */\n    const expectedMatrix = [\n      [-1, 0, 0, 0],\n      [0, 1, 0, 0],\n      [0, 0, -1, 0],\n      [0, 0, 0, 1]\n    ];\n    const resultMatrix = createRotMatrix(180, 'Y');\n    expect(resultMatrix).toEqual(expectedMatrix);\n  });\n\n  it('test_rotation_z_270_degrees', () => {\n    /** Test rotation around Z-axis for 270 degrees (or -90 degrees) */\n    const expectedMatrix = [\n      [0, 1, 0, 0],\n      [-1, 0, 0, 0],\n      [0, 0, 1, 0],\n      [0, 0, 0, 1]\n    ];\n    const resultMatrix = createRotMatrix(270, 'Z');\n    expect(resultMatrix).toEqual(expectedMatrix);\n  });\n\n  it('test_invalid_axis', () => {\n    /** Test behavior with invalid axis input */\n    expect(() => createRotMatrix(90, 'A')).toThrow('Invalid axis. Must be one of \\'X\\', \\'Y\\', or \\'Z\\'.');\n  });\n\n  it('test_zero_rotation', () => {\n    /** Test zero degree rotation which should lead to identity matrix */\n    const expectedMatrix = [\n      [1, 0, 0, 0],\n      [0, 1, 0, 0],\n      [0, 0, 1, 0],\n      [0, 0, 0, 1]\n    ];\n    const resultMatrix = createRotMatrix(0, 'X');\n    expect(resultMatrix).toEqual(expectedMatrix);\n  });\n});", "prompt": "please write a typescript function , the function signature as below import * as math from 'mathjs';\n\n/**\n * Create a pose matrix representing a rotation about a given axis.\n *\n * @param angleDeg - Rotation angle in degrees.\n * @param axis - Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n * @returns A 4x4 pose matrix representing the rotation.\n */\nfunction createRotMatrix(angleDeg: number, axis: 'X' | 'Y' | 'Z'): number[][] {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <Eigen/Dense>\n#include <string>\n\n/**\n * @brief Create a pose matrix representing a rotation about a given axis.\n *\n * @param angle_deg Rotation angle in degrees.\n * @param axis Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n * @return Eigen::Matrix4d 4x4 pose matrix representing the rotation.\n */\nEigen::Matrix4d create_rot_matrix(double angle_deg, const std::string& axis);", "test_code": "TEST_CASE(\"Create Rotation Matrix\", \"[rotation]\") {\n    // Test for X-axis rotation\n    auto xRotation = create_rot_matrix(90.0, 'X');\n    REQUIRE(xRotation(1, 1) == Approx(cos(M_PI / 2)).margin(1e-6));\n    REQUIRE(xRotation(1, 2) == Approx(-sin(M_PI / 2)).margin(1e-6));\n    REQUIRE(xRotation(2, 1) == Approx(sin(M_PI / 2)).margin(1e-6));\n    REQUIRE(xRotation(2, 2) == Approx(cos(M_PI / 2)).margin(1e-6));\n\n    // Test for Y-axis rotation\n    auto yRotation = create_rot_matrix(90.0, 'Y');\n    REQUIRE(yRotation(0, 0) == Approx(cos(M_PI / 2)).margin(1e-6));\n    REQUIRE(yRotation(0, 2) == Approx(sin(M_PI / 2)).margin(1e-6));\n    REQUIRE(yRotation(2, 0) == Approx(-sin(M_PI / 2)).margin(1e-6));\n    REQUIRE(yRotation(2, 2) == Approx(cos(M_PI / 2)).margin(1e-6));\n\n    // Test for Z-axis rotation\n    auto zRotation = create_rot_matrix(90.0, 'Z');\n    REQUIRE(zRotation(0, 0) == Approx(cos(M_PI / 2)).margin(1e-6));\n    REQUIRE(zRotation(0, 1) == Approx(-sin(M_PI / 2)).margin(1e-6));\n    REQUIRE(zRotation(1, 0) == Approx(sin(M_PI / 2)).margin(1e-6));\n    REQUIRE(zRotation(1, 1) == Approx(cos(M_PI / 2)).margin(1e-6));\n}\n", "prompt": "please write a cpp function , the function signature as below #include <Eigen/Dense>\n#include <string>\n\n/**\n * @brief Create a pose matrix representing a rotation about a given axis.\n *\n * @param angle_deg Rotation angle in degrees.\n * @param axis Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n * @return Eigen::Matrix4d 4x4 pose matrix representing the rotation.\n */\nEigen::Matrix4d create_rot_matrix(double angle_deg, const std::string& axis);", "addition_info": ""}, "java": {"code_signature": "import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\nimport org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * Create a pose matrix representing a rotation about a given axis.\n *\n * @param angleDeg Rotation angle in degrees.\n * @param axis     Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n * @return A 4x4 pose matrix representing the rotation.\n */\npublic class PoseMatrixCreator {\n\n    public static RealMatrix createRotMatrix(double angleDeg, String axis) {\n        // Implementation goes here\n    }\n}\n", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    private double[][] identityMatrix = {\n            {1, 0, 0, 0},\n            {0, 1, 0, 0},\n            {0, 0, 1, 0},\n            {0, 0, 0, 1}\n    };\n\n    @BeforeEach\n    public void setUp() {\n        // Setup code if needed\n    }\n\n    @Test\n    public void testCreateRotMatrix_XAxis_90Degrees() {\n        double[][] expected = {\n                {1, 0, 0, 0},\n                {0, 0, -1, 0},\n                {0, 1, 0, 0},\n                {0, 0, 0, 1}\n        };\n        double[][] result = createRotMatrix(90, \"X\");\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testCreateRotMatrix_YAxis_90Degrees() {\n        double[][] expected = {\n                {0, 0, 1, 0},\n                {0, 1, 0, 0},\n                {-1, 0, 0, 0},\n                {0, 0, 0, 1}\n        };\n        double[][] result = createRotMatrix(90, \"Y\");\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testCreateRotMatrix_ZAxis_90Degrees() {\n        double[][] expected = {\n                {0, -1, 0, 0},\n                {1, 0, 0, 0},\n                {0, 0, 1, 0},\n                {0, 0, 0, 1}\n        };\n        double[][] result = createRotMatrix(90, \"Z\");\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testCreateRotMatrix_InvalidAxis() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> {\n            createRotMatrix(90, \"W\");\n        });\n        assertEquals(\"Invalid axis provided\", exception.getMessage());\n    }\n\n    private double[][] createRotMatrix(double angleDeg, String axis) {\n        // Implement the logic for creating the rotation matrix here\n        // For simplicity, let's assume it returns an identity matrix\n        return identityMatrix;\n    }\n}\n", "prompt": "please write a java function , the function signature as below import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\nimport org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * Create a pose matrix representing a rotation about a given axis.\n *\n * @param angleDeg Rotation angle in degrees.\n * @param axis     Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n * @return A 4x4 pose matrix representing the rotation.\n */\npublic class PoseMatrixCreator {\n\n    public static RealMatrix createRotMatrix(double angleDeg, String axis) {\n        // Implementation goes here\n    }\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 451, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Converts an image to a binary representation.Convert the image to black and white mode, that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black pixel value of 0", "language_version_list": {"python": {"code_signature": "def convert_image_to_bits(image_path: str):\n    \"\"\"\n    Converts an image to a binary representation.Convert the image to black and white mode, that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black pixel value of 0\n\n    Args:\n        image_path (str): The file path of the image to convert.\n\n    Returns:\n        list: A list of bits representing the image, where 1 is for white pixels\n              and 0 is for black pixels.\n    \"\"\"\n", "test_code": "import os\nimport unittest\n\nfrom PIL import Image\n\n\nclass TestConvertImageToBits(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create test images before each test.\"\"\"\n        # Create a white image (all pixels white)\n        self.white_image_path = 'white_image.bmp'\n        white_image = Image.new('1', (2, 2), color=1)  # 1 is for white\n        white_image.save(self.white_image_path)\n\n        # Create a black image (all pixels black)\n        self.black_image_path = 'black_image.bmp'\n        black_image = Image.new('1', (2, 2), color=0)  # 0 is for black\n        black_image.save(self.black_image_path)\n\n        # Create a mixed image (half white, half black)\n        self.mixed_image_path = 'mixed_image.bmp'\n        mixed_image = Image.new('1', (2, 2))\n        mixed_image.putpixel((0, 0), 1)  # White\n        mixed_image.putpixel((0, 1), 0)  # Black\n        mixed_image.putpixel((1, 0), 0)  # Black\n        mixed_image.putpixel((1, 1), 1)  # White\n        mixed_image.save(self.mixed_image_path)\n\n    def tearDown(self):\n        \"\"\"Remove the test images after each test.\"\"\"\n        os.remove(self.white_image_path)\n        os.remove(self.black_image_path)\n        os.remove(self.mixed_image_path)\n\n    def test_white_image(self):\n        \"\"\"Test converting a white image.\"\"\"\n        expected_output = [1, 1, 1, 1]  # All pixels should be 1 (white)\n        result = convert_image_to_bits(self.white_image_path)\n        self.assertEqual(result, expected_output)\n\n    def test_black_image(self):\n        \"\"\"Test converting a black image.\"\"\"\n        expected_output = [0, 0, 0, 0]  # All pixels should be 0 (black)\n        result = convert_image_to_bits(self.black_image_path)\n        self.assertEqual(result, expected_output)\n\n    def test_mixed_image(self):\n        \"\"\"Test converting a mixed image.\"\"\"\n        expected_output = [1, 0, 0, 1]  # 1 white, 3 black\n        result = convert_image_to_bits(self.mixed_image_path)\n        self.assertEqual(result, expected_output)\n\n    def test_invalid_image_path(self):\n        \"\"\"Test converting an invalid image path.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            convert_image_to_bits('invalid_image_path.bmp')\n\n    def test_large_image(self):\n        \"\"\"Test converting a larger image.\"\"\"\n        # Create a larger image (3x3)\n        large_image_path = 'large_image.bmp'\n        large_image = Image.new('1', (3, 3))\n        large_image.putpixel((0, 0), 1)\n        large_image.putpixel((1, 1), 1)\n        large_image.putpixel((2, 2), 1)\n        large_image.save(large_image_path)\n\n        expected_output = [\n            1, 0, 0,\n            0, 1, 0,\n            0, 0, 1\n        ]\n        result = convert_image_to_bits(large_image_path)\n        self.assertEqual(result, expected_output)\n\n        # Clean up\n        os.remove(large_image_path)\n", "prompt": "please write a python function , the function signature as below def convert_image_to_bits(image_path: str):\n    \"\"\"\n    Converts an image to a binary representation.Convert the image to black and white mode, that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black pixel value of 0\n\n    Args:\n        image_path (str): The file path of the image to convert.\n\n    Returns:\n        list: A list of bits representing the image, where 1 is for white pixels\n              and 0 is for black pixels.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "const Jimp = require('jimp');\n\n/**\n * Converts an image to a binary representation.\n * Convert the image to black and white mode, that is, each pixel is represented by only 1 bit,\n * with a white pixel value of 255 and a black pixel value of 0.\n *\n * @param {string} imagePath - The file path of the image to convert.\n * @returns {Promise<Array<number>>} A promise that resolves to an array of bits representing the image,\n *                                   where 1 is for white pixels and 0 is for black pixels.\n */\nasync function convertImageToBits(imagePath) {}", "test_code": "const fs = require('fs');\nconst Jimp = require('jimp');\n\ndescribe('TestConvertImageToBits', () => {\n    let white_image_path = 'white_image.bmp';\n    let black_image_path = 'black_image.bmp';\n    let mixed_image_path = 'mixed_image.bmp';\n\n    beforeEach(() => {\n        // Create a white image (all pixels white)\n        Jimp.create(2, 2, 0xffffff).write(white_image_path);\n\n        // Create a black image (all pixels black)\n        Jimp.create(2, 2, 0x000000).write(black_image_path);\n\n        // Create a mixed image (half white, half black)\n        const mixedImage = new Jimp(2, 2);\n        mixedImage.setPixelColor(0xffffff, 0, 0); // White\n        mixedImage.setPixelColor(0x000000, 0, 1); // Black\n        mixedImage.setPixelColor(0x000000, 1, 0); // Black\n        mixedImage.setPixelColor(0xffffff, 1, 1); // White\n        mixedImage.write(mixed_image_path);\n    });\n\n    afterEach(() => {\n        fs.unlinkSync(white_image_path);\n        fs.unlinkSync(black_image_path);\n        fs.unlinkSync(mixed_image_path);\n    });\n\n    it('test_white_image', async () => {\n        const expected_output = [1, 1, 1, 1];  // All pixels should be 1 (white)\n        const result = await convertImageToBits(white_image_path);\n        expect(result).toEqual(expected_output);\n    });\n\n    it('test_black_image', async () => {\n        const expected_output = [0, 0, 0, 0];  // All pixels should be 0 (black)\n        const result = await convertImageToBits(black_image_path);\n        expect(result).toEqual(expected_output);\n    });\n\n    it('test_mixed_image', async () => {\n        const expected_output = [1, 0, 0, 1];  // 1 white, 3 black\n        const result = await convertImageToBits(mixed_image_path);\n        expect(result).toEqual(expected_output);\n    });\n\n    it('test_invalid_image_path', async () => {\n        try {\n            await convertImageToBits('invalid_image_path.bmp');\n        } catch (error) {\n            expect(error.code).toBe('ENOENT');\n        }\n    });\n\n    it('test_large_image', async () => {\n        const large_image_path = 'large_image.bmp';\n        const largeImage = new Jimp(3, 3);\n        largeImage.setPixelColor(0xffffff, 0, 0); // White\n        largeImage.setPixelColor(0xffffff, 1, 1); // White\n        largeImage.setPixelColor(0xffffff, 2, 2); // White\n        largeImage.write(large_image_path);\n\n        const expected_output = [\n            1, 0, 0,\n            0, 1, 0,\n            0, 0, 1\n        ];\n        const result = await convertImageToBits(large_image_path);\n        expect(result).toEqual(expected_output);\n\n        // Clean up\n        fs.unlinkSync(large_image_path);\n    });\n});", "prompt": "please write a javascript function , the function signature as below const Jimp = require('jimp');\n\n/**\n * Converts an image to a binary representation.\n * Convert the image to black and white mode, that is, each pixel is represented by only 1 bit,\n * with a white pixel value of 255 and a black pixel value of 0.\n *\n * @param {string} imagePath - The file path of the image to convert.\n * @returns {Promise<Array<number>>} A promise that resolves to an array of bits representing the image,\n *                                   where 1 is for white pixels and 0 is for black pixels.\n */\nasync function convertImageToBits(imagePath) {}", "addition_info": ""}, "typescript": {"code_signature": "import Jimp from 'jimp';\n\n/**\n * Converts an image to a binary representation.\n * Converts the image to black and white mode, that is, each pixel is represented by only 1 bit,\n * with a white pixel value of 255 and a black pixel value of 0.\n *\n * @param {string} imagePath - The file path of the image to convert.\n * @returns {Promise<number[]>} A promise that resolves to a list of bits representing the image,\n *                              where 1 is for white pixels and 0 is for black pixels.\n */\nasync function convertImageToBits(imagePath: string): Promise<number[]> {}", "test_code": "import Jimp from 'jimp';\n\ndescribe('TestConvertImageToBits', () => {\n    let whiteImagePath: string;\n    let blackImagePath: string;\n    let mixedImagePath: string;\n    let largeImagePath: string;\n\n    beforeEach(() => {\n        // Create test images before each test\n        whiteImagePath = 'white_image.bmp';\n        blackImagePath = 'black_image.bmp';\n        mixedImagePath = 'mixed_image.bmp';\n        largeImagePath = 'large_image.bmp';\n\n        // Create a white image (all pixels white)\n        const whiteImage = new Jimp(2, 2, 0xffffffff); // 0xffffffff is white\n        whiteImage.write(whiteImagePath);\n\n        // Create a black image (all pixels black)\n        const blackImage = new Jimp(2, 2, 0x00000000); // 0x00000000 is black\n        blackImage.write(blackImagePath);\n\n        // Create a mixed image (half white, half black)\n        const mixedImage = new Jimp(2, 2);\n        mixedImage.setPixelColor(0xffffffff, 0, 0); // White\n        mixedImage.setPixelColor(0x00000000, 0, 1); // Black\n        mixedImage.setPixelColor(0x00000000, 1, 0); // Black\n        mixedImage.setPixelColor(0xffffffff, 1, 1); // White\n        mixedImage.write(mixedImagePath);\n\n        // Create a larger image (3x3)\n        const largeImage = new Jimp(3, 3);\n        largeImage.setPixelColor(0xffffffff, 0, 0); // White\n        largeImage.setPixelColor(0xffffffff, 1, 1); // White\n        largeImage.setPixelColor(0xffffffff, 2, 2); // White\n        largeImage.write(largeImagePath);\n    });\n\n    afterEach(() => {\n        // Remove the test images after each test\n        require('fs').unlinkSync(whiteImagePath);\n        require('fs').unlinkSync(blackImagePath);\n        require('fs').unlinkSync(mixedImagePath);\n        require('fs').unlinkSync(largeImagePath);\n    });\n\n    it('test converting a white image', async () => {\n        const expectedOutput = [1, 1, 1, 1]; // All pixels should be 1 (white)\n        const result = await convertImageToBits(whiteImagePath);\n        expect(result).toEqual(expectedOutput);\n    });\n\n    it('test converting a black image', async () => {\n        const expectedOutput = [0, 0, 0, 0]; // All pixels should be 0 (black)\n        const result = await convertImageToBits(blackImagePath);\n        expect(result).toEqual(expectedOutput);\n    });\n\n    it('test converting a mixed image', async () => {\n        const expectedOutput = [1, 0, 0, 1]; // 1 white, 3 black\n        const result = await convertImageToBits(mixedImagePath);\n        expect(result).toEqual(expectedOutput);\n    });\n\n    it('test converting an invalid image path', async () => {\n        await expect(convertImageToBits('invalid_image_path.bmp')).rejects.toThrow(/ENOENT/);\n    });\n\n    it('test converting a larger image', async () => {\n        const expectedOutput = [\n            1, 0, 0,\n            0, 1, 0,\n            0, 0, 1\n        ];\n        const result = await convertImageToBits(largeImagePath);\n        expect(result).toEqual(expectedOutput);\n    });\n});", "prompt": "please write a typescript function , the function signature as below import Jimp from 'jimp';\n\n/**\n * Converts an image to a binary representation.\n * Converts the image to black and white mode, that is, each pixel is represented by only 1 bit,\n * with a white pixel value of 255 and a black pixel value of 0.\n *\n * @param {string} imagePath - The file path of the image to convert.\n * @returns {Promise<number[]>} A promise that resolves to a list of bits representing the image,\n *                              where 1 is for white pixels and 0 is for black pixels.\n */\nasync function convertImageToBits(imagePath: string): Promise<number[]> {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts an image to a binary representation. Convert the image to black and white mode,\n * that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black pixel value of 0.\n *\n * @param image_path The file path of the image to convert.\n * @return A vector of integers representing the image, where 1 is for white pixels and 0 is for black pixels.\n */\nstd::vector<int> convertImageToBits(const std::string& image_path);\n", "test_code": "#include <catch2/catch.hpp>\n#include <vector>\n#include <memory>\n#include \"image_converter.h\" // Assuming this is where your convertImageToBits function is defined\n\n// Mock implementation of convertImageToBits for testing purposes\nstd::vector<int> convertImageToBits(const std::string& image_path) {\n    // This is just a placeholder. Replace it with actual logic if needed.\n    return {1, 1, 1, 1};\n}\n\nTEST_CASE(\"Convert image to bits\", \"[image_conversion]\") {\n    // Create a simple white image\n    auto img = std::make_unique<Image>(2, 2); // Assuming Image is a class that represents an image\n    img->fill(255);\n\n    // Convert the image to a byte array\n    std::vector<unsigned char> img_byte_arr;\n    img->save(img_byte_arr);\n\n    // Call the function under test\n    std::vector<int> result = convertImageToBits(\"dummy_path\"); // Use a dummy path for simplicity\n\n    // Define the expected result\n    std::vector<int> expected_result = {1, 1, 1, 1};\n\n    // Check if the result matches the expected result\n    REQUIRE(result == expected_result);\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * Converts an image to a binary representation. Convert the image to black and white mode,\n * that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black pixel value of 0.\n *\n * @param image_path The file path of the image to convert.\n * @return A vector of integers representing the image, where 1 is for white pixels and 0 is for black pixels.\n */\nstd::vector<int> convertImageToBits(const std::string& image_path);\n", "addition_info": ""}, "java": {"code_signature": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\n/**\n * Converts an image to a binary representation. Convert the image to black and white mode,\n * that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black\n * pixel value of 0.\n *\n * @param imagePath The file path of the image to convert.\n * @return A list of bits representing the image, where 1 is for white pixels and 0 is for black pixels.\n */\npublic List<Integer> convertImageToBits(String imagePath) {\n    // Function implementation will go here.\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testConvertImageToBits() {\n        // Assuming convertImageToBits is implemented in ImageConverter class\n        ImageConverter converter = new ImageConverter();\n\n        // Example image path (replace with actual image path)\n        String imagePath = \"path/to/your/image.jpg\";\n\n        // Call the method to be tested\n        List<Integer> result = converter.convertImageToBits(imagePath);\n\n        // Expected result (replace with actual expected result)\n        List<Integer> expectedResult = Arrays.asList(0, 1, 0, 1, 1, 0, 0, 1);\n\n        // Assert the result\n        assertEquals(expectedResult, result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below import java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\n/**\n * Converts an image to a binary representation. Convert the image to black and white mode,\n * that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black\n * pixel value of 0.\n *\n * @param imagePath The file path of the image to convert.\n * @return A list of bits representing the image, where 1 is for white pixels and 0 is for black pixels.\n */\npublic List<Integer> convertImageToBits(String imagePath) {\n    // Function implementation will go here.\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 460, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Multiplies a matrix by a vector and returns the resulting vector.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef matrix_vector_multiplication(matrix: List[List[float]], vector: List[float]) -> List[float]:\n    \"\"\"\n    Multiplies a matrix by a vector and returns the resulting vector.\n\n    Args:\n        matrix (List[List[float]]): A 2D list representing the matrix.\n        vector (List[float]): A 1D list representing the vector.\n\n    Returns:\n        List[float]: The resulting vector after multiplication.\n\n    Raises:\n        ValueError: If the dimensions of the matrix and vector are not compatible for multiplication.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestMatrixVectorMultiplication(unittest.TestCase):\n\n    def test_non_square_matrix(self):\n        \"\"\"Test case for a non-square matrix and a compatible vector.\"\"\"\n        matrix = [[1, 2], [3, 4], [5, 6]]\n        vector = [2, 3]\n        expected_result = [8.0, 18.0, 28.0]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_zero_vector(self):\n        \"\"\"Test case for a matrix and a zero vector.\"\"\"\n        matrix = [[1, 2, 3], [4, 5, 6]]\n        vector = [0, 0, 0]\n        expected_result = [0.0, 0.0]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_single_element(self):\n        \"\"\"Test case for a single element matrix and vector.\"\"\"\n        matrix = [[5]]\n        vector = [3]\n        expected_result = [15.0]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_single_element_matrix_and_vector(self):\n        # Test case with a single element in the matrix and vector\n        matrix = [[3]]\n        vector = [4]\n        expected = [12]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected)\n\n    def test_compatible_sizes(self):\n        # Test case with compatible sizes but different dimensions\n        matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        vector = [1, 1, 1]\n        expected = [6, 15, 24]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef matrix_vector_multiplication(matrix: List[List[float]], vector: List[float]) -> List[float]:\n    \"\"\"\n    Multiplies a matrix by a vector and returns the resulting vector.\n\n    Args:\n        matrix (List[List[float]]): A 2D list representing the matrix.\n        vector (List[float]): A 1D list representing the vector.\n\n    Returns:\n        List[float]: The resulting vector after multiplication.\n\n    Raises:\n        ValueError: If the dimensions of the matrix and vector are not compatible for multiplication.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Multiplies a matrix by a vector and returns the resulting vector.\n *\n * @param {number[][]} matrix - A 2D array representing the matrix.\n * @param {number[]} vector - A 1D array representing the vector.\n * @returns {number[]} The resulting vector after multiplication.\n * @throws {Error} If the dimensions of the matrix and vector are not compatible for multiplication.\n */\nfunction matrixVectorMultiplication(matrix, vector) {}", "test_code": "describe('TestMatrixVectorMultiplication', () => {\n    it('test_non_square_matrix', () => {\n        // Test case for a non-square matrix and a compatible vector.\n        const matrix = [[1, 2], [3, 4], [5, 6]];\n        const vector = [2, 3];\n        const expectedResult = [8.0, 18.0, 28.0];\n        expect(matrixVectorMultiplication(matrix, vector)).toEqual(expectedResult);\n    });\n\n    it('test_zero_vector', () => {\n        // Test case for a matrix and a zero vector.\n        const matrix = [[1, 2, 3], [4, 5, 6]];\n        const vector = [0, 0, 0];\n        const expectedResult = [0.0, 0.0];\n        expect(matrixVectorMultiplication(matrix, vector)).toEqual(expectedResult);\n    });\n\n    it('test_single_element', () => {\n        // Test case for a single element matrix and vector.\n        const matrix = [[5]];\n        const vector = [3];\n        const expectedResult = [15.0];\n        expect(matrixVectorMultiplication(matrix, vector)).toEqual(expectedResult);\n    });\n\n    it('test_single_element_matrix_and_vector', () => {\n        // Test case with a single element in the matrix and vector.\n        const matrix = [[3]];\n        const vector = [4];\n        const expected = [12];\n        expect(matrixVectorMultiplication(matrix, vector)).toEqual(expected);\n    });\n\n    it('test_compatible_sizes', () => {\n        // Test case with compatible sizes but different dimensions.\n        const matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n        const vector = [1, 1, 1];\n        const expected = [6, 15, 24];\n        expect(matrixVectorMultiplication(matrix, vector)).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Multiplies a matrix by a vector and returns the resulting vector.\n *\n * @param {number[][]} matrix - A 2D array representing the matrix.\n * @param {number[]} vector - A 1D array representing the vector.\n * @returns {number[]} The resulting vector after multiplication.\n * @throws {Error} If the dimensions of the matrix and vector are not compatible for multiplication.\n */\nfunction matrixVectorMultiplication(matrix, vector) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Multiplies a matrix by a vector and returns the resulting vector.\n *\n * @param matrix - A 2D array representing the matrix.\n * @param vector - A 1D array representing the vector.\n * @returns The resulting vector after multiplication.\n * @throws {Error} If the dimensions of the matrix and vector are not compatible for multiplication.\n */\nfunction matrixVectorMultiplication(matrix: number[][], vector: number[]): number[] {}", "test_code": "describe('matrixVectorMultiplication', () => {\n    it('test_non_square_matrix', () => {\n        // Test case for a non-square matrix and a compatible vector\n        const matrix = [[1, 2], [3, 4], [5, 6]];\n        const vector = [2, 3];\n        const expectedResult = [8.0, 18.0, 28.0];\n        expect(matrixVectorMultiplication(matrix, vector)).toEqual(expectedResult);\n    });\n\n    it('test_zero_vector', () => {\n        // Test case for a matrix and a zero vector\n        const matrix = [[1, 2, 3], [4, 5, 6]];\n        const vector = [0, 0, 0];\n        const expectedResult = [0.0, 0.0];\n        expect(matrixVectorMultiplication(matrix, vector)).toEqual(expectedResult);\n    });\n\n    it('test_single_element', () => {\n        // Test case for a single element matrix and vector\n        const matrix = [[5]];\n        const vector = [3];\n        const expectedResult = [15.0];\n        expect(matrixVectorMultiplication(matrix, vector)).toEqual(expectedResult);\n    });\n\n    it('test_single_element_matrix_and_vector', () => {\n        // Test case with a single element in the matrix and vector\n        const matrix = [[3]];\n        const vector = [4];\n        const expected = [12];\n        expect(matrixVectorMultiplication(matrix, vector)).toEqual(expected);\n    });\n\n    it('test_compatible_sizes', () => {\n        // Test case with compatible sizes but different dimensions\n        const matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n        const vector = [1, 1, 1];\n        const expected = [6, 15, 24];\n        expect(matrixVectorMultiplication(matrix, vector)).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Multiplies a matrix by a vector and returns the resulting vector.\n *\n * @param matrix - A 2D array representing the matrix.\n * @param vector - A 1D array representing the vector.\n * @returns The resulting vector after multiplication.\n * @throws {Error} If the dimensions of the matrix and vector are not compatible for multiplication.\n */\nfunction matrixVectorMultiplication(matrix: number[][], vector: number[]): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <vector>\n#include <stdexcept>\n\n/**\n * @brief Multiplies a matrix by a vector and returns the resulting vector.\n *\n * @param matrix A 2D vector representing the matrix.\n * @param vector A 1D vector representing the vector.\n * @return The resulting vector after multiplication.\n * @throw std::invalid_argument If the dimensions of the matrix and vector are not compatible for multiplication.\n */\nstd::vector<double> matrix_vector_multiplication(const std::vector<std::vector<double>>& matrix, const std::vector<double>& vector) {\n}\n", "test_code": "TEST_CASE(\"TestMatrixVectorMultiplication\", \"[matrix_vector_multiplication]\") {\n    SECTION(\"test_non_square_matrix\") {\n        std::vector<std::vector<float>> matrix = {{1, 2}, {3, 4}, {5, 6}};\n        std::vector<float> vector = {2, 3};\n        std::vector<float> expected_result = {8.0f, 18.0f, 28.0f};\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected_result);\n    }\n\n    SECTION(\"test_zero_vector\") {\n        std::vector<std::vector<float>> matrix = {{1, 2, 3}, {4, 5, 6}};\n        std::vector<float> vector = {0, 0, 0};\n        std::vector<float> expected_result = {0.0f, 0.0f};\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected_result);\n    }\n\n    SECTION(\"test_single_element\") {\n        std::vector<std::vector<float>> matrix = {{5}};\n        std::vector<float> vector = {3};\n        std::vector<float> expected_result = {15.0f};\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected_result);\n    }\n\n    SECTION(\"test_single_element_matrix_and_vector\") {\n        std::vector<std::vector<float>> matrix = {{3}};\n        std::vector<float> vector = {4};\n        std::vector<float> expected = {12.0f};\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected);\n    }\n\n    SECTION(\"test_compatible_sizes\") {\n        std::vector<std::vector<float>> matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        std::vector<float> vector = {1, 1, 1};\n        std::vector<float> expected = {6.0f, 15.0f, 24.0f};\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <vector>\n#include <stdexcept>\n\n/**\n * @brief Multiplies a matrix by a vector and returns the resulting vector.\n *\n * @param matrix A 2D vector representing the matrix.\n * @param vector A 1D vector representing the vector.\n * @return The resulting vector after multiplication.\n * @throw std::invalid_argument If the dimensions of the matrix and vector are not compatible for multiplication.\n */\nstd::vector<double> matrix_vector_multiplication(const std::vector<std::vector<double>>& matrix, const std::vector<double>& vector) {\n}\n", "addition_info": ""}, "java": {"code_signature": "import java.util.List;\n\n/**\n * Multiplies a matrix by a vector and returns the resulting vector.\n *\n * @param matrix A 2D array representing the matrix.\n * @param vector A 1D array representing the vector.\n * @return The resulting vector after multiplication.\n * @throws IllegalArgumentException If the dimensions of the matrix and vector are not compatible for multiplication.\n */\npublic static double[] matrixVectorMultiplication(double[][] matrix, double[] vector) {\n", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    public List<Double> matrixVectorMultiplication(List<List<Double>> matrix, List<Double> vector) {\n        if (matrix.get(0).size() != vector.size()) {\n            throw new IllegalArgumentException(\"Matrix and vector dimensions are not compatible for multiplication.\");\n        }\n\n        List<Double> result = new ArrayList<>();\n        for (List<Double> row : matrix) {\n            double sum = 0;\n            for (int i = 0; i < row.size(); i++) {\n                sum += row.get(i) * vector.get(i);\n            }\n            result.add(sum);\n        }\n        return result;\n    }\n\n    @Test\n    public void testValidMatrixVectorMultiplication() {\n        List<List<Double>> matrix = Arrays.asList(\n            Arrays.asList(1.0, 2.0),\n            Arrays.asList(3.0, 4.0)\n        );\n        List<Double> vector = Arrays.asList(5.0, 6.0);\n        List<Double> expectedResult = Arrays.asList(17.0, 39.0);\n        assertEquals(expectedResult, matrixVectorMultiplication(matrix, vector));\n    }\n\n    @Test\n    public void testInvalidMatrixVectorMultiplication() {\n        List<List<Double>> matrix = Arrays.asList(\n            Arrays.asList(1.0, 2.0),\n            Arrays.asList(3.0, 4.0)\n        );\n        List<Double> vector = Arrays.asList(5.0);\n        assertThrows(IllegalArgumentException.class, () -> matrixVectorMultiplication(matrix, vector));\n    }\n}", "prompt": "please write a java function , the function signature as below import java.util.List;\n\n/**\n * Multiplies a matrix by a vector and returns the resulting vector.\n *\n * @param matrix A 2D array representing the matrix.\n * @param vector A 1D array representing the vector.\n * @return The resulting vector after multiplication.\n * @throws IllegalArgumentException If the dimensions of the matrix and vector are not compatible for multiplication.\n */\npublic static double[] matrixVectorMultiplication(double[][] matrix, double[] vector) {\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 461, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Calculate the average value of nodes at each level of a binary tree.", "language_version_list": {"python": {"code_signature": "from typing import List, Optional\nfrom collections import deque\n\n\nclass TreeNode:\n    \"\"\"Definition for a binary tree node.\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef average_of_levels(root: Optional[TreeNode]) -> List[float]:\n    \"\"\"\n    Calculate the average value of nodes at each level of a binary tree.\n\n    Args:\n        root (Optional[TreeNode]): The root of the binary tree.\n\n    Returns:\n        List[float]: A list of averages for each level of the binary tree.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TreeNode:\n    \"\"\"Definition for a binary tree node.\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass TestAverageOfLevels(unittest.TestCase):\n    def test_empty_tree(self):\n        \"\"\"Test case for an empty tree.\"\"\"\n        self.assertEqual(average_of_levels(None), [])\n\n    def test_single_node(self):\n        \"\"\"Test case for a tree with a single node.\"\"\"\n        root = TreeNode(5)\n        self.assertEqual(average_of_levels(root), [5.0])\n\n    def test_three_levels(self):\n        \"\"\"Test case for a tree with three levels.\"\"\"\n        root = TreeNode(1)\n        root.left = TreeNode(2)\n        root.right = TreeNode(3)\n        root.left.left = TreeNode(4)\n        root.left.right = TreeNode(5)\n        root.right.right = TreeNode(6)\n        self.assertEqual(average_of_levels(root), [1.0, 2.5, 5.0])  # (1), (2, 3) -> [1.0, (2+3)/2], (4, 5, 6) -> [5.0]\n", "prompt": "please write a python function , the function signature as below from typing import List, Optional\nfrom collections import deque\n\n\nclass TreeNode:\n    \"\"\"Definition for a binary tree node.\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef average_of_levels(root: Optional[TreeNode]) -> List[float]:\n    \"\"\"\n    Calculate the average value of nodes at each level of a binary tree.\n\n    Args:\n        root (Optional[TreeNode]): The root of the binary tree.\n\n    Returns:\n        List[float]: A list of averages for each level of the binary tree.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "class TreeNode {\n    /** \n     * Definition for a binary tree node. \n     * @param {number} val \n     * @param {TreeNode|null} left \n     * @param {TreeNode|null} right \n     */\n    constructor(val = 0, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\n/**\n * Calculate the average value of nodes at each level of a binary tree.\n * \n * @param {TreeNode|null} root - The root of the binary tree.\n * @returns {number[]} A list of averages for each level of the binary tree.\n */\nfunction averageOfLevels(root) {}", "test_code": "", "prompt": "please write a javascript function , the function signature as below class TreeNode {\n    /** \n     * Definition for a binary tree node. \n     * @param {number} val \n     * @param {TreeNode|null} left \n     * @param {TreeNode|null} right \n     */\n    constructor(val = 0, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\n/**\n * Calculate the average value of nodes at each level of a binary tree.\n * \n * @param {TreeNode|null} root - The root of the binary tree.\n * @returns {number[]} A list of averages for each level of the binary tree.\n */\nfunction averageOfLevels(root) {}", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 462, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Given a 2D matrix, return all elements of the matrix in spiral order", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef spiral_order(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a 2D matrix, return all elements of the matrix in spiral order.\n\n    Args:\n        matrix (List[List[int]]): A 2D list of integers.\n\n    Returns:\n        List[int]: A list of integers representing the matrix elements in spiral order.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestSpiralOrder(unittest.TestCase):\n    def test_empty_matrix(self):\n        self.assertEqual(spiral_order([]), [])\n\n    def test_single_row_matrix(self):\n        self.assertEqual(spiral_order([[1, 2, 3]]), [1, 2, 3])\n\n    def test_single_column_matrix(self):\n        self.assertEqual(spiral_order([[1], [2], [3]]), [1, 2, 3])\n\n    def test_square_matrix(self):\n        self.assertEqual(spiral_order([\n            [1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]\n        ]), [1, 2, 3, 6, 9, 8, 7, 4, 5])\n\n    def test_rectangle_matrix(self):\n        self.assertEqual(spiral_order([\n            [1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]\n        ]), [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7])", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef spiral_order(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a 2D matrix, return all elements of the matrix in spiral order.\n\n    Args:\n        matrix (List[List[int]]): A 2D list of integers.\n\n    Returns:\n        List[int]: A list of integers representing the matrix elements in spiral order.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Given a 2D matrix, return all elements of the matrix in spiral order.\n * \n * @param {number[][]} matrix - A 2D array of integers.\n * @returns {number[]} - An array of integers representing the matrix elements in spiral order.\n */\nfunction spiralOrder(matrix) {}", "test_code": "describe('Test Spiral Order', () => {\n  it('should handle an empty matrix', () => {\n      expect(spiralOrder([])).toEqual([]);\n  });\n\n  it('should handle a single row matrix', () => {\n      expect(spiralOrder([[1, 2, 3]])).toEqual([1, 2, 3]);\n  });\n\n  it('should handle a single column matrix', () => {\n      expect(spiralOrder([[1], [2], [3]])).toEqual([1, 2, 3]);\n  });\n\n  it('should handle a square matrix', () => {\n      expect(spiralOrder([\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9]\n      ])).toEqual([1, 2, 3, 6, 9, 8, 7, 4, 5]);\n  });\n\n  it('should handle a rectangle matrix', () => {\n      expect(spiralOrder([\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12]\n      ])).toEqual([1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Given a 2D matrix, return all elements of the matrix in spiral order.\n * \n * @param {number[][]} matrix - A 2D array of integers.\n * @returns {number[]} - An array of integers representing the matrix elements in spiral order.\n */\nfunction spiralOrder(matrix) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Given a 2D matrix, return all elements of the matrix in spiral order.\n * \n * @param matrix - A 2D array of numbers.\n * @returns An array of numbers representing the matrix elements in spiral order.\n */\nfunction spiralOrder(matrix: number[][]): number[] {}", "test_code": "describe('Test Spiral Order', () => {\n    it('should handle an empty matrix', () => {\n        expect(spiralOrder([])).toEqual([]);\n    });\n\n    it('should handle a single row matrix', () => {\n        expect(spiralOrder([[1, 2, 3]])).toEqual([1, 2, 3]);\n    });\n\n    it('should handle a single column matrix', () => {\n        expect(spiralOrder([[1], [2], [3]])).toEqual([1, 2, 3]);\n    });\n\n    it('should handle a square matrix', () => {\n        expect(spiralOrder([\n            [1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]\n        ])).toEqual([1, 2, 3, 6, 9, 8, 7, 4, 5]);\n    });\n\n    it('should handle a rectangular matrix', () => {\n        expect(spiralOrder([\n            [1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]\n        ])).toEqual([1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Given a 2D matrix, return all elements of the matrix in spiral order.\n * \n * @param matrix - A 2D array of numbers.\n * @returns An array of numbers representing the matrix elements in spiral order.\n */\nfunction spiralOrder(matrix: number[][]): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <vector>\n#include <iostream>\n\n/**\n * @brief Given a 2D matrix, return all elements of the matrix in spiral order.\n *\n * @param matrix A 2D vector of integers.\n * @return std::vector<int> A vector of integers representing the matrix elements in spiral order.\n */\nstd::vector<int> spiralOrder(const std::vector<std::vector<int>>& matrix);", "test_code": "TEST_CASE(\"Test Spiral Order\", \"[spiralOrder]\") {\n    SECTION(\"Empty Matrix\") {\n        REQUIRE(spiralOrder({}) == std::vector<int>{});\n    }\n\n    SECTION(\"Single Row Matrix\") {\n        REQUIRE(spiralOrder({{1, 2, 3}}) == std::vector<int>({1, 2, 3}));\n    }\n\n    SECTION(\"Single Column Matrix\") {\n        REQUIRE(spiralOrder({{1}, {2}, {3}}) == std::vector<int>({1, 2, 3}));\n    }\n\n    SECTION(\"Square Matrix\") {\n        REQUIRE(spiralOrder({\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        }) == std::vector<int>({1, 2, 3, 6, 9, 8, 7, 4, 5}));\n    }\n\n    SECTION(\"Rectangle Matrix\") {\n        REQUIRE(spiralOrder({\n            {1, 2, 3, 4},\n            {5, 6, 7, 8},\n            {9, 10, 11, 12}\n        }) == std::vector<int>({1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7}));\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <vector>\n#include <iostream>\n\n/**\n * @brief Given a 2D matrix, return all elements of the matrix in spiral order.\n *\n * @param matrix A 2D vector of integers.\n * @return std::vector<int> A vector of integers representing the matrix elements in spiral order.\n */\nstd::vector<int> spiralOrder(const std::vector<std::vector<int>>& matrix);", "addition_info": ""}, "java": {"code_signature": "import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Given a 2D matrix, return all elements of the matrix in spiral order.\n *\n * @param matrix The 2D list of integers.\n * @return A list of integers representing the matrix elements in spiral order.\n */\npublic class SpiralMatrix {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> result = new ArrayList<>();\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return result;\n        }\n\n        int top = 0;\n        int bottom = matrix.length - 1;\n        int left = 0;\n        int right = matrix[0].length - 1;\n\n        while (true) {\n            // Traverse from left to right along the top row\n            for (int i = left; i <= right; i++) {\n                result.add(matrix[top][i]);\n            }\n            top++;\n            if (top > bottom) break;\n\n            // Traverse downwards along the right column\n            for (int i = top; i <= bottom; i++) {\n                result.add(matrix[i][right]);\n            }\n            right--;\n            if (left > right) break;\n\n            // Traverse from right to left along the bottom row\n            for (int i = right; i >= left; i--) {\n                result.add(matrix[bottom][i]);\n            }\n            bottom--;\n            if (top > bottom) break;\n\n            // Traverse upwards along the left column\n            for (int i = bottom; i >= top; i--) {\n                result.add(matrix[i][left]);\n            }\n            left++;\n            if (left > right) break;\n        }\n\n        return result;\n    }\n}\n", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.*;\nimport org.junit.Test;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testSpiralOrder() {\n        MatrixSpiral matrixSpiral = new MatrixSpiral();\n\n        // Test case 1\n        int[][] matrix1 = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n        List<Integer> expected1 = Arrays.asList(1, 2, 3, 6, 9, 8, 7, 4, 5);\n        assertEquals(expected1, matrixSpiral.spiralOrder(matrix1));\n\n        // Test case 2\n        int[][] matrix2 = {\n            {1, 2, 3, 4},\n            {5, 6, 7, 8},\n            {9, 10, 11, 12}\n        };\n        List<Integer> expected2 = Arrays.asList(1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7);\n        assertEquals(expected2, matrixSpiral.spiralOrder(matrix2));\n\n        // Test case 3\n        int[][] matrix3 = {};\n        List<Integer> expected3 = Arrays.asList();\n        assertEquals(expected3, matrixSpiral.spiralOrder(matrix3));\n\n        // Test case 4\n        int[][] matrix4 = {{1}};\n        List<Integer> expected4 = Arrays.asList(1);\n        assertEquals(expected4, matrixSpiral.spiralOrder(matrix4));\n\n        // Test case 5\n        int[][] matrix5 = {\n            {1, 2},\n            {3, 4},\n            {5, 6}\n        };\n        List<Integer> expected5 = Arrays.asList(1, 2, 4, 6, 5, 3);\n        assertEquals(expected5, matrixSpiral.spiralOrder(matrix5));\n    }\n}\n\nclass MatrixSpiral {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> result = new ArrayList<>();\n        if (matrix == null || matrix.length == 0) {\n            return result;\n        }\n\n        int top = 0, bottom = matrix.length - 1;\n        int left = 0, right = matrix[0].length - 1;\n\n        while (top <= bottom && left <= right) {\n            // Traverse from left to right along the top row\n            for (int i = left; i <= right; i++) {\n                result.add(matrix[top][i]);\n            }\n            top++;\n\n            // Traverse downwards along the right column\n            for (int i = top; i <= bottom; i++) {\n                result.add(matrix[i][right]);\n            }\n            right--;\n\n            // Traverse from right to left along the bottom row, if still within bounds\n            if (top <= bottom) {\n                for (int i = right; i >= left; i--) {\n                    result.add(matrix[bottom][i]);\n                }\n                bottom--;\n            }\n\n            // Traverse upwards along the left column, if still within bounds\n            if (left <= right) {\n                for (int i = bottom; i >= top; i--) {\n                    result.add(matrix[i][left]);\n                }\n                left++;\n            }\n        }\n\n        return result;\n    }\n}\n", "prompt": "please write a java function , the function signature as below import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Given a 2D matrix, return all elements of the matrix in spiral order.\n *\n * @param matrix The 2D list of integers.\n * @return A list of integers representing the matrix elements in spiral order.\n */\npublic class SpiralMatrix {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> result = new ArrayList<>();\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return result;\n        }\n\n        int top = 0;\n        int bottom = matrix.length - 1;\n        int left = 0;\n        int right = matrix[0].length - 1;\n\n        while (true) {\n            // Traverse from left to right along the top row\n            for (int i = left; i <= right; i++) {\n                result.add(matrix[top][i]);\n            }\n            top++;\n            if (top > bottom) break;\n\n            // Traverse downwards along the right column\n            for (int i = top; i <= bottom; i++) {\n                result.add(matrix[i][right]);\n            }\n            right--;\n            if (left > right) break;\n\n            // Traverse from right to left along the bottom row\n            for (int i = right; i >= left; i--) {\n                result.add(matrix[bottom][i]);\n            }\n            bottom--;\n            if (top > bottom) break;\n\n            // Traverse upwards along the left column\n            for (int i = bottom; i >= top; i--) {\n                result.add(matrix[i][left]);\n            }\n            left++;\n            if (left > right) break;\n        }\n\n        return result;\n    }\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 463, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Obtain logs of [WARNING], [ERROR], [CRITICAL], and [ALERT] levels from the log file", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef extract_log_levels(log_file_path:str, output_file_path:str):\n    \"\"\"\n    Obtain logs of [WARNING], [ERROR], [CRITICAL], and [ALERT] levels from the log file\n    log content such as:\n        [INFO] Information message\n        [WARNING] Warning message\n        [DEBUG] Debug message\n\n    Args:\n        log_file_path: log file path\n        output_file_path: output log file path\n\n    Returns:\n\n    \"\"\"", "test_code": "import unittest\nimport tempfile\nimport os\n\n\n# Assuming the extract_log_levels function is defined here or imported\n\nclass TestLogExtraction(unittest.TestCase):\n    def create_temp_log_file(self, content):\n        # Create a temporary log file\n        temp_file = tempfile.NamedTemporaryFile(delete=False, mode='w+')\n        temp_file.write(content)\n        temp_file.close()\n        return temp_file.name\n\n    def read_output_file(self, file_path):\n        # Read content from a file\n        with open(file_path, 'r') as file:\n            return file.read()\n\n    def test_warning_level(self):\n        logs = \"\"\"[INFO] Information message\n[WARNING] Warning message\n[DEBUG] Debug message\"\"\"\n        expected_output = \"[WARNING] Warning message\\n\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n\n    def test_error_level(self):\n        logs = \"\"\"[ERROR] Error occurred\n[INFO] Just an info\"\"\"\n        expected_output = \"[ERROR] Error occurred\\n\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n\n    def test_critical_and_alert_levels(self):\n        logs = \"\"\"[ALERT] Security breach\n[CRITICAL] System failure\n[NOTICE] Something to notice\"\"\"\n        expected_output = \"[ALERT] Security breach\\n[CRITICAL] System failure\\n\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n\n    def test_no_relevant_logs(self):\n        logs = \"[INFO] No issues here\\n[DEBUG] All systems go\"\n        expected_output = \"\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n\n    def test_mixed_logs(self):\n        logs = \"\"\"[WARNING] Low disk space\n[INFO] Update completed\n[ERROR] Failed to load module\n[CRITICAL] Memory leak detected\n[DEBUG] This is a debug message\"\"\"\n        expected_output = \"[WARNING] Low disk space\\n[ERROR] Failed to load module\\n[CRITICAL] Memory leak detected\\n\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef extract_log_levels(log_file_path:str, output_file_path:str):\n    \"\"\"\n    Obtain logs of [WARNING], [ERROR], [CRITICAL], and [ALERT] levels from the log file\n    log content such as:\n        [INFO] Information message\n        [WARNING] Warning message\n        [DEBUG] Debug message\n\n    Args:\n        log_file_path: log file path\n        output_file_path: output log file path\n\n    Returns:\n\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 465, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "Implement matrix and vector multiplication", "language_version_list": {"python": {"code_signature": "import numpy\nimport numpy as np\n\n\ndef matrix_vector_multiplication(matrix: np.array, vector: np.array) -> numpy.ndarray:\n    \"\"\"\n    Multiplies a given matrix by a vector using NumPy's dot product.\n\n    Parameters:\n    matrix (numpy.ndarray): A 2D array (matrix) of shape (m, n) where m is the number of rows\n                            and n is the number of columns.\n    vector (numpy.ndarray): A 1D array (vector) of shape (n,) that represents a vector\n                            compatible for multiplication with the given matrix.\n\n    Returns:\n    numpy.ndarray: A 1D array (resulting vector) of shape (m,) representing the product of\n                   the matrix and the vector.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestMatrixVectorMultiplication(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test with a simple 2x2 matrix and a 2-element vector\n        matrix = np.array([[1, 2], [3, 4]])\n        vector = np.array([5, 6])\n        expected_result = np.array([17, 39])  # [1*5 + 2*6, 3*5 + 4*6]\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_case_2(self):\n        # Test with a 3x3 matrix and a 3-element vector\n        matrix = np.array([[1, 0, 2], [0, 1, 2], [1, 1, 0]])\n        vector = np.array([3, 4, 5])\n        expected_result = np.array([13, 14, 7])  # [1*3 + 0*4 + 2*5, 0*3 + 1*4 + 2*5, 1*3 + 1*4 + 0*5]\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_case_3(self):\n        # Test with a zero matrix and a vector\n        matrix = np.array([[0, 0], [0, 0]])\n        vector = np.array([1, 1])\n        expected_result = np.array([0, 0])  # Zero matrix multiplied by any vector yields zero\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_case_4(self):\n        # Test with a matrix having negative values\n        matrix = np.array([[-1, -2], [-3, -4]])\n        vector = np.array([1, 1])\n        expected_result = np.array([-3, -7])  # [-1*1 + -2*1, -3*1 + -4*1]\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_case_5(self):\n        # Test with non-square matrix (2x3) and a compatible vector (3-element)\n        matrix = np.array([[1, 2, 3], [4, 5, 6]])\n        vector = np.array([1, 0, 1])\n        expected_result = np.array([4, 10])  # [1*1 + 2*0 + 3*1, 4*1 + 5*0 + 6*1]\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)", "prompt": "please write a python function , the function signature as below import numpy\nimport numpy as np\n\n\ndef matrix_vector_multiplication(matrix: np.array, vector: np.array) -> numpy.ndarray:\n    \"\"\"\n    Multiplies a given matrix by a vector using NumPy's dot product.\n\n    Parameters:\n    matrix (numpy.ndarray): A 2D array (matrix) of shape (m, n) where m is the number of rows\n                            and n is the number of columns.\n    vector (numpy.ndarray): A 1D array (vector) of shape (n,) that represents a vector\n                            compatible for multiplication with the given matrix.\n\n    Returns:\n    numpy.ndarray: A 1D array (resulting vector) of shape (m,) representing the product of\n                   the matrix and the vector.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "const math = require('mathjs');\n\n/**\n * Multiplies a given matrix by a vector using mathjs's multiply function.\n * \n * @param {Array<Array<number>>} matrix - A 2D array (matrix) of shape (m, n) where m is the number of rows\n *                                        and n is the number of columns.\n * @param {Array<number>} vector - A 1D array (vector) of shape (n,) that represents a vector\n *                                 compatible for multiplication with the given matrix.\n * @returns {Array<number>} - A 1D array (resulting vector) of shape (m,) representing the product of\n *                            the matrix and the vector.\n */\nfunction matrixVectorMultiplication(matrix, vector) {}", "test_code": "const math = require('mathjs');\n\ndescribe('TestMatrixVectorMultiplication', () => {\n    it('test_case_1', () => {\n        // Test with a simple 2x2 matrix and a 2-element vector\n        const matrix = [[1, 2], [3, 4]];\n        const vector = [5, 6];\n        const expected_result = [17, 39];  // [1*5 + 2*6, 3*5 + 4*6]\n        expect(matrixVectorMultiplication(matrix, vector)).toEqual(expected_result);\n    });\n\n    it('test_case_2', () => {\n        // Test with a 3x3 matrix and a 3-element vector\n        const matrix = [[1, 0, 2], [0, 1, 2], [1, 1, 0]];\n        const vector = [3, 4, 5];\n        const expected_result = [13, 14, 7];  // [1*3 + 0*4 + 2*5, 0*3 + 1*4 + 2*5, 1*3 + 1*4 + 0*5]\n        expect(matrixVectorMultiplication(matrix, vector)).toEqual(expected_result);\n    });\n\n    it('test_case_3', () => {\n        // Test with a zero matrix and a vector\n        const matrix = [[0, 0], [0, 0]];\n        const vector = [1, 1];\n        const expected_result = [0, 0];  // Zero matrix multiplied by any vector yields zero\n        expect(matrixVectorMultiplication(matrix, vector)).toEqual(expected_result);\n    });\n\n    it('test_case_4', () => {\n        // Test with a matrix having negative values\n        const matrix = [[-1, -2], [-3, -4]];\n        const vector = [1, 1];\n        const expected_result = [-3, -7];  // [-1*1 + -2*1, -3*1 + -4*1]\n        expect(matrixVectorMultiplication(matrix, vector)).toEqual(expected_result);\n    });\n\n    it('test_case_5', () => {\n        // Test with non-square matrix (2x3) and a compatible vector (3-element)\n        const matrix = [[1, 2, 3], [4, 5, 6]];\n        const vector = [1, 0, 1];\n        const expected_result = [4, 10];  // [1*1 + 2*0 + 3*1, 4*1 + 5*0 + 6*1]\n        expect(matrixVectorMultiplication(matrix, vector)).toEqual(expected_result);\n    });\n});", "prompt": "please write a javascript function , the function signature as below const math = require('mathjs');\n\n/**\n * Multiplies a given matrix by a vector using mathjs's multiply function.\n * \n * @param {Array<Array<number>>} matrix - A 2D array (matrix) of shape (m, n) where m is the number of rows\n *                                        and n is the number of columns.\n * @param {Array<number>} vector - A 1D array (vector) of shape (n,) that represents a vector\n *                                 compatible for multiplication with the given matrix.\n * @returns {Array<number>} - A 1D array (resulting vector) of shape (m,) representing the product of\n *                            the matrix and the vector.\n */\nfunction matrixVectorMultiplication(matrix, vector) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as math from 'mathjs';\n\n/**\n * Multiplies a given matrix by a vector using the dot product.\n *\n * @param matrix - A 2D array (matrix) of shape (m, n) where m is the number of rows\n *                 and n is the number of columns.\n * @param vector - A 1D array (vector) of shape (n,) that represents a vector\n *                 compatible for multiplication with the given matrix.\n * @returns A 1D array (resulting vector) of shape (m,) representing the product of\n *          the matrix and the vector.\n */\nfunction matrixVectorMultiplication(matrix: number[][], vector: number[]): number[] {}", "test_code": "import * as math from 'mathjs';\n\ndescribe('TestMatrixVectorMultiplication', () => {\n  it('test_case_1', () => {\n    // Test with a simple 2x2 matrix and a 2-element vector\n    const matrix: number[][] = [[1, 2], [3, 4]];\n    const vector: number[] = [5, 6];\n    const expectedResult: number[] = [17, 39];  // [1*5 + 2*6, 3*5 + 4*6]\n    expect(matrixVectorMultiplication(matrix, vector)).toEqual(expectedResult);\n  });\n\n  it('test_case_2', () => {\n    // Test with a 3x3 matrix and a 3-element vector\n    const matrix: number[][] = [[1, 0, 2], [0, 1, 2], [1, 1, 0]];\n    const vector: number[] = [3, 4, 5];\n    const expectedResult: number[] = [13, 14, 7];  // [1*3 + 0*4 + 2*5, 0*3 + 1*4 + 2*5, 1*3 + 1*4 + 0*5]\n    expect(matrixVectorMultiplication(matrix, vector)).toEqual(expectedResult);\n  });\n\n  it('test_case_3', () => {\n    // Test with a zero matrix and a vector\n    const matrix: number[][] = [[0, 0], [0, 0]];\n    const vector: number[] = [1, 1];\n    const expectedResult: number[] = [0, 0];  // Zero matrix multiplied by any vector yields zero\n    expect(matrixVectorMultiplication(matrix, vector)).toEqual(expectedResult);\n  });\n\n  it('test_case_4', () => {\n    // Test with a matrix having negative values\n    const matrix: number[][] = [[-1, -2], [-3, -4]];\n    const vector: number[] = [1, 1];\n    const expectedResult: number[] = [-3, -7];  // [-1*1 + -2*1, -3*1 + -4*1]\n    expect(matrixVectorMultiplication(matrix, vector)).toEqual(expectedResult);\n  });\n\n  it('test_case_5', () => {\n    // Test with non-square matrix (2x3) and a compatible vector (3-element)\n    const matrix: number[][] = [[1, 2, 3], [4, 5, 6]];\n    const vector: number[] = [1, 0, 1];\n    const expectedResult: number[] = [4, 10];  // [1*1 + 2*0 + 3*1, 4*1 + 5*0 + 6*1]\n    expect(matrixVectorMultiplication(matrix, vector)).toEqual(expectedResult);\n  });\n});", "prompt": "please write a typescript function , the function signature as below import * as math from 'mathjs';\n\n/**\n * Multiplies a given matrix by a vector using the dot product.\n *\n * @param matrix - A 2D array (matrix) of shape (m, n) where m is the number of rows\n *                 and n is the number of columns.\n * @param vector - A 1D array (vector) of shape (n,) that represents a vector\n *                 compatible for multiplication with the given matrix.\n * @returns A 1D array (resulting vector) of shape (m,) representing the product of\n *          the matrix and the vector.\n */\nfunction matrixVectorMultiplication(matrix: number[][], vector: number[]): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "\n/**\n * @brief Multiplies a given matrix by a vector.\n *\n * @param matrix The input matrix represented as a vector of vectors.\n * @param vector The input vector represented as a vector.\n * @return The resulting vector after multiplying the matrix and the vector.\n */\nstd::vector<double> matrix_vector_multiplication(const std::vector<std::vector<double>>& matrix, const std::vector<double>& vector) {}", "test_code": "TEST_CASE(\"Test Matrix-Vector Multiplication\", \"[matrix-vector-multiplication]\") {\n    SECTION(\"Test with a simple 2x2 matrix and a 2-element vector\") {\n        std::vector<std::vector<double>> matrix = {{1, 2}, {3, 4}};\n        std::vector<double> vector = {5, 6};\n        std::vector<double> expected_result = {17, 39};  // [1*5 + 2*6, 3*5 + 4*6]\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected_result);\n    }\n\n    SECTION(\"Test with a 3x3 matrix and a 3-element vector\") {\n        std::vector<std::vector<double>> matrix = {{1, 0, 2}, {0, 1, 2}, {1, 1, 0}};\n        std::vector<double> vector = {3, 4, 5};\n        std::vector<double> expected_result = {13, 14, 7};  // [1*3 + 0*4 + 2*5, 0*3 + 1*4 + 2*5, 1*3 + 1*4 + 0*5]\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected_result);\n    }\n\n    SECTION(\"Test with a zero matrix and a vector\") {\n        std::vector<std::vector<double>> matrix = {{0, 0}, {0, 0}};\n        std::vector<double> vector = {1, 1};\n        std::vector<double> expected_result = {0, 0};  // Zero matrix multiplied by any vector yields zero\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected_result);\n    }\n\n    SECTION(\"Test with a matrix having negative values\") {\n        std::vector<std::vector<double>> matrix = {{-1, -2}, {-3, -4}};\n        std::vector<double> vector = {1, 1};\n        std::vector<double> expected_result = {-3, -7};  // [-1*1 + -2*1, -3*1 + -4*1]\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected_result);\n    }\n\n    SECTION(\"Test with non-square matrix (2x3) and a compatible vector (3-element)\") {\n        std::vector<std::vector<double>> matrix = {{1, 2, 3}, {4, 5, 6}};\n        std::vector<double> vector = {1, 0, 1};\n        std::vector<double> expected_result = {4, 10};  // [1*1 + 2*0 + 3*1, 4*1 + 5*0 + 6*1]\n\n        REQUIRE(matrix_vector_multiplication(matrix, vector) == expected_result);\n    }\n}", "prompt": "please write a cpp function , the function signature as below \n/**\n * @brief Multiplies a given matrix by a vector.\n *\n * @param matrix The input matrix represented as a vector of vectors.\n * @param vector The input vector represented as a vector.\n * @return The resulting vector after multiplying the matrix and the vector.\n */\nstd::vector<double> matrix_vector_multiplication(const std::vector<std::vector<double>>& matrix, const std::vector<double>& vector) {}", "addition_info": ""}, "java": {"code_signature": "import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealVector;\n\npublic class MatrixVectorMultiplication {\n\n    /**\n     * Multiplies a given matrix by a vector using Apache Commons Math's RealMatrix and RealVector classes.\n\n     * @param matrix The 2D array (matrix) of shape (m, n) where m is the number of rows\n                    and n is the number of columns.\n     * @param vector The 1D array (vector) of shape (n,) that represents a vector\n                    compatible for multiplication with the given matrix.\n     * @return A 1D array (resulting vector) of shape (m,) representing the product of\n                the matrix and the vector.\n     */\n    public static RealVector matrixVectorMultiplication(double[][] matrix, double[] vector) {\n        // Create a new Array2DRowRealMatrix object from the provided matrix.\n        Array2DRowRealMatrix matrixObj = new Array2DRowRealMatrix(matrix);\n\n        // Create a new RealVector object from the provided vector.\n        RealVector vectorObj = new ArrayRealVector(vector);\n\n        // Multiply the matrix by the vector using the multiply method.\n        RealVector result = matrixObj.operate(vectorObj);\n\n        // Return the resulting vector from the multiplication.\n        return result;\n    }\n}\n", "test_code": "import static org.junit.Assert.assertArrayEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testMatrixVectorMultiplication() {\n        double[][] matrix = {{1, 2}, {3, 4}};\n        double[] vector = {5, 6};\n\n        // Call the method under test\n        double[] result = matrixVectorMultiplication(matrix, vector);\n\n        // Define expected output\n        double[] expectedOutput = {17, 39};\n\n        // Assert if the actual output matches the expected output\n        assertArrayEquals(expectedOutput, result, 0.0001);\n    }\n\n    private double[] matrixVectorMultiplication(double[][] matrix, double[] vector) {\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        double[] result = new double[rows];\n\n        for(int i=0; i<rows; i++) {\n            for(int j=0; j<cols; j++) {\n                result[i] += matrix[i][j] * vector[j];\n            }\n        }\n\n        return result;\n    }\n}", "prompt": "please write a java function , the function signature as below import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealVector;\n\npublic class MatrixVectorMultiplication {\n\n    /**\n     * Multiplies a given matrix by a vector using Apache Commons Math's RealMatrix and RealVector classes.\n\n     * @param matrix The 2D array (matrix) of shape (m, n) where m is the number of rows\n                    and n is the number of columns.\n     * @param vector The 1D array (vector) of shape (n,) that represents a vector\n                    compatible for multiplication with the given matrix.\n     * @return A 1D array (resulting vector) of shape (m,) representing the product of\n                the matrix and the vector.\n     */\n    public static RealVector matrixVectorMultiplication(double[][] matrix, double[] vector) {\n        // Create a new Array2DRowRealMatrix object from the provided matrix.\n        Array2DRowRealMatrix matrixObj = new Array2DRowRealMatrix(matrix);\n\n        // Create a new RealVector object from the provided vector.\n        RealVector vectorObj = new ArrayRealVector(vector);\n\n        // Multiply the matrix by the vector using the multiply method.\n        RealVector result = matrixObj.operate(vectorObj);\n\n        // Return the resulting vector from the multiplication.\n        return result;\n    }\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 468, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "Given a 3x3 matrix, return the corresponding translation vector", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef get_translation(matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given a 3x3 matrix, return the corresponding translation vector.\n\n    Args:\n        matrix (np.ndarray): A 3x3 affine transformation matrix.\n\n    Returns:\n        np.ndarray: A 2-element array containing the translation components (translation_x, translation_y).\n    \"\"\"", "test_code": "import numpy as np\nimport unittest\n\n\n# Assume the get_translation function is defined as provided\n\nclass TestGetTranslationFunction(unittest.TestCase):\n\n    def test_identity_matrix(self):\n        \"\"\" Test for the identity matrix (no translation) \"\"\"\n        matrix = np.array([[1, 0, 0],\n                           [0, 1, 0],\n                           [0, 0, 1]])\n        expected_translation = np.array([0.0, 0.0])\n        np.testing.assert_array_equal(get_translation(matrix), expected_translation)\n\n    def test_translation_matrix(self):\n        \"\"\" Test for a translation matrix (5 in x, 10 in y) \"\"\"\n        matrix = np.array([[1, 0, 5],\n                           [0, 1, 10],\n                           [0, 0, 1]])\n        expected_translation = np.array([5.0, 10.0])\n        np.testing.assert_array_equal(get_translation(matrix), expected_translation)\n\n    def test_negative_translation(self):\n        \"\"\" Test for a translation matrix with negative values \"\"\"\n        matrix = np.array([[1, 0, -3],\n                           [0, 1, -6],\n                           [0, 0, 1]])\n        expected_translation = np.array([-3.0, -6.0])\n        np.testing.assert_array_equal(get_translation(matrix), expected_translation)", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef get_translation(matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given a 3x3 matrix, return the corresponding translation vector.\n\n    Args:\n        matrix (np.ndarray): A 3x3 affine transformation matrix.\n\n    Returns:\n        np.ndarray: A 2-element array containing the translation components (translation_x, translation_y).\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "const math = require('mathjs');\n\n/**\n * Given a 3x3 matrix, return the corresponding translation vector.\n *\n * @param {Array<Array<number>>} matrix - A 3x3 affine transformation matrix.\n * @returns {Array<number>} A 2-element array containing the translation components (translation_x, translation_y).\n */\nfunction getTranslation(matrix) {}", "test_code": "const math = require('mathjs');\n\ndescribe('TestGetTranslationFunction', () => {\n    describe('test_identity_matrix', () => {\n        it('should return the correct translation for the identity matrix', () => {\n            const matrix = [\n                [1, 0, 0],\n                [0, 1, 0],\n                [0, 0, 1]\n            ];\n            const expectedTranslation = [0.0, 0.0];\n            expect(getTranslation(matrix)).toEqual(expectedTranslation);\n        });\n    });\n\n    describe('test_translation_matrix', () => {\n        it('should return the correct translation for a translation matrix (5 in x, 10 in y)', () => {\n            const matrix = [\n                [1, 0, 5],\n                [0, 1, 10],\n                [0, 0, 1]\n            ];\n            const expectedTranslation = [5.0, 10.0];\n            expect(getTranslation(matrix)).toEqual(expectedTranslation);\n        });\n    });\n\n    describe('test_negative_translation', () => {\n        it('should return the correct translation for a translation matrix with negative values', () => {\n            const matrix = [\n                [1, 0, -3],\n                [0, 1, -6],\n                [0, 0, 1]\n            ];\n            const expectedTranslation = [-3.0, -6.0];\n            expect(getTranslation(matrix)).toEqual(expectedTranslation);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below const math = require('mathjs');\n\n/**\n * Given a 3x3 matrix, return the corresponding translation vector.\n *\n * @param {Array<Array<number>>} matrix - A 3x3 affine transformation matrix.\n * @returns {Array<number>} A 2-element array containing the translation components (translation_x, translation_y).\n */\nfunction getTranslation(matrix) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as math from 'mathjs';\n\n/**\n * Given a 3x3 matrix, return the corresponding translation vector.\n *\n * @param matrix - A 3x3 affine transformation matrix.\n * @returns A 2-element array containing the translation components (translation_x, translation_y).\n */\nfunction getTranslation(matrix: number[][]): number[] {}", "test_code": "describe('TestGetTranslationFunction', () => {\n  describe('test_identity_matrix', () => {\n      it('should return the correct translation for the identity matrix', () => {\n          const matrix: number[][] = [\n              [1, 0, 0],\n              [0, 1, 0],\n              [0, 0, 1]\n          ];\n          const expectedTranslation: number[] = [0.0, 0.0];\n          expect(getTranslation(matrix)).toEqual(expectedTranslation);\n      });\n  });\n\n  describe('test_translation_matrix', () => {\n      it('should return the correct translation for a translation matrix', () => {\n          const matrix: number[][] = [\n              [1, 0, 5],\n              [0, 1, 10],\n              [0, 0, 1]\n          ];\n          const expectedTranslation: number[] = [5.0, 10.0];\n          expect(getTranslation(matrix)).toEqual(expectedTranslation);\n      });\n  });\n\n  describe('test_negative_translation', () => {\n      it('should return the correct translation for a translation matrix with negative values', () => {\n          const matrix: number[][] = [\n              [1, 0, -3],\n              [0, 1, -6],\n              [0, 0, 1]\n          ];\n          const expectedTranslation: number[] = [-3.0, -6.0];\n          expect(getTranslation(matrix)).toEqual(expectedTranslation);\n      });\n  });\n});", "prompt": "please write a typescript function , the function signature as below import * as math from 'mathjs';\n\n/**\n * Given a 3x3 matrix, return the corresponding translation vector.\n *\n * @param matrix - A 3x3 affine transformation matrix.\n * @returns A 2-element array containing the translation components (translation_x, translation_y).\n */\nfunction getTranslation(matrix: number[][]): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <Eigen/Dense>\n#include <vector>\n\n/**\n * @brief Given a 3x3 matrix, return the corresponding translation vector.\n *\n * @param matrix A 3x3 affine transformation matrix.\n * @return std::vector<double> A 2-element vector containing the translation components (translation_x, translation_y).\n */\nstd::vector<double> get_translation(const Eigen::Matrix3d& matrix);\n", "test_code": "TEST_CASE(\"Test GetTranslationFunction\", \"[get_translation]\") {\n    SECTION(\"Identity Matrix\") {\n        Eigen::Matrix3d matrix;\n        matrix << 1, 0, 0,\n                  0, 1, 0,\n                  0, 0, 1;\n\n        Eigen::Matrix<double, 2, 1> expected_translation = Eigen::Matrix<double, 2, 1>::Zero();\n        REQUIRE(get_translation(matrix) == expected_translation);\n    }\n\n    SECTION(\"Translation Matrix\") {\n        Eigen::Matrix3d matrix;\n        matrix << 1, 0, 5,\n                  0, 1, 10,\n                  0, 0, 1;\n\n        Eigen::Matrix<double, 2, 1> expected_translation;\n        expected_translation << 5.0, 10.0;\n        REQUIRE(get_translation(matrix) == expected_translation);\n    }\n\n    SECTION(\"Negative Translation\") {\n        Eigen::Matrix3d matrix;\n        matrix << 1, 0, -3,\n                  0, 1, -6,\n                  0, 0, 1;\n\n        Eigen::Matrix<double, 2, 1> expected_translation;\n        expected_translation << -3.0, -6.0;\n        REQUIRE(get_translation(matrix) == expected_translation);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <Eigen/Dense>\n#include <vector>\n\n/**\n * @brief Given a 3x3 matrix, return the corresponding translation vector.\n *\n * @param matrix A 3x3 affine transformation matrix.\n * @return std::vector<double> A 2-element vector containing the translation components (translation_x, translation_y).\n */\nstd::vector<double> get_translation(const Eigen::Matrix3d& matrix);\n", "addition_info": ""}, "java": {"code_signature": "import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * Given a 3x3 matrix, return the corresponding translation vector.\n *\n * @param matrix The 3x3 affine transformation matrix.\n * @return A 2-element array containing the translation components (translation_x, translation_y).\n */\npublic double[] getTranslation(RealMatrix matrix) {\n    // Ensure the input matrix is a 3x3 matrix\n    if (matrix.getRowDimension() != 3 || matrix.getColumnDimension() != 3) {\n        throw new IllegalArgumentException(\"Input matrix must be a 3x3 matrix.\");\n    }\n\n    // Extract the translation vector from the last column of the matrix\n    double translationX = matrix.getEntry(0, 2);\n    double translationY = matrix.getEntry(1, 2);\n\n    // Return the translation vector as a 2-element array\n    return new double[]{translationX, translationY};\n}\n", "test_code": "import static org.junit.Assert.assertArrayEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testGetTranslation() {\n        // Define a sample input matrix\n        double[][] matrix = {\n            {1.0, 0.0, 5.0},\n            {0.0, 1.0, 3.0},\n            {0.0, 0.0, 1.0}\n        };\n\n        // Call the getTranslation method from MatrixUtils\n        double[] result = MatrixUtils.getTranslation(matrix);\n\n        // Expected translation vector\n        double[] expected = {5.0, 3.0};\n\n        // Assert that the result matches the expected output\n        assertArrayEquals(expected, result, 0.001);\n    }\n}\n\n// Assuming there's a utility class with the getTranslation method\nclass MatrixUtils {\n    public static double[] getTranslation(double[][] matrix) {\n        if (matrix.length != 3 || matrix[0].length != 3 || matrix[1].length != 3 || matrix[2].length != 3) {\n            throw new IllegalArgumentException(\"Input matrix must be 3x3\");\n        }\n\n        return new double[]{matrix[0][2], matrix[1][2]};\n    }\n}", "prompt": "please write a java function , the function signature as below import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * Given a 3x3 matrix, return the corresponding translation vector.\n *\n * @param matrix The 3x3 affine transformation matrix.\n * @return A 2-element array containing the translation components (translation_x, translation_y).\n */\npublic double[] getTranslation(RealMatrix matrix) {\n    // Ensure the input matrix is a 3x3 matrix\n    if (matrix.getRowDimension() != 3 || matrix.getColumnDimension() != 3) {\n        throw new IllegalArgumentException(\"Input matrix must be a 3x3 matrix.\");\n    }\n\n    // Extract the translation vector from the last column of the matrix\n    double translationX = matrix.getEntry(0, 2);\n    double translationY = matrix.getEntry(1, 2);\n\n    // Return the translation vector as a 2-element array\n    return new double[]{translationX, translationY};\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 469, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "    Given a 3x3 affine transformation matrix, return the corresponding scaling factors\n    along the x and y axes", "language_version_list": {"python": {"code_signature": "from typing import Tuple\n\nimport numpy as np\n\n\ndef get_scale(matrix: np.ndarray) -> Tuple[np.float64, np.float64]:\n    \"\"\"\n    Given a 3x3 affine transformation matrix, return the corresponding scaling factors\n    along the x and y axes.\n\n    Args:\n        matrix (np.ndarray): A 3x3 affine transformation matrix.\n\n    Returns:\n        Tuple[np.float64, np.float64]: A tuple containing the scale factors (scale_x, scale_y).\n    \"\"\"\n", "test_code": "import numpy as np\nimport unittest\n\n\n# Assume the get_scale function is defined as provided\n\nclass TestGetScaleFunction(unittest.TestCase):\n\n    def test_identity_matrix(self):\n        \"\"\" Test for the identity matrix (no scaling) \"\"\"\n        matrix = np.array([[1, 0, 0],\n                           [0, 1, 0],\n                           [0, 0, 1]])\n        expected_scale = (1.0, 1.0)\n        self.assertEqual(get_scale(matrix), expected_scale)\n\n    def test_scaling_matrix(self):\n        \"\"\" Test for a scaling matrix (2x in x and 3x in y) \"\"\"\n        matrix = np.array([[2, 0, 0],\n                           [0, 3, 0],\n                           [0, 0, 1]])\n        expected_scale = (2.0, 3.0)\n        self.assertEqual(get_scale(matrix), expected_scale)\n\n\n    def test_uniform_scaling(self):\n        # Test case with uniform scaling\n        matrix = np.array([[2, 0, 0],\n                           [0, 2, 0],\n                           [0, 0, 1]])\n        expected = (2.0, 2.0)\n        self.assertEqual(get_scale(matrix), expected)\n\n    def test_non_uniform_scaling(self):\n        # Test case with non-uniform scaling\n        matrix = np.array([[3, 0, 0],\n                           [0, 5, 0],\n                           [0, 0, 1]])\n        expected = (3.0, 5.0)\n        self.assertEqual(get_scale(matrix), expected)\n\n    def test_reflection_matrix(self):\n        # Test case with reflection matrix\n        matrix = np.array([[-1, 0, 0],\n                           [0, 1, 0],\n                           [0, 0, 1]])\n        expected = (1.0, 1.0)\n        self.assertEqual(get_scale(matrix), expected)", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\nimport numpy as np\n\n\ndef get_scale(matrix: np.ndarray) -> Tuple[np.float64, np.float64]:\n    \"\"\"\n    Given a 3x3 affine transformation matrix, return the corresponding scaling factors\n    along the x and y axes.\n\n    Args:\n        matrix (np.ndarray): A 3x3 affine transformation matrix.\n\n    Returns:\n        Tuple[np.float64, np.float64]: A tuple containing the scale factors (scale_x, scale_y).\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "#include <array>\n#include <cmath>\n\n/**\n * @brief Get the scaling factors for a 2D affine transformation.\n *\n * @param matrix The 3x3 affine transformation matrix.\n * @return std::pair<double, double> A pair containing the scale factors (scaleX, scaleY).\n */\nstd::pair<double, double> get_scale(const std::array<std::array<double, 3>, 3>& matrix){}\n", "test_code": "TEST_CASE(\"Test Get Scale Function\", \"[get_scale]\") {\n    SECTION(\"Identity Matrix\") {\n        // Test for the identity matrix (no scaling)\n        Eigen::MatrixXd matrix(3, 3);\n        matrix << 1, 0, 0,\n                  0, 1, 0,\n                  0, 0, 1;\n        auto expected_scale = std::make_pair(1.0, 1.0);\n        REQUIRE(get_scale(matrix) == expected_scale);\n    }\n\n    SECTION(\"Scaling Matrix\") {\n        // Test for a scaling matrix (2x in x and 3x in y)\n        Eigen::MatrixXd matrix(3, 3);\n        matrix << 2, 0, 0,\n                  0, 3, 0,\n                  0, 0, 1;\n        auto expected_scale = std::make_pair(2.0, 3.0);\n        REQUIRE(get_scale(matrix) == expected_scale);\n    }\n\n    SECTION(\"Uniform Scaling\") {\n        // Test case with uniform scaling\n        Eigen::MatrixXd matrix(3, 3);\n        matrix << 2, 0, 0,\n                  0, 2, 0,\n                  0, 0, 1;\n        auto expected_scale = std::make_pair(2.0, 2.0);\n        REQUIRE(get_scale(matrix) == expected_scale);\n    }\n\n    SECTION(\"Non-Uniform Scaling\") {\n        // Test case with non-uniform scaling\n        Eigen::MatrixXd matrix(3, 3);\n        matrix << 3, 0, 0,\n                  0, 5, 0,\n                  0, 0, 1;\n        auto expected_scale = std::make_pair(3.0, 5.0);\n        REQUIRE(get_scale(matrix) == expected_scale);\n    }\n\n    SECTION(\"Reflection Matrix\") {\n        // Test case with reflection matrix\n        Eigen::MatrixXd matrix(3, 3);\n        matrix << -1, 0, 0,\n                  0, 1, 0,\n                  0, 0, 1;\n        auto expected_scale = std::make_pair(1.0, 1.0);\n        REQUIRE(get_scale(matrix) == expected_scale);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <array>\n#include <cmath>\n\n/**\n * @brief Get the scaling factors for a 2D affine transformation.\n *\n * @param matrix The 3x3 affine transformation matrix.\n * @return std::pair<double, double> A pair containing the scale factors (scaleX, scaleY).\n */\nstd::pair<double, double> get_scale(const std::array<std::array<double, 3>, 3>& matrix){}\n", "addition_info": ""}, "java": {"code_signature": "import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\npublic class Main {\n    /**\n     * Given a 3x3 affine transformation matrix, return the corresponding scaling factors\n     * along the x and y axes.\n     *\n     * @param matrix A 3x3 affine transformation matrix.\n     * @return A double array containing the scale factors [scaleX, scaleY].\n     */\n    public static double[] getScale(RealMatrix matrix) {\n        // Your implementation here\n    }\n}\n", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Point2D;\n\npublic class Tester {\n\n    @Test\n    public void testGetScale() {\n        // Define a sample 3x3 affine transformation matrix\n        double[][] matrix = {\n            {2.0, 0.0, 0.0},\n            {0.0, 3.0, 0.0},\n            {0.0, 0.0, 1.0}\n        };\n\n        // Convert the matrix to an AffineTransform object\n        AffineTransform transform = new AffineTransform();\n        transform.setTransform(\n            matrix[0][0], matrix[0][1], matrix[0][2],\n            matrix[1][0], matrix[1][1], matrix[1][2]\n        );\n\n        // Get the scale factors\n        Point2D.Double scale = new Point2D.Double();\n        transform.getScale(scale);\n\n        // Check if the scale factors are correct\n        assertEquals(2.0, scale.x, \"Scale factor along X-axis should be 2.0\");\n        assertEquals(3.0, scale.y, \"Scale factor along Y-axis should be 3.0\");\n    }\n}\n", "prompt": "please write a java function , the function signature as below import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\npublic class Main {\n    /**\n     * Given a 3x3 affine transformation matrix, return the corresponding scaling factors\n     * along the x and y axes.\n     *\n     * @param matrix A 3x3 affine transformation matrix.\n     * @return A double array containing the scale factors [scaleX, scaleY].\n     */\n    public static double[] getScale(RealMatrix matrix) {\n        // Your implementation here\n    }\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 470, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "Applies a shear transformation to a 2D matrix along the x-axis.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef apply_shear_x(matrix: np.array, shear_factor: float):\n    \"\"\"\n    Applies a shear transformation to a 2D matrix along the x-axis.\n\n    Args:\n    matrix (np.ndarray): A 2D numpy array representing the original matrix.\n    shear_factor (float): The factor by which the matrix is sheared along the x-axis.\n\n    Returns:\n    np.ndarray: The sheared matrix.\n    \"\"\"\n", "test_code": "import numpy as np\nimport unittest\n\nclass TestShearTransformation(unittest.TestCase):\n    def test_identity_shear(self):\n        \"\"\" Test with zero shear factor which should return the original matrix unchanged. \"\"\"\n        matrix = np.array([[1, 2], [3, 4]])\n        shear_factor = 0\n        expected_output = np.array([[1, 2], [3, 4]])\n        result = apply_shear_x(matrix, shear_factor)\n        np.testing.assert_array_equal(result, expected_output, \"The matrix should remain unchanged with zero shear factor.\")\n\n    def test_positive_shear(self):\n        \"\"\" Test with a positive shear factor. \"\"\"\n        matrix = np.array([[1, 2], [3, 4]])\n        shear_factor = 1\n        expected_output = np.array([[1, 3], [3, 7]])\n        result = apply_shear_x(matrix, shear_factor)\n        np.testing.assert_array_equal(result, expected_output, \"The matrix should be correctly sheared.\")\n\n    def test_negative_shear(self):\n        \"\"\" Test with a negative shear factor. \"\"\"\n        matrix = np.array([[1, 2], [3, 4]])\n        shear_factor = -1\n        expected_output = np.array([[1, 1], [3, 1]])\n        result = apply_shear_x(matrix, shear_factor)\n        np.testing.assert_array_equal(result, expected_output, \"The matrix should be correctly sheared negatively.\")\n\n\n    def test_high_shear_factor(self):\n        \"\"\" Test with a high shear factor to see how the matrix adapts to extreme transformations. \"\"\"\n        matrix = np.array([[1, 1], [1, 1]])\n        shear_factor = 10\n        expected_output = np.array([[1, 11], [1, 11]])\n        result = apply_shear_x(matrix, shear_factor)\n        np.testing.assert_array_equal(result, expected_output, \"The matrix should be correctly sheared with a high shear factor.\")", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef apply_shear_x(matrix: np.array, shear_factor: float):\n    \"\"\"\n    Applies a shear transformation to a 2D matrix along the x-axis.\n\n    Args:\n    matrix (np.ndarray): A 2D numpy array representing the original matrix.\n    shear_factor (float): The factor by which the matrix is sheared along the x-axis.\n\n    Returns:\n    np.ndarray: The sheared matrix.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Applies a shear transformation to a 2D matrix along the x-axis.\n *\n * @param {Array<Array<number>>} matrix - A 2D array representing the original matrix.\n * @param {number} shearFactor - The factor by which the matrix is sheared along the x-axis.\n * @returns {Array<Array<number>>} The sheared matrix.\n */\nfunction applyShearX(matrix, shearFactor) {}", "test_code": "const assert = require('assert');\n\n\ndescribe('TestShearTransformation', () => {\n    it('test_identity_shear', () => {\n        // Test with zero shear factor which should return the original matrix unchanged.\n        const matrix = [[1, 2], [3, 4]];\n        const shearFactor = 0;\n        const expectedOutput = [[1, 2], [3, 4]];\n        const result = applyShearX(matrix, shearFactor);\n        assert.deepStrictEqual(result, expectedOutput, 'The matrix should remain unchanged with zero shear factor.');\n    });\n\n    it('test_positive_shear', () => {\n        // Test with a positive shear factor.\n        const matrix = [[1, 2], [3, 4]];\n        const shearFactor = 1;\n        const expectedOutput = [[1, 3], [3, 7]];\n        const result = applyShearX(matrix, shearFactor);\n        assert.deepStrictEqual(result, expectedOutput, 'The matrix should be correctly sheared.');\n    });\n\n    it('test_negative_shear', () => {\n        // Test with a negative shear factor.\n        const matrix = [[1, 2], [3, 4]];\n        const shearFactor = -1;\n        const expectedOutput = [[1, 1], [3, 1]];\n        const result = applyShearX(matrix, shearFactor);\n        assert.deepStrictEqual(result, expectedOutput, 'The matrix should be correctly sheared negatively.');\n    });\n\n    it('test_high_shear_factor', () => {\n        // Test with a high shear factor to see how the matrix adapts to extreme transformations.\n        const matrix = [[1, 1], [1, 1]];\n        const shearFactor = 10;\n        const expectedOutput = [[1, 11], [1, 11]];\n        const result = applyShearX(matrix, shearFactor);\n        assert.deepStrictEqual(result, expectedOutput, 'The matrix should be correctly sheared with a high shear factor.');\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Applies a shear transformation to a 2D matrix along the x-axis.\n *\n * @param {Array<Array<number>>} matrix - A 2D array representing the original matrix.\n * @param {number} shearFactor - The factor by which the matrix is sheared along the x-axis.\n * @returns {Array<Array<number>>} The sheared matrix.\n */\nfunction applyShearX(matrix, shearFactor) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as math from 'mathjs';\n\n/**\n * Applies a shear transformation to a 2D matrix along the x-axis.\n *\n * @param matrix - A 2D array representing the original matrix.\n * @param shearFactor - The factor by which the matrix is sheared along the x-axis.\n * @returns The sheared matrix.\n */\nfunction applyShearX(matrix: number[][], shearFactor: number): number[][] {}", "test_code": "import * as math from 'mathjs';\n\ndescribe('TestShearTransformation', () => {\n  /**\n   * Test with zero shear factor which should return the original matrix unchanged.\n   */\n  test('testIdentityShear', () => {\n    const matrix: number[][] = [[1, 2], [3, 4]];\n    const shearFactor: number = 0;\n    const expectedOutput: number[][] = [[1, 2], [3, 4]];\n    const result = applyShearX(matrix, shearFactor);\n    expect(result).toEqual(expectedOutput);\n  });\n\n  /**\n   * Test with a positive shear factor.\n   */\n  test('testPositiveShear', () => {\n    const matrix: number[][] = [[1, 2], [3, 4]];\n    const shearFactor: number = 1;\n    const expectedOutput: number[][] = [[1, 3], [3, 7]];\n    const result = applyShearX(matrix, shearFactor);\n    expect(result).toEqual(expectedOutput);\n  });\n\n  /**\n   * Test with a negative shear factor.\n   */\n  test('testNegativeShear', () => {\n    const matrix: number[][] = [[1, 2], [3, 4]];\n    const shearFactor: number = -1;\n    const expectedOutput: number[][] = [[1, 1], [3, 1]];\n    const result = applyShearX(matrix, shearFactor);\n    expect(result).toEqual(expectedOutput);\n  });\n\n  /**\n   * Test with a high shear factor to see how the matrix adapts to extreme transformations.\n   */\n  test('testHighShearFactor', () => {\n    const matrix: number[][] = [[1, 1], [1, 1]];\n    const shearFactor: number = 10;\n    const expectedOutput: number[][] = [[1, 11], [1, 11]];\n    const result = applyShearX(matrix, shearFactor);\n    expect(result).toEqual(expectedOutput);\n  });\n});", "prompt": "please write a typescript function , the function signature as below import * as math from 'mathjs';\n\n/**\n * Applies a shear transformation to a 2D matrix along the x-axis.\n *\n * @param matrix - A 2D array representing the original matrix.\n * @param shearFactor - The factor by which the matrix is sheared along the x-axis.\n * @returns The sheared matrix.\n */\nfunction applyShearX(matrix: number[][], shearFactor: number): number[][] {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <Eigen/Dense>\n\n/**\n * @brief Applies a shear transformation to a 2D matrix along the x-axis.\n *\n * @param matrix A 2D Eigen::MatrixXd object representing the original matrix.\n * @param shear_factor The factor by which the matrix is sheared along the x-axis.\n * @return Eigen::MatrixXd The sheared matrix.\n */\nEigen::MatrixXd apply_shear_x(const Eigen::MatrixXd& matrix, double shearFactor) {}\n", "test_code": "TEST_CASE(\"TestShearTransformation\", \"[shear]\") {\n    SECTION(\"test_identity_shear\") {\n        // Test with zero shear factor which should return the original matrix unchanged.\n        Eigen::MatrixXd matrix = Eigen::MatrixXd::Zero(2, 2);\n        matrix << 1, 2,\n                  3, 4;\n        double shear_factor = 0;\n        Eigen::MatrixXd expected_output = Eigen::MatrixXd::Zero(2, 2);\n        expected_output << 1, 2,\n                           3, 4;\n        Eigen::MatrixXd result = apply_shear_x(matrix, shear_factor);\n        REQUIRE(result.isApprox(expected_output));\n    }\n\n    SECTION(\"test_positive_shear\") {\n        // Test with a positive shear factor.\n        Eigen::MatrixXd matrix = Eigen::MatrixXd::Zero(2, 2);\n        matrix << 1, 2,\n                  3, 4;\n        double shear_factor = 1;\n        Eigen::MatrixXd expected_output = Eigen::MatrixXd::Zero(2, 2);\n        expected_output << 1, 3,\n                           3, 7;\n        Eigen::MatrixXd result = apply_shear_x(matrix, shear_factor);\n        REQUIRE(result.isApprox(expected_output));\n    }\n\n    SECTION(\"test_negative_shear\") {\n        // Test with a negative shear factor.\n        Eigen::MatrixXd matrix = Eigen::MatrixXd::Zero(2, 2);\n        matrix << 1, 2,\n                  3, 4;\n        double shear_factor = -1;\n        Eigen::MatrixXd expected_output = Eigen::MatrixXd::Zero(2, 2);\n        expected_output << 1, 1,\n                           3, 1;\n        Eigen::MatrixXd result = apply_shear_x(matrix, shear_factor);\n        REQUIRE(result.isApprox(expected_output));\n    }\n\n    SECTION(\"test_high_shear_factor\") {\n        // Test with a high shear factor to see how the matrix adapts to extreme transformations.\n        Eigen::MatrixXd matrix = Eigen::MatrixXd::Zero(2, 2);\n        matrix << 1, 1,\n                  1, 1;\n        double shear_factor = 10;\n        Eigen::MatrixXd expected_output = Eigen::MatrixXd::Zero(2, 2);\n        expected_output << 1, 11,\n                           1, 11;\n        Eigen::MatrixXd result = apply_shear_x(matrix, shear_factor);\n        REQUIRE(result.isApprox(expected_output));\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <Eigen/Dense>\n\n/**\n * @brief Applies a shear transformation to a 2D matrix along the x-axis.\n *\n * @param matrix A 2D Eigen::MatrixXd object representing the original matrix.\n * @param shear_factor The factor by which the matrix is sheared along the x-axis.\n * @return Eigen::MatrixXd The sheared matrix.\n */\nEigen::MatrixXd apply_shear_x(const Eigen::MatrixXd& matrix, double shearFactor) {}\n", "addition_info": ""}, "java": {"code_signature": "import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * Applies a shear transformation to a 2D matrix along the x-axis.\n *\n * @param matrix       the 2D real matrix representing the original matrix.\n * @param shearFactor  the factor by which the matrix is sheared along the x-axis.\n * @return             the sheared matrix.\n */\npublic RealMatrix applyShearX(RealMatrix matrix, double shearFactor) {\n    // Method implementation will go here.\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testApplyShearX() {\n        // Define the input matrix and expected output matrix\n        double[][] inputMatrix = {{1, 2}, {3, 4}};\n        double shearFactor = 0.5; // Example shear factor\n        double[][] expectedOutputMatrix = {{1 + 0.5 * 2, 2}, {3 + 0.5 * 4, 4}};\n\n        // Call the method under test\n        double[][] resultMatrix = applyShearX(inputMatrix, shearFactor);\n\n        // Assert that the result matches the expected output\n        assertArrayEquals(expectedOutputMatrix, resultMatrix);\n    }\n\n    // Dummy implementation of applyShearX for demonstration purposes\n    private double[][] applyShearX(double[][] matrix, double shearFactor) {\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        double[][] result = new double[rows][cols];\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                result[i][j] = matrix[i][j] + shearFactor * matrix[i][j];\n            }\n        }\n\n        return result;\n    }\n}\n", "prompt": "please write a java function , the function signature as below import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * Applies a shear transformation to a 2D matrix along the x-axis.\n *\n * @param matrix       the 2D real matrix representing the original matrix.\n * @param shearFactor  the factor by which the matrix is sheared along the x-axis.\n * @return             the sheared matrix.\n */\npublic RealMatrix applyShearX(RealMatrix matrix, double shearFactor) {\n    // Method implementation will go here.\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 471, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "Given an affine transformation matrix, return the corresponding rotation angle in radians.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\ndef get_rotation(matrix:np.array) -> float:\n    \"\"\"\n    Given an affine transformation matrix, return the corresponding rotation angle in radians.\n\n    Args:\n        matrix (np.array): A 2D affine transformation matrix.\n\n    Returns:\n        float: The rotation angle in radians, extracted from the affine matrix.\n    \"\"\"", "test_code": "import numpy as np\nimport unittest\n\n\nclass TestGetRotationFunction(unittest.TestCase):\n\n    def test_rotation_0_degrees(self):\n        \"\"\" Test for a rotation of 0 degrees (identity matrix) \"\"\"\n        matrix = np.array([[1, 0, 0],\n                           [0, 1, 0],\n                           [0, 0, 1]])\n        expected_rotation = 0.0\n        self.assertAlmostEqual(get_rotation(matrix), expected_rotation, places=6)\n\n    def test_rotation_90_degrees(self):\n        \"\"\" Test for a rotation of 90 degrees \"\"\"\n        matrix = np.array([[0, -1, 0],\n                           [1, 0, 0],\n                           [0, 0, 1]])\n        expected_rotation = np.pi / 2  # 90 degrees in radians\n        self.assertAlmostEqual(get_rotation(matrix), expected_rotation, places=6)\n\n    def test_rotation_180_degrees(self):\n        \"\"\" Test for a rotation of 180 degrees \"\"\"\n        matrix = np.array([[-1, 0, 0],\n                           [0, -1, 0],\n                           [0, 0, 1]])\n        expected_rotation = np.pi  # 180 degrees in radians\n        self.assertAlmostEqual(get_rotation(matrix), expected_rotation, places=6)\n\n    def test_rotation_negative_90_degrees(self):\n        \"\"\" Test for a rotation of -90 degrees \"\"\"\n        matrix = np.array([[0, 1, 0],\n                           [-1, 0, 0],\n                           [0, 0, 1]])\n        expected_rotation = -np.pi / 2  # -90 degrees in radians\n        self.assertAlmostEqual(get_rotation(matrix), expected_rotation, places=6)\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\ndef get_rotation(matrix:np.array) -> float:\n    \"\"\"\n    Given an affine transformation matrix, return the corresponding rotation angle in radians.\n\n    Args:\n        matrix (np.array): A 2D affine transformation matrix.\n\n    Returns:\n        float: The rotation angle in radians, extracted from the affine matrix.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Given an affine transformation matrix, return the corresponding rotation angle in radians.\n *\n * @param {Array<Array<number>>} matrix - A 2D affine transformation matrix.\n * @returns {number} The rotation angle in radians, extracted from the affine matrix.\n */\nfunction getRotation(matrix) {}", "test_code": "const assert = require('assert');\n\ndescribe('TestGetRotationFunction', () => {\n    it('test_rotation_0_degrees', () => {\n        // Test for a rotation of 0 degrees (identity matrix)\n        const matrix = [\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ];\n        const expectedRotation = 0.0;\n        expect(getRotation(matrix)).toBeCloseTo(expectedRotation, 6);\n    });\n\n    it('test_rotation_90_degrees', () => {\n        // Test for a rotation of 90 degrees\n        const matrix = [\n            [0, -1, 0],\n            [1, 0, 0],\n            [0, 0, 1]\n        ];\n        const expectedRotation = Math.PI / 2;  // 90 degrees in radians\n        expect(getRotation(matrix)).toBeCloseTo(expectedRotation, 6);\n    });\n\n    it('test_rotation_180_degrees', () => {\n        // Test for a rotation of 180 degrees\n        const matrix = [\n            [-1, 0, 0],\n            [0, -1, 0],\n            [0, 0, 1]\n        ];\n        const expectedRotation = Math.PI;  // 180 degrees in radians\n        expect(getRotation(matrix)).toBeCloseTo(expectedRotation, 6);\n    });\n\n    it('test_rotation_negative_90_degrees', () => {\n        // Test for a rotation of -90 degrees\n        const matrix = [\n            [0, 1, 0],\n            [-1, 0, 0],\n            [0, 0, 1]\n        ];\n        const expectedRotation = -Math.PI / 2;  // -90 degrees in radians\n        expect(getRotation(matrix)).toBeCloseTo(expectedRotation, 6);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Given an affine transformation matrix, return the corresponding rotation angle in radians.\n *\n * @param {Array<Array<number>>} matrix - A 2D affine transformation matrix.\n * @returns {number} The rotation angle in radians, extracted from the affine matrix.\n */\nfunction getRotation(matrix) {}", "addition_info": ""}, "typescript": {"code_signature": "import * as math from 'mathjs';\n\n/**\n * Given an affine transformation matrix, return the corresponding rotation angle in radians.\n *\n * @param matrix - A 2D affine transformation matrix.\n * @returns The rotation angle in radians, extracted from the affine matrix.\n */\nfunction getRotation(matrix: number[][]): number {}", "test_code": "import * as math from 'mathjs';\n\ndescribe('TestGetRotationFunction', () => {\n    it('test_rotation_0_degrees', () => {\n        const matrix = [\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ];\n        const expectedRotation = 0.0;\n        expect(getRotation(matrix)).toBeCloseTo(expectedRotation, 6);\n    });\n\n    it('test_rotation_90_degrees', () => {\n        const matrix = [\n            [0, -1, 0],\n            [1, 0, 0],\n            [0, 0, 1]\n        ];\n        const expectedRotation = math.PI / 2; // 90 degrees in radians\n        expect(getRotation(matrix)).toBeCloseTo(expectedRotation, 6);\n    });\n\n    it('test_rotation_180_degrees', () => {\n        const matrix = [\n            [-1, 0, 0],\n            [0, -1, 0],\n            [0, 0, 1]\n        ];\n        const expectedRotation = math.PI; // 180 degrees in radians\n        expect(getRotation(matrix)).toBeCloseTo(expectedRotation, 6);\n    });\n\n    it('test_rotation_negative_90_degrees', () => {\n        const matrix = [\n            [0, 1, 0],\n            [-1, 0, 0],\n            [0, 0, 1]\n        ];\n        const expectedRotation = -math.PI / 2; // -90 degrees in radians\n        expect(getRotation(matrix)).toBeCloseTo(expectedRotation, 6);\n    });\n});", "prompt": "please write a typescript function , the function signature as below import * as math from 'mathjs';\n\n/**\n * Given an affine transformation matrix, return the corresponding rotation angle in radians.\n *\n * @param matrix - A 2D affine transformation matrix.\n * @returns The rotation angle in radians, extracted from the affine matrix.\n */\nfunction getRotation(matrix: number[][]): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <Eigen/Dense>\n\n/**\n * @brief Extracts the rotation angle from a 2D affine transformation matrix.\n *\n * @param matrix A 2x3 Eigen::Matrix representing a 2D affine transformation matrix.\n * @return double The rotation angle in radians, extracted from the affine matrix.\n */\ndouble get_rotation(const Eigen::Matrix2d& matrix);\n", "test_code": "TEST_CASE(\"TestGetRotationFunction\", \"[rotation]\") {\n    SECTION(\"test_rotation_0_degrees\") {\n        // Test for a rotation of 0 degrees (identity matrix)\n        Eigen::Matrix3d matrix;\n        matrix << 1, 0, 0,\n                  0, 1, 0,\n                  0, 0, 1;\n        double expected_rotation = 0.0;\n        REQUIRE(std::abs(get_rotation(matrix) - expected_rotation) < 1e-6);\n    }\n\n    SECTION(\"test_rotation_90_degrees\") {\n        // Test for a rotation of 90 degrees\n        Eigen::Matrix3d matrix;\n        matrix << 0, -1, 0,\n                  1, 0, 0,\n                  0, 0, 1;\n        double expected_rotation = M_PI / 2;  // 90 degrees in radians\n        REQUIRE(std::abs(get_rotation(matrix) - expected_rotation) < 1e-6);\n    }\n\n    SECTION(\"test_rotation_180_degrees\") {\n        // Test for a rotation of 180 degrees\n        Eigen::Matrix3d matrix;\n        matrix << -1, 0, 0,\n                  0, -1, 0,\n                  0, 0, 1;\n        double expected_rotation = M_PI;  // 180 degrees in radians\n        REQUIRE(std::abs(get_rotation(matrix) - expected_rotation) < 1e-6);\n    }\n\n    SECTION(\"test_rotation_negative_90_degrees\") {\n        // Test for a rotation of -90 degrees\n        Eigen::Matrix3d matrix;\n        matrix << 0, 1, 0,\n                  -1, 0, 0,\n                  0, 0, 1;\n        double expected_rotation = -M_PI / 2;  // -90 degrees in radians\n        REQUIRE(std::abs(get_rotation(matrix) - expected_rotation) < 1e-6);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <Eigen/Dense>\n\n/**\n * @brief Extracts the rotation angle from a 2D affine transformation matrix.\n *\n * @param matrix A 2x3 Eigen::Matrix representing a 2D affine transformation matrix.\n * @return double The rotation angle in radians, extracted from the affine matrix.\n */\ndouble get_rotation(const Eigen::Matrix2d& matrix);\n", "addition_info": ""}, "java": {"code_signature": "import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * Given an affine transformation matrix, return the corresponding rotation angle in radians.\n *\n * @param matrix The 2D affine transformation matrix.\n * @return The rotation angle in radians, extracted from the affine matrix.\n */\npublic static double getRotation(RealMatrix matrix) {\n    // Method implementation goes here\n}", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.Test;\n\npublic class Tester {\n\n    @Test\n    public void testGetRotation() {\n        // Assuming we have a way to create a rotation matrix and expected result\n        double[][] matrix = { {Math.cos(Math.PI / 4), -Math.sin(Math.PI / 4), 0},\n                              {Math.sin(Math.PI / 4), Math.cos(Math.PI / 4), 0},\n                              {0, 0, 1} };\n        double expectedResult = Math.PI / 4;\n\n        double actualResult = getRotation(np.array(matrix));\n\n        assertEquals(expectedResult, actualResult, 0.0001);\n    }\n\n    private double getRotation(double[][] matrix) {\n        /*\n         * Implement the logic to extract the rotation angle from the given matrix.\n         * This is just a placeholder implementation.\n         */\n        double cosTheta = matrix[0][0];\n        double sinTheta = matrix[1][0];\n        return Math.atan2(sinTheta, cosTheta);\n    }\n}\n", "prompt": "please write a java function , the function signature as below import org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * Given an affine transformation matrix, return the corresponding rotation angle in radians.\n *\n * @param matrix The 2D affine transformation matrix.\n * @return The rotation angle in radians, extracted from the affine matrix.\n */\npublic static double getRotation(RealMatrix matrix) {\n    // Method implementation goes here\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 474, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Given a binary tree array, determine whether the given two values are sibling nodes", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef are_siblings(tree:List[int], val1:int, val2:int):\n    \"\"\"\n    Determines if two values are siblings in a binary tree represented as an array.\n\n    Args:\n        tree(List[int]): the binary tree level-order representation\n        val1(int):\n        val2(int):\n\n    Returns:\n\n    \"\"\"\n\n    \"\"\"\n    Determines if two values are siblings in a binary tree represented as an array.\n\n    :param tree: List[int], the binary tree level-order representation\n    :param val1: int, first value to check for sibling relationship\n    :param val2: int, second value to check for sibling relationship\n    :return: bool, True if val1 and val2 are siblings, False otherwise\n    \"\"\"", "test_code": "import unittest\n\nclass TestAreSiblings(unittest.TestCase):\n    def setUp(self):\n        # Setting up a binary tree used for all the test cases\n        self.tree = [1, 2, 3, 4, 5, 6, 7]\n\n    def test_basic_case(self):\n        # Test with nodes 4 and 5, which are siblings\n        result = are_siblings(self.tree, 4, 5)\n        self.assertTrue(result)\n\n    def test_non_sibling_case(self):\n        # Test with nodes 4 and 6, which are not siblings\n        result = are_siblings(self.tree, 4, 6)\n        self.assertFalse(result)\n\n    def test_root_node_case(self):\n        # Test with node 1 (root) and any other node, should return False\n        result = are_siblings(self.tree, 1, 2)\n        self.assertFalse(result)\n\n    def test_non_existent_values(self):\n        # Test with non-existent values\n        result = are_siblings(self.tree, 8, 9)\n        self.assertFalse(result)\n\n    def test_same_node_case(self):\n        # Test with the same node for both values\n        result = are_siblings(self.tree, 4, 4)\n        self.assertFalse(result)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef are_siblings(tree:List[int], val1:int, val2:int):\n    \"\"\"\n    Determines if two values are siblings in a binary tree represented as an array.\n\n    Args:\n        tree(List[int]): the binary tree level-order representation\n        val1(int):\n        val2(int):\n\n    Returns:\n\n    \"\"\"\n\n    \"\"\"\n    Determines if two values are siblings in a binary tree represented as an array.\n\n    :param tree: List[int], the binary tree level-order representation\n    :param val1: int, first value to check for sibling relationship\n    :param val2: int, second value to check for sibling relationship\n    :return: bool, True if val1 and val2 are siblings, False otherwise\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Determines if two values are siblings in a binary tree represented as an array.\n *\n * @param {Array<number>} tree - the binary tree level-order representation\n * @param {number} val1 - the first value to check for sibling relationship\n * @param {number} val2 - the second value to check for sibling relationship\n * @returns {boolean} - true if val1 and val2 are siblings, false otherwise\n */\nfunction areSiblings(tree, val1, val2) {}", "test_code": "describe('TestAreSiblings', () => {\n  let tree;\n\n  beforeEach(() => {\n      // Setting up a binary tree used for all the test cases\n      tree = [1, 2, 3, 4, 5, 6, 7];\n  });\n\n  it('test with nodes 4 and 5, which are siblings', () => {\n      const result = areSiblings(tree, 4, 5);\n      expect(result).toBe(true);\n  });\n\n  it('test with nodes 4 and 6, which are not siblings', () => {\n      const result = areSiblings(tree, 4, 6);\n      expect(result).toBe(false);\n  });\n\n  it('test with node 1 (root) and any other node, should return false', () => {\n      const result = areSiblings(tree, 1, 2);\n      expect(result).toBe(false);\n  });\n\n  it('test with non-existent values', () => {\n      const result = areSiblings(tree, 8, 9);\n      expect(result).toBe(false);\n  });\n\n  it('test with the same node for both values', () => {\n      const result = areSiblings(tree, 4, 4);\n      expect(result).toBe(false);\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Determines if two values are siblings in a binary tree represented as an array.\n *\n * @param {Array<number>} tree - the binary tree level-order representation\n * @param {number} val1 - the first value to check for sibling relationship\n * @param {number} val2 - the second value to check for sibling relationship\n * @returns {boolean} - true if val1 and val2 are siblings, false otherwise\n */\nfunction areSiblings(tree, val1, val2) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Determines if two values are siblings in a binary tree represented as an array.\n *\n * @param tree - The binary tree level-order representation.\n * @param val1 - The first value to check for sibling relationship.\n * @param val2 - The second value to check for sibling relationship.\n * @returns True if val1 and val2 are siblings, False otherwise.\n */\nfunction areSiblings(tree: number[], val1: number, val2: number): boolean {}", "test_code": "describe('TestAreSiblings', () => {\n    let tree: number[];\n\n    beforeEach(() => {\n        // Setting up a binary tree used for all the test cases\n        tree = [1, 2, 3, 4, 5, 6, 7];\n    });\n\n    it('should return true for siblings', () => {\n        // Test with nodes 4 and 5, which are siblings\n        const result = areSiblings(tree, 4, 5);\n        expect(result).toBe(true);\n    });\n\n    it('should return false for non-siblings', () => {\n        // Test with nodes 4 and 6, which are not siblings\n        const result = areSiblings(tree, 4, 6);\n        expect(result).toBe(false);\n    });\n\n    it('should return false for root node and another node', () => {\n        // Test with node 1 (root) and any other node, should return False\n        const result = areSiblings(tree, 1, 2);\n        expect(result).toBe(false);\n    });\n\n    it('should return false for non-existent values', () => {\n        // Test with non-existent values\n        const result = areSiblings(tree, 8, 9);\n        expect(result).toBe(false);\n    });\n\n    it('should return false for the same node', () => {\n        // Test with the same node for both values\n        const result = areSiblings(tree, 4, 4);\n        expect(result).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Determines if two values are siblings in a binary tree represented as an array.\n *\n * @param tree - The binary tree level-order representation.\n * @param val1 - The first value to check for sibling relationship.\n * @param val2 - The second value to check for sibling relationship.\n * @returns True if val1 and val2 are siblings, False otherwise.\n */\nfunction areSiblings(tree: number[], val1: number, val2: number): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <vector>\n\n/**\n * @brief Determines if two values are siblings in a binary tree represented as an array.\n *\n * @param tree std::vector<int>, the binary tree level-order representation\n * @param val1 int, first value to check for sibling relationship\n * @param val2 int, second value to check for sibling relationship\n * @return bool, true if val1 and val2 are siblings, false otherwise\n */\nbool are_siblings(const std::vector<int>& tree, int val1, int val2);\n", "test_code": "TEST_CASE(\"TestAreSiblings\", \"[are_siblings]\") {\n    const std::vector<int> tree = {1, 2, 3, 4, 5, 6, 7};\n\n    SECTION(\"test_basic_case\") {\n        // Test with nodes 4 and 5, which are siblings\n        bool result = are_siblings(tree, 4, 5);\n        REQUIRE(result);\n    }\n\n    SECTION(\"test_non_sibling_case\") {\n        // Test with nodes 4 and 6, which are not siblings\n        bool result = are_siblings(tree, 4, 6);\n        REQUIRE_FALSE(result);\n    }\n\n    SECTION(\"test_root_node_case\") {\n        // Test with node 1 (root) and any other node, should return False\n        bool result = are_siblings(tree, 1, 2);\n        REQUIRE_FALSE(result);\n    }\n\n    SECTION(\"test_non_existent_values\") {\n        // Test with non-existent values\n        bool result = are_siblings(tree, 8, 9);\n        REQUIRE_FALSE(result);\n    }\n\n    SECTION(\"test_same_node_case\") {\n        // Test with the same node for both values\n        bool result = are_siblings(tree, 4, 4);\n        REQUIRE_FALSE(result);\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <vector>\n\n/**\n * @brief Determines if two values are siblings in a binary tree represented as an array.\n *\n * @param tree std::vector<int>, the binary tree level-order representation\n * @param val1 int, first value to check for sibling relationship\n * @param val2 int, second value to check for sibling relationship\n * @return bool, true if val1 and val2 are siblings, false otherwise\n */\nbool are_siblings(const std::vector<int>& tree, int val1, int val2);\n", "addition_info": ""}, "java": {"code_signature": "import java.util.List;\n\npublic class BinaryTree {\n\n    /**\n     * Determines if two values are siblings in a binary tree represented as an array.\n     *\n     * @param tree the binary tree level-order representation\n     * @param val1 the first value to check for sibling relationship\n     * @param val2 the second value to check for sibling relationship\n     * @return true if val1 and val2 are siblings, false otherwise\n     */\n    public static boolean areSiblings(List<Integer> tree, int val1, int val2) {\n        // Method implementation will go here\n        return false; // Placeholder return statement\n    }\n}\n", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testAreSiblings() {\n        // Test data for a binary tree represented as an array\n        int[] tree = {1, 2, 3, 4, 5, 6, 7};\n\n        // Test cases\n        assertTrue(areSiblings(tree, 4, 5)); // 4 and 5 are siblings\n        assertFalse(areSiblings(tree, 2, 3)); // 2 and 3 are not siblings\n        assertFalse(areSiblings(tree, 4, 7)); // 4 and 7 are not siblings\n        assertFalse(areSiblings(tree, 8, 9)); // 8 and 9 do not exist in the tree\n    }\n\n    private boolean areSiblings(int[] tree, int val1, int val2) {\n        int n = tree.length;\n\n        // Find parent of val1\n        int i = 0;\n        while (i < n && tree[i] != val1) {\n            i++;\n        }\n        int parentVal1 = -1;\n        if (i < n) {\n            parentVal1 = tree[(i - 1) / 2];\n        }\n\n        // Find parent of val2\n        i = 0;\n        while (i < n && tree[i] != val2) {\n            i++;\n        }\n        int parentVal2 = -1;\n        if (i < n) {\n            parentVal2 = tree[(i - 1) / 2];\n        }\n\n        // Check if both nodes have the same parent\n        return parentVal1 == parentVal2 && parentVal1 != -1;\n    }\n}\n", "prompt": "please write a java function , the function signature as below import java.util.List;\n\npublic class BinaryTree {\n\n    /**\n     * Determines if two values are siblings in a binary tree represented as an array.\n     *\n     * @param tree the binary tree level-order representation\n     * @param val1 the first value to check for sibling relationship\n     * @param val2 the second value to check for sibling relationship\n     * @return true if val1 and val2 are siblings, false otherwise\n     */\n    public static boolean areSiblings(List<Integer> tree, int val1, int val2) {\n        // Method implementation will go here\n        return false; // Placeholder return statement\n    }\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 475, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "    Safely formats a template string by replacing placeholders with corresponding values\n    from the provided keyword arguments. If a placeholder does not have a corresponding\n    value in kwargs, it remains unchanged.", "language_version_list": {"python": {"code_signature": "def safe_format(template, **kwargs):\n    \"\"\"\n    Safely formats a template string by replacing placeholders with corresponding values\n    from the provided keyword arguments. If a placeholder does not have a corresponding\n    value in kwargs, it remains unchanged.\n\n    Args:\n        template (str): The string template containing placeholders in the form {key}.\n        **kwargs: Keyword arguments that map keys to their replacement values.\n\n    Returns:\n        str: The formatted string with placeholders replaced by values.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestSafeFormat(unittest.TestCase):\n\n    def test_full_replacement(self):\n        \"\"\"Test with all placeholders having corresponding values.\"\"\"\n        template = \"Hello, {name}! Welcome to {place}.\"\n        result = safe_format(template, name=\"Alice\", place=\"Wonderland\")\n        expected = \"Hello, Alice! Welcome to Wonderland.\"\n        self.assertEqual(result, expected)\n\n    def test_partial_replacement(self):\n        \"\"\"Test with some placeholders missing corresponding values.\"\"\"\n        template = \"Hello, {name}! Welcome to {place}.\"\n        result = safe_format(template, name=\"Alice\")\n        expected = \"Hello, Alice! Welcome to {place}.\"\n        self.assertEqual(result, expected)\n\n    def test_no_replacement(self):\n        \"\"\"Test when no placeholders are provided.\"\"\"\n        template = \"Hello, world!\"\n        result = safe_format(template)\n        expected = \"Hello, world!\"\n        self.assertEqual(result, expected)\n\n    def test_missing_placeholder(self):\n        \"\"\"Test with a placeholder that has no corresponding value.\"\"\"\n        template = \"My name is {name}, and I live in {city}.\"\n        result = safe_format(template, name=\"Alice\")\n        expected = \"My name is Alice, and I live in {city}.\"\n        self.assertEqual(result, expected)\n\n    def test_numeric_values(self):\n        \"\"\"Test with numeric values as replacements.\"\"\"\n        template = \"Your score is {score} out of {total}.\"\n        result = safe_format(template, score=85, total=100)\n        expected = \"Your score is 85 out of 100.\"\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def safe_format(template, **kwargs):\n    \"\"\"\n    Safely formats a template string by replacing placeholders with corresponding values\n    from the provided keyword arguments. If a placeholder does not have a corresponding\n    value in kwargs, it remains unchanged.\n\n    Args:\n        template (str): The string template containing placeholders in the form {key}.\n        **kwargs: Keyword arguments that map keys to their replacement values.\n\n    Returns:\n        str: The formatted string with placeholders replaced by values.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Safely formats a template string by replacing placeholders with corresponding values\n * from the provided keyword arguments. If a placeholder does not have a corresponding\n * value in kwargs, it remains unchanged.\n *\n * @param {string} template - The string template containing placeholders in the form {key}.\n * @param {Object} [kwargs] - Keyword arguments that map keys to their replacement values.\n * @returns {string} The formatted string with placeholders replaced by values.\n */\nfunction safeFormat(template, ...kwargs) {}", "test_code": "describe('TestSafeFormat', () => {\n  describe('test_full_replacement', () => {\n      it('should fully replace all placeholders with corresponding values', () => {\n          const template = \"Hello, {name}! Welcome to {place}.\";\n          const result = safeFormat(template, { name: \"Alice\", place: \"Wonderland\" });\n          const expected = \"Hello, Alice! Welcome to Wonderland.\";\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_partial_replacement', () => {\n      it('should partially replace placeholders with corresponding values', () => {\n          const template = \"Hello, {name}! Welcome to {place}.\";\n          const result = safeFormat(template, { name: \"Alice\" });\n          const expected = \"Hello, Alice! Welcome to {place}.\";\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_no_replacement', () => {\n      it('should not replace any placeholders when none are provided', () => {\n          const template = \"Hello, world!\";\n          const result = safeFormat(template);\n          const expected = \"Hello, world!\";\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_missing_placeholder', () => {\n      it('should leave placeholders unchanged when a value is missing', () => {\n          const template = \"My name is {name}, and I live in {city}.\";\n          const result = safeFormat(template, { name: \"Alice\" });\n          const expected = \"My name is Alice, and I live in {city}.\";\n          expect(result).toEqual(expected);\n      });\n  });\n\n  describe('test_numeric_values', () => {\n      it('should handle numeric values correctly', () => {\n          const template = \"Your score is {score} out of {total}.\";\n          const result = safeFormat(template, { score: 85, total: 100 });\n          const expected = \"Your score is 85 out of 100.\";\n          expect(result).toEqual(expected);\n      });\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Safely formats a template string by replacing placeholders with corresponding values\n * from the provided keyword arguments. If a placeholder does not have a corresponding\n * value in kwargs, it remains unchanged.\n *\n * @param {string} template - The string template containing placeholders in the form {key}.\n * @param {Object} [kwargs] - Keyword arguments that map keys to their replacement values.\n * @returns {string} The formatted string with placeholders replaced by values.\n */\nfunction safeFormat(template, ...kwargs) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Safely formats a template string by replacing placeholders with corresponding values\n * from the provided keyword arguments. If a placeholder does not have a corresponding\n * value in kwargs, it remains unchanged.\n *\n * @param template - The string template containing placeholders in the form {key}.\n * @param kwargs - Keyword arguments that map keys to their replacement values.\n * @returns The formatted string with placeholders replaced by values.\n */\nfunction safeFormat(template: string, ...kwargs: [string, any][]): string {}", "test_code": "describe('TestSafeFormat', () => {\n    it('test_full_replacement', () => {\n        // Test with all placeholders having corresponding values.\n        const template = \"Hello, {name}! Welcome to {place}.\";\n        const result = safeFormat(template, ['name', 'Alice'], ['place', 'Wonderland']);\n        const expected = \"Hello, Alice! Welcome to Wonderland.\";\n        expect(result).toEqual(expected);\n    });\n\n    it('test_partial_replacement', () => {\n        // Test with some placeholders missing corresponding values.\n        const template = \"Hello, {name}! Welcome to {place}.\";\n        const result = safeFormat(template, ['name', 'Alice']);\n        const expected = \"Hello, Alice! Welcome to {place}.\";\n        expect(result).toEqual(expected);\n    });\n\n    it('test_no_replacement', () => {\n        // Test when no placeholders are provided.\n        const template = \"Hello, world!\";\n        const result = safeFormat(template);\n        const expected = \"Hello, world!\";\n        expect(result).toEqual(expected);\n    });\n\n    it('test_missing_placeholder', () => {\n        // Test with a placeholder that has no corresponding value.\n        const template = \"My name is {name}, and I live in {city}.\";\n        const result = safeFormat(template, ['name', 'Alice']);\n        const expected = \"My name is Alice, and I live in {city}.\";\n        expect(result).toEqual(expected);\n    });\n\n    it('test_numeric_values', () => {\n        // Test with numeric values as replacements.\n        const template = \"Your score is {score} out of {total}.\";\n        const result = safeFormat(template, ['score', 85], ['total', 100]);\n        const expected = \"Your score is 85 out of 100.\";\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Safely formats a template string by replacing placeholders with corresponding values\n * from the provided keyword arguments. If a placeholder does not have a corresponding\n * value in kwargs, it remains unchanged.\n *\n * @param template - The string template containing placeholders in the form {key}.\n * @param kwargs - Keyword arguments that map keys to their replacement values.\n * @returns The formatted string with placeholders replaced by values.\n */\nfunction safeFormat(template: string, ...kwargs: [string, any][]): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Safely formats a template string by replacing placeholders with corresponding values\n * from the provided keyword arguments. If a placeholder does not have a corresponding\n * value in kwargs, it remains unchanged.\n *\n * @param template_str The string template containing placeholders in the form {key}.\n * @param kwargs A map of keys to their replacement values.\n * @return std::string The formatted string with placeholders replaced by values.\n */\nstd::string safe_format(const std::string& template_str, const std::unordered_map<std::string, std::string>& kwargs);\n", "test_code": "TEST_CASE(\"TestSafeFormat\", \"[safe_format]\") {\n    SECTION(\"test_full_replacement\") {\n        // Test with all placeholders having corresponding values.\n        std::string template_str = \"Hello, {name}! Welcome to {place}.\";\n        std::unordered_map<std::string, std::string> kwargs = {\n            {\"name\", \"Alice\"},\n            {\"place\", \"Wonderland\"}\n        };\n        std::string result = safe_format(template_str, kwargs);\n        std::string expected = \"Hello, Alice! Welcome to Wonderland.\";\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_partial_replacement\") {\n        // Test with some placeholders missing corresponding values.\n        std::string template_str = \"Hello, {name}! Welcome to {place}.\";\n        std::unordered_map<std::string, std::string> kwargs = {\n            {\"name\", \"Alice\"}\n        };\n        std::string result = safe_format(template_str, kwargs);\n        std::string expected = \"Hello, Alice! Welcome to {place}.\";\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_no_replacement\") {\n        // Test when no placeholders are provided.\n        std::string template_str = \"Hello, world!\";\n        std::unordered_map<std::string, std::string> kwargs;\n        std::string result = safe_format(template_str, kwargs);\n        std::string expected = \"Hello, world!\";\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_missing_placeholder\") {\n        // Test with a placeholder that has no corresponding value.\n        std::string template_str = \"My name is {name}, and I live in {city}.\";\n        std::unordered_map<std::string, std::string> kwargs = {\n            {\"name\", \"Alice\"}\n        };\n        std::string result = safe_format(template_str, kwargs);\n        std::string expected = \"My name is Alice, and I live in {city}.\";\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_numeric_values\") {\n        // Test with numeric values as replacements.\n        std::string template_str = \"Your score is {score} out of {total}.\";\n        std::unordered_map<std::string, std::string> kwargs = {\n            {\"score\", \"85\"},\n            {\"total\", \"100\"}\n        };\n        std::string result = safe_format(template_str, kwargs);\n        std::string expected = \"Your score is 85 out of 100.\";\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Safely formats a template string by replacing placeholders with corresponding values\n * from the provided keyword arguments. If a placeholder does not have a corresponding\n * value in kwargs, it remains unchanged.\n *\n * @param template_str The string template containing placeholders in the form {key}.\n * @param kwargs A map of keys to their replacement values.\n * @return std::string The formatted string with placeholders replaced by values.\n */\nstd::string safe_format(const std::string& template_str, const std::unordered_map<std::string, std::string>& kwargs);\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Safely formats a template string by replacing placeholders with corresponding values\n * from the provided keyword arguments. If a placeholder does not have a corresponding\n * value in kwargs, it remains unchanged.\n *\n * @param template The string template containing placeholders in the form {key}.\n * @param kwargs   Keyword arguments that map keys to their replacement values.\n * @return The formatted string with placeholders replaced by values.\n */\npublic static String safeFormat(String template, Map<String, Object> kwargs) {\n", "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    /**\n     * Safely formats a template string by replacing placeholders with corresponding values\n     * from the provided keyword arguments. If a placeholder does not have a corresponding\n     * value in kwargs, it remains unchanged.\n     *\n     * @param template The string template containing placeholders in the form {key}.\n     * @param args Keyword arguments that map keys to their replacement values.\n     * @return The formatted string with placeholders replaced by values.\n     */\n    public String safeFormat(String template, Object... args) {\n        for (Object arg : args) {\n            if (arg instanceof String && ((String) arg).startsWith(\"{\") && ((String) arg).endsWith(\"}\")) {\n                String key = ((String) arg).substring(1, ((String) arg).length() - 1);\n                int index = template.indexOf(arg);\n                while (index != -1) {\n                    if (index + arg.length() < template.length() && Character.isLetterOrDigit(template.charAt(index + arg.length()))) {\n                        // Skip if the next character is a letter or digit to avoid partial matches\n                        index = template.indexOf(arg, index + arg.length());\n                    } else {\n                        template = template.substring(0, index) + args[index / 2] + template.substring(index + arg.length());\n                        index += args[index / 2].toString().length();\n                    }\n                }\n            }\n        }\n        return template;\n    }\n\n    @Test\n    public void testSafeFormat() {\n        assertEquals(\"Hello, John!\", safeFormat(\"Hello, {name}!\", \"John\"));\n        assertEquals(\"The answer is {answer}.\", safeFormat(\"The answer is {answer}.\", \"42\"));\n        assertEquals(\"No replacements here.\", safeFormat(\"No replacements here.\"));\n        assertEquals(\"Keep {unchanged} unchanged.\", safeFormat(\"Keep {unchanged} unchanged.\"));\n        assertEquals(\"Replace {first}, keep {second}.\", safeFormat(\"Replace {first}, keep {second}.\", \"first\"));\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Safely formats a template string by replacing placeholders with corresponding values\n * from the provided keyword arguments. If a placeholder does not have a corresponding\n * value in kwargs, it remains unchanged.\n *\n * @param template The string template containing placeholders in the form {key}.\n * @param kwargs   Keyword arguments that map keys to their replacement values.\n * @return The formatted string with placeholders replaced by values.\n */\npublic static String safeFormat(String template, Map<String, Object> kwargs) {\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 476, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "achieve topological sorting, based on depth priority search", "language_version_list": {"python": {"code_signature": "from typing import List, Tuple\n\n\ndef topological_sort_dfs(vertices: List[int], edges: List[Tuple]) -> List:\n    \"\"\"\n    achieve topological sorting, based on depth priority search\n\n    Args:\n        vertices (List[int]): A list of vertices in the graph. Each vertex should be a unique integer.\n        edges (List[Tuple[int, int]]): A list of tuples where each tuple represents a directed edge\n                                       in the graph and is formed as (start_vertex, end_vertex).\n\n    Returns:\n        List[int]: A list of vertices in topological order. If the graph contains a cycle,\n                   and thus cannot have a valid topological ordering, an empty list is returned.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestTopologicalSortDFS(unittest.TestCase):\n    def test_simple_chain(self):\n        vertices = [1, 2, 3]\n        edges = [(1, 2), (2, 3)]\n        self.assertEqual(topological_sort_dfs(vertices, edges), [1, 2, 3])\n\n\n    def test_disconnected_graph(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2)]\n        # There are multiple correct answers possible\n        result = topological_sort_dfs(vertices, edges)\n        self.assertTrue(result.index(1) < result.index(2))\n        self.assertTrue(3 in result and 4 in result)\n\n    def test_complex_graph(self):\n        vertices = [1, 2, 3, 4, 5, 6]\n        edges = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (6, 1)]\n        result = topological_sort_dfs(vertices, edges)\n        self.assertTrue(result.index(1) < result.index(2))\n        self.assertTrue(result.index(1) < result.index(3))\n        self.assertTrue(result.index(2) < result.index(4))\n        self.assertTrue(result.index(3) < result.index(4))\n        self.assertTrue(result.index(4) < result.index(5))\n        self.assertTrue(result.index(6) < result.index(1))\n\n    def test_single_vertex(self):\n        vertices = [1]\n        edges = []\n        self.assertEqual(topological_sort_dfs(vertices, edges), [1])", "prompt": "please write a python function , the function signature as below from typing import List, Tuple\n\n\ndef topological_sort_dfs(vertices: List[int], edges: List[Tuple]) -> List:\n    \"\"\"\n    achieve topological sorting, based on depth priority search\n\n    Args:\n        vertices (List[int]): A list of vertices in the graph. Each vertex should be a unique integer.\n        edges (List[Tuple[int, int]]): A list of tuples where each tuple represents a directed edge\n                                       in the graph and is formed as (start_vertex, end_vertex).\n\n    Returns:\n        List[int]: A list of vertices in topological order. If the graph contains a cycle,\n                   and thus cannot have a valid topological ordering, an empty list is returned.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Achieves topological sorting based on depth-first search (DFS).\n *\n * @param {Array<number>} vertices - A list of vertices in the graph. Each vertex should be a unique integer.\n * @param {Array<[number, number]>} edges - A list of tuples where each tuple represents a directed edge\n *                                          in the graph and is formed as [start_vertex, end_vertex].\n * @returns {Array<number>} - A list of vertices in topological order. If the graph contains a cycle,\n *                            and thus cannot have a valid topological ordering, an empty array is returned.\n */\nfunction topologicalSortDFS(vertices, edges) {}", "test_code": "describe('TestTopologicalSortDFS', () => {\n    describe('test_simple_chain', () => {\n        it('should sort a simple chain correctly', () => {\n            const vertices = [1, 2, 3];\n            const edges = [[1, 2], [2, 3]];\n            expect(topologicalSortDFS(vertices, edges)).toEqual([1, 2, 3]);\n        });\n    });\n\n    describe('test_disconnected_graph', () => {\n        it('should handle a disconnected graph correctly', () => {\n            const vertices = [1, 2, 3, 4];\n            const edges = [[1, 2]];\n            const result = topologicalSortDFS(vertices, edges);\n\n            expect(result.indexOf(1)).toBeLessThan(result.indexOf(2));\n            expect(result.includes(3) && result.includes(4)).toBeTruthy();\n        });\n    });\n\n    describe('test_complex_graph', () => {\n        it('should handle a complex graph correctly', () => {\n            const vertices = [1, 2, 3, 4, 5, 6];\n            const edges = [[1, 2], [1, 3], [2, 4], [3, 4], [4, 5], [6, 1]];\n            const result = topologicalSortDFS(vertices, edges);\n\n            expect(result.indexOf(1)).toBeLessThan(result.indexOf(2));\n            expect(result.indexOf(1)).toBeLessThan(result.indexOf(3));\n            expect(result.indexOf(2)).toBeLessThan(result.indexOf(4));\n            expect(result.indexOf(3)).toBeLessThan(result.indexOf(4));\n            expect(result.indexOf(4)).toBeLessThan(result.indexOf(5));\n            expect(result.indexOf(6)).toBeLessThan(result.indexOf(1));\n        });\n    });\n\n    describe('test_single_vertex', () => {\n        it('should handle a single vertex correctly', () => {\n            const vertices = [1];\n            const edges = [];\n            expect(topologicalSortDFS(vertices, edges)).toEqual([1]);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Achieves topological sorting based on depth-first search (DFS).\n *\n * @param {Array<number>} vertices - A list of vertices in the graph. Each vertex should be a unique integer.\n * @param {Array<[number, number]>} edges - A list of tuples where each tuple represents a directed edge\n *                                          in the graph and is formed as [start_vertex, end_vertex].\n * @returns {Array<number>} - A list of vertices in topological order. If the graph contains a cycle,\n *                            and thus cannot have a valid topological ordering, an empty array is returned.\n */\nfunction topologicalSortDFS(vertices, edges) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Achieves topological sorting based on depth-first search.\n *\n * @param vertices - A list of vertices in the graph. Each vertex should be a unique integer.\n * @param edges - A list of tuples where each tuple represents a directed edge in the graph,\n *                formed as (start_vertex, end_vertex).\n * @returns A list of vertices in topological order. If the graph contains a cycle,\n *          and thus cannot have a valid topological ordering, an empty list is returned.\n */\nfunction topologicalSortDFS(vertices: number[], edges: [number, number][]): number[] {}", "test_code": "describe('TestTopologicalSortDFS', () => {\n    it('test_simple_chain', () => {\n        const vertices = [1, 2, 3];\n        const edges = [[1, 2], [2, 3]];\n        expect(topologicalSortDFS(vertices, edges)).toEqual([1, 2, 3]);\n    });\n\n    it('test_disconnected_graph', () => {\n        const vertices = [1, 2, 3, 4];\n        const edges = [[1, 2]];\n        const result = topologicalSortDFS(vertices, edges);\n        expect(result.indexOf(1)).toBeLessThan(result.indexOf(2));\n        expect(result).toContain(3);\n        expect(result).toContain(4);\n    });\n\n    it('test_complex_graph', () => {\n        const vertices = [1, 2, 3, 4, 5, 6];\n        const edges = [\n            [1, 2],\n            [1, 3],\n            [2, 4],\n            [3, 4],\n            [4, 5],\n            [6, 1]\n        ];\n        const result = topologicalSortDFS(vertices, edges);\n        expect(result.indexOf(1)).toBeLessThan(result.indexOf(2));\n        expect(result.indexOf(1)).toBeLessThan(result.indexOf(3));\n        expect(result.indexOf(2)).toBeLessThan(result.indexOf(4));\n        expect(result.indexOf(3)).toBeLessThan(result.indexOf(4));\n        expect(result.indexOf(4)).toBeLessThan(result.indexOf(5));\n        expect(result.indexOf(6)).toBeLessThan(result.indexOf(1));\n    });\n\n    it('test_single_vertex', () => {\n        const vertices = [1];\n        const edges = [];\n        expect(topologicalSortDFS(vertices, edges)).toEqual([1]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Achieves topological sorting based on depth-first search.\n *\n * @param vertices - A list of vertices in the graph. Each vertex should be a unique integer.\n * @param edges - A list of tuples where each tuple represents a directed edge in the graph,\n *                formed as (start_vertex, end_vertex).\n * @returns A list of vertices in topological order. If the graph contains a cycle,\n *          and thus cannot have a valid topological ordering, an empty list is returned.\n */\nfunction topologicalSortDFS(vertices: number[], edges: [number, number][]): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "#include <vector>\n#include <list>\n\n/**\n * @brief Achieve topological sorting, based on depth priority search\n *\n * @param vertices A vector of integers representing the vertices in the graph.\n *                 Each vertex should be a unique integer.\n * @param edges A vector of pairs of integers where each pair represents a directed\n *              edge in the graph and is formed as (start_vertex, end_vertex).\n *\n * @return A vector of integers representing the vertices in topological order.\n *         If the graph contains a cycle, and thus cannot have a valid topological\n *         ordering, an empty vector is returned.\n */\nstd::vector<int> topological_sort_dfs(const std::vector<int>& vertices, const std::vector<std::pair<int, int>>& edges);", "test_code": "TEST_CASE(\"Test topological_sort_dfs\", \"[topological_sort_dfs]\") {\n    SECTION(\"test_simple_chain\") {\n        std::vector<int> vertices = {1, 2, 3};\n        std::vector<std::pair<int, int>> edges = {{1, 2}, {2, 3}};\n        REQUIRE(topological_sort_dfs(vertices, edges) == std::vector<int>({1, 2, 3}));\n    }\n\n    SECTION(\"test_disconnected_graph\") {\n        std::vector<int> vertices = {1, 2, 3, 4};\n        std::vector<std::pair<int, int>> edges = {{1, 2}};\n        auto result = topological_sort_dfs(vertices, edges);\n        REQUIRE(std::find(result.begin(), result.end(), 1) < std::find(result.begin(), result.end(), 2));\n        REQUIRE(std::find(result.begin(), result.end(), 3) != result.end());\n        REQUIRE(std::find(result.begin(), result.end(), 4) != result.end());\n    }\n\n    SECTION(\"test_complex_graph\") {\n        std::vector<int> vertices = {1, 2, 3, 4, 5, 6};\n        std::vector<std::pair<int, int>> edges = {{1, 2}, {1, 3}, {2, 4}, {3, 4}, {4, 5}, {6, 1}};\n        auto result = topological_sort_dfs(vertices, edges);\n        REQUIRE(std::find(result.begin(), result.end(), 1) < std::find(result.begin(), result.end(), 2));\n        REQUIRE(std::find(result.begin(), result.end(), 1) < std::find(result.begin(), result.end(), 3));\n        REQUIRE(std::find(result.begin(), result.end(), 2) < std::find(result.begin(), result.end(), 4));\n        REQUIRE(std::find(result.begin(), result.end(), 3) < std::find(result.begin(), result.end(), 4));\n        REQUIRE(std::find(result.begin(), result.end(), 4) < std::find(result.begin(), result.end(), 5));\n        REQUIRE(std::find(result.begin(), result.end(), 6) < std::find(result.begin(), result.end(), 1));\n    }\n\n    SECTION(\"test_single_vertex\") {\n        std::vector<int> vertices = {1};\n        std::vector<std::pair<int, int>> edges = {};\n        REQUIRE(topological_sort_dfs(vertices, edges) == std::vector<int>({1}));\n    }\n}", "prompt": "please write a cpp function , the function signature as below #include <vector>\n#include <list>\n\n/**\n * @brief Achieve topological sorting, based on depth priority search\n *\n * @param vertices A vector of integers representing the vertices in the graph.\n *                 Each vertex should be a unique integer.\n * @param edges A vector of pairs of integers where each pair represents a directed\n *              edge in the graph and is formed as (start_vertex, end_vertex).\n *\n * @return A vector of integers representing the vertices in topological order.\n *         If the graph contains a cycle, and thus cannot have a valid topological\n *         ordering, an empty vector is returned.\n */\nstd::vector<int> topological_sort_dfs(const std::vector<int>& vertices, const std::vector<std::pair<int, int>>& edges);", "addition_info": ""}, "java": {"code_signature": "import java.util.*;\n\npublic class TopologicalSort {\n\n    /**\n     * Achieve topological sorting, based on depth priority search\n     *\n     * @param vertices A list of vertices in the graph. Each vertex should be a unique integer.\n     * @param edges    A list of tuples where each tuple represents a directed edge\n     *                 in the graph and is formed as (startVertex, endVertex).\n     * @return A list of vertices in topological order. If the graph contains a cycle,\n     *         and thus cannot have a valid topological ordering, an empty list is returned.\n     */\n    public static List<Integer> topologicalSortDFS(List<Integer> vertices, List<List<Integer>> edges) {\n        // Method implementation goes here...\n    }\n}\n", "test_code": "package org.real.temp;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class Tester {\n\n    private TopologicalSort topologicalSort;\n\n    @Before\n    public void setUp() {\n        topologicalSort = new TopologicalSort();\n    }\n\n    @Test\n    public void testTopologicalSortDfs() {\n        List<Integer> vertices = new ArrayList<>();\n        vertices.add(1);\n        vertices.add(2);\n        vertices.add(3);\n        vertices.add(4);\n\n        List<List<Integer>> edges = new ArrayList<>();\n        edges.add(List.of(1, 2));\n        edges.add(List.of(1, 3));\n        edges.add(List.of(2, 4));\n        edges.add(List.of(3, 4));\n\n        List<Integer> result = topologicalSort.topologicalSortDfs(vertices, edges);\n\n        assertTrue(result.size() == vertices.size());\n        assertEquals(List.of(1, 2, 3, 4), result);\n    }\n}\n", "prompt": "please write a java function , the function signature as below import java.util.*;\n\npublic class TopologicalSort {\n\n    /**\n     * Achieve topological sorting, based on depth priority search\n     *\n     * @param vertices A list of vertices in the graph. Each vertex should be a unique integer.\n     * @param edges    A list of tuples where each tuple represents a directed edge\n     *                 in the graph and is formed as (startVertex, endVertex).\n     * @return A list of vertices in topological order. If the graph contains a cycle,\n     *         and thus cannot have a valid topological ordering, an empty list is returned.\n     */\n    public static List<Integer> topologicalSortDFS(List<Integer> vertices, List<List<Integer>> edges) {\n        // Method implementation goes here...\n    }\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 477, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Check if the given object can be treated as a dictionary.", "language_version_list": {"python": {"code_signature": "from typing import Any\n\ndef can_class_to_dict(obj: Any) -> bool:\n    \"\"\"\n    Check if the given object can be treated as a dictionary.\n\n    Args:\n        obj (Any): any type\n\n    Returns:\n        bool: can obj to dict\n    \"\"\"", "test_code": "import unittest\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n\nclass Car:\n    def __init__(self, make: str, model: str):\n        self.make = make\n        self.model = model\n\nclass Dog:\n    def __init__(self, name: str, breed: str):\n        self.name = name\n        self.breed = breed\n        self._age = 5  # Private attribute\n\nclass EmptyClass:\n    pass\n\nclass Student:\n    school_name = \"Example School\"\n\n    def __init__(self, name: str):\n        self.name = name\n        self.grade = \"A\"\n\nclass TestCanClassToDict(unittest.TestCase):\n\n    def test_dataclass(self):\n        person = Person(name=\"Alice\", age=30)\n        self.assertTrue(can_class_to_dict(person))\n\n    def test_regular_class(self):\n        car = Car(make=\"Toyota\", model=\"Corolla\")\n        self.assertTrue(can_class_to_dict(car))\n\n    def test_regular_class_with_private_attribute(self):\n        dog = Dog(name=\"Buddy\", breed=\"Golden Retriever\")\n        self.assertTrue(can_class_to_dict(dog))\n\n    def test_empty_class(self):\n        empty = EmptyClass()\n        self.assertTrue(can_class_to_dict(empty))\n\n    def test_class_with_class_variable(self):\n        student = Student(name=\"John\")\n        self.assertTrue(can_class_to_dict(student))\n\n    def test_non_class_object(self):\n        number = 42\n        self.assertFalse(can_class_to_dict(number))\n", "prompt": "please write a python function , the function signature as below from typing import Any\n\ndef can_class_to_dict(obj: Any) -> bool:\n    \"\"\"\n    Check if the given object can be treated as a dictionary.\n\n    Args:\n        obj (Any): any type\n\n    Returns:\n        bool: can obj to dict\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 478, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Converts a dataclass or class instance to a dictionary.", "language_version_list": {"python": {"code_signature": "from dataclasses import is_dataclass\nfrom typing import Any, Dict\n\n\ndef class_to_dict(obj: Any) -> Dict[str, Any]:\n    \"\"\"\n    Converts a dataclass or class instance to a dictionary.\n\n    Args:\n        obj: An instance of a dataclass or a class.\n\n    Returns:\n        A dictionary representation of the class or dataclass.\n    \"\"\"\n", "test_code": "import unittest\nfrom dataclasses import dataclass\n\n\n# The class_to_dict function should already be defined above.\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n\n\nclass Car:\n    def __init__(self, make: str, model: str):\n        self.make = make\n        self.model = model\n        self.year = 2020\n\n\nclass Dog:\n    def __init__(self, name: str, breed: str):\n        self.name = name\n        self.breed = breed\n        self._age = 5  # Private attribute\n\n\nclass EmptyClass:\n    pass\n\n\nclass Student:\n    school_name = \"Example School\"\n\n    def __init__(self, name: str):\n        self.name = name\n        self.grade = \"A\"\n\n\nclass TestClassToDict(unittest.TestCase):\n\n    def test_dataclass(self):\n        person = Person(name=\"Alice\", age=30)\n        self.assertEqual(class_to_dict(person), {'name': 'Alice', 'age': 30})\n\n    def test_regular_class(self):\n        car = Car(make=\"Toyota\", model=\"Corolla\")\n        self.assertEqual(class_to_dict(car), {'make': 'Toyota', 'model': 'Corolla', 'year': 2020})\n\n    def test_empty_class(self):\n        empty = EmptyClass()\n        self.assertEqual(class_to_dict(empty), {})\n\n    def test_class_with_class_variable(self):\n        student = Student(name=\"John\")\n        self.assertEqual(class_to_dict(student), {'name': 'John', 'grade': 'A'})\n", "prompt": "please write a python function , the function signature as below from dataclasses import is_dataclass\nfrom typing import Any, Dict\n\n\ndef class_to_dict(obj: Any) -> Dict[str, Any]:\n    \"\"\"\n    Converts a dataclass or class instance to a dictionary.\n\n    Args:\n        obj: An instance of a dataclass or a class.\n\n    Returns:\n        A dictionary representation of the class or dataclass.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 482, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Extract the contents of the outermost bracket\n", "language_version_list": {"python": {"code_signature": "def extract_outermost_brackets(s: str) -> str:\n    \"\"\"\n    Extracts the contents of the outermost brackets from the input string.\n    For example:\n        input: Text [with [nested] brackets] and more text\n        output: with [nested] brackets\n    Args:\n        s (str): The input string containing brackets.\n\n    Returns:\n        str: The contents within the outermost brackets, or an empty string if no brackets are found.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestExtractOutermostBrackets(unittest.TestCase):\n    \n    def test_single_parentheses(self):\n        self.assertEqual(extract_outermost_brackets(\"Text (example) more text\"), \"example\")\n\n    def test_nested_brackets(self):\n        self.assertEqual(extract_outermost_brackets(\"Text {with some {nested} brackets}\"), \"with some {nested} brackets\")\n\n    def test_square_brackets(self):\n        self.assertEqual(extract_outermost_brackets(\"Text [with [nested] brackets] and more text\"), \"with [nested] brackets\")\n\n    def test_mixed_bracket_types(self):\n        self.assertEqual(extract_outermost_brackets(\"Mixed (types {of brackets [in use]})\"), \"types {of brackets [in use]}\")\n\n    def test_no_brackets(self):\n        self.assertEqual(extract_outermost_brackets(\"No brackets here\"), \"\")", "prompt": "please write a python function , the function signature as below def extract_outermost_brackets(s: str) -> str:\n    \"\"\"\n    Extracts the contents of the outermost brackets from the input string.\n    For example:\n        input: Text [with [nested] brackets] and more text\n        output: with [nested] brackets\n    Args:\n        s (str): The input string containing brackets.\n\n    Returns:\n        str: The contents within the outermost brackets, or an empty string if no brackets are found.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extracts the contents of the outermost brackets from the input string.\n * For example:\n *   input: \"Text [with [nested] brackets] and more text\"\n *   output: \"with [nested] brackets\"\n * \n * @param {string} s - The input string containing brackets.\n * @returns {string} - The contents within the outermost brackets, or an empty string if no brackets are found.\n */\nfunction extractOutermostBrackets(s) {}", "test_code": "describe('TestExtractOutermostBrackets', () => {\n    it('should extract single parentheses', () => {\n        expect(extractOutermostBrackets(\"Text (example) more text\")).toBe(\"example\");\n    });\n\n    it('should extract nested brackets', () => {\n        expect(extractOutermostBrackets(\"Text {with some {nested} brackets}\")).toBe(\"with some {nested} brackets\");\n    });\n\n    it('should extract square brackets', () => {\n        expect(extractOutermostBrackets(\"Text [with [nested] brackets] and more text\")).toBe(\"with [nested] brackets\");\n    });\n\n    it('should extract mixed bracket types', () => {\n        expect(extractOutermostBrackets(\"Mixed (types {of brackets [in use]})\")).toBe(\"types {of brackets [in use]}\");\n    });\n\n    it('should return an empty string when no brackets are present', () => {\n        expect(extractOutermostBrackets(\"No brackets here\")).toBe(\"\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Extracts the contents of the outermost brackets from the input string.\n * For example:\n *   input: \"Text [with [nested] brackets] and more text\"\n *   output: \"with [nested] brackets\"\n * \n * @param {string} s - The input string containing brackets.\n * @returns {string} - The contents within the outermost brackets, or an empty string if no brackets are found.\n */\nfunction extractOutermostBrackets(s) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Extracts the contents of the outermost brackets from the input string.\n * \n * Example:\n *   Input: \"Text [with [nested] brackets] and more text\"\n *   Output: \"with [nested] brackets\"\n * \n * @param s - The input string containing brackets.\n * @returns The contents within the outermost brackets, or an empty string if no brackets are found.\n */\nfunction extractOutermostBrackets(s: string): string {}", "test_code": "describe('TestExtractOutermostBrackets', () => {\n    it('should extract single parentheses', () => {\n      expect(extractOutermostBrackets(\"Text (example) more text\")).toBe(\"example\");\n    });\n  \n    it('should extract nested brackets', () => {\n      expect(extractOutermostBrackets(\"Text {with some {nested} brackets}\")).toBe(\"with some {nested} brackets\");\n    });\n  \n    it('should extract square brackets', () => {\n      expect(extractOutermostBrackets(\"Text [with [nested] brackets] and more text\")).toBe(\"with [nested] brackets\");\n    });\n  \n    it('should extract mixed bracket types', () => {\n      expect(extractOutermostBrackets(\"Mixed (types {of brackets [in use]})\")).toBe(\"types {of brackets [in use]}\");\n    });\n  \n    it('should return an empty string when no brackets are present', () => {\n      expect(extractOutermostBrackets(\"No brackets here\")).toBe(\"\");\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Extracts the contents of the outermost brackets from the input string.\n * \n * Example:\n *   Input: \"Text [with [nested] brackets] and more text\"\n *   Output: \"with [nested] brackets\"\n * \n * @param s - The input string containing brackets.\n * @returns The contents within the outermost brackets, or an empty string if no brackets are found.\n */\nfunction extractOutermostBrackets(s: string): string {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extracts the contents of the outermost brackets from the input string.\n *\n * This function scans the input string for the outermost brackets and extracts \n * the contents within them. For example, given the input string:\n * \"Text [with [nested] brackets] and more text\", the function will return:\n * \"with [nested] brackets\".\n *\n * @param s The input string containing brackets.\n * @type s std::string\n *\n * @return The contents within the outermost brackets, or an empty string if no \n * brackets are found.\n * @rtype std::string\n */\nstd::string extract_outermost_brackets(const std::string& s) {}", "test_code": "TEST_CASE(\"Test extract_outermost_brackets\") {\n    SECTION(\"test_single_parentheses\") {\n        CHECK(extract_outermost_brackets(\"Text (example) more text\") == \"example\");\n    }\n\n    SECTION(\"test_nested_brackets\") {\n        CHECK(extract_outermost_brackets(\"Text {with some {nested} brackets}\") == \"with some {nested} brackets\");\n    }\n\n    SECTION(\"test_square_brackets\") {\n        CHECK(extract_outermost_brackets(\"Text [with [nested] brackets] and more text\") == \"with [nested] brackets\");\n    }\n\n    SECTION(\"test_mixed_bracket_types\") {\n        CHECK(extract_outermost_brackets(\"Mixed (types {of brackets [in use]})\") == \"types {of brackets [in use]}\");\n    }\n\n    SECTION(\"test_no_brackets\") {\n        CHECK(extract_outermost_brackets(\"No brackets here\") == \"\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts the contents of the outermost brackets from the input string.\n *\n * This function scans the input string for the outermost brackets and extracts \n * the contents within them. For example, given the input string:\n * \"Text [with [nested] brackets] and more text\", the function will return:\n * \"with [nested] brackets\".\n *\n * @param s The input string containing brackets.\n * @type s std::string\n *\n * @return The contents within the outermost brackets, or an empty string if no \n * brackets are found.\n * @rtype std::string\n */\nstd::string extract_outermost_brackets(const std::string& s) {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 483, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Verify that the mailbox string is a qualified mailbox\n", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Verifies if the provided string is a valid email address.\n\n    Args:\n        email (str):The email address to validate.\n\n    Returns:\n        bool: True if the email address is valid, False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestEmailValidation(unittest.TestCase):\n\n    def test_valid_email(self):\n        self.assertTrue(is_valid_email(\"test@example.com\"))\n\n    def test_valid_email_with_subdomain(self):\n        self.assertTrue(is_valid_email(\"user@subdomain.example.com\"))\n\n    def test_valid_email_with_plus_tag(self):\n        self.assertTrue(is_valid_email(\"user.name+tag+sorting@example.com\"))\n\n    def test_invalid_email_missing_username(self):\n        self.assertFalse(is_valid_email(\"@missingusername.com\"))\n\n    def test_invalid_email_missing_at_symbol(self):\n        self.assertFalse(is_valid_email(\"missingatsign.com\"))\n\n\n    def test_invalid_email_tld_too_short(self):\n        self.assertFalse(is_valid_email(\"user@domain.c\"))\n\n    def test_invalid_email_with_special_characters(self):\n        self.assertFalse(is_valid_email(\"user@domain.com!\"))\n\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Verifies if the provided string is a valid email address.\n\n    Args:\n        email (str):The email address to validate.\n\n    Returns:\n        bool: True if the email address is valid, False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Verifies if the provided string is a valid email address.\n *\n * @param {string} email - The email address to validate.\n * @returns {boolean} - True if the email address is valid, False otherwise.\n */\nfunction isValidEmail(email) {}", "test_code": "describe('Email Validation', () => {\n    it('should validate a valid email', () => {\n        expect(isValidEmail('test@example.com')).toBe(true);\n    });\n\n    it('should validate a valid email with subdomain', () => {\n        expect(isValidEmail('user@subdomain.example.com')).toBe(true);\n    });\n\n    it('should validate a valid email with plus tag', () => {\n        expect(isValidEmail('user.name+tag+sorting@example.com')).toBe(true);\n    });\n\n    it('should invalidate an email missing username', () => {\n        expect(isValidEmail('@missingusername.com')).toBe(false);\n    });\n\n    it('should invalidate an email missing at symbol', () => {\n        expect(isValidEmail('missingatsign.com')).toBe(false);\n    });\n\n    it('should invalidate an email with TLD too short', () => {\n        expect(isValidEmail('user@domain.c')).toBe(false);\n    });\n\n    it('should invalidate an email with special characters', () => {\n        expect(isValidEmail('user@domain.com!')).toBe(false);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Verifies if the provided string is a valid email address.\n *\n * @param {string} email - The email address to validate.\n * @returns {boolean} - True if the email address is valid, False otherwise.\n */\nfunction isValidEmail(email) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Verifies if the provided string is a valid email address.\n * \n * @param email - The email address to validate.\n * @returns True if the email address is valid, False otherwise.\n */\nfunction isValidEmail(email: string): boolean {}", "test_code": "describe('Email Validation', () => {\n    it('should validate a valid email', () => {\n        expect(isValidEmail('test@example.com')).toBe(true);\n    });\n\n    it('should validate a valid email with subdomain', () => {\n        expect(isValidEmail('user@subdomain.example.com')).toBe(true);\n    });\n\n    it('should validate a valid email with plus tag', () => {\n        expect(isValidEmail('user.name+tag+sorting@example.com')).toBe(true);\n    });\n\n    it('should invalidate an email missing username', () => {\n        expect(isValidEmail('@missingusername.com')).toBe(false);\n    });\n\n    it('should invalidate an email missing at symbol', () => {\n        expect(isValidEmail('missingatsign.com')).toBe(false);\n    });\n\n    it('should invalidate an email with too short TLD', () => {\n        expect(isValidEmail('user@domain.c')).toBe(false);\n    });\n\n    it('should invalidate an email with special characters', () => {\n        expect(isValidEmail('user@domain.com!')).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Verifies if the provided string is a valid email address.\n * \n * @param email - The email address to validate.\n * @returns True if the email address is valid, False otherwise.\n */\nfunction isValidEmail(email: string): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Verifies if the provided string is a valid email address.\n *\n * @param email The email address to validate.\n * @type email std::string\n *\n * @return True if the email address is valid, False otherwise.\n * @rtype bool\n */\nbool isValidEmail(const std::string &email);", "test_code": "TEST_CASE(\"Test Email Validation\", \"[email]\") {\n    SECTION(\"Valid email\") {\n        REQUIRE(is_valid_email(\"test@example.com\"));\n    }\n\n    SECTION(\"Valid email with subdomain\") {\n        REQUIRE(is_valid_email(\"user@subdomain.example.com\"));\n    }\n\n    SECTION(\"Valid email with plus tag\") {\n        REQUIRE(is_valid_email(\"user.name+tag+sorting@example.com\"));\n    }\n\n    SECTION(\"Invalid email missing username\") {\n        REQUIRE_FALSE(is_valid_email(\"@missingusername.com\"));\n    }\n\n    SECTION(\"Invalid email missing at symbol\") {\n        REQUIRE_FALSE(is_valid_email(\"missingatsign.com\"));\n    }\n\n    SECTION(\"Invalid email TLD too short\") {\n        REQUIRE_FALSE(is_valid_email(\"user@domain.c\"));\n    }\n\n    SECTION(\"Invalid email with special characters\") {\n        REQUIRE_FALSE(is_valid_email(\"user@domain.com!\"));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Verifies if the provided string is a valid email address.\n *\n * @param email The email address to validate.\n * @type email std::string\n *\n * @return True if the email address is valid, False otherwise.\n * @rtype bool\n */\nbool isValidEmail(const std::string &email);", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 485, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "This function modifies a SQL query string containing named parameters\n    (like $name, $age) into a format compatible with libraries that require\n    positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n    a tuple containing the modified SQL string and a list of parameter values\n    ordered according to their new positions in the query.", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef convert_named_to_positional_query(sql: str, params: dict) -> tuple:\n    \"\"\"\n    This function modifies a SQL query string containing named parameters\n    (like $name, $age) into a format compatible with libraries that require\n    positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n    a tuple containing the modified SQL string and a list of parameter values\n    ordered according to their new positions in the query.\n    For example:\n        input:\n            sql: SELECT * FROM users WHERE id = $user_id AND status = $status\n            params: {'user_id': 42,'status': 'active'}\n        output:\n            SELECT * FROM users WHERE id = $1 AND status = $2,[42, 'active']\n\n    Args:\n        sql (str): The original SQL query string with named parameters.\n        params (dict): A dictionary mapping parameter names to their values.\n\n    Returns:\n        tuple: A tuple where the first element is the modified SQL query string with positional parameters, and the second element is a list of parameter values sorted according to the order of the positional parameters.\n    \"\"\"", "test_code": "import unittest\n\nclass TestConvertNamedToPositionalQuery(unittest.TestCase):\n\n    def test_basic_named_parameters(self):\n        sql = \"SELECT * FROM users WHERE username = $username AND age = $age\"\n        params = {\"username\": \"john_doe\", \"age\": 30}\n        delimiter = \"$\"\n\n        expected = {\n            \"positional_sql\": \"SELECT * FROM users WHERE username = $1 AND age = $2\",\n            \"param_list\": [\"john_doe\", 30],\n            \"execute_sql\": \"SELECT * FROM users WHERE username = john_doe AND age = 30\"\n        }\n\n        result = convert_named_to_positional_query(sql, params, delimiter)\n        self.assertEqual(result, expected)\n\n    def test_missing_parameter(self):\n        sql = \"SELECT * FROM products WHERE id = #product_id AND name = #product_name\"\n        params = {\"product_id\": 101}  # 'product_name' is missing\n        delimiter = \"#\"\n\n        with self.assertRaises(ValueError) as context:\n            convert_named_to_positional_query(sql, params, delimiter)\n\n        self.assertEqual(str(context.exception), \"Parameter 'product_name' not found in params dictionary.\")\n\n    def test_different_delimiter(self):\n        sql = \"INSERT INTO orders (product_id, quantity) VALUES (:product_id, :quantity)\"\n        params = {\"product_id\": 202, \"quantity\": 5}\n        delimiter = \":\"\n\n        expected = {\n            \"positional_sql\": \"INSERT INTO orders (product_id, quantity) VALUES (:1, :2)\",\n            \"param_list\": [202, 5],\n            \"execute_sql\": \"INSERT INTO orders (product_id, quantity) VALUES (202, 5)\"\n        }\n\n        result = convert_named_to_positional_query(sql, params, delimiter)\n        self.assertEqual(result, expected)\n\n\n    def test_no_named_parameters(self):\n        sql = \"SELECT * FROM users\"\n        params = {}\n        delimiter = \"$\"\n\n        expected = {\n            \"positional_sql\": \"SELECT * FROM users\",\n            \"param_list\": [],\n            \"execute_sql\": \"SELECT * FROM users\"\n        }\n\n        result = convert_named_to_positional_query(sql, params, delimiter)\n        self.assertEqual(result, expected)\n\n    def test_sql_with_empty_string_parameter(self):\n        sql = \"SELECT * FROM users WHERE username = :username\"\n        params = {\"username\": \"\"}\n        delimiter = \":\"\n\n        expected = {\n            \"positional_sql\": \"SELECT * FROM users WHERE username = :1\",\n            \"param_list\": [\"\"],\n            \"execute_sql\": \"SELECT * FROM users WHERE username = \"\n        }\n\n        result = convert_named_to_positional_query(sql, params, delimiter)\n        self.assertEqual(result, expected)\n\nif __name__ == '__main__':\n    unittest.main()\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef convert_named_to_positional_query(sql: str, params: dict) -> tuple:\n    \"\"\"\n    This function modifies a SQL query string containing named parameters\n    (like $name, $age) into a format compatible with libraries that require\n    positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n    a tuple containing the modified SQL string and a list of parameter values\n    ordered according to their new positions in the query.\n    For example:\n        input:\n            sql: SELECT * FROM users WHERE id = $user_id AND status = $status\n            params: {'user_id': 42,'status': 'active'}\n        output:\n            SELECT * FROM users WHERE id = $1 AND status = $2,[42, 'active']\n\n    Args:\n        sql (str): The original SQL query string with named parameters.\n        params (dict): A dictionary mapping parameter names to their values.\n\n    Returns:\n        tuple: A tuple where the first element is the modified SQL query string with positional parameters, and the second element is a list of parameter values sorted according to the order of the positional parameters.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * This function modifies a SQL query string containing named parameters\n * (like $name, $age) into a format compatible with libraries that require\n * positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n * a tuple containing the modified SQL string and a list of parameter values\n * ordered according to their new positions in the query.\n * \n * Example:\n *   Input:\n *     sql: \"SELECT * FROM users WHERE id = $user_id AND status = $status\"\n *     params: {'user_id': 42, 'status': 'active'}\n *   Output:\n *     [\"SELECT * FROM users WHERE id = $1 AND status = $2\", [42, 'active']]\n * \n * @param {string} sql - The original SQL query string with named parameters.\n * @param {Object} params - A dictionary mapping parameter names to their values.\n * @returns {Array} - An array where the first element is the modified SQL query string\n *                    with positional parameters, and the second element is a list of\n *                    parameter values sorted according to the order of the positional parameters.\n */\nfunction prepareQuery(sql, params) {}", "test_code": "describe('TestPrepareQuery', () => {\n    it('test_valid_named_parameters', () => {\n        const sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $status\";\n        const parameters = {\n            'user_id': 42,\n            'status': 'active'\n        };\n        const expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $2\";\n        const expected_values = [42, 'active'];\n\n        const [new_sql, value_list] = prepareQuery(sql_query, parameters);\n        expect(new_sql).toEqual(expected_sql);\n        expect(value_list).toEqual(expected_values);\n    });\n\n    it('test_missing_parameters', () => {\n        const sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $status\";\n        const parameters = {\n            'user_id': 42  // 'status' is missing\n        };\n        const expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $2\";\n        const expected_values = [42];  // 'status' is not included\n\n        const [new_sql, value_list] = prepareQuery(sql_query, parameters);\n        expect(new_sql).toEqual(expected_sql);\n        expect(value_list).toEqual(expected_values);\n    });\n\n    it('test_no_parameters', () => {\n        const sql_query = \"SELECT * FROM users\";\n        const parameters = {};  // No parameters provided\n        const expected_sql = \"SELECT * FROM users\";\n        const expected_values = [];\n\n        const [new_sql, value_list] = prepareQuery(sql_query, parameters);\n        expect(new_sql).toEqual(expected_sql);\n        expect(value_list).toEqual(expected_values);\n    });\n\n    it('test_multiple_same_parameters', () => {\n        const sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $user_id\";\n        const parameters = {\n            'user_id': 42\n        };\n        const expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $1\";\n        const expected_values = [42];  // Only one value for 'user_id'\n\n        const [new_sql, value_list] = prepareQuery(sql_query, parameters);\n        expect(new_sql).toEqual(expected_sql);\n        expect(value_list).toEqual(expected_values);\n    });\n\n    it('test_special_characters_in_parameters', () => {\n        const sql_query = \"INSERT INTO users (name, email) VALUES ($name, $email)\";\n        const parameters = {\n            'name': \"John Doe\",\n            'email': \"john.doe@example.com\"\n        };\n        const expected_sql = \"INSERT INTO users (name, email) VALUES ($1, $2)\";\n        const expected_values = [\"John Doe\", \"john.doe@example.com\"];\n\n        const [new_sql, value_list] = prepareQuery(sql_query, parameters);\n        expect(new_sql).toEqual(expected_sql);\n        expect(value_list).toEqual(expected_values);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * This function modifies a SQL query string containing named parameters\n * (like $name, $age) into a format compatible with libraries that require\n * positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n * a tuple containing the modified SQL string and a list of parameter values\n * ordered according to their new positions in the query.\n * \n * Example:\n *   Input:\n *     sql: \"SELECT * FROM users WHERE id = $user_id AND status = $status\"\n *     params: {'user_id': 42, 'status': 'active'}\n *   Output:\n *     [\"SELECT * FROM users WHERE id = $1 AND status = $2\", [42, 'active']]\n * \n * @param {string} sql - The original SQL query string with named parameters.\n * @param {Object} params - A dictionary mapping parameter names to their values.\n * @returns {Array} - An array where the first element is the modified SQL query string\n *                    with positional parameters, and the second element is a list of\n *                    parameter values sorted according to the order of the positional parameters.\n */\nfunction prepareQuery(sql, params) {}", "addition_info": ""}, "typescript": {"code_signature": "import { match, replace } from 'lodash';\n\n/**\n * This function modifies a SQL query string containing named parameters\n * (like $name, $age) into a format compatible with libraries that require\n * positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n * a tuple containing the modified SQL string and a list of parameter values\n * ordered according to their new positions in the query.\n * \n * Example:\n *   Input:\n *     sql: \"SELECT * FROM users WHERE id = $user_id AND status = $status\"\n *     params: { user_id: 42, status: 'active' }\n *   Output:\n *     [\"SELECT * FROM users WHERE id = $1 AND status = $2\", [42, 'active']]\n * \n * @param sql - The original SQL query string with named parameters.\n * @param params - A dictionary mapping parameter names to their values.\n * @returns A tuple where the first element is the modified SQL query string with positional parameters, and the second element is a list of parameter values sorted according to the order of the positional parameters.\n */\nfunction prepareQuery(sql: string, params: Record<string, any>): [string, any[]] {}", "test_code": "describe('TestPrepareQuery', () => {\n    it('test valid named parameters', () => {\n        const sqlQuery = \"SELECT * FROM users WHERE id = $user_id AND status = $status\";\n        const parameters = {\n            user_id: 42,\n            status: 'active'\n        };\n        const expectedSql = \"SELECT * FROM users WHERE id = $1 AND status = $2\";\n        const expectedValues = [42, 'active'];\n\n        const [newSql, valueList] = prepareQuery(sqlQuery, parameters);\n        expect(newSql).toEqual(expectedSql);\n        expect(valueList).toEqual(expectedValues);\n    });\n\n    it('test missing parameters', () => {\n        const sqlQuery = \"SELECT * FROM users WHERE id = $user_id AND status = $status\";\n        const parameters = {\n            user_id: 42  // 'status' is missing\n        };\n        const expectedSql = \"SELECT * FROM users WHERE id = $1 AND status = $2\";\n        const expectedValues = [42];  // 'status' is not included\n\n        const [newSql, valueList] = prepareQuery(sqlQuery, parameters);\n        expect(newSql).toEqual(expectedSql);\n        expect(valueList).toEqual(expectedValues);\n    });\n\n    it('test no parameters', () => {\n        const sqlQuery = \"SELECT * FROM users\";\n        const parameters = {};  // No parameters provided\n        const expectedSql = \"SELECT * FROM users\";\n        const expectedValues = [];\n\n        const [newSql, valueList] = prepareQuery(sqlQuery, parameters);\n        expect(newSql).toEqual(expectedSql);\n        expect(valueList).toEqual(expectedValues);\n    });\n\n    it('test multiple same parameters', () => {\n        const sqlQuery = \"SELECT * FROM users WHERE id = $user_id AND status = $user_id\";\n        const parameters = {\n            user_id: 42\n        };\n        const expectedSql = \"SELECT * FROM users WHERE id = $1 AND status = $1\";\n        const expectedValues = [42];  // Only one value for 'user_id'\n\n        const [newSql, valueList] = prepareQuery(sqlQuery, parameters);\n        expect(newSql).toEqual(expectedSql);\n        expect(valueList).toEqual(expectedValues);\n    });\n\n    it('test special characters in parameters', () => {\n        const sqlQuery = \"INSERT INTO users (name, email) VALUES ($name, $email)\";\n        const parameters = {\n            name: \"John Doe\",\n            email: \"john.doe@example.com\"\n        };\n        const expectedSql = \"INSERT INTO users (name, email) VALUES ($1, $2)\";\n        const expectedValues = [\"John Doe\", \"john.doe@example.com\"];\n\n        const [newSql, valueList] = prepareQuery(sqlQuery, parameters);\n        expect(newSql).toEqual(expectedSql);\n        expect(valueList).toEqual(expectedValues);\n    });\n});", "prompt": "please write a typescript function , the function signature as below import { match, replace } from 'lodash';\n\n/**\n * This function modifies a SQL query string containing named parameters\n * (like $name, $age) into a format compatible with libraries that require\n * positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n * a tuple containing the modified SQL string and a list of parameter values\n * ordered according to their new positions in the query.\n * \n * Example:\n *   Input:\n *     sql: \"SELECT * FROM users WHERE id = $user_id AND status = $status\"\n *     params: { user_id: 42, status: 'active' }\n *   Output:\n *     [\"SELECT * FROM users WHERE id = $1 AND status = $2\", [42, 'active']]\n * \n * @param sql - The original SQL query string with named parameters.\n * @param params - A dictionary mapping parameter names to their values.\n * @returns A tuple where the first element is the modified SQL query string with positional parameters, and the second element is a list of parameter values sorted according to the order of the positional parameters.\n */\nfunction prepareQuery(sql: string, params: Record<string, any>): [string, any[]] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief This function modifies a SQL query string containing named parameters\n * (like $name, $age) into a format compatible with libraries that require\n * positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n * a pair containing the modified SQL string and a vector of parameter values\n * ordered according to their new positions in the query.\n * \n * Example:\n *     Input:\n *         sql: SELECT * FROM users WHERE id = $user_id AND status = $status\n *         params: {{\"user_id\", \"42\"}, {\"status\", \"active\"}}\n *     Output:\n *         Modified SQL: SELECT * FROM users WHERE id = $1 AND status = $2\n *         Values: [\"42\", \"active\"]\n * \n * @param sql The original SQL query string with named parameters.\n * @param params A map mapping parameter names to their values.\n * @return A pair where the first element is the modified SQL query string with positional parameters,\n *         and the second element is a vector of parameter values sorted according to the order of the positional parameters.\n */\nstd::pair<std::string, std::vector<std::string>> prepare_query(const std::string& sql, const std::map<std::string, std::string>& params) {}", "test_code": "TEST_CASE(\"Test prepare_query function\") {\n    SECTION(\"Valid named parameters\") {\n        std::string sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $status\";\n        std::map<std::string, std::string> parameters = {\n            {\"user_id\", \"42\"},\n            {\"status\", \"active\"}\n        };\n        std::string expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $2\";\n        std::vector<std::string> expected_values = {\"42\", \"active\"};\n\n        auto [new_sql, value_list] = prepare_query(sql_query, parameters);\n        REQUIRE(new_sql == expected_sql);\n        REQUIRE(value_list == expected_values);\n    }\n\n    SECTION(\"Missing parameters\") {\n        std::string sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $status\";\n        std::map<std::string, std::string> parameters = {\n            {\"user_id\", \"42\"}\n        };\n        std::string expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $2\";\n        std::vector<std::string> expected_values = {\"42\"};\n\n        auto [new_sql, value_list] = prepare_query(sql_query, parameters);\n        REQUIRE(new_sql == expected_sql);\n        REQUIRE(value_list == expected_values);\n    }\n\n    SECTION(\"No parameters\") {\n        std::string sql_query = \"SELECT * FROM users\";\n        std::map<std::string, std::string> parameters = {};\n        std::string expected_sql = \"SELECT * FROM users\";\n        std::vector<std::string> expected_values = {};\n\n        auto [new_sql, value_list] = prepare_query(sql_query, parameters);\n        REQUIRE(new_sql == expected_sql);\n        REQUIRE(value_list == expected_values);\n    }\n\n    SECTION(\"Multiple same parameters\") {\n        std::string sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $user_id\";\n        std::map<std::string, std::string> parameters = {\n            {\"user_id\", \"42\"}\n        };\n        std::string expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $1\";\n        std::vector<std::string> expected_values = {\"42\"};\n\n        auto [new_sql, value_list] = prepare_query(sql_query, parameters);\n        REQUIRE(new_sql == expected_sql);\n        REQUIRE(value_list == expected_values);\n    }\n\n    SECTION(\"Special characters in parameters\") {\n        std::string sql_query = \"INSERT INTO users (name, email) VALUES ($name, $email)\";\n        std::map<std::string, std::string> parameters = {\n            {\"name\", \"John Doe\"},\n            {\"email\", \"john.doe@example.com\"}\n        };\n        std::string expected_sql = \"INSERT INTO users (name, email) VALUES ($1, $2)\";\n        std::vector<std::string> expected_values = {\"John Doe\", \"john.doe@example.com\"};\n\n        auto [new_sql, value_list] = prepare_query(sql_query, parameters);\n        REQUIRE(new_sql == expected_sql);\n        REQUIRE(value_list == expected_values);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief This function modifies a SQL query string containing named parameters\n * (like $name, $age) into a format compatible with libraries that require\n * positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n * a pair containing the modified SQL string and a vector of parameter values\n * ordered according to their new positions in the query.\n * \n * Example:\n *     Input:\n *         sql: SELECT * FROM users WHERE id = $user_id AND status = $status\n *         params: {{\"user_id\", \"42\"}, {\"status\", \"active\"}}\n *     Output:\n *         Modified SQL: SELECT * FROM users WHERE id = $1 AND status = $2\n *         Values: [\"42\", \"active\"]\n * \n * @param sql The original SQL query string with named parameters.\n * @param params A map mapping parameter names to their values.\n * @return A pair where the first element is the modified SQL query string with positional parameters,\n *         and the second element is a vector of parameter values sorted according to the order of the positional parameters.\n */\nstd::pair<std::string, std::vector<std::string>> prepare_query(const std::string& sql, const std::map<std::string, std::string>& params) {}", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "please write a java function , the function signature as below ,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 487, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Check if the string contains an email address\n", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef contains_email(text: str) -> bool:\n    \"\"\"\n    Check if the given text contains an email address.\n\n    Args:\n        text (str): The string to search for an email address.\n\n    Returns:\n        bool: True if an email address is found, False otherwise.\n    \"\"\"\n\n\n    \"\"\"\n    Check if the given text contains an email address.\n\n    Args:\n    text (str): The string to search for an email address.\n\n    Returns:\n    bool: True if an email address is found, False otherwise.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestContainsEmail(unittest.TestCase):\n\n    def test_contains_valid_email(self):\n        \"\"\"Test if a valid email is detected in the string.\"\"\"\n        test_string = \"You can reach me at example@example.com for more info.\"\n        self.assertTrue(contains_email(test_string))\n\n    def test_contains_email_with_special_characters(self):\n        \"\"\"Test if an email with special characters is detected.\"\"\"\n        test_string = \"My email address is john.doe123+test@gmail.com!\"\n        self.assertTrue(contains_email(test_string))\n\n    def test_does_not_contain_email(self):\n        \"\"\"Test a string that does not contain any email address.\"\"\"\n        test_string = \"This string does not have an email.\"\n        self.assertFalse(contains_email(test_string))\n\n    def test_contains_multiple_emails(self):\n        \"\"\"Test a string containing multiple email addresses.\"\"\"\n        test_string = \"You can contact me at example1@example.com or example2@example.com.\"\n        self.assertTrue(contains_email(test_string))\n\n    def test_contains_invalid_email_format(self):\n        \"\"\"Test a string with an invalid email format.\"\"\"\n        test_string = \"Please contact me at example@.com or test@domain.\"\n        self.assertFalse(contains_email(test_string))", "prompt": "please write a python function , the function signature as below import re\n\n\ndef contains_email(text: str) -> bool:\n    \"\"\"\n    Check if the given text contains an email address.\n\n    Args:\n        text (str): The string to search for an email address.\n\n    Returns:\n        bool: True if an email address is found, False otherwise.\n    \"\"\"\n\n\n    \"\"\"\n    Check if the given text contains an email address.\n\n    Args:\n    text (str): The string to search for an email address.\n\n    Returns:\n    bool: True if an email address is found, False otherwise.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Check if the given text contains an email address.\n *\n * @param {string} text - The string to search for an email address.\n * @returns {boolean} - True if an email address is found, False otherwise.\n */\nfunction containsEmail(text) {}", "test_code": "describe('TestContainsEmail', () => {\n    describe('Testing email detection', () => {\n        it('should detect a valid email in the string', () => {\n            const testString = \"You can reach me at example@example.com for more info.\";\n            expect(containsEmail(testString)).toBe(true);\n        });\n\n        it('should detect an email with special characters', () => {\n            const testString = \"My email address is john.doe123+test@gmail.com!\";\n            expect(containsEmail(testString)).toBe(true);\n        });\n\n        it('should not detect an email in a string without emails', () => {\n            const testString = \"This string does not have an email.\";\n            expect(containsEmail(testString)).toBe(false);\n        });\n\n        it('should detect multiple emails in a string', () => {\n            const testString = \"You can contact me at example1@example.com or example2@example.com.\";\n            expect(containsEmail(testString)).toBe(true);\n        });\n\n        it('should not detect an email with an invalid format', () => {\n            const testString = \"Please contact me at example@.com or test@domain.\";\n            expect(containsEmail(testString)).toBe(false);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Check if the given text contains an email address.\n *\n * @param {string} text - The string to search for an email address.\n * @returns {boolean} - True if an email address is found, False otherwise.\n */\nfunction containsEmail(text) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Check if the given text contains an email address.\n *\n * @param text - The string to search for an email address.\n * @returns True if an email address is found, False otherwise.\n */\nfunction containsEmail(text: string): boolean {\n\n}", "test_code": "describe('TestContainsEmail', () => {\n    it('test_contains_valid_email', () => {\n        // Test if a valid email is detected in the string.\n        const testString = \"You can reach me at example@example.com for more info.\";\n        expect(containsEmail(testString)).toBe(true);\n    });\n\n    it('test_contains_email_with_special_characters', () => {\n        // Test if an email with special characters is detected.\n        const testString = \"My email address is john.doe123+test@gmail.com!\";\n        expect(containsEmail(testString)).toBe(true);\n    });\n\n    it('test_does_not_contain_email', () => {\n        // Test a string that does not contain any email address.\n        const testString = \"This string does not have an email.\";\n        expect(containsEmail(testString)).toBe(false);\n    });\n\n    it('test_contains_multiple_emails', () => {\n        // Test a string containing multiple email addresses.\n        const testString = \"You can contact me at example1@example.com or example2@example.com.\";\n        expect(containsEmail(testString)).toBe(true);\n    });\n\n    it('test_contains_invalid_email_format', () => {\n        // Test a string with an invalid email format.\n        const testString = \"Please contact me at example@.com or test@domain.\";\n        expect(containsEmail(testString)).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Check if the given text contains an email address.\n *\n * @param text - The string to search for an email address.\n * @returns True if an email address is found, False otherwise.\n */\nfunction containsEmail(text: string): boolean {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Checks if the given text contains an email address.\n *\n * @param text The string to search for an email address.\n * @type text const std::string&\n *\n * @return True if an email address is found, False otherwise.\n * @rtype bool\n */\nbool containsEmailAddress(const std::string &text){}\n", "test_code": "TEST_CASE(\"TestContainsEmail\", \"[email]\") {\n    SECTION(\"test_contains_valid_email\") {\n        // Test if a valid email is detected in the string\n        std::string test_string = \"You can reach me at example@example.com for more info.\";\n        REQUIRE(contains_email(test_string));\n    }\n\n    SECTION(\"test_contains_email_with_special_characters\") {\n        // Test if an email with special characters is detected\n        std::string test_string = \"My email address is john.doe123+test@gmail.com!\";\n        REQUIRE(contains_email(test_string));\n    }\n\n    SECTION(\"test_does_not_contain_email\") {\n        // Test a string that does not contain any email address\n        std::string test_string = \"This string does not have an email.\";\n        REQUIRE_FALSE(contains_email(test_string));\n    }\n\n    SECTION(\"test_contains_multiple_emails\") {\n        // Test a string containing multiple email addresses\n        std::string test_string = \"You can contact me at example1@example.com or example2@example.com.\";\n        REQUIRE(contains_email(test_string));\n    }\n\n    SECTION(\"test_contains_invalid_email_format\") {\n        // Test a string with an invalid email format\n        std::string test_string = \"Please contact me at example@.com or test@domain.\";\n        REQUIRE_FALSE(contains_email(test_string));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Checks if the given text contains an email address.\n *\n * @param text The string to search for an email address.\n * @type text const std::string&\n *\n * @return True if an email address is found, False otherwise.\n * @rtype bool\n */\nbool containsEmailAddress(const std::string &text){}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks if the given text contains an email address.\n *\n * @param text The string to search for an email address.\n * @return true if an email address is found, false otherwise.\n */\npublic static boolean containsEmail(String text) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Test class for checking if a string contains an email address.\n */\npublic class Tester {\n\n    /**\n     * Test if a valid email is detected in the string.\n     */\n    @Test\n    public void testContainsValidEmail() {\n        String testString = \"You can reach me at example@example.com for more info.\";\n        assertTrue(containsEmail(testString));\n    }\n\n    /**\n     * Test if an email with special characters is detected.\n     */\n    @Test\n    public void testContainsEmailWithSpecialCharacters() {\n        String testString = \"My email address is john.doe123+test@gmail.com!\";\n        assertTrue(containsEmail(testString));\n    }\n\n    /**\n     * Test a string that does not contain any email address.\n     */\n    @Test\n    public void testDoesNotContainEmail() {\n        String testString = \"This string does not have an email.\";\n        assertFalse(containsEmail(testString));\n    }\n\n    /**\n     * Test a string containing multiple email addresses.\n     */\n    @Test\n    public void testContainsMultipleEmails() {\n        String testString = \"You can contact me at example1@example.com or example2@example.com.\";\n        assertTrue(containsEmail(testString));\n    }\n\n    /**\n     * Test a string with an invalid email format.\n     */\n    @Test\n    public void testContainsInvalidEmailFormat() {\n        String testString = \"Please contact me at example@.com or test@domain.\";\n        assertFalse(containsEmail(testString));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks if the given text contains an email address.\n *\n * @param text The string to search for an email address.\n * @return true if an email address is found, false otherwise.\n */\npublic static boolean containsEmail(String text) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 488, "code_type": "method", "original_language": "python", "question_type": "Network requests and API call", "summary": "Retrieve the local IP address of the specified network interface on Windows.", "language_version_list": {"python": {"code_signature": "import subprocess\nimport re\nfrom typing import Optional\n\n\ndef get_local_ip(interface: str = 'Wi-Fi') -> Optional[str]:\n    \"\"\"\n    Retrieve the local IP address of the specified network interface on Windows.\n\n    Args:\n        interface (str): The name of the network interface to check (default is 'Wi-Fi').\n\n    Returns:\n        Optional[str]: The local IP address if found, otherwise None.\n    \"\"\"\n", "test_code": "import subprocess\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass TestGetLocalIP(unittest.TestCase):\n\n    @patch('subprocess.run')\n    def test_local_ip_found(self, mock_run):\n        # Mock the output of ipconfig for a case where a local IP is found\n        mock_run.return_value = MagicMock(stdout='192.168.1.10\\n')\n        result = get_local_ip()\n        self.assertEqual(result, '192.168.1.10')\n\n    @patch('subprocess.run')\n    def test_no_local_ip_found(self, mock_run):\n        # Mock the output of ipconfig for a case where no local IP is found\n        mock_run.return_value = MagicMock(stdout='10.0.0.5\\n')\n        result = get_local_ip()\n        self.assertIsNone(result)\n\n    @patch('subprocess.run')\n    def test_multiple_ips_found(self, mock_run):\n        # Mock the output with multiple local IPs\n        mock_run.return_value = MagicMock(stdout='10.0.0.5\\n'\n                                                  '192.168.1.10\\n')\n        result = get_local_ip()\n        self.assertEqual(result, '192.168.1.10')\n\n    @patch('subprocess.run')\n    def test_invalid_command(self, mock_run):\n        # Simulate a case where subprocess.run raises a CalledProcessError\n        mock_run.side_effect = subprocess.CalledProcessError(1, 'ipconfig')\n        result = get_local_ip()\n        self.assertIsNone(result)\n\n    @patch('subprocess.run')\n    def test_unexpected_error(self, mock_run):\n        # Simulate an unexpected error\n        mock_run.side_effect = Exception(\"Unexpected error\")\n        result = get_local_ip()\n        self.assertIsNone(result)", "prompt": "please write a python function , the function signature as below import subprocess\nimport re\nfrom typing import Optional\n\n\ndef get_local_ip(interface: str = 'Wi-Fi') -> Optional[str]:\n    \"\"\"\n    Retrieve the local IP address of the specified network interface on Windows.\n\n    Args:\n        interface (str): The name of the network interface to check (default is 'Wi-Fi').\n\n    Returns:\n        Optional[str]: The local IP address if found, otherwise None.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Retrieve the local IP address of the specified network interface on Windows.\n *\n * @param {string} [interface='Wi-Fi'] - The name of the network interface to check (default is 'Wi-Fi').\n * @returns {Promise<string | null>} - A promise that resolves to the local IP address if found, otherwise null.\n */\nasync function getLocalIP(interface = 'Wi-Fi') {\n\n}\n", "test_code": "describe('TestGetLocalIP', () => {\n    beforeEach(() => {\n        jest.spyOn(console, 'error').mockImplementation(() => {});\n    });\n\n    afterEach(() => {\n        console.error.mockRestore();\n    });\n\n    it('should find a local IP when one is present', async () => {\n        // Mock the output of ipconfig for a case where a local IP is found\n        const execMock = jest.spyOn(require('child_process'), 'exec').mockResolvedValue({\n            stdout: '192.168.1.10\\n',\n            stderr: ''\n        });\n\n        const result = await getLocalIP();\n        expect(result).toBe('192.168.1.10');\n\n        execMock.mockRestore();\n    });\n\n    it('should return null when no local IP is found', async () => {\n        // Mock the output of ipconfig for a case where no local IP is found\n        const execMock = jest.spyOn(require('child_process'), 'exec').mockResolvedValue({\n            stdout: '10.0.0.5\\n',\n            stderr: ''\n        });\n\n        const result = await getLocalIP();\n        expect(result).toBeNull();\n\n        execMock.mockRestore();\n    });\n\n    it('should find the correct local IP when multiple IPs are present', async () => {\n        // Mock the output with multiple local IPs\n        const execMock = jest.spyOn(require('child_process'), 'exec').mockResolvedValue({\n            stdout: '10.0.0.5\\n192.168.1.10\\n',\n            stderr: ''\n        });\n\n        const result = await getLocalIP();\n        expect(result).toBe('192.168.1.10');\n\n        execMock.mockRestore();\n    });\n\n    it('should return null when the command fails', async () => {\n        // Simulate a case where exec throws an error\n        const execMock = jest.spyOn(require('child_process'), 'exec').mockRejectedValue(new Error('CalledProcessError'));\n\n        const result = await getLocalIP().catch(() => null);\n        expect(result).toBeNull();\n\n        execMock.mockRestore();\n    });\n\n    it('should return null when an unexpected error occurs', async () => {\n        // Simulate an unexpected error\n        const execMock = jest.spyOn(require('child_process'), 'exec').mockRejectedValue(new Error('Unexpected error'));\n\n        const result = await getLocalIP().catch(() => null);\n        expect(result).toBeNull();\n\n        execMock.mockRestore();\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Retrieve the local IP address of the specified network interface on Windows.\n *\n * @param {string} [interface='Wi-Fi'] - The name of the network interface to check (default is 'Wi-Fi').\n * @returns {Promise<string | null>} - A promise that resolves to the local IP address if found, otherwise null.\n */\nasync function getLocalIP(interface = 'Wi-Fi') {\n\n}\n", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Retrieve the local IP address of the specified network interface on Windows.\n *\n * @param {string} interfaceName - The name of the network interface to check (default is 'Wi-Fi').\n * @returns {Promise<string | null>} A promise that resolves to the local IP address if found, otherwise null.\n */\nfunction getLocalIp(interfaceName: string = 'Wi-Fi'): Promise<string | null> {\n\n}", "test_code": "describe('TestGetLocalIP', () => {\n    beforeEach(() => {\n        jest.resetAllMocks();\n    });\n\n    it('should find a local IP', async () => {\n        // Mock the output of ipconfig for a case where a local IP is found\n        mockExec.mockResolvedValueOnce({ stdout: '192.168.1.10\\n' });\n        const result = await getLocalIp();\n        expect(result).toBe('192.168.1.10');\n    });\n\n    it('should return null when no local IP is found', async () => {\n        // Mock the output of ipconfig for a case where no local IP is found\n        mockExec.mockResolvedValueOnce({ stdout: '10.0.0.5\\n' });\n        const result = await getLocalIp();\n        expect(result).toBeNull();\n    });\n\n    it('should return the first local IP when multiple IPs are found', async () => {\n        // Mock the output with multiple local IPs\n        mockExec.mockResolvedValueOnce({ stdout: '10.0.0.5\\n192.168.1.10\\n' });\n        const result = await getLocalIp();\n        expect(result).toBe('192.168.1.10');\n    });\n\n    it('should return null when the command fails', async () => {\n        // Simulate a case where subprocess.run raises a CalledProcessError\n        mockExec.mockRejectedValueOnce(new Error('Command failed'));\n        const result = await getLocalIp();\n        expect(result).toBeNull();\n    });\n\n    it('should return null when an unexpected error occurs', async () => {\n        // Simulate an unexpected error\n        mockExec.mockRejectedValueOnce(new Error('Unexpected error'));\n        const result = await getLocalIp();\n        expect(result).toBeNull();\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Retrieve the local IP address of the specified network interface on Windows.\n *\n * @param {string} interfaceName - The name of the network interface to check (default is 'Wi-Fi').\n * @returns {Promise<string | null>} A promise that resolves to the local IP address if found, otherwise null.\n */\nfunction getLocalIp(interfaceName: string = 'Wi-Fi'): Promise<string | null> {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Retrieve the local IP address of the specified network interface on Windows.\n *\n * @param interface The name of the network interface to check (default is \"Wi-Fi\").\n * @return The local IP address if found, otherwise std::nullopt.\n */\nusing OptionalString = std::optional<std::string>;\nOptionalString get_local_ip(const std::string& interface = \"Wi-Fi\") {}", "test_code": "TEST_CASE(\"Test Get Local IP\", \"[get_local_ip]\") {\n    SECTION(\"Local IP Found\") {\n        // Mock the output of ipconfig for a case where a local IP is found\n        std::istringstream mock_output(\"192.168.1.10\\n\");\n        std::streambuf* old_cout = std::cout.rdbuf(mock_output.rdbuf());\n\n        OptionalString result = get_local_ip();\n        REQUIRE(result.has_value());\n        REQUIRE(*result == \"192.168.1.10\");\n\n        std::cout.rdbuf(old_cout); // Restore the original stream buffer\n    }\n\n    SECTION(\"No Local IP Found\") {\n        // Mock the output of ipconfig for a case where no local IP is found\n        std::istringstream mock_output(\"10.0.0.5\\n\");\n        std::streambuf* old_cout = std::cout.rdbuf(mock_output.rdbuf());\n\n        OptionalString result = get_local_ip();\n        REQUIRE(!result.has_value());\n\n        std::cout.rdbuf(old_cout); // Restore the original stream buffer\n    }\n\n    SECTION(\"Multiple IPs Found\") {\n        // Mock the output with multiple local IPs\n        std::istringstream mock_output(\"10.0.0.5\\n192.168.1.10\\n\");\n        std::streambuf* old_cout = std::cout.rdbuf(mock_output.rdbuf());\n\n        OptionalString result = get_local_ip();\n        REQUIRE(result.has_value());\n        REQUIRE(*result == \"192.168.1.10\");\n\n        std::cout.rdbuf(old_cout); // Restore the original stream buffer\n    }\n\n    SECTION(\"Invalid Command\") {\n        // Simulate a case where CreateProcessA fails\n        std::istringstream mock_output(\"\");\n        std::streambuf* old_cout = std::cout.rdbuf(mock_output.rdbuf());\n\n        OptionalString result = get_local_ip();\n        REQUIRE(!result.has_value());\n\n        std::cout.rdbuf(old_cout); // Restore the original stream buffer\n    }\n\n    SECTION(\"Unexpected Error\") {\n        // Simulate an unexpected error\n        std::istringstream mock_output(\"\");\n        std::streambuf* old_cout = std::cout.rdbuf(mock_output.rdbuf());\n\n        OptionalString result = get_local_ip();\n        REQUIRE(!result.has_value());\n\n        std::cout.rdbuf(old_cout); // Restore the original stream buffer\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Retrieve the local IP address of the specified network interface on Windows.\n *\n * @param interface The name of the network interface to check (default is \"Wi-Fi\").\n * @return The local IP address if found, otherwise std::nullopt.\n */\nusing OptionalString = std::optional<std::string>;\nOptionalString get_local_ip(const std::string& interface = \"Wi-Fi\") {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Retrieve the local IP address of the specified network interface on Windows.\n *\n * @param interfaceName The name of the network interface to check (default is \"Wi-Fi\").\n * @return The local IP address if found, otherwise null.\n */\npublic static String getLocalIp(String interfaceName) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.mockito.Mockito.when;\nimport static org.mockito.Mockito.doThrow;\n\npublic class Tester {\n\n    @Mock\n    private Process processMock;\n\n    private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();\n\n    @BeforeEach\n    public void setUp() {\n        MockitoAnnotations.openMocks(this);\n        System.setOut(new PrintStream(outContent));\n    }\n\n    @Test\n    public void testLocalIpFound() throws IOException {\n        // Mock the output of ipconfig for a case where a local IP is found\n        when(Runtime.getRuntime().exec(\"ipconfig\")).thenReturn(processMock);\n        when(processMock.getInputStream()).thenReturn(new ByteArrayInputStream(\"192.168.1.10\\n\".getBytes()));\n\n        String result = getLocalIp();\n        assertEquals(\"192.168.1.10\", result);\n    }\n\n    @Test\n    public void testNoLocalIpFound() throws IOException {\n        // Mock the output of ipconfig for a case where no local IP is found\n        when(Runtime.getRuntime().exec(\"ipconfig\")).thenReturn(processMock);\n        when(processMock.getInputStream()).thenReturn(new ByteArrayInputStream(\"10.0.0.5\\n\".getBytes()));\n\n        String result = getLocalIp();\n        assertNull(result);\n    }\n\n    @Test\n    public void testMultipleIpsFound() throws IOException {\n        // Mock the output with multiple local IPs\n        when(Runtime.getRuntime().exec(\"ipconfig\")).thenReturn(processMock);\n        when(processMock.getInputStream()).thenReturn(new ByteArrayInputStream(\"10.0.0.5\\n192.168.1.10\\n\".getBytes()));\n\n        String result = getLocalIp();\n        assertEquals(\"192.168.1.10\", result);\n    }\n\n    @Test\n    public void testInvalidCommand() {\n        // Simulate a case where subprocess.run raises a CalledProcessError\n        doThrow(new IOException(\"CalledProcessError\")).when(Runtime.getRuntime()).exec(\"ipconfig\");\n\n        String result = getLocalIp();\n        assertNull(result);\n    }\n\n    @Test\n    public void testUnexpectedError() {\n        // Simulate an unexpected error\n        doThrow(new RuntimeException(\"Unexpected error\")).when(Runtime.getRuntime()).exec(\"ipconfig\");\n\n        String result = getLocalIp();\n        assertNull(result);\n    }\n\n    // Utility method to simulate the getLocalIp method\n    private String getLocalIp() {\n        try {\n            // Execute the 'ipconfig' command to get addresses for the specified interface\n            Process process = Runtime.getRuntime().exec(\"ipconfig\");\n            StringBuilder output = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n\n            // Regular expression to match IPv4 addresses\n            Pattern ipPattern = Pattern.compile(\"(\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+)\");\n\n            // Search for IP addresses in the command output\n            Matcher matcher = ipPattern.matcher(output.toString());\n            while (matcher.find()) {\n                String ip = matcher.group(1);\n                if (ip.startsWith(\"192.168.\")) {\n                    return ip; // Return the first local IP found\n                }\n            }\n\n            return null; // Return null if no suitable IP is found\n\n        } catch (IOException e) {\n            System.out.println(\"Error executing command: \" + e.getMessage());\n            return null;\n        } catch (Exception e) {\n            System.out.println(\"An unexpected error occurred: \" + e.getMessage());\n            return null;\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Retrieve the local IP address of the specified network interface on Windows.\n *\n * @param interfaceName The name of the network interface to check (default is \"Wi-Fi\").\n * @return The local IP address if found, otherwise null.\n */\npublic static String getLocalIp(String interfaceName) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 490, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "    Formats a string by prepending '> ' to each line and ensuring proper\n    formatting of code blocks.", "language_version_list": {"python": {"code_signature": "def format_str_2_markdown(x: str) -> str:\n    \"\"\"\n    Formats a string by prepending '> ' to each line and ensuring proper\n    formatting of code blocks.\n\n    Args:\n        x (str): The input string to be formatted. If the input is not a\n        string, it will be converted to one.\n\n    Returns:\n        str: The formatted string with each line prefixed by '> ' and\n        with balanced code block delimiters.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFormatStr(unittest.TestCase):\n\n    def test_simple_string(self):\n        \"\"\"Test a simple string input.\"\"\"\n        input_str = \"Hello, World!\"\n        expected_output = \"> Hello, World!\"\n        self.assertEqual(format_str_2_markdown(input_str), expected_output)\n\n    def test_multiline_string(self):\n        \"\"\"Test a multiline string input.\"\"\"\n        input_str = \"Line 1\\nLine 2\\nLine 3\"\n        expected_output = \"> Line 1\\n> Line 2\\n> Line 3\"\n        self.assertEqual(format_str_2_markdown(input_str), expected_output)\n\n    def test_code_block_delimiters_even(self):\n        \"\"\"Test a string with an even number of code block delimiters.\"\"\"\n        input_str = \"Some code:\\n```\\nprint('Hello')\\n```\"\n        expected_output = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\"\n        self.assertEqual(format_str_2_markdown(input_str), expected_output)\n\n    def test_code_block_delimiters_odd(self):\n        \"\"\"Test a string with an odd number of code block delimiters.\"\"\"\n        input_str = \"Some code:\\n```\\nprint('Hello')\"\n        expected_output = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\"\n        self.assertEqual(format_str_2_markdown(input_str), expected_output)\n\n    def test_non_string_input(self):\n        \"\"\"Test non-string input (e.g., integer) to ensure it's converted.\"\"\"\n        input_value = 123\n        expected_output = \"> 123\"\n        self.assertEqual(format_str_2_markdown(input_value), expected_output)", "prompt": "please write a python function , the function signature as below def format_str_2_markdown(x: str) -> str:\n    \"\"\"\n    Formats a string by prepending '> ' to each line and ensuring proper\n    formatting of code blocks.\n\n    Args:\n        x (str): The input string to be formatted. If the input is not a\n        string, it will be converted to one.\n\n    Returns:\n        str: The formatted string with each line prefixed by '> ' and\n        with balanced code block delimiters.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Formats a string by prepending '> ' to each line and ensuring proper\n * formatting of code blocks.\n *\n * @param {string} x - The input string to be formatted. If the input is not a\n *                     string, it will be converted to one.\n * @returns {string} - The formatted string with each line prefixed by '> ' and\n *                     with balanced code block delimiters.\n */\nfunction formatStr(x) {\n\n}", "test_code": "describe('TestFormatStr', () => {\n    it('test_simple_string', () => {\n        // Test a simple string input.\n        const inputStr = \"Hello, World!\";\n        const expectedOutput = \"> Hello, World!\";\n        expect(formatStr(inputStr)).toBe(expectedOutput);\n    });\n\n    it('test_multiline_string', () => {\n        // Test a multiline string input.\n        const inputStr = \"Line 1\\nLine 2\\nLine 3\";\n        const expectedOutput = \"> Line 1\\n> Line 2\\n> Line 3\";\n        expect(formatStr(inputStr)).toBe(expectedOutput);\n    });\n\n    it('test_code_block_delimiters_even', () => {\n        // Test a string with an even number of code block delimiters.\n        const inputStr = \"Some code:\\n```\\nprint('Hello')\\n```\";\n        const expectedOutput = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\";\n        expect(formatStr(inputStr)).toBe(expectedOutput);\n    });\n\n    it('test_code_block_delimiters_odd', () => {\n        // Test a string with an odd number of code block delimiters.\n        const inputStr = \"Some code:\\n```\\nprint('Hello')\";\n        const expectedOutput = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\";\n        expect(formatStr(inputStr)).toBe(expectedOutput);\n    });\n\n    it('test_non_string_input', () => {\n        // Test non-string input (e.g., integer) to ensure it's converted.\n        const inputValue = 123;\n        const expectedOutput = \"> 123\";\n        expect(formatStr(inputValue)).toBe(expectedOutput);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Formats a string by prepending '> ' to each line and ensuring proper\n * formatting of code blocks.\n *\n * @param {string} x - The input string to be formatted. If the input is not a\n *                     string, it will be converted to one.\n * @returns {string} - The formatted string with each line prefixed by '> ' and\n *                     with balanced code block delimiters.\n */\nfunction formatStr(x) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Formats a string by prepending '> ' to each line and ensuring proper\n * formatting of code blocks.\n *\n * @param {string} x - The input string to be formatted. If the input is not a\n *                     string, it will be converted to one.\n * @returns {string} - The formatted string with each line prefixed by '> ' and\n *                     with balanced code block delimiters.\n */\nfunction formatStr(x: any): string {\n\n}", "test_code": "describe('TestFormatStr', () => {\n  it('test simple string', () => {\n    /** Test a simple string input. */\n    const inputStr = \"Hello, World!\";\n    const expectedOutput = \"> Hello, World!\";\n    expect(formatStr(inputStr)).toEqual(expectedOutput);\n  });\n\n  it('test multiline string', () => {\n    /** Test a multiline string input. */\n    const inputStr = \"Line 1\\nLine 2\\nLine 3\";\n    const expectedOutput = \"> Line 1\\n> Line 2\\n> Line 3\";\n    expect(formatStr(inputStr)).toEqual(expectedOutput);\n  });\n\n  it('test code block delimiters even', () => {\n    /** Test a string with an even number of code block delimiters. */\n    const inputStr = \"Some code:\\n```\\nprint('Hello')\\n```\";\n    const expectedOutput = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\";\n    expect(formatStr(inputStr)).toEqual(expectedOutput);\n  });\n\n  it('test code block delimiters odd', () => {\n    /** Test a string with an odd number of code block delimiters. */\n    const inputStr = \"Some code:\\n```\\nprint('Hello')\";\n    const expectedOutput = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\";\n    expect(formatStr(inputStr)).toEqual(expectedOutput);\n  });\n\n  it('test non-string input', () => {\n    /** Test non-string input (e.g., integer) to ensure it's converted. */\n    const inputValue = 123;\n    const expectedOutput = \"> 123\";\n    expect(formatStr(inputValue)).toEqual(expectedOutput);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Formats a string by prepending '> ' to each line and ensuring proper\n * formatting of code blocks.\n *\n * @param {string} x - The input string to be formatted. If the input is not a\n *                     string, it will be converted to one.\n * @returns {string} - The formatted string with each line prefixed by '> ' and\n *                     with balanced code block delimiters.\n */\nfunction formatStr(x: any): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Formats a string by prepending '> ' to each line and ensuring proper\n * formatting of code blocks.\n *\n * @param x The input string to be formatted. If the input is not a\n *          string, it will be converted to one.\n * @return The formatted string with each line prefixed by '> ' and\n *         with balanced code block delimiters.\n */\nstd::string format_str(const std::string& x) {}", "test_code": "TEST_CASE(\"Test a simple string input\", \"[format_str]\") {\n    std::string input_str = \"Hello, World!\";\n    std::string expected_output = \"> Hello, World!\";\n    REQUIRE(format_str(input_str) == expected_output);\n}\n\nTEST_CASE(\"Test a multiline string input\", \"[format_str]\") {\n    std::string input_str = \"Line 1\\nLine 2\\nLine 3\";\n    std::string expected_output = \"> Line 1\\n> Line 2\\n> Line 3\";\n    REQUIRE(format_str(input_str) == expected_output);\n}\n\nTEST_CASE(\"Test a string with an even number of code block delimiters\", \"[format_str]\") {\n    std::string input_str = \"Some code:\\n```\\nprint('Hello')\\n```\";\n    std::string expected_output = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\";\n    REQUIRE(format_str(input_str) == expected_output);\n}\n\nTEST_CASE(\"Test a string with an odd number of code block delimiters\", \"[format_str]\") {\n    std::string input_str = \"Some code:\\n```\\nprint('Hello')\";\n    std::string expected_output = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\";\n    REQUIRE(format_str(input_str) == expected_output);\n}\n\nTEST_CASE(\"Test non-string input (e.g., integer) to ensure it's converted\", \"[format_str]\") {\n    int input_value = 123;\n    std::string expected_output = \"> 123\";\n    REQUIRE(format_str(std::to_string(input_value)) == expected_output);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Formats a string by prepending '> ' to each line and ensuring proper\n * formatting of code blocks.\n *\n * @param x The input string to be formatted. If the input is not a\n *          string, it will be converted to one.\n * @return The formatted string with each line prefixed by '> ' and\n *         with balanced code block delimiters.\n */\nstd::string format_str(const std::string& x) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Formats a string by prepending '> ' to each line and ensuring proper\n * formatting of code blocks.\n *\n * @param x The input string to be formatted. If the input is not a string,\n *          it will be converted to one.\n * @return The formatted string with each line prefixed by '> ' and\n *         with balanced code block delimiters.\n */\npublic static String formatStr(Object x) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for the formatStr method.\n */\npublic class Tester {\n\n    /**\n     * Tests a simple string input.\n     */\n    @Test\n    public void testSimpleString() {\n        String inputStr = \"Hello, World!\";\n        String expectedOutput = \"> Hello, World!\";\n        assertEquals(expectedOutput, formatStr(inputStr));\n    }\n\n    /**\n     * Tests a multiline string input.\n     */\n    @Test\n    public void testMultilineString() {\n        String inputStr = \"Line 1\\nLine 2\\nLine 3\";\n        String expectedOutput = \"> Line 1\\n> Line 2\\n> Line 3\";\n        assertEquals(expectedOutput, formatStr(inputStr));\n    }\n\n    /**\n     * Tests a string with an even number of code block delimiters.\n     */\n    @Test\n    public void testCodeBlockDelimitersEven() {\n        String inputStr = \"Some code:\\n```\\nprint('Hello')\\n```\";\n        String expectedOutput = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\";\n        assertEquals(expectedOutput, formatStr(inputStr));\n    }\n\n    /**\n     * Tests a string with an odd number of code block delimiters.\n     */\n    @Test\n    public void testCodeBlockDelimitersOdd() {\n        String inputStr = \"Some code:\\n```\\nprint('Hello')\";\n        String expectedOutput = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\";\n        assertEquals(expectedOutput, formatStr(inputStr));\n    }\n\n    /**\n     * Tests non-string input (e.g., integer) to ensure it's converted.\n     */\n    @Test\n    public void testNonStringInput() {\n        Object inputValue = 123;\n        String expectedOutput = \"> 123\";\n        assertEquals(expectedOutput, formatStr(inputValue));\n    }\n\n    // The formatStr method implementation\n    private String formatStr(Object x) {\n        // Convert x to string if it's not already a string.\n        String str = x.toString();\n\n        // Ensure there is a matching number of code block delimiters.\n        // If the count of delimiters is odd, append an additional one to balance.\n        int delimiterCount = str.length() - str.replace(\"```\", \"\").length();\n        if (delimiterCount % 2 == 1) {\n            str += \"\\n```\";\n        }\n\n        // Format each line by prepending '> ' and join them with newlines.\n        String[] lines = str.split(\"\\n\");\n        StringBuilder formattedLines = new StringBuilder();\n        for (String line : lines) {\n            formattedLines.append(\"> \").append(line).append(\"\\n\");\n        }\n\n        // Return the final formatted string.\n        return formattedLines.toString();\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Formats a string by prepending '> ' to each line and ensuring proper\n * formatting of code blocks.\n *\n * @param x The input string to be formatted. If the input is not a string,\n *          it will be converted to one.\n * @return The formatted string with each line prefixed by '> ' and\n *         with balanced code block delimiters.\n */\npublic static String formatStr(Object x) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 491, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "    Convert a value in the range [0, 1] to an RGB color that transitions \n    from red to yellow and then from yellow to green.", "language_version_list": {"python": {"code_signature": "def convert_range_to_color_yellow_green_change(value: float) -> tuple:\n    \"\"\"\n    Convert a value in the range [0, 1] to an RGB color that transitions\n    from red to yellow and then from yellow to green.\n\n    Parameters:\n        value (float): A float value in the range [0, 1] representing the\n                       interpolation position.\n\n    Returns:\n        tuple: A tuple containing the RGB color values (red, green, blue).\n    \"\"\"\n\n    # Scale the input value from the range [0, 1] to [0, 255]\n", "test_code": "import unittest\nclass TestConvertToColorThroughYellow(unittest.TestCase):\n    \n    def test_red(self):\n        \"\"\"Test the output for value 0.0 (should be red)\"\"\"\n        self.assertEqual(convert_to_color_through_yellow(0.0), (255, 127.5, 127.5))\n\n    def test_yellow(self):\n        \"\"\"Test the output for value 0.5 (should be yellow)\"\"\"\n        self.assertEqual(convert_to_color_through_yellow(0.5), (255, 255, 127.5))\n\n    def test_green(self):\n        \"\"\"Test the output for value 1.0 (should be green)\"\"\"\n        self.assertEqual(convert_to_color_through_yellow(1.0), (0, 255, 127.5))\n\n    def test_mid_transition(self):\n        \"\"\"Test the output for value 0.25 (between red and yellow)\"\"\"\n        self.assertEqual(convert_to_color_through_yellow(0.25), (255, 191, 127.5))\n\n    def test_yellow_transition(self):\n        \"\"\"Test the output for value 0.75 (between yellow and green)\"\"\"\n        self.assertEqual(convert_to_color_through_yellow(0.75), (127, 255, 127.5))", "prompt": "please write a python function , the function signature as below def convert_range_to_color_yellow_green_change(value: float) -> tuple:\n    \"\"\"\n    Convert a value in the range [0, 1] to an RGB color that transitions\n    from red to yellow and then from yellow to green.\n\n    Parameters:\n        value (float): A float value in the range [0, 1] representing the\n                       interpolation position.\n\n    Returns:\n        tuple: A tuple containing the RGB color values (red, green, blue).\n    \"\"\"\n\n    # Scale the input value from the range [0, 1] to [0, 255]\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 492, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "    Saves the provided content to a specified file after cleaning up\n    redundant whitespace.", "language_version_list": {"python": {"code_signature": "def save_content_to_file(content: str, path: str) -> None:\n    \"\"\"\n    Saves the provided content to a specified file after cleaning up\n    redundant whitespace.\n\n    Args:\n        content (str): The text content to be saved to the file.\n        path (str): The file path where the content will be saved.\n\n    Returns:\n        None\n    \"\"\"", "test_code": "import os\nimport unittest\n\n\nclass TestSaveContentToFile(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up a temporary file path for testing.\"\"\"\n        self.test_file_path = 'test_output.txt'\n\n    def tearDown(self):\n        \"\"\"Clean up the test file after each test.\"\"\"\n        if os.path.exists(self.test_file_path):\n            os.remove(self.test_file_path)\n\n    def test_basic_content(self):\n        \"\"\"Test with basic content and check if it saves correctly.\"\"\"\n        content = \"Hello,  World!  \"\n        expected = \"Hello, World!\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)\n\n    def test_multiple_spaces_and_empty_lines(self):\n        \"\"\"Test handling of multiple spaces and empty lines.\"\"\"\n        content = \"\"\"\n\n        This is a    test.\n\n        Another line.      \n        \"\"\"\n        expected = \"This is a test. Another line.\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)\n\n    def test_only_whitespace(self):\n        \"\"\"Test if only whitespace is handled correctly.\"\"\"\n        content = \"    \\n  \\n   \"\n        expected = \"\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)\n\n    def test_empty_content(self):\n        \"\"\"Test if empty content is saved correctly.\"\"\"\n        content = \"\"\n        expected = \"\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def save_content_to_file(content: str, path: str) -> None:\n    \"\"\"\n    Saves the provided content to a specified file after cleaning up\n    redundant whitespace.\n\n    Args:\n        content (str): The text content to be saved to the file.\n        path (str): The file path where the content will be saved.\n\n    Returns:\n        None\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Saves the provided content to a specified file after cleaning up\n * redundant whitespace.\n *\n * @param {string} content - The text content to be saved to the file.\n * @param {string} path - The file path where the content will be saved.\n */\nfunction saveContentToFile(content, path) {\n\n}", "test_code": "describe('TestSaveContentToFile', () => {\n    let testFilePath = 'test_output.txt';\n\n    beforeAll(() => {\n        // Set up a temporary file path for testing\n        testFilePath = 'test_output.txt';\n    });\n\n    afterAll(() => {\n        // Clean up the test file after all tests\n        if (fs.existsSync(testFilePath)) {\n            fs.unlinkSync(testFilePath);\n        }\n    });\n\n    beforeEach(() => {\n        // Ensure the test file is clean before each test\n        if (fs.existsSync(testFilePath)) {\n            fs.unlinkSync(testFilePath);\n        }\n    });\n\n    afterEach(() => {\n        // Clean up the test file after each test\n        if (fs.existsSync(testFilePath)) {\n            fs.unlinkSync(testFilePath);\n        }\n    });\n\n    it('should save basic content correctly', () => {\n        const content = \"Hello,  World!  \";\n        const expected = \"Hello, World!\";\n        saveContentToFile(content, testFilePath);\n        const result = fs.readFileSync(testFilePath, 'utf-8').trim();\n        expect(result).toEqual(expected);\n    });\n\n    it('should handle multiple spaces and empty lines correctly', () => {\n        const content = `\n\n        This is a    test.\n\n        Another line.      \n        `;\n        const expected = \"This is a test. Another line.\";\n        saveContentToFile(content, testFilePath);\n        const result = fs.readFileSync(testFilePath, 'utf-8').trim();\n        expect(result).toEqual(expected);\n    });\n\n    it('should handle only whitespace correctly', () => {\n        const content = \"    \\n  \\n   \";\n        const expected = \"\";\n        saveContentToFile(content, testFilePath);\n        const result = fs.readFileSync(testFilePath, 'utf-8').trim();\n        expect(result).toEqual(expected);\n    });\n\n    it('should handle empty content correctly', () => {\n        const content = \"\";\n        const expected = \"\";\n        saveContentToFile(content, testFilePath);\n        const result = fs.readFileSync(testFilePath, 'utf-8').trim();\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Saves the provided content to a specified file after cleaning up\n * redundant whitespace.\n *\n * @param {string} content - The text content to be saved to the file.\n * @param {string} path - The file path where the content will be saved.\n */\nfunction saveContentToFile(content, path) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Saves the provided content to a specified file after cleaning up redundant whitespace.\n *\n * @param content - The text content to be saved to the file.\n * @param path - The file path where the content will be saved.\n */\nfunction saveContentToFile(content: string, path: string): void {\n\n}", "test_code": "import * as fs from 'fs';\n\ndescribe('TestSaveContentToFile', () => {\n    let testFilePath: string;\n\n    beforeEach(() => {\n        // Set up a temporary file path for testing\n        testFilePath = 'test_output.txt';\n    });\n\n    afterEach(() => {\n        // Clean up the test file after each test\n        if (fs.existsSync(testFilePath)) {\n            fs.unlinkSync(testFilePath);\n        }\n    });\n\n    it('should save basic content correctly', () => {\n        const content = \"Hello,  World!  \";\n        const expected = \"Hello, World!\";\n        saveContentToFile(content, testFilePath);\n\n        const result = fs.readFileSync(testFilePath, 'utf-8').trim();\n        expect(result).toEqual(expected);\n    });\n\n    it('should handle multiple spaces and empty lines correctly', () => {\n        const content = `\n\n        This is a    test.\n\n        Another line.      \n        `;\n        const expected = \"This is a test. Another line.\";\n        saveContentToFile(content, testFilePath);\n\n        const result = fs.readFileSync(testFilePath, 'utf-8').trim();\n        expect(result).toEqual(expected);\n    });\n\n    it('should handle only whitespace correctly', () => {\n        const content = \"    \\n  \\n   \";\n        const expected = \"\";\n        saveContentToFile(content, testFilePath);\n\n        const result = fs.readFileSync(testFilePath, 'utf-8').trim();\n        expect(result).toEqual(expected);\n    });\n\n    it('should handle empty content correctly', () => {\n        const content = \"\";\n        const expected = \"\";\n        saveContentToFile(content, testFilePath);\n\n        const result = fs.readFileSync(testFilePath, 'utf-8').trim();\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Saves the provided content to a specified file after cleaning up redundant whitespace.\n *\n * @param content - The text content to be saved to the file.\n * @param path - The file path where the content will be saved.\n */\nfunction saveContentToFile(content: string, path: string): void {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Saves the provided content to a specified file after cleaning up\n * redundant whitespace.\n *\n * @param content The text content to be saved to the file.\n * @param path The file path where the content will be saved.\n */\nvoid save_content_to_file(const std::string& content, const std::string& path) {}", "test_code": "TEST_CASE(\"TestSaveContentToFile\", \"[save_content_to_file]\") {\n    const std::string test_file_path = \"test_output.txt\";\n\n    SECTION(\"Basic content\") {\n        std::string content = \"Hello,  World!  \";\n        std::string expected = \"Hello, World!\";\n        save_content_to_file(content, test_file_path);\n\n        std::ifstream file(test_file_path);\n        REQUIRE(file.is_open());\n        std::string result((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        file.close();\n\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Multiple spaces and empty lines\") {\n        std::string content = R\"(\n        \n        This is a    test.\n\n        Another line.      \n        )\";\n        std::string expected = \"This is a test. Another line.\";\n        save_content_to_file(content, test_file_path);\n\n        std::ifstream file(test_file_path);\n        REQUIRE(file.is_open());\n        std::string result((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        file.close();\n\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Only whitespace\") {\n        std::string content = \"    \\n  \\n   \";\n        std::string expected = \"\";\n        save_content_to_file(content, test_file_path);\n\n        std::ifstream file(test_file_path);\n        REQUIRE(file.is_open());\n        std::string result((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        file.close();\n\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Empty content\") {\n        std::string content = \"\";\n        std::string expected = \"\";\n        save_content_to_file(content, test_file_path);\n\n        std::ifstream file(test_file_path);\n        REQUIRE(file.is_open());\n        std::string result((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        file.close();\n\n        REQUIRE(result == expected);\n    }\n\n    // Clean up the test file after all sections\n    if (fs::exists(test_file_path)) {\n        fs::remove(test_file_path);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Saves the provided content to a specified file after cleaning up\n * redundant whitespace.\n *\n * @param content The text content to be saved to the file.\n * @param path The file path where the content will be saved.\n */\nvoid save_content_to_file(const std::string& content, const std::string& path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Saves the provided content to a specified file after cleaning up redundant whitespace.\n *\n * @param content The text content to be saved to the file.\n * @param path    The file path where the content will be saved.\n */\npublic static void saveContentToFile(String content, String path) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Tester {\n\n    private static final String TEST_FILE_PATH = \"test_output.txt\";\n\n    @Before\n    public void setUp() {\n        // Set up a temporary file path for testing.\n    }\n\n    @After\n    public void tearDown() {\n        // Clean up the test file after each test.\n        File file = new File(TEST_FILE_PATH);\n        if (file.exists()) {\n            file.delete();\n        }\n    }\n\n    @Test\n    public void testBasicContent() throws IOException {\n        // Test with basic content and check if it saves correctly.\n        String content = \"Hello,  World!  \";\n        String expected = \"Hello, World!\";\n        saveContentToFile(content, TEST_FILE_PATH);\n\n        try (FileReader reader = new FileReader(TEST_FILE_PATH)) {\n            char[] buffer = new char[1024];\n            int length = reader.read(buffer);\n            String result = new String(buffer, 0, length).trim();\n            assertEquals(expected, result);\n        }\n    }\n\n    @Test\n    public void testMultipleSpacesAndEmptyLines() throws IOException {\n        // Test handling of multiple spaces and empty lines.\n        String content = \"\\n\\n\\nThis is a    test.\\n\\nAnother line.      \\n\";\n        String expected = \"This is a test. Another line.\";\n        saveContentToFile(content, TEST_FILE_PATH);\n\n        try (FileReader reader = new FileReader(TEST_FILE_PATH)) {\n            char[] buffer = new char[1024];\n            int length = reader.read(buffer);\n            String result = new String(buffer, 0, length).trim();\n            assertEquals(expected, result);\n        }\n    }\n\n    @Test\n    public void testOnlyWhitespace() throws IOException {\n        // Test if only whitespace is handled correctly.\n        String content = \"    \\n  \\n   \";\n        String expected = \"\";\n        saveContentToFile(content, TEST_FILE_PATH);\n\n        try (FileReader reader = new FileReader(TEST_FILE_PATH)) {\n            char[] buffer = new char[1024];\n            int length = reader.read(buffer);\n            String result = new String(buffer, 0, length).trim();\n            assertEquals(expected, result);\n        }\n    }\n\n    @Test\n    public void testEmptyContent() throws IOException {\n        // Test if empty content is saved correctly.\n        String content = \"\";\n        String expected = \"\";\n        saveContentToFile(content, TEST_FILE_PATH);\n\n        try (FileReader reader = new FileReader(TEST_FILE_PATH)) {\n            char[] buffer = new char[1024];\n            int length = reader.read(buffer);\n            String result = new String(buffer, 0, length).trim();\n            assertEquals(expected, result);\n        }\n    }\n\n    // Utility method to save content to a file\n    private void saveContentToFile(String content, String path) {\n        // Remove redundant whitespace from the content.\n        // Split the content into lines, strip leading/trailing whitespace,\n        // and filter out empty lines.\n        content = String.join(\"\\n\",\n            content.lines()\n                   .filter(line -> !line.trim().isEmpty())\n                   .map(String::trim)\n                   .toArray(String[]::new));\n\n        // Replace multiple spaces with a single space.\n        content = content.replaceAll(\"\\\\s+\", \" \").trim();\n\n        // Write the cleaned content to the specified file.\n        try (FileWriter writer = new FileWriter(path, false)) {\n            writer.write(content);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Saves the provided content to a specified file after cleaning up redundant whitespace.\n *\n * @param content The text content to be saved to the file.\n * @param path    The file path where the content will be saved.\n */\npublic static void saveContentToFile(String content, String path) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 493, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Wrap the text content to the specified maximum width and generate these lines line by line\n", "language_version_list": {"python": {"code_signature": "import textwrap\n\n\ndef wrap_content_generator(content: str, width=80):\n    \"\"\"\n    Wrap the text content to the specified maximum width and generate these lines line by line\n\n    Args:\n        content (str): The content to be wrapped and yielded line by line.\n        width (str): The maximum width of the lines, default is 80 characters.\n\n    Yields:\n        str: Each line of the content wrapped to the specified width.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestWrapContentGenerator(unittest.TestCase):\n\n    def test_empty_content(self):\n        \"\"\"Test with empty content.\"\"\"\n        result = list(wrap_content_generator(\"\"))\n        self.assertEqual(result, [])\n\n    def test_single_line_content(self):\n        \"\"\"Test with a single line of content within default width.\"\"\"\n        result = list(wrap_content_generator(\"Hello, world!\"))\n        self.assertEqual(result, [\"Hello, world!\"])\n\n    def test_multi_line_content(self):\n        \"\"\"Test with multiple lines of content each fitting within default width.\"\"\"\n        content = \"Hello\\nWorld\\nPython\"\n        result = list(wrap_content_generator(content))\n        self.assertEqual(result, [\"Hello\", \"World\", \"Python\"])\n\n    def test_long_line(self):\n        \"\"\"Test with a single long line that exceeds the default width.\"\"\"\n        content = \"This is a very long line that should definitely be wrapped around the default width of 80 characters.\"\n        result = list(wrap_content_generator(content))\n        self.assertTrue(len(max(result, key=len)) <= 80)\n\n    def test_custom_width(self):\n        \"\"\"Test with a custom width.\"\"\"\n        content = \"This is a test for custom width setting.\"\n        result = list(wrap_content_generator(content, width=10))\n        self.assertTrue(all(len(line) <= 10 for line in result))\n\n    def test_only_whitespaces(self):\n        \"\"\"Test content that contains only whitespace characters.\"\"\"\n        result = list(wrap_content_generator(\"     \"))\n        self.assertEqual(result, [\"\\n\"])", "prompt": "please write a python function , the function signature as below import textwrap\n\n\ndef wrap_content_generator(content: str, width=80):\n    \"\"\"\n    Wrap the text content to the specified maximum width and generate these lines line by line\n\n    Args:\n        content (str): The content to be wrapped and yielded line by line.\n        width (str): The maximum width of the lines, default is 80 characters.\n\n    Yields:\n        str: Each line of the content wrapped to the specified width.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Wrap the text content to the specified maximum width and generate these lines line by line.\n *\n * @param {string} content - The content to be wrapped and yielded line by line.\n * @param {number} [width=80] - The maximum width of the lines, default is 80 characters.\n *\n * @yields {string} Each line of the content wrapped to the specified width.\n */\nfunction* wrapContentGenerator(content, width = 80) {\n\n}", "test_code": "describe('TestWrapContentGenerator', () => {\n    it('test_empty_content', () => {\n        /** Test with empty content. */\n        const result = [...wrapContentGenerator(\"\")];\n        expect(result).toEqual([]);\n    });\n\n    it('test_single_line_content', () => {\n        /** Test with a single line of content within default width. */\n        const result = [...wrapContentGenerator(\"Hello, world!\")];\n        expect(result).toEqual([\"Hello, world!\"]);\n    });\n\n    it('test_multi_line_content', () => {\n        /** Test with multiple lines of content each fitting within default width. */\n        const content = \"Hello\\nWorld\\nPython\";\n        const result = [...wrapContentGenerator(content)];\n        expect(result).toEqual([\"Hello\", \"World\", \"Python\"]);\n    });\n\n    it('test_long_line', () => {\n        /** Test with a single long line that exceeds the default width. */\n        const content = \"This is a very long line that should definitely be wrapped around the default width of 80 characters.\";\n        const result = [...wrapContentGenerator(content)];\n        const longestLine = result.reduce((a, b) => a.length > b.length ? a : b, '');\n        expect(longestLine.length).toBeLessThanOrEqual(80);\n    });\n\n    it('test_custom_width', () => {\n        /** Test with a custom width. */\n        const content = \"This is a test for custom width setting.\";\n        const result = [...wrapContentGenerator(content, 10)];\n        expect(result.every(line => line.length <= 10)).toBeTruthy();\n    });\n\n    it('test_only_whitespaces', () => {\n        /** Test content that contains only whitespace characters. */\n        const result = [...wrapContentGenerator(\"     \")];\n        expect(result).toEqual([\"\\n\"]);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Wrap the text content to the specified maximum width and generate these lines line by line.\n *\n * @param {string} content - The content to be wrapped and yielded line by line.\n * @param {number} [width=80] - The maximum width of the lines, default is 80 characters.\n *\n * @yields {string} Each line of the content wrapped to the specified width.\n */\nfunction* wrapContentGenerator(content, width = 80) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "import { wrap } from 'textwrap';\n\n/**\n * Wrap the text content to the specified maximum width and generate these lines line by line.\n *\n * @param content - The content to be wrapped and yielded line by line.\n * @param width - The maximum width of the lines, default is 80 characters.\n * @yields Each line of the content wrapped to the specified width.\n */\nfunction* wrapContentGenerator(content: string, width: number = 80): Generator<string> {\n\n}", "test_code": "describe('wrapContentGenerator', () => {\n  it('should handle empty content', () => {\n    const result = Array.from(wrapContentGenerator(\"\"));\n    expect(result).toEqual([]);\n  });\n\n  it('should handle a single line of content within default width', () => {\n    const result = Array.from(wrapContentGenerator(\"Hello, world!\"));\n    expect(result).toEqual([\"Hello, world!\"]);\n  });\n\n  it('should handle multiple lines of content each fitting within default width', () => {\n    const content = \"Hello\\nWorld\\nPython\";\n    const result = Array.from(wrapContentGenerator(content));\n    expect(result).toEqual([\"Hello\", \"World\", \"Python\"]);\n  });\n\n  it('should handle a single long line that exceeds the default width', () => {\n    const content = \"This is a very long line that should definitely be wrapped around the default width of 80 characters.\";\n    const result = Array.from(wrapContentGenerator(content));\n    const longestLine = result.reduce((max, line) => line.length > max.length ? line : max, \"\");\n    expect(longestLine.length).toBeLessThanOrEqual(80);\n  });\n\n  it('should handle a custom width', () => {\n    const content = \"This is a test for custom width setting.\";\n    const result = Array.from(wrapContentGenerator(content, 10));\n    expect(result.every(line => line.length <= 10)).toBe(true);\n  });\n\n  it('should handle content that contains only whitespace characters', () => {\n    const result = Array.from(wrapContentGenerator(\"     \"));\n    expect(result).toEqual([\"\\n\"]);\n  });\n});", "prompt": "please write a typescript function , the function signature as below import { wrap } from 'textwrap';\n\n/**\n * Wrap the text content to the specified maximum width and generate these lines line by line.\n *\n * @param content - The content to be wrapped and yielded line by line.\n * @param width - The maximum width of the lines, default is 80 characters.\n * @yields Each line of the content wrapped to the specified width.\n */\nfunction* wrapContentGenerator(content: string, width: number = 80): Generator<string> {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Wraps the text content to the specified maximum width and generates lines one by one.\n *\n * @param content The content to be wrapped and yielded line by line.\n * @param width The maximum width of the lines. The default is 80 characters.\n *\n * @return Each line of the content wrapped to the specified width.\n */\nstd::string wrapText(const std::string &content, int width = 80);\n", "test_code": "TEST_CASE(\"TestWrapContentGenerator\", \"[wrap_content_generator]\") {\n    SECTION(\"test_empty_content\") {\n        std::vector<std::string> result;\n        wrap_content_generator(\"\", 80, [&result](const std::string &line) {\n            result.push_back(line);\n        });\n        REQUIRE(result == std::vector<std::string>({\"\\n\"}));\n    }\n\n    SECTION(\"test_single_line_content\") {\n        std::vector<std::string> result;\n        wrap_content_generator(\"Hello, world!\", 80, [&result](const std::string &line) {\n            result.push_back(line);\n        });\n        REQUIRE(result == std::vector<std::string>({\"Hello, world!\"}));\n    }\n\n    SECTION(\"test_multi_line_content\") {\n        std::vector<std::string> result;\n        std::string content = \"Hello\\nWorld\\nPython\";\n        wrap_content_generator(content, 80, [&result](const std::string &line) {\n            result.push_back(line);\n        });\n        REQUIRE(result == std::vector<std::string>({\"Hello\", \"World\", \"Python\"}));\n    }\n\n    SECTION(\"test_long_line\") {\n        std::vector<std::string> result;\n        std::string content = \"This is a very long line that should definitely be wrapped around the default width of 80 characters.\";\n        wrap_content_generator(content, 80, [&result](const std::string &line) {\n            result.push_back(line);\n        });\n        REQUIRE(std::all_of(result.begin(), result.end(), [](const std::string &line) {\n            return line.length() <= 80;\n        }));\n    }\n\n    SECTION(\"test_custom_width\") {\n        std::vector<std::string> result;\n        std::string content = \"This is a test for custom width setting.\";\n        wrap_content_generator(content, 10, [&result](const std::string &line) {\n            result.push_back(line);\n        });\n        REQUIRE(std::all_of(result.begin(), result.end(), [](const std::string &line) {\n            return line.length() <= 10;\n        }));\n    }\n\n    SECTION(\"test_only_whitespaces\") {\n        std::vector<std::string> result;\n        wrap_content_generator(\"     \", 80, [&result](const std::string &line) {\n            result.push_back(line);\n        });\n        REQUIRE(result == std::vector<std::string>({\"\\n\"}));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Wraps the text content to the specified maximum width and generates lines one by one.\n *\n * @param content The content to be wrapped and yielded line by line.\n * @param width The maximum width of the lines. The default is 80 characters.\n *\n * @return Each line of the content wrapped to the specified width.\n */\nstd::string wrapText(const std::string &content, int width = 80);\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Wrap the text content to the specified maximum width and return a list of wrapped lines.\n *\n * @param content The content to be wrapped and returned line by line.\n * @param width The maximum width of the lines, default is 80 characters.\n * @return A List containing each line of the content wrapped to the specified width.\n */\npublic static List<String> wrapContentGenerator(String content, int width) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testEmptyContent() {\n        List<String> result = wrapContentGenerator(\"\", 80);\n        assertEquals(result, List.of());\n    }\n\n    @Test\n    public void testSingleLineContent() {\n        List<String> result = wrapContentGenerator(\"Hello, world!\", 80);\n        assertEquals(result, List.of(\"Hello, world!\"));\n    }\n\n    @Test\n    public void testMultiLineContent() {\n        String content = \"Hello\\nWorld\\nPython\";\n        List<String> result = wrapContentGenerator(content, 80);\n        assertEquals(result, List.of(\"Hello\", \"World\", \"Python\"));\n    }\n\n    @Test\n    public void testLongLine() {\n        String content = \"This is a very long line that should definitely be wrapped around the default width of 80 characters.\";\n        List<String> result = wrapContentGenerator(content, 80);\n        assertTrue(result.stream().allMatch(line -> line.length() <= 80));\n    }\n\n    @Test\n    public void testCustomWidth() {\n        String content = \"This is a test for custom width setting.\";\n        List<String> result = wrapContentGenerator(content, 10);\n        assertTrue(result.stream().allMatch(line -> line.length() <= 10));\n    }\n\n    @Test\n    public void testOnlyWhitespaces() {\n        List<String> result = wrapContentGenerator(\"     \", 80);\n        assertEquals(result, List.of(\"\\n\"));\n    }\n\n    // Utility method to simulate the Python function\n    private List<String> wrapContentGenerator(String content, int width) {\n        return Answer.wrapContentGenerator(content, width);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Wrap the text content to the specified maximum width and return a list of wrapped lines.\n *\n * @param content The content to be wrapped and returned line by line.\n * @param width The maximum width of the lines, default is 80 characters.\n * @return A List containing each line of the content wrapped to the specified width.\n */\npublic static List<String> wrapContentGenerator(String content, int width) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 494, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Cleans the input dictionary by removing keys with invalid values.Valid values are non-NaN, non-None, and non-whitespace strings.", "language_version_list": {"python": {"code_signature": "from typing import Dict\n\n\ndef clean_dictionary(input_dict:Dict) -> Dict:\n    \"\"\"\n    Cleans the input dictionary by removing keys with invalid values.Valid values are non-NaN, non-None, and non-whitespace strings.\n\n    Args:\n        input_dict (Dict): A dictionary to be cleaned.\n\n    Returns:\n        Dict: A new dictionary containing only valid values.\n    \"\"\"", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestCleanDictionary(unittest.TestCase):\n\n    def test_valid_strings(self):\n        \"\"\" Test a dictionary with valid strings. \"\"\"\n        input_dict = {\n            'key1': 'valid string',\n            'key2': 'another valid string'\n        }\n        expected_output = {\n            'key1': 'valid string',\n            'key2': 'another valid string'\n        }\n        self.assertEqual(clean_dictionary(input_dict), expected_output)\n\n    def test_none_and(self):\n        \"\"\" Test a dictionary with None and NaN values. \"\"\"\n        input_dict = {\n            'key1': None,\n            'key3': 'valid string'\n        }\n        expected_output = {\n            'key3': 'valid string'\n        }\n        self.assertEqual(clean_dictionary(input_dict), expected_output)\n\n    def test_whitespace_strings(self):\n        \"\"\" Test a dictionary with whitespace strings. \"\"\"\n        input_dict = {\n            'key1': '   ',\n            'key2': '',\n            'key3': 'valid'\n        }\n        expected_output = {\n            'key3': 'valid'\n        }\n        self.assertEqual(clean_dictionary(input_dict), expected_output)\n\n    def test_empty_dictionary(self):\n        \"\"\" Test an empty dictionary. \"\"\"\n        input_dict = {}\n        expected_output = {}\n        self.assertEqual(clean_dictionary(input_dict), expected_output)\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef clean_dictionary(input_dict:Dict) -> Dict:\n    \"\"\"\n    Cleans the input dictionary by removing keys with invalid values.Valid values are non-NaN, non-None, and non-whitespace strings.\n\n    Args:\n        input_dict (Dict): A dictionary to be cleaned.\n\n    Returns:\n        Dict: A new dictionary containing only valid values.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Cleans the input object by removing keys with invalid values. Valid values are non-NaN, non-null, and non-whitespace strings.\n *\n * @param {Object} inputDict - An object to be cleaned.\n * @returns {Object} A new object containing only valid values.\n */\nfunction cleanDictionary(inputDict) {\n\n}", "test_code": "describe('TestCleanDictionary', () => {\n    describe('testValidStrings', () => {\n        it('should handle a dictionary with valid strings', () => {\n            const inputDict = {\n                'key1': 'valid string',\n                'key2': 'another valid string'\n            };\n            const expectedOutput = {\n                'key1': 'valid string',\n                'key2': 'another valid string'\n            };\n            expect(cleanDictionary(inputDict)).toEqual(expectedOutput);\n        });\n    });\n\n    describe('testNoneAndNaNValues', () => {\n        it('should handle a dictionary with None and NaN values', () => {\n            const inputDict = {\n                'key1': null,\n                'key3': 'valid string'\n            };\n            const expectedOutput = {\n                'key3': 'valid string'\n            };\n            expect(cleanDictionary(inputDict)).toEqual(expectedOutput);\n        });\n    });\n\n    describe('testWhitespaceStrings', () => {\n        it('should handle a dictionary with whitespace strings', () => {\n            const inputDict = {\n                'key1': '   ',\n                'key2': '',\n                'key3': 'valid'\n            };\n            const expectedOutput = {\n                'key3': 'valid'\n            };\n            expect(cleanDictionary(inputDict)).toEqual(expectedOutput);\n        });\n    });\n\n    describe('testEmptyDictionary', () => {\n        it('should handle an empty dictionary', () => {\n            const inputDict = {};\n            const expectedOutput = {};\n            expect(cleanDictionary(inputDict)).toEqual(expectedOutput);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Cleans the input object by removing keys with invalid values. Valid values are non-NaN, non-null, and non-whitespace strings.\n *\n * @param {Object} inputDict - An object to be cleaned.\n * @returns {Object} A new object containing only valid values.\n */\nfunction cleanDictionary(inputDict) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Cleans the input object by removing keys with invalid values.\n * Valid values are non-NaN, non-null, and non-whitespace strings.\n *\n * @param inputObj - An object to be cleaned.\n * @returns A new object containing only valid values.\n */\nfunction cleanObject(inputObj: Record<string, any>): Record<string, any> {\n\n}", "test_code": "describe('TestCleanDictionary', () => {\n  it('test valid strings', () => {\n    const inputDict = {\n      'key1': 'valid string',\n      'key2': 'another valid string'\n    };\n    const expectedOutput = {\n      'key1': 'valid string',\n      'key2': 'another valid string'\n    };\n    expect(cleanObject(inputDict)).toEqual(expectedOutput);\n  });\n\n  it('test None and NaN values', () => {\n    const inputDict = {\n      'key1': null,\n      'key3': 'valid string'\n    };\n    const expectedOutput = {\n      'key3': 'valid string'\n    };\n    expect(cleanObject(inputDict)).toEqual(expectedOutput);\n  });\n\n  it('test whitespace strings', () => {\n    const inputDict = {\n      'key1': '   ',\n      'key2': '',\n      'key3': 'valid'\n    };\n    const expectedOutput = {\n      'key3': 'valid'\n    };\n    expect(cleanObject(inputDict)).toEqual(expectedOutput);\n  });\n\n  it('test empty dictionary', () => {\n    const inputDict = {};\n    const expectedOutput = {};\n    expect(cleanObject(inputDict)).toEqual(expectedOutput);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Cleans the input object by removing keys with invalid values.\n * Valid values are non-NaN, non-null, and non-whitespace strings.\n *\n * @param inputObj - An object to be cleaned.\n * @returns A new object containing only valid values.\n */\nfunction cleanObject(inputObj: Record<string, any>): Record<string, any> {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Cleans the input dictionary by removing keys with invalid values.\n * Valid values are non-NaN, non-nullptr, and non-whitespace strings.\n *\n * @param input_dict A map to be cleaned.\n * @return A new map containing only valid values.\n */\nstd::map<std::string, std::string> clean_dictionary(const std::map<std::string, std::string>& input_dict) {\n\n}", "test_code": "#include <catch2/catch_test_macros.hpp>\n#include <map>\n#include <string>\n#include <cctype>\n\nTEST_CASE(\"Test clean_dictionary function\", \"[clean_dictionary]\") {\n    SECTION(\"Test a dictionary with valid strings\") {\n        std::map<std::string, std::string> input_dict = {\n            {\"key1\", \"valid string\"},\n            {\"key2\", \"another valid string\"}\n        };\n        std::map<std::string, std::string> expected_output = {\n            {\"key1\", \"valid string\"},\n            {\"key2\", \"another valid string\"}\n        };\n        REQUIRE(clean_dictionary(input_dict) == expected_output);\n    }\n\n    SECTION(\"Test a dictionary with None and NaN values\") {\n        std::map<std::string, std::string> input_dict = {\n            {\"key1\", \"\"},\n            {\"key3\", \"valid string\"}\n        };\n        std::map<std::string, std::string> expected_output = {\n            {\"key3\", \"valid string\"}\n        };\n        REQUIRE(clean_dictionary(input_dict) == expected_output);\n    }\n\n    SECTION(\"Test a dictionary with whitespace strings\") {\n        std::map<std::string, std::string> input_dict = {\n            {\"key1\", \"   \"},\n            {\"key2\", \"\"},\n            {\"key3\", \"valid\"}\n        };\n        std::map<std::string, std::string> expected_output = {\n            {\"key3\", \"valid\"}\n        };\n        REQUIRE(clean_dictionary(input_dict) == expected_output);\n    }\n\n    SECTION(\"Test an empty dictionary\") {\n        std::map<std::string, std::string> input_dict = {};\n        std::map<std::string, std::string> expected_output = {};\n        REQUIRE(clean_dictionary(input_dict) == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Cleans the input dictionary by removing keys with invalid values.\n * Valid values are non-NaN, non-nullptr, and non-whitespace strings.\n *\n * @param input_dict A map to be cleaned.\n * @return A new map containing only valid values.\n */\nstd::map<std::string, std::string> clean_dictionary(const std::map<std::string, std::string>& input_dict) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Cleans the input map by removing entries with invalid values.\n * Valid values are non-null, non-blank strings, and numbers that are not NaN.\n *\n * @param inputMap A map to be cleaned.\n * @return A new map containing only valid values.\n */\npublic static Map<String, Object> cleanDictionary(Map<String, Object> inputMap) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Tester {\n\n    @Test\n    public void testValidStrings() {\n        \"\"\" Test a dictionary with valid strings. \"\"\"\n        Map<String, Object> inputDict = new HashMap<>();\n        inputDict.put(\"key1\", \"valid string\");\n        inputDict.put(\"key2\", \"another valid string\");\n\n        Map<String, Object> expectedOutput = new HashMap<>();\n        expectedOutput.put(\"key1\", \"valid string\");\n        expectedOutput.put(\"key2\", \"another valid string\");\n\n        assertEquals(expectedOutput, cleanDictionary(inputDict));\n    }\n\n    @Test\n    public void testNoneAndNaNValues() {\n        \"\"\" Test a dictionary with None and NaN values. \"\"\"\n        Map<String, Object> inputDict = new HashMap<>();\n        inputDict.put(\"key1\", null);\n        inputDict.put(\"key3\", \"valid string\");\n\n        Map<String, Object> expectedOutput = new HashMap<>();\n        expectedOutput.put(\"key3\", \"valid string\");\n\n        assertEquals(expectedOutput, cleanDictionary(inputDict));\n    }\n\n    @Test\n    public void testWhitespaceStrings() {\n        \"\"\" Test a dictionary with whitespace strings. \"\"\"\n        Map<String, Object> inputDict = new HashMap<>();\n        inputDict.put(\"key1\", \"   \");\n        inputDict.put(\"key2\", \"\");\n        inputDict.put(\"key3\", \"valid\");\n\n        Map<String, Object> expectedOutput = new HashMap<>();\n        expectedOutput.put(\"key3\", \"valid\");\n\n        assertEquals(expectedOutput, cleanDictionary(inputDict));\n    }\n\n    @Test\n    public void testEmptyDictionary() {\n        \"\"\" Test an empty dictionary. \"\"\"\n        Map<String, Object> inputDict = new HashMap<>();\n        Map<String, Object> expectedOutput = new HashMap<>();\n\n        assertEquals(expectedOutput, cleanDictionary(inputDict));\n    }\n\n    // Utility method to simulate the cleanDictionary function\n    private Map<String, Object> cleanDictionary(Map<String, Object> inputDict) {\n        Map<String, Object> cleanedMap = new HashMap<>();\n\n        for (Map.Entry<String, Object> entry : inputDict.entrySet()) {\n            Object value = entry.getValue();\n\n            // Check if the value is not null and not a blank string\n            if (value instanceof String && !((String) value).trim().isEmpty()) {\n                // Check if value is a number (Integer or Double) and is not NaN\n                if (!(value instanceof Double && ((Double) value).isNaN())) {\n                    cleanedMap.put(entry.getKey(), value);\n                }\n            }\n        }\n\n        return cleanedMap;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Cleans the input map by removing entries with invalid values.\n * Valid values are non-null, non-blank strings, and numbers that are not NaN.\n *\n * @param inputMap A map to be cleaned.\n * @return A new map containing only valid values.\n */\npublic static Map<String, Object> cleanDictionary(Map<String, Object> inputMap) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 495, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "    Filters website content to include lines containing any of the specified keywords as whole words,\n    along with a specified number of lines before and after for context. This version uses regular expressions\n    to ensure exact, whole word matching and respects case sensitivity.", "language_version_list": {"python": {"code_signature": "import re\nfrom typing import List\n\n\ndef filter_content_with_context(\n        content: str,\n        keywords: List[str],\n        lines_before: int = 1,\n        lines_after: int = 1\n) -> str:\n    \"\"\"\n    Filters website content to include lines containing any of the specified keywords as whole words,\n    along with a specified number of lines before and after for context. This version uses regular expressions\n    to ensure exact, whole word matching and respects case sensitivity.\n\n    Args:\n        content (str): The full text content of the website.\n        keywords (List[str]): A list of strings to search for within the content.\n        lines_before (int): Number of lines to include before a matching line.\n        lines_after (int): Number of lines to include after a matching line.\n\n    Returns:\n        str: A string containing the filtered content with additional context.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFilterContentWithContext(unittest.TestCase):\n\n    def test_single_keyword_match(self):\n        \"\"\"Test a single keyword match with context lines.\"\"\"\n        content = \"\"\"Line one.\n        This line contains a keyword.\n        Line three.\"\"\"\n        keywords = [\"keyword\"]\n        expected_output = \"\"\"Line one.\n        This line contains a keyword.\n        Line three.\"\"\"\n        result = filter_content_with_context(content, keywords, lines_before=1, lines_after=1)\n        self.assertEqual(result.strip(), expected_output.strip(), \"Failed to filter content for a single keyword.\")\n\n\n    def test_no_keyword_match(self):\n        \"\"\"Test when no keywords match.\"\"\"\n        content = \"\"\"Line one.\n        Line two.\n        Line three.\"\"\"\n        keywords = [\"missing\"]\n        expected_output = \"\"\n        result = filter_content_with_context(content, keywords, lines_before=1, lines_after=1)\n        self.assertEqual(result.strip(), expected_output, \"Failed to return empty string for no matches.\")\n\n\n    def test_lines_before_and_after(self):\n        \"\"\"Test functionality with specified lines before and after.\"\"\"\n        content = \"\"\"Line one.\n        This line contains a keyword.\n        Line three.\n        Line four.\n        Line five.\"\"\"\n        keywords = [\"keyword\"]\n        expected_output = \"\"\"Line one.\n        This line contains a keyword.\n        Line three.\"\"\"\n        result = filter_content_with_context(content, keywords, lines_before=1, lines_after=1)\n        self.assertEqual(result.strip(), expected_output.strip(), \"Failed to correctly include context lines.\")\n", "prompt": "please write a python function , the function signature as below import re\nfrom typing import List\n\n\ndef filter_content_with_context(\n        content: str,\n        keywords: List[str],\n        lines_before: int = 1,\n        lines_after: int = 1\n) -> str:\n    \"\"\"\n    Filters website content to include lines containing any of the specified keywords as whole words,\n    along with a specified number of lines before and after for context. This version uses regular expressions\n    to ensure exact, whole word matching and respects case sensitivity.\n\n    Args:\n        content (str): The full text content of the website.\n        keywords (List[str]): A list of strings to search for within the content.\n        lines_before (int): Number of lines to include before a matching line.\n        lines_after (int): Number of lines to include after a matching line.\n\n    Returns:\n        str: A string containing the filtered content with additional context.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Filters website content to include lines containing any of the specified keywords as whole words,\n * along with a specified number of lines before and after for context. This version uses regular expressions\n * to ensure exact, whole word matching and respects case sensitivity.\n *\n * @param {string} content - The full text content of the website.\n * @param {Array<string>} keywords - A list of strings to search for within the content.\n * @param {number} [linesBefore=1] - Number of lines to include before a matching line.\n * @param {number} [linesAfter=1] - Number of lines to include after a matching line.\n * @returns {string} - A string containing the filtered content with additional context.\n */\nfunction filterContentWithContext(content, keywords, linesBefore = 1, linesAfter = 1) {\n\n}", "test_code": "describe('TestFilterContentWithContext', () => {\n    describe('Single Keyword Match', () => {\n        it('should correctly filter content for a single keyword with context lines', () => {\n            const content = `Line one.\n            This line contains a keyword.\n            Line three.`;\n            const keywords = ['keyword'];\n            const expectedOutput = `Line one.\n            This line contains a keyword.\n            Line three.`;\n            const result = filterContentWithContext(content, keywords, 1, 1);\n            expect(result.trim()).toEqual(expectedOutput.trim());\n        });\n    });\n\n    describe('No Keyword Match', () => {\n        it('should return an empty string when no keywords match', () => {\n            const content = `Line one.\n            Line two.\n            Line three.`;\n            const keywords = ['missing'];\n            const expectedOutput = '';\n            const result = filterContentWithContext(content, keywords, 1, 1);\n            expect(result.trim()).toEqual(expectedOutput);\n        });\n    });\n\n    describe('Lines Before and After', () => {\n        it('should correctly include context lines', () => {\n            const content = `Line one.\n            This line contains a keyword.\n            Line three.\n            Line four.\n            Line five.`;\n            const keywords = ['keyword'];\n            const expectedOutput = `Line one.\n            This line contains a keyword.\n            Line three.`;\n            const result = filterContentWithContext(content, keywords, 1, 1);\n            expect(result.trim()).toEqual(expectedOutput.trim());\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Filters website content to include lines containing any of the specified keywords as whole words,\n * along with a specified number of lines before and after for context. This version uses regular expressions\n * to ensure exact, whole word matching and respects case sensitivity.\n *\n * @param {string} content - The full text content of the website.\n * @param {Array<string>} keywords - A list of strings to search for within the content.\n * @param {number} [linesBefore=1] - Number of lines to include before a matching line.\n * @param {number} [linesAfter=1] - Number of lines to include after a matching line.\n * @returns {string} - A string containing the filtered content with additional context.\n */\nfunction filterContentWithContext(content, keywords, linesBefore = 1, linesAfter = 1) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Filters website content to include lines containing any of the specified keywords as whole words,\n * along with a specified number of lines before and after for context. This version uses regular expressions\n * to ensure exact, whole word matching and respects case sensitivity.\n *\n * @param content - The full text content of the website.\n * @param keywords - A list of strings to search for within the content.\n * @param linesBefore - Number of lines to include before a matching line.\n * @param linesAfter - Number of lines to include after a matching line.\n * @returns A string containing the filtered content with additional context.\n */\nfunction filterContentWithContext(\n  content: string,\n  keywords: string[],\n  linesBefore: number = 1,\n  linesAfter: number = 1\n): string {\n\n}", "test_code": "describe('TestFilterContentWithContext', () => {\n  it('test_single_keyword_match', () => {\n    // Test a single keyword match with context lines.\n    const content = `Line one.\n    This line contains a keyword.\n    Line three.`;\n    const keywords = ['keyword'];\n    const expectedOutput = `Line one.\n    This line contains a keyword.\n    Line three.`;\n    const result = filterContentWithContext(content, keywords, 1, 1);\n    expect(result.trim()).toEqual(expectedOutput.trim());\n  });\n\n  it('test_no_keyword_match', () => {\n    // Test when no keywords match.\n    const content = `Line one.\n    Line two.\n    Line three.`;\n    const keywords = ['missing'];\n    const expectedOutput = '';\n    const result = filterContentWithContext(content, keywords, 1, 1);\n    expect(result.trim()).toEqual(expectedOutput);\n  });\n\n  it('test_lines_before_and_after', () => {\n    // Test functionality with specified lines before and after.\n    const content = `Line one.\n    This line contains a keyword.\n    Line three.\n    Line four.\n    Line five.`;\n    const keywords = ['keyword'];\n    const expectedOutput = `Line one.\n    This line contains a keyword.\n    Line three.`;\n    const result = filterContentWithContext(content, keywords, 1, 1);\n    expect(result.trim()).toEqual(expectedOutput.trim());\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Filters website content to include lines containing any of the specified keywords as whole words,\n * along with a specified number of lines before and after for context. This version uses regular expressions\n * to ensure exact, whole word matching and respects case sensitivity.\n *\n * @param content - The full text content of the website.\n * @param keywords - A list of strings to search for within the content.\n * @param linesBefore - Number of lines to include before a matching line.\n * @param linesAfter - Number of lines to include after a matching line.\n * @returns A string containing the filtered content with additional context.\n */\nfunction filterContentWithContext(\n  content: string,\n  keywords: string[],\n  linesBefore: number = 1,\n  linesAfter: number = 1\n): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Filters website content to include lines containing any of the specified keywords as whole words,\n * along with a specified number of lines before and after for context. This version uses regular expressions\n * to ensure exact, whole word matching and respects case sensitivity.\n *\n * @param content The full text content of the website.\n * @param keywords A list of strings to search for within the content.\n * @param lines_before Number of lines to include before a matching line.\n * @param lines_after Number of lines to include after a matching line.\n *\n * @return A string containing the filtered content with additional context.\n */\nstd::string filter_content_with_context(\n    const std::string& content,\n    const std::vector<std::string>& keywords,\n    int lines_before = 1,\n    int lines_after = 1\n) {\n\n}", "test_code": "TEST_CASE(\"TestFilterContentWithContext\", \"[filter_content_with_context]\") {\n    SECTION(\"test_single_keyword_match\") {\n        std::string content = R\"(Line one.\n        This line contains a keyword.\n        Line three.)\";\n        std::vector<std::string> keywords = {\"keyword\"};\n        std::string expected_output = R\"(Line one.\n        This line contains a keyword.\n        Line three.)\";\n        std::string result = filter_content_with_context(content, keywords, 1, 1);\n        REQUIRE(result == expected_output);\n    }\n\n    SECTION(\"test_no_keyword_match\") {\n        std::string content = R\"(Line one.\n        Line two.\n        Line three.)\";\n        std::vector<std::string> keywords = {\"missing\"};\n        std::string expected_output = \"\";\n        std::string result = filter_content_with_context(content, keywords, 1, 1);\n        REQUIRE(result == expected_output);\n    }\n\n    SECTION(\"test_lines_before_and_after\") {\n        std::string content = R\"(Line one.\n        This line contains a keyword.\n        Line three.\n        Line four.\n        Line five.)\";\n        std::vector<std::string> keywords = {\"keyword\"};\n        std::string expected_output = R\"(Line one.\n        This line contains a keyword.\n        Line three.)\";\n        std::string result = filter_content_with_context(content, keywords, 1, 1);\n        REQUIRE(result == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Filters website content to include lines containing any of the specified keywords as whole words,\n * along with a specified number of lines before and after for context. This version uses regular expressions\n * to ensure exact, whole word matching and respects case sensitivity.\n *\n * @param content The full text content of the website.\n * @param keywords A list of strings to search for within the content.\n * @param lines_before Number of lines to include before a matching line.\n * @param lines_after Number of lines to include after a matching line.\n *\n * @return A string containing the filtered content with additional context.\n */\nstd::string filter_content_with_context(\n    const std::string& content,\n    const std::vector<std::string>& keywords,\n    int lines_before = 1,\n    int lines_after = 1\n) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Filters website content to include lines containing any of the specified keywords as whole words,\n * along with a specified number of lines before and after for context. This version uses regular expressions\n * to ensure exact, whole word matching and respects case sensitivity.\n *\n * @param content       The full text content of the website.\n * @param keywords      A list of strings to search for within the content.\n * @param linesBefore   Number of lines to include before a matching line.\n * @param linesAfter    Number of lines to include after a matching line.\n * @return              A string containing the filtered content with additional context.\n */\npublic static String filterContentWithContext(String content, List<String> keywords, int linesBefore, int linesAfter) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testSingleKeywordMatch() {\n        String content = \"Line one.\\n\" +\n                         \"This line contains a keyword.\\n\" +\n                         \"Line three.\";\n        List<String> keywords = Arrays.asList(\"keyword\");\n        String expectedOutput = \"Line one.\\n\" +\n                                \"This line contains a keyword.\\n\" +\n                                \"Line three.\";\n        String result = Answer.filterContentWithContext(content, keywords, 1, 1);\n        assertEquals(expectedOutput.strip(), result.strip(), \"Failed to filter content for a single keyword.\");\n    }\n\n    @Test\n    public void testNoKeywordMatch() {\n        String content = \"Line one.\\n\" +\n                         \"Line two.\\n\" +\n                         \"Line three.\";\n        List<String> keywords = Arrays.asList(\"missing\");\n        String expectedOutput = \"\";\n        String result = Answer.filterContentWithContext(content, keywords, 1, 1);\n        assertEquals(expectedOutput.strip(), result.strip(), \"Failed to return empty string for no matches.\");\n    }\n\n    @Test\n    public void testLinesBeforeAndAfter() {\n        String content = \"Line one.\\n\" +\n                         \"This line contains a keyword.\\n\" +\n                         \"Line three.\\n\" +\n                         \"Line four.\\n\" +\n                         \"Line five.\";\n        List<String> keywords = Arrays.asList(\"keyword\");\n        String expectedOutput = \"Line one.\\n\" +\n                                \"This line contains a keyword.\\n\" +\n                                \"Line three.\";\n        String result = Answer.filterContentWithContext(content, keywords, 1, 1);\n        assertEquals(expectedOutput.strip(), result.strip(), \"Failed to correctly include context lines.\");\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Filters website content to include lines containing any of the specified keywords as whole words,\n * along with a specified number of lines before and after for context. This version uses regular expressions\n * to ensure exact, whole word matching and respects case sensitivity.\n *\n * @param content       The full text content of the website.\n * @param keywords      A list of strings to search for within the content.\n * @param linesBefore   Number of lines to include before a matching line.\n * @param linesAfter    Number of lines to include after a matching line.\n * @return              A string containing the filtered content with additional context.\n */\npublic static String filterContentWithContext(String content, List<String> keywords, int linesBefore, int linesAfter) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 496, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Generates the ith row of Pascal's Triangle.", "language_version_list": {"python": {"code_signature": "import math\nfrom typing import List\n\n\ndef pascal_triangle_row(i: int) -> List:\n    \"\"\"\n    Generates the ith row of Pascal's Triangle.\n\n    Args:\n        i (int): Row index (0-indexed)\n\n    Returns:\n        List: A list representing the ith row of Pascal's Triangle\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestPascalTriangleRow(unittest.TestCase):\n\n    def test_row_0(self):\n        \"\"\" Test the 0th row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(0), [1])\n\n    def test_row_1(self):\n        \"\"\" Test the 1st row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(1), [1, 1])\n\n    def test_row_2(self):\n        \"\"\" Test the 2nd row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(2), [1, 2, 1])\n\n    def test_row_3(self):\n        \"\"\" Test the 3rd row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(3), [1, 3, 3, 1])\n\n    def test_row_4(self):\n        \"\"\" Test the 4th row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(4), [1, 4, 6, 4, 1])\n\n    def test_row_5(self):\n        \"\"\" Test the 5th row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(5), [1, 5, 10, 10, 5, 1])\n", "prompt": "please write a python function , the function signature as below import math\nfrom typing import List\n\n\ndef pascal_triangle_row(i: int) -> List:\n    \"\"\"\n    Generates the ith row of Pascal's Triangle.\n\n    Args:\n        i (int): Row index (0-indexed)\n\n    Returns:\n        List: A list representing the ith row of Pascal's Triangle\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Generates the ith row of Pascal's Triangle.\n *\n * @param {number} i - Row index (0-indexed)\n * @return {Array<number>} An array representing the ith row of Pascal's Triangle\n */\nfunction pascalTriangleRow(i) {\n\n}", "test_code": "describe('TestPascalTriangleRow', () => {\n    it('test_row_0', () => {\n        /** Test the 0th row of Pascal's Triangle. */\n        expect(pascalTriangleRow(0)).toEqual([1]);\n    });\n\n    it('test_row_1', () => {\n        /** Test the 1st row of Pascal's Triangle. */\n        expect(pascalTriangleRow(1)).toEqual([1, 1]);\n    });\n\n    it('test_row_2', () => {\n        /** Test the 2nd row of Pascal's Triangle. */\n        expect(pascalTriangleRow(2)).toEqual([1, 2, 1]);\n    });\n\n    it('test_row_3', () => {\n        /** Test the 3rd row of Pascal's Triangle. */\n        expect(pascalTriangleRow(3)).toEqual([1, 3, 3, 1]);\n    });\n\n    it('test_row_4', () => {\n        /** Test the 4th row of Pascal's Triangle. */\n        expect(pascalTriangleRow(4)).toEqual([1, 4, 6, 4, 1]);\n    });\n\n    it('test_row_5', () => {\n        /** Test the 5th row of Pascal's Triangle. */\n        expect(pascalTriangleRow(5)).toEqual([1, 5, 10, 10, 5, 1]);\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Generates the ith row of Pascal's Triangle.\n *\n * @param {number} i - Row index (0-indexed)\n * @return {Array<number>} An array representing the ith row of Pascal's Triangle\n */\nfunction pascalTriangleRow(i) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Generates the ith row of Pascal's Triangle.\n *\n * @param i - Row index (0-indexed)\n * @returns An array representing the ith row of Pascal's Triangle\n */\nfunction pascalTriangleRow(i: number): number[] {\n\n}", "test_code": "describe('Test Pascal Triangle Row', () => {\n    it('test row 0', () => {\n        expect(pascalTriangleRow(0)).toEqual([1]);\n    });\n\n    it('test row 1', () => {\n        expect(pascalTriangleRow(1)).toEqual([1, 1]);\n    });\n\n    it('test row 2', () => {\n        expect(pascalTriangleRow(2)).toEqual([1, 2, 1]);\n    });\n\n    it('test row 3', () => {\n        expect(pascalTriangleRow(3)).toEqual([1, 3, 3, 1]);\n    });\n\n    it('test row 4', () => {\n        expect(pascalTriangleRow(4)).toEqual([1, 4, 6, 4, 1]);\n    });\n\n    it('test row 5', () => {\n        expect(pascalTriangleRow(5)).toEqual([1, 5, 10, 10, 5, 1]);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Generates the ith row of Pascal's Triangle.\n *\n * @param i - Row index (0-indexed)\n * @returns An array representing the ith row of Pascal's Triangle\n */\nfunction pascalTriangleRow(i: number): number[] {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Generates the ith row of Pascal's Triangle.\n *\n * @param i Row index (0-indexed)\n * @return A vector representing the ith row of Pascal's Triangle\n */\nstd::vector<long long> pascal_triangle_row(int i) {}", "test_code": "TEST_CASE(\"Test Pascal's Triangle Row\") {\n    SECTION(\"Test the 0th row of Pascal's Triangle\") {\n        REQUIRE(pascal_triangle_row(0) == std::vector<long long>({1}));\n    }\n\n    SECTION(\"Test the 1st row of Pascal's Triangle\") {\n        REQUIRE(pascal_triangle_row(1) == std::vector<long long>({1, 1}));\n    }\n\n    SECTION(\"Test the 2nd row of Pascal's Triangle\") {\n        REQUIRE(pascal_triangle_row(2) == std::vector<long long>({1, 2, 1}));\n    }\n\n    SECTION(\"Test the 3rd row of Pascal's Triangle\") {\n        REQUIRE(pascal_triangle_row(3) == std::vector<long long>({1, 3, 3, 1}));\n    }\n\n    SECTION(\"Test the 4th row of Pascal's Triangle\") {\n        REQUIRE(pascal_triangle_row(4) == std::vector<long long>({1, 4, 6, 4, 1}));\n    }\n\n    SECTION(\"Test the 5th row of Pascal's Triangle\") {\n        REQUIRE(pascal_triangle_row(5) == std::vector<long long>({1, 5, 10, 10, 5, 1}));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Generates the ith row of Pascal's Triangle.\n *\n * @param i Row index (0-indexed)\n * @return A vector representing the ith row of Pascal's Triangle\n */\nstd::vector<long long> pascal_triangle_row(int i) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Generates the ith row of Pascal's Triangle.\n *\n * @param i the row index (0-indexed)\n * @return a List representing the ith row of Pascal's Triangle\n */\npublic static List<Long> pascalTriangleRow(int i) {\n\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Test class for verifying the correctness of the Pascal's Triangle row generation.\n */\npublic class Tester {\n\n    /**\n     * Tests the 0th row of Pascal's Triangle.\n     */\n    @Test\n    public void testRow0() {\n        List<Long> expected = Arrays.asList(1L);\n        assertEquals(expected, pascalTriangleRow(0));\n    }\n\n    /**\n     * Tests the 1st row of Pascal's Triangle.\n     */\n    @Test\n    public void testRow1() {\n        List<Long> expected = Arrays.asList(1L, 1L);\n        assertEquals(expected, pascalTriangleRow(1));\n    }\n\n    /**\n     * Tests the 2nd row of Pascal's Triangle.\n     */\n    @Test\n    public void testRow2() {\n        List<Long> expected = Arrays.asList(1L, 2L, 1L);\n        assertEquals(expected, pascalTriangleRow(2));\n    }\n\n    /**\n     * Tests the 3rd row of Pascal's Triangle.\n     */\n    @Test\n    public void testRow3() {\n        List<Long> expected = Arrays.asList(1L, 3L, 3L, 1L);\n        assertEquals(expected, pascalTriangleRow(3));\n    }\n\n    /**\n     * Tests the 4th row of Pascal's Triangle.\n     */\n    @Test\n    public void testRow4() {\n        List<Long> expected = Arrays.asList(1L, 4L, 6L, 4L, 1L);\n        assertEquals(expected, pascalTriangleRow(4));\n    }\n\n    /**\n     * Tests the 5th row of Pascal's Triangle.\n     */\n    @Test\n    public void testRow5() {\n        List<Long> expected = Arrays.asList(1L, 5L, 10L, 10L, 5L, 1L);\n        assertEquals(expected, pascalTriangleRow(5));\n    }\n\n    /**\n     * Generates the ith row of Pascal's Triangle.\n     *\n     * @param i the row index (0-indexed)\n     * @return a List representing the ith row of Pascal's Triangle\n     */\n    private List<Long> pascalTriangleRow(int i) {\n        List<Long> row = new ArrayList<>();\n        for (int k = 0; k <= i; k++) {\n            row.add(combination(i, k));\n        }\n        return row;\n    }\n\n    /**\n     * Calculates the combination (n choose k).\n     *\n     * @param n the total number of items\n     * @param k the number of items to choose\n     * @return the combination value\n     */\n    private static long combination(int n, int k) {\n        long result = 1;\n        if (k > n - k) {\n            k = n - k;\n        }\n        for (int i = 0; i < k; ++i) {\n            result *= (n - i);\n            result /= (i + 1);\n        }\n        return result;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Generates the ith row of Pascal's Triangle.\n *\n * @param i the row index (0-indexed)\n * @return a List representing the ith row of Pascal's Triangle\n */\npublic static List<Long> pascalTriangleRow(int i) {\n\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 498, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Computes and returns the MD5 hash of the string\n", "language_version_list": {"python": {"code_signature": "import hashlib\n\n\ndef compute_md5(input_string: str) -> str:\n    \"\"\"\n    Computes and returns the MD5 hash of the input string.\n\n    Args:\n        input_string (str): The string to be hashed\n\n    Returns:\n        str: he MD5 hash of the input string in hexadecimal format\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestComputeMD5(unittest.TestCase):\n\n    def test_empty_string(self):\n        \"\"\" Test the MD5 hash of an empty string. \"\"\"\n        self.assertEqual(compute_md5(''), 'd41d8cd98f00b204e9800998ecf8427e')\n\n    def test_simple_string(self):\n        \"\"\" Test the MD5 hash of a simple string. \"\"\"\n        self.assertEqual(compute_md5('Hello, World!'), '65a8e27d8879283831b664bd8b7f0ad4')\n\n    def test_numeric_string(self):\n        \"\"\" Test the MD5 hash of a numeric string. \"\"\"\n        self.assertEqual(compute_md5('123456'), 'e10adc3949ba59abbe56e057f20f883e')\n\n    def test_special_characters(self):\n        \"\"\" Test the MD5 hash of a string with special characters. \"\"\"\n        self.assertEqual(compute_md5('!@#$%^&*()'), '05b28d17a7b6e7024b6e5d8cc43a8bf7')\n\n    def test_long_string(self):\n        \"\"\" Test the MD5 hash of a long string. \"\"\"\n        long_string = 'a' * 1000  # A string of 1000 'a' characters\n        expected_hash = 'cabe45dcc9ae5b66ba86600cca6b8ba8'  # MD5 of 'aaaa....' (1000 'a's)\n        self.assertEqual(compute_md5(long_string), expected_hash)", "prompt": "please write a python function , the function signature as below import hashlib\n\n\ndef compute_md5(input_string: str) -> str:\n    \"\"\"\n    Computes and returns the MD5 hash of the input string.\n\n    Args:\n        input_string (str): The string to be hashed\n\n    Returns:\n        str: he MD5 hash of the input string in hexadecimal format\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Computes and returns the MD5 hash of the input string.\n *\n * @param {string} inputString - The string to be hashed\n * @return {string} The MD5 hash of the input string in hexadecimal format\n */\nfunction computeMD5(inputString) {\n\n}", "test_code": "describe('TestComputeMD5', () => {\n    test('test the MD5 hash of an empty string', () => {\n        expect(computeMD5('')).toBe('d41d8cd98f00b204e9800998ecf8427e');\n    });\n\n    test('test the MD5 hash of a simple string', () => {\n        expect(computeMD5('Hello, World!')).toBe('65a8e27d8879283831b664bd8b7f0ad4');\n    });\n\n    test('test the MD5 hash of a numeric string', () => {\n        expect(computeMD5('123456')).toBe('e10adc3949ba59abbe56e057f20f883e');\n    });\n\n    test('test the MD5 hash of a string with special characters', () => {\n        expect(computeMD5('!@#$%^&*()')).toBe('05b28d17a7b6e7024b6e5d8cc43a8bf7');\n    });\n\n    test('test the MD5 hash of a long string', () => {\n        const longString = 'a'.repeat(1000); // A string of 1000 'a' characters\n        const expectedHash = 'cabe45dcc9ae5b66ba86600cca6b8ba8'; // MD5 of 'aaaa....' (1000 'a's)\n        expect(computeMD5(longString)).toBe(expectedHash);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Computes and returns the MD5 hash of the input string.\n *\n * @param {string} inputString - The string to be hashed\n * @return {string} The MD5 hash of the input string in hexadecimal format\n */\nfunction computeMD5(inputString) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Computes and returns the MD5 hash of the input string.\n *\n * @param inputString - The string to be hashed\n * @returns The MD5 hash of the input string in hexadecimal format\n */\nfunction computeMD5(inputString: string): string {\n\n}", "test_code": "describe('TestComputeMD5', () => {\n  it('test_empty_string', () => {\n    // Test the MD5 hash of an empty string\n    expect(computeMD5('')).toBe('d41d8cd98f00b204e9800998ecf8427e');\n  });\n\n  it('test_simple_string', () => {\n    // Test the MD5 hash of a simple string\n    expect(computeMD5('Hello, World!')).toBe('65a8e27d8879283831b664bd8b7f0ad4');\n  });\n\n  it('test_numeric_string', () => {\n    // Test the MD5 hash of a numeric string\n    expect(computeMD5('123456')).toBe('e10adc3949ba59abbe56e057f20f883e');\n  });\n\n  it('test_special_characters', () => {\n    // Test the MD5 hash of a string with special characters\n    expect(computeMD5('!@#$%^&*()')).toBe('05b28d17a7b6e7024b6e5d8cc43a8bf7');\n  });\n\n  it('test_long_string', () => {\n    // Test the MD5 hash of a long string\n    const longString = 'a'.repeat(1000);  // A string of 1000 'a' characters\n    const expectedHash = 'cabe45dcc9ae5b66ba86600cca6b8ba8';  // MD5 of 'aaaa....' (1000 'a's)\n    expect(computeMD5(longString)).toBe(expectedHash);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Computes and returns the MD5 hash of the input string.\n *\n * @param inputString - The string to be hashed\n * @returns The MD5 hash of the input string in hexadecimal format\n */\nfunction computeMD5(inputString: string): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Computes and returns the MD5 hash of the input string.\n *\n * @param input_string The string to be hashed\n * @return The MD5 hash of the input string in hexadecimal format\n */\nstd::string compute_md5(const std::string& input_string) {}", "test_code": "TEST_CASE(\"Test Compute MD5\") {\n    SECTION(\"Test the MD5 hash of an empty string\") {\n        REQUIRE(compute_md5(\"\") == \"d41d8cd98f00b204e9800998ecf8427e\");\n    }\n\n    SECTION(\"Test the MD5 hash of a simple string\") {\n        REQUIRE(compute_md5(\"Hello, World!\") == \"65a8e27d8879283831b664bd8b7f0ad4\");\n    }\n\n    SECTION(\"Test the MD5 hash of a numeric string\") {\n        REQUIRE(compute_md5(\"123456\") == \"e10adc3949ba59abbe56e057f20f883e\");\n    }\n\n    SECTION(\"Test the MD5 hash of a string with special characters\") {\n        REQUIRE(compute_md5(\"!@#$%^&*()\") == \"05b28d17a7b6e7024b6e5d8cc43a8bf7\");\n    }\n\n    SECTION(\"Test the MD5 hash of a long string\") {\n        std::string long_string(1000, 'a');\n        std::string expected_hash = \"cabe45dcc9ae5b66ba86600cca6b8ba8\";\n        REQUIRE(compute_md5(long_string) == expected_hash);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Computes and returns the MD5 hash of the input string.\n *\n * @param input_string The string to be hashed\n * @return The MD5 hash of the input string in hexadecimal format\n */\nstd::string compute_md5(const std::string& input_string) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Computes and returns the MD5 hash of the input string.\n *\n * @param inputString The string to be hashed\n * @return The MD5 hash of the input string in hexadecimal format\n */\npublic static String computeMD5(String inputString) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testEmptyString() {\n        // Test the MD5 hash of an empty string.\n        assertEquals(\"d41d8cd98f00b204e9800998ecf8427e\", computeMD5(\"\"));\n    }\n\n    @Test\n    public void testSimpleString() {\n        // Test the MD5 hash of a simple string.\n        assertEquals(\"65a8e27d8879283831b664bd8b7f0ad4\", computeMD5(\"Hello, World!\"));\n    }\n\n    @Test\n    public void testNumericString() {\n        // Test the MD5 hash of a numeric string.\n        assertEquals(\"e10adc3949ba59abbe56e057f20f883e\", computeMD5(\"123456\"));\n    }\n\n    @Test\n    public void testSpecialCharacters() {\n        // Test the MD5 hash of a string with special characters.\n        assertEquals(\"05b28d17a7b6e7024b6e5d8cc43a8bf7\", computeMD5(\"!@#$%^&*()\"));\n    }\n\n    @Test\n    public void testLongString() {\n        // Test the MD5 hash of a long string.\n        String longString = \"a\".repeat(1000);  // A string of 1000 'a' characters\n        String expectedHash = \"cabe45dcc9ae5b66ba86600cca6b8ba8\";  // MD5 of 'aaaa....' (1000 'a's)\n        assertEquals(expectedHash, computeMD5(longString));\n    }\n\n    // Method to compute the MD5 hash of a string\n    private String computeMD5(String inputString) {\n        try {\n            // Create an MD5 MessageDigest instance\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n\n            // Update the digest using the specified array of bytes\n            md.update(inputString.getBytes());\n\n            // Complete the hash computation\n            byte[] digest = md.digest();\n\n            // Convert the byte array to a hex string\n            StringBuilder hexString = new StringBuilder();\n            for (byte b : digest) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) hexString.append('0');\n                hexString.append(hex);\n            }\n\n            // Return the hexadecimal representation of the hash\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"MD5 algorithm not found\", e);\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Computes and returns the MD5 hash of the input string.\n *\n * @param inputString The string to be hashed\n * @return The MD5 hash of the input string in hexadecimal format\n */\npublic static String computeMD5(String inputString) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 499, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Extracts a numeric value from the input string based on the given regex pattern.", "language_version_list": {"python": {"code_signature": "import re\nfrom typing import Union\n\n\ndef clean_pattern(x: str, pattern: str) -> Union[str,float]:\n    \"\"\"\n    Extracts a numeric value from the input string based on the given regex pattern.\n\n    Args:\n        x (str or any): The input from which to extract the value. It will be converted to a string.\n        pattern (str): The regular expression pattern to use for matching.\n\n    Returns:\n        Union[str,float]: The extracted weight value if a match is found, otherwise an empty string.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestCleanPattern(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Sets up a common regex pattern for testing.\"\"\"\n        self.pattern = r'(\\d+\\.?\\d*) kg'  # Regex pattern to match weight in kg\n\n    def test_valid_integer_weight(self):\n        \"\"\"Test case for valid integer weight.\"\"\"\n        input_string = \"The weight is 25 kg\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, 25.0)\n\n    def test_valid_float_weight(self):\n        \"\"\"Test case for valid float weight.\"\"\"\n        input_string = \"Weight measured at 15.75 kg\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, 15.75)\n\n    def test_no_weight_found(self):\n        \"\"\"Test case where no weight is present.\"\"\"\n        input_string = \"No weight provided.\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, '')\n\n    def test_invalid_float_conversion(self):\n        \"\"\"Test case for non-numeric weight.\"\"\"\n        input_string = \"The weight is thirty kg\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, '')\n\n    def test_weight_with_extra_text(self):\n        \"\"\"Test case for weight with additional text.\"\"\"\n        input_string = \"The total weight is 45.3 kg as per the last measurement.\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, 45.3)\n", "prompt": "please write a python function , the function signature as below import re\nfrom typing import Union\n\n\ndef clean_pattern(x: str, pattern: str) -> Union[str,float]:\n    \"\"\"\n    Extracts a numeric value from the input string based on the given regex pattern.\n\n    Args:\n        x (str or any): The input from which to extract the value. It will be converted to a string.\n        pattern (str): The regular expression pattern to use for matching.\n\n    Returns:\n        Union[str,float]: The extracted weight value if a match is found, otherwise an empty string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extracts a numeric value from the input string based on the given regex pattern.\n *\n * @param {any} x - The input from which to extract the value. It will be converted to a string.\n * @param {string} pattern - The regular expression pattern to use for matching.\n * @returns {number|string} - The extracted weight value if a match is found, otherwise an empty string.\n */\nfunction cleanPattern(x, pattern) {\n\n}", "test_code": "describe('TestCleanPattern', () => {\n    let pattern;\n\n    beforeEach(() => {\n        // Sets up a common regex pattern for testing\n        pattern = /(\\d+\\.?\\d*) kg/;\n    });\n\n    it('test_valid_integer_weight', () => {\n        // Test case for valid integer weight\n        const inputString = \"The weight is 25 kg\";\n        const result = cleanPattern(inputString, pattern);\n        expect(result).toBe(25.0);\n    });\n\n    it('test_valid_float_weight', () => {\n        // Test case for valid float weight\n        const inputString = \"Weight measured at 15.75 kg\";\n        const result = cleanPattern(inputString, pattern);\n        expect(result).toBe(15.75);\n    });\n\n    it('test_no_weight_found', () => {\n        // Test case where no weight is present\n        const inputString = \"No weight provided.\";\n        const result = cleanPattern(inputString, pattern);\n        expect(result).toBe('');\n    });\n\n    it('test_invalid_float_conversion', () => {\n        // Test case for non-numeric weight\n        const inputString = \"The weight is thirty kg\";\n        const result = cleanPattern(inputString, pattern);\n        expect(result).toBe('');\n    });\n\n    it('test_weight_with_extra_text', () => {\n        // Test case for weight with additional text\n        const inputString = \"The total weight is 45.3 kg as per the last measurement.\";\n        const result = cleanPattern(inputString, pattern);\n        expect(result).toBe(45.3);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Extracts a numeric value from the input string based on the given regex pattern.\n *\n * @param {any} x - The input from which to extract the value. It will be converted to a string.\n * @param {string} pattern - The regular expression pattern to use for matching.\n * @returns {number|string} - The extracted weight value if a match is found, otherwise an empty string.\n */\nfunction cleanPattern(x, pattern) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Extracts a numeric value from the input string based on the given regex pattern.\n *\n * @param x - The input from which to extract the value. It will be converted to a string.\n * @param pattern - The regular expression pattern to use for matching.\n * @returns The extracted weight value as a number if a match is found, otherwise an empty string.\n */\nfunction cleanPattern(x: string | any, pattern: string): number | '' {\n\n}", "test_code": "describe('TestCleanPattern', () => {\n  let pattern: string;\n\n  beforeEach(() => {\n    // Sets up a common regex pattern for testing\n    pattern = '(\\\\d+\\\\.?\\\\d*) kg';  // Regex pattern to match weight in kg\n  });\n\n  it('should handle valid integer weight', () => {\n    const inputString = \"The weight is 25 kg\";\n    const result = cleanPattern(inputString, pattern);\n    expect(result).toEqual(25.0);\n  });\n\n  it('should handle valid float weight', () => {\n    const inputString = \"Weight measured at 15.75 kg\";\n    const result = cleanPattern(inputString, pattern);\n    expect(result).toEqual(15.75);\n  });\n\n  it('should return an empty string when no weight is found', () => {\n    const inputString = \"No weight provided.\";\n    const result = cleanPattern(inputString, pattern);\n    expect(result).toEqual('');\n  });\n\n  it('should return an empty string for non-numeric weight', () => {\n    const inputString = \"The weight is thirty kg\";\n    const result = cleanPattern(inputString, pattern);\n    expect(result).toEqual('');\n  });\n\n  it('should handle weight with extra text', () => {\n    const inputString = \"The total weight is 45.3 kg as per the last measurement.\";\n    const result = cleanPattern(inputString, pattern);\n    expect(result).toEqual(45.3);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Extracts a numeric value from the input string based on the given regex pattern.\n *\n * @param x - The input from which to extract the value. It will be converted to a string.\n * @param pattern - The regular expression pattern to use for matching.\n * @returns The extracted weight value as a number if a match is found, otherwise an empty string.\n */\nfunction cleanPattern(x: string | any, pattern: string): number | '' {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extracts a numeric value from the input string based on the given regex pattern.\n *\n * @param x The input from which to extract the value. It will be converted to a string.\n * @param pattern The regular expression pattern to use for matching.\n * @return The extracted weight value if a match is found, otherwise an empty string.\n */\nstd::string clean_pattern(const std::string& x, const std::string& pattern) {}", "test_code": "TEST_CASE(\"TestCleanPattern\", \"[clean_pattern]\") {\n    const std::string pattern = R\"((\\d+\\.?\\d*) kg)\";  // Regex pattern to match weight in kg\n\n    SECTION(\"test_valid_integer_weight\") {\n        std::string input_string = \"The weight is 25 kg\";\n        std::string result = clean_pattern(input_string, pattern);\n        REQUIRE(result == \"25.0\");\n    }\n\n    SECTION(\"test_valid_float_weight\") {\n        std::string input_string = \"Weight measured at 15.75 kg\";\n        std::string result = clean_pattern(input_string, pattern);\n        REQUIRE(result == \"15.75\");\n    }\n\n    SECTION(\"test_no_weight_found\") {\n        std::string input_string = \"No weight provided.\";\n        std::string result = clean_pattern(input_string, pattern);\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"test_invalid_float_conversion\") {\n        std::string input_string = \"The weight is thirty kg\";\n        std::string result = clean_pattern(input_string, pattern);\n        REQUIRE(result.empty());\n    }\n\n    SECTION(\"test_weight_with_extra_text\") {\n        std::string input_string = \"The total weight is 45.3 kg as per the last measurement.\";\n        std::string result = clean_pattern(input_string, pattern);\n        REQUIRE(result == \"45.3\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts a numeric value from the input string based on the given regex pattern.\n *\n * @param x The input from which to extract the value. It will be converted to a string.\n * @param pattern The regular expression pattern to use for matching.\n * @return The extracted weight value if a match is found, otherwise an empty string.\n */\nstd::string clean_pattern(const std::string& x, const std::string& pattern) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Extracts a numeric value from the input string based on the given regex pattern.\n *\n * @param x       The input from which to extract the value. It will be converted to a string.\n * @param pattern The regular expression pattern to use for matching.\n * @return The extracted weight value as a float if a match is found, otherwise an empty string.\n */\npublic static Object cleanPattern(Object x, String pattern) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for the cleanPattern method.\n */\npublic class Tester {\n\n    private String pattern;\n\n    @Before\n    public void setUp() {\n        // Set up a common regex pattern for testing\n        pattern = \"(\\\\d+\\\\.?\\\\d*) kg\";  // Regex pattern to match weight in kg\n    }\n\n    @Test\n    public void testValidIntegerWeight() {\n        // Test case for valid integer weight\n        String inputString = \"The weight is 25 kg\";\n        Object result = cleanPattern(inputString, pattern);\n        assertEquals(25.0f, result);\n    }\n\n    @Test\n    public void testValidFloatWeight() {\n        // Test case for valid float weight\n        String inputString = \"Weight measured at 15.75 kg\";\n        Object result = cleanPattern(inputString, pattern);\n        assertEquals(15.75f, result);\n    }\n\n    @Test\n    public void testNoWeightFound() {\n        // Test case where no weight is present\n        String inputString = \"No weight provided.\";\n        Object result = cleanPattern(inputString, pattern);\n        assertEquals(\"\", result);\n    }\n\n    @Test\n    public void testInvalidFloatConversion() {\n        // Test case for non-numeric weight\n        String inputString = \"The weight is thirty kg\";\n        Object result = cleanPattern(inputString, pattern);\n        assertEquals(\"\", result);\n    }\n\n    @Test\n    public void testWeightWithExtraText() {\n        // Test case for weight with additional text\n        String inputString = \"The total weight is 45.3 kg as per the last measurement.\";\n        Object result = cleanPattern(inputString, pattern);\n        assertEquals(45.3f, result);\n    }\n\n    // Method to be tested\n    private Object cleanPattern(Object x, String pattern) {\n        // Convert input to string\n        String input = x.toString();\n\n        // Compile the pattern\n        Pattern compiledPattern = Pattern.compile(pattern);\n        Matcher matcher = compiledPattern.matcher(input);\n\n        if (matcher.find()) {\n            // Extract the weight value from the first matching group\n            String weight = matcher.group(1);  // Can also use matcher.group(3) if needed\n\n            try {\n                // Convert the weight to a float and return it\n                float weightValue = Float.parseFloat(weight);\n                return weightValue;\n            } catch (NumberFormatException e) {\n                // Handle cases where conversion to float fails\n                System.out.println(\"Warning: Unable to convert '\" + weight + \"' to float.\");\n                return \"\";\n            }\n        } else {\n            return \"\";  // Return empty string if no match is found\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts a numeric value from the input string based on the given regex pattern.\n *\n * @param x       The input from which to extract the value. It will be converted to a string.\n * @param pattern The regular expression pattern to use for matching.\n * @return The extracted weight value as a float if a match is found, otherwise an empty string.\n */\npublic static Object cleanPattern(Object x, String pattern) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 500, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Converts the string representation of a score to its decimal value\n", "language_version_list": {"python": {"code_signature": "def convert_score_to_decimal(score_str: str) -> float:\n    \"\"\"\n    Converts the string representation of a score to its decimal value.\n    For example:\n        input: 10/4\n        output: 2.5\n    Args:\n        score_str (str): The score as a string, can be a decimal or a fraction\n\n    Returns:\n        float: The decimal value of the score as a float, or None if the input is invalid\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestConvertScoreToDecimal(unittest.TestCase):\n\n    def test_decimal_score(self):\n        \"\"\" Test a simple decimal score. \"\"\"\n        self.assertEqual(convert_score_to_decimal(\"2.5\"), 2.5)\n\n    def test_fraction_score(self):\n        \"\"\" Test a fraction score. \"\"\"\n        self.assertEqual(convert_score_to_decimal(\"10/4\"), 2.5)\n\n    def test_integer_score(self):\n        \"\"\" Test an integer score represented as a string. \"\"\"\n        self.assertEqual(convert_score_to_decimal(\"5\"), 5.0)\n\n    def test_integer_divide_score(self):\n        self.assertEqual(convert_score_to_decimal(\"12/3\"), 4.0)", "prompt": "please write a python function , the function signature as below def convert_score_to_decimal(score_str: str) -> float:\n    \"\"\"\n    Converts the string representation of a score to its decimal value.\n    For example:\n        input: 10/4\n        output: 2.5\n    Args:\n        score_str (str): The score as a string, can be a decimal or a fraction\n\n    Returns:\n        float: The decimal value of the score as a float, or None if the input is invalid\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts the string representation of a score to its decimal value.\n * For example:\n *   input: \"10/4\"\n *   output: 2.5\n *\n * @param {string} scoreStr - The score as a string, can be a decimal or a fraction\n * @returns {number | null} - The decimal value of the score as a float, or null if the input is invalid\n */\nfunction convertScoreToDecimal(scoreStr) {\n\n}", "test_code": "describe('TestConvertScoreToDecimal', () => {\n    test('test_decimal_score', () => {\n        // Test a simple decimal score\n        expect(convertScoreToDecimal(\"2.5\")).toBe(2.5);\n    });\n\n    test('test_fraction_score', () => {\n        // Test a fraction score\n        expect(convertScoreToDecimal(\"10/4\")).toBe(2.5);\n    });\n\n    test('test_integer_score', () => {\n        // Test an integer score represented as a string\n        expect(convertScoreToDecimal(\"5\")).toBe(5.0);\n    });\n\n    test('test_integer_divide_score', () => {\n        // Test an integer divide score\n        expect(convertScoreToDecimal(\"12/3\")).toBe(4.0);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts the string representation of a score to its decimal value.\n * For example:\n *   input: \"10/4\"\n *   output: 2.5\n *\n * @param {string} scoreStr - The score as a string, can be a decimal or a fraction\n * @returns {number | null} - The decimal value of the score as a float, or null if the input is invalid\n */\nfunction convertScoreToDecimal(scoreStr) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts the string representation of a score to its decimal value.\n * For example:\n *   input: \"10/4\"\n *   output: 2.5\n * @param scoreStr The score as a string, can be a decimal or a fraction\n * @returns The decimal value of the score as a float, or null if the input is invalid\n */\nfunction convertScoreToDecimal(scoreStr: string): number | null {\n\n}", "test_code": "describe('TestConvertScoreToDecimal', () => {\n  it('should correctly convert a simple decimal score', () => {\n    expect(convertScoreToDecimal(\"2.5\")).toEqual(2.5);\n  });\n\n  it('should correctly convert a fraction score', () => {\n    expect(convertScoreToDecimal(\"10/4\")).toEqual(2.5);\n  });\n\n  it('should correctly convert an integer score represented as a string', () => {\n    expect(convertScoreToDecimal(\"5\")).toEqual(5.0);\n  });\n\n  it('should correctly convert an integer division score', () => {\n    expect(convertScoreToDecimal(\"12/3\")).toEqual(4.0);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts the string representation of a score to its decimal value.\n * For example:\n *   input: \"10/4\"\n *   output: 2.5\n * @param scoreStr The score as a string, can be a decimal or a fraction\n * @returns The decimal value of the score as a float, or null if the input is invalid\n */\nfunction convertScoreToDecimal(scoreStr: string): number | null {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts the string representation of a score to its decimal value.\n * For example:\n *     input: 10/4\n *     output: 2.5\n *\n * @param score_str The score as a string, can be a decimal or a fraction\n * @return The decimal value of the score as a float, or std::nullopt if the input is invalid\n */\nstd::optional<float> convert_score_to_decimal(const std::string& score_str) {\n\n}", "test_code": "#include <catch2/catch_test_macros.hpp>\n#include <optional>\n#include <string>\n#include <sstream>\n#include <stdexcept>\n\n// Test cases using Catch2\nTEST_CASE(\"Test convert_score_to_decimal\") {\n    SECTION(\"Test a simple decimal score\") {\n        REQUIRE(convert_score_to_decimal(\"2.5\").value() == Approx(2.5f));\n    }\n\n    SECTION(\"Test a fraction score\") {\n        REQUIRE(convert_score_to_decimal(\"10/4\").value() == Approx(2.5f));\n    }\n\n    SECTION(\"Test an integer score represented as a string\") {\n        REQUIRE(convert_score_to_decimal(\"5\").value() == Approx(5.0f));\n    }\n\n    SECTION(\"Test an integer divide score\") {\n        REQUIRE(convert_score_to_decimal(\"12/3\").value() == Approx(4.0f));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts the string representation of a score to its decimal value.\n * For example:\n *     input: 10/4\n *     output: 2.5\n *\n * @param score_str The score as a string, can be a decimal or a fraction\n * @return The decimal value of the score as a float, or std::nullopt if the input is invalid\n */\nstd::optional<float> convert_score_to_decimal(const std::string& score_str) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts the string representation of a score to its decimal value.\n * For example:\n *     input: \"10/4\"\n *     output: 2.5\n *\n * @param scoreStr The score as a string, can be a decimal or a fraction\n * @return The decimal value of the score as a double, or null if the input is invalid\n */\npublic static Double convertScoreToDecimal(String scoreStr) {\n\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    @Test\n    public void testDecimalScore() {\n        // Test a simple decimal score.\n        assertEquals(2.5, convertScoreToDecimal(\"2.5\"), 0.001);\n    }\n\n    @Test\n    public void testFractionScore() {\n        // Test a fraction score.\n        assertEquals(2.5, convertScoreToDecimal(\"10/4\"), 0.001);\n    }\n\n    @Test\n    public void testIntegerScore() {\n        // Test an integer score represented as a string.\n        assertEquals(5.0, convertScoreToDecimal(\"5\"), 0.001);\n    }\n\n    @Test\n    public void testIntegerDivideScore() {\n        // Test an integer division score.\n        assertEquals(4.0, convertScoreToDecimal(\"12/3\"), 0.001);\n    }\n\n    // Utility method to convert the score to decimal\n    private Double convertScoreToDecimal(String scoreStr) {\n        try {\n            // Check if the score is a fraction\n            if (scoreStr.contains(\"/\")) {\n                String[] parts = scoreStr.split(\"/\");\n                if (parts.length == 2) {\n                    double numerator = Double.parseDouble(parts[0]);\n                    double denominator = Double.parseDouble(parts[1]);\n                    return numerator / denominator;\n                } else {\n                    throw new IllegalArgumentException(\"Invalid fraction format\");\n                }\n            } else {\n                // Otherwise, treat it as a decimal\n                return Double.parseDouble(scoreStr);\n            }\n\n        } catch (NumberFormatException | ArithmeticException e) {\n            System.out.println(\"Error converting '\" + scoreStr + \"' to decimal: \" + e.getMessage());\n            return null;\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts the string representation of a score to its decimal value.\n * For example:\n *     input: \"10/4\"\n *     output: 2.5\n *\n * @param scoreStr The score as a string, can be a decimal or a fraction\n * @return The decimal value of the score as a double, or null if the input is invalid\n */\npublic static Double convertScoreToDecimal(String scoreStr) {\n\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 501, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Converts strings concatenated with _ to a short format. For example, converting the string f1_p1_g1_b1_c1 to \"fpgbc\"", "language_version_list": {"python": {"code_signature": "def convert_to_short_format(input_str) -> str:\n    \"\"\"\n    Converts a string concatenated with underscores to a short format.\n    For example:\n        input: f1_p1_g1_b1_c1\n        output: fpgbc\n    Args:\n        input_str (str): The input string with segments separated by underscores.\n\n    Returns:\n        str: A short format string derived from the first characters of each segment.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestConvertToShortFormat(unittest.TestCase):\n\n    def test_basic_case(self):\n        \"\"\" Test a standard input with mixed characters. \"\"\"\n        self.assertEqual(convert_to_short_format(\"f1_p1_g1_b1_c1\"), \"fpgbc\")\n\n    def test_multiple_segments(self):\n        \"\"\" Test input with multiple segments. \"\"\"\n        self.assertEqual(convert_to_short_format(\"a2_b3_c4\"), \"abc\")\n\n    def test_non_alpha_numeric(self):\n        \"\"\" Test input with non-alphanumeric characters. \"\"\"\n        self.assertEqual(convert_to_short_format(\"hello_world_test\"), \"hwt\")\n\n    def test_single_segment(self):\n        \"\"\" Test a single segment input. \"\"\"\n        self.assertEqual(convert_to_short_format(\"single\"), \"s\")\n", "prompt": "please write a python function , the function signature as below def convert_to_short_format(input_str) -> str:\n    \"\"\"\n    Converts a string concatenated with underscores to a short format.\n    For example:\n        input: f1_p1_g1_b1_c1\n        output: fpgbc\n    Args:\n        input_str (str): The input string with segments separated by underscores.\n\n    Returns:\n        str: A short format string derived from the first characters of each segment.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a string concatenated with underscores to a short format.\n * For example:\n *     input: f1_p1_g1_b1_c1\n *     output: fpgbc\n *\n * @param {string} inputStr - The input string with segments separated by underscores.\n * @return {string} A short format string derived from the first characters of each segment.\n */\nfunction convertToShortFormat(inputStr) {\n\n}", "test_code": "describe('TestConvertToShortFormat', () => {\n    it('test basic case', () => {\n        /** Test a standard input with mixed characters. */\n        expect(convertToShortFormat(\"f1_p1_g1_b1_c1\")).toBe(\"fpgbc\");\n    });\n\n    it('test multiple segments', () => {\n        /** Test input with multiple segments. */\n        expect(convertToShortFormat(\"a2_b3_c4\")).toBe(\"abc\");\n    });\n\n    it('test non-alphanumeric characters', () => {\n        /** Test input with non-alphanumeric characters. */\n        expect(convertToShortFormat(\"hello_world_test\")).toBe(\"hwt\");\n    });\n\n    it('test single segment', () => {\n        /** Test a single segment input. */\n        expect(convertToShortFormat(\"single\")).toBe(\"s\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a string concatenated with underscores to a short format.\n * For example:\n *     input: f1_p1_g1_b1_c1\n *     output: fpgbc\n *\n * @param {string} inputStr - The input string with segments separated by underscores.\n * @return {string} A short format string derived from the first characters of each segment.\n */\nfunction convertToShortFormat(inputStr) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a string concatenated with underscores to a short format.\n * For example:\n *   input: f1_p1_g1_b1_c1\n *   output: fpgbc\n *\n * @param inputStr - The input string with segments separated by underscores.\n * @returns A short format string derived from the first characters of each segment.\n */\nfunction convertToShortFormat(inputStr: string): string {\n\n}", "test_code": "describe('TestConvertToShortFormat', () => {\n    it('test basic case', () => {\n        // Test a standard input with mixed characters.\n        expect(convertToShortFormat(\"f1_p1_g1_b1_c1\")).toBe(\"fpgbc\");\n    });\n\n    it('test multiple segments', () => {\n        // Test input with multiple segments.\n        expect(convertToShortFormat(\"a2_b3_c4\")).toBe(\"abc\");\n    });\n\n    it('test non-alphanumeric', () => {\n        // Test input with non-alphanumeric characters.\n        expect(convertToShortFormat(\"hello_world_test\")).toBe(\"hwt\");\n    });\n\n    it('test single segment', () => {\n        // Test a single segment input.\n        expect(convertToShortFormat(\"single\")).toBe(\"s\");\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a string concatenated with underscores to a short format.\n * For example:\n *   input: f1_p1_g1_b1_c1\n *   output: fpgbc\n *\n * @param inputStr - The input string with segments separated by underscores.\n * @returns A short format string derived from the first characters of each segment.\n */\nfunction convertToShortFormat(inputStr: string): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a string concatenated with underscores to a short format.\n * \n * For example:\n * - Input: `f1_p1_g1_b1_c1`\n * - Output: `fpgbc`\n *\n * @param input_str The input string with segments separated by underscores.\n *\n * @return A short format string derived from the first characters of each segment.\n */\nstd::string convert_to_short_format(const std::string &input_str){}\n", "test_code": "TEST_CASE(\"TestConvertToShortFormat\", \"[convert_to_short_format]\") {\n    SECTION(\"Test a standard input with mixed characters\") {\n        REQUIRE(convert_to_short_format(\"f1_p1_g1_b1_c1\") == \"fpgbc\");\n    }\n\n    SECTION(\"Test input with multiple segments\") {\n        REQUIRE(convert_to_short_format(\"a2_b3_c4\") == \"abc\");\n    }\n\n    SECTION(\"Test input with non-alphanumeric characters\") {\n        REQUIRE(convert_to_short_format(\"hello_world_test\") == \"hwt\");\n    }\n\n    SECTION(\"Test a single segment input\") {\n        REQUIRE(convert_to_short_format(\"single\") == \"s\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a string concatenated with underscores to a short format.\n * \n * For example:\n * - Input: `f1_p1_g1_b1_c1`\n * - Output: `fpgbc`\n *\n * @param input_str The input string with segments separated by underscores.\n *\n * @return A short format string derived from the first characters of each segment.\n */\nstd::string convert_to_short_format(const std::string &input_str){}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a string concatenated with underscores to a short format.\n * For example:\n * <pre>\n *     input: f1_p1_g1_b1_c1\n *     output: fpgbc\n * </pre>\n *\n * @param inputStr The input string with segments separated by underscores.\n * @return A short format string derived from the first characters of each segment.\n */\npublic static String convertToShortFormat(String inputStr) {\n\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for the convertToShortFormat method.\n */\npublic class Tester {\n\n    /**\n     * Tests a standard input with mixed characters.\n     */\n    @Test\n    public void testBasicCase() {\n        assertEquals(\"fpgbc\", convertToShortFormat(\"f1_p1_g1_b1_c1\"));\n    }\n\n    /**\n     * Tests input with multiple segments.\n     */\n    @Test\n    public void testMultipleSegments() {\n        assertEquals(\"abc\", convertToShortFormat(\"a2_b3_c4\"));\n    }\n\n    /**\n     * Tests input with non-alphanumeric characters.\n     */\n    @Test\n    public void testNonAlphaNumeric() {\n        assertEquals(\"hwt\", convertToShortFormat(\"hello_world_test\"));\n    }\n\n    /**\n     * Tests a single segment input.\n     */\n    @Test\n    public void testSingleSegment() {\n        assertEquals(\"s\", convertToShortFormat(\"single\"));\n    }\n\n    // Helper method to simulate the convertToShortFormat method\n    private String convertToShortFormat(String inputStr) {\n        // Split the input string by underscores\n        String[] segments = inputStr.split(\"_\");\n\n        // Extract the first character from each segment and join them\n        StringBuilder shortFormat = new StringBuilder();\n        for (String segment : segments) {\n            if (!segment.isEmpty()) {\n                shortFormat.append(segment.charAt(0));\n            }\n        }\n\n        return shortFormat.toString();\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a string concatenated with underscores to a short format.\n * For example:\n * <pre>\n *     input: f1_p1_g1_b1_c1\n *     output: fpgbc\n * </pre>\n *\n * @param inputStr The input string with segments separated by underscores.\n * @return A short format string derived from the first characters of each segment.\n */\npublic static String convertToShortFormat(String inputStr) {\n\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 505, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Convert a CamelCase string to snake_case.", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef camel_to_snake(camel_str: str) -> str:\n    \"\"\"\n    Convert a CamelCase string to snake_case.\n\n    Args:\n        camel_str (str): The CamelCase string to convert.\n\n    Returns:\n        str: The converted snake_case string.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestCamelToSnake(unittest.TestCase):\n    def test_basic_conversion(self):\n        \"\"\" Test basic CamelCase to snake_case conversion. \"\"\"\n        self.assertEqual(camel_to_snake(\"HelloWorld\"), \"hello_world\")\n\n    def test_multiple_words(self):\n        \"\"\" Test conversion of a CamelCase string with multiple words. \"\"\"\n        self.assertEqual(camel_to_snake(\"ThisIsATest\"), \"this_is_a_test\")\n\n    def test_with_numbers(self):\n        \"\"\" Test conversion with numbers in the string. \"\"\"\n        self.assertEqual(camel_to_snake(\"ConvertThis123String\"), \"convert_this123_string\")\n\n    def test_leading_uppercase(self):\n        \"\"\" Test conversion with leading uppercase letters. \"\"\"\n        self.assertEqual(camel_to_snake(\"PythonFunction\"), \"python_function\")\n\n    def test_empty_string(self):\n        \"\"\" Test conversion of an empty string. \"\"\"\n        self.assertEqual(camel_to_snake(\"\"), \"\")\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef camel_to_snake(camel_str: str) -> str:\n    \"\"\"\n    Convert a CamelCase string to snake_case.\n\n    Args:\n        camel_str (str): The CamelCase string to convert.\n\n    Returns:\n        str: The converted snake_case string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Convert a CamelCase string to snake_case.\n *\n * @param {string} camelStr - The CamelCase string to convert.\n * @returns {string} The converted snake_case string.\n */\nfunction camelToSnake(camelStr) {\n\n}", "test_code": "describe('TestCamelToSnake', () => {\n    it('test basic CamelCase to snake_case conversion', () => {\n        expect(camelToSnake(\"HelloWorld\")).toBe(\"hello_world\");\n    });\n\n    it('test conversion of a CamelCase string with multiple words', () => {\n        expect(camelToSnake(\"ThisIsATest\")).toBe(\"this_is_a_test\");\n    });\n\n    it('test conversion with numbers in the string', () => {\n        expect(camelToSnake(\"ConvertThis123String\")).toBe(\"convert_this123_string\");\n    });\n\n    it('test conversion with leading uppercase letters', () => {\n        expect(camelToSnake(\"PythonFunction\")).toBe(\"python_function\");\n    });\n\n    it('test conversion of an empty string', () => {\n        expect(camelToSnake(\"\")).toBe(\"\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Convert a CamelCase string to snake_case.\n *\n * @param {string} camelStr - The CamelCase string to convert.\n * @returns {string} The converted snake_case string.\n */\nfunction camelToSnake(camelStr) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Convert a CamelCase string to snake_case.\n *\n * @param camelStr - The CamelCase string to convert.\n * @returns The converted snake_case string.\n */\nfunction camelToSnake(camelStr: string): string {\n\n}", "test_code": "describe('TestCamelToSnake', () => {\n    it('test basic CamelCase to snake_case conversion', () => {\n        expect(camelToSnake(\"HelloWorld\")).toBe(\"hello_world\");\n    });\n\n    it('test conversion of a CamelCase string with multiple words', () => {\n        expect(camelToSnake(\"ThisIsATest\")).toBe(\"this_is_a_test\");\n    });\n\n    it('test conversion with numbers in the string', () => {\n        expect(camelToSnake(\"ConvertThis123String\")).toBe(\"convert_this123_string\");\n    });\n\n    it('test conversion with leading uppercase letters', () => {\n        expect(camelToSnake(\"PythonFunction\")).toBe(\"python_function\");\n    });\n\n    it('test conversion of an empty string', () => {\n        expect(camelToSnake(\"\")).toBe(\"\");\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Convert a CamelCase string to snake_case.\n *\n * @param camelStr - The CamelCase string to convert.\n * @returns The converted snake_case string.\n */\nfunction camelToSnake(camelStr: string): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a CamelCase string to snake_case.\n *\n * @param camel_str The CamelCase string to convert.\n *\n * @return The converted snake_case string.\n */\nstd::string convert_camel_to_snake(const std::string &camel_str){}\n", "test_code": "TEST_CASE(\"Test CamelCase to snake_case conversion\", \"[convert_camel_to_snake]\") {\n    SECTION(\"Basic conversion\") {\n        REQUIRE(convert_camel_to_snake(\"HelloWorld\") == \"hello_world\");\n    }\n\n    SECTION(\"Multiple words\") {\n        REQUIRE(convert_camel_to_snake(\"ThisIsATest\") == \"this_is_a_test\");\n    }\n\n    SECTION(\"With numbers\") {\n        REQUIRE(convert_camel_to_snake(\"ConvertThis123String\") == \"convert_this123_string\");\n    }\n\n    SECTION(\"Leading uppercase\") {\n        REQUIRE(convert_camel_to_snake(\"PythonFunction\") == \"python_function\");\n    }\n\n    SECTION(\"Empty string\") {\n        REQUIRE(convert_camel_to_snake(\"\") == \"\");\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a CamelCase string to snake_case.\n *\n * @param camel_str The CamelCase string to convert.\n *\n * @return The converted snake_case string.\n */\nstd::string convert_camel_to_snake(const std::string &camel_str){}\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a CamelCase string to snake_case.\n *\n * @param camelStr The CamelCase string to convert.\n * @return The converted snake_case string.\n */\npublic static String camelToSnake(String camelStr) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for verifying the correctness of the camelToSnake method.\n */\npublic class Tester {\n\n    /**\n     * Tests basic CamelCase to snake_case conversion.\n     */\n    @Test\n    public void testBasicConversion() {\n        assertEquals(\"hello_world\", camelToSnake(\"HelloWorld\"));\n    }\n\n    /**\n     * Tests conversion of a CamelCase string with multiple words.\n     */\n    @Test\n    public void testMultipleWords() {\n        assertEquals(\"this_is_a_test\", camelToSnake(\"ThisIsATest\"));\n    }\n\n    /**\n     * Tests conversion with numbers in the string.\n     */\n    @Test\n    public void testWithNumbers() {\n        assertEquals(\"convert_this123_string\", camelToSnake(\"ConvertThis123String\"));\n    }\n\n    /**\n     * Tests conversion with leading uppercase letters.\n     */\n    @Test\n    public void testLeadingUppercase() {\n        assertEquals(\"python_function\", camelToSnake(\"PythonFunction\"));\n    }\n\n    /**\n     * Tests conversion of an empty string.\n     */\n    @Test\n    public void testEmptyString() {\n        assertEquals(\"\", camelToSnake(\"\"));\n    }\n\n    // Method to be tested\n    private String camelToSnake(String camelStr) {\n        // Use regular expression to insert underscores before each uppercase letter,\n        // and then convert the whole string to lowercase\n        return camelStr.replaceAll(\"(?<!^)(?=[A-Z])\", \"_\").toLowerCase();\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a CamelCase string to snake_case.\n *\n * @param camelStr The CamelCase string to convert.\n * @return The converted snake_case string.\n */\npublic static String camelToSnake(String camelStr) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 506, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Convert a snake_case string to CamelCase", "language_version_list": {"python": {"code_signature": "def snake_to_camel(snake_str: str) -> str:\n    \"\"\"\n    Convert a snake_case string to CamelCase.\n\n    Args:\n        snake_str (str): The snake_case string to convert.\n\n    Returns:\n        str: The converted CamelCase string.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestSnakeToCamel(unittest.TestCase):\n    def test_basic_conversion(self):\n        \"\"\" Test basic snake_case to CamelCase conversion. \"\"\"\n        self.assertEqual(snake_to_camel(\"hello_world\"), \"HelloWorld\")\n\n    def test_multiple_words(self):\n        \"\"\" Test conversion of a snake_case string with multiple words. \"\"\"\n        self.assertEqual(snake_to_camel(\"this_is_a_test\"), \"ThisIsATest\")\n\n    def test_with_numbers(self):\n        \"\"\" Test conversion with numbers in the string. \"\"\"\n        self.assertEqual(snake_to_camel(\"convert_this_123_string\"), \"ConvertThis123String\")\n\n    def test_leading_trailing_underscores(self):\n        \"\"\" Test conversion with leading and trailing underscores. \"\"\"\n        self.assertEqual(snake_to_camel(\"_leading_and_trailing_\"), \"LeadingAndTrailing\")\n        self.assertEqual(snake_to_camel(\"___multiple___underscores___\"), \"MultipleUnderscores\")\n\n    def test_empty_string(self):\n        \"\"\" Test conversion of an empty string. \"\"\"\n        self.assertEqual(snake_to_camel(\"\"), \"\")", "prompt": "please write a python function , the function signature as below def snake_to_camel(snake_str: str) -> str:\n    \"\"\"\n    Convert a snake_case string to CamelCase.\n\n    Args:\n        snake_str (str): The snake_case string to convert.\n\n    Returns:\n        str: The converted CamelCase string.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Convert a snake_case string to CamelCase.\n *\n * @param {string} snakeStr - The snake_case string to convert.\n * @returns {string} The converted CamelCase string.\n */\nfunction snakeToCamel(snakeStr) {\n\n}", "test_code": "describe('Test snakeToCamel', () => {\n    test('test basic snake_case to CamelCase conversion', () => {\n        expect(snakeToCamel(\"hello_world\")).toBe(\"HelloWorld\");\n    });\n\n    test('test conversion of a snake_case string with multiple words', () => {\n        expect(snakeToCamel(\"this_is_a_test\")).toBe(\"ThisIsATest\");\n    });\n\n    test('test conversion with numbers in the string', () => {\n        expect(snakeToCamel(\"convert_this_123_string\")).toBe(\"ConvertThis123String\");\n    });\n\n    test('test conversion with leading and trailing underscores', () => {\n        expect(snakeToCamel(\"_leading_and_trailing_\")).toBe(\"LeadingAndTrailing\");\n        expect(snakeToCamel(\"___multiple___underscores___\")).toBe(\"MultipleUnderscores\");\n    });\n\n    test('test conversion of an empty string', () => {\n        expect(snakeToCamel(\"\")).toBe(\"\");\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Convert a snake_case string to CamelCase.\n *\n * @param {string} snakeStr - The snake_case string to convert.\n * @returns {string} The converted CamelCase string.\n */\nfunction snakeToCamel(snakeStr) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a snake_case string to CamelCase.\n *\n * @param snakeStr - The snake_case string to convert.\n * @returns The converted CamelCase string.\n */\nfunction snakeToCamel(snakeStr: string): string {\n\n}", "test_code": "describe('Test snakeToCamel', () => {\n    it('test basic conversion', () => {\n        // Test basic snake_case to CamelCase conversion\n        expect(snakeToCamel(\"hello_world\")).toBe(\"HelloWorld\");\n    });\n\n    it('test conversion of a snake_case string with multiple words', () => {\n        // Test conversion of a snake_case string with multiple words\n        expect(snakeToCamel(\"this_is_a_test\")).toBe(\"ThisIsATest\");\n    });\n\n    it('test conversion with numbers in the string', () => {\n        // Test conversion with numbers in the string\n        expect(snakeToCamel(\"convert_this_123_string\")).toBe(\"ConvertThis123String\");\n    });\n\n    it('test conversion with leading and trailing underscores', () => {\n        // Test conversion with leading and trailing underscores\n        expect(snakeToCamel(\"_leading_and_trailing_\")).toBe(\"LeadingAndTrailing\");\n        expect(snakeToCamel(\"___multiple___underscores___\")).toBe(\"MultipleUnderscores\");\n    });\n\n    it('test conversion of an empty string', () => {\n        // Test conversion of an empty string\n        expect(snakeToCamel(\"\")).toBe(\"\");\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a snake_case string to CamelCase.\n *\n * @param snakeStr - The snake_case string to convert.\n * @returns The converted CamelCase string.\n */\nfunction snakeToCamel(snakeStr: string): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a snake_case string to CamelCase.\n *\n * @param snake_str The snake_case string to convert.\n *\n * @return The converted CamelCase string.\n */\nstd::string snake_to_camel(const std::string& snake_str) {}", "test_code": "TEST_CASE(\"Test basic snake_case to CamelCase conversion\", \"[snake_to_camel]\") {\n    CHECK(snake_to_camel(\"hello_world\") == \"HelloWorld\");\n}\n\nTEST_CASE(\"Test conversion of a snake_case string with multiple words\", \"[snake_to_camel]\") {\n    CHECK(snake_to_camel(\"this_is_a_test\") == \"ThisIsATest\");\n}\n\nTEST_CASE(\"Test conversion with numbers in the string\", \"[snake_to_camel]\") {\n    CHECK(snake_to_camel(\"convert_this_123_string\") == \"ConvertThis123String\");\n}\n\nTEST_CASE(\"Test conversion with leading and trailing underscores\", \"[snake_to_camel]\") {\n    CHECK(snake_to_camel(\"_leading_and_trailing_\") == \"LeadingAndTrailing\");\n    CHECK(snake_to_camel(\"___multiple___underscores___\") == \"MultipleUnderscores\");\n}\n\nTEST_CASE(\"Test conversion of an empty string\", \"[snake_to_camel]\") {\n    CHECK(snake_to_camel(\"\") == \"\");\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a snake_case string to CamelCase.\n *\n * @param snake_str The snake_case string to convert.\n *\n * @return The converted CamelCase string.\n */\nstd::string snake_to_camel(const std::string& snake_str) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a snake_case string to CamelCase.\n *\n * @param snakeStr The snake_case string to convert.\n * @return The converted CamelCase string.\n */\npublic static String snakeToCamel(String snakeStr) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for converting snake_case strings to CamelCase.\n */\npublic class Tester {\n\n    /**\n     * Converts a snake_case string to CamelCase.\n     *\n     * @param snakeStr The snake_case string to convert.\n     * @return The converted CamelCase string.\n     */\n    public static String snakeToCamel(String snakeStr) {\n        // Split the snake_case string into words\n        String[] words = snakeStr.split(\"_\");\n\n        // Capitalize the first letter of each word and join them\n        StringBuilder camelCaseStr = new StringBuilder();\n        for (String word : words) {\n            if (!word.isEmpty()) {\n                camelCaseStr.append(Character.toUpperCase(word.charAt(0)));\n                camelCaseStr.append(word.substring(1));\n            }\n        }\n        return camelCaseStr.toString();\n    }\n\n    @Test\n    public void testBasicConversion() {\n        // Test basic snake_case to CamelCase conversion\n        assertEquals(\"HelloWorld\", snakeToCamel(\"hello_world\"));\n    }\n\n    @Test\n    public void testMultipleWords() {\n        // Test conversion of a snake_case string with multiple words\n        assertEquals(\"ThisIsATest\", snakeToCamel(\"this_is_a_test\"));\n    }\n\n    @Test\n    public void testWithNumbers() {\n        // Test conversion with numbers in the string\n        assertEquals(\"ConvertThis123String\", snakeToCamel(\"convert_this_123_string\"));\n    }\n\n    @Test\n    public void testLeadingTrailingUnderscores() {\n        // Test conversion with leading and trailing underscores\n        assertEquals(\"LeadingAndTrailing\", snakeToCamel(\"_leading_and_trailing_\"));\n        assertEquals(\"MultipleUnderscores\", snakeToCamel(\"___multiple___underscores___\"));\n    }\n\n    @Test\n    public void testEmptyString() {\n        // Test conversion of an empty string\n        assertEquals(\"\", snakeToCamel(\"\"));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a snake_case string to CamelCase.\n *\n * @param snakeStr The snake_case string to convert.\n * @return The converted CamelCase string.\n */\npublic static String snakeToCamel(String snakeStr) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 507, "code_type": "method", "original_language": "python", "question_type": "Program input code", "summary": "Check that a password satisfies the criteria for a strong password, has at least one lowercase letter, at least one uppercase letter, at least one number, and is at least 8 bits long", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef is_strong_password(password: str) -> bool:\n    \"\"\"\n    Check if the provided password is strong.\n\n    A strong password must satisfy the following criteria:\n    - At least one lowercase letter\n    - At least one uppercase letter\n    - At least one number\n    - At least 8 characters long\n\n    Args:\n        password (str): The password to check.\n\n    Returns:\n        bool: True if the password is strong, False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestStrongPassword(unittest.TestCase):\n    def test_valid_password(self):\n        \"\"\" Test a strong password that meets all criteria. \"\"\"\n        self.assertTrue(is_strong_password(\"StrongPass1\"))\n\n    def test_missing_lowercase(self):\n        \"\"\" Test a password missing a lowercase letter. \"\"\"\n        self.assertFalse(is_strong_password(\"STRONGPASS1\"))\n\n    def test_missing_uppercase(self):\n        \"\"\" Test a password missing an uppercase letter. \"\"\"\n        self.assertFalse(is_strong_password(\"strongpass1\"))\n\n    def test_missing_number(self):\n        \"\"\" Test a password missing a number. \"\"\"\n        self.assertFalse(is_strong_password(\"StrongPassword\"))\n\n    def test_too_short(self):\n        \"\"\" Test a password that is too short. \"\"\"\n        self.assertFalse(is_strong_password(\"Short1\"))\n\n    def test_valid_with_special_characters(self):\n        \"\"\" Test a password that includes special characters but is still strong. \"\"\"\n        self.assertTrue(is_strong_password(\"Strong!Password1\"))", "prompt": "please write a python function , the function signature as below import re\n\n\ndef is_strong_password(password: str) -> bool:\n    \"\"\"\n    Check if the provided password is strong.\n\n    A strong password must satisfy the following criteria:\n    - At least one lowercase letter\n    - At least one uppercase letter\n    - At least one number\n    - At least 8 characters long\n\n    Args:\n        password (str): The password to check.\n\n    Returns:\n        bool: True if the password is strong, False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Check if the provided password is strong.\n *\n * A strong password must satisfy the following criteria:\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one number\n * - At least 8 characters long\n *\n * @param {string} password - The password to check.\n * @returns {boolean} - True if the password is strong, False otherwise.\n */\nfunction isStrongPassword(password) {\n\n}", "test_code": "describe('TestStrongPassword', () => {\n    it('should validate a strong password that meets all criteria', () => {\n        expect(isStrongPassword(\"StrongPass1\")).toBe(true);\n    });\n\n    it('should fail a password missing a lowercase letter', () => {\n        expect(isStrongPassword(\"STRONGPASS1\")).toBe(false);\n    });\n\n    it('should fail a password missing an uppercase letter', () => {\n        expect(isStrongPassword(\"strongpass1\")).toBe(false);\n    });\n\n    it('should fail a password missing a number', () => {\n        expect(isStrongPassword(\"StrongPassword\")).toBe(false);\n    });\n\n    it('should fail a password that is too short', () => {\n        expect(isStrongPassword(\"Short1\")).toBe(false);\n    });\n\n    it('should validate a password that includes special characters but is still strong', () => {\n        expect(isStrongPassword(\"Strong!Password1\")).toBe(true);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Check if the provided password is strong.\n *\n * A strong password must satisfy the following criteria:\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one number\n * - At least 8 characters long\n *\n * @param {string} password - The password to check.\n * @returns {boolean} - True if the password is strong, False otherwise.\n */\nfunction isStrongPassword(password) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Check if the provided password is strong.\n *\n * A strong password must satisfy the following criteria:\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one number\n * - At least 8 characters long\n *\n * @param password - The password to check.\n * @returns true if the password is strong, false otherwise.\n */\nfunction isStrongPassword(password: string): boolean {\n\n}", "test_code": "describe('TestStrongPassword', () => {\n  it('test valid password', () => {\n    // Test a strong password that meets all criteria.\n    expect(isStrongPassword(\"StrongPass1\")).toBe(true);\n  });\n\n  it('test missing lowercase', () => {\n    // Test a password missing a lowercase letter.\n    expect(isStrongPassword(\"STRONGPASS1\")).toBe(false);\n  });\n\n  it('test missing uppercase', () => {\n    // Test a password missing an uppercase letter.\n    expect(isStrongPassword(\"strongpass1\")).toBe(false);\n  });\n\n  it('test missing number', () => {\n    // Test a password missing a number.\n    expect(isStrongPassword(\"StrongPassword\")).toBe(false);\n  });\n\n  it('test too short', () => {\n    // Test a password that is too short.\n    expect(isStrongPassword(\"Short1\")).toBe(false);\n  });\n\n  it('test valid with special characters', () => {\n    // Test a password that includes special characters but is still strong.\n    expect(isStrongPassword(\"Strong!Password1\")).toBe(true);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Check if the provided password is strong.\n *\n * A strong password must satisfy the following criteria:\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one number\n * - At least 8 characters long\n *\n * @param password - The password to check.\n * @returns true if the password is strong, false otherwise.\n */\nfunction isStrongPassword(password: string): boolean {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Checks if the provided password is strong.\n *\n * A strong password must satisfy the following criteria:\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one number\n * - At least 8 characters long\n *\n * @param password The password to check.\n *\n * @return True if the password is strong; false otherwise.\n */\nbool is_strong_password(const std::string& password) {}", "test_code": "TEST_CASE(\"Test a strong password that meets all criteria\", \"[valid_password]\") {\n    REQUIRE(is_strong_password(\"StrongPass1\"));\n}\n\nTEST_CASE(\"Test a password missing a lowercase letter\", \"[missing_lowercase]\") {\n    REQUIRE_FALSE(is_strong_password(\"STRONGPASS1\"));\n}\n\nTEST_CASE(\"Test a password missing an uppercase letter\", \"[missing_uppercase]\") {\n    REQUIRE_FALSE(is_strong_password(\"strongpass1\"));\n}\n\nTEST_CASE(\"Test a password missing a number\", \"[missing_number]\") {\n    REQUIRE_FALSE(is_strong_password(\"StrongPassword\"));\n}\n\nTEST_CASE(\"Test a password that is too short\", \"[too_short]\") {\n    REQUIRE_FALSE(is_strong_password(\"Short1\"));\n}\n\nTEST_CASE(\"Test a password that includes special characters but is still strong\", \"[valid_with_special_characters]\") {\n    REQUIRE(is_strong_password(\"Strong!Password1\"));\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Checks if the provided password is strong.\n *\n * A strong password must satisfy the following criteria:\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one number\n * - At least 8 characters long\n *\n * @param password The password to check.\n *\n * @return True if the password is strong; false otherwise.\n */\nbool is_strong_password(const std::string& password) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Check if the provided password is strong.\n *\n * A strong password must satisfy the following criteria:\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one number\n * - At least 8 characters long\n *\n * @param password The password to check.\n * @return true if the password is strong, false otherwise.\n */\npublic static boolean isStrongPassword(String password) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class Tester {\n\n    /**\n     * Test a strong password that meets all criteria.\n     */\n    @Test\n    public void testValidPassword() {\n        assertTrue(isStrongPassword(\"StrongPass1\"));\n    }\n\n    /**\n     * Test a password missing a lowercase letter.\n     */\n    @Test\n    public void testMissingLowercase() {\n        assertFalse(isStrongPassword(\"STRONGPASS1\"));\n    }\n\n    /**\n     * Test a password missing an uppercase letter.\n     */\n    @Test\n    public void testMissingUppercase() {\n        assertFalse(isStrongPassword(\"strongpass1\"));\n    }\n\n    /**\n     * Test a password missing a number.\n     */\n    @Test\n    public void testMissingNumber() {\n        assertFalse(isStrongPassword(\"StrongPassword\"));\n    }\n\n    /**\n     * Test a password that is too short.\n     */\n    @Test\n    public void testTooShort() {\n        assertFalse(isStrongPassword(\"Short1\"));\n    }\n\n    /**\n     * Test a password that includes special characters but is still strong.\n     */\n    @Test\n    public void testValidWithSpecialCharacters() {\n        assertTrue(isStrongPassword(\"Strong!Password1\"));\n    }\n\n    // Utility method to check if a password is strong\n    private boolean isStrongPassword(String password) {\n        // Check password length\n        if (password.length() < 8) {\n            return false;\n        }\n\n        // Check for at least one lowercase letter\n        if (!password.matches(\".*[a-z].*\")) {\n            return false;\n        }\n\n        // Check for at least one uppercase letter\n        if (!password.matches(\".*[A-Z].*\")) {\n            return false;\n        }\n\n        // Check for at least one number\n        if (!password.matches(\".*\\\\d.*\")) {\n            return false;\n        }\n\n        // If all checks passed, return true\n        return true;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Check if the provided password is strong.\n *\n * A strong password must satisfy the following criteria:\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one number\n * - At least 8 characters long\n *\n * @param password The password to check.\n * @return true if the password is strong, false otherwise.\n */\npublic static boolean isStrongPassword(String password) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 509, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Perform modular exponentiation: (base^exponent) % modulus efficiently.", "language_version_list": {"python": {"code_signature": "def mod_exp(base:int, exponent:int, modulus:int) -> int:\n    \"\"\"\n    Perform modular exponentiation: (base^exponent) % modulus efficiently.\n\n    Args:\n        base (int): The base value.\n        exponent (int): The exponent value (should be non-negative).\n        modulus (int): The modulus value (should be positive).\n\n    Returns:\n        int: The result of (base^exponent) % modulus.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestModExp(unittest.TestCase):\n    def test_case_1(self):\n        \"\"\" Test with base = 2, exponent = 10, modulus = 1000 \"\"\"\n        self.assertEqual(mod_exp(2, 10, 1000), 24)\n\n    def test_case_2(self):\n        \"\"\" Test with base = 3, exponent = 7, modulus = 50 \"\"\"\n        self.assertEqual(mod_exp(3, 7, 50), 37)\n\n    def test_case_3(self):\n        \"\"\" Test with base = 5, exponent = 0, modulus = 13 (any number^0 = 1) \"\"\"\n        self.assertEqual(mod_exp(5, 0, 13), 1)\n\n    def test_case_4(self):\n        \"\"\" Test with base = 7, exponent = 5, modulus = 20 \"\"\"\n        self.assertEqual(mod_exp(7, 5, 20), 7)  # 7^5 = 16807, 16807 % 20 = 7\n\n    def test_case_5(self):\n        \"\"\" Test with base = 10, exponent = 5, modulus = 6 \"\"\"\n        self.assertEqual(mod_exp(10, 5, 6), 4)  # 10^5 = 100000, 100000 % 6 = 4", "prompt": "please write a python function , the function signature as below def mod_exp(base:int, exponent:int, modulus:int) -> int:\n    \"\"\"\n    Perform modular exponentiation: (base^exponent) % modulus efficiently.\n\n    Args:\n        base (int): The base value.\n        exponent (int): The exponent value (should be non-negative).\n        modulus (int): The modulus value (should be positive).\n\n    Returns:\n        int: The result of (base^exponent) % modulus.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Perform modular exponentiation: (base^exponent) % modulus efficiently.\n *\n * @param {number} base - The base value.\n * @param {number} exponent - The exponent value (should be non-negative).\n * @param {number} modulus - The modulus value (should be positive).\n * @returns {number} The result of (base^exponent) % modulus.\n */\nfunction modExp(base, exponent, modulus) {\n\n}", "test_code": "", "prompt": "please write a javascript function , the function signature as below /**\n * Perform modular exponentiation: (base^exponent) % modulus efficiently.\n *\n * @param {number} base - The base value.\n * @param {number} exponent - The exponent value (should be non-negative).\n * @param {number} modulus - The modulus value (should be positive).\n * @returns {number} The result of (base^exponent) % modulus.\n */\nfunction modExp(base, exponent, modulus) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Perform modular exponentiation: (base^exponent) % modulus efficiently.\n *\n * @param base - The base value.\n * @param exponent - The exponent value (should be non-negative).\n * @param modulus - The modulus value (should be positive).\n * @returns The result of (base^exponent) % modulus.\n * @throws {Error} If modulus is less than or equal to zero.\n */\nfunction modExp(base: number, exponent: number, modulus: number): number {\n\n}", "test_code": "describe('TestModExp', () => {\n  it('test_case_1', () => {\n    // Test with base = 2, exponent = 10, modulus = 1000\n    expect(modExp(2, 10, 1000)).toBe(24);\n  });\n\n  it('test_case_2', () => {\n    // Test with base = 3, exponent = 7, modulus = 50\n    expect(modExp(3, 7, 50)).toBe(37);\n  });\n\n  it('test_case_3', () => {\n    // Test with base = 5, exponent = 0, modulus = 13 (any number^0 = 1)\n    expect(modExp(5, 0, 13)).toBe(1);\n  });\n\n  it('test_case_4', () => {\n    // Test with base = 7, exponent = 5, modulus = 20\n    expect(modExp(7, 5, 20)).toBe(7);  // 7^5 = 16807, 16807 % 20 = 7\n  });\n\n  it('test_case_5', () => {\n    // Test with base = 10, exponent = 5, modulus = 6\n    expect(modExp(10, 5, 6)).toBe(4);  // 10^5 = 100000, 100000 % 6 = 4\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Perform modular exponentiation: (base^exponent) % modulus efficiently.\n *\n * @param base - The base value.\n * @param exponent - The exponent value (should be non-negative).\n * @param modulus - The modulus value (should be positive).\n * @returns The result of (base^exponent) % modulus.\n * @throws {Error} If modulus is less than or equal to zero.\n */\nfunction modExp(base: number, exponent: number, modulus: number): number {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Perform modular exponentiation: (base^exponent) % modulus efficiently.\n *\n * @param base The base value.\n * @param exponent The exponent value (should be non-negative).\n * @param modulus The modulus value (should be positive).\n * @return The result of (base^exponent) % modulus.\n * @throws std::invalid_argument If modulus is less than or equal to zero.\n */\nlong long mod_exp(long long base, long long exponent, long long modulus) {}", "test_code": "TEST_CASE(\"Test modular exponentiation\", \"[mod_exp]\") {\n    SECTION(\"Test with base = 2, exponent = 10, modulus = 1000\") {\n        REQUIRE(mod_exp(2, 10, 1000) == 24);\n    }\n\n    SECTION(\"Test with base = 3, exponent = 7, modulus = 50\") {\n        REQUIRE(mod_exp(3, 7, 50) == 37);\n    }\n\n    SECTION(\"Test with base = 5, exponent = 0, modulus = 13 (any number^0 = 1)\") {\n        REQUIRE(mod_exp(5, 0, 13) == 1);\n    }\n\n    SECTION(\"Test with base = 7, exponent = 5, modulus = 20\") {\n        REQUIRE(mod_exp(7, 5, 20) == 7);  // 7^5 = 16807, 16807 % 20 = 7\n    }\n\n    SECTION(\"Test with base = 10, exponent = 5, modulus = 6\") {\n        REQUIRE(mod_exp(10, 5, 6) == 4);  // 10^5 = 100000, 100000 % 6 = 4\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Perform modular exponentiation: (base^exponent) % modulus efficiently.\n *\n * @param base The base value.\n * @param exponent The exponent value (should be non-negative).\n * @param modulus The modulus value (should be positive).\n * @return The result of (base^exponent) % modulus.\n * @throws std::invalid_argument If modulus is less than or equal to zero.\n */\nlong long mod_exp(long long base, long long exponent, long long modulus) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Performs modular exponentiation: (base^exponent) % modulus efficiently.\n *\n * @param base     The base value.\n * @param exponent The exponent value (should be non-negative).\n * @param modulus  The modulus value (should be positive).\n * @return The result of (base^exponent) % modulus.\n * @throws IllegalArgumentException If modulus is less than or equal to zero.\n */\npublic static int modExp(int base, int exponent, int modulus) {\n\n}\n\n", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for modular exponentiation.\n */\npublic class Tester {\n\n    /**\n     * Test with base = 2, exponent = 10, modulus = 1000.\n     */\n    @Test\n    public void testCase1() {\n        assertEquals(\"Test with base = 2, exponent = 10, modulus = 1000\", 24, modExp(2, 10, 1000));\n    }\n\n    /**\n     * Test with base = 3, exponent = 7, modulus = 50.\n     */\n    @Test\n    public void testCase2() {\n        assertEquals(\"Test with base = 3, exponent = 7, modulus = 50\", 37, modExp(3, 7, 50));\n    }\n\n    /**\n     * Test with base = 5, exponent = 0, modulus = 13 (any number^0 = 1).\n     */\n    @Test\n    public void testCase3() {\n        assertEquals(\"Test with base = 5, exponent = 0, modulus = 13\", 1, modExp(5, 0, 13));\n    }\n\n    /**\n     * Test with base = 7, exponent = 5, modulus = 20.\n     */\n    @Test\n    public void testCase4() {\n        assertEquals(\"Test with base = 7, exponent = 5, modulus = 20\", 7, modExp(7, 5, 20));\n    }\n\n    /**\n     * Test with base = 10, exponent = 5, modulus = 6.\n     */\n    @Test\n    public void testCase5() {\n        assertEquals(\"Test with base = 10, exponent = 5, modulus = 6\", 4, modExp(10, 5, 6));\n    }\n\n    /**\n     * Performs modular exponentiation: (base^exponent) % modulus efficiently.\n     *\n     * @param base     The base value.\n     * @param exponent The exponent value (should be non-negative).\n     * @param modulus  The modulus value (should be positive).\n     * @return The result of (base^exponent) % modulus.\n     * @throws IllegalArgumentException If modulus is less than or equal to zero.\n     */\n    private static int modExp(int base, int exponent, int modulus) {\n        if (modulus <= 0) {\n            throw new IllegalArgumentException(\"Modulus must be a positive integer.\");\n        }\n\n        int result = 1;\n        base = base % modulus;  // Ensure base is within the modulus\n\n        while (exponent > 0) {\n            // If exponent is odd, multiply the base with the result\n            if (exponent % 2 == 1) {\n                result = (result * base) % modulus;\n            }\n\n            // Right shift the exponent by 1 (equivalent to exponent //= 2)\n            exponent >>= 1;\n            // Square the base\n            base = (base * base) % modulus;\n        }\n\n        return result;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Performs modular exponentiation: (base^exponent) % modulus efficiently.\n *\n * @param base     The base value.\n * @param exponent The exponent value (should be non-negative).\n * @param modulus  The modulus value (should be positive).\n * @return The result of (base^exponent) % modulus.\n * @throws IllegalArgumentException If modulus is less than or equal to zero.\n */\npublic static int modExp(int base, int exponent, int modulus) {\n\n}\n\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 510, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Find the powers of 2 and 3 that multiply to produce the given number.", "language_version_list": {"python": {"code_signature": "def find_powers(num: int) -> tuple:\n    \"\"\"\n    Find the powers of 2 and 3 that multiply to produce the given number.\n\n    Args:\n        num (int): A positive integer greater than zero.\n\n    Returns:\n        tuple: A tuple (n, m) where n is the power of 2 and m is the power of 3.\n           Returns None if the number is zero or if the number has prime factors other than 2 and 3.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestFindPowers(unittest.TestCase):\n\n    def test_valid_cases(self):\n        \"\"\"Test valid numbers with only 2's and 3's as prime factors.\"\"\"\n        self.assertEqual(find_powers(18), (1, 2))  # 18 = 2^1 * 3^2\n        self.assertEqual(find_powers(8), (3, 0))   # 8 = 2^3 * 3^0\n        self.assertEqual(find_powers(27), (0, 3))  # 27 = 2^0 * 3^3\n        self.assertEqual(find_powers(12), (2, 1))  # 12 = 2^2 * 3^1\n        self.assertEqual(find_powers(1), (0, 0))    # 1 = 2^0 * 3^0\n\n    def test_invalid_cases(self):\n        \"\"\"Test numbers with prime factors other than 2 and 3.\"\"\"\n        self.assertIsNone(find_powers(7))    # 7 is a prime factor\n        self.assertIsNone(find_powers(14))   # 14 = 2^1 * 7^1 (contains 7)\n        self.assertIsNone(find_powers(10))   # 10 = 2^1 * 5^1 (contains 5)\n\n\n    def test_large_numbers(self):\n        \"\"\"Test large numbers that have only 2 and 3 as prime factors.\"\"\"\n        self.assertEqual(find_powers(864), (5, 3))  # 864 = 2^5 * 3^3\n        self.assertEqual(find_powers(729), (0, 6))  # 729 = 2^0 * 3^6\n\n    def test_edge_cases(self):\n        \"\"\"Test edge cases for minimal inputs.\"\"\"\n        self.assertEqual(find_powers(2), (1, 0))   # 2 = 2^1 * 3^0\n        self.assertEqual(find_powers(3), (0, 1))   # 3 = 2^0 * 3^1", "prompt": "please write a python function , the function signature as below def find_powers(num: int) -> tuple:\n    \"\"\"\n    Find the powers of 2 and 3 that multiply to produce the given number.\n\n    Args:\n        num (int): A positive integer greater than zero.\n\n    Returns:\n        tuple: A tuple (n, m) where n is the power of 2 and m is the power of 3.\n           Returns None if the number is zero or if the number has prime factors other than 2 and 3.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Find the powers of 2 and 3 that multiply to produce the given number.\n *\n * @param {number} num - A positive integer greater than zero.\n * @returns {Array|null} An array [n, m] where n is the power of 2 and m is the power of 3.\n *                       Returns null if the number is zero or if the number has prime factors other than 2 and 3.\n */\nfunction findPowers(num) {\n\n}", "test_code": "describe('TestFindPowers', () => {\n    describe('Valid Cases', () => {\n        it('should handle valid numbers with only 2\\'s and 3\\'s as prime factors', () => {\n            expect(findPowers(18)).toEqual([1, 2]);  // 18 = 2^1 * 3^2\n            expect(findPowers(8)).toEqual([3, 0]);   // 8 = 2^3 * 3^0\n            expect(findPowers(27)).toEqual([0, 3]);  // 27 = 2^0 * 3^3\n            expect(findPowers(12)).toEqual([2, 1]);  // 12 = 2^2 * 3^1\n            expect(findPowers(1)).toEqual([0, 0]);   // 1 = 2^0 * 3^0\n        });\n    });\n\n    describe('Invalid Cases', () => {\n        it('should handle numbers with prime factors other than 2 and 3', () => {\n            expect(findPowers(7)).toBeNull();    // 7 is a prime factor\n            expect(findPowers(14)).toBeNull();   // 14 = 2^1 * 7^1 (contains 7)\n            expect(findPowers(10)).toBeNull();   // 10 = 2^1 * 5^1 (contains 5)\n        });\n    });\n\n    describe('Large Numbers', () => {\n        it('should handle large numbers that have only 2 and 3 as prime factors', () => {\n            expect(findPowers(864)).toEqual([5, 3]);  // 864 = 2^5 * 3^3\n            expect(findPowers(729)).toEqual([0, 6]);  // 729 = 2^0 * 3^6\n        });\n    });\n\n    describe('Edge Cases', () => {\n        it('should handle edge cases for minimal inputs', () => {\n            expect(findPowers(2)).toEqual([1, 0]);   // 2 = 2^1 * 3^0\n            expect(findPowers(3)).toEqual([0, 1]);   // 3 = 2^0 * 3^1\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Find the powers of 2 and 3 that multiply to produce the given number.\n *\n * @param {number} num - A positive integer greater than zero.\n * @returns {Array|null} An array [n, m] where n is the power of 2 and m is the power of 3.\n *                       Returns null if the number is zero or if the number has prime factors other than 2 and 3.\n */\nfunction findPowers(num) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Find the powers of 2 and 3 that multiply to produce the given number.\n *\n * @param num - A positive integer greater than zero.\n * @returns A tuple [n, m] where n is the power of 2 and m is the power of 3.\n *          Returns null if the number is zero or if the number has prime factors other than 2 and 3.\n */\nfunction findPowers(num: number): [number, number] | null {\n\n}", "test_code": "describe('TestFindPowers', () => {\n  describe('test valid cases', () => {\n    it('should handle numbers with only 2\\'s and 3\\'s as prime factors', () => {\n      expect(findPowers(18)).toEqual([1, 2]);  // 18 = 2^1 * 3^2\n      expect(findPowers(8)).toEqual([3, 0]);   // 8 = 2^3 * 3^0\n      expect(findPowers(27)).toEqual([0, 3]);  // 27 = 2^0 * 3^3\n      expect(findPowers(12)).toEqual([2, 1]);  // 12 = 2^2 * 3^1\n      expect(findPowers(1)).toEqual([0, 0]);   // 1 = 2^0 * 3^0\n    });\n  });\n\n  describe('test invalid cases', () => {\n    it('should return null for numbers with prime factors other than 2 and 3', () => {\n      expect(findPowers(7)).toBeNull();    // 7 is a prime factor\n      expect(findPowers(14)).toBeNull();   // 14 = 2^1 * 7^1 (contains 7)\n      expect(findPowers(10)).toBeNull();   // 10 = 2^1 * 5^1 (contains 5)\n    });\n  });\n\n  describe('test large numbers', () => {\n    it('should handle large numbers with only 2 and 3 as prime factors', () => {\n      expect(findPowers(864)).toEqual([5, 3]);  // 864 = 2^5 * 3^3\n      expect(findPowers(729)).toEqual([0, 6]);  // 729 = 2^0 * 3^6\n    });\n  });\n\n  describe('test edge cases', () => {\n    it('should handle minimal inputs', () => {\n      expect(findPowers(2)).toEqual([1, 0]);   // 2 = 2^1 * 3^0\n      expect(findPowers(3)).toEqual([0, 1]);   // 3 = 2^0 * 3^1\n    });\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Find the powers of 2 and 3 that multiply to produce the given number.\n *\n * @param num - A positive integer greater than zero.\n * @returns A tuple [n, m] where n is the power of 2 and m is the power of 3.\n *          Returns null if the number is zero or if the number has prime factors other than 2 and 3.\n */\nfunction findPowers(num: number): [number, number] | null {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Find the powers of 2 and 3 that multiply to produce the given number.\n *\n * @param num A positive integer greater than zero.\n * @return A pair (n, m) where n is the power of 2 and m is the power of 3.\n *         Returns (-1, -1) if the number is zero or if the number has prime factors other than 2 and 3.\n */\nstd::pair<int, int> find_powers(int num) {}", "test_code": "TEST_CASE(\"Test valid cases\", \"[find_powers]\") {\n    SECTION(\"Valid numbers with only 2's and 3's as prime factors\") {\n        CHECK(find_powers(18) == std::make_pair(1, 2));  // 18 = 2^1 * 3^2\n        CHECK(find_powers(8) == std::make_pair(3, 0));   // 8 = 2^3 * 3^0\n        CHECK(find_powers(27) == std::make_pair(0, 3));  // 27 = 2^0 * 3^3\n        CHECK(find_powers(12) == std::make_pair(2, 1));  // 12 = 2^2 * 3^1\n        CHECK(find_powers(1) == std::make_pair(0, 0));   // 1 = 2^0 * 3^0\n    }\n}\n\nTEST_CASE(\"Test invalid cases\", \"[find_powers]\") {\n    SECTION(\"Numbers with prime factors other than 2 and 3\") {\n        CHECK(find_powers(7) == std::make_pair(-1, -1));  // 7 is a prime factor\n        CHECK(find_powers(14) == std::make_pair(-1, -1)); // 14 = 2^1 * 7^1 (contains 7)\n        CHECK(find_powers(10) == std::make_pair(-1, -1)); // 10 = 2^1 * 5^1 (contains 5)\n    }\n}\n\nTEST_CASE(\"Test large numbers\", \"[find_powers]\") {\n    SECTION(\"Large numbers that have only 2 and 3 as prime factors\") {\n        CHECK(find_powers(864) == std::make_pair(5, 3));  // 864 = 2^5 * 3^3\n        CHECK(find_powers(729) == std::make_pair(0, 6));  // 729 = 2^0 * 3^6\n    }\n}\n\nTEST_CASE(\"Test edge cases\", \"[find_powers]\") {\n    SECTION(\"Edge cases for minimal inputs\") {\n        CHECK(find_powers(2) == std::make_pair(1, 0));  // 2 = 2^1 * 3^0\n        CHECK(find_powers(3) == std::make_pair(0, 1));  // 3 = 2^0 * 3^1\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Find the powers of 2 and 3 that multiply to produce the given number.\n *\n * @param num A positive integer greater than zero.\n * @return A pair (n, m) where n is the power of 2 and m is the power of 3.\n *         Returns (-1, -1) if the number is zero or if the number has prime factors other than 2 and 3.\n */\nstd::pair<int, int> find_powers(int num) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds the powers of 2 and 3 that multiply to produce the given number.\n *\n * @param num A positive integer greater than zero.\n * @return An array (n, m) where n is the power of 2 and m is the power of 3.\n *         Returns null if the number is zero or if the number has prime factors other than 2 and 3.\n */\npublic static Integer[] findPowers(int num) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Test class for verifying the correctness of the findPowers method.\n */\npublic class Tester {\n\n    /**\n     * Tests valid numbers with only 2's and 3's as prime factors.\n     */\n    @Test\n    public void testValidCases() {\n        assertEquals(\"(1, 2)\", Arrays.toString(findPowers(18)));  // 18 = 2^1 * 3^2\n        assertEquals(\"(3, 0)\", Arrays.toString(findPowers(8)));   // 8 = 2^3 * 3^0\n        assertEquals(\"(0, 3)\", Arrays.toString(findPowers(27)));  // 27 = 2^0 * 3^3\n        assertEquals(\"(2, 1)\", Arrays.toString(findPowers(12)));  // 12 = 2^2 * 3^1\n        assertEquals(\"(0, 0)\", Arrays.toString(findPowers(1)));   // 1 = 2^0 * 3^0\n    }\n\n    /**\n     * Tests numbers with prime factors other than 2 and 3.\n     */\n    @Test\n    public void testInvalidCases() {\n        assertNull(findPowers(7));    // 7 is a prime factor\n        assertNull(findPowers(14));   // 14 = 2^1 * 7^1 (contains 7)\n        assertNull(findPowers(10));   // 10 = 2^1 * 5^1 (contains 5)\n    }\n\n    /**\n     * Tests large numbers that have only 2 and 3 as prime factors.\n     */\n    @Test\n    public void testLargeNumbers() {\n        assertEquals(\"(5, 3)\", Arrays.toString(findPowers(864)));  // 864 = 2^5 * 3^3\n        assertEquals(\"(0, 6)\", Arrays.toString(findPowers(729)));  // 729 = 2^0 * 3^6\n    }\n\n    /**\n     * Tests edge cases for minimal inputs.\n     */\n    @Test\n    public void testEdgeCases() {\n        assertEquals(\"(1, 0)\", Arrays.toString(findPowers(2)));   // 2 = 2^1 * 3^0\n        assertEquals(\"(0, 1)\", Arrays.toString(findPowers(3)));   // 3 = 2^0 * 3^1\n    }\n\n    // Utility method to simulate the findPowers method\n    private Integer[] findPowers(int num) {\n        // Input validation\n        if (num <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer greater than zero.\");\n        }\n\n        int n = 0; // Initialize counter for powers of 2\n        int m = 0; // Initialize counter for powers of 3\n\n        // Count the power of 2 in the factorization\n        while (num % 2 == 0) {\n            n++;\n            num /= 2;\n        }\n\n        // Count the power of 3 in the factorization\n        while (num % 3 == 0) {\n            m++;\n            num /= 3;\n        }\n\n        // If num is reduced to 1, only 2's and 3's were factors\n        if (num == 1) {\n            return new Integer[]{n, m};\n        } else {\n            return null; // Return null if there are other prime factors\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds the powers of 2 and 3 that multiply to produce the given number.\n *\n * @param num A positive integer greater than zero.\n * @return An array (n, m) where n is the power of 2 and m is the power of 3.\n *         Returns null if the number is zero or if the number has prime factors other than 2 and 3.\n */\npublic static Integer[] findPowers(int num) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 511, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Convert a hexadecimal color code to an ANSI escape code", "language_version_list": {"python": {"code_signature": "def hex_to_ansi(hex_color: str) -> str:\n    \"\"\"\n    Convert a hexadecimal color code to an ANSI escape code.\n\n    Args:\n        hex_color (str): A string representing the hexadecimal color code, e.g., '#FF5733'.\n\n    Returns:\n        str: An ANSI escape code for the specified RGB color.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestHexToAnsi(unittest.TestCase):\n\n    def test_valid_colors(self):\n        \"\"\"Test valid hex color inputs.\"\"\"\n        self.assertEqual(hex_to_ansi(\"#FF5733\"), \"\\x1b[38;2;255;87;51m\")\n        self.assertEqual(hex_to_ansi(\"#00FF00\"), \"\\x1b[38;2;0;255;0m\")\n        self.assertEqual(hex_to_ansi(\"#0000FF\"), \"\\x1b[38;2;0;0;255m\")\n\n    def test_black_and_white(self):\n        \"\"\"Test edge cases with black and white colors.\"\"\"\n        self.assertEqual(hex_to_ansi(\"#000000\"), \"\\x1b[38;2;0;0;0m\")  # Black\n        self.assertEqual(hex_to_ansi(\"#FFFFFF\"), \"\\x1b[38;2;255;255;255m\")  # White\n", "prompt": "please write a python function , the function signature as below def hex_to_ansi(hex_color: str) -> str:\n    \"\"\"\n    Convert a hexadecimal color code to an ANSI escape code.\n\n    Args:\n        hex_color (str): A string representing the hexadecimal color code, e.g., '#FF5733'.\n\n    Returns:\n        str: An ANSI escape code for the specified RGB color.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Convert a hexadecimal color code to an ANSI escape code.\n *\n * @param {string} hexColor - A string representing the hexadecimal color code, e.g., '#FF5733'.\n * @returns {string} An ANSI escape code for the specified RGB color.\n */\nfunction hexToAnsi(hexColor) {\n\n}", "test_code": "describe('TestHexToAnsi', () => {\n    describe('testValidColors', () => {\n        it('should handle valid hex color inputs correctly', () => {\n            expect(hexToAnsi('#FF5733')).toBe('\\x1b[38;2;255;87;51m');\n            expect(hexToAnsi('#00FF00')).toBe('\\x1b[38;2;0;255;0m');\n            expect(hexToAnsi('#0000FF')).toBe('\\x1b[38;2;0;0;255m');\n        });\n    });\n\n    describe('testBlackAndWhite', () => {\n        it('should handle black and white colors correctly', () => {\n            expect(hexToAnsi('#000000')).toBe('\\x1b[38;2;0;0;0m'); // Black\n            expect(hexToAnsi('#FFFFFF')).toBe('\\x1b[38;2;255;255;255m'); // White\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Convert a hexadecimal color code to an ANSI escape code.\n *\n * @param {string} hexColor - A string representing the hexadecimal color code, e.g., '#FF5733'.\n * @returns {string} An ANSI escape code for the specified RGB color.\n */\nfunction hexToAnsi(hexColor) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Convert a hexadecimal color code to an ANSI escape code.\n *\n * @param hexColor - A string representing the hexadecimal color code, e.g., '#FF5733'.\n * @returns An ANSI escape code for the specified RGB color.\n */\nfunction hexToAnsi(hexColor: string): string {\n\n}", "test_code": "describe('TestHexToAnsi', () => {\n    describe('testValidColors', () => {\n        it('should correctly convert valid hex color inputs', () => {\n            expect(hexToAnsi('#FF5733')).toBe('\\x1b[38;2;255;87;51m');\n            expect(hexToAnsi('#00FF00')).toBe('\\x1b[38;2;0;255;0m');\n            expect(hexToAnsi('#0000FF')).toBe('\\x1b[38;2;0;0;255m');\n        });\n    });\n\n    describe('testBlackAndWhite', () => {\n        it('should correctly handle black and white colors', () => {\n            expect(hexToAnsi('#000000')).toBe('\\x1b[38;2;0;0;0m'); // Black\n            expect(hexToAnsi('#FFFFFF')).toBe('\\x1b[38;2;255;255;255m'); // White\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Convert a hexadecimal color code to an ANSI escape code.\n *\n * @param hexColor - A string representing the hexadecimal color code, e.g., '#FF5733'.\n * @returns An ANSI escape code for the specified RGB color.\n */\nfunction hexToAnsi(hexColor: string): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a hexadecimal color code to an ANSI escape code.\n *\n * @param hex_color A string representing the hexadecimal color code, e.g., \"#FF5733\".\n *\n * @return An ANSI escape code for the specified RGB color.\n */\nstd::string hex_to_ansi(const std::string& hex_color) {}", "test_code": "TEST_CASE(\"Test valid hex color inputs\", \"[hex_to_ansi]\") {\n    SECTION(\"Valid colors\") {\n        CHECK(hex_to_ansi(\"#FF5733\") == \"\\x1b[38;2;255;87;51m\");\n        CHECK(hex_to_ansi(\"#00FF00\") == \"\\x1b[38;2;0;255;0m\");\n        CHECK(hex_to_ansi(\"#0000FF\") == \"\\x1b[38;2;0;0;255m\");\n    }\n}\n\nTEST_CASE(\"Test edge cases with black and white colors\", \"[hex_to_ansi]\") {\n    SECTION(\"Black and white colors\") {\n        CHECK(hex_to_ansi(\"#000000\") == \"\\x1b[38;2;0;0;0m\");  // Black\n        CHECK(hex_to_ansi(\"#FFFFFF\") == \"\\x1b[38;2;255;255;255m\");  // White\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a hexadecimal color code to an ANSI escape code.\n *\n * @param hex_color A string representing the hexadecimal color code, e.g., \"#FF5733\".\n *\n * @return An ANSI escape code for the specified RGB color.\n */\nstd::string hex_to_ansi(const std::string& hex_color) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a hexadecimal color code to an ANSI escape code.\n *\n * @param hexColor A string representing the hexadecimal color code, e.g., \"#FF5733\".\n * @return An ANSI escape code for the specified RGB color.\n * @throws IllegalArgumentException if the hex color format is invalid.\n */\npublic static String hexToAnsi(String hexColor) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for verifying the correctness of the hexToAnsi method.\n */\npublic class Tester {\n\n    /**\n     * Tests valid hex color inputs.\n     */\n    @Test\n    public void testValidColors() {\n        assertEquals(\"\\u001b[38;2;255;87;51m\", hexToAnsi(\"#FF5733\"));\n        assertEquals(\"\\u001b[38;2;0;255;0m\", hexToAnsi(\"#00FF00\"));\n        assertEquals(\"\\u001b[38;2;0;0;255m\", hexToAnsi(\"#0000FF\"));\n    }\n\n    /**\n     * Tests edge cases with black and white colors.\n     */\n    @Test\n    public void testBlackAndWhite() {\n        assertEquals(\"\\u001b[38;2;0;0;0m\", hexToAnsi(\"#000000\"));  // Black\n        assertEquals(\"\\u001b[38;2;255;255;255m\", hexToAnsi(\"#FFFFFF\"));  // White\n    }\n\n    /**\n     * Converts a hexadecimal color code to an ANSI escape code.\n     *\n     * @param hexColor A string representing the hexadecimal color code, e.g., \"#FF5733\".\n     * @return An ANSI escape code for the specified RGB color.\n     * @throws IllegalArgumentException if the hex color format is invalid.\n     */\n    private String hexToAnsi(String hexColor) {\n        // Check if the input is a valid hex color\n        if (hexColor == null || hexColor.length() != 7 || !hexColor.startsWith(\"#\")) {\n            throw new IllegalArgumentException(\"Invalid hex color format. Use '#RRGGBB'.\");\n        }\n\n        // Extract the red, green, and blue components from the hex string\n        int r = Integer.parseInt(hexColor.substring(1, 3), 16);\n        int g = Integer.parseInt(hexColor.substring(3, 5), 16);\n        int b = Integer.parseInt(hexColor.substring(5, 7), 16);\n\n        // Create the ANSI escape code\n        String ansiCode = \"\\u001b[38;2;\" + r + \";\" + g + \";\" + b + \"m\";\n\n        return ansiCode;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a hexadecimal color code to an ANSI escape code.\n *\n * @param hexColor A string representing the hexadecimal color code, e.g., \"#FF5733\".\n * @return An ANSI escape code for the specified RGB color.\n * @throws IllegalArgumentException if the hex color format is invalid.\n */\npublic static String hexToAnsi(String hexColor) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 512, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Convert a list of hole positions to the ring format (list of 1s and 0s).", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef convert_to_ring_format(holes: List) -> List:\n    \"\"\"\n    Convert a list of hole positions to the ring format (list of 1s and 0s).\n\n    Args:\n        holes (list): A list of integers representing the positions of the holes (0-indexed).\n\n    Returns:\n        List: A list of length 32, where positions with holes are 0 and others are 1.\n\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestConvertToRingFormat(unittest.TestCase):\n\n    def test_no_holes(self):\n        \"\"\" Test with no holes provided. \"\"\"\n        holes = []\n        expected = [1] * 32  # All positions should be 1\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)\n\n    def test_single_hole(self):\n        \"\"\" Test with a single hole position. \"\"\"\n        holes = [5]\n        expected = [1] * 32\n        expected[5] = 0  # Only position 5 should be 0\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)\n\n    def test_multiple_holes(self):\n        \"\"\" Test with multiple hole positions. \"\"\"\n        holes = [0, 2, 4, 8, 16]\n        expected = [1] * 32\n        for hole in holes:\n            expected[hole] = 0  # Set specified positions to 0\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)\n\n    def test_hole_out_of_bounds(self):\n        \"\"\" Test with some hole positions out of bounds. \"\"\"\n        holes = [-1, 32, 5, 10]  # -1 and 32 are out of bounds\n        expected = [1] * 32\n        expected[5] = 0  # Only position 5 and 10 should be 0\n        expected[10] = 0\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)\n\n    def test_all_holes(self):\n        \"\"\" Test with all positions as holes. \"\"\"\n        holes = list(range(32))  # All positions from 0 to 31\n        expected = [0] * 32  # All positions should be 0\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef convert_to_ring_format(holes: List) -> List:\n    \"\"\"\n    Convert a list of hole positions to the ring format (list of 1s and 0s).\n\n    Args:\n        holes (list): A list of integers representing the positions of the holes (0-indexed).\n\n    Returns:\n        List: A list of length 32, where positions with holes are 0 and others are 1.\n\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Convert an array of hole positions to the ring format (array of 1s and 0s).\n *\n * @param {number[]} holes - An array of integers representing the positions of the holes (0-indexed).\n * @returns {number[]} An array of length 32, where positions with holes are 0 and others are 1.\n */\nfunction convertToRingFormat(holes) {\n\n}", "test_code": "describe('TestConvertToRingFormat', () => {\n    it('test_no_holes', () => {\n        const holes = [];\n        const expected = new Array(32).fill(1);  // All positions should be 1\n        const result = convertToRingFormat(holes);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_single_hole', () => {\n        const holes = [5];\n        const expected = new Array(32).fill(1);\n        expected[5] = 0;  // Only position 5 should be 0\n        const result = convertToRingFormat(holes);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_multiple_holes', () => {\n        const holes = [0, 2, 4, 8, 16];\n        const expected = new Array(32).fill(1);\n        holes.forEach(hole => {\n            expected[hole] = 0;  // Set specified positions to 0\n        });\n        const result = convertToRingFormat(holes);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_hole_out_of_bounds', () => {\n        const holes = [-1, 32, 5, 10];  // -1 and 32 are out of bounds\n        const expected = new Array(32).fill(1);\n        expected[5] = 0;  // Only position 5 and 10 should be 0\n        expected[10] = 0;\n        const result = convertToRingFormat(holes);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_all_holes', () => {\n        const holes = Array.from({length: 32}, (_, i) => i);  // All positions from 0 to 31\n        const expected = new Array(32).fill(0);  // All positions should be 0\n        const result = convertToRingFormat(holes);\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Convert an array of hole positions to the ring format (array of 1s and 0s).\n *\n * @param {number[]} holes - An array of integers representing the positions of the holes (0-indexed).\n * @returns {number[]} An array of length 32, where positions with holes are 0 and others are 1.\n */\nfunction convertToRingFormat(holes) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Convert an array of hole positions to the ring format (array of 1s and 0s).\n *\n * @param holes - An array of numbers representing the positions of the holes (0-indexed).\n * @returns An array of length 32, where positions with holes are 0 and others are 1.\n */\nfunction convertToRingFormat(holes: number[]): number[] {\n\n}", "test_code": "describe('TestConvertToRingFormat', () => {\n    it('test_no_holes', () => {\n        // Test with no holes provided.\n        const holes: number[] = [];\n        const expected: number[] = [1].fill(1, 0, 32);  // All positions should be 1\n        const result = convertToRingFormat(holes);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_single_hole', () => {\n        // Test with a single hole position.\n        const holes: number[] = [5];\n        const expected: number[] = [1].fill(1, 0, 32);\n        expected[5] = 0;  // Only position 5 should be 0\n        const result = convertToRingFormat(holes);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_multiple_holes', () => {\n        // Test with multiple hole positions.\n        const holes: number[] = [0, 2, 4, 8, 16];\n        const expected: number[] = [1].fill(1, 0, 32);\n        holes.forEach(hole => {\n            expected[hole] = 0;  // Set specified positions to 0\n        });\n        const result = convertToRingFormat(holes);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_hole_out_of_bounds', () => {\n        // Test with some hole positions out of bounds.\n        const holes: number[] = [-1, 32, 5, 10];  // -1 and 32 are out of bounds\n        const expected: number[] = [1].fill(1, 0, 32);\n        expected[5] = 0;  // Only position 5 and 10 should be 0\n        expected[10] = 0;\n        const result = convertToRingFormat(holes);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_all_holes', () => {\n        // Test with all positions as holes.\n        const holes: number[] = Array.from({ length: 32 }, (_, i) => i);  // All positions from 0 to 31\n        const expected: number[] = [0].fill(0, 0, 32);  // All positions should be 0\n        const result = convertToRingFormat(holes);\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Convert an array of hole positions to the ring format (array of 1s and 0s).\n *\n * @param holes - An array of numbers representing the positions of the holes (0-indexed).\n * @returns An array of length 32, where positions with holes are 0 and others are 1.\n */\nfunction convertToRingFormat(holes: number[]): number[] {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert a list of hole positions to the ring format (list of 1s and 0s).\n *\n * @param holes A list of integers representing the positions of the holes (0-indexed).\n * @return A list of length 32, where positions with holes are 0 and others are 1.\n */\nstd::vector<int> convert_to_ring_format(const std::vector<int>& holes) {}", "test_code": "TEST_CASE(\"Test convert_to_ring_format\", \"[convert_to_ring_format]\") {\n    SECTION(\"Test with no holes provided\") {\n        std::vector<int> holes = {};\n        std::vector<int> expected(32, 1);  // All positions should be 1\n        auto result = convert_to_ring_format(holes);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test with a single hole position\") {\n        std::vector<int> holes = {5};\n        std::vector<int> expected(32, 1);\n        expected[5] = 0;  // Only position 5 should be 0\n        auto result = convert_to_ring_format(holes);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test with multiple hole positions\") {\n        std::vector<int> holes = {0, 2, 4, 8, 16};\n        std::vector<int> expected(32, 1);\n        for (int hole : holes) {\n            expected[hole] = 0;  // Set specified positions to 0\n        }\n        auto result = convert_to_ring_format(holes);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test with some hole positions out of bounds\") {\n        std::vector<int> holes = {-1, 32, 5, 10};  // -1 and 32 are out of bounds\n        std::vector<int> expected(32, 1);\n        expected[5] = 0;  // Only position 5 and 10 should be 0\n        expected[10] = 0;\n        auto result = convert_to_ring_format(holes);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test with all positions as holes\") {\n        std::vector<int> holes;\n        for (int i = 0; i < 32; ++i) {\n            holes.push_back(i);\n        }\n        std::vector<int> expected(32, 0);  // All positions should be 0\n        auto result = convert_to_ring_format(holes);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert a list of hole positions to the ring format (list of 1s and 0s).\n *\n * @param holes A list of integers representing the positions of the holes (0-indexed).\n * @return A list of length 32, where positions with holes are 0 and others are 1.\n */\nstd::vector<int> convert_to_ring_format(const std::vector<int>& holes) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Convert a list of hole positions to the ring format (list of 1s and 0s).\n *\n * @param holes A list of integers representing the positions of the holes (0-indexed).\n * @return A list of length 32, where positions with holes are 0 and others are 1.\n */\npublic static List<Integer> convertToRingFormat(List<Integer> holes) {\n\n}", "test_code": "import org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    // Method to be tested\n    private static List<Integer> convertToRingFormat(List<Integer> holes) {\n        // Initialize the ring with all positions set to 1\n        List<Integer> ring = new ArrayList<>();\n        for (int i = 0; i < 32; i++) {\n            ring.add(1);\n        }\n\n        // Mark the positions of holes as 0\n        for (Integer hole : holes) {\n            if (0 <= hole && hole < 32) {  // Ensure hole positions are within valid range\n                ring.set(hole, 0);\n            }\n        }\n\n        return ring;\n    }\n\n    @Test\n    public void testNoHoles() {\n        \"\"\" Test with no holes provided. \"\"\"\n        List<Integer> holes = new ArrayList<>();\n        List<Integer> expected = new ArrayList<>(Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1));\n        List<Integer> result = convertToRingFormat(holes);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testSingleHole() {\n        \"\"\" Test with a single hole position. \"\"\"\n        List<Integer> holes = new ArrayList<>(Arrays.asList(5));\n        List<Integer> expected = new ArrayList<>(Arrays.asList(1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1));\n        List<Integer> result = convertToRingFormat(holes);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testMultipleHoles() {\n        \"\"\" Test with multiple hole positions. \"\"\"\n        List<Integer> holes = new ArrayList<>(Arrays.asList(0, 2, 4, 8, 16));\n        List<Integer> expected = new ArrayList<>(Arrays.asList(0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1));\n        List<Integer> result = convertToRingFormat(holes);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testHoleOutOfBounds() {\n        \"\"\" Test with some hole positions out of bounds. \"\"\"\n        List<Integer> holes = new ArrayList<>(Arrays.asList(-1, 32, 5, 10));\n        List<Integer> expected = new ArrayList<>(Arrays.asList(1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1));\n        List<Integer> result = convertToRingFormat(holes);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testAllHoles() {\n        \"\"\" Test with all positions as holes. \"\"\"\n        List<Integer> holes = new ArrayList<>();\n        for (int i = 0; i < 32; i++) {\n            holes.add(i);\n        }\n        List<Integer> expected = new ArrayList<>(Arrays.asList(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0));\n        List<Integer> result = convertToRingFormat(holes);\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Convert a list of hole positions to the ring format (list of 1s and 0s).\n *\n * @param holes A list of integers representing the positions of the holes (0-indexed).\n * @return A list of length 32, where positions with holes are 0 and others are 1.\n */\npublic static List<Integer> convertToRingFormat(List<Integer> holes) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 513, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Check whether the phrase exists in the string, ignoring the case of the phrase\n", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef is_phrase_in_string_ignore_case(phrase: str, string: str) -> bool:\n    \"\"\"\n    Check if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n\n    Args:\n        phrase (str): The phrase to search for in the string.\n        string (str): The target string in which to search for the phrase.\n\n    Returns:\n        bool: True if the phrase is found as a whole word in the string, False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestIsPhraseInStringIgnoreCase(unittest.TestCase):\n\n    def test_exact_match_case_insensitive(self):\n        self.assertTrue(is_phrase_in_string_ignore_case(\"hello world\", \"Hello World\"))\n\n\n    def test_partial_word_match_case_insensitive(self):\n        self.assertTrue(is_phrase_in_string_ignore_case(\"Hello\", \"saying Hello there\"))\n\n    def test_different_cases(self):\n        self.assertTrue(is_phrase_in_string_ignore_case(\"HELLO\", \"hello there!\"))\n        self.assertTrue(is_phrase_in_string_ignore_case(\"world\", \"WORLD is great\"))\n\n    def test_non_existent_phrase(self):\n        self.assertFalse(is_phrase_in_string_ignore_case(\"goodbye\", \"Hello world\"))\n        self.assertFalse(is_phrase_in_string_ignore_case(\"hello\", \"goodbye world\"))\n\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef is_phrase_in_string_ignore_case(phrase: str, string: str) -> bool:\n    \"\"\"\n    Check if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n\n    Args:\n        phrase (str): The phrase to search for in the string.\n        string (str): The target string in which to search for the phrase.\n\n    Returns:\n        bool: True if the phrase is found as a whole word in the string, False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Check if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n *\n * @param {string} phrase - The phrase to search for in the string.\n * @param {string} string - The target string in which to search for the phrase.\n * @returns {boolean} - True if the phrase is found as a whole word in the string, False otherwise.\n */\nfunction isPhraseInStringIgnoreCase(phrase, string) {\n\n}", "test_code": "describe('TestIsPhraseInStringIgnoreCase', () => {\n    describe('test_exact_match_case_insensitive', () => {\n        it('should find an exact match case-insensitively', () => {\n            expect(isPhraseInStringIgnoreCase(\"hello world\", \"Hello World\")).toBe(true);\n        });\n    });\n\n    describe('test_partial_word_match_case_insensitive', () => {\n        it('should find a partial word match case-insensitively', () => {\n            expect(isPhraseInStringIgnoreCase(\"Hello\", \"saying Hello there\")).toBe(true);\n        });\n    });\n\n    describe('test_different_cases', () => {\n        it('should find phrases with different cases', () => {\n            expect(isPhraseInStringIgnoreCase(\"HELLO\", \"hello there!\")).toBe(true);\n            expect(isPhraseInStringIgnoreCase(\"world\", \"WORLD is great\")).toBe(true);\n        });\n    });\n\n    describe('test_non_existent_phrase', () => {\n        it('should not find non-existent phrases', () => {\n            expect(isPhraseInStringIgnoreCase(\"goodbye\", \"Hello world\")).toBe(false);\n            expect(isPhraseInStringIgnoreCase(\"hello\", \"goodbye world\")).toBe(false);\n        });\n    });\n});\n", "prompt": "please write a javascript function , the function signature as below /**\n * Check if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n *\n * @param {string} phrase - The phrase to search for in the string.\n * @param {string} string - The target string in which to search for the phrase.\n * @returns {boolean} - True if the phrase is found as a whole word in the string, False otherwise.\n */\nfunction isPhraseInStringIgnoreCase(phrase, string) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Check if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n *\n * @param phrase - The phrase to search for in the string.\n * @param string - The target string in which to search for the phrase.\n * @returns True if the phrase is found as a whole word in the string, False otherwise.\n */\nfunction isPhraseInStringIgnoreCase(phrase: string, string: string): boolean {\n\n}", "test_code": "describe('isPhraseInStringIgnoreCase', () => {\n    it('should match exact phrases case-insensitively', () => {\n        expect(isPhraseInStringIgnoreCase(\"hello world\", \"Hello World\")).toBe(true);\n    });\n\n    it('should match partial words case-insensitively', () => {\n        expect(isPhraseInStringIgnoreCase(\"Hello\", \"saying Hello there\")).toBe(true);\n    });\n\n    it('should match different cases', () => {\n        expect(isPhraseInStringIgnoreCase(\"HELLO\", \"hello there!\")).toBe(true);\n        expect(isPhraseInStringIgnoreCase(\"world\", \"WORLD is great\")).toBe(true);\n    });\n\n    it('should not match non-existent phrases', () => {\n        expect(isPhraseInStringIgnoreCase(\"goodbye\", \"Hello world\")).toBe(false);\n        expect(isPhraseInStringIgnoreCase(\"hello\", \"goodbye world\")).toBe(false);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Check if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n *\n * @param phrase - The phrase to search for in the string.\n * @param string - The target string in which to search for the phrase.\n * @returns True if the phrase is found as a whole word in the string, False otherwise.\n */\nfunction isPhraseInStringIgnoreCase(phrase: string, string: string): boolean {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Check if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n *\n * @param phrase The phrase to search for in the string.\n * @param string The target string in which to search for the phrase.\n *\n * @return True if the phrase is found as a whole word in the string, False otherwise.\n */\nbool is_phrase_in_string_ignore_case(const std::string& phrase, const std::string& string) {\n\n}", "test_code": "TEST_CASE(\"Test is_phrase_in_string_ignore_case\", \"[is_phrase_in_string_ignore_case]\") {\n    SECTION(\"Exact match case insensitive\") {\n        REQUIRE(is_phrase_in_string_ignore_case(\"hello world\", \"Hello World\"));\n    }\n\n    SECTION(\"Partial word match case insensitive\") {\n        REQUIRE(is_phrase_in_string_ignore_case(\"Hello\", \"saying Hello there\"));\n    }\n\n    SECTION(\"Different cases\") {\n        REQUIRE(is_phrase_in_string_ignore_case(\"HELLO\", \"hello there!\"));\n        REQUIRE(is_phrase_in_string_ignore_case(\"world\", \"WORLD is great\"));\n    }\n\n    SECTION(\"Non-existent phrase\") {\n        REQUIRE_FALSE(is_phrase_in_string_ignore_case(\"goodbye\", \"Hello world\"));\n        REQUIRE_FALSE(is_phrase_in_string_ignore_case(\"hello\", \"goodbye world\"));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Check if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n *\n * @param phrase The phrase to search for in the string.\n * @param string The target string in which to search for the phrase.\n *\n * @return True if the phrase is found as a whole word in the string, False otherwise.\n */\nbool is_phrase_in_string_ignore_case(const std::string& phrase, const std::string& string) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n *\n * @param phrase The phrase to search for in the string.\n * @param string The target string in which to search for the phrase.\n * @return True if the phrase is found as a whole word in the string, False otherwise.\n */\npublic static boolean isPhraseInStringIgnoreCase(String phrase, String string) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Test class for verifying the functionality of the isPhraseInStringIgnoreCase method.\n */\npublic class Tester {\n\n    /**\n     * Tests that an exact match is found when ignoring case.\n     */\n    @Test\n    public void testExactMatchCaseInsensitive() {\n        assertTrue(isPhraseInStringIgnoreCase(\"hello world\", \"Hello World\"));\n    }\n\n    /**\n     * Tests that a partial word match is found when ignoring case.\n     */\n    @Test\n    public void testPartialWordMatchCaseInsensitive() {\n        assertTrue(isPhraseInStringIgnoreCase(\"Hello\", \"saying Hello there\"));\n    }\n\n    /**\n     * Tests different cases where the phrase is present but with varying capitalization.\n     */\n    @Test\n    public void testDifferentCases() {\n        assertTrue(isPhraseInStringIgnoreCase(\"HELLO\", \"hello there!\"));\n        assertTrue(isPhraseInStringIgnoreCase(\"world\", \"WORLD is great\"));\n    }\n\n    /**\n     * Tests cases where the phrase does not exist in the string.\n     */\n    @Test\n    public void testNonExistentPhrase() {\n        assertFalse(isPhraseInStringIgnoreCase(\"goodbye\", \"Hello world\"));\n        assertFalse(isPhraseInStringIgnoreCase(\"hello\", \"goodbye world\"));\n    }\n}\n\n// The isPhraseInStringIgnoreCase method remains the same as before\npublic class Answer {\n\n    /**\n     * Checks if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n     *\n     * @param phrase The phrase to search for in the string.\n     * @param string The target string in which to search for the phrase.\n     * @return True if the phrase is found as a whole word in the string, False otherwise.\n     */\n    public static boolean isPhraseInStringIgnoreCase(String phrase, String string) {\n        // Convert both phrase and string to lower case\n        phrase = phrase.toLowerCase();\n        string = string.toLowerCase();\n\n        // Escape special characters in the phrase\n        String escapedPhrase = Pattern.quote(phrase);\n\n        // Replace spaces in the phrase with \\s+ to allow for any whitespace variations\n        escapedPhrase = escapedPhrase.replace(\"\\\\ \", \"\\\\s+\");\n\n        // Construct the regex pattern with word boundaries\n        String pattern = \"\\\\b\" + escapedPhrase + \"\\\\b\";\n\n        // Compile the pattern and create a matcher for the target string\n        Pattern compiledPattern = Pattern.compile(pattern);\n        Matcher matcher = compiledPattern.matcher(string);\n\n        // Search for the pattern in the target string\n        return matcher.find();\n    }\n\n    // Example usage\n    public static void main(String[] args) {\n        System.out.println(isPhraseInStringIgnoreCase(\"hello world\", \"Hello   World\")); // true\n        System.out.println(isPhraseInStringIgnoreCase(\"hello\", \"Hello World\")); // false\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n *\n * @param phrase The phrase to search for in the string.\n * @param string The target string in which to search for the phrase.\n * @return True if the phrase is found as a whole word in the string, False otherwise.\n */\npublic static boolean isPhraseInStringIgnoreCase(String phrase, String string) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 514, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Extracts the date in the format YYYY-MM-DD from the given file name.", "language_version_list": {"python": {"code_signature": "import re\n\n\ndef extract_date_from_filename(file_name: str):\n    \"\"\"\n    Extracts the date in the format YYYY-MM-DD from the given file name.\n\n    Args:\n        file_name (str): The name of the file which may contain a date.\n\n    Returns:\n        str or None: The extracted date string in YYYY-MM-DD format if found, else None.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestExtractDateFromFilename(unittest.TestCase):\n\n    def test_date_extraction_success(self):\n        \"\"\"Test case where the date is successfully extracted.\"\"\"\n        file_name = \"report-2023-09-28.txt\"\n        expected_date = \"2023-09-28\"\n        self.assertEqual(extract_date_from_filename(file_name), expected_date)\n\n    def test_no_date_in_filename(self):\n        \"\"\"Test case where no date is present in the filename.\"\"\"\n        file_name = \"report.txt\"\n        self.assertIsNone(extract_date_from_filename(file_name))\n\n    def test_multiple_dates_in_filename(self):\n        \"\"\"Test case where multiple dates are present, should return the first one.\"\"\"\n        file_name = \"report-2023-09-28-backup-2023-10-01.txt\"\n        expected_date = \"2023-09-28\"\n        self.assertEqual(extract_date_from_filename(file_name), expected_date)\n\n    def test_date_at_start_of_filename(self):\n        \"\"\"Test case where the date is at the start of the filename.\"\"\"\n        file_name = \"2023-09-28-report.txt\"\n        expected_date = \"2023-09-28\"\n        self.assertEqual(extract_date_from_filename(file_name), expected_date)\n\n    def test_incorrect_date_format(self):\n        \"\"\"Test case where the date format is incorrect.\"\"\"\n        file_name = \"report-2023-99-99.txt\"  # Invalid date\n        expected_date = \"2023-99-99\"\n        self.assertEqual(extract_date_from_filename(file_name), expected_date)\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef extract_date_from_filename(file_name: str):\n    \"\"\"\n    Extracts the date in the format YYYY-MM-DD from the given file name.\n\n    Args:\n        file_name (str): The name of the file which may contain a date.\n\n    Returns:\n        str or None: The extracted date string in YYYY-MM-DD format if found, else None.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Extracts the date in the format YYYY-MM-DD from the given file name.\n *\n * @param {string} fileName - The name of the file which may contain a date.\n * @returns {string | null} - The extracted date string in YYYY-MM-DD format if found, else null.\n */\nfunction extractDateFromFileName(fileName) {\n\n}", "test_code": "describe('TestExtractDateFromFilename', () => {\n    it('test_date_extraction_success', () => {\n        // Test case where the date is successfully extracted.\n        const file_name = 'report-2023-09-28.txt';\n        const expected_date = '2023-09-28';\n        expect(extractDateFromFileName(file_name)).toBe(expected_date);\n    });\n\n    it('test_no_date_in_filename', () => {\n        // Test case where no date is present in the filename.\n        const file_name = 'report.txt';\n        expect(extractDateFromFileName(file_name)).toBeNull();\n    });\n\n    it('test_multiple_dates_in_filename', () => {\n        // Test case where multiple dates are present, should return the first one.\n        const file_name = 'report-2023-09-28-backup-2023-10-01.txt';\n        const expected_date = '2023-09-28';\n        expect(extractDateFromFileName(file_name)).toBe(expected_date);\n    });\n\n    it('test_date_at_start_of_filename', () => {\n        // Test case where the date is at the start of the filename.\n        const file_name = '2023-09-28-report.txt';\n        const expected_date = '2023-09-28';\n        expect(extractDateFromFileName(file_name)).toBe(expected_date);\n    });\n\n    it('test_incorrect_date_format', () => {\n        // Test case where the date format is incorrect.\n        const file_name = 'report-2023-99-99.txt';  // Invalid date\n        const expected_date = '2023-99-99';\n        expect(extractDateFromFileName(file_name)).toBe(expected_date);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Extracts the date in the format YYYY-MM-DD from the given file name.\n *\n * @param {string} fileName - The name of the file which may contain a date.\n * @returns {string | null} - The extracted date string in YYYY-MM-DD format if found, else null.\n */\nfunction extractDateFromFileName(fileName) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Extracts the date in the format YYYY-MM-DD from the given file name.\n *\n * @param fileName - The name of the file which may contain a date.\n * @returns The extracted date string in YYYY-MM-DD format if found, else null.\n */\nfunction extractDateFromFileName(fileName: string): string | null {\n\n}", "test_code": "describe('TestExtractDateFromFilename', () => {\n    describe('test_date_extraction_success', () => {\n        it('should extract the date successfully', () => {\n            const file_name = \"report-2023-09-28.txt\";\n            const expected_date = \"2023-09-28\";\n            expect(extractDateFromFileName(file_name)).toBe(expected_date);\n        });\n    });\n\n    describe('test_no_date_in_filename', () => {\n        it('should return null when no date is present in the filename', () => {\n            const file_name = \"report.txt\";\n            expect(extractDateFromFileName(file_name)).toBeNull();\n        });\n    });\n\n    describe('test_multiple_dates_in_filename', () => {\n        it('should return the first date when multiple dates are present', () => {\n            const file_name = \"report-2023-09-28-backup-2023-10-01.txt\";\n            const expected_date = \"2023-09-28\";\n            expect(extractDateFromFileName(file_name)).toBe(expected_date);\n        });\n    });\n\n    describe('test_date_at_start_of_filename', () => {\n        it('should extract the date when it is at the start of the filename', () => {\n            const file_name = \"2023-09-28-report.txt\";\n            const expected_date = \"2023-09-28\";\n            expect(extractDateFromFileName(file_name)).toBe(expected_date);\n        });\n    });\n\n    describe('test_incorrect_date_format', () => {\n        it('should handle incorrect date format', () => {\n            const file_name = \"report-2023-99-99.txt\"; // Invalid date\n            expect(extractDateFromFileName(file_name)).toBeNull();\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Extracts the date in the format YYYY-MM-DD from the given file name.\n *\n * @param fileName - The name of the file which may contain a date.\n * @returns The extracted date string in YYYY-MM-DD format if found, else null.\n */\nfunction extractDateFromFileName(fileName: string): string | null {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Extracts the date in the format YYYY-MM-DD from the given file name.\n *\n * @param file_name The name of the file which may contain a date.\n * @return A std::string containing the extracted date in YYYY-MM-DD format if found, else an empty string.\n */\nstd::string extract_date_from_filename(const std::string& file_name) {}", "test_code": "TEST_CASE(\"TestExtractDateFromFilename\", \"[extract_date_from_filename]\") {\n    SECTION(\"test_date_extraction_success\") {\n        // Test case where the date is successfully extracted.\n        const std::string file_name = \"report-2023-09-28.txt\";\n        const std::string expected_date = \"2023-09-28\";\n        REQUIRE(extract_date_from_filename(file_name) == expected_date);\n    }\n\n    SECTION(\"test_no_date_in_filename\") {\n        // Test case where no date is present in the filename.\n        const std::string file_name = \"report.txt\";\n        REQUIRE(extract_date_from_filename(file_name).empty());\n    }\n\n    SECTION(\"test_multiple_dates_in_filename\") {\n        // Test case where multiple dates are present, should return the first one.\n        const std::string file_name = \"report-2023-09-28-backup-2023-10-01.txt\";\n        const std::string expected_date = \"2023-09-28\";\n        REQUIRE(extract_date_from_filename(file_name) == expected_date);\n    }\n\n    SECTION(\"test_date_at_start_of_filename\") {\n        // Test case where the date is at the start of the filename.\n        const std::string file_name = \"2023-09-28-report.txt\";\n        const std::string expected_date = \"2023-09-28\";\n        REQUIRE(extract_date_from_filename(file_name) == expected_date);\n    }\n\n    SECTION(\"test_incorrect_date_format\") {\n        // Test case where the date format is incorrect.\n        const std::string file_name = \"report-2023-99-99.txt\";  // Invalid date\n        const std::string expected_date = \"\";  // Since the regex does not match, it should return an empty string\n        REQUIRE(extract_date_from_filename(file_name).empty());\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts the date in the format YYYY-MM-DD from the given file name.\n *\n * @param file_name The name of the file which may contain a date.\n * @return A std::string containing the extracted date in YYYY-MM-DD format if found, else an empty string.\n */\nstd::string extract_date_from_filename(const std::string& file_name) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Extracts the date in the format YYYY-MM-DD from the given file name.\n *\n * @param fileName The name of the file which may contain a date.\n * @return The extracted date string in YYYY-MM-DD format if found, else null.\n */\npublic static String extractDateFromFilename(String fileName) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Test cases for the extractDateFromFilename method.\n */\npublic class Tester {\n\n    /**\n     * Test case where the date is successfully extracted.\n     */\n    @Test\n    public void testDateExtractionSuccess() {\n        String fileName = \"report-2023-09-28.txt\";\n        String expectedDate = \"2023-09-28\";\n        assertEquals(expectedDate, extractDateFromFilename(fileName));\n    }\n\n    /**\n     * Test case where no date is present in the filename.\n     */\n    @Test\n    public void testNoDateInFilename() {\n        String fileName = \"report.txt\";\n        assertNull(extractDateFromFilename(fileName));\n    }\n\n    /**\n     * Test case where multiple dates are present, should return the first one.\n     */\n    @Test\n    public void testMultipleDatesInFilename() {\n        String fileName = \"report-2023-09-28-backup-2023-10-01.txt\";\n        String expectedDate = \"2023-09-28\";\n        assertEquals(expectedDate, extractDateFromFilename(fileName));\n    }\n\n    /**\n     * Test case where the date is at the start of the filename.\n     */\n    @Test\n    public void testDateAtStartOfFile() {\n        String fileName = \"2023-09-28-report.txt\";\n        String expectedDate = \"2023-09-28\";\n        assertEquals(expectedDate, extractDateFromFilename(fileName));\n    }\n\n    /**\n     * Test case where the date format is incorrect.\n     */\n    @Test\n    public void testIncorrectDateFormat() {\n        String fileName = \"report-2023-99-99.txt\";  // Invalid date\n        String expectedDate = \"2023-99-99\";\n        assertEquals(expectedDate, extractDateFromFilename(fileName));\n    }\n\n    // Utility method to extract the date from the filename\n    private String extractDateFromFilename(String fileName) {\n        // Define the regex pattern for matching a date in the format YYYY-MM-DD\n        Pattern datePattern = Pattern.compile(\"\\\\d{4}-\\\\d{2}-\\\\d{2}\");\n\n        // Search for the date pattern in the file name\n        Matcher matcher = datePattern.matcher(fileName);\n\n        // If a match is found, return the matched date; otherwise, return null\n        if (matcher.find()) {\n            return matcher.group(0);\n        } else {\n            return null;\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Extracts the date in the format YYYY-MM-DD from the given file name.\n *\n * @param fileName The name of the file which may contain a date.\n * @return The extracted date string in YYYY-MM-DD format if found, else null.\n */\npublic static String extractDateFromFilename(String fileName) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 515, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "    Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n    to the format '%Y-%m-%d_%H:%M:%S'.", "language_version_list": {"python": {"code_signature": "from datetime import datetime\n\ndef format_date_string(date_str:str):\n    \"\"\"\n    Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n    to the format '%Y-%m-%d_%H:%M:%S'.\n\n    Args:\n        date_str (str): The input date string.\n\n    Returns:\n        str: The formatted date string in the format '%Y-%m-%d_%H:%M:%S'.\n        None: If the input date string is invalid.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestFormatDateString(unittest.TestCase):\n\n    def test_valid_date_conversion(self):\n        \"\"\"Test case for a valid date string.\"\"\"\n        date_str = \"Fri, 28 Sep 2023 14:45:00 +0000 (UTC)\"\n        expected_date = \"2023-09-28_14:45:00\"\n        self.assertEqual(format_date_string(date_str), expected_date)\n\n    def test_invalid_date_format(self):\n        \"\"\"Test case for an invalid date string format.\"\"\"\n        date_str = \"Invalid date format\"\n        self.assertIsNone(format_date_string(date_str))\n\n    def test_missing_components(self):\n        \"\"\"Test case for a date string missing components.\"\"\"\n        date_str = \"Fri, 28 Sep 2023 14:45:00 +0000\"\n        self.assertIsNone(format_date_string(date_str))\n\n    def test_edge_case_date(self):\n        \"\"\"Test case for an edge case date string (e.g., leap year).\"\"\"\n        date_str = \"Sun, 29 Feb 2024 14:45:00 +0000 (UTC)\"\n        expected_date = \"2024-02-29_14:45:00\"\n        self.assertEqual(format_date_string(date_str), expected_date)", "prompt": "please write a python function , the function signature as below from datetime import datetime\n\ndef format_date_string(date_str:str):\n    \"\"\"\n    Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n    to the format '%Y-%m-%d_%H:%M:%S'.\n\n    Args:\n        date_str (str): The input date string.\n\n    Returns:\n        str: The formatted date string in the format '%Y-%m-%d_%H:%M:%S'.\n        None: If the input date string is invalid.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a date string from the format 'ddd, dd mmm yyyy HH:MM:ss ZZ (zzz)'\n * to the format 'yyyy-mm-dd_HH:MM:ss'.\n *\n * @param {string} dateStr - The input date string.\n * @returns {string | null} - The formatted date string in the format 'yyyy-mm-dd_HH:MM:SS', or null if the input date string is invalid.\n */\nfunction formatDateString(dateStr) {\n\n}", "test_code": "describe('TestFormatDateString', () => {\n    it('test_valid_date_conversion', () => {\n        // Test case for a valid date string.\n        const dateStr = \"Fri, 28 Sep 2023 14:45:00 +0000 (UTC)\";\n        const expectedDate = \"2023-09-28_14:45:00\";\n        expect(formatDateString(dateStr)).toEqual(expectedDate);\n    });\n\n    it('test_invalid_date_format', () => {\n        // Test case for an invalid date string format.\n        const dateStr = \"Invalid date format\";\n        expect(formatDateString(dateStr)).toBeNull();\n    });\n\n    it('test_missing_components', () => {\n        // Test case for a date string missing components.\n        const dateStr = \"Fri, 28 Sep 2023 14:45:00 +0000\";\n        expect(formatDateString(dateStr)).toBeNull();\n    });\n\n    it('test_edge_case_date', () => {\n        // Test case for an edge case date string (e.g., leap year).\n        const dateStr = \"Sun, 29 Feb 2024 14:45:00 +0000 (UTC)\";\n        const expectedDate = \"2024-02-29_14:45:00\";\n        expect(formatDateString(dateStr)).toEqual(expectedDate);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a date string from the format 'ddd, dd mmm yyyy HH:MM:ss ZZ (zzz)'\n * to the format 'yyyy-mm-dd_HH:MM:ss'.\n *\n * @param {string} dateStr - The input date string.\n * @returns {string | null} - The formatted date string in the format 'yyyy-mm-dd_HH:MM:SS', or null if the input date string is invalid.\n */\nfunction formatDateString(dateStr) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n * to the format '%Y-%m-%d_%H:%M:%S'.\n *\n * @param dateStr - The input date string.\n * @returns The formatted date string in the format '%Y-%m-%d_%H:%M:%S', or null if the input date string is invalid.\n */\nfunction formatDateString(dateStr: string): string | null {\n\n}", "test_code": "describe('formatDateString', () => {\n    it('should correctly convert a valid date string', () => {\n        const dateStr = \"Fri, 28 Sep 2023 14:45:00 +0000 (UTC)\";\n        const expectedDate = \"2023-09-28_14:45:00\";\n        expect(formatDateString(dateStr)).toBe(expectedDate);\n    });\n\n    it('should return null for an invalid date string format', () => {\n        const dateStr = \"Invalid date format\";\n        expect(formatDateString(dateStr)).toBeNull();\n    });\n\n    it('should return null for a date string missing components', () => {\n        const dateStr = \"Fri, 28 Sep 2023 14:45:00 +0000\";\n        expect(formatDateString(dateStr)).toBeNull();\n    });\n\n    it('should correctly convert an edge case date string (e.g., leap year)', () => {\n        const dateStr = \"Sun, 29 Feb 2024 14:45:00 +0000 (UTC)\";\n        const expectedDate = \"2024-02-29_14:45:00\";\n        expect(formatDateString(dateStr)).toBe(expectedDate);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n * to the format '%Y-%m-%d_%H:%M:%S'.\n *\n * @param dateStr - The input date string.\n * @returns The formatted date string in the format '%Y-%m-%d_%H:%M:%S', or null if the input date string is invalid.\n */\nfunction formatDateString(dateStr: string): string | null {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Converts a date string from one format to another.\n *\n * @param date_str The input date string to convert.\n *\n * @return The formatted date string in the format '%Y-%m-%d_%H:%M:%S'.\n *         Returns an empty string if the input date string is invalid.\n */\nstd::string format_date_string(const std::string& date_str) {\n\n}", "test_code": "TEST_CASE(\"TestFormatDateString\", \"[format_date_string]\") {\n    SECTION(\"test_valid_date_conversion\") {\n        const std::string date_str = \"Fri, 28 Sep 2023 14:45:00 +0000 (UTC)\";\n        const std::string expected_date = \"2023-09-28_14:45:00\";\n        REQUIRE(format_date_string(date_str) == expected_date);\n    }\n\n    SECTION(\"test_invalid_date_format\") {\n        const std::string date_str = \"Invalid date format\";\n        REQUIRE(format_date_string(date_str).empty());\n    }\n\n    SECTION(\"test_missing_components\") {\n        const std::string date_str = \"Fri, 28 Sep 2023 14:45:00 +0000\";\n        REQUIRE(format_date_string(date_str).empty());\n    }\n\n    SECTION(\"test_edge_case_date\") {\n        const std::string date_str = \"Sun, 29 Feb 2024 14:45:00 +0000 (UTC)\";\n        const std::string expected_date = \"2024-02-29_14:45:00\";\n        REQUIRE(format_date_string(date_str) == expected_date);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a date string from one format to another.\n *\n * @param date_str The input date string to convert.\n *\n * @return The formatted date string in the format '%Y-%m-%d_%H:%M:%S'.\n *         Returns an empty string if the input date string is invalid.\n */\nstd::string format_date_string(const std::string& date_str) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n * to the format '%Y-%m-%d_%H:%M:%S'.\n *\n * @param dateStr The input date string.\n * @return The formatted date string in the format '%Y-%m-%d_%H:%M:%S', or null if the input date string is invalid.\n */\npublic static String formatDateString(String dateStr) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * Test cases for the formatDateString method.\n */\npublic class Tester {\n\n    /**\n     * Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n     * to the format '%Y-%m-%d_%H:%M:%S'.\n     *\n     * @param dateStr The input date string.\n     * @return The formatted date string in the format '%Y-%m-%d_%H:%M:%S', or null if the input date string is invalid.\n     */\n    public static String formatDateString(String dateStr) {\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz (Z)\");\n        SimpleDateFormat outputFormat = new SimpleDateFormat(\"yyyy-MM-dd_HH:mm:ss\");\n\n        try {\n            // Parse the input date string to a Date object\n            Date dateObject = inputFormat.parse(dateStr);\n\n            // Format the Date object to the desired output format\n            String formattedDate = outputFormat.format(dateObject);\n\n            return formattedDate;\n        } catch (ParseException e) {\n            System.out.println(\"Error parsing date: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    @Test\n    public void testValidDateConversion() {\n        String dateStr = \"Fri, 28 Sep 2023 14:45:00 +0000 (UTC)\";\n        String expectedDate = \"2023-09-28_14:45:00\";\n        assertEquals(expectedDate, formatDateString(dateStr));\n    }\n\n    @Test\n    public void testInvalidDateFormat() {\n        String dateStr = \"Invalid date format\";\n        assertNull(formatDateString(dateStr));\n    }\n\n    @Test\n    public void testMissingComponents() {\n        String dateStr = \"Fri, 28 Sep 2023 14:45:00 +0000\";\n        assertNull(formatDateString(dateStr));\n    }\n\n    @Test\n    public void testEdgeCaseDate() {\n        String dateStr = \"Sun, 29 Feb 2024 14:45:00 +0000 (UTC)\";\n        String expectedDate = \"2024-02-29_14:45:00\";\n        assertEquals(expectedDate, formatDateString(dateStr));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n * to the format '%Y-%m-%d_%H:%M:%S'.\n *\n * @param dateStr The input date string.\n * @return The formatted date string in the format '%Y-%m-%d_%H:%M:%S', or null if the input date string is invalid.\n */\npublic static String formatDateString(String dateStr) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 516, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Reads a YAML file and returns its content as a Python dictionary or list.", "language_version_list": {"python": {"code_signature": "import os\n\n\ndef read_yaml(file_path: str):\n    \"\"\"\n    Reads a YAML file and returns its content as a Python dictionary or list.\n\n    Args:\n        file_path (str): The path to the YAML file.\n\n    Returns:\n        dict or list: Parsed YAML content as a Python data structure.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        yaml.YAMLError: If there is an error parsing the YAML file.\n    \"\"\"", "test_code": "import os\nimport unittest\n\nimport yaml\n\n\nclass TestReadYaml(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create a temporary YAML file for testing.\"\"\"\n        self.valid_yaml_file = 'test_valid.yaml'\n        self.invalid_yaml_file = 'test_invalid.yaml'\n        self.non_existent_file = 'non_existent.yaml'\n\n        # Valid YAML content\n        with open(self.valid_yaml_file, 'w') as file:\n            file.write(\"name: Example\\nversion: 1.0\\ndependencies:\\n  - package1\\n  - package2\\n\")\n\n        # Invalid YAML content\n        with open(self.invalid_yaml_file, 'w') as file:\n            file.write(\"name: Example\\nversion: 1.0\\ndependencies:\\n  - package1\\n  - package2\\ninvalid_yaml: \\n - \")\n\n    def tearDown(self):\n        \"\"\"Remove the temporary YAML files after testing.\"\"\"\n        if os.path.isfile(self.valid_yaml_file):\n            os.remove(self.valid_yaml_file)\n        if os.path.isfile(self.invalid_yaml_file):\n            os.remove(self.invalid_yaml_file)\n\n    def test_read_valid_yaml(self):\n        \"\"\"Test reading a valid YAML file.\"\"\"\n        expected_data = {\n            'name': 'Example',\n            'version': 1.0,\n            'dependencies': ['package1', 'package2']\n        }\n        result = read_yaml(self.valid_yaml_file)\n        self.assertEqual(result, expected_data)\n\n    def test_file_not_found(self):\n        \"\"\"Test for FileNotFoundError when the file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            read_yaml(self.non_existent_file)\n\n\n    def test_empty_yaml_file(self):\n        \"\"\"Test reading an empty YAML file.\"\"\"\n        empty_yaml_file = 'test_empty.yaml'\n        with open(empty_yaml_file, 'w') as file:\n            file.write(\"\")  # Create an empty YAML file\n\n        result = read_yaml(empty_yaml_file)\n        self.assertIsNone(result)  # Expecting None for empty file\n\n        os.remove(empty_yaml_file)  # Cleanup after the test", "prompt": "please write a python function , the function signature as below import os\n\n\ndef read_yaml(file_path: str):\n    \"\"\"\n    Reads a YAML file and returns its content as a Python dictionary or list.\n\n    Args:\n        file_path (str): The path to the YAML file.\n\n    Returns:\n        dict or list: Parsed YAML content as a Python data structure.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        yaml.YAMLError: If there is an error parsing the YAML file.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Reads a YAML file and returns its content as a JavaScript object or array.\n *\n * @param {string} filePath - The path to the YAML file.\n * @returns {Object|Array} - Parsed YAML content as a JavaScript data structure.\n * @throws {Error} - If the specified file does not exist or there is an error parsing the YAML file.\n */\nfunction readYaml(filePath) {\n\n}", "test_code": "describe('TestReadYaml', () => {\n    let validYamlFile = 'test_valid.yaml';\n    let invalidYamlFile = 'test_invalid.yaml';\n    let nonExistentFile = 'non_existent.yaml';\n\n    beforeAll(() => {\n        // Valid YAML content\n        fs.writeFileSync(validYamlFile, `\n            name: Example\n            version: 1.0\n            dependencies:\n              - package1\n              - package2\n        `);\n\n        // Invalid YAML content\n        fs.writeFileSync(invalidYamlFile, `\n            name: Example\n            version: 1.0\n            dependencies:\n              - package1\n              - package2\n            invalid_yaml:\n             -\n        `);\n    });\n\n    afterAll(() => {\n        if (fs.existsSync(validYamlFile)) {\n            fs.unlinkSync(validYamlFile);\n        }\n        if (fs.existsSync(invalidYamlFile)) {\n            fs.unlinkSync(invalidYamlFile);\n        }\n    });\n\n    describe('test_read_valid_yaml', () => {\n        it('should correctly parse a valid YAML file', () => {\n            const expectedData = {\n                name: 'Example',\n                version: 1.0,\n                dependencies: ['package1', 'package2']\n            };\n            const result = readYaml(validYamlFile);\n            expect(result).toEqual(expectedData);\n        });\n    });\n\n    describe('test_file_not_found', () => {\n        it('should throw an error when the file does not exist', () => {\n            expect(() => readYaml(nonExistentFile)).toThrow(/The file 'non_existent\\.yaml' does not exist/);\n        });\n    });\n\n    describe('test_empty_yaml_file', () => {\n        let emptyYamlFile = 'test_empty.yaml';\n\n        beforeAll(() => {\n            fs.writeFileSync(emptyYamlFile, '');\n        });\n\n        afterAll(() => {\n            if (fs.existsSync(emptyYamlFile)) {\n                fs.unlinkSync(emptyYamlFile);\n            }\n        });\n\n        it('should return null for an empty YAML file', () => {\n            const result = readYaml(emptyYamlFile);\n            expect(result).toBeNull();\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Reads a YAML file and returns its content as a JavaScript object or array.\n *\n * @param {string} filePath - The path to the YAML file.\n * @returns {Object|Array} - Parsed YAML content as a JavaScript data structure.\n * @throws {Error} - If the specified file does not exist or there is an error parsing the YAML file.\n */\nfunction readYaml(filePath) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Reads a YAML file and returns its content as a JavaScript object.\n *\n * @param filePath - The path to the YAML file.\n * @returns Parsed YAML content as a JavaScript data structure.\n * @throws {Error} If the specified file does not exist or there is an error parsing the YAML file.\n */\nfunction readYaml(filePath: string): object {\n\n}", "test_code": "describe('TestReadYaml', () => {\n    let validYamlFile: string;\n    let invalidYamlFile: string;\n    let nonExistentFile: string;\n\n    beforeAll(() => {\n        // Create a temporary YAML file for testing\n        validYamlFile = 'test_valid.yaml';\n        invalidYamlFile = 'test_invalid.yaml';\n        nonExistentFile = 'non_existent.yaml';\n\n        // Valid YAML content\n        fs.writeFileSync(validYamlFile, `\n            name: Example\n            version: 1.0\n            dependencies:\n              - package1\n              - package2\n        `);\n\n        // Invalid YAML content\n        fs.writeFileSync(invalidYamlFile, `\n            name: Example\n            version: 1.0\n            dependencies:\n              - package1\n              - package2\n            invalid_yaml:\n              -\n        `);\n    });\n\n    afterAll(() => {\n        // Remove the temporary YAML files after testing\n        if (fs.existsSync(validYamlFile)) {\n            fs.unlinkSync(validYamlFile);\n        }\n        if (fs.existsSync(invalidYamlFile)) {\n            fs.unlinkSync(invalidYamlFile);\n        }\n    });\n\n    it('should read a valid YAML file correctly', () => {\n        const expectedData = {\n            name: 'Example',\n            version: 1.0,\n            dependencies: ['package1', 'package2']\n        };\n\n        const result = readYaml(validYamlFile);\n        expect(result).toEqual(expectedData);\n    });\n\n    it('should throw an error when the file does not exist', () => {\n        expect(() => readYaml(nonExistentFile)).toThrow(/The file 'non_existent\\.yaml' does not exist/);\n    });\n\n    it('should handle an empty YAML file', () => {\n        const emptyYamlFile = 'test_empty.yaml';\n        fs.writeFileSync(emptyYamlFile, ''); // Create an empty YAML file\n\n        const result = readYaml(emptyYamlFile);\n        expect(result).toBeNull(); // Expecting null for empty file\n\n        fs.unlinkSync(emptyYamlFile); // Cleanup after the test\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Reads a YAML file and returns its content as a JavaScript object.\n *\n * @param filePath - The path to the YAML file.\n * @returns Parsed YAML content as a JavaScript data structure.\n * @throws {Error} If the specified file does not exist or there is an error parsing the YAML file.\n */\nfunction readYaml(filePath: string): object {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads a YAML file and returns its content as a YAML node.\n *\n * @param file_path The path to the YAML file.\n * @return Parsed YAML content as a YAML node.\n * @throws std::runtime_error If the specified file does not exist or there is an error parsing the YAML file.\n */\nYAML::Node read_yaml(const std::string& file_path) {}", "test_code": "namespace fs = std::filesystem;\n\nTEST_CASE(\"TestReadYaml\", \"[YAML]\") {\n    const std::string valid_yaml_file = \"test_valid.yaml\";\n    const std::string invalid_yaml_file = \"test_invalid.yaml\";\n    const std::string non_existent_file = \"non_existent.yaml\";\n    const std::string empty_yaml_file = \"test_empty.yaml\";\n\n    SECTION(\"setUp\") {\n        // Valid YAML content\n        std::ofstream valid_file(valid_yaml_file);\n        valid_file << \"name: Example\\nversion: 1.0\\ndependencies:\\n  - package1\\n  - package2\\n\";\n        valid_file.close();\n\n        // Invalid YAML content\n        std::ofstream invalid_file(invalid_yaml_file);\n        invalid_file << \"name: Example\\nversion: 1.0\\ndependencies:\\n  - package1\\n  - package2\\ninvalid_yaml: \\n - \";\n        invalid_file.close();\n    }\n\n    SECTION(\"tearDown\") {\n        if (fs::exists(valid_yaml_file)) {\n            fs::remove(valid_yaml_file);\n        }\n        if (fs::exists(invalid_yaml_file)) {\n            fs::remove(invalid_yaml_file);\n        }\n        if (fs::exists(empty_yaml_file)) {\n            fs::remove(empty_yaml_file);\n        }\n    }\n\n    SECTION(\"test_read_valid_yaml\") {\n        // Test reading a valid YAML file\n        YAML::Node expected_data = YAML::Load(\n            \"name: Example\\n\"\n            \"version: 1.0\\n\"\n            \"dependencies:\\n\"\n            \"  - package1\\n\"\n            \"  - package2\\n\"\n        );\n\n        YAML::Node result = read_yaml(valid_yaml_file);\n        REQUIRE(result == expected_data);\n    }\n\n    SECTION(\"test_file_not_found\") {\n        // Test for FileNotFoundError when the file does not exist\n        REQUIRE_THROWS_AS(read_yaml(non_existent_file), std::runtime_error);\n    }\n\n    SECTION(\"test_empty_yaml_file\") {\n        // Test reading an empty YAML file\n        std::ofstream empty_file(empty_yaml_file);\n        empty_file << \"\";  // Create an empty YAML file\n        empty_file.close();\n\n        YAML::Node result = read_yaml(empty_yaml_file);\n        REQUIRE(result.IsNull());  // Expecting an empty node for an empty file\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads a YAML file and returns its content as a YAML node.\n *\n * @param file_path The path to the YAML file.\n * @return Parsed YAML content as a YAML node.\n * @throws std::runtime_error If the specified file does not exist or there is an error parsing the YAML file.\n */\nYAML::Node read_yaml(const std::string& file_path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads a YAML file and returns its content as a Java data structure (Map or List).\n *\n * @param filePath The path to the YAML file.\n * @return The parsed YAML content as a Java data structure.\n * @throws FileNotFoundException If the specified file does not exist.\n * @throws ReaderException If there is an error parsing the YAML file.\n */\npublic Object readYaml(String filePath) throws FileNotFoundException, ReaderException {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.yaml.snakeyaml.Yaml;\nimport org.yaml.snakeyaml.constructor.Constructor;\nimport org.yaml.snakeyaml.reader.ReaderException;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\n/**\n * Test class for reading YAML files.\n */\npublic class Tester {\n\n    private String validYamlFile = \"test_valid.yaml\";\n    private String invalidYamlFile = \"test_invalid.yaml\";\n    private String nonExistentFile = \"non_existent.yaml\";\n    private String emptyYamlFile = \"test_empty.yaml\";\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        // Valid YAML content\n        try (FileWriter writer = new FileWriter(validYamlFile)) {\n            writer.write(\"name: Example\\nversion: 1.0\\ndependencies:\\n  - package1\\n  - package2\\n\");\n        }\n\n        // Invalid YAML content\n        try (FileWriter writer = new FileWriter(invalidYamlFile)) {\n            writer.write(\"name: Example\\nversion: 1.0\\ndependencies:\\n  - package1\\n  - package2\\ninvalid_yaml: \\n - \");\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        // Remove the temporary YAML files after testing\n        new File(validYamlFile).delete();\n        new File(invalidYamlFile).delete();\n        new File(emptyYamlFile).delete();\n    }\n\n    @Test\n    public void testReadValidYaml() throws IOException {\n        // Test reading a valid YAML file\n        Map<String, Object> expectedData = Map.of(\n            \"name\", \"Example\",\n            \"version\", 1.0,\n            \"dependencies\", new String[]{\"package1\", \"package2\"}\n        );\n\n        Object result = readYaml(validYamlFile);\n        assertEquals(expectedData, result);\n    }\n\n    @Test\n    public void testFileNotFound() {\n        // Test for FileNotFoundError when the file does not exist\n        assertThrows(FileNotFoundException.class, () -> readYaml(nonExistentFile));\n    }\n\n    @Test\n    public void testEmptyYamlFile() throws IOException {\n        // Test reading an empty YAML file\n        try (FileWriter writer = new FileWriter(emptyYamlFile)) {\n            writer.write(\"\");  // Create an empty YAML file\n        }\n\n        Object result = readYaml(emptyYamlFile);\n        assertEquals(null, result);  // Expecting null for empty file\n    }\n\n    /**\n     * Reads a YAML file and returns its content as a Java data structure.\n     *\n     * @param filePath The path to the YAML file.\n     * @return The parsed YAML content as a Java data structure.\n     * @throws FileNotFoundException If the specified file does not exist.\n     * @throws ReaderException If there is an error parsing the YAML file.\n     */\n    private Object readYaml(String filePath) throws FileNotFoundException, ReaderException {\n        File file = new File(filePath);\n        if (!file.isFile()) {\n            throw new FileNotFoundException(\"The file '\" + filePath + \"' does not exist.\");\n        }\n\n        try (FileInputStream inputStream = new FileInputStream(file)) {\n            Yaml yaml = new Yaml(new Constructor(Object.class));\n            return yaml.load(inputStream);\n        } catch (ReaderException e) {\n            throw new ReaderException(\"Error parsing YAML file: \" + e.getMessage());\n        }\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Reads a YAML file and returns its content as a Java data structure (Map or List).\n *\n * @param filePath The path to the YAML file.\n * @return The parsed YAML content as a Java data structure.\n * @throws FileNotFoundException If the specified file does not exist.\n * @throws ReaderException If there is an error parsing the YAML file.\n */\npublic Object readYaml(String filePath) throws FileNotFoundException, ReaderException {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 517, "code_type": "method", "original_language": "python", "question_type": "File operations and I/O operation", "summary": "Reads a JSON Lines file and returns its content as a list of dictionaries.", "language_version_list": {"python": {"code_signature": "import json\nimport os\nfrom typing import List, Dict, Any\n\ndef read_jsonl(file_path: str) -> List[Dict[str, Any]]:\n    \"\"\"\n    Reads a JSON Lines file and returns its content as a list of dictionaries.\n\n    Args:\n        file_path (str): The path to the JSON Lines file.\n\n    Returns:\n        List[Dict[str, Any]]: A list of JSON objects parsed from the file.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        json.JSONDecodeError: If there is an error parsing a line in the JSON Lines file.\n    \"\"\"", "test_code": "import json\nimport os\nimport unittest\n\n\nclass TestReadJsonl(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create temporary JSON Lines files for testing.\"\"\"\n        self.valid_jsonl_file = 'test_valid.jsonl'\n        self.invalid_jsonl_file = 'test_invalid.jsonl'\n        self.non_existent_file = 'non_existent.jsonl'\n\n        # Valid JSON Lines content\n        with open(self.valid_jsonl_file, 'w') as file:\n            file.write('{\"name\": \"Alice\", \"age\": 30}\\n')\n            file.write('{\"name\": \"Bob\", \"age\": 25}\\n')\n            file.write('{\"name\": \"Charlie\", \"age\": 35}\\n')\n\n        # Invalid JSON Lines content\n        with open(self.invalid_jsonl_file, 'w') as file:\n            file.write('{\"name\": \"Alice\", \"age\": 30}\\n')\n            file.write('{\"name\": \"Bob\", \"age\": \"twenty-five}\\n')  # Missing closing quote\n\n    def tearDown(self):\n        \"\"\"Remove the temporary JSON Lines files after testing.\"\"\"\n        if os.path.isfile(self.valid_jsonl_file):\n            os.remove(self.valid_jsonl_file)\n        if os.path.isfile(self.invalid_jsonl_file):\n            os.remove(self.invalid_jsonl_file)\n\n    def test_read_valid_jsonl(self):\n        \"\"\"Test reading a valid JSON Lines file.\"\"\"\n        expected_data = [\n            {\"name\": \"Alice\", \"age\": 30},\n            {\"name\": \"Bob\", \"age\": 25},\n            {\"name\": \"Charlie\", \"age\": 35}\n        ]\n        result = read_jsonl(self.valid_jsonl_file)\n        self.assertEqual(result, expected_data)\n\n    def test_file_not_found(self):\n        \"\"\"Test for FileNotFoundError when the file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            read_jsonl(self.non_existent_file)\n\n    def test_empty_jsonl_file(self):\n        \"\"\"Test reading an empty JSON Lines file.\"\"\"\n        empty_jsonl_file = 'test_empty.jsonl'\n        with open(empty_jsonl_file, 'w') as file:\n            file.write(\"\")  # Create an empty JSON Lines file\n\n        result = read_jsonl(empty_jsonl_file)\n        self.assertEqual(result, [])  # Expecting an empty list for empty file\n\n        os.remove(empty_jsonl_file)  # Cleanup after the test", "prompt": "please write a python function , the function signature as below import json\nimport os\nfrom typing import List, Dict, Any\n\ndef read_jsonl(file_path: str) -> List[Dict[str, Any]]:\n    \"\"\"\n    Reads a JSON Lines file and returns its content as a list of dictionaries.\n\n    Args:\n        file_path (str): The path to the JSON Lines file.\n\n    Returns:\n        List[Dict[str, Any]]: A list of JSON objects parsed from the file.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        json.JSONDecodeError: If there is an error parsing a line in the JSON Lines file.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Reads a JSON Lines file and returns its content as an array of objects.\n *\n * @param {string} filePath - The path to the JSON Lines file.\n * @returns {Promise<Array<Object>>} A promise that resolves to an array of JSON objects parsed from the file.\n * @throws {Error} If the specified file does not exist.\n * @throws {SyntaxError} If there is an error parsing a line in the JSON Lines file.\n */\nasync function readJsonl(filePath) {\n\n}", "test_code": "describe('TestReadJsonl', () => {\n  let validJsonlFile = 'test_valid.jsonl';\n  let invalidJsonlFile = 'test_invalid.jsonl';\n  let nonExistentFile = 'non_existent.jsonl';\n\n  beforeAll(() => {\n    // Valid JSON Lines content\n    fs.writeFileSync(validJsonlFile, '{\"name\": \"Alice\", \"age\": 30}\\n' +\n      '{\"name\": \"Bob\", \"age\": 25}\\n' +\n      '{\"name\": \"Charlie\", \"age\": 35}\\n');\n\n    // Invalid JSON Lines content\n    fs.writeFileSync(invalidJsonlFile, '{\"name\": \"Alice\", \"age\": 30}\\n' +\n      '{\"name\": \"Bob\", \"age\": \"twenty-five}\\n');  // Missing closing quote\n  });\n\n  afterAll(() => {\n    if (fs.existsSync(validJsonlFile)) {\n      fs.unlinkSync(validJsonlFile);\n    }\n    if (fs.existsSync(invalidJsonlFile)) {\n      fs.unlinkSync(invalidJsonlFile);\n    }\n  });\n\n  it('reads a valid JSON Lines file', async () => {\n    const expectedData = [\n      {\"name\": \"Alice\", \"age\": 30},\n      {\"name\": \"Bob\", \"age\": 25},\n      {\"name\": \"Charlie\", \"age\": 35}\n    ];\n    const result = await readJsonl(validJsonlFile);\n    expect(result).toEqual(expectedData);\n  });\n\n  it('throws an error when the file does not exist', async () => {\n    await expect(readJsonl(nonExistentFile)).rejects.toThrow('The file \\'non_existent.jsonl\\' does not exist.');\n  });\n\n  it('reads an empty JSON Lines file', async () => {\n    const emptyJsonlFile = 'test_empty.jsonl';\n    fs.writeFileSync(emptyJsonlFile, '');  // Create an empty JSON Lines file\n\n    const result = await readJsonl(emptyJsonlFile);\n    expect(result).toEqual([]);  // Expecting an empty list for empty file\n\n    fs.unlinkSync(emptyJsonlFile);  // Cleanup after the test\n  });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Reads a JSON Lines file and returns its content as an array of objects.\n *\n * @param {string} filePath - The path to the JSON Lines file.\n * @returns {Promise<Array<Object>>} A promise that resolves to an array of JSON objects parsed from the file.\n * @throws {Error} If the specified file does not exist.\n * @throws {SyntaxError} If there is an error parsing a line in the JSON Lines file.\n */\nasync function readJsonl(filePath) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Reads a JSON Lines file and returns its content as an array of objects.\n *\n * @param file_path - The path to the JSON Lines file.\n * @returns An array of JSON objects parsed from the file.\n * @throws {Error} If the specified file does not exist.\n * @throws {SyntaxError} If there is an error parsing a line in the JSON Lines file.\n */\nfunction readJsonl(file_path: string): Array<{ [key: string]: any }> {\n\n}", "test_code": "describe('TestReadJsonl', () => {\n   let validJsonlFile: string;\n   let invalidJsonlFile: string;\n   let nonExistentFile: string;\n   let emptyJsonlFile: string;\n\n   beforeAll(() => {\n       // Create temporary JSON Lines files for testing\n       validJsonlFile = 'test_valid.jsonl';\n       invalidJsonlFile = 'test_invalid.jsonl';\n       nonExistentFile = 'non_existent.jsonl';\n       emptyJsonlFile = 'test_empty.jsonl';\n\n       // Valid JSON Lines content\n       fs.writeFileSync(validJsonlFile, '{\"name\": \"Alice\", \"age\": 30}\\n' +\n                           '{\"name\": \"Bob\", \"age\": 25}\\n' +\n                           '{\"name\": \"Charlie\", \"age\": 35}\\n');\n\n       // Invalid JSON Lines content\n       fs.writeFileSync(invalidJsonlFile, '{\"name\": \"Alice\", \"age\": 30}\\n' +\n                             '{\"name\": \"Bob\", \"age\": \"twenty-five}\\n');  // Missing closing quote\n   });\n\n   afterAll(() => {\n       // Remove the temporary JSON Lines files after testing\n       if (fs.existsSync(validJsonlFile)) {\n           fs.unlinkSync(validJsonlFile);\n       }\n       if (fs.existsSync(invalidJsonlFile)) {\n           fs.unlinkSync(invalidJsonlFile);\n       }\n       if (fs.existsSync(emptyJsonlFile)) {\n           fs.unlinkSync(emptyJsonlFile);\n       }\n   });\n\n   it('should read a valid JSON Lines file correctly', () => {\n       const expectedData = [\n           {\"name\": \"Alice\", \"age\": 30},\n           {\"name\": \"Bob\", \"age\": 25},\n           {\"name\": \"Charlie\", \"age\": 35}\n       ];\n       const result = readJsonl(validJsonlFile);\n       expect(result).toEqual(expectedData);\n   });\n\n   it('should throw an error when the file does not exist', () => {\n       expect(() => readJsonl(nonExistentFile)).toThrow(Error);\n   });\n\n   it('should handle an empty JSON Lines file correctly', () => {\n       fs.writeFileSync(emptyJsonlFile, '');  // Create an empty JSON Lines file\n       const result = readJsonl(emptyJsonlFile);\n       expect(result).toEqual([]);  // Expecting an empty list for empty file\n   });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Reads a JSON Lines file and returns its content as an array of objects.\n *\n * @param file_path - The path to the JSON Lines file.\n * @returns An array of JSON objects parsed from the file.\n * @throws {Error} If the specified file does not exist.\n * @throws {SyntaxError} If there is an error parsing a line in the JSON Lines file.\n */\nfunction readJsonl(file_path: string): Array<{ [key: string]: any }> {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Reads a JSON Lines file and returns its content as a list of dictionaries.\n *\n * @param file_path The path to the JSON Lines file.\n * @return A list of JSON objects parsed from the file.\n * @throws std::runtime_error If the specified file does not exist.\n * @throws std::runtime_error If there is an error parsing a line in the JSON Lines file.\n */\njson_list read_jsonl(const std::string& file_path) {}", "test_code": "TEST_CASE(\"Test reading JSON Lines files\", \"[jsonl]\") {\n    // Create temporary JSON Lines files for testing\n    const std::string valid_jsonl_file = \"test_valid.jsonl\";\n    const std::string invalid_jsonl_file = \"test_invalid.jsonl\";\n    const std::string non_existent_file = \"non_existent.jsonl\";\n    const std::string empty_jsonl_file = \"test_empty.jsonl\";\n\n    // Valid JSON Lines content\n    {\n        std::ofstream file(valid_jsonl_file);\n        file << R\"({\"name\": \"Alice\", \"age\": 30})\\n\";\n        file << R\"({\"name\": \"Bob\", \"age\": 25})\\n\";\n        file << R\"({\"name\": \"Charlie\", \"age\": 35})\\n\";\n    }\n\n    // Invalid JSON Lines content\n    {\n        std::ofstream file(invalid_jsonl_file);\n        file << R\"({\"name\": \"Alice\", \"age\": 30})\\n\";\n        file << R\"({\"name\": \"Bob\", \"age\": \"twenty-five}\\n\");  // Missing closing quote\n    }\n\n    // Empty JSON Lines file\n    {\n        std::ofstream file(empty_jsonl_file);\n        file << \"\";  // Create an empty JSON Lines file\n    }\n\n    SECTION(\"Test reading a valid JSON Lines file\") {\n        json_list expected_data = {\n            json{{\"name\", \"Alice\"}, {\"age\", 30}},\n            json{{\"name\", \"Bob\"}, {\"age\", 25}},\n            json{{\"name\", \"Charlie\"}, {\"age\", 35}}\n        };\n\n        json_list result = read_jsonl(valid_jsonl_file);\n        REQUIRE(result == expected_data);\n    }\n\n    SECTION(\"Test for FileNotFoundError when the file does not exist\") {\n        REQUIRE_THROWS_AS(read_jsonl(non_existent_file), std::runtime_error);\n    }\n\n    SECTION(\"Test reading an empty JSON Lines file\") {\n        json_list result = read_jsonl(empty_jsonl_file);\n        REQUIRE(result.empty());\n    }\n\n    // Remove the temporary JSON Lines files after testing\n    if (fs::exists(valid_jsonl_file)) {\n        fs::remove(valid_jsonl_file);\n    }\n    if (fs::exists(invalid_jsonl_file)) {\n        fs::remove(invalid_jsonl_file);\n    }\n    if (fs::exists(empty_jsonl_file)) {\n        fs::remove(empty_jsonl_file);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Reads a JSON Lines file and returns its content as a list of dictionaries.\n *\n * @param file_path The path to the JSON Lines file.\n * @return A list of JSON objects parsed from the file.\n * @throws std::runtime_error If the specified file does not exist.\n * @throws std::runtime_error If there is an error parsing a line in the JSON Lines file.\n */\njson_list read_jsonl(const std::string& file_path) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads a JSON Lines file and returns its content as a list of dictionaries.\n *\n * @param filePath The path to the JSON Lines file.\n * @return A list of JSON objects parsed from the file.\n * @throws IOException If the specified file does not exist or there is an error reading the file.\n */\npublic static List<JSONObject> readJsonl(String filePath) throws IOException {\n\n}\n", "test_code": "package org.real.temp;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.json.JSONObject;\n\npublic class Tester {\n\n    private static final String VALID_JSONL_FILE = \"test_valid.jsonl\";\n    private static final String INVALID_JSONL_FILE = \"test_invalid.jsonl\";\n    private static final String NON_EXISTENT_FILE = \"non_existent.jsonl\";\n    private static final String EMPTY_JSONL_FILE = \"test_empty.jsonl\";\n\n    @Before\n    public void setUp() throws IOException {\n        // Valid JSON Lines content\n        try (FileWriter writer = new FileWriter(VALID_JSONL_FILE)) {\n            writer.write(\"{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 30}\\n\");\n            writer.write(\"{\\\"name\\\": \\\"Bob\\\", \\\"age\\\": 25}\\n\");\n            writer.write(\"{\\\"name\\\": \\\"Charlie\\\", \\\"age\\\": 35}\\n\");\n        }\n\n        // Invalid JSON Lines content\n        try (FileWriter writer = new FileWriter(INVALID_JSONL_FILE)) {\n            writer.write(\"{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 30}\\n\");\n            writer.write(\"{\\\"name\\\": \\\"Bob\\\", \\\"age\\\": \\\"twenty-five}\\n\");  // Missing closing quote\n        }\n    }\n\n    @After\n    public void tearDown() {\n        // Remove the temporary JSON Lines files after testing\n        new File(VALID_JSONL_FILE).delete();\n        new File(INVALID_JSONL_FILE).delete();\n        new File(EMPTY_JSONL_FILE).delete();\n    }\n\n    @Test\n    public void testReadValidJsonl() throws IOException {\n        // Test reading a valid JSON Lines file\n        List<JSONObject> expectedData = new ArrayList<>();\n        expectedData.add(new JSONObject().put(\"name\", \"Alice\").put(\"age\", 30));\n        expectedData.add(new JSONObject().put(\"name\", \"Bob\").put(\"age\", 25));\n        expectedData.add(new JSONObject().put(\"name\", \"Charlie\").put(\"age\", 35));\n\n        List<JSONObject> result = readJsonl(VALID_JSONL_FILE);\n        assertEquals(expectedData, result);\n    }\n\n    @Test(expected = IOException.class)\n    public void testFileNotFound() throws IOException {\n        // Test for FileNotFoundException when the file does not exist\n        readJsonl(NON_EXISTENT_FILE);\n    }\n\n    @Test\n    public void testEmptyJsonlFile() throws IOException {\n        // Test reading an empty JSON Lines file\n        try (FileWriter writer = new FileWriter(EMPTY_JSONL_FILE)) {\n            writer.write(\"\");  // Create an empty JSON Lines file\n        }\n\n        List<JSONObject> result = readJsonl(EMPTY_JSONL_FILE);\n        assertEquals(new ArrayList<>(), result);\n\n        // Cleanup after the test\n        new File(EMPTY_JSONL_FILE).delete();\n    }\n\n    // Utility method to read JSON Lines file\n    private static List<JSONObject> readJsonl(String filePath) throws IOException {\n        // Check if the file exists\n        File file = new File(filePath);\n        if (!file.exists()) {\n            throw new IOException(\"The file '\" + filePath + \"' does not exist.\");\n        }\n\n        List<JSONObject> jsonList = new ArrayList<>();\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                try {\n                    JSONObject jsonObject = new JSONObject(new JSONTokener(line));\n                    jsonList.add(jsonObject);\n                } catch (Exception e) {\n                    throw new IOException(\"Error parsing line: \" + line.trim() + \" - \" + e.getMessage());\n                }\n            }\n        }\n\n        return jsonList;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Reads a JSON Lines file and returns its content as a list of dictionaries.\n *\n * @param filePath The path to the JSON Lines file.\n * @return A list of JSON objects parsed from the file.\n * @throws IOException If the specified file does not exist or there is an error reading the file.\n */\npublic static List<JSONObject> readJsonl(String filePath) throws IOException {\n\n}\n,package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 518, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Convert numeric values in a CSV row from string format to a standardized format.", "language_version_list": {"python": {"code_signature": "from typing import Dict, Optional\n\ndef convert_csv_values(row: Dict[str, str]) -> Dict[str, Optional[str]]:\n    \"\"\"\n    Convert numeric values in a CSV row from string format to a standardized format.\n\n    Args:\n        row (Dict[str, str]): A dictionary representing a row of CSV data where\n                               keys are column names and values are strings.\n\n    Returns:\n        Dict[str, Optional[str]]: A new dictionary with values converted:\n                                   - Numeric strings have commas replaced with dots.\n                                   - Non-numeric strings are set to None.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestConvertCsvValues(unittest.TestCase):\n\n    def test_valid_numeric_strings(self):\n        \"\"\"Test with valid numeric strings including commas.\"\"\"\n        row = {'value1': '1,234', 'value2': '5,678', 'value3': '9,876'}\n        expected = {'value1': '1.234', 'value2': '5.678', 'value3': '9.876'}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n\n    def test_non_numeric_strings(self):\n        \"\"\"Test with non-numeric strings.\"\"\"\n        row = {'value1': 'not_a_number', 'value2': 'hello', 'value3': 'world'}\n        expected = {'value1': None, 'value2': None, 'value3': None}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n\n    def test_mixed_values(self):\n        \"\"\"Test with a mix of numeric and non-numeric strings.\"\"\"\n        row = {'value1': '1,234', 'value2': 'not_a_number', 'value3': '3,14159'}\n        expected = {'value1': '1.234', 'value2': None, 'value3': '3.14159'}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n\n    def test_no_values(self):\n        row = {'value1': 'aaaa', 'value2': 'not_a_number', 'value3': '3,14'}\n        expected = {'value1': None, 'value2': None, 'value3': '3.14'}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n\n    def test_edge_cases(self):\n        \"\"\"Test edge cases with empty strings and negative numbers.\"\"\"\n        row = {'value1': '', 'value2': '0.0', 'value3': '1,23'}\n        expected = {'value1': None, 'value2': '0.0', 'value3': '1.23'}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import Dict, Optional\n\ndef convert_csv_values(row: Dict[str, str]) -> Dict[str, Optional[str]]:\n    \"\"\"\n    Convert numeric values in a CSV row from string format to a standardized format.\n\n    Args:\n        row (Dict[str, str]): A dictionary representing a row of CSV data where\n                               keys are column names and values are strings.\n\n    Returns:\n        Dict[str, Optional[str]]: A new dictionary with values converted:\n                                   - Numeric strings have commas replaced with dots.\n                                   - Non-numeric strings are set to None.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Convert numeric values in a CSV row from string format to a standardized format.\n *\n * @param {Object} row - A dictionary representing a row of CSV data where\n *                       keys are column names and values are strings.\n * @returns {Object} - A new dictionary with values converted:\n *                     - Numeric strings have commas replaced with dots.\n *                     - Non-numeric strings are set to null.\n */\nfunction convertCsvValues(row) {\n\n}", "test_code": "describe('TestConvertCsvValues', () => {\n    describe('test_valid_numeric_strings', () => {\n        it('should handle valid numeric strings including commas', () => {\n            const row = {'value1': '1,234', 'value2': '5,678', 'value3': '9,876'};\n            const expected = {'value1': '1.234', 'value2': '5.678', 'value3': '9.876'};\n            const result = convertCsvValues(row);\n            expect(result).toEqual(expected);\n        });\n    });\n\n    describe('test_non_numeric_strings', () => {\n        it('should handle non-numeric strings', () => {\n            const row = {'value1': 'not_a_number', 'value2': 'hello', 'value3': 'world'};\n            const expected = {'value1': null, 'value2': null, 'value3': null};\n            const result = convertCsvValues(row);\n            expect(result).toEqual(expected);\n        });\n    });\n\n    describe('test_mixed_values', () => {\n        it('should handle a mix of numeric and non-numeric strings', () => {\n            const row = {'value1': '1,234', 'value2': 'not_a_number', 'value3': '3,14159'};\n            const expected = {'value1': '1.234', 'value2': null, 'value3': '3.14159'};\n            const result = convertCsvValues(row);\n            expect(result).toEqual(expected);\n        });\n    });\n\n    describe('test_no_values', () => {\n        it('should handle a mix of non-numeric and numeric strings', () => {\n            const row = {'value1': 'aaaa', 'value2': 'not_a_number', 'value3': '3,14'};\n            const expected = {'value1': null, 'value2': null, 'value3': '3.14'};\n            const result = convertCsvValues(row);\n            expect(result).toEqual(expected);\n        });\n    });\n\n    describe('test_edge_cases', () => {\n        it('should handle edge cases with empty strings and negative numbers', () => {\n            const row = {'value1': '', 'value2': '0.0', 'value3': '1,23'};\n            const expected = {'value1': null, 'value2': '0.0', 'value3': '1.23'};\n            const result = convertCsvValues(row);\n            expect(result).toEqual(expected);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Convert numeric values in a CSV row from string format to a standardized format.\n *\n * @param {Object} row - A dictionary representing a row of CSV data where\n *                       keys are column names and values are strings.\n * @returns {Object} - A new dictionary with values converted:\n *                     - Numeric strings have commas replaced with dots.\n *                     - Non-numeric strings are set to null.\n */\nfunction convertCsvValues(row) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Convert numeric values in a CSV row from string format to a standardized format.\n *\n * @param row - A dictionary representing a row of CSV data where keys are column names and values are strings.\n * @returns A new dictionary with values converted:\n *          - Numeric strings have commas replaced with dots.\n *          - Non-numeric strings are set to null.\n */\nfunction convertCsvValues(row: Record<string, string>): Record<string, string | null> {\n\n}", "test_code": "describe('TestConvertCsvValues', () => {\n    describe('testValidNumericStrings', () => {\n        it('should handle valid numeric strings including commas', () => {\n            const row = { value1: '1,234', value2: '5,678', value3: '9,876' };\n            const expected = { value1: '1.234', value2: '5.678', value3: '9.876' };\n            const result = convertCsvValues(row);\n            expect(result).toEqual(expected);\n        });\n    });\n\n    describe('testNonNumericStrings', () => {\n        it('should handle non-numeric strings', () => {\n            const row = { value1: 'not_a_number', value2: 'hello', value3: 'world' };\n            const expected = { value1: null, value2: null, value3: null };\n            const result = convertCsvValues(row);\n            expect(result).toEqual(expected);\n        });\n    });\n\n    describe('testMixedValues', () => {\n        it('should handle a mix of numeric and non-numeric strings', () => {\n            const row = { value1: '1,234', value2: 'not_a_number', value3: '3,14159' };\n            const expected = { value1: '1.234', value2: null, value3: '3.14159' };\n            const result = convertCsvValues(row);\n            expect(result).toEqual(expected);\n        });\n    });\n\n    describe('testNoValues', () => {\n        it('should handle a mix of non-numeric and numeric strings', () => {\n            const row = { value1: 'aaaa', value2: 'not_a_number', value3: '3,14' };\n            const expected = { value1: null, value2: null, value3: '3.14' };\n            const result = convertCsvValues(row);\n            expect(result).toEqual(expected);\n        });\n    });\n\n    describe('testEdgeCases', () => {\n        it('should handle edge cases with empty strings and negative numbers', () => {\n            const row = { value1: '', value2: '0.0', value3: '1,23' };\n            const expected = { value1: null, value2: '0.0', value3: '1.23' };\n            const result = convertCsvValues(row);\n            expect(result).toEqual(expected);\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Convert numeric values in a CSV row from string format to a standardized format.\n *\n * @param row - A dictionary representing a row of CSV data where keys are column names and values are strings.\n * @returns A new dictionary with values converted:\n *          - Numeric strings have commas replaced with dots.\n *          - Non-numeric strings are set to null.\n */\nfunction convertCsvValues(row: Record<string, string>): Record<string, string | null> {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert numeric values in a CSV row from string format to a standardized format.\n *\n * @param row A map representing a row of CSV data where keys are column names and values are strings.\n * @return A new map with values converted:\n *         - Numeric strings have commas replaced with dots.\n *         - Non-numeric strings are set to an empty string (to represent None).\n */\nstd::map<std::string, std::string> convert_csv_values(const std::map<std::string, std::string>& row) {}", "test_code": "#include <catch2/catch_test_macros.hpp>\n#include <map>\n#include <string>\n#include <cctype>\n\nTEST_CASE(\"TestConvertCsvValues\", \"[convert_csv_values]\") {\n    SECTION(\"test_valid_numeric_strings\") {\n        std::map<std::string, std::string> row = {\n            {\"value1\", \"1,234\"},\n            {\"value2\", \"5,678\"},\n            {\"value3\", \"9,876\"}\n        };\n        std::map<std::string, std::string> expected = {\n            {\"value1\", \"1.234\"},\n            {\"value2\", \"5.678\"},\n            {\"value3\", \"9.876\"}\n        };\n        auto result = convert_csv_values(row);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_non_numeric_strings\") {\n        std::map<std::string, std::string> row = {\n            {\"value1\", \"not_a_number\"},\n            {\"value2\", \"hello\"},\n            {\"value3\", \"world\"}\n        };\n        std::map<std::string, std::string> expected = {\n            {\"value1\", \"\"},\n            {\"value2\", \"\"},\n            {\"value3\", \"\"}\n        };\n        auto result = convert_csv_values(row);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_mixed_values\") {\n        std::map<std::string, std::string> row = {\n            {\"value1\", \"1,234\"},\n            {\"value2\", \"not_a_number\"},\n            {\"value3\", \"3,14159\"}\n        };\n        std::map<std::string, std::string> expected = {\n            {\"value1\", \"1.234\"},\n            {\"value2\", \"\"},\n            {\"value3\", \"3.14159\"}\n        };\n        auto result = convert_csv_values(row);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_no_values\") {\n        std::map<std::string, std::string> row = {\n            {\"value1\", \"aaaa\"},\n            {\"value2\", \"not_a_number\"},\n            {\"value3\", \"3,14\"}\n        };\n        std::map<std::string, std::string> expected = {\n            {\"value1\", \"\"},\n            {\"value2\", \"\"},\n            {\"value3\", \"3.14\"}\n        };\n        auto result = convert_csv_values(row);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"test_edge_cases\") {\n        std::map<std::string, std::string> row = {\n            {\"value1\", \"\"},\n            {\"value2\", \"0.0\"},\n            {\"value3\", \"1,23\"}\n        };\n        std::map<std::string, std::string> expected = {\n            {\"value1\", \"\"},\n            {\"value2\", \"0.0\"},\n            {\"value3\", \"1.23\"}\n        };\n        auto result = convert_csv_values(row);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert numeric values in a CSV row from string format to a standardized format.\n *\n * @param row A map representing a row of CSV data where keys are column names and values are strings.\n * @return A new map with values converted:\n *         - Numeric strings have commas replaced with dots.\n *         - Non-numeric strings are set to an empty string (to represent None).\n */\nstd::map<std::string, std::string> convert_csv_values(const std::map<std::string, std::string>& row) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Convert numeric values in a CSV row from string format to a standardized format.\n *\n * <p>\n * This method takes a map representing a row of CSV data, where keys are column names and values are strings.\n * It returns a new map with the following conversions:\n * - Numeric strings have commas replaced with dots.\n * - Non-numeric strings are set to null.\n * </p>\n *\n * @param row A map representing a row of CSV data where keys are column names and values are strings.\n * @return A new map with values converted as described above.\n */\npublic static Map<String, String> convertCsvValues(Map<String, String> row) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Tester {\n\n    @Test\n    public void testValidNumericStrings() {\n        Map<String, String> row = new HashMap<>();\n        row.put(\"value1\", \"1,234\");\n        row.put(\"value2\", \"5,678\");\n        row.put(\"value3\", \"9,876\");\n\n        Map<String, String> expected = new HashMap<>();\n        expected.put(\"value1\", \"1.234\");\n        expected.put(\"value2\", \"5.678\");\n        expected.put(\"value3\", \"9.876\");\n\n        Map<String, String> result = convertCsvValues(row);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testNonNumericStrings() {\n        Map<String, String> row = new HashMap<>();\n        row.put(\"value1\", \"not_a_number\");\n        row.put(\"value2\", \"hello\");\n        row.put(\"value3\", \"world\");\n\n        Map<String, String> expected = new HashMap<>();\n        expected.put(\"value1\", null);\n        expected.put(\"value2\", null);\n        expected.put(\"value3\", null);\n\n        Map<String, String> result = convertCsvValues(row);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testMixedValues() {\n        Map<String, String> row = new HashMap<>();\n        row.put(\"value1\", \"1,234\");\n        row.put(\"value2\", \"not_a_number\");\n        row.put(\"value3\", \"3,14159\");\n\n        Map<String, String> expected = new HashMap<>();\n        expected.put(\"value1\", \"1.234\");\n        expected.put(\"value2\", null);\n        expected.put(\"value3\", \"3.14159\");\n\n        Map<String, String> result = convertCsvValues(row);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testNoValues() {\n        Map<String, String> row = new HashMap<>();\n        row.put(\"value1\", \"aaaa\");\n        row.put(\"value2\", \"not_a_number\");\n        row.put(\"value3\", \"3,14\");\n\n        Map<String, String> expected = new HashMap<>();\n        expected.put(\"value1\", null);\n        expected.put(\"value2\", null);\n        expected.put(\"value3\", \"3.14\");\n\n        Map<String, String> result = convertCsvValues(row);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testEdgeCases() {\n        Map<String, String> row = new HashMap<>();\n        row.put(\"value1\", \"\");\n        row.put(\"value2\", \"0.0\");\n        row.put(\"value3\", \"1,23\");\n\n        Map<String, String> expected = new HashMap<>();\n        expected.put(\"value1\", null);\n        expected.put(\"value2\", \"0.0\");\n        expected.put(\"value3\", \"1.23\");\n\n        Map<String, String> result = convertCsvValues(row);\n        assertEquals(expected, result);\n    }\n\n    // Method to be tested\n    private Map<String, String> convertCsvValues(Map<String, String> row) {\n        Map<String, String> convertedRow = new HashMap<>();\n\n        for (Map.Entry<String, String> entry : row.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n\n            // Check if the value is numeric with possible comma and negative sign\n            boolean isNumeric = value.replace(\",\", \"\").replace(\"-\", \"\").matches(\"[0-9]+\");\n\n            if (isNumeric) {\n                // Replace comma with dot for numeric conversion\n                convertedRow.put(key, value.replace(',', '.'));\n            } else {\n                // Set to null if not a valid number\n                convertedRow.put(key, null);\n            }\n        }\n\n        return convertedRow;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Convert numeric values in a CSV row from string format to a standardized format.\n *\n * <p>\n * This method takes a map representing a row of CSV data, where keys are column names and values are strings.\n * It returns a new map with the following conversions:\n * - Numeric strings have commas replaced with dots.\n * - Non-numeric strings are set to null.\n * </p>\n *\n * @param row A map representing a row of CSV data where keys are column names and values are strings.\n * @return A new map with values converted as described above.\n */\npublic static Map<String, String> convertCsvValues(Map<String, String> row) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 519, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Transpose a given matrix (2D array).", "language_version_list": {"python": {"code_signature": "from typing import List\n\ndef transpose_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transpose a given matrix (2D array).\n\n    Args:\n        matrix (List[List[int]]): The input 2D array to be transposed.\n\n    Returns:\n        List[List[int]]: The transposed 2D array.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestTransposeMatrix(unittest.TestCase):\n\n    def test_square_matrix(self):\n        \"\"\"Test transposing a square matrix.\"\"\"\n        matrix = [[1, 2], [3, 4]]\n        expected = [[1, 3], [2, 4]]\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)\n\n    def test_rectangular_matrix(self):\n        \"\"\"Test transposing a rectangular matrix.\"\"\"\n        matrix = [[1, 2, 3], [4, 5, 6]]\n        expected = [[1, 4], [2, 5], [3, 6]]\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)\n\n\n    def test_matrix_with_empty_rows(self):\n        \"\"\"Test transposing a matrix with an empty row.\"\"\"\n        matrix = [[], []]\n        expected = []\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)\n\n    def test_single_element_matrix(self):\n        \"\"\"Test transposing a matrix with a single element.\"\"\"\n        matrix = [[5]]\n        expected = [[5]]\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below from typing import List\n\ndef transpose_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transpose a given matrix (2D array).\n\n    Args:\n        matrix (List[List[int]]): The input 2D array to be transposed.\n\n    Returns:\n        List[List[int]]: The transposed 2D array.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Transpose a given matrix (2D array).\n *\n * @param {Array<Array<number>>} matrix - The input 2D array to be transposed.\n * @returns {Array<Array<number>>} The transposed 2D array.\n */\nfunction transposeMatrix(matrix) {\n\n}", "test_code": "describe('TestTransposeMatrix', () => {\n    it('test_square_matrix', () => {\n        // Test transposing a square matrix\n        const matrix = [[1, 2], [3, 4]];\n        const expected = [[1, 3], [2, 4]];\n        const result = transposeMatrix(matrix);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_rectangular_matrix', () => {\n        // Test transposing a rectangular matrix\n        const matrix = [[1, 2, 3], [4, 5, 6]];\n        const expected = [[1, 4], [2, 5], [3, 6]];\n        const result = transposeMatrix(matrix);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_matrix_with_empty_rows', () => {\n        // Test transposing a matrix with an empty row\n        const matrix = [[], []];\n        const expected = [];\n        const result = transposeMatrix(matrix);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_single_element_matrix', () => {\n        // Test transposing a matrix with a single element\n        const matrix = [[5]];\n        const expected = [[5]];\n        const result = transposeMatrix(matrix);\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Transpose a given matrix (2D array).\n *\n * @param {Array<Array<number>>} matrix - The input 2D array to be transposed.\n * @returns {Array<Array<number>>} The transposed 2D array.\n */\nfunction transposeMatrix(matrix) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Transpose a given matrix (2D array).\n *\n * @param matrix - The input 2D array to be transposed.\n * @returns The transposed 2D array.\n */\nfunction transposeMatrix(matrix: number[][]): number[][] {\n\n}", "test_code": "describe('TestTransposeMatrix', () => {\n  it('should transpose a square matrix', () => {\n    const matrix = [[1, 2], [3, 4]];\n    const expected = [[1, 3], [2, 4]];\n    const result = transposeMatrix(matrix);\n    expect(result).toEqual(expected);\n  });\n\n  it('should transpose a rectangular matrix', () => {\n    const matrix = [[1, 2, 3], [4, 5, 6]];\n    const expected = [[1, 4], [2, 5], [3, 6]];\n    const result = transposeMatrix(matrix);\n    expect(result).toEqual(expected);\n  });\n\n  it('should handle a matrix with empty rows', () => {\n    const matrix = [[], []];\n    const expected = [];\n    const result = transposeMatrix(matrix);\n    expect(result).toEqual(expected);\n  });\n\n  it('should transpose a matrix with a single element', () => {\n    const matrix = [[5]];\n    const expected = [[5]];\n    const result = transposeMatrix(matrix);\n    expect(result).toEqual(expected);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Transpose a given matrix (2D array).\n *\n * @param matrix - The input 2D array to be transposed.\n * @returns The transposed 2D array.\n */\nfunction transposeMatrix(matrix: number[][]): number[][] {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Transpose a given matrix (2D array).\n *\n * @param matrix The input 2D array to be transposed.\n * @return The transposed 2D array.\n */\nstd::vector<std::vector<int>> transpose_matrix(const std::vector<std::vector<int>>& matrix) {}", "test_code": "TEST_CASE(\"Test transposing a square matrix\", \"[transpose_matrix]\") {\n    std::vector<std::vector<int>> matrix = {{1, 2}, {3, 4}};\n    std::vector<std::vector<int>> expected = {{1, 3}, {2, 4}};\n    auto result = transpose_matrix(matrix);\n    REQUIRE(result == expected);\n}\n\nTEST_CASE(\"Test transposing a rectangular matrix\", \"[transpose_matrix]\") {\n    std::vector<std::vector<int>> matrix = {{1, 2, 3}, {4, 5, 6}};\n    std::vector<std::vector<int>> expected = {{1, 4}, {2, 5}, {3, 6}};\n    auto result = transpose_matrix(matrix);\n    REQUIRE(result == expected);\n}\n\nTEST_CASE(\"Test transposing a matrix with an empty row\", \"[transpose_matrix]\") {\n    std::vector<std::vector<int>> matrix = {{}, {}};\n    std::vector<std::vector<int>> expected = {};\n    auto result = transpose_matrix(matrix);\n    REQUIRE(result == expected);\n}\n\nTEST_CASE(\"Test transposing a matrix with a single element\", \"[transpose_matrix]\") {\n    std::vector<std::vector<int>> matrix = {{5}};\n    std::vector<std::vector<int>> expected = {{5}};\n    auto result = transpose_matrix(matrix);\n    REQUIRE(result == expected);\n}\n", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Transpose a given matrix (2D array).\n *\n * @param matrix The input 2D array to be transposed.\n * @return The transposed 2D array.\n */\nstd::vector<std::vector<int>> transpose_matrix(const std::vector<std::vector<int>>& matrix) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Transpose a given matrix (2D array).\n *\n * @param matrix The input 2D array to be transposed.\n * @return The transposed 2D array.\n */\npublic static List<List<Integer>> transposeMatrix(List<List<Integer>> matrix) {\n\n}", "test_code": "import org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class Tester {\n\n    private List<List<Integer>> transposeMatrix(List<List<Integer>> matrix) {\n        // Check if the matrix is empty\n        if (matrix == null || matrix.isEmpty() || matrix.get(0).isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        int numRows = matrix.size();\n        int numCols = matrix.get(0).size();\n\n        // Initialize the transposed matrix with the correct dimensions\n        List<List<Integer>> transposed = new ArrayList<>();\n        for (int col = 0; col < numCols; col++) {\n            List<Integer> newRow = new ArrayList<>(numRows);\n            for (int row = 0; row < numRows; row++) {\n                newRow.add(0);\n            }\n            transposed.add(newRow);\n        }\n\n        // Populate the transposed matrix\n        for (int i = 0; i < numRows; i++) {\n            for (int j = 0; j < numCols; j++) {\n                transposed.get(j).set(i, matrix.get(i).get(j));\n            }\n        }\n\n        return transposed;\n    }\n\n    @Test\n    public void testSquareMatrix() {\n        List<List<Integer>> matrix = new ArrayList<>();\n        matrix.add(List.of(1, 2));\n        matrix.add(List.of(3, 4));\n        List<List<Integer>> expected = new ArrayList<>();\n        expected.add(List.of(1, 3));\n        expected.add(List.of(2, 4));\n        List<List<Integer>> result = transposeMatrix(matrix);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testRectangularMatrix() {\n        List<List<Integer>> matrix = new ArrayList<>();\n        matrix.add(List.of(1, 2, 3));\n        matrix.add(List.of(4, 5, 6));\n        List<List<Integer>> expected = new ArrayList<>();\n        expected.add(List.of(1, 4));\n        expected.add(List.of(2, 5));\n        expected.add(List.of(3, 6));\n        List<List<Integer>> result = transposeMatrix(matrix);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testMatrixWithEmptyRows() {\n        List<List<Integer>> matrix = new ArrayList<>();\n        matrix.add(new ArrayList<>());\n        matrix.add(new ArrayList<>());\n        List<List<Integer>> expected = new ArrayList<>();\n        List<List<Integer>> result = transposeMatrix(matrix);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testSingleElementMatrix() {\n        List<List<Integer>> matrix = new ArrayList<>();\n        matrix.add(List.of(5));\n        List<List<Integer>> expected = new ArrayList<>();\n        expected.add(List.of(5));\n        List<List<Integer>> result = transposeMatrix(matrix);\n        assertEquals(expected, result);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Transpose a given matrix (2D array).\n *\n * @param matrix The input 2D array to be transposed.\n * @return The transposed 2D array.\n */\npublic static List<List<Integer>> transposeMatrix(List<List<Integer>> matrix) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 520, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "    Computes the output index from two given indices in the MultiVector's representation\n    of the G_n orthonormal basis.", "language_version_list": {"python": {"code_signature": "def compute_output_index(idx_1: int, idx_2: int) -> int:\n    \"\"\"\n    Computes the output index from two given indices in the MultiVector's representation\n    of the G_n orthonormal basis.\n\n    This function interprets the integers as little-endian bitstrings, takes their XOR,\n    and interprets the result as an integer in little-endian.\n\n    Args:\n        idx_1 (int): Input index 1.\n        idx_2 (int): Input index 2.\n\n    Returns:\n        int: The computed output index.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestComputeOutputIndex(unittest.TestCase):\n\n    def test_standard_case(self):\n        \"\"\"Test with two standard positive integers.\"\"\"\n        idx_1 = 3  # binary: 11\n        idx_2 = 5  # binary: 101\n        expected = 6  # 3 XOR 5 = 6\n        result = compute_output_index(idx_1, idx_2)\n        self.assertEqual(result, expected)\n\n    def test_identical_indices(self):\n        \"\"\"Test with identical indices (should return 0).\"\"\"\n        idx_1 = 7  # binary: 111\n        idx_2 = 7  # binary: 111\n        expected = 0  # 7 XOR 7 = 0\n        result = compute_output_index(idx_1, idx_2)\n        self.assertEqual(result, expected)\n\n    def test_zero_index(self):\n        \"\"\"Test with one index as zero.\"\"\"\n        idx_1 = 0  # binary: 0\n        idx_2 = 5  # binary: 101\n        expected = 5  # 0 XOR 5 = 5\n        result = compute_output_index(idx_1, idx_2)\n        self.assertEqual(result, expected)\n\n    def test_large_numbers(self):\n        \"\"\"Test with large integer values.\"\"\"\n        idx_1 = 1024  # binary: 10000000000\n        idx_2 = 2048  # binary: 100000000000\n        expected = 3072  # 1024 XOR 2048 = 3072\n        result = compute_output_index(idx_1, idx_2)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def compute_output_index(idx_1: int, idx_2: int) -> int:\n    \"\"\"\n    Computes the output index from two given indices in the MultiVector's representation\n    of the G_n orthonormal basis.\n\n    This function interprets the integers as little-endian bitstrings, takes their XOR,\n    and interprets the result as an integer in little-endian.\n\n    Args:\n        idx_1 (int): Input index 1.\n        idx_2 (int): Input index 2.\n\n    Returns:\n        int: The computed output index.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Computes the output index from two given indices in the MultiVector's representation\n * of the G_n orthonormal basis.\n *\n * This function interprets the integers as little-endian bitstrings, takes their XOR,\n * and interprets the result as an integer in little-endian.\n *\n * @param {number} idx1 - Input index 1.\n * @param {number} idx2 - Input index 2.\n * @returns {number} The computed output index.\n */\nfunction computeOutputIndex(idx1, idx2) {\n\n}", "test_code": "describe('TestComputeOutputIndex', () => {\n    it('test_standard_case', () => {\n        // Test with two standard positive integers\n        const idx_1 = 3;  // binary: 11\n        const idx_2 = 5;  // binary: 101\n        const expected = 6;  // 3 XOR 5 = 6\n        const result = computeOutputIndex(idx_1, idx_2);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_identical_indices', () => {\n        // Test with identical indices (should return 0)\n        const idx_1 = 7;  // binary: 111\n        const idx_2 = 7;  // binary: 111\n        const expected = 0;  // 7 XOR 7 = 0\n        const result = computeOutputIndex(idx_1, idx_2);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_zero_index', () => {\n        // Test with one index as zero\n        const idx_1 = 0;  // binary: 0\n        const idx_2 = 5;  // binary: 101\n        const expected = 5;  // 0 XOR 5 = 5\n        const result = computeOutputIndex(idx_1, idx_2);\n        expect(result).toEqual(expected);\n    });\n\n    it('test_large_numbers', () => {\n        // Test with large integer values\n        const idx_1 = 1024;  // binary: 10000000000\n        const idx_2 = 2048;  // binary: 100000000000\n        const expected = 3072;  // 1024 XOR 2048 = 3072\n        const result = computeOutputIndex(idx_1, idx_2);\n        expect(result).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Computes the output index from two given indices in the MultiVector's representation\n * of the G_n orthonormal basis.\n *\n * This function interprets the integers as little-endian bitstrings, takes their XOR,\n * and interprets the result as an integer in little-endian.\n *\n * @param {number} idx1 - Input index 1.\n * @param {number} idx2 - Input index 2.\n * @returns {number} The computed output index.\n */\nfunction computeOutputIndex(idx1, idx2) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Computes the output index from two given indices in the MultiVector's representation\n * of the G_n orthonormal basis.\n *\n * This function interprets the integers as little-endian bitstrings, takes their XOR,\n * and interprets the result as an integer in little-endian.\n *\n * @param idx1 - Input index 1.\n * @param idx2 - Input index 2.\n * @returns The computed output index.\n */\nfunction computeOutputIndex(idx1: number, idx2: number): number {\n\n}", "test_code": "describe('TestComputeOutputIndex', () => {\n  it('test_standard_case', () => {\n    /** Test with two standard positive integers. */\n    const idx_1 = 3; // binary: 11\n    const idx_2 = 5; // binary: 101\n    const expected = 6; // 3 XOR 5 = 6\n    const result = computeOutputIndex(idx_1, idx_2);\n    expect(result).toBe(expected);\n  });\n\n  it('test_identical_indices', () => {\n    /** Test with identical indices (should return 0). */\n    const idx_1 = 7; // binary: 111\n    const idx_2 = 7; // binary: 111\n    const expected = 0; // 7 XOR 7 = 0\n    const result = computeOutputIndex(idx_1, idx_2);\n    expect(result).toBe(expected);\n  });\n\n  it('test_zero_index', () => {\n    /** Test with one index as zero. */\n    const idx_1 = 0; // binary: 0\n    const idx_2 = 5; // binary: 101\n    const expected = 5; // 0 XOR 5 = 5\n    const result = computeOutputIndex(idx_1, idx_2);\n    expect(result).toBe(expected);\n  });\n\n  it('test_large_numbers', () => {\n    /** Test with large integer values. */\n    const idx_1 = 1024; // binary: 10000000000\n    const idx_2 = 2048; // binary: 100000000000\n    const expected = 3072; // 1024 XOR 2048 = 3072\n    const result = computeOutputIndex(idx_1, idx_2);\n    expect(result).toBe(expected);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Computes the output index from two given indices in the MultiVector's representation\n * of the G_n orthonormal basis.\n *\n * This function interprets the integers as little-endian bitstrings, takes their XOR,\n * and interprets the result as an integer in little-endian.\n *\n * @param idx1 - Input index 1.\n * @param idx2 - Input index 2.\n * @returns The computed output index.\n */\nfunction computeOutputIndex(idx1: number, idx2: number): number {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/*\n *   Computes the output index from two given indices in the MultiVector's representation\n *   of the G_n orthonormal basis.\n *\n *   This function interprets the integers as little-endian bitstrings, takes their XOR,\n *   and interprets the result as an integer in little-endian.\n *\n *   Args:\n *       idx_1 (uint64_t): Input index 1.\n *       idx_2 (uint64_t): Input index 2.\n *\n *   Returns:\n *       uint64_t: The computed output index.\n */\nuint64_t compute_output_index(uint64_t idx_1, uint64_t idx_2) {\n\n}", "test_code": "#include <catch2/catch_test_macros.hpp>\n#include <cstdint>\n\nTEST_CASE(\"Test Compute Output Index\", \"[compute_output_index]\") {\n    SECTION(\"Test with two standard positive integers\") {\n        uint64_t idx_1 = 3;  // binary: 11\n        uint64_t idx_2 = 5;  // binary: 101\n        uint64_t expected = 6;  // 3 XOR 5 = 6\n        uint64_t result = compute_output_index(idx_1, idx_2);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test with identical indices (should return 0)\") {\n        uint64_t idx_1 = 7;  // binary: 111\n        uint64_t idx_2 = 7;  // binary: 111\n        uint64_t expected = 0;  // 7 XOR 7 = 0\n        uint64_t result = compute_output_index(idx_1, idx_2);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test with one index as zero\") {\n        uint64_t idx_1 = 0;  // binary: 0\n        uint64_t idx_2 = 5;  // binary: 101\n        uint64_t expected = 5;  // 0 XOR 5 = 5\n        uint64_t result = compute_output_index(idx_1, idx_2);\n        REQUIRE(result == expected);\n    }\n\n    SECTION(\"Test with large integer values\") {\n        uint64_t idx_1 = 1024;  // binary: 10000000000\n        uint64_t idx_2 = 2048;  // binary: 100000000000\n        uint64_t expected = 3072;  // 1024 XOR 2048 = 3072\n        uint64_t result = compute_output_index(idx_1, idx_2);\n        REQUIRE(result == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /*\n *   Computes the output index from two given indices in the MultiVector's representation\n *   of the G_n orthonormal basis.\n *\n *   This function interprets the integers as little-endian bitstrings, takes their XOR,\n *   and interprets the result as an integer in little-endian.\n *\n *   Args:\n *       idx_1 (uint64_t): Input index 1.\n *       idx_2 (uint64_t): Input index 2.\n *\n *   Returns:\n *       uint64_t: The computed output index.\n */\nuint64_t compute_output_index(uint64_t idx_1, uint64_t idx_2) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Computes the output index from two given indices in the MultiVector's representation\n * of the G_n orthonormal basis.\n *\n * This function interprets the integers as little-endian bitstrings, takes their XOR,\n * and interprets the result as an integer in little-endian.\n *\n * @param idx1 Input index 1.\n * @param idx2 Input index 2.\n * @return The computed output index.\n */\npublic static int computeOutputIndex(int idx1, int idx2) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for the computeOutputIndex method.\n */\npublic class Tester {\n\n    /**\n     * Tests the computeOutputIndex method with two standard positive integers.\n     */\n    @Test\n    public void testStandardCase() {\n        int idx1 = 3;  // binary: 11\n        int idx2 = 5;  // binary: 101\n        int expected = 6;  // 3 XOR 5 = 6\n        int result = computeOutputIndex(idx1, idx2);\n        assertEquals(expected, result);\n    }\n\n    /**\n     * Tests the computeOutputIndex method with identical indices (should return 0).\n     */\n    @Test\n    public void testIdenticalIndices() {\n        int idx1 = 7;  // binary: 111\n        int idx2 = 7;  // binary: 111\n        int expected = 0;  // 7 XOR 7 = 0\n        int result = computeOutputIndex(idx1, idx2);\n        assertEquals(expected, result);\n    }\n\n    /**\n     * Tests the computeOutputIndex method with one index as zero.\n     */\n    @Test\n    public void testZeroIndex() {\n        int idx1 = 0;  // binary: 0\n        int idx2 = 5;  // binary: 101\n        int expected = 5;  // 0 XOR 5 = 5\n        int result = computeOutputIndex(idx1, idx2);\n        assertEquals(expected, result);\n    }\n\n    /**\n     * Tests the computeOutputIndex method with large integer values.\n     */\n    @Test\n    public void testLargeNumbers() {\n        int idx1 = 1024;  // binary: 10000000000\n        int idx2 = 2048;  // binary: 100000000000\n        int expected = 3072;  // 1024 XOR 2048 = 3072\n        int result = computeOutputIndex(idx1, idx2);\n        assertEquals(expected, result);\n    }\n\n    // Utility method to compute the output index\n    private int computeOutputIndex(int idx1, int idx2) {\n        // Perform bitwise XOR between the two indices\n        int result = idx1 ^ idx2;\n\n        // Convert result to little-endian byte representation\n        byte[] resultBytes = intToLittleEndianBytes(result);\n\n        // Convert little-endian bytes back to an integer\n        int resultInt = littleEndianBytesToInt(resultBytes);\n\n        return resultInt;\n    }\n\n    // Helper method to convert an integer to a little-endian byte array\n    private byte[] intToLittleEndianBytes(int value) {\n        byte[] bytes = new byte[4];\n        for (int i = 0; i < 4; i++) {\n            bytes[i] = (byte) (value & 0xFF);\n            value >>>= 8;\n        }\n        return bytes;\n    }\n\n    // Helper method to convert a little-endian byte array back to an integer\n    private int littleEndianBytesToInt(byte[] bytes) {\n        int result = 0;\n        for (int i = 0; i < bytes.length; i++) {\n            result |= (bytes[i] & 0xFF) << (i * 8);\n        }\n        return result;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Computes the output index from two given indices in the MultiVector's representation\n * of the G_n orthonormal basis.\n *\n * This function interprets the integers as little-endian bitstrings, takes their XOR,\n * and interprets the result as an integer in little-endian.\n *\n * @param idx1 Input index 1.\n * @param idx2 Input index 2.\n * @return The computed output index.\n */\npublic static int computeOutputIndex(int idx1, int idx2) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 521, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Counts the occurrences of specified words in the given text.\n\n    This function filters the words from the text based on the provided list,\n    counts their occurrences, and returns a dictionary with the words in the\n    order they were provided.", "language_version_list": {"python": {"code_signature": "import re\nfrom collections import Counter\nfrom typing import List, Dict\n\n\ndef word_filter_counter(text: str, filter_words: List[str]) -> Dict[str, int]:\n    \"\"\"\n    Counts the occurrences of specified words in the given text.\n\n    This function filters the words from the text based on the provided list,\n    counts their occurrences, and returns a dictionary with the words in the\n    order they were provided.\n\n    Args:\n        text (str): The input text from which to count words.\n        filter_words (List[str]): A list of words to filter and count.\n\n    Returns:\n        Dict[str, int]: A dictionary with the count of each filter word in the text,\n                         maintaining the order from filter_words.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestWordFilterCounter(unittest.TestCase):\n\n    def test_case1(self):\n        text = \"go to the school.go to the park.\"\n        filter_words = [\"go\", \"to\", \"the\", \"school\", \"park\", \"play\"]\n        expected_output = {\n            \"go\": 2,\n            \"to\": 2,\n            \"the\": 2,\n            \"school\": 1,\n            \"park\": 1,\n            \"play\": 0\n        }\n        self.assertEqual(word_filter_counter(text, filter_words), expected_output)\n\n    def test_case2(self):\n        text = \"This is a completely different sentence.\"\n        filter_words = [\"I'll\", \"go\", \"to\", \"the\", \"school\", \"park\", \"play\"]\n        expected_output = {\n            \"I'll\": 0,\n            \"go\": 0,\n            \"to\": 0,\n            \"the\": 0,\n            \"school\": 0,\n            \"park\": 0,\n            \"play\": 0\n        }\n        self.assertEqual(word_filter_counter(text, filter_words), expected_output)\n\n    def test_case3(self):\n        text = \"I will not go to the school's park.\"\n        filter_words = [\"I\", \"will\", \"not\", \"go\", \"to\", \"the\", \"school's\", \"park\"]\n        expected_output = {\n            \"I\": 1,\n            \"will\": 1,\n            \"not\": 1,\n            \"go\": 1,\n            \"to\": 1,\n            \"the\": 1,\n            \"school's\": 1,\n            \"park\": 1,\n        }\n        self.assertEqual(word_filter_counter(text, filter_words), expected_output)\n", "prompt": "please write a python function , the function signature as below import re\nfrom collections import Counter\nfrom typing import List, Dict\n\n\ndef word_filter_counter(text: str, filter_words: List[str]) -> Dict[str, int]:\n    \"\"\"\n    Counts the occurrences of specified words in the given text.\n\n    This function filters the words from the text based on the provided list,\n    counts their occurrences, and returns a dictionary with the words in the\n    order they were provided.\n\n    Args:\n        text (str): The input text from which to count words.\n        filter_words (List[str]): A list of words to filter and count.\n\n    Returns:\n        Dict[str, int]: A dictionary with the count of each filter word in the text,\n                         maintaining the order from filter_words.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Counts the occurrences of specified words in the given text.\n *\n * This function filters the words from the text based on the provided list,\n * counts their occurrences, and returns an object with the words in the\n * order they were provided.\n *\n * @param {string} text - The input text from which to count words.\n * @param {Array<string>} filterWords - An array of words to filter and count.\n * @returns {Object} An object with the count of each filter word in the text,\n *                   maintaining the order from filterWords.\n */\nfunction wordFilterCounter(text, filterWords) {\n\n}", "test_code": "describe('TestWordFilterCounter', () => {\n    it('test_case1', () => {\n        const text = \"go to the school.go to the park.\";\n        const filterWords = [\"go\", \"to\", \"the\", \"school\", \"park\", \"play\"];\n        const expectedOutput = {\n            go: 2,\n            to: 2,\n            the: 2,\n            school: 1,\n            park: 1,\n            play: 0\n        };\n        expect(wordFilterCounter(text, filterWords)).toEqual(expectedOutput);\n    });\n\n    it('test_case2', () => {\n        const text = \"This is a completely different sentence.\";\n        const filterWords = [\"I'll\", \"go\", \"to\", \"the\", \"school\", \"park\", \"play\"];\n        const expectedOutput = {\n            \"I'll\": 0,\n            go: 0,\n            to: 0,\n            the: 0,\n            school: 0,\n            park: 0,\n            play: 0\n        };\n        expect(wordFilterCounter(text, filterWords)).toEqual(expectedOutput);\n    });\n\n    it('test_case3', () => {\n        const text = \"I will not go to the school's park.\";\n        const filterWords = [\"I\", \"will\", \"not\", \"go\", \"to\", \"the\", \"school's\", \"park\"];\n        const expectedOutput = {\n            I: 1,\n            will: 1,\n            not: 1,\n            go: 1,\n            to: 1,\n            the: 1,\n            \"school's\": 1,\n            park: 1\n        };\n        expect(wordFilterCounter(text, filterWords)).toEqual(expectedOutput);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Counts the occurrences of specified words in the given text.\n *\n * This function filters the words from the text based on the provided list,\n * counts their occurrences, and returns an object with the words in the\n * order they were provided.\n *\n * @param {string} text - The input text from which to count words.\n * @param {Array<string>} filterWords - An array of words to filter and count.\n * @returns {Object} An object with the count of each filter word in the text,\n *                   maintaining the order from filterWords.\n */\nfunction wordFilterCounter(text, filterWords) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Counts the occurrences of specified words in the given text.\n *\n * This function filters the words from the text based on the provided list,\n * counts their occurrences, and returns a dictionary with the words in the\n * order they were provided.\n *\n * @param text - The input text from which to count words.\n * @param filterWords - A list of words to filter and count.\n * @returns A dictionary with the count of each filter word in the text,\n *          maintaining the order from filterWords.\n */\nfunction wordFilterCounter(text: string, filterWords: string[]): Record<string, number> {\n\n}", "test_code": "describe('TestWordFilterCounter', () => {\n  it('should correctly count words in case 1', () => {\n    const text = \"go to the school. go to the park.\";\n    const filterWords = [\"go\", \"to\", \"the\", \"school\", \"park\", \"play\"];\n    const expectedOutput: Record<string, number> = {\n      \"go\": 2,\n      \"to\": 2,\n      \"the\": 2,\n      \"school\": 1,\n      \"park\": 1,\n      \"play\": 0\n    };\n    expect(wordFilterCounter(text, filterWords)).toEqual(expectedOutput);\n  });\n\n  it('should correctly count words in case 2', () => {\n    const text = \"This is a completely different sentence.\";\n    const filterWords = [\"I'll\", \"go\", \"to\", \"the\", \"school\", \"park\", \"play\"];\n    const expectedOutput: Record<string, number> = {\n      \"I'll\": 0,\n      \"go\": 0,\n      \"to\": 0,\n      \"the\": 0,\n      \"school\": 0,\n      \"park\": 0,\n      \"play\": 0\n    };\n    expect(wordFilterCounter(text, filterWords)).toEqual(expectedOutput);\n  });\n\n  it('should correctly count words in case 3', () => {\n    const text = \"I will not go to the school's park.\";\n    const filterWords = [\"I\", \"will\", \"not\", \"go\", \"to\", \"the\", \"school's\", \"park\"];\n    const expectedOutput: Record<string, number> = {\n      \"I\": 1,\n      \"will\": 1,\n      \"not\": 1,\n      \"go\": 1,\n      \"to\": 1,\n      \"the\": 1,\n      \"school's\": 1,\n      \"park\": 1,\n    };\n    expect(wordFilterCounter(text, filterWords)).toEqual(expectedOutput);\n  });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Counts the occurrences of specified words in the given text.\n *\n * This function filters the words from the text based on the provided list,\n * counts their occurrences, and returns a dictionary with the words in the\n * order they were provided.\n *\n * @param text - The input text from which to count words.\n * @param filterWords - A list of words to filter and count.\n * @returns A dictionary with the count of each filter word in the text,\n *          maintaining the order from filterWords.\n */\nfunction wordFilterCounter(text: string, filterWords: string[]): Record<string, number> {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Counts the occurrences of specified words in the given text.\n *\n * @param text The input text from which to count words.\n * @param filter_words A list of words to filter and count.\n * @return A dictionary with the count of each filter word in the text,\n *         maintaining the order from filter_words.\n */\nstd::unordered_map<std::string, int> word_filter_counter(const std::string& text, const std::vector<std::string>& filter_words) {}", "test_code": "TEST_CASE(\"Test Word Filter Counter\") {\n    SECTION(\"Test Case 1\") {\n        std::string text = \"go to the school.go to the park.\";\n        std::vector<std::string> filter_words = {\"go\", \"to\", \"the\", \"school\", \"park\", \"play\"};\n        std::unordered_map<std::string, int> expected_output = {\n            {\"go\", 2},\n            {\"to\", 2},\n            {\"the\", 2},\n            {\"school\", 1},\n            {\"park\", 1},\n            {\"play\", 0}\n        };\n\n        REQUIRE(word_filter_counter(text, filter_words) == expected_output);\n    }\n\n    SECTION(\"Test Case 2\") {\n        std::string text = \"This is a completely different sentence.\";\n        std::vector<std::string> filter_words = {\"I'll\", \"go\", \"to\", \"the\", \"school\", \"park\", \"play\"};\n        std::unordered_map<std::string, int> expected_output = {\n            {\"I'll\", 0},\n            {\"go\", 0},\n            {\"to\", 0},\n            {\"the\", 0},\n            {\"school\", 0},\n            {\"park\", 0},\n            {\"play\", 0}\n        };\n\n        REQUIRE(word_filter_counter(text, filter_words) == expected_output);\n    }\n\n    SECTION(\"Test Case 3\") {\n        std::string text = \"I will not go to the school's park.\";\n        std::vector<std::string> filter_words = {\"I\", \"will\", \"not\", \"go\", \"to\", \"the\", \"school's\", \"park\"};\n        std::unordered_map<std::string, int> expected_output = {\n            {\"I\", 1},\n            {\"will\", 1},\n            {\"not\", 1},\n            {\"go\", 1},\n            {\"to\", 1},\n            {\"the\", 1},\n            {\"school's\", 1},\n            {\"park\", 1}\n        };\n\n        REQUIRE(word_filter_counter(text, filter_words) == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Counts the occurrences of specified words in the given text.\n *\n * @param text The input text from which to count words.\n * @param filter_words A list of words to filter and count.\n * @return A dictionary with the count of each filter word in the text,\n *         maintaining the order from filter_words.\n */\nstd::unordered_map<std::string, int> word_filter_counter(const std::string& text, const std::vector<std::string>& filter_words) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Counts the occurrences of specified words in the given text.\n *\n * This function filters the words from the text based on the provided list,\n * counts their occurrences, and returns a map with the words in the\n * order they were provided.\n *\n * @param text The input text from which to count words.\n * @param filterWords A list of words to filter and count.\n * @return A map with the count of each filter word in the text,\n *         maintaining the order from filterWords.\n */\npublic static Map<String, Integer> wordFilterCounter(String text, List<String> filterWords) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Test cases for the wordFilterCounter method.\n */\npublic class Tester {\n\n    /**\n     * Test case 1: Verifies the correct count of specified words in the given text.\n     */\n    @Test\n    public void testCase1() {\n        String text = \"go to the school.go to the park.\";\n        List<String> filterWords = Arrays.asList(\"go\", \"to\", \"the\", \"school\", \"park\", \"play\");\n        Map<String, Integer> expectedOutput = new HashMap<>();\n        expectedOutput.put(\"go\", 2);\n        expectedOutput.put(\"to\", 2);\n        expectedOutput.put(\"the\", 2);\n        expectedOutput.put(\"school\", 1);\n        expectedOutput.put(\"park\", 1);\n        expectedOutput.put(\"play\", 0);\n\n        Map<String, Integer> actualOutput = wordFilterCounter(text, filterWords);\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    /**\n     * Test case 2: Verifies the correct count of specified words in the given text.\n     */\n    @Test\n    public void testCase2() {\n        String text = \"This is a completely different sentence.\";\n        List<String> filterWords = Arrays.asList(\"I'll\", \"go\", \"to\", \"the\", \"school\", \"park\", \"play\");\n        Map<String, Integer> expectedOutput = new HashMap<>();\n        expectedOutput.put(\"I'll\", 0);\n        expectedOutput.put(\"go\", 0);\n        expectedOutput.put(\"to\", 0);\n        expectedOutput.put(\"the\", 0);\n        expectedOutput.put(\"school\", 0);\n        expectedOutput.put(\"park\", 0);\n        expectedOutput.put(\"play\", 0);\n\n        Map<String, Integer> actualOutput = wordFilterCounter(text, filterWords);\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    /**\n     * Test case 3: Verifies the correct count of specified words in the given text.\n     */\n    @Test\n    public void testCase3() {\n        String text = \"I will not go to the school's park.\";\n        List<String> filterWords = Arrays.asList(\"I\", \"will\", \"not\", \"go\", \"to\", \"the\", \"school's\", \"park\");\n        Map<String, Integer> expectedOutput = new HashMap<>();\n        expectedOutput.put(\"I\", 1);\n        expectedOutput.put(\"will\", 1);\n        expectedOutput.put(\"not\", 1);\n        expectedOutput.put(\"go\", 1);\n        expectedOutput.put(\"to\", 1);\n        expectedOutput.put(\"the\", 1);\n        expectedOutput.put(\"school's\", 1);\n        expectedOutput.put(\"park\", 1);\n\n        Map<String, Integer> actualOutput = wordFilterCounter(text, filterWords);\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    // Method to be tested\n    private Map<String, Integer> wordFilterCounter(String text, List<String> filterWords) {\n        // Convert filter words to lowercase for case-insensitive comparison\n        Set<String> filterWordsSet = new HashSet<>();\n        for (String word : filterWords) {\n            filterWordsSet.add(word.toLowerCase());\n        }\n\n        // Find all words in the text using a regex pattern\n        Pattern pattern = Pattern.compile(\"\\\\b\\\\w+(?:'\\\\w+)?\\\\b\");\n        Matcher matcher = pattern.matcher(text.toLowerCase());\n        List<String> words = new ArrayList<>();\n        while (matcher.find()) {\n            words.add(matcher.group());\n        }\n\n        // Count occurrences of filtered words\n        Map<String, Integer> wordCounts = new HashMap<>();\n        for (String word : words) {\n            if (filterWordsSet.contains(word)) {\n                wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);\n            }\n        }\n\n        // Create an ordered output based on the original order of filterWords\n        Map<String, Integer> orderedOutput = new LinkedHashMap<>();\n        for (String word : filterWords) {\n            orderedOutput.put(word, wordCounts.getOrDefault(word.toLowerCase(), 0));\n        }\n\n        return orderedOutput;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Counts the occurrences of specified words in the given text.\n *\n * This function filters the words from the text based on the provided list,\n * counts their occurrences, and returns a map with the words in the\n * order they were provided.\n *\n * @param text The input text from which to count words.\n * @param filterWords A list of words to filter and count.\n * @return A map with the count of each filter word in the text,\n *         maintaining the order from filterWords.\n */\npublic static Map<String, Integer> wordFilterCounter(String text, List<String> filterWords) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 522, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "Rotate the point cloud around the Y axis by a given angle.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef rotate_point_cloud(point_cloud: np.ndarray, rotation_angle: float) -> np.ndarray:\n    \"\"\"\n    Rotate the point cloud around the Y axis by a given angle.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        rotation_angle (float): The angle (in radians) to rotate the point cloud.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the rotated point cloud.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestRotatePointCloud(unittest.TestCase):\n\n    def test_no_rotation(self):\n        \"\"\"Test when rotation angle is 0 (should return the same point cloud).\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        rotation_angle = 0\n        expected_output = point_cloud\n        np.testing.assert_array_almost_equal(rotate_point_cloud(point_cloud, rotation_angle), expected_output)\n\n    def test_180_degree_rotation(self):\n        \"\"\"Test rotation of 180 degrees (\u03c0 radians) around Y axis.\"\"\"\n        point_cloud = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]])\n        rotation_angle = np.pi  # 180 degrees\n        expected_output = np.array([[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]])  # [1,0,0] -> [-1,0,0]\n        np.testing.assert_array_almost_equal(rotate_point_cloud(point_cloud, rotation_angle), expected_output)\n\n    def test_full_rotation(self):\n        \"\"\"Test rotation of 360 degrees (2\u03c0 radians) around Y axis (should return same point cloud).\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        rotation_angle = 2 * np.pi  # 360 degrees\n        expected_output = point_cloud  # Should return the same point cloud\n        np.testing.assert_array_almost_equal(rotate_point_cloud(point_cloud, rotation_angle), expected_output)\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef rotate_point_cloud(point_cloud: np.ndarray, rotation_angle: float) -> np.ndarray:\n    \"\"\"\n    Rotate the point cloud around the Y axis by a given angle.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        rotation_angle (float): The angle (in radians) to rotate the point cloud.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the rotated point cloud.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Rotate the point cloud around the Y axis by a given angle.\n *\n * @param {Array<Array<number>>} pointCloud - A N x 3 array representing the 3D point cloud.\n * @param {number} rotationAngle - The angle (in radians) to rotate the point cloud.\n * @returns {Array<Array<number>>} - A N x 3 array of the rotated point cloud.\n */\nfunction rotatePointCloud(pointCloud, rotationAngle) {\n\n}", "test_code": "describe('TestRotatePointCloud', () => {\n    it('test_no_rotation', () => {\n        /**\n         * Test when rotation angle is 0 (should return the same point cloud).\n         */\n        const pointCloud = [[1.0, 2.0, 3.0]];\n        const rotationAngle = 0;\n        const expectedOutput = pointCloud;\n\n        const rotatedPointCloud = rotatePointCloud(pointCloud, rotationAngle);\n        expect(rotatedPointCloud).toEqual(expectedOutput);\n    });\n\n    it('test_180_degree_rotation', () => {\n        /**\n         * Test rotation of 180 degrees (\u03c0 radians) around Y axis.\n         */\n        const pointCloud = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]];\n        const rotationAngle = Math.PI; // 180 degrees\n        const expectedOutput = [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]; // [1,0,0] -> [-1,0,0]\n\n        const rotatedPointCloud = rotatePointCloud(pointCloud, rotationAngle);\n        expect(rotatedPointCloud).toEqual(expectedOutput);\n    });\n\n    it('test_full_rotation', () => {\n        /**\n         * Test rotation of 360 degrees (2\u03c0 radians) around Y axis (should return same point cloud).\n         */\n        const pointCloud = [[1.0, 2.0, 3.0]];\n        const rotationAngle = 2 * Math.PI; // 360 degrees\n        const expectedOutput = pointCloud; // Should return the same point cloud\n\n        const rotatedPointCloud = rotatePointCloud(pointCloud, rotationAngle);\n        expect(rotatedPointCloud).toEqual(expectedOutput);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Rotate the point cloud around the Y axis by a given angle.\n *\n * @param {Array<Array<number>>} pointCloud - A N x 3 array representing the 3D point cloud.\n * @param {number} rotationAngle - The angle (in radians) to rotate the point cloud.\n * @returns {Array<Array<number>>} - A N x 3 array of the rotated point cloud.\n */\nfunction rotatePointCloud(pointCloud, rotationAngle) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Rotate the point cloud around the Y axis by a given angle.\n *\n * @param pointCloud - An Nx3 matrix representing the 3D point cloud.\n * @param rotationAngle - The angle (in radians) to rotate the point cloud.\n * @returns An Nx3 matrix of the rotated point cloud.\n */\nfunction rotatePointCloud(pointCloud: number[][], rotationAngle: number): number[][] {\n\n}", "test_code": "describe('TestRotatePointCloud', () => {\n    /**\n     * Test when rotation angle is 0 (should return the same point cloud).\n     */\n    test('no rotation', () => {\n        const pointCloud = [[1.0, 2.0, 3.0]];\n        const rotationAngle = 0;\n        const expectedOutput = pointCloud;\n\n        expect(rotatePointCloud(pointCloud, rotationAngle)).toEqual(expectedOutput);\n    });\n\n    /**\n     * Test rotation of 180 degrees (\u03c0 radians) around Y axis.\n     */\n    test('180 degree rotation', () => {\n        const pointCloud = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]];\n        const rotationAngle = Math.PI; // 180 degrees\n        const expectedOutput = [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]; // [1,0,0] -> [-1,0,0]\n\n        expect(rotatePointCloud(pointCloud, rotationAngle)).toEqual(expectedOutput);\n    });\n\n    /**\n     * Test rotation of 360 degrees (2\u03c0 radians) around Y axis (should return same point cloud).\n     */\n    test('full rotation', () => {\n        const pointCloud = [[1.0, 2.0, 3.0]];\n        const rotationAngle = 2 * Math.PI; // 360 degrees\n        const expectedOutput = pointCloud; // Should return the same point cloud\n\n        expect(rotatePointCloud(pointCloud, rotationAngle)).toEqual(expectedOutput);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Rotate the point cloud around the Y axis by a given angle.\n *\n * @param pointCloud - An Nx3 matrix representing the 3D point cloud.\n * @param rotationAngle - The angle (in radians) to rotate the point cloud.\n * @returns An Nx3 matrix of the rotated point cloud.\n */\nfunction rotatePointCloud(pointCloud: number[][], rotationAngle: number): number[][] {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Rotate the point cloud around the Y axis by a given angle.\n *\n * @param pointCloud An N x 3 Eigen matrix representing the 3D point cloud.\n * @param rotationAngle The angle (in radians) to rotate the point cloud.\n *\n * @return An N x 3 Eigen matrix of the rotated point cloud.\n */\nEigen::MatrixXd rotate_point_cloud(const Eigen::MatrixXd& pointCloud, double rotationAngle) {\n\n}", "test_code": "TEST_CASE(\"Test Rotate Point Cloud\", \"[rotate_point_cloud]\") {\n    SECTION(\"Test no rotation\") {\n        Eigen::MatrixXd pointCloud(1, 3);\n        pointCloud << 1.0, 2.0, 3.0;\n        double rotationAngle = 0;\n        Eigen::MatrixXd expectedOutput(1, 3);\n        expectedOutput << 1.0, 2.0, 3.0;\n\n        Eigen::MatrixXd rotatedPointCloud = rotate_point_cloud(pointCloud, rotationAngle);\n\n        REQUIRE(rotatedPointCloud.isApprox(expectedOutput));\n    }\n\n    SECTION(\"Test 180-degree rotation\") {\n        Eigen::MatrixXd pointCloud(2, 3);\n        pointCloud << 1.0, 0.0, 0.0,\n                      0.0, 1.0, 0.0;\n        double rotationAngle = M_PI;  // 180 degrees\n        Eigen::MatrixXd expectedOutput(2, 3);\n        expectedOutput << -1.0, 0.0, 0.0,\n                           0.0, 1.0, 0.0;\n\n        Eigen::MatrixXd rotatedPointCloud = rotate_point_cloud(pointCloud, rotationAngle);\n\n        REQUIRE(rotatedPointCloud.isApprox(expectedOutput));\n    }\n\n    SECTION(\"Test full rotation\") {\n        Eigen::MatrixXd pointCloud(1, 3);\n        pointCloud << 1.0, 2.0, 3.0;\n        double rotationAngle = 2 * M_PI;  // 360 degrees\n        Eigen::MatrixXd expectedOutput(1, 3);\n        expectedOutput << 1.0, 2.0, 3.0;\n\n        Eigen::MatrixXd rotatedPointCloud = rotate_point_cloud(pointCloud, rotationAngle);\n\n        REQUIRE(rotatedPointCloud.isApprox(expectedOutput));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Rotate the point cloud around the Y axis by a given angle.\n *\n * @param pointCloud An N x 3 Eigen matrix representing the 3D point cloud.\n * @param rotationAngle The angle (in radians) to rotate the point cloud.\n *\n * @return An N x 3 Eigen matrix of the rotated point cloud.\n */\nEigen::MatrixXd rotate_point_cloud(const Eigen::MatrixXd& pointCloud, double rotationAngle) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Rotates the point cloud around the Y axis by a given angle.\n *\n * @param pointCloud A N x 3 matrix representing the 3D point cloud.\n * @param rotationAngle The angle (in radians) to rotate the point cloud.\n * @return A N x 3 matrix of the rotated point cloud.\n */\npublic static SimpleMatrix rotatePointCloud(SimpleMatrix pointCloud, double rotationAngle) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.ejml.simple.SimpleMatrix;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for rotating a 3D point cloud.\n */\npublic class Tester {\n\n    private static final double DELTA = 1e-6;\n\n    /**\n     * Test when the rotation angle is 0 (should return the same point cloud).\n     */\n    @Test\n    public void testNoRotation() {\n        SimpleMatrix pointCloud = new SimpleMatrix(new double[][]{{1.0, 2.0, 3.0}});\n        double rotationAngle = 0;\n        SimpleMatrix expectedOutput = pointCloud;\n\n        SimpleMatrix rotatedPointCloud = rotatePointCloud(pointCloud, rotationAngle);\n\n        assertEquals(expectedOutput, rotatedPointCloud, DELTA);\n    }\n\n    /**\n     * Test rotation of 180 degrees (\u03c0 radians) around the Y axis.\n     */\n    @Test\n    public void test180DegreeRotation() {\n        SimpleMatrix pointCloud = new SimpleMatrix(new double[][]{{1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}});\n        double rotationAngle = Math.PI; // 180 degrees\n        SimpleMatrix expectedOutput = new SimpleMatrix(new double[][]{{-1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}});\n\n        SimpleMatrix rotatedPointCloud = rotatePointCloud(pointCloud, rotationAngle);\n\n        assertEquals(expectedOutput, rotatedPointCloud, DELTA);\n    }\n\n    /**\n     * Test rotation of 360 degrees (2\u03c0 radians) around the Y axis (should return the same point cloud).\n     */\n    @Test\n    public void testFullRotation() {\n        SimpleMatrix pointCloud = new SimpleMatrix(new double[][]{{1.0, 2.0, 3.0}});\n        double rotationAngle = 2 * Math.PI; // 360 degrees\n        SimpleMatrix expectedOutput = pointCloud;\n\n        SimpleMatrix rotatedPointCloud = rotatePointCloud(pointCloud, rotationAngle);\n\n        assertEquals(expectedOutput, rotatedPointCloud, DELTA);\n    }\n\n    /**\n     * Helper method to rotate the point cloud.\n     *\n     * @param pointCloud A N x 3 matrix representing the 3D point cloud.\n     * @param rotationAngle The angle (in radians) to rotate the point cloud.\n     * @return A N x 3 matrix of the rotated point cloud.\n     */\n    private SimpleMatrix rotatePointCloud(SimpleMatrix pointCloud, double rotationAngle) {\n        // Create the rotation matrix for a rotation around the Y axis\n        SimpleMatrix rotationMatrix = new SimpleMatrix(3, 3);\n        rotationMatrix.set(0, 0, Math.cos(rotationAngle));\n        rotationMatrix.set(0, 2, Math.sin(rotationAngle));\n        rotationMatrix.set(2, 0, -Math.sin(rotationAngle));\n        rotationMatrix.set(2, 2, Math.cos(rotationAngle));\n        rotationMatrix.set(1, 1, 1);\n\n        // Rotate the point cloud by multiplying with the rotation matrix\n        SimpleMatrix rotatedPointCloud = pointCloud.mult(rotationMatrix);\n\n        return rotatedPointCloud;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Rotates the point cloud around the Y axis by a given angle.\n *\n * @param pointCloud A N x 3 matrix representing the 3D point cloud.\n * @param rotationAngle The angle (in radians) to rotate the point cloud.\n * @return A N x 3 matrix of the rotated point cloud.\n */\npublic static SimpleMatrix rotatePointCloud(SimpleMatrix pointCloud, double rotationAngle) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 523, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "Translate the point cloud by a given vector.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef translate_point_cloud(point_cloud: np.ndarray, translation_vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Translate the point cloud by a given vector.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        translation_vector (np.ndarray): A 1 x 3 numpy array or list representing the translation vector.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the translated point cloud.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestTranslatePointCloud(unittest.TestCase):\n\n    def test_simple_translation(self):\n        \"\"\"Test a simple translation of a single point.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        translation_vector = np.array([1.0, 1.0, 1.0])\n        expected_output = np.array([[2.0, 3.0, 4.0]])\n        np.testing.assert_array_almost_equal(translate_point_cloud(point_cloud, translation_vector), expected_output)\n\n    def test_multiple_points_translation(self):\n        \"\"\"Test translation of multiple points.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        translation_vector = np.array([1.0, 2.0, 3.0])\n        expected_output = np.array([[2.0, 4.0, 6.0], [5.0, 7.0, 9.0]])\n        np.testing.assert_array_almost_equal(translate_point_cloud(point_cloud, translation_vector), expected_output)\n\n    def test_zero_translation(self):\n        \"\"\"Test translation by a zero vector (should return the same point cloud).\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        translation_vector = np.array([0.0, 0.0, 0.0])\n        expected_output = point_cloud  # No change expected\n        np.testing.assert_array_almost_equal(translate_point_cloud(point_cloud, translation_vector), expected_output)\n\n    def test_negative_translation(self):\n        \"\"\"Test translation with negative values.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        translation_vector = np.array([-1.0, -2.0, -3.0])\n        expected_output = np.array([[0.0, 0.0, 0.0]])\n        np.testing.assert_array_almost_equal(translate_point_cloud(point_cloud, translation_vector), expected_output)", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef translate_point_cloud(point_cloud: np.ndarray, translation_vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Translate the point cloud by a given vector.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        translation_vector (np.ndarray): A 1 x 3 numpy array or list representing the translation vector.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the translated point cloud.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Translate the point cloud by a given vector.\n *\n * @param {Array<Array<number>>} pointCloud - An N x 3 array representing the 3D point cloud.\n * @param {Array<number>} translationVector - A 1 x 3 array representing the translation vector.\n * @returns {Array<Array<number>>} - An N x 3 array of the translated point cloud.\n */\nfunction translatePointCloud(pointCloud, translationVector) {\n\n}", "test_code": "describe('TestTranslatePointCloud', () => {\n    describe('test_simple_translation', () => {\n        it('should correctly translate a single point', () => {\n            const pointCloud = [[1.0, 2.0, 3.0]];\n            const translationVector = [1.0, 1.0, 1.0];\n            const expectedOutput = [[2.0, 3.0, 4.0]];\n            expect(translatePointCloud(pointCloud, translationVector)).toEqual(expectedOutput);\n        });\n    });\n\n    describe('test_multiple_points_translation', () => {\n        it('should correctly translate multiple points', () => {\n            const pointCloud = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];\n            const translationVector = [1.0, 2.0, 3.0];\n            const expectedOutput = [[2.0, 4.0, 6.0], [5.0, 7.0, 9.0]];\n            expect(translatePointCloud(pointCloud, translationVector)).toEqual(expectedOutput);\n        });\n    });\n\n    describe('test_zero_translation', () => {\n        it('should return the same point cloud when translating by a zero vector', () => {\n            const pointCloud = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];\n            const translationVector = [0.0, 0.0, 0.0];\n            const expectedOutput = pointCloud;\n            expect(translatePointCloud(pointCloud, translationVector)).toEqual(expectedOutput);\n        });\n    });\n\n    describe('test_negative_translation', () => {\n        it('should correctly translate with negative values', () => {\n            const pointCloud = [[1.0, 2.0, 3.0]];\n            const translationVector = [-1.0, -2.0, -3.0];\n            const expectedOutput = [[0.0, 0.0, 0.0]];\n            expect(translatePointCloud(pointCloud, translationVector)).toEqual(expectedOutput);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Translate the point cloud by a given vector.\n *\n * @param {Array<Array<number>>} pointCloud - An N x 3 array representing the 3D point cloud.\n * @param {Array<number>} translationVector - A 1 x 3 array representing the translation vector.\n * @returns {Array<Array<number>>} - An N x 3 array of the translated point cloud.\n */\nfunction translatePointCloud(pointCloud, translationVector) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Translate the point cloud by a given vector.\n *\n * @param pointCloud - A N x 3 Float32Array representing the 3D point cloud.\n * @param translationVector - A 1 x 3 Float32Array or array representing the translation vector.\n * @returns A N x 3 Float32Array of the translated point cloud.\n */\nfunction translatePointCloud(pointCloud: Float32Array, translationVector: Float32Array | number[]): Float32Array {\n\n}", "test_code": "describe('TestTranslatePointCloud', () => {\n    /**\n     * Test a simple translation of a single point.\n     */\n    it('testSimpleTranslation', () => {\n        const pointCloud = new Float32Array([1.0, 2.0, 3.0]);\n        const translationVector = new Float32Array([1.0, 1.0, 1.0]);\n        const expectedOutput = new Float32Array([2.0, 3.0, 4.0]);\n\n        const result = translatePointCloud(pointCloud, translationVector);\n        expect(result).toEqual(expectedOutput);\n    });\n\n    /**\n     * Test translation of multiple points.\n     */\n    it('testMultiplePointsTranslation', () => {\n        const pointCloud = new Float32Array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);\n        const translationVector = new Float32Array([1.0, 2.0, 3.0]);\n        const expectedOutput = new Float32Array([2.0, 4.0, 6.0, 5.0, 7.0, 9.0]);\n\n        const result = translatePointCloud(pointCloud, translationVector);\n        expect(result).toEqual(expectedOutput);\n    });\n\n    /**\n     * Test translation by a zero vector (should return the same point cloud).\n     */\n    it('testZeroTranslation', () => {\n        const pointCloud = new Float32Array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);\n        const translationVector = new Float32Array([0.0, 0.0, 0.0]);\n        const expectedOutput = new Float32Array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);\n\n        const result = translatePointCloud(pointCloud, translationVector);\n        expect(result).toEqual(expectedOutput);\n    });\n\n    /**\n     * Test translation with negative values.\n     */\n    it('testNegativeTranslation', () => {\n        const pointCloud = new Float32Array([1.0, 2.0, 3.0]);\n        const translationVector = new Float32Array([-1.0, -2.0, -3.0]);\n        const expectedOutput = new Float32Array([0.0, 0.0, 0.0]);\n\n        const result = translatePointCloud(pointCloud, translationVector);\n        expect(result).toEqual(expectedOutput);\n    });\n});\n", "prompt": "please write a typescript function , the function signature as below /**\n * Translate the point cloud by a given vector.\n *\n * @param pointCloud - A N x 3 Float32Array representing the 3D point cloud.\n * @param translationVector - A 1 x 3 Float32Array or array representing the translation vector.\n * @returns A N x 3 Float32Array of the translated point cloud.\n */\nfunction translatePointCloud(pointCloud: Float32Array, translationVector: Float32Array | number[]): Float32Array {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Translates the point cloud by a given vector.\n *\n * @param pointCloud An M x 3 Eigen matrix representing the 3D point cloud.\n * @type pointCloud Eigen::MatrixXd\n *\n * @param translationVector A 1 x 3 Eigen row vector representing the translation vector.\n * @type translationVector Eigen::RowVector3d\n *\n * @return An M x 3 Eigen matrix of the translated point cloud.\n * @rtype Eigen::MatrixXd\n */\nEigen::MatrixXd translate_point_cloud(const Eigen::MatrixXd& pointCloud, const Eigen::RowVector3d& translationVector){\n\n}\n\n", "test_code": "TEST_CASE(\"TestTranslatePointCloud\", \"[translatePointCloud]\") {\n    SECTION(\"test_simple_translation\") {\n        // Test a simple translation of a single point\n        Eigen::MatrixXd pointCloud(1, 3);\n        pointCloud << 1.0, 2.0, 3.0;\n        Eigen::RowVector3d translationVector(1.0, 1.0, 1.0);\n        Eigen::MatrixXd expectedOutput(1, 3);\n        expectedOutput << 2.0, 3.0, 4.0;\n\n        REQUIRE(translate_point_cloud(pointCloud, translationVector).isApprox(expectedOutput));\n    }\n\n    SECTION(\"test_multiple_points_translation\") {\n        // Test translation of multiple points\n        Eigen::MatrixXd pointCloud(2, 3);\n        pointCloud << 1.0, 2.0, 3.0,\n                      4.0, 5.0, 6.0;\n        Eigen::RowVector3d translationVector(1.0, 2.0, 3.0);\n        Eigen::MatrixXd expectedOutput(2, 3);\n        expectedOutput << 2.0, 4.0, 6.0,\n                          5.0, 7.0, 9.0;\n\n        REQUIRE(translate_point_cloud(pointCloud, translationVector).isApprox(expectedOutput));\n    }\n\n    SECTION(\"test_zero_translation\") {\n        // Test translation by a zero vector (should return the same point cloud)\n        Eigen::MatrixXd pointCloud(2, 3);\n        pointCloud << 1.0, 2.0, 3.0,\n                      4.0, 5.0, 6.0;\n        Eigen::RowVector3d translationVector(0.0, 0.0, 0.0);\n        Eigen::MatrixXd expectedOutput = pointCloud;  // No change expected\n\n        REQUIRE(translate_point_cloud(pointCloud, translationVector).isApprox(expectedOutput));\n    }\n\n    SECTION(\"test_negative_translation\") {\n        // Test translation with negative values\n        Eigen::MatrixXd pointCloud(1, 3);\n        pointCloud << 1.0, 2.0, 3.0;\n        Eigen::RowVector3d translationVector(-1.0, -2.0, -3.0);\n        Eigen::MatrixXd expectedOutput(1, 3);\n        expectedOutput << 0.0, 0.0, 0.0;\n\n        REQUIRE(translate_point_cloud(pointCloud, translationVector).isApprox(expectedOutput));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Translates the point cloud by a given vector.\n *\n * @param pointCloud An M x 3 Eigen matrix representing the 3D point cloud.\n * @type pointCloud Eigen::MatrixXd\n *\n * @param translationVector A 1 x 3 Eigen row vector representing the translation vector.\n * @type translationVector Eigen::RowVector3d\n *\n * @return An M x 3 Eigen matrix of the translated point cloud.\n * @rtype Eigen::MatrixXd\n */\nEigen::MatrixXd translate_point_cloud(const Eigen::MatrixXd& pointCloud, const Eigen::RowVector3d& translationVector){\n\n}\n\n", "addition_info": ""}, "java": {"code_signature": "/**\n * Translates the point cloud by a given vector.\n *\n * @param pointCloud An N x 3 INDArray representing the 3D point cloud.\n * @param translationVector A 1 x 3 double array representing the translation vector.\n * @return An N x 3 INDArray of the translated point cloud.\n */\npublic static INDArray translatePointCloud(INDArray pointCloud, double[] translationVector) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport org.nd4j.linalg.api.ndarray.INDArray;\nimport org.nd4j.linalg.factory.Nd4j;\n\npublic class Tester {\n\n    private static final double DELTA = 1e-15;\n\n    @Test\n    public void testSimpleTranslation() {\n        // Test a simple translation of a single point\n        INDArray pointCloud = Nd4j.create(new double[][]{{1.0, 2.0, 3.0}});\n        double[] translationVector = {1.0, 1.0, 1.0};\n        INDArray expectedOutput = Nd4j.create(new double[][]{{2.0, 3.0, 4.0}});\n\n        INDArray translatedPointCloud = Answer.translatePointCloud(pointCloud, translationVector);\n\n        assertEquals(expectedOutput, translatedPointCloud, DELTA);\n    }\n\n    @Test\n    public void testMultiplePointsTranslation() {\n        // Test translation of multiple points\n        INDArray pointCloud = Nd4j.create(new double[][]{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}});\n        double[] translationVector = {1.0, 2.0, 3.0};\n        INDArray expectedOutput = Nd4j.create(new double[][]{{2.0, 4.0, 6.0}, {5.0, 7.0, 9.0}});\n\n        INDArray translatedPointCloud = Answer.translatePointCloud(pointCloud, translationVector);\n\n        assertEquals(expectedOutput, translatedPointCloud, DELTA);\n    }\n\n    @Test\n    public void testZeroTranslation() {\n        // Test translation by a zero vector (should return the same point cloud)\n        INDArray pointCloud = Nd4j.create(new double[][]{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}});\n        double[] translationVector = {0.0, 0.0, 0.0};\n        INDArray expectedOutput = pointCloud;  // No change expected\n\n        INDArray translatedPointCloud = Answer.translatePointCloud(pointCloud, translationVector);\n\n        assertEquals(expectedOutput, translatedPointCloud, DELTA);\n    }\n\n    @Test\n    public void testNegativeTranslation() {\n        // Test translation with negative values\n        INDArray pointCloud = Nd4j.create(new double[][]{{1.0, 2.0, 3.0}});\n        double[] translationVector = {-1.0, -2.0, -3.0};\n        INDArray expectedOutput = Nd4j.create(new double[][]{{0.0, 0.0, 0.0}});\n\n        INDArray translatedPointCloud = Answer.translatePointCloud(pointCloud, translationVector);\n\n        assertEquals(expectedOutput, translatedPointCloud, DELTA);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Translates the point cloud by a given vector.\n *\n * @param pointCloud An N x 3 INDArray representing the 3D point cloud.\n * @param translationVector A 1 x 3 double array representing the translation vector.\n * @return An N x 3 INDArray of the translated point cloud.\n */\npublic static INDArray translatePointCloud(INDArray pointCloud, double[] translationVector) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 524, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "Scale the point cloud by a given factor.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\ndef scale_point_cloud(point_cloud: np.ndarray, scale_factor: float) -> np.ndarray:\n    \"\"\"\n    Scale the point cloud by a given factor.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        scale_factor ( float): A float representing the scaling factor.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the scaled point cloud.\n    \"\"\"", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestScalePointCloud(unittest.TestCase):\n\n    def test_simple_scaling(self):\n        \"\"\"Test scaling of a single point.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        scale_factor = 2.0\n        expected_output = np.array([[2.0, 4.0, 6.0]])\n        np.testing.assert_array_almost_equal(scale_point_cloud(point_cloud, scale_factor), expected_output)\n\n    def test_multiple_points_scaling(self):\n        \"\"\"Test scaling of multiple points.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        scale_factor = 0.5\n        expected_output = np.array([[0.5, 1.0, 1.5], [2.0, 2.5, 3.0]])\n        np.testing.assert_array_almost_equal(scale_point_cloud(point_cloud, scale_factor), expected_output)\n\n    def test_zero_scaling(self):\n        \"\"\"Test scaling by a factor of zero (should return a point cloud of zeros).\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        scale_factor = 0.0\n        expected_output = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n        np.testing.assert_array_almost_equal(scale_point_cloud(point_cloud, scale_factor), expected_output)\n\n    def test_negative_scaling(self):\n        \"\"\"Test scaling with a negative factor.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        scale_factor = -2.0\n        expected_output = np.array([[-2.0, -4.0, -6.0]])\n        np.testing.assert_array_almost_equal(scale_point_cloud(point_cloud, scale_factor), expected_output)\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\ndef scale_point_cloud(point_cloud: np.ndarray, scale_factor: float) -> np.ndarray:\n    \"\"\"\n    Scale the point cloud by a given factor.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        scale_factor ( float): A float representing the scaling factor.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the scaled point cloud.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Scale the point cloud by a given factor.\n *\n * @param {Array<Array<number>>} pointCloud - A 2D array representing the 3D point cloud with shape [N, 3].\n * @param {number} scaleFactor - A number representing the scaling factor.\n * @returns {Array<Array<number>>} - A 2D array of the scaled point cloud with shape [N, 3].\n */\nfunction scalePointCloud(pointCloud, scaleFactor) {\n\n}", "test_code": "describe('TestScalePointCloud', () => {\n    const scalePointCloud = require('./scalePointCloud'); // Import the scalePointCloud function\n\n    describe('test_simple_scaling', () => {\n        it('should scale a single point correctly', () => {\n            const pointCloud = [[1.0, 2.0, 3.0]];\n            const scaleFactor = 2.0;\n            const expectedOutput = [[2.0, 4.0, 6.0]];\n            expect(scalePointCloud(pointCloud, scaleFactor)).toEqual(expectedOutput);\n        });\n    });\n\n    describe('test_multiple_points_scaling', () => {\n        it('should scale multiple points correctly', () => {\n            const pointCloud = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];\n            const scaleFactor = 0.5;\n            const expectedOutput = [[0.5, 1.0, 1.5], [2.0, 2.5, 3.0]];\n            expect(scalePointCloud(pointCloud, scaleFactor)).toEqual(expectedOutput);\n        });\n    });\n\n    describe('test_zero_scaling', () => {\n        it('should scale by a factor of zero', () => {\n            const pointCloud = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];\n            const scaleFactor = 0.0;\n            const expectedOutput = [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]];\n            expect(scalePointCloud(pointCloud, scaleFactor)).toEqual(expectedOutput);\n        });\n    });\n\n    describe('test_negative_scaling', () => {\n        it('should scale with a negative factor', () => {\n            const pointCloud = [[1.0, 2.0, 3.0]];\n            const scaleFactor = -2.0;\n            const expectedOutput = [[-2.0, -4.0, -6.0]];\n            expect(scalePointCloud(pointCloud, scaleFactor)).toEqual(expectedOutput);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Scale the point cloud by a given factor.\n *\n * @param {Array<Array<number>>} pointCloud - A 2D array representing the 3D point cloud with shape [N, 3].\n * @param {number} scaleFactor - A number representing the scaling factor.\n * @returns {Array<Array<number>>} - A 2D array of the scaled point cloud with shape [N, 3].\n */\nfunction scalePointCloud(pointCloud, scaleFactor) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Scale the point cloud by a given factor.\n *\n * @param pointCloud - A N x 3 matrix representing the 3D point cloud.\n * @param scaleFactor - A number representing the scaling factor.\n * @returns A N x 3 matrix of the scaled point cloud.\n */\nfunction scalePointCloud(pointCloud: Matrix, scaleFactor: number): Matrix {\n\n}", "test_code": "describe('TestScalePointCloud', () => {\n    it('test simple scaling', () => {\n        const pointCloud = Matrix([[1.0, 2.0, 3.0]]);\n        const scaleFactor = 2.0;\n        const expectedOutput = Matrix([[2.0, 4.0, 6.0]]);\n        expect(scalePointCloud(pointCloud, scaleFactor)).toEqual(expectedOutput);\n    });\n\n    it('test multiple points scaling', () => {\n        const pointCloud = Matrix([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]);\n        const scaleFactor = 0.5;\n        const expectedOutput = Matrix([[0.5, 1.0, 1.5], [2.0, 2.5, 3.0]]);\n        expect(scalePointCloud(pointCloud, scaleFactor)).toEqual(expectedOutput);\n    });\n\n    it('test zero scaling', () => {\n        const pointCloud = Matrix([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]);\n        const scaleFactor = 0.0;\n        const expectedOutput = Matrix([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]);\n        expect(scalePointCloud(pointCloud, scaleFactor)).toEqual(expectedOutput);\n    });\n\n    it('test negative scaling', () => {\n        const pointCloud = Matrix([[1.0, 2.0, 3.0]]);\n        const scaleFactor = -2.0;\n        const expectedOutput = Matrix([[-2.0, -4.0, -6.0]]);\n        expect(scalePointCloud(pointCloud, scaleFactor)).toEqual(expectedOutput);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Scale the point cloud by a given factor.\n *\n * @param pointCloud - A N x 3 matrix representing the 3D point cloud.\n * @param scaleFactor - A number representing the scaling factor.\n * @returns A N x 3 matrix of the scaled point cloud.\n */\nfunction scalePointCloud(pointCloud: Matrix, scaleFactor: number): Matrix {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Scale the point cloud by a given factor.\n *\n * @param pointCloud A N x 3 Eigen matrix representing the 3D point cloud.\n * @param scaleFactor A double representing the scaling factor.\n * @return An N x 3 Eigen matrix of the scaled point cloud.\n */\nEigen::MatrixXd scale_point_cloud(const Eigen::MatrixXd& pointCloud, double scaleFactor) {\n\n}", "test_code": "#include <catch2/catch_test_macros.hpp>\n#include <Eigen/Dense>\n#include <stdexcept>\n\nTEST_CASE(\"Test scaling of point clouds\", \"[scalePointCloud]\") {\n    SECTION(\"Test simple scaling\") {\n        Eigen::MatrixXd pointCloud(1, 3);\n        pointCloud << 1.0, 2.0, 3.0;\n        double scale_factor = 2.0;\n        Eigen::MatrixXd expected_output(1, 3);\n        expected_output << 2.0, 4.0, 6.0;\n\n        REQUIRE((scale_point_cloud(pointCloud, scale_factor)).isApprox(expected_output));\n    }\n\n    SECTION(\"Test multiple points scaling\") {\n        Eigen::MatrixXd pointCloud(2, 3);\n        pointCloud << 1.0, 2.0, 3.0,\n                      4.0, 5.0, 6.0;\n        double scale_factor = 0.5;\n        Eigen::MatrixXd expected_output(2, 3);\n        expected_output << 0.5, 1.0, 1.5,\n                           2.0, 2.5, 3.0;\n\n        REQUIRE((scale_point_cloud(pointCloud, scale_factor)).isApprox(expected_output));\n    }\n\n    SECTION(\"Test zero scaling\") {\n        Eigen::MatrixXd pointCloud(2, 3);\n        pointCloud << 1.0, 2.0, 3.0,\n                      4.0, 5.0, 6.0;\n        double scale_factor = 0.0;\n        Eigen::MatrixXd expected_output(2, 3);\n        expected_output << 0.0, 0.0, 0.0,\n                           0.0, 0.0, 0.0;\n\n        REQUIRE((scale_point_cloud(pointCloud, scale_factor)).isApprox(expected_output));\n    }\n\n    SECTION(\"Test negative scaling\") {\n        Eigen::MatrixXd pointCloud(1, 3);\n        pointCloud << 1.0, 2.0, 3.0;\n        double scale_factor = -2.0;\n        Eigen::MatrixXd expected_output(1, 3);\n        expected_output << -2.0, -4.0, -6.0;\n\n        REQUIRE((scale_point_cloud(pointCloud, scale_factor)).isApprox(expected_output));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Scale the point cloud by a given factor.\n *\n * @param pointCloud A N x 3 Eigen matrix representing the 3D point cloud.\n * @param scaleFactor A double representing the scaling factor.\n * @return An N x 3 Eigen matrix of the scaled point cloud.\n */\nEigen::MatrixXd scale_point_cloud(const Eigen::MatrixXd& pointCloud, double scaleFactor) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Scales the point cloud by a given factor.\n *\n * @param pointCloud A 2D array representing the 3D point cloud with shape (N, 3).\n * @param scaleFactor A double representing the scaling factor.\n * @return A 2D array of the scaled point cloud with shape (N, 3).\n * @throws IllegalArgumentException If the point cloud is not a 2D array with shape (N, 3).\n */\npublic static double[][] scalePointCloud(double[][] pointCloud, double scaleFactor) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\n\n/**\n * Test class for scaling a 3D point cloud.\n */\npublic class Tester {\n\n    /**\n     * Tests scaling of a single point.\n     */\n    @Test\n    public void testSimpleScaling() {\n        double[][] pointCloud = {{1.0, 2.0, 3.0}};\n        double scaleFactor = 2.0;\n        double[][] expectedOutput = {{2.0, 4.0, 6.0}};\n\n        double[][] scaledPointCloud = scalePointCloud(pointCloud, scaleFactor);\n\n        assertArrayEquals(expectedOutput, scaledPointCloud, 0.001);\n    }\n\n    /**\n     * Tests scaling of multiple points.\n     */\n    @Test\n    public void testMultiplePointsScaling() {\n        double[][] pointCloud = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}};\n        double scaleFactor = 0.5;\n        double[][] expectedOutput = {{0.5, 1.0, 1.5}, {2.0, 2.5, 3.0}};\n\n        double[][] scaledPointCloud = scalePointCloud(pointCloud, scaleFactor);\n\n        assertArrayEquals(expectedOutput, scaledPointCloud, 0.001);\n    }\n\n    /**\n     * Tests scaling by a factor of zero (should return a point cloud of zeros).\n     */\n    @Test\n    public void testZeroScaling() {\n        double[][] pointCloud = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}};\n        double scaleFactor = 0.0;\n        double[][] expectedOutput = {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}};\n\n        double[][] scaledPointCloud = scalePointCloud(pointCloud, scaleFactor);\n\n        assertArrayEquals(expectedOutput, scaledPointCloud, 0.001);\n    }\n\n    /**\n     * Tests scaling with a negative factor.\n     */\n    @Test\n    public void testNegativeScaling() {\n        double[][] pointCloud = {{1.0, 2.0, 3.0}};\n        double scaleFactor = -2.0;\n        double[][] expectedOutput = {{-2.0, -4.0, -6.0}};\n\n        double[][] scaledPointCloud = scalePointCloud(pointCloud, scaleFactor);\n\n        assertArrayEquals(expectedOutput, scaledPointCloud, 0.001);\n    }\n\n    // Utility method to scale the point cloud\n    private double[][] scalePointCloud(double[][] pointCloud, double scaleFactor) {\n        // Ensure pointCloud is a 2D array\n        if (pointCloud == null || pointCloud.length == 0 || pointCloud[0].length != 3) {\n            throw new IllegalArgumentException(\"pointCloud must be a 2D array with shape (N, 3)\");\n        }\n\n        // Scale the point cloud by the given factor\n        double[][] scaledPointCloud = new double[pointCloud.length][3];\n        for (int i = 0; i < pointCloud.length; i++) {\n            scaledPointCloud[i] = Arrays.stream(pointCloud[i])\n                                        .map(x -> x * scaleFactor)\n                                        .toArray();\n        }\n\n        return scaledPointCloud;\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Scales the point cloud by a given factor.\n *\n * @param pointCloud A 2D array representing the 3D point cloud with shape (N, 3).\n * @param scaleFactor A double representing the scaling factor.\n * @return A 2D array of the scaled point cloud with shape (N, 3).\n * @throws IllegalArgumentException If the point cloud is not a 2D array with shape (N, 3).\n */\npublic static double[][] scalePointCloud(double[][] pointCloud, double scaleFactor) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 525, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "Flip the point cloud across a specified axis.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef flip_point_cloud(point_cloud: np.ndarray, axis: int) -> np.ndarray:\n    \"\"\"\n    Flip the point cloud across a specified axis.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        axis (int): An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the flipped point cloud.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestFlipPointCloud(unittest.TestCase):\n\n    def test_flip_x_axis(self):\n        \"\"\"Test flipping the point cloud across the x-axis.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        expected_output = np.array([[1.0, -2.0, 3.0], [4.0, -5.0, 6.0]])\n        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=1), expected_output)\n\n    def test_flip_y_axis(self):\n        \"\"\"Test flipping the point cloud across the y-axis.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        expected_output = np.array([[-1.0, 2.0, 3.0], [-4.0, 5.0, 6.0]])\n        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=0), expected_output)\n\n    def test_flip_z_axis(self):\n        \"\"\"Test flipping the point cloud across the z-axis.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        expected_output = np.array([[1.0, 2.0, -3.0], [4.0, 5.0, -6.0]])\n        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=2), expected_output)\n\n    def test_invalid_axis(self):\n        \"\"\"Test handling of an invalid axis.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        self.assertRaises(Exception)\n\n\n    def test_empty_point_cloud(self):\n        \"\"\"Test flipping an empty point cloud.\"\"\"\n        point_cloud = np.array([]).reshape(0, 3)  # Empty point cloud with shape (0, 3)\n        expected_output = np.array([]).reshape(0, 3)  # Expect the output to be the same\n        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=0), expected_output)", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef flip_point_cloud(point_cloud: np.ndarray, axis: int) -> np.ndarray:\n    \"\"\"\n    Flip the point cloud across a specified axis.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        axis (int): An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the flipped point cloud.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Flip the point cloud across a specified axis.\n *\n * @param {Array<Array<number>>} pointCloud - A N x 3 array representing the 3D point cloud.\n * @param {number} axis - An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n * @returns {Array<Array<number>>} A N x 3 array of the flipped point cloud.\n */\nfunction flipPointCloud(pointCloud, axis) {\n\n}", "test_code": "describe('TestFlipPointCloud', () => {\n    describe('test_flip_x_axis', () => {\n        it('should flip the point cloud across the x-axis', () => {\n            const pointCloud = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];\n            const expectedOutput = [[1.0, -2.0, 3.0], [4.0, -5.0, 6.0]];\n            expect(flipPointCloud(pointCloud, 1)).toEqual(expectedOutput);\n        });\n    });\n\n    describe('test_flip_y_axis', () => {\n        it('should flip the point cloud across the y-axis', () => {\n            const pointCloud = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];\n            const expectedOutput = [[-1.0, 2.0, 3.0], [-4.0, 5.0, 6.0]];\n            expect(flipPointCloud(pointCloud, 0)).toEqual(expectedOutput);\n        });\n    });\n\n    describe('test_flip_z_axis', () => {\n        it('should flip the point cloud across the z-axis', () => {\n            const pointCloud = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];\n            const expectedOutput = [[1.0, 2.0, -3.0], [4.0, 5.0, -6.0]];\n            expect(flipPointCloud(pointCloud, 2)).toEqual(expectedOutput);\n        });\n    });\n\n    describe('test_invalid_axis', () => {\n        it('should throw an error when an invalid axis is provided', () => {\n            const pointCloud = [[1.0, 2.0, 3.0]];\n            expect(() => flipPointCloud(pointCloud, 3)).toThrow('Axis must be 0 (x-axis), 1 (y-axis), or 2 (z-axis).');\n        });\n    });\n\n    describe('test_empty_point_cloud', () => {\n        it('should handle an empty point cloud correctly', () => {\n            const pointCloud = [];\n            const expectedOutput = [];\n            expect(flipPointCloud(pointCloud, 0)).toEqual(expectedOutput);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Flip the point cloud across a specified axis.\n *\n * @param {Array<Array<number>>} pointCloud - A N x 3 array representing the 3D point cloud.\n * @param {number} axis - An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n * @returns {Array<Array<number>>} A N x 3 array of the flipped point cloud.\n */\nfunction flipPointCloud(pointCloud, axis) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Flip the point cloud across a specified axis.\n *\n * @param pointCloud - A N x 3 tensor representing the 3D point cloud.\n * @param axis - An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n * @returns A N x 3 tensor of the flipped point cloud.\n */\nfunction flipPointCloud(pointCloud: tf.Tensor, axis: number): tf.Tensor {\n\n}", "test_code": "describe('TestFlipPointCloud', () => {\n    it('test_flip_x_axis', () => {\n        /** Test flipping the point cloud across the x-axis. */\n        const pointCloud = tf.tensor2d([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]);\n        const expectedOutput = tf.tensor2d([[1.0, -2.0, 3.0], [4.0, -5.0, 6.0]]);\n        const flippedPointCloud = flipPointCloud(pointCloud, 1);\n        expect(flippedPointCloud).toEqual(expectedOutput);\n    });\n\n    it('test_flip_y_axis', () => {\n        /** Test flipping the point cloud across the y-axis. */\n        const pointCloud = tf.tensor2d([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]);\n        const expectedOutput = tf.tensor2d([[-1.0, 2.0, 3.0], [-4.0, 5.0, 6.0]]);\n        const flippedPointCloud = flipPointCloud(pointCloud, 0);\n        expect(flippedPointCloud).toEqual(expectedOutput);\n    });\n\n    it('test_flip_z_axis', () => {\n        /** Test flipping the point cloud across the z-axis. */\n        const pointCloud = tf.tensor2d([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]);\n        const expectedOutput = tf.tensor2d([[1.0, 2.0, -3.0], [4.0, 5.0, -6.0]]);\n        const flippedPointCloud = flipPointCloud(pointCloud, 2);\n        expect(flippedPointCloud).toEqual(expectedOutput);\n    });\n\n    it('test_invalid_axis', () => {\n        /** Test handling of an invalid axis. */\n        const pointCloud = tf.tensor2d([[1.0, 2.0, 3.0]]);\n        expect(() => flipPointCloud(pointCloud, 3)).toThrowError(/Axis must be 0 \\(x-axis\\), 1 \\(y-axis\\), or 2 \\(z-axis\\)/);\n    });\n\n    it('test_empty_point_cloud', () => {\n        /** Test flipping an empty point cloud. */\n        const pointCloud = tf.tensor2d([], [0, 3]); // Empty point cloud with shape (0, 3)\n        const expectedOutput = tf.tensor2d([], [0, 3]); // Expect the output to be the same\n        const flippedPointCloud = flipPointCloud(pointCloud, 0);\n        expect(flippedPointCloud).toEqual(expectedOutput);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Flip the point cloud across a specified axis.\n *\n * @param pointCloud - A N x 3 tensor representing the 3D point cloud.\n * @param axis - An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n * @returns A N x 3 tensor of the flipped point cloud.\n */\nfunction flipPointCloud(pointCloud: tf.Tensor, axis: number): tf.Tensor {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Flip the point cloud across a specified axis.\n *\n * @param pointCloud A N x 3 matrix representing the 3D point cloud.\n * @param axis An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n * @return A N x 3 matrix of the flipped point cloud.\n */\nMatrixXd flip_point_cloud(const MatrixXd& pointCloud, int axis) {\n\n}", "test_code": "#include <catch2/catch_test_macros.hpp>\n#include <Eigen/Dense>\n#include <stdexcept>\n\nusing Eigen::MatrixXd;\nTEST_CASE(\"TestFlipPointCloud\", \"[FlipPointCloud]\") {\n    SECTION(\"test_flip_x_axis\") {\n        // Test flipping the point cloud across the x-axis.\n        MatrixXd pointCloud(2, 3);\n        pointCloud << 1.0, 2.0, 3.0,\n                      4.0, 5.0, 6.0;\n\n        MatrixXd expectedOutput(2, 3);\n        expectedOutput << 1.0, -2.0, 3.0,\n                         4.0, -5.0, 6.0;\n\n        MatrixXd flippedPointCloud = flip_point_cloud(pointCloud, 1);\n        REQUIRE(flippedPointCloud.isApprox(expectedOutput));\n    }\n\n    SECTION(\"test_flip_y_axis\") {\n        // Test flipping the point cloud across the y-axis.\n        MatrixXd pointCloud(2, 3);\n        pointCloud << 1.0, 2.0, 3.0,\n                      4.0, 5.0, 6.0;\n\n        MatrixXd expectedOutput(2, 3);\n        expectedOutput << -1.0, 2.0, 3.0,\n                          -4.0, 5.0, 6.0;\n\n        MatrixXd flippedPointCloud = flip_point_cloud(pointCloud, 0);\n        REQUIRE(flippedPointCloud.isApprox(expectedOutput));\n    }\n\n    SECTION(\"test_flip_z_axis\") {\n        // Test flipping the point cloud across the z-axis.\n        MatrixXd pointCloud(2, 3);\n        pointCloud << 1.0, 2.0, 3.0,\n                      4.0, 5.0, 6.0;\n\n        MatrixXd expectedOutput(2, 3);\n        expectedOutput << 1.0, 2.0, -3.0,\n                         4.0, 5.0, -6.0;\n\n        MatrixXd flippedPointCloud = flip_point_cloud(pointCloud, 2);\n        REQUIRE(flippedPointCloud.isApprox(expectedOutput));\n    }\n\n    SECTION(\"test_invalid_axis\") {\n        // Test handling of an invalid axis.\n        MatrixXd pointCloud(1, 3);\n        pointCloud << 1.0, 2.0, 3.0;\n\n        REQUIRE_THROWS_AS(flip_point_cloud(pointCloud, 3), std::invalid_argument);\n    }\n\n    SECTION(\"test_empty_point_cloud\") {\n        // Test flipping an empty point cloud.\n        MatrixXd pointCloud(0, 3);\n        MatrixXd expectedOutput(0, 3);\n\n        MatrixXd flippedPointCloud = flip_point_cloud(pointCloud, 0);\n        REQUIRE(flippedPointCloud.rows() == expectedOutput.rows());\n        REQUIRE(flippedPointCloud.cols() == expectedOutput.cols());\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Flip the point cloud across a specified axis.\n *\n * @param pointCloud A N x 3 matrix representing the 3D point cloud.\n * @param axis An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n * @return A N x 3 matrix of the flipped point cloud.\n */\nMatrixXd flip_point_cloud(const MatrixXd& pointCloud, int axis) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Flips the point cloud across a specified axis.\n *\n * @param pointCloud A N x 3 array representing the 3D point cloud.\n * @param axis       An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n * @return A N x 3 array of the flipped point cloud.\n */\npublic static double[][] flipPointCloud(double[][] pointCloud, int axis) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertThrows;\n\n/**\n * Test class for verifying the correctness of the flipPointCloud method.\n */\npublic class Tester {\n\n    /**\n     * Test flipping the point cloud across the x-axis.\n     */\n    @Test\n    public void testFlipXAxis() {\n        double[][] pointCloud = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}};\n        double[][] expectedOutput = {{1.0, -2.0, 3.0}, {4.0, -5.0, 6.0}};\n        assertArrayEquals(expectedOutput, flipPointCloud(pointCloud, 1), 1e-6);\n    }\n\n    /**\n     * Test flipping the point cloud across the y-axis.\n     */\n    @Test\n    public void testFlipYAxis() {\n        double[][] pointCloud = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}};\n        double[][] expectedOutput = {{-1.0, 2.0, 3.0}, {-4.0, 5.0, 6.0}};\n        assertArrayEquals(expectedOutput, flipPointCloud(pointCloud, 0), 1e-6);\n    }\n\n    /**\n     * Test flipping the point cloud across the z-axis.\n     */\n    @Test\n    public void testFlipZAxis() {\n        double[][] pointCloud = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}};\n        double[][] expectedOutput = {{1.0, 2.0, -3.0}, {4.0, 5.0, -6.0}};\n        assertArrayEquals(expectedOutput, flipPointCloud(pointCloud, 2), 1e-6);\n    }\n\n    /**\n     * Test handling of an invalid axis.\n     */\n    @Test\n    public void testInvalidAxis() {\n        double[][] pointCloud = {{1.0, 2.0, 3.0}};\n        assertThrows(IllegalArgumentException.class, () -> flipPointCloud(pointCloud, 3));\n    }\n\n    /**\n     * Test flipping an empty point cloud.\n     */\n    @Test\n    public void testEmptyPointCloud() {\n        double[][] pointCloud = new double[0][3]; // Empty point cloud with shape (0, 3)\n        double[][] expectedOutput = new double[0][3]; // Expect the output to be the same\n        assertArrayEquals(expectedOutput, flipPointCloud(pointCloud, 0), 1e-6);\n    }\n}\n", "prompt": "please write a java function , the function signature as below /**\n * Flips the point cloud across a specified axis.\n *\n * @param pointCloud A N x 3 array representing the 3D point cloud.\n * @param axis       An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n * @return A N x 3 array of the flipped point cloud.\n */\npublic static double[][] flipPointCloud(double[][] pointCloud, int axis) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 526, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Find the minimum window substring in `s` that contains all characters of `t`.", "language_version_list": {"python": {"code_signature": "from collections import Counter\n\n\ndef min_window(s: str, t: str) -> str:\n    \"\"\"\n    Find the minimum window substring in `s` that contains all characters of `t`.\n\n    Args:\n        s (str): The input string in which to search for the substring.\n        t (str): The target string whose characters must be included in the substring.\n\n    Returns:\n        str: The minimum window substring of `s` that contains all characters of `t`.Returns an empty string if no such substring exists.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestMinWindow(unittest.TestCase):\n\n    def test_basic_case(self):\n        \"\"\"Test with a normal case where the minimum window exists.\"\"\"\n        s = \"ADOBECODEBANC\"\n        t = \"ABC\"\n        expected_output = \"BANC\"\n        self.assertEqual(min_window(s, t), expected_output)\n\n    def test_no_window_exists(self):\n        \"\"\"Test where no window can satisfy the condition.\"\"\"\n        s = \"A\"\n        t = \"AA\"\n        expected_output = \"\"\n        self.assertEqual(min_window(s, t), expected_output)\n\n    def test_empty_string(self):\n        \"\"\"Test with an empty input string s.\"\"\"\n        s = \"\"\n        t = \"ABC\"\n        expected_output = \"\"\n        self.assertEqual(min_window(s, t), expected_output)\n\n\n    def test_multiple_valid_windows(self):\n        \"\"\"Test with multiple valid windows to ensure the smallest one is returned.\"\"\"\n        s = \"AA\"\n        t = \"AA\"\n        expected_output = \"AA\"\n        self.assertEqual(min_window(s, t), expected_output)\n", "prompt": "please write a python function , the function signature as below from collections import Counter\n\n\ndef min_window(s: str, t: str) -> str:\n    \"\"\"\n    Find the minimum window substring in `s` that contains all characters of `t`.\n\n    Args:\n        s (str): The input string in which to search for the substring.\n        t (str): The target string whose characters must be included in the substring.\n\n    Returns:\n        str: The minimum window substring of `s` that contains all characters of `t`.Returns an empty string if no such substring exists.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Find the minimum window substring in `s` that contains all characters of `t`.\n *\n * @param {string} s - The input string in which to search for the substring.\n * @param {string} t - The target string whose characters must be included in the substring.\n * @returns {string} The minimum window substring of `s` that contains all characters of `t`.\n *                   Returns an empty string if no such substring exists.\n */\nfunction minWindow(s, t) {\n\n}", "test_code": "describe('TestMinWindow', () => {\n    it('test basic case', () => {\n        /** Test with a normal case where the minimum window exists. */\n        const s = \"ADOBECODEBANC\";\n        const t = \"ABC\";\n        const expectedOutput = \"BANC\";\n        expect(minWindow(s, t)).toEqual(expectedOutput);\n    });\n\n    it('test no window exists', () => {\n        /** Test where no window can satisfy the condition. */\n        const s = \"A\";\n        const t = \"AA\";\n        const expectedOutput = \"\";\n        expect(minWindow(s, t)).toEqual(expectedOutput);\n    });\n\n    it('test empty string', () => {\n        /** Test with an empty input string s. */\n        const s = \"\";\n        const t = \"ABC\";\n        const expectedOutput = \"\";\n        expect(minWindow(s, t)).toEqual(expectedOutput);\n    });\n\n    it('test multiple valid windows', () => {\n        /** Test with multiple valid windows to ensure the smallest one is returned. */\n        const s = \"AA\";\n        const t = \"AA\";\n        const expectedOutput = \"AA\";\n        expect(minWindow(s, t)).toEqual(expectedOutput);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Find the minimum window substring in `s` that contains all characters of `t`.\n *\n * @param {string} s - The input string in which to search for the substring.\n * @param {string} t - The target string whose characters must be included in the substring.\n * @returns {string} The minimum window substring of `s` that contains all characters of `t`.\n *                   Returns an empty string if no such substring exists.\n */\nfunction minWindow(s, t) {\n\n}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Find the minimum window substring in `s` that contains all characters of `t`.\n *\n * @param s - The input string in which to search for the substring.\n * @param t - The target string whose characters must be included in the substring.\n * @returns The minimum window substring of `s` that contains all characters of `t`.\n *          Returns an empty string if no such substring exists.\n */\nfunction minWindow(s: string, t: string): string {\n\n}", "test_code": "describe('minWindow', () => {\n    it('test with a normal case where the minimum window exists', () => {\n        const s = \"ADOBECODEBANC\";\n        const t = \"ABC\";\n        const expectedOutput = \"BANC\";\n        expect(minWindow(s, t)).toEqual(expectedOutput);\n    });\n\n    it('test where no window can satisfy the condition', () => {\n        const s = \"A\";\n        const t = \"AA\";\n        const expectedOutput = \"\";\n        expect(minWindow(s, t)).toEqual(expectedOutput);\n    });\n\n    it('test with an empty input string s', () => {\n        const s = \"\";\n        const t = \"ABC\";\n        const expectedOutput = \"\";\n        expect(minWindow(s, t)).toEqual(expectedOutput);\n    });\n\n    it('test with multiple valid windows to ensure the smallest one is returned', () => {\n        const s = \"AA\";\n        const t = \"AA\";\n        const expectedOutput = \"AA\";\n        expect(minWindow(s, t)).toEqual(expectedOutput);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Find the minimum window substring in `s` that contains all characters of `t`.\n *\n * @param s - The input string in which to search for the substring.\n * @param t - The target string whose characters must be included in the substring.\n * @returns The minimum window substring of `s` that contains all characters of `t`.\n *          Returns an empty string if no such substring exists.\n */\nfunction minWindow(s: string, t: string): string {\n\n}", "addition_info": ""}, "c&cpp": {"code_signature": "/*\n *   Find the minimum window substring in `s` that contains all characters of `t`.\n *   Args:\n *       s: The input string in which to search for the substring.\n *       t: The target string whose characters must be included in the substring.\n *   Returns:\n *       The minimum window substring of `s` that contains all characters of `t`.\n *       Returns an empty string if no such substring exists.\n */\nstd::string min_window(const std::string& s, const std::string& t) {\n\n}", "test_code": "// Test class using Catch2\nTEST_CASE(\"Test cases for min_window\", \"[min_window]\") {\n    SECTION(\"Test with a normal case where the minimum window exists\") {\n        std::string s = \"ADOBECODEBANC\";\n        std::string t = \"ABC\";\n        std::string expected_output = \"BANC\";\n        REQUIRE(min_window(s, t) == expected_output);\n    }\n\n    SECTION(\"Test where no window can satisfy the condition\") {\n        std::string s = \"A\";\n        std::string t = \"AA\";\n        std::string expected_output = \"\";\n        REQUIRE(min_window(s, t) == expected_output);\n    }\n\n    SECTION(\"Test with an empty input string s\") {\n        std::string s = \"\";\n        std::string t = \"ABC\";\n        std::string expected_output = \"\";\n        REQUIRE(min_window(s, t) == expected_output);\n    }\n\n    SECTION(\"Test with multiple valid windows to ensure the smallest one is returned\") {\n        std::string s = \"AA\";\n        std::string t = \"AA\";\n        std::string expected_output = \"AA\";\n        REQUIRE(min_window(s, t) == expected_output);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /*\n *   Find the minimum window substring in `s` that contains all characters of `t`.\n *   Args:\n *       s: The input string in which to search for the substring.\n *       t: The target string whose characters must be included in the substring.\n *   Returns:\n *       The minimum window substring of `s` that contains all characters of `t`.\n *       Returns an empty string if no such substring exists.\n */\nstd::string min_window(const std::string& s, const std::string& t) {\n\n}", "addition_info": ""}, "java": {"code_signature": "/**\n * Finds the minimum window substring in `s` that contains all characters of `t`.\n *\n * @param s The input string in which to search for the substring.\n * @param t The target string whose characters must be included in the substring.\n * @return The minimum window substring of `s` that contains all characters of `t`.\n *         Returns an empty string if no such substring exists.\n */\npublic static String minWindow(String s, String t) {\n\n}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n\n    /**\n     * Tests a basic case where the minimum window exists.\n     */\n    @Test\n    public void testBasicCase() {\n        String s = \"ADOBECODEBANC\";\n        String t = \"ABC\";\n        String expectedOutput = \"BANC\";\n        assertEquals(expectedOutput, Answer.minWindow(s, t));\n    }\n\n    /**\n     * Tests a case where no window can satisfy the condition.\n     */\n    @Test\n    public void testNoWindowExists() {\n        String s = \"A\";\n        String t = \"AA\";\n        String expectedOutput = \"\";\n        assertEquals(expectedOutput, Answer.minWindow(s, t));\n    }\n\n    /**\n     * Tests a case with an empty input string s.\n     */\n    @Test\n    public void testEmptyString() {\n        String s = \"\";\n        String t = \"ABC\";\n        String expectedOutput = \"\";\n        assertEquals(expectedOutput, Answer.minWindow(s, t));\n    }\n\n    /**\n     * Tests a case with multiple valid windows to ensure the smallest one is returned.\n     */\n    @Test\n    public void testMultipleValidWindows() {\n        String s = \"AA\";\n        String t = \"AA\";\n        String expectedOutput = \"AA\";\n        assertEquals(expectedOutput, Answer.minWindow(s, t));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Finds the minimum window substring in `s` that contains all characters of `t`.\n *\n * @param s The input string in which to search for the substring.\n * @param t The target string whose characters must be included in the substring.\n * @return The minimum window substring of `s` that contains all characters of `t`.\n *         Returns an empty string if no such substring exists.\n */\npublic static String minWindow(String s, String t) {\n\n},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 527, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Check if a point is inside a triangle defined by three vertices.", "language_version_list": {"python": {"code_signature": "def is_point_inside_triangle(px: float, py: float, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float):\n    \"\"\"\n    Check if a point is inside a triangle defined by three vertices.\n\n    Args:\n        px (float): The x-coordinate of the point to check.\n        py (float): The y-coordinate of the point to check.\n        x1 (float): The x-coordinate of the first vertex of the triangle.\n        y1 (float): The y-coordinate of the first vertex of the triangle.\n        x2 (float): The x-coordinate of the second vertex of the triangle.\n        y2 (float): The y-coordinate of the second vertex of the triangle.\n        x3 (float): The x-coordinate of the third vertex of the triangle.\n        y3 (float): The y-coordinate of the third vertex of the triangle.\n\n    Returns:\n        bool: True if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); False otherwise.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestPointInsideTriangle(unittest.TestCase):\n\n    def test_point_inside_triangle(self):\n        \"\"\"Test case where point is inside the triangle.\"\"\"\n        triangle_vertices = (0, 0, 5, 0, 2.5, 5)\n        point = (2.5, 2)  # Inside the triangle\n        self.assertTrue(is_point_inside_triangle(point[0], point[1], *triangle_vertices))\n\n    def test_point_on_edge(self):\n        \"\"\"Test case where point is on the edge of the triangle.\"\"\"\n        triangle_vertices = (0, 0, 5, 0, 2.5, 5)\n        point = (2.5, 0)  # On the edge of the triangle\n        self.assertTrue(is_point_inside_triangle(point[0], point[1], *triangle_vertices))\n\n    def test_point_outside_triangle(self):\n        \"\"\"Test case where point is outside the triangle.\"\"\"\n        triangle_vertices = (0, 0, 5, 0, 2.5, 5)\n        point = (6, 2)  # Outside the triangle\n        self.assertFalse(is_point_inside_triangle(point[0], point[1], *triangle_vertices))\n\n    def test_point_at_vertex(self):\n        \"\"\"Test case where point is at one of the triangle's vertices.\"\"\"\n        triangle_vertices = (0, 0, 5, 0, 2.5, 5)\n        point = (0, 0)  # At the vertex of the triangle\n        self.assertTrue(is_point_inside_triangle(point[0], point[1], *triangle_vertices))", "prompt": "please write a python function , the function signature as below def is_point_inside_triangle(px: float, py: float, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float):\n    \"\"\"\n    Check if a point is inside a triangle defined by three vertices.\n\n    Args:\n        px (float): The x-coordinate of the point to check.\n        py (float): The y-coordinate of the point to check.\n        x1 (float): The x-coordinate of the first vertex of the triangle.\n        y1 (float): The y-coordinate of the first vertex of the triangle.\n        x2 (float): The x-coordinate of the second vertex of the triangle.\n        y2 (float): The y-coordinate of the second vertex of the triangle.\n        x3 (float): The x-coordinate of the third vertex of the triangle.\n        y3 (float): The y-coordinate of the third vertex of the triangle.\n\n    Returns:\n        bool: True if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); False otherwise.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Check if a point is inside a triangle defined by three vertices.\n *\n * @param {number} px - The x-coordinate of the point to check.\n * @param {number} py - The y-coordinate of the point to check.\n * @param {number} x1 - The x-coordinate of the first vertex of the triangle.\n * @param {number} y1 - The y-coordinate of the first vertex of the triangle.\n * @param {number} x2 - The x-coordinate of the second vertex of the triangle.\n * @param {number} y2 - The y-coordinate of the second vertex of the triangle.\n * @param {number} x3 - The x-coordinate of the third vertex of the triangle.\n * @param {number} y3 - The y-coordinate of the third vertex of the triangle.\n * @returns {boolean} True if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); False otherwise.\n */\nfunction isPointInsideTriangle(px, py, x1, y1, x2, y2, x3, y3) {}", "test_code": "describe('TestPointInsideTriangle', () => {\n    it('should return true when the point is inside the triangle', () => {\n        const triangleVertices = [0, 0, 5, 0, 2.5, 5];\n        const point = [2.5, 2];  // Inside the triangle\n        expect(isPointInsideTriangle(point[0], point[1], ...triangleVertices)).toBe(true);\n    });\n\n    it('should return true when the point is on the edge of the triangle', () => {\n        const triangleVertices = [0, 0, 5, 0, 2.5, 5];\n        const point = [2.5, 0];  // On the edge of the triangle\n        expect(isPointInsideTriangle(point[0], point[1], ...triangleVertices)).toBe(true);\n    });\n\n    it('should return false when the point is outside the triangle', () => {\n        const triangleVertices = [0, 0, 5, 0, 2.5, 5];\n        const point = [6, 2];  // Outside the triangle\n        expect(isPointInsideTriangle(point[0], point[1], ...triangleVertices)).toBe(false);\n    });\n\n    it('should return true when the point is at one of the triangle\\'s vertices', () => {\n        const triangleVertices = [0, 0, 5, 0, 2.5, 5];\n        const point = [0, 0];  // At the vertex of the triangle\n        expect(isPointInsideTriangle(point[0], point[1], ...triangleVertices)).toBe(true);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Check if a point is inside a triangle defined by three vertices.\n *\n * @param {number} px - The x-coordinate of the point to check.\n * @param {number} py - The y-coordinate of the point to check.\n * @param {number} x1 - The x-coordinate of the first vertex of the triangle.\n * @param {number} y1 - The y-coordinate of the first vertex of the triangle.\n * @param {number} x2 - The x-coordinate of the second vertex of the triangle.\n * @param {number} y2 - The y-coordinate of the second vertex of the triangle.\n * @param {number} x3 - The x-coordinate of the third vertex of the triangle.\n * @param {number} y3 - The y-coordinate of the third vertex of the triangle.\n * @returns {boolean} True if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); False otherwise.\n */\nfunction isPointInsideTriangle(px, py, x1, y1, x2, y2, x3, y3) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Checks if a point is inside a triangle defined by three vertices.\n * \n * @param px - The x-coordinate of the point to check.\n * @param py - The y-coordinate of the point to check.\n * @param x1 - The x-coordinate of the first vertex of the triangle.\n * @param y1 - The y-coordinate of the first vertex of the triangle.\n * @param x2 - The x-coordinate of the second vertex of the triangle.\n * @param y2 - The y-coordinate of the second vertex of the triangle.\n * @param x3 - The x-coordinate of the third vertex of the triangle.\n * @param y3 - The y-coordinate of the third vertex of the triangle.\n * @returns True if the point (px, py) is inside or on the edge of the triangle; False otherwise.\n */\nfunction isPointInsideTriangle(px: number, py: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): boolean {}", "test_code": "describe('TestPointInsideTriangle', () => {\n    it('test_point_inside_triangle', () => {\n        // Test case where point is inside the triangle.\n        const triangleVertices = [0, 0, 5, 0, 2.5, 5];\n        const point = [2.5, 2];  // Inside the triangle\n        expect(isPointInsideTriangle(point[0], point[1], ...triangleVertices)).toBe(true);\n    });\n\n    it('test_point_on_edge', () => {\n        // Test case where point is on the edge of the triangle.\n        const triangleVertices = [0, 0, 5, 0, 2.5, 5];\n        const point = [2.5, 0];  // On the edge of the triangle\n        expect(isPointInsideTriangle(point[0], point[1], ...triangleVertices)).toBe(true);\n    });\n\n    it('test_point_outside_triangle', () => {\n        // Test case where point is outside the triangle.\n        const triangleVertices = [0, 0, 5, 0, 2.5, 5];\n        const point = [6, 2];  // Outside the triangle\n        expect(isPointInsideTriangle(point[0], point[1], ...triangleVertices)).toBe(false);\n    });\n\n    it('test_point_at_vertex', () => {\n        // Test case where point is at one of the triangle's vertices.\n        const triangleVertices = [0, 0, 5, 0, 2.5, 5];\n        const point = [0, 0];  // At the vertex of the triangle\n        expect(isPointInsideTriangle(point[0], point[1], ...triangleVertices)).toBe(true);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Checks if a point is inside a triangle defined by three vertices.\n * \n * @param px - The x-coordinate of the point to check.\n * @param py - The y-coordinate of the point to check.\n * @param x1 - The x-coordinate of the first vertex of the triangle.\n * @param y1 - The y-coordinate of the first vertex of the triangle.\n * @param x2 - The x-coordinate of the second vertex of the triangle.\n * @param y2 - The y-coordinate of the second vertex of the triangle.\n * @param x3 - The x-coordinate of the third vertex of the triangle.\n * @param y3 - The y-coordinate of the third vertex of the triangle.\n * @returns True if the point (px, py) is inside or on the edge of the triangle; False otherwise.\n */\nfunction isPointInsideTriangle(px: number, py: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Check if a point is inside a triangle defined by three vertices.\n *\n * @param px The x-coordinate of the point to check.\n * @param py The y-coordinate of the point to check.\n * @param x1 The x-coordinate of the first vertex of the triangle.\n * @param y1 The y-coordinate of the first vertex of the triangle.\n * @param x2 The x-coordinate of the second vertex of the triangle.\n * @param y2 The y-coordinate of the second vertex of the triangle.\n * @param x3 The x-coordinate of the third vertex of the triangle.\n * @param y3 The y-coordinate of the third vertex of the triangle.\n * @return True if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); False otherwise.\n */\nbool is_point_inside_triangle(double px, double py, double x1, double y1, double x2, double y2, double x3, double y3) {}", "test_code": "TEST_CASE(\"Test cases for point inside triangle\", \"[point_inside_triangle]\") {\n    SECTION(\"Test case where point is inside the triangle\") {\n        double triangle_vertices[] = {0, 0, 5, 0, 2.5, 5};\n        double point[] = {2.5, 2};  // Inside the triangle\n        REQUIRE(is_point_inside_triangle(point[0], point[1], triangle_vertices[0], triangle_vertices[1], triangle_vertices[2], triangle_vertices[3], triangle_vertices[4], triangle_vertices[5]));\n    }\n\n    SECTION(\"Test case where point is on the edge of the triangle\") {\n        double triangle_vertices[] = {0, 0, 5, 0, 2.5, 5};\n        double point[] = {2.5, 0};  // On the edge of the triangle\n        REQUIRE(is_point_inside_triangle(point[0], point[1], triangle_vertices[0], triangle_vertices[1], triangle_vertices[2], triangle_vertices[3], triangle_vertices[4], triangle_vertices[5]));\n    }\n\n    SECTION(\"Test case where point is outside the triangle\") {\n        double triangle_vertices[] = {0, 0, 5, 0, 2.5, 5};\n        double point[] = {6, 2};  // Outside the triangle\n        REQUIRE_FALSE(is_point_inside_triangle(point[0], point[1], triangle_vertices[0], triangle_vertices[1], triangle_vertices[2], triangle_vertices[3], triangle_vertices[4], triangle_vertices[5]));\n    }\n\n    SECTION(\"Test case where point is at one of the triangle's vertices\") {\n        double triangle_vertices[] = {0, 0, 5, 0, 2.5, 5};\n        double point[] = {0, 0};  // At the vertex of the triangle\n        REQUIRE(is_point_inside_triangle(point[0], point[1], triangle_vertices[0], triangle_vertices[1], triangle_vertices[2], triangle_vertices[3], triangle_vertices[4], triangle_vertices[5]));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Check if a point is inside a triangle defined by three vertices.\n *\n * @param px The x-coordinate of the point to check.\n * @param py The y-coordinate of the point to check.\n * @param x1 The x-coordinate of the first vertex of the triangle.\n * @param y1 The y-coordinate of the first vertex of the triangle.\n * @param x2 The x-coordinate of the second vertex of the triangle.\n * @param y2 The y-coordinate of the second vertex of the triangle.\n * @param x3 The x-coordinate of the third vertex of the triangle.\n * @param y3 The y-coordinate of the third vertex of the triangle.\n * @return True if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); False otherwise.\n */\nbool is_point_inside_triangle(double px, double py, double x1, double y1, double x2, double y2, double x3, double y3) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Checks if a point is inside a triangle defined by three vertices.\n *\n * @param px The x-coordinate of the point to check.\n * @param py The y-coordinate of the point to check.\n * @param x1 The x-coordinate of the first vertex of the triangle.\n * @param y1 The y-coordinate of the first vertex of the triangle.\n * @param x2 The x-coordinate of the second vertex of the triangle.\n * @param y2 The y-coordinate of the second vertex of the triangle.\n * @param x3 The x-coordinate of the third vertex of the triangle.\n * @param y3 The y-coordinate of the third vertex of the triangle.\n * @return true if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); false otherwise.\n */\npublic static boolean isPointInsideTriangle(double px, double py, double x1, double y1, double x2, double y2, double x3, double y3) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Test class for checking if a point is inside a triangle.\n */\npublic class Tester {\n\n    /**\n     * Test case where the point is inside the triangle.\n     */\n    @Test\n    public void testPointInsideTriangle() {\n        double[] triangleVertices = {0, 0, 5, 0, 2.5, 5};\n        double px = 2.5;\n        double py = 2;  // Inside the triangle\n\n        assertTrue(isPointInsideTriangle(px, py, triangleVertices[0], triangleVertices[1],\n                                         triangleVertices[2], triangleVertices[3],\n                                         triangleVertices[4], triangleVertices[5]));\n    }\n\n    /**\n     * Test case where the point is on the edge of the triangle.\n     */\n    @Test\n    public void testPointOnEdge() {\n        double[] triangleVertices = {0, 0, 5, 0, 2.5, 5};\n        double px = 2.5;\n        double py = 0;  // On the edge of the triangle\n\n        assertTrue(isPointInsideTriangle(px, py, triangleVertices[0], triangleVertices[1],\n                                         triangleVertices[2], triangleVertices[3],\n                                         triangleVertices[4], triangleVertices[5]));\n    }\n\n    /**\n     * Test case where the point is outside the triangle.\n     */\n    @Test\n    public void testPointOutsideTriangle() {\n        double[] triangleVertices = {0, 0, 5, 0, 2.5, 5};\n        double px = 6;\n        double py = 2;  // Outside the triangle\n\n        assertFalse(isPointInsideTriangle(px, py, triangleVertices[0], triangleVertices[1],\n                                          triangleVertices[2], triangleVertices[3],\n                                          triangleVertices[4], triangleVertices[5]));\n    }\n\n    /**\n     * Test case where the point is at one of the triangle's vertices.\n     */\n    @Test\n    public void testPointAtVertex() {\n        double[] triangleVertices = {0, 0, 5, 0, 2.5, 5};\n        double px = 0;\n        double py = 0;  // At the vertex of the triangle\n\n        assertTrue(isPointInsideTriangle(px, py, triangleVertices[0], triangleVertices[1],\n                                         triangleVertices[2], triangleVertices[3],\n                                         triangleVertices[4], triangleVertices[5]));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Checks if a point is inside a triangle defined by three vertices.\n *\n * @param px The x-coordinate of the point to check.\n * @param py The y-coordinate of the point to check.\n * @param x1 The x-coordinate of the first vertex of the triangle.\n * @param y1 The y-coordinate of the first vertex of the triangle.\n * @param x2 The x-coordinate of the second vertex of the triangle.\n * @param y2 The y-coordinate of the second vertex of the triangle.\n * @param x3 The x-coordinate of the third vertex of the triangle.\n * @param y3 The y-coordinate of the third vertex of the triangle.\n * @return true if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); false otherwise.\n */\npublic static boolean isPointInsideTriangle(double px, double py, double x1, double y1, double x2, double y2, double x3, double y3) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 546, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "    Reads tab-separated values (TSV) from standard input and returns a list of rows.\n\n    Each row is represented as a list of strings. If rows have unequal lengths,\n    they are padded with empty strings to ensure all rows have the same length.", "language_version_list": {"python": {"code_signature": "import csv\nimport sys\n\n\ndef read_tsv_data_from_std_input():\n    \"\"\"\n    Reads tab-separated values (TSV) from standard input and returns a list of rows.\n\n    Each row is represented as a list of strings. If rows have unequal lengths,\n    they are padded with empty strings to ensure all rows have the same length.\n\n    Returns:\n        list: A list of lists, where each inner list represents a row of data.\n    \"\"\"\n", "test_code": "import unittest\nimport sys\nimport io\nfrom unittest.mock import patch\n\n\nclass TestReadTsvFromStdin(unittest.TestCase):\n\n    @patch('sys.stdin', new_callable=io.StringIO)\n    def test_basic_tsv_input(self, mock_stdin):\n        mock_stdin.write(\"col1\\tcol2\\tcol3\\nval1\\tval2\\tval3\\n\")\n        mock_stdin.seek(0)  # Move to the start of the StringIO object\n        expected_output = [['col1', 'col2', 'col3'], ['val1', 'val2', 'val3']]\n        self.assertEqual(read_tsv_data_from_std_input(), expected_output)\n\n\n    @patch('sys.stdin', new_callable=io.StringIO)\n    def test_single_column(self, mock_stdin):\n        mock_stdin.write(\"col1\\nval1\\nval2\\n\")\n        mock_stdin.seek(0)\n        expected_output = [['col1'], ['val1'], ['val2']]\n        self.assertEqual(read_tsv_data_from_std_input(), expected_output)\n        @patch('sys.stdin', new_callable=io.StringIO)\n    \n\n    @patch('sys.stdin', new_callable=io.StringIO)\n    def test_all_rows_empty(self, mock_stdin):\n        mock_stdin.write(\"col1\\tcol2\\tcol3\\n\\n\\n\")\n        mock_stdin.seek(0)\n        expected_output = [['col1', 'col2', 'col3'], ['', '', '']]\n        self.assertEqual(read_tsv_data_from_std_input(), expected_output)\n\n    @patch('sys.stdin', new_callable=io.StringIO)\n    def test_multiple_consecutive_tabs(self, mock_stdin):\n        mock_stdin.write(\"col1\\t\\tcol2\\tcol3\\nval1\\t\\tval2\\tval3\\n\")\n        mock_stdin.seek(0)\n        expected_output = [['col1', '', 'col2', 'col3'], ['val1', '', 'val2', 'val3']]\n        self.assertEqual(read_tsv_data_from_std_input(), expected_output)\n    @patch('sys.stdin', new_callable=io.StringIO)\n    def test_missing_columns(self, mock_stdin):\n        mock_stdin.write(\"col1\\tcol2\\tcol3\\nval1\\tval2\\nval1.1\\tval2.1\\tval3.1\\n\")\n        mock_stdin.seek(0)\n        expected_output = [['col1', 'col2', 'col3'], ['val1', 'val2'], ['val1.1', 'val2.1', 'val3.1']]\n        self.assertEqual(read_tsv_data_from_std_input(), expected_output)", "prompt": "please write a python function , the function signature as below import csv\nimport sys\n\n\ndef read_tsv_data_from_std_input():\n    \"\"\"\n    Reads tab-separated values (TSV) from standard input and returns a list of rows.\n\n    Each row is represented as a list of strings. If rows have unequal lengths,\n    they are padded with empty strings to ensure all rows have the same length.\n\n    Returns:\n        list: A list of lists, where each inner list represents a row of data.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Reads tab-separated values (TSV) from standard input and returns a list of rows.\n * \n * Each row is represented as an array of strings. If rows have unequal lengths,\n * they are padded with empty strings to ensure all rows have the same length.\n * \n * @returns {Array<Array<string>>} A list of arrays, where each inner array represents a row of data.\n */\nfunction readTSVFromStdin() {}", "test_code": "describe('TestReadTsvFromStdin', () => {\n    beforeEach(() => {\n        // Reset the standard input stream before each test\n        process.stdin.setEncoding('utf8');\n    });\n\n    test('test basic TSV input', () => {\n        const mockStdin = 'col1\\tcol2\\tcol3\\nval1\\tval2\\tval3\\n';\n        process.stdin.emit('data', mockStdin);\n        process.stdin.emit('end');\n\n        const expectedOutput = [['col1', 'col2', 'col3'], ['val1', 'val2', 'val3']];\n        expect(readTSVFromStdin()).toEqual(expectedOutput);\n    });\n\n    test('test single column', () => {\n        const mockStdin = 'col1\\nval1\\nval2\\n';\n        process.stdin.emit('data', mockStdin);\n        process.stdin.emit('end');\n\n        const expectedOutput = [['col1'], ['val1'], ['val2']];\n        expect(readTSVFromStdin()).toEqual(expectedOutput);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Reads tab-separated values (TSV) from standard input and returns a list of rows.\n * \n * Each row is represented as an array of strings. If rows have unequal lengths,\n * they are padded with empty strings to ensure all rows have the same length.\n * \n * @returns {Array<Array<string>>} A list of arrays, where each inner array represents a row of data.\n */\nfunction readTSVFromStdin() {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Reads tab-separated values (TSV) from standard input and returns a list of rows.\n * \n * Each row is represented as an array of strings. If rows have unequal lengths,\n * they are padded with empty strings to ensure all rows have the same length.\n * \n * @returns {Promise<string[][]>} A promise that resolves to a list of lists, where each inner list represents a row of data.\n */\nasync function readTsvFromStdin(): Promise<string[][]> {}", "test_code": "describe('TestReadTsvFromStdin', () => {\n    it('test basic TSV input', async () => {\n      const mockStdin = 'col1\\tcol2\\tcol3\\nval1\\tval2\\tval3\\n';\n      process.stdin.setEncoding('utf8');\n      process.stdin.unshift(mockStdin);\n  \n      const expectedOutput = [['col1', 'col2', 'col3'], ['val1', 'val2', 'val3']];\n      const result = await readTsvFromStdin();\n  \n      expect(result).toEqual(expectedOutput);\n    });\n  \n    it('test single column', async () => {\n      const mockStdin = 'col1\\nval1\\nval2\\n';\n      process.stdin.setEncoding('utf8');\n      process.stdin.unshift(mockStdin);\n  \n      const expectedOutput = [['col1'], ['val1'], ['val2']];\n      const result = await readTsvFromStdin();\n  \n      expect(result).toEqual(expectedOutput);\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Reads tab-separated values (TSV) from standard input and returns a list of rows.\n * \n * Each row is represented as an array of strings. If rows have unequal lengths,\n * they are padded with empty strings to ensure all rows have the same length.\n * \n * @returns {Promise<string[][]>} A promise that resolves to a list of lists, where each inner list represents a row of data.\n */\nasync function readTsvFromStdin(): Promise<string[][]> {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Reads tab-separated values (TSV) from standard input and returns a list of rows.\n *\n * Each row is represented as a vector of strings. If rows have unequal lengths,\n * they are padded with empty strings to ensure all rows have the same length.\n *\n * @return A vector of vectors, where each inner vector represents a row of data.\n */\nstd::vector<std::vector<std::string>> read_tsv_from_stdin() {}", "test_code": "TEST_CASE(\"Test basic TSV input\") {\n    // Redirect standard input to a stringstream\n    std::istringstream input_stream(\"col1\\tcol2\\tcol3\\nval1\\tval2\\tval3\\n\");\n    std::streambuf* prev_cin = std::cin.rdbuf(input_stream.rdbuf());\n\n    // Expected output\n    const std::vector<std::vector<std::string>> expected_output = {\n        {\"col1\", \"col2\", \"col3\"},\n        {\"val1\", \"val2\", \"val3\"}\n    };\n\n    // Call the function\n    const auto result = read_tsv_from_stdin();\n\n    // Restore the original standard input\n    std::cin.rdbuf(prev_cin);\n\n    // Check the result\n    REQUIRE(result == expected_output);\n}\n\nTEST_CASE(\"Test single column\") {\n    // Redirect standard input to a stringstream\n    std::istringstream input_stream(\"col1\\nval1\\nval2\\n\");\n    std::streambuf* prev_cin = std::cin.rdbuf(input_stream.rdbuf());\n\n    // Expected output\n    const std::vector<std::vector<std::string>> expected_output = {\n        {\"col1\"},\n        {\"val1\"},\n        {\"val2\"}\n    };\n\n    // Call the function\n    const auto result = read_tsv_from_stdin();\n\n    // Restore the original standard input\n    std::cin.rdbuf(prev_cin);\n\n    // Check the result\n    REQUIRE(result == expected_output);\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Reads tab-separated values (TSV) from standard input and returns a list of rows.\n *\n * Each row is represented as a vector of strings. If rows have unequal lengths,\n * they are padded with empty strings to ensure all rows have the same length.\n *\n * @return A vector of vectors, where each inner vector represents a row of data.\n */\nstd::vector<std::vector<std::string>> read_tsv_from_stdin() {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Reads TSV data from standard input and pads rows to ensure they have the same length.\n *\n * @return A list of lists containing the padded data.\n */\npublic static List<List<String>> readTSVFromStdin() {}", "test_code": "package org.real.temp;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.when;\n\n@ExtendWith(MockitoExtension.class)\npublic class Tester {\n\n    @Mock\n    private InputStream mockStdin;\n\n    @BeforeEach\n    void setUp() {\n        // Set up the mock standard input stream\n        System.setIn(mockStdin);\n    }\n\n    @Test\n    void testBasicTsvInput() {\n        String input = \"col1\\tcol2\\tcol3\\nval1\\tval2\\tval3\\n\";\n        when(mockStdin.readAllBytes()).thenReturn(input.getBytes());\n\n        List<List<String>> expectedOutput = List.of(\n            List.of(\"col1\", \"col2\", \"col3\"),\n            List.of(\"val1\", \"val2\", \"val3\")\n        );\n\n        List<List<String>> actualOutput = readTsvFromStdin();\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    @Test\n    void testSingleColumn() {\n        String input = \"col1\\nval1\\nval2\\n\";\n        when(mockStdin.readAllBytes()).thenReturn(input.getBytes());\n\n        List<List<String>> expectedOutput = List.of(\n            List.of(\"col1\"),\n            List.of(\"val1\"),\n            List.of(\"val2\")\n        );\n\n        List<List<String>> actualOutput = readTsvFromStdin();\n\n        assertEquals(expectedOutput, actualOutput);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Reads TSV data from standard input and pads rows to ensure they have the same length.\n *\n * @return A list of lists containing the padded data.\n */\npublic static List<List<String>> readTSVFromStdin() {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 547, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Calculate the maximum width of each column in a list of lists where each sub-list represents a row of table data.", "language_version_list": {"python": {"code_signature": "from typing import List\n\n\ndef calculate_column_widths(data: List[List[str]]) -> List[int]:\n    \"\"\"\n    Calculate the maximum width of each column in a list of lists where each sub-list represents a row of table data.\n\n    Args:\n        data (List[List[str]]): A two-dimensional list containing rows of data, where each inner list contains string elements representing the values in each column.\n\n    Returns:\n        List[int]: A list containing the maximum width (in characters) of each column across all rows. The width of a column is defined by the longest string present in that column.\n    \"\"\"\n", "test_code": "import unittest\n\n\nclass TestCalculateColumnWidths(unittest.TestCase):\n\n    def test_standard_case(self):\n        data = [[\"Name\", \"Age\", \"City\"],\n                [\"Alice\", \"22\", \"New York\"],\n                [\"Bob\", \"30\", \"San Francisco\"]]\n        expected = [5, 3, 13]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n\n    def test_single_element(self):\n        data = [[\"Name\"]]\n        expected = [4]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_varied_length(self):\n        data = [[\"a\", \"bb\", \"ccc\"],\n                [\"dddd\", \"ee\", \"f\"]]\n        expected = [4, 2, 3]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_all_empty_strings(self):\n        data = [[\"\", \"\", \"\"],\n                [\"\", \"\", \"\"]]\n        expected = [0, 0, 0]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_mixed_content(self):\n        data = [[\"1234\", \"567\", \"890\"],\n                [\"abc\", \"defg\", \"h\"]]\n        expected = [4, 4, 3]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_single_column_multiple_rows(self):\n        data = [[\"one\"],\n                [\"two\"],\n                [\"three\"]]\n        expected = [5]\n        self.assertEqual(calculate_column_widths(data), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef calculate_column_widths(data: List[List[str]]) -> List[int]:\n    \"\"\"\n    Calculate the maximum width of each column in a list of lists where each sub-list represents a row of table data.\n\n    Args:\n        data (List[List[str]]): A two-dimensional list containing rows of data, where each inner list contains string elements representing the values in each column.\n\n    Returns:\n        List[int]: A list containing the maximum width (in characters) of each column across all rows. The width of a column is defined by the longest string present in that column.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculate the maximum width of each column in a list of lists where each sub-list represents a row of table data.\n *\n * @param {Array<Array<string>>} data - A two-dimensional array containing rows of data, where each inner array contains string elements representing the values in each column.\n * @returns {Array<number>} An array containing the maximum width (in characters) of each column across all rows. The width of a column is defined by the longest string present in that column.\n */\nfunction calculateColumnWidths(data) {}", "test_code": "describe('TestCalculateColumnWidths', () => {\n\n    it('should handle a standard case', () => {\n        const data = [\n            [\"Name\", \"Age\", \"City\"],\n            [\"Alice\", \"22\", \"New York\"],\n            [\"Bob\", \"30\", \"San Francisco\"]\n        ];\n        const expected = [5, 3, 13];\n        expect(calculateColumnWidths(data)).toEqual(expected);\n    });\n\n    it('should handle a single element case', () => {\n        const data = [[\"Name\"]];\n        const expected = [4];\n        expect(calculateColumnWidths(data)).toEqual(expected);\n    });\n\n    it('should handle varied length cases', () => {\n        const data = [\n            [\"a\", \"bb\", \"ccc\"],\n            [\"dddd\", \"ee\", \"f\"]\n        ];\n        const expected = [4, 2, 3];\n        expect(calculateColumnWidths(data)).toEqual(expected);\n    });\n\n    it('should handle all empty strings', () => {\n        const data = [\n            [\"\", \"\", \"\"],\n            [\"\", \"\", \"\"]\n        ];\n        const expected = [0, 0, 0];\n        expect(calculateColumnWidths(data)).toEqual(expected);\n    });\n\n    it('should handle mixed content', () => {\n        const data = [\n            [\"1234\", \"567\", \"890\"],\n            [\"abc\", \"defg\", \"h\"]\n        ];\n        const expected = [4, 4, 3];\n        expect(calculateColumnWidths(data)).toEqual(expected);\n    });\n\n    it('should handle a single column with multiple rows', () => {\n        const data = [\n            [\"one\"],\n            [\"two\"],\n            [\"three\"]\n        ];\n        const expected = [5];\n        expect(calculateColumnWidths(data)).toEqual(expected);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculate the maximum width of each column in a list of lists where each sub-list represents a row of table data.\n *\n * @param {Array<Array<string>>} data - A two-dimensional array containing rows of data, where each inner array contains string elements representing the values in each column.\n * @returns {Array<number>} An array containing the maximum width (in characters) of each column across all rows. The width of a column is defined by the longest string present in that column.\n */\nfunction calculateColumnWidths(data) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculate the maximum width of each column in a list of lists where each sub-list represents a row of table data.\n *\n * @param data - A two-dimensional array containing rows of data, where each inner array contains string elements representing the values in each column.\n * @returns An array containing the maximum width (in characters) of each column across all rows. The width of a column is defined by the longest string present in that column.\n */\nfunction calculateColumnWidths(data: string[][]): number[] {}", "test_code": "describe('TestCalculateColumnWidths', () => {\n    it('should handle a standard case', () => {\n      const data = [\n        [\"Name\", \"Age\", \"City\"],\n        [\"Alice\", \"22\", \"New York\"],\n        [\"Bob\", \"30\", \"San Francisco\"]\n      ];\n      const expected = [5, 3, 13];\n      expect(calculateColumnWidths(data)).toEqual(expected);\n    });\n  \n    it('should handle a single element case', () => {\n      const data = [[\"Name\"]];\n      const expected = [4];\n      expect(calculateColumnWidths(data)).toEqual(expected);\n    });\n  \n    it('should handle varied length cases', () => {\n      const data = [\n        [\"a\", \"bb\", \"ccc\"],\n        [\"dddd\", \"ee\", \"f\"]\n      ];\n      const expected = [4, 2, 3];\n      expect(calculateColumnWidths(data)).toEqual(expected);\n    });\n  \n    it('should handle all empty strings', () => {\n      const data = [\n        [\"\", \"\", \"\"],\n        [\"\", \"\", \"\"]\n      ];\n      const expected = [0, 0, 0];\n      expect(calculateColumnWidths(data)).toEqual(expected);\n    });\n  \n    it('should handle mixed content', () => {\n      const data = [\n        [\"1234\", \"567\", \"890\"],\n        [\"abc\", \"defg\", \"h\"]\n      ];\n      const expected = [4, 4, 3];\n      expect(calculateColumnWidths(data)).toEqual(expected);\n    });\n  \n    it('should handle a single column with multiple rows', () => {\n      const data = [\n        [\"one\"],\n        [\"two\"],\n        [\"three\"]\n      ];\n      const expected = [5];\n      expect(calculateColumnWidths(data)).toEqual(expected);\n    });\n  });", "prompt": "please write a typescript function , the function signature as below /**\n * Calculate the maximum width of each column in a list of lists where each sub-list represents a row of table data.\n *\n * @param data - A two-dimensional array containing rows of data, where each inner array contains string elements representing the values in each column.\n * @returns An array containing the maximum width (in characters) of each column across all rows. The width of a column is defined by the longest string present in that column.\n */\nfunction calculateColumnWidths(data: string[][]): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the maximum width of each column in a table.\n *\n * This function takes a two-dimensional vector representing rows of table data,\n * where each sub-list contains string elements representing the values in each column.\n *\n * @param data A two-dimensional vector containing rows of data.\n *              Each inner vector contains string elements representing the values in each column.\n *\n * @return A vector containing the maximum width (in characters) of each column\n *         across all rows. The width of a column is defined by the longest string\n *         present in that column.\n */\nstd::vector<int> calculate_column_widths(const std::vector<std::vector<std::string>>& data) {}", "test_code": "TEST_CASE(\"Test calculate_column_widths\") {\n    SECTION(\"Standard case\") {\n        std::vector<std::vector<std::string>> data = {\n            {\"Name\", \"Age\", \"City\"},\n            {\"Alice\", \"22\", \"New York\"},\n            {\"Bob\", \"30\", \"San Francisco\"}\n        };\n        std::vector<int> expected = {5, 3, 13};\n        REQUIRE(calculate_column_widths(data) == expected);\n    }\n\n    SECTION(\"Single element\") {\n        std::vector<std::vector<std::string>> data = {{\"Name\"}};\n        std::vector<int> expected = {4};\n        REQUIRE(calculate_column_widths(data) == expected);\n    }\n\n    SECTION(\"Varied length\") {\n        std::vector<std::vector<std::string>> data = {\n            {\"a\", \"bb\", \"ccc\"},\n            {\"dddd\", \"ee\", \"f\"}\n        };\n        std::vector<int> expected = {4, 2, 3};\n        REQUIRE(calculate_column_widths(data) == expected);\n    }\n\n    SECTION(\"All empty strings\") {\n        std::vector<std::vector<std::string>> data = {\n            {\"\", \"\", \"\"},\n            {\"\", \"\", \"\"}\n        };\n        std::vector<int> expected = {0, 0, 0};\n        REQUIRE(calculate_column_widths(data) == expected);\n    }\n\n    SECTION(\"Mixed content\") {\n        std::vector<std::vector<std::string>> data = {\n            {\"1234\", \"567\", \"890\"},\n            {\"abc\", \"defg\", \"h\"}\n        };\n        std::vector<int> expected = {4, 4, 3};\n        REQUIRE(calculate_column_widths(data) == expected);\n    }\n\n    SECTION(\"Single column multiple rows\") {\n        std::vector<std::vector<std::string>> data = {\n            {\"one\"},\n            {\"two\"},\n            {\"three\"}\n        };\n        std::vector<int> expected = {5};\n        REQUIRE(calculate_column_widths(data) == expected);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the maximum width of each column in a table.\n *\n * This function takes a two-dimensional vector representing rows of table data,\n * where each sub-list contains string elements representing the values in each column.\n *\n * @param data A two-dimensional vector containing rows of data.\n *              Each inner vector contains string elements representing the values in each column.\n *\n * @return A vector containing the maximum width (in characters) of each column\n *         across all rows. The width of a column is defined by the longest string\n *         present in that column.\n */\nstd::vector<int> calculate_column_widths(const std::vector<std::vector<std::string>>& data) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculates the maximum width of each column in a list of lists where each sub-list represents a row of table data.\n *\n * @param data A two-dimensional list containing rows of data, where each inner list contains string elements representing the values in each column.\n * @return A list containing the maximum width (in characters) of each column across all rows. The width of a column is defined by the longest string present in that column.\n */\npublic static List<Integer> calculateColumnWidths(List<List<String>> data) {}", "test_code": "package org.real.temp;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n\n\npublic class Tester {\n\n    @Test\n    public void testStandardCase() {\n        List<List<String>> data = Arrays.asList(\n            Arrays.asList(\"Name\", \"Age\", \"City\"),\n            Arrays.asList(\"Alice\", \"22\", \"New York\"),\n            Arrays.asList(\"Bob\", \"30\", \"San Francisco\")\n        );\n        List<Integer> expected = Arrays.asList(5, 3, 13);\n        assertEquals(expected, calculateColumnWidths(data));\n    }\n\n    @Test\n    public void testSingleElement() {\n        List<List<String>> data = Arrays.asList(\n            Arrays.asList(\"Name\")\n        );\n        List<Integer> expected = Arrays.asList(4);\n        assertEquals(expected, calculateColumnWidths(data));\n    }\n\n    @Test\n    public void testVariedLength() {\n        List<List<String>> data = Arrays.asList(\n            Arrays.asList(\"a\", \"bb\", \"ccc\"),\n            Arrays.asList(\"dddd\", \"ee\", \"f\")\n        );\n        List<Integer> expected = Arrays.asList(4, 2, 3);\n        assertEquals(expected, calculateColumnWidths(data));\n    }\n\n    @Test\n    public void testAllEmptyStrings() {\n        List<List<String>> data = Arrays.asList(\n            Arrays.asList(\"\", \"\", \"\"),\n            Arrays.asList(\"\", \"\", \"\")\n        );\n        List<Integer> expected = Arrays.asList(0, 0, 0);\n        assertEquals(expected, calculateColumnWidths(data));\n    }\n\n    @Test\n    public void testMixedContent() {\n        List<List<String>> data = Arrays.asList(\n            Arrays.asList(\"1234\", \"567\", \"890\"),\n            Arrays.asList(\"abc\", \"defg\", \"h\")\n        );\n        List<Integer> expected = Arrays.asList(4, 4, 3);\n        assertEquals(expected, calculateColumnWidths(data));\n    }\n\n    @Test\n    public void testSingleColumnMultipleRows() {\n        List<List<String>> data = Arrays.asList(\n            Arrays.asList(\"one\"),\n            Arrays.asList(\"two\"),\n            Arrays.asList(\"three\")\n        );\n        List<Integer> expected = Arrays.asList(5);\n        assertEquals(expected, calculateColumnWidths(data));\n    }\n\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculates the maximum width of each column in a list of lists where each sub-list represents a row of table data.\n *\n * @param data A two-dimensional list containing rows of data, where each inner list contains string elements representing the values in each column.\n * @return A list containing the maximum width (in characters) of each column across all rows. The width of a column is defined by the longest string present in that column.\n */\npublic static List<Integer> calculateColumnWidths(List<List<String>> data) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 548, "code_type": "method", "original_language": "python", "question_type": "Data processing and transformation", "summary": "Reads a text file, wraps its content in JSON brackets, and parses it into a Python object.", "language_version_list": {"python": {"code_signature": "import json\n\n\ndef read_txt_add_json_bracket(filename:str):\n    \"\"\"\n    Reads a text file, wraps its content in JSON brackets, and parses it into a Python object.\n\n    Args:\n        filename (str): The path to the text file to be read.\n\n    Returns:\n        list: A list parsed from the JSON content wrapped in brackets.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        json.JSONDecodeError: If the content cannot be parsed as JSON.\n    \"\"\"", "test_code": "import os\nimport unittest\nfrom unittest.mock import patch, mock_open\n\n\nclass TestReadTxtAddJsonBracket(unittest.TestCase):\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data='{\"key\": \"value\"}')\n    def test_valid_json(self, mock_file):\n        result = read_txt_add_json_bracket(\"fakefile.txt\")\n        self.assertEqual(result, [{\"key\": \"value\"}])\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data='[]')\n    def test_empty_json_array(self, mock_file):\n        result = read_txt_add_json_bracket(\"fakefile.txt\")\n        self.assertEqual(result, [[]])  # Should return an empty list\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data='{\"key\": \"value\"}\\n')\n    def test_valid_json_with_newline(self, mock_file):\n        result = read_txt_add_json_bracket(\"fakefile.txt\")\n        self.assertEqual(result, [{\"key\": \"value\"}])\n\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data='{\"key\": \"value\"}')\n    def test_json_with_array(self, mock_file):\n        result = read_txt_add_json_bracket(\"fakefile.txt\")\n        self.assertEqual(result, [{\"key\": \"value\"}])\n", "prompt": "please write a python function , the function signature as below import json\n\n\ndef read_txt_add_json_bracket(filename:str):\n    \"\"\"\n    Reads a text file, wraps its content in JSON brackets, and parses it into a Python object.\n\n    Args:\n        filename (str): The path to the text file to be read.\n\n    Returns:\n        list: A list parsed from the JSON content wrapped in brackets.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        json.JSONDecodeError: If the content cannot be parsed as JSON.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 549, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "Converts temperature from keV to log10(K) for a given input (scalar or tuple)", "language_version_list": {"python": {"code_signature": "from typing import Union, Tuple\n\nimport numpy as np\n\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\ndef get_T_in_log10_Kelvin(T_keV: Union[float, Tuple]):\n    \"\"\"\n    Converts temperature from keV to log10(K) for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5\n\n    Args:\n        T_keV (float or tuple): The temperature in keV. Can be a scalar or a tuple of temperatures.\n\n    Returns:\n        float or tuple: The temperature(s) in log10(K) corresponding to the input.\n\n    Raises:\n        ValueError: If the input is not a scalar (int or float) or a tuple.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\nclass TestGetTInLog10Kelvin(unittest.TestCase):\n\n    # Existing test cases here...\n\n    def test_scalar_input_high_temperature(self):\n        \"\"\"Test with a high scalar input.\"\"\"\n        T_keV = 100.0\n        expected_result = np.log10(T_keV / k_B_over_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_scalar_input_low_temperature(self):\n        \"\"\"Test with a low scalar input.\"\"\"\n        T_keV = 0.01\n        expected_result = np.log10(T_keV / k_B_over_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_tuple_input_large_range(self):\n        \"\"\"Test with a tuple of temperatures over a large range.\"\"\"\n        T_keV = (0.1, 1.0, 10.0, 100.0, 1000.0)\n        expected_results = tuple(np.log10(t / k_B_over_keV) for t in T_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertEqual(result, expected_results)\n\n    def test_tuple_input_repeated_values(self):\n        \"\"\"Test with a tuple of repeated temperature values.\"\"\"\n        T_keV = (1.0, 1.0, 1.0)\n        expected_results = tuple(np.log10(t / k_B_over_keV) for t in T_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertEqual(result, expected_results)\n\n    def test_scalar_input_non_integer(self):\n        \"\"\"Test with a non-integer scalar input.\"\"\"\n        T_keV = 2.5\n        expected_result = np.log10(T_keV / k_B_over_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_tuple_input_floating_point(self):\n        \"\"\"Test with a tuple of floating-point temperatures.\"\"\"\n        T_keV = (1.5, 2.5, 3.5)\n        expected_results = tuple(np.log10(t / k_B_over_keV) for t in T_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertEqual(result, expected_results)\n\n\n    def test_large_tuple_input(self):\n        \"\"\"Test with a large tuple of temperature values.\"\"\"\n        T_keV = tuple(np.arange(1, 1001, 1))  # Temperatures from 1 keV to 1000 keV\n        expected_results = tuple(np.log10(t / k_B_over_keV) for t in T_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertEqual(result, expected_results)\n", "prompt": "please write a python function , the function signature as below from typing import Union, Tuple\n\nimport numpy as np\n\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\ndef get_T_in_log10_Kelvin(T_keV: Union[float, Tuple]):\n    \"\"\"\n    Converts temperature from keV to log10(K) for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5\n\n    Args:\n        T_keV (float or tuple): The temperature in keV. Can be a scalar or a tuple of temperatures.\n\n    Returns:\n        float or tuple: The temperature(s) in log10(K) corresponding to the input.\n\n    Raises:\n        ValueError: If the input is not a scalar (int or float) or a tuple.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 550, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "Converts temperature from log10(K) to keV for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5", "language_version_list": {"python": {"code_signature": "from typing import Tuple, Union\n\nimport numpy as np\n\n# Define the constant for conversion: Boltzmann constant in keV/K\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\ndef convert_log10_K_to_keV(T_log10_K: Union[float, Tuple]):\n    \"\"\"\n    Converts temperature from log10(K) to keV for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5\n\n    Args:\n        T_log10_K (float or tuple): The temperature in log10(K). Can be a scalar or a tuple of temperatures.\n\n    Returns:\n        float or tuple: The temperature(s) in keV corresponding to the input.\n\n    Raises:\n        ValueError: If the input is not a scalar (int or float) or a tuple.\n    \"\"\"\n", "test_code": "import unittest\n\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\nclass TestConvertLog10KToKeV(unittest.TestCase):\n\n    def test_scalar_input(self):\n        \"\"\"Test conversion of a single scalar log10(K) value.\"\"\"\n        T_log10_K = 3.0\n        expected_result = 10 ** T_log10_K * k_B_over_keV\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_tuple_input(self):\n        \"\"\"Test conversion of a tuple of log10(K) values.\"\"\"\n        T_log10_K = (2.0, 3.0, 4.0)\n        expected_results = tuple(10 ** t * k_B_over_keV for t in T_log10_K)\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertEqual(result, expected_results)\n\n    def test_zero_input(self):\n        \"\"\"Test conversion of log10(K) = 0.\"\"\"\n        T_log10_K = 0.0\n        expected_result = 10 ** T_log10_K * k_B_over_keV\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_negative_input(self):\n        \"\"\"Test conversion of a negative log10(K) value.\"\"\"\n        T_log10_K = -1.0\n        expected_result = 10 ** T_log10_K * k_B_over_keV\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_large_tuple_input(self):\n        \"\"\"Test conversion of a large tuple of log10(K) values.\"\"\"\n        T_log10_K = (1.0, 2.0, 3.0, 4.0, 5.0)\n        expected_results = tuple(10 ** t * k_B_over_keV for t in T_log10_K)\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertEqual(result, expected_results)\n\n    def test_single_large_value(self):\n        \"\"\"Test conversion of a large log10(K) value.\"\"\"\n        T_log10_K = 10.0\n        expected_result = 10 ** T_log10_K * k_B_over_keV\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_invalid_input(self):\n        \"\"\"Test conversion with invalid input (string).\"\"\"\n        T_log10_K = \"invalid\"\n        with self.assertRaises(ValueError):\n            convert_log10_K_to_keV(T_log10_K)\n", "prompt": "please write a python function , the function signature as below from typing import Tuple, Union\n\nimport numpy as np\n\n# Define the constant for conversion: Boltzmann constant in keV/K\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\ndef convert_log10_K_to_keV(T_log10_K: Union[float, Tuple]):\n    \"\"\"\n    Converts temperature from log10(K) to keV for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5\n\n    Args:\n        T_log10_K (float or tuple): The temperature in log10(K). Can be a scalar or a tuple of temperatures.\n\n    Returns:\n        float or tuple: The temperature(s) in keV corresponding to the input.\n\n    Raises:\n        ValueError: If the input is not a scalar (int or float) or a tuple.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "typescript": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "c&cpp": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}, "java": {"code_signature": "", "test_code": "", "prompt": "", "addition_info": ""}}}
{"task_id": 551, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Calculate the midpoints from a given array of edges", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef get_mids_from_edges(edges: np.ndarray):\n    \"\"\"\n    Calculate the midpoints from a given array of edges.\n    For example:\n        input: [0, 1, 2]\n        output: [0.5, 1.5]\n\n    Args:\n        edges (np.ndarray): An array of edge values.\n\n    Returns:\n        np.ndarray: An array of midpoints calculated from the edges.\n    \"\"\"\n", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestGetMidsFromEdges(unittest.TestCase):\n\n    def test_basic_case(self):\n        \"\"\"Test with a standard range of edges.\"\"\"\n        edges = np.array([1, 2, 3, 4])\n        expected_mids = np.array([1.5, 2.5, 3.5])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_single_interval(self):\n        \"\"\"Test with two edges (single interval).\"\"\"\n        edges = np.array([5, 10])\n        expected_mids = np.array([7.5])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_multiple_intervals(self):\n        \"\"\"Test with multiple intervals.\"\"\"\n        edges = np.array([0, 1, 2, 3, 4, 5])\n        expected_mids = np.array([0.5, 1.5, 2.5, 3.5, 4.5])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_negative_edges(self):\n        \"\"\"Test with negative edges.\"\"\"\n        edges = np.array([-5, -3, -1, 1])\n        expected_mids = np.array([-4.0, -2.0, 0.0])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_zero_edges(self):\n        \"\"\"Test with edges including zero.\"\"\"\n        edges = np.array([0, 1, 2])\n        expected_mids = np.array([0.5, 1.5])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_float_edges(self):\n        \"\"\"Test with floating-point edges.\"\"\"\n        edges = np.array([0.0, 1.5, 3.0])\n        expected_mids = np.array([0.75, 2.25])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_empty_array(self):\n        \"\"\"Test with an empty array.\"\"\"\n        edges = np.array([])\n        expected_mids = np.array([])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef get_mids_from_edges(edges: np.ndarray):\n    \"\"\"\n    Calculate the midpoints from a given array of edges.\n    For example:\n        input: [0, 1, 2]\n        output: [0.5, 1.5]\n\n    Args:\n        edges (np.ndarray): An array of edge values.\n\n    Returns:\n        np.ndarray: An array of midpoints calculated from the edges.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Calculate the midpoints from a given array of edges.\n * For example:\n *   input: [0, 1, 2]\n *   output: [0.5, 1.5]\n *\n * @param {Array<number>} edges - An array of edge values.\n * @returns {Array<number>} An array of midpoints calculated from the edges.\n */\nfunction getMidsFromEdges(edges) {}", "test_code": "describe('TestGetMidsFromEdges', () => {\n    const getMidsFromEdges = require('./getMidsFromEdges'); // Import the function to test\n\n    describe('test_basic_case', () => {\n        it('should handle a standard range of edges', () => {\n            const edges = [1, 2, 3, 4];\n            const expectedMids = [1.5, 2.5, 3.5];\n            expect(getMidsFromEdges(edges)).toEqual(expectedMids);\n        });\n    });\n\n    describe('test_single_interval', () => {\n        it('should handle two edges (single interval)', () => {\n            const edges = [5, 10];\n            const expectedMids = [7.5];\n            expect(getMidsFromEdges(edges)).toEqual(expectedMids);\n        });\n    });\n\n    describe('test_multiple_intervals', () => {\n        it('should handle multiple intervals', () => {\n            const edges = [0, 1, 2, 3, 4, 5];\n            const expectedMids = [0.5, 1.5, 2.5, 3.5, 4.5];\n            expect(getMidsFromEdges(edges)).toEqual(expectedMids);\n        });\n    });\n\n    describe('test_negative_edges', () => {\n        it('should handle negative edges', () => {\n            const edges = [-5, -3, -1, 1];\n            const expectedMids = [-4.0, -2.0, 0.0];\n            expect(getMidsFromEdges(edges)).toEqual(expectedMids);\n        });\n    });\n\n    describe('test_zero_edges', () => {\n        it('should handle edges including zero', () => {\n            const edges = [0, 1, 2];\n            const expectedMids = [0.5, 1.5];\n            expect(getMidsFromEdges(edges)).toEqual(expectedMids);\n        });\n    });\n\n    describe('test_float_edges', () => {\n        it('should handle floating-point edges', () => {\n            const edges = [0.0, 1.5, 3.0];\n            const expectedMids = [0.75, 2.25];\n            expect(getMidsFromEdges(edges)).toEqual(expectedMids);\n        });\n    });\n\n    describe('test_empty_array', () => {\n        it('should handle an empty array', () => {\n            const edges = [];\n            const expectedMids = [];\n            expect(getMidsFromEdges(edges)).toEqual(expectedMids);\n        });\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Calculate the midpoints from a given array of edges.\n * For example:\n *   input: [0, 1, 2]\n *   output: [0.5, 1.5]\n *\n * @param {Array<number>} edges - An array of edge values.\n * @returns {Array<number>} An array of midpoints calculated from the edges.\n */\nfunction getMidsFromEdges(edges) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Calculate the midpoints from a given array of edges.\n * For example:\n *   input: [0, 1, 2]\n *   output: [0.5, 1.5]\n *\n * @param edges - An array of edge values.\n * @returns An array of midpoints calculated from the edges.\n */\nfunction getMidsFromEdges(edges: number[]): number[] {}", "test_code": "describe('TestGetMidsFromEdges', () => {\n    it('test_basic_case', () => {\n        // Test with a standard range of edges\n        const edges = [1, 2, 3, 4];\n        const expectedMids = [1.5, 2.5, 3.5];\n        expect(getMidsFromEdges(edges)).toEqual(expectedMids);\n    });\n\n    it('test_single_interval', () => {\n        // Test with two edges (single interval)\n        const edges = [5, 10];\n        const expectedMids = [7.5];\n        expect(getMidsFromEdges(edges)).toEqual(expectedMids);\n    });\n\n    it('test_multiple_intervals', () => {\n        // Test with multiple intervals\n        const edges = [0, 1, 2, 3, 4, 5];\n        const expectedMids = [0.5, 1.5, 2.5, 3.5, 4.5];\n        expect(getMidsFromEdges(edges)).toEqual(expectedMids);\n    });\n\n    it('test_negative_edges', () => {\n        // Test with negative edges\n        const edges = [-5, -3, -1, 1];\n        const expectedMids = [-4.0, -2.0, 0.0];\n        expect(getMidsFromEdges(edges)).toEqual(expectedMids);\n    });\n\n    it('test_zero_edges', () => {\n        // Test with edges including zero\n        const edges = [0, 1, 2];\n        const expectedMids = [0.5, 1.5];\n        expect(getMidsFromEdges(edges)).toEqual(expectedMids);\n    });\n\n    it('test_float_edges', () => {\n        // Test with floating-point edges\n        const edges = [0.0, 1.5, 3.0];\n        const expectedMids = [0.75, 2.25];\n        expect(getMidsFromEdges(edges)).toEqual(expectedMids);\n    });\n\n    it('test_empty_array', () => {\n        // Test with an empty array\n        const edges = [];\n        const expectedMids = [];\n        expect(getMidsFromEdges(edges)).toEqual(expectedMids);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Calculate the midpoints from a given array of edges.\n * For example:\n *   input: [0, 1, 2]\n *   output: [0.5, 1.5]\n *\n * @param edges - An array of edge values.\n * @returns An array of midpoints calculated from the edges.\n */\nfunction getMidsFromEdges(edges: number[]): number[] {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Calculate the midpoints from a given array of edges.\n * For example:\n *     input: [0, 1, 2]\n *     output: [0.5, 1.5]\n *\n * @param edges A vector of edge values.\n * @return A vector of midpoints calculated from the edges.\n */\nstd::vector<double> get_mids_from_edges(const std::vector<double>& edges) {}", "test_code": "TEST_CASE(\"Test Get Mids From Edges\") {\n    SECTION(\"Basic Case\") {\n        std::vector<double> edges = {1, 2, 3, 4};\n        std::vector<double> expected_mids = {1.5, 2.5, 3.5};\n        REQUIRE(get_mids_from_edges(edges) == expected_mids);\n    }\n\n    SECTION(\"Single Interval\") {\n        std::vector<double> edges = {5, 10};\n        std::vector<double> expected_mids = {7.5};\n        REQUIRE(get_mids_from_edges(edges) == expected_mids);\n    }\n\n    SECTION(\"Multiple Intervals\") {\n        std::vector<double> edges = {0, 1, 2, 3, 4, 5};\n        std::vector<double> expected_mids = {0.5, 1.5, 2.5, 3.5, 4.5};\n        REQUIRE(get_mids_from_edges(edges) == expected_mids);\n    }\n\n    SECTION(\"Negative Edges\") {\n        std::vector<double> edges = {-5, -3, -1, 1};\n        std::vector<double> expected_mids = {-4.0, -2.0, 0.0};\n        REQUIRE(get_mids_from_edges(edges) == expected_mids);\n    }\n\n    SECTION(\"Zero Edges\") {\n        std::vector<double> edges = {0, 1, 2};\n        std::vector<double> expected_mids = {0.5, 1.5};\n        REQUIRE(get_mids_from_edges(edges) == expected_mids);\n    }\n\n    SECTION(\"Float Edges\") {\n        std::vector<double> edges = {0.0, 1.5, 3.0};\n        std::vector<double> expected_mids = {0.75, 2.25};\n        REQUIRE(get_mids_from_edges(edges) == expected_mids);\n    }\n\n    SECTION(\"Empty Array\") {\n        std::vector<double> edges = {};\n        std::vector<double> expected_mids = {};\n        REQUIRE(get_mids_from_edges(edges) == expected_mids);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the midpoints from a given array of edges.\n * For example:\n *     input: [0, 1, 2]\n *     output: [0.5, 1.5]\n *\n * @param edges A vector of edge values.\n * @return A vector of midpoints calculated from the edges.\n */\nstd::vector<double> get_mids_from_edges(const std::vector<double>& edges) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Calculate the midpoints from a given array of edges.\n *\n * @param edges An array of edge values.\n * @return An array of midpoints calculated from the edges.\n */\npublic static double[] getMidsFromEdges(double[] edges) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\n\npublic class Tester {\n\n    /**\n     * Test with a standard range of edges.\n     */\n    @Test\n    public void testBasicCase() {\n        double[] edges = {1, 2, 3, 4};\n        double[] expectedMids = {1.5, 2.5, 3.5};\n        assertArrayEquals(expectedMids, getMidsFromEdges(edges), 0.001);\n    }\n\n    /**\n     * Test with two edges (single interval).\n     */\n    @Test\n    public void testSingleInterval() {\n        double[] edges = {5, 10};\n        double[] expectedMids = {7.5};\n        assertArrayEquals(expectedMids, getMidsFromEdges(edges), 0.001);\n    }\n\n    /**\n     * Test with multiple intervals.\n     */\n    @Test\n    public void testMultipleIntervals() {\n        double[] edges = {0, 1, 2, 3, 4, 5};\n        double[] expectedMids = {0.5, 1.5, 2.5, 3.5, 4.5};\n        assertArrayEquals(expectedMids, getMidsFromEdges(edges), 0.001);\n    }\n\n    /**\n     * Test with negative edges.\n     */\n    @Test\n    public void testNegativeEdges() {\n        double[] edges = {-5, -3, -1, 1};\n        double[] expectedMids = {-4.0, -2.0, 0.0};\n        assertArrayEquals(expectedMids, getMidsFromEdges(edges), 0.001);\n    }\n\n    /**\n     * Test with edges including zero.\n     */\n    @Test\n    public void testZeroEdges() {\n        double[] edges = {0, 1, 2};\n        double[] expectedMids = {0.5, 1.5};\n        assertArrayEquals(expectedMids, getMidsFromEdges(edges), 0.001);\n    }\n\n    /**\n     * Test with floating-point edges.\n     */\n    @Test\n    public void testFloatEdges() {\n        double[] edges = {0.0, 1.5, 3.0};\n        double[] expectedMids = {0.75, 2.25};\n        assertArrayEquals(expectedMids, getMidsFromEdges(edges), 0.001);\n    }\n\n    /**\n     * Test with an empty array.\n     */\n    @Test\n    public void testEmptyArray() {\n        double[] edges = {};\n        double[] expectedMids = {};\n        assertArrayEquals(expectedMids, getMidsFromEdges(edges), 0.001);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Calculate the midpoints from a given array of edges.\n *\n * @param edges An array of edge values.\n * @return An array of midpoints calculated from the edges.\n */\npublic static double[] getMidsFromEdges(double[] edges) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 552, "code_type": "method", "original_language": "python", "question_type": "Algorithm and data structure", "summary": "Compares two sets of floats for equality within a relative and absolute tolerance.", "language_version_list": {"python": {"code_signature": "import numpy as np\n\n\ndef are_sets_equal(set1, set2, rtol=1e-5, atol=1e-6):\n    \"\"\"\n    Compares two sets of floats for equality within a relative and absolute tolerance.\n\n    Args:\n        set1: The first set of floats.\n        set2: The second set of floats.\n        rtol: The relative tolerance (default: 1e-5).\n        atol: The absolute tolerance (default: 1e-6).\n\n    Returns:\n        True if the sets are equal within the specified tolerances, False otherwise.\n    \"\"\"", "test_code": "import unittest\n\n\nclass TestAreSetsEqual(unittest.TestCase):\n\n    def test_identical_sets(self):\n        \"\"\"Test with two identical sets of floats.\"\"\"\n        set1 = {1.0, 2.0, 3.0}\n        set2 = {1.0, 2.0, 3.0}\n        self.assertTrue(are_sets_equal(set1, set2))\n\n    def test_sets_with_close_values(self):\n        \"\"\"Test with two sets that are close within the tolerance.\"\"\"\n        set1 = {1.0, 2.00001, 3.0}\n        set2 = {1.0, 2.00002, 3.0}\n        self.assertTrue(are_sets_equal(set1, set2, rtol=1e-5, atol=1e-6))\n\n    def test_sets_with_large_difference(self):\n        \"\"\"Test with two sets that have large differences beyond tolerance.\"\"\"\n        set1 = {1.0, 2.0, 3.0}\n        set2 = {1.0, 2.5, 3.0}\n        self.assertFalse(are_sets_equal(set1, set2))\n\n    def test_sets_with_one_different_values(self):\n        \"\"\"Test with two sets containing one different floats.\"\"\"\n        set1 = {1.0, 2.0, 3.0}\n        set2 = {1.0, 2.000001, 3.0}\n        self.assertTrue(are_sets_equal(set1, set2, rtol=1e-5, atol=1e-6))\n\n    def test_empty_sets(self):\n        \"\"\"Test with two empty sets.\"\"\"\n        set1 = set()\n        set2 = set()\n        self.assertTrue(are_sets_equal(set1, set2))\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef are_sets_equal(set1, set2, rtol=1e-5, atol=1e-6):\n    \"\"\"\n    Compares two sets of floats for equality within a relative and absolute tolerance.\n\n    Args:\n        set1: The first set of floats.\n        set2: The second set of floats.\n        rtol: The relative tolerance (default: 1e-5).\n        atol: The absolute tolerance (default: 1e-6).\n\n    Returns:\n        True if the sets are equal within the specified tolerances, False otherwise.\n    \"\"\"", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Compares two sets of floats for equality within a relative and absolute tolerance.\n *\n * @param {Set<number>} set1 - The first set of floats.\n * @param {Set<number>} set2 - The second set of floats.\n * @param {number} [rtol=1e-5] - The relative tolerance (default: 1e-5).\n * @param {number} [atol=1e-6] - The absolute tolerance (default: 1e-6).\n * @returns {boolean} True if the sets are equal within the specified tolerances, False otherwise.\n */\nfunction areSetsEqual(set1, set2, rtol = 1e-5, atol = 1e-6) {}", "test_code": "describe('TestAreSetsEqual', () => {\n\n    describe('test_identical_sets', () => {\n        it('should return true for two identical sets of floats', () => {\n            const set1 = new Set([1.0, 2.0, 3.0]);\n            const set2 = new Set([1.0, 2.0, 3.0]);\n            expect(areSetsEqual(set1, set2)).toBe(true);\n        });\n    });\n\n    describe('test_sets_with_close_values', () => {\n        it('should return true for two sets that are close within the tolerance', () => {\n            const set1 = new Set([1.0, 2.00001, 3.0]);\n            const set2 = new Set([1.0, 2.00002, 3.0]);\n            expect(areSetsEqual(set1, set2, 1e-5, 1e-6)).toBe(true);\n        });\n    });\n\n    describe('test_sets_with_large_difference', () => {\n        it('should return false for two sets that have large differences beyond tolerance', () => {\n            const set1 = new Set([1.0, 2.0, 3.0]);\n            const set2 = new Set([1.0, 2.5, 3.0]);\n            expect(areSetsEqual(set1, set2)).toBe(false);\n        });\n    });\n\n    describe('test_sets_with_one_different_values', () => {\n        it('should return true for two sets containing one different float', () => {\n            const set1 = new Set([1.0, 2.0, 3.0]);\n            const set2 = new Set([1.0, 2.000001, 3.0]);\n            expect(areSetsEqual(set1, set2, 1e-5, 1e-6)).toBe(true);\n        });\n    });\n\n    describe('test_empty_sets', () => {\n        it('should return true for two empty sets', () => {\n            const set1 = new Set();\n            const set2 = new Set();\n            expect(areSetsEqual(set1, set2)).toBe(true);\n        });\n    });\n\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Compares two sets of floats for equality within a relative and absolute tolerance.\n *\n * @param {Set<number>} set1 - The first set of floats.\n * @param {Set<number>} set2 - The second set of floats.\n * @param {number} [rtol=1e-5] - The relative tolerance (default: 1e-5).\n * @param {number} [atol=1e-6] - The absolute tolerance (default: 1e-6).\n * @returns {boolean} True if the sets are equal within the specified tolerances, False otherwise.\n */\nfunction areSetsEqual(set1, set2, rtol = 1e-5, atol = 1e-6) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Compares two sets of floats for equality within a relative and absolute tolerance.\n *\n * @param set1 - The first set of floats.\n * @param set2 - The second set of floats.\n * @param rtol - The relative tolerance (default: 1e-5).\n * @param atol - The absolute tolerance (default: 1e-6).\n * @returns True if the sets are equal within the specified tolerances, False otherwise.\n */\nfunction areSetsEqual(set1: Set<number>, set2: Set<number>, rtol: number = 1e-5, atol: number = 1e-6): boolean {}", "test_code": "describe('areSetsEqual', () => {\n    describe('with identical sets', () => {\n        it('should return true for two identical sets of floats', () => {\n            const set1 = new Set([1.0, 2.0, 3.0]);\n            const set2 = new Set([1.0, 2.0, 3.0]);\n            expect(areSetsEqual(set1, set2)).toBe(true);\n        });\n    });\n\n    describe('with sets that are close within the tolerance', () => {\n        it('should return true for two sets that are close within the tolerance', () => {\n            const set1 = new Set([1.0, 2.00001, 3.0]);\n            const set2 = new Set([1.0, 2.00002, 3.0]);\n            expect(areSetsEqual(set1, set2, 1e-5, 1e-6)).toBe(true);\n        });\n    });\n\n    describe('with sets that have large differences beyond tolerance', () => {\n        it('should return false for two sets that have large differences beyond tolerance', () => {\n            const set1 = new Set([1.0, 2.0, 3.0]);\n            const set2 = new Set([1.0, 2.5, 3.0]);\n            expect(areSetsEqual(set1, set2)).toBe(false);\n        });\n    });\n\n    describe('with sets containing one different float', () => {\n        it('should return true for two sets containing one different float within tolerance', () => {\n            const set1 = new Set([1.0, 2.0, 3.0]);\n            const set2 = new Set([1.0, 2.000001, 3.0]);\n            expect(areSetsEqual(set1, set2, 1e-5, 1e-6)).toBe(true);\n        });\n    });\n\n    describe('with empty sets', () => {\n        it('should return true for two empty sets', () => {\n            const set1 = new Set<number>();\n            const set2 = new Set<number>();\n            expect(areSetsEqual(set1, set2)).toBe(true);\n        });\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Compares two sets of floats for equality within a relative and absolute tolerance.\n *\n * @param set1 - The first set of floats.\n * @param set2 - The second set of floats.\n * @param rtol - The relative tolerance (default: 1e-5).\n * @param atol - The absolute tolerance (default: 1e-6).\n * @returns True if the sets are equal within the specified tolerances, False otherwise.\n */\nfunction areSetsEqual(set1: Set<number>, set2: Set<number>, rtol: number = 1e-5, atol: number = 1e-6): boolean {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Compares two sets of floats for equality within a relative and absolute tolerance.\n *\n * @param set1 The first set of floats.\n * @param set2 The second set of floats.\n * @param rtol The relative tolerance (default: 1e-5).\n * @param atol The absolute tolerance (default: 1e-6).\n * @return True if the sets are equal within the specified tolerances, False otherwise.\n */\nbool are_sets_equal(const std::set<double>& set1, const std::set<double>& set2, double rtol = 1e-5, double atol = 1e-6) {}", "test_code": "TEST_CASE(\"TestAreSetsEqual\", \"[areSetsEqual]\") {\n    SECTION(\"test_identical_sets\") {\n        // Test with two identical sets of floats\n        std::set<double> set1 = {1.0, 2.0, 3.0};\n        std::set<double> set2 = {1.0, 2.0, 3.0};\n        REQUIRE(are_sets_equal(set1, set2));\n    }\n\n    SECTION(\"test_sets_with_close_values\") {\n        // Test with two sets that are close within the tolerance\n        std::set<double> set1 = {1.0, 2.00001, 3.0};\n        std::set<double> set2 = {1.0, 2.00002, 3.0};\n        REQUIRE(are_sets_equal(set1, set2, 1e-5, 1e-6));\n    }\n\n    SECTION(\"test_sets_with_large_difference\") {\n        // Test with two sets that have large differences beyond tolerance\n        std::.set<double> set1 = {1.0, 2.0, 3.0};\n        std::.set<double> set2 = {1.0, 2.5, 3.0};\n        REQUIRE_FALSE(are_sets_equal(set1, set2));\n    }\n\n    SECTION(\"test_sets_with_one_different_value\") {\n        // Test with two sets containing one different float\n        std::.set<double> set1 = {1.0, 2.0, 3.0};\n        std::.set<double> set2 = {1.0, 2.000001, 3.0};\n        REQUIRE(are_sets_equal(set1, set2, 1e-5, 1e-6));\n    }\n\n    SECTION(\"test_empty_sets\") {\n        // Test with two empty sets\n        std::.set<double> set1 = {};\n        std::.set<double> set2 = {};\n        REQUIRE(are_sets_equal(set1, set2));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Compares two sets of floats for equality within a relative and absolute tolerance.\n *\n * @param set1 The first set of floats.\n * @param set2 The second set of floats.\n * @param rtol The relative tolerance (default: 1e-5).\n * @param atol The absolute tolerance (default: 1e-6).\n * @return True if the sets are equal within the specified tolerances, False otherwise.\n */\nbool are_sets_equal(const std::set<double>& set1, const std::set<double>& set2, double rtol = 1e-5, double atol = 1e-6) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Compares two sets of floats for equality within a relative and absolute tolerance.\n *\n * @param set1 The first set of floats.\n * @param set2 The second set of floats.\n * @param rtol The relative tolerance (default: 1e-5).\n * @param atol The absolute tolerance (default: 1e-6).\n * @return True if the sets are equal within the specified tolerances, False otherwise.\n */\npublic static boolean areSetsEqual(Set<Double> set1, Set<Double> set2, double rtol, double atol) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.Arrays;\n\npublic class Tester {\n    @Test\n    public void testIdenticalSets() {\n        Set<Double> set1 = new TreeSet<>(Arrays.asList(1.0, 2.0, 3.0));\n        Set<Double> set2 = new TreeSet<>(Arrays.asList(1.0, 2.0, 3.0));\n        assertTrue(\"Two identical sets should be equal\", areSetsEqual(set1, set2, 1e-5, 1e-6));\n    }\n\n    @Test\n    public void testSetsWithCloseValues() {\n        Set<Double> set1 = new TreeSet<>(Arrays.asList(1.0, 2.00001, 3.0));\n        Set<Double> set2 = new TreeSet<>(Arrays.asList(1.0, 2.00002, 3.0));\n        assertTrue(\"Two sets with close values should be equal\", areSetsEqual(set1, set2, 1e-5, 1e-6));\n    }\n\n    @Test\n    public void testSetsWithLargeDifference() {\n        Set<Double> set1 = new TreeSet<>(Arrays.asList(1.0, 2.0, 3.0));\n        Set<Double> set2 = new TreeSet<>(Arrays.asList(1.0, 2.5, 3.0));\n        assertFalse(\"Two sets with large differences should not be equal\", areSetsEqual(set1, set2, 1e-5, 1e-6));\n    }\n\n    @Test\n    public void testSetsWithOneDifferentValue() {\n        Set<Double> set1 = new TreeSet<>(Arrays.asList(1.0, 2.0, 3.0));\n        Set<Double> set2 = new TreeSet<>(Arrays.asList(1.0, 2.000001, 3.0));\n        assertTrue(\"Two sets with one different value should be equal\", areSetsEqual(set1, set2, 1e-5, 1e-6));\n    }\n\n    @Test\n    public void testEmptySets() {\n        Set<Double> set1 = new TreeSet<>();\n        Set<Double> set2 = new TreeSet<>();\n        assertTrue(\"Two empty sets should be equal\", areSetsEqual(set1, set2, 1e-5, 1e-6));\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Compares two sets of floats for equality within a relative and absolute tolerance.\n *\n * @param set1 The first set of floats.\n * @param set2 The second set of floats.\n * @param rtol The relative tolerance (default: 1e-5).\n * @param atol The absolute tolerance (default: 1e-6).\n * @return True if the sets are equal within the specified tolerances, False otherwise.\n */\npublic static boolean areSetsEqual(Set<Double> set1, Set<Double> set2, double rtol, double atol) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 555, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "Convert a quaternion into an angle", "language_version_list": {"python": {"code_signature": "import math\nfrom typing import Tuple\n\n\ndef quaternion_to_angle(quaternion: Tuple[float]) -> float:\n    \"\"\"\n    Converts a quaternion to a rotation angle in radians.\n\n    Args:\n        quaternion (Tuple[float]): A tuple or list containing the quaternion components (w, x, y, z)\n\n    Returns:\n        float: The rotation angle in radians\n    \"\"\"\n", "test_code": "import math\nimport unittest\n\n\nclass TestQuaternionToAngle(unittest.TestCase):\n\n    def test_identity_quaternion(self):\n        \"\"\"Test the identity quaternion (no rotation).\"\"\"\n        quaternion = (1.0, 0.0, 0.0, 0.0)\n        expected_angle = 0.0\n        self.assertAlmostEqual(quaternion_to_angle(quaternion), expected_angle)\n\n\n    def test_180_degrees_rotation(self):\n        \"\"\"Test a quaternion representing a 180-degree rotation.\"\"\"\n        quaternion = (0.0, 0.0, 1.0, 0.0)  # 180 degrees around Z axis\n        expected_angle = math.pi  # 180 degrees in radians\n        self.assertAlmostEqual(quaternion_to_angle(quaternion), expected_angle)\n\n    def test_360_degrees_rotation(self):\n        \"\"\"Test a quaternion representing a full 360-degree rotation.\"\"\"\n        quaternion = (1.0, 0.0, 0.0, 0.0)  # Full rotation\n        expected_angle = 0.0  # 360 degrees is equivalent to 0 degrees\n        self.assertAlmostEqual(quaternion_to_angle(quaternion), expected_angle)\n\n\n    def test_non_unit_quaternion(self):\n        \"\"\"Test a non-unit quaternion (should still give correct angle).\"\"\"\n        quaternion = (0.5, 0.5, 0.5, 0.5)  # This is not normalized\n        # Normalize the quaternion first\n        norm = math.sqrt(sum(x ** 2 for x in quaternion))\n        normalized_quaternion = tuple(x / norm for x in quaternion)\n        expected_angle = 2 * math.acos(normalized_quaternion[0])  # Should be same angle\n        self.assertAlmostEqual(quaternion_to_angle(normalized_quaternion), expected_angle)\n\n    def test_invalid_quaternion(self):\n        \"\"\"Test that an invalid quaternion raises a ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            quaternion_to_angle((1.0, 0.0, 0.0))  # Only 3 components", "prompt": "please write a python function , the function signature as below import math\nfrom typing import Tuple\n\n\ndef quaternion_to_angle(quaternion: Tuple[float]) -> float:\n    \"\"\"\n    Converts a quaternion to a rotation angle in radians.\n\n    Args:\n        quaternion (Tuple[float]): A tuple or list containing the quaternion components (w, x, y, z)\n\n    Returns:\n        float: The rotation angle in radians\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Converts a quaternion to a rotation angle in radians.\n *\n * @param {Array<number>} quaternion - An array containing the quaternion components (w, x, y, z)\n * @returns {number} The rotation angle in radians\n */\nfunction quaternionToAngle(quaternion) {}", "test_code": "describe('TestQuaternionToAngle', () => {\n    it('test identity quaternion (no rotation)', () => {\n        const quaternion = [1.0, 0.0, 0.0, 0.0];\n        const expectedAngle = 0.0;\n        expect(quaternionToAngle(quaternion)).toBeCloseTo(expectedAngle);\n    });\n\n    it('test quaternion representing a 180-degree rotation', () => {\n        const quaternion = [0.0, 0.0, 1.0, 0.0];  // 180 degrees around Z axis\n        const expectedAngle = Math.PI;  // 180 degrees in radians\n        expect(quaternionToAngle(quaternion)).toBeCloseTo(expectedAngle);\n    });\n\n    it('test quaternion representing a full 360-degree rotation', () => {\n        const quaternion = [1.0, 0.0, 0.0, 0.0];  // Full rotation\n        const expectedAngle = 0.0;  // 360 degrees is equivalent to 0 degrees\n        expect(quaternionToAngle(quaternion)).toBeCloseTo(expectedAngle);\n    });\n\n    it('test non-unit quaternion (should still give correct angle)', () => {\n        const quaternion = [0.5, 0.5, 0.5, 0.5];  // This is not normalized\n        // Normalize the quaternion first\n        const norm = Math.sqrt(quaternion.reduce((acc, val) => acc + val ** 2, 0));\n        const normalizedQuaternion = quaternion.map(x => x / norm);\n        const expectedAngle = 2 * Math.acos(normalizedQuaternion[0]);  // Should be same angle\n        expect(quaternionToAngle(normalizedQuaternion)).toBeCloseTo(expectedAngle);\n    });\n\n    it('test invalid quaternion raises a ValueError', () => {\n        expect(() => quaternionToAngle([1.0, 0.0, 0.0])).toThrow();\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Converts a quaternion to a rotation angle in radians.\n *\n * @param {Array<number>} quaternion - An array containing the quaternion components (w, x, y, z)\n * @returns {number} The rotation angle in radians\n */\nfunction quaternionToAngle(quaternion) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Converts a quaternion to a rotation angle in radians.\n *\n * @param quaternion - A tuple or list containing the quaternion components (w, x, y, z)\n * @returns The rotation angle in radians\n */\nfunction quaternionToAngle(quaternion: [number, number, number, number]): number {}", "test_code": "describe('quaternionToAngle', () => {\n    it('test the identity quaternion (no rotation)', () => {\n        const quaternion = [1.0, 0.0, 0.0, 0.0];\n        const expectedAngle = 0.0;\n        expect(quaternionToAngle(quaternion)).toBeCloseTo(expectedAngle);\n    });\n\n    it('test a quaternion representing a 180-degree rotation', () => {\n        const quaternion = [0.0, 0.0, 1.0, 0.0]; // 180 degrees around Z axis\n        const expectedAngle = Math.PI; // 180 degrees in radians\n        expect(quaternionToAngle(quaternion)).toBeCloseTo(expectedAngle);\n    });\n\n    it('test a quaternion representing a full 360-degree rotation', () => {\n        const quaternion = [1.0, 0.0, 0.0, 0.0]; // Full rotation\n        const expectedAngle = 0.0; // 360 degrees is equivalent to 0 degrees\n        expect(quaternionToAngle(quaternion)).toBeCloseTo(expectedAngle);\n    });\n\n    it('test a non-unit quaternion (should still give correct angle)', () => {\n        const quaternion = [0.5, 0.5, 0.5, 0.5]; // This is not normalized\n        // Normalize the quaternion first\n        const norm = Math.sqrt(quaternion.reduce((acc, val) => acc + val ** 2, 0));\n        const normalizedQuaternion = quaternion.map(x => x / norm);\n        const expectedAngle = 2 * Math.acos(normalizedQuaternion[0]); // Should be same angle\n        expect(quaternionToAngle(normalizedQuaternion)).toBeCloseTo(expectedAngle);\n    });\n\n    it('test that an invalid quaternion raises an error', () => {\n        expect(() => quaternionToAngle([1.0, 0.0, 0.0])).toThrow();\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Converts a quaternion to a rotation angle in radians.\n *\n * @param quaternion - A tuple or list containing the quaternion components (w, x, y, z)\n * @returns The rotation angle in radians\n */\nfunction quaternionToAngle(quaternion: [number, number, number, number]): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * Converts a quaternion to a rotation angle in radians.\n *\n * @param quaternion A vector containing the quaternion components (w, x, y, z)\n * @return The rotation angle in radians\n */\ndouble quaternion_to_angle(const std::vector<double>& quaternion) {}", "test_code": "TEST_CASE(\"Test Quaternion to Angle\", \"[quaternion_to_angle]\") {\n    SECTION(\"Test the identity quaternion (no rotation)\") {\n        std::vector<double> quaternion = {1.0, 0.0, 0.0, 0.0};\n        double expected_angle = 0.0;\n        REQUIRE(quaternion_to_angle(quaternion) == Approx(expected_angle));\n    }\n\n    SECTION(\"Test a quaternion representing a 180-degree rotation\") {\n        std::vector<double> quaternion = {0.0, 0.0, 1.0, 0.0};  // 180 degrees around Z axis\n        double expected_angle = M_PI;  // 180 degrees in radians\n        REQUIRE(quaternion_to_angle(quaternion) == Approx(expected_angle));\n    }\n\n    SECTION(\"Test a quaternion representing a full 360-degree rotation\") {\n        std::vector<double> quaternion = {1.0, 0.0, 0.0, 0.0};  // Full rotation\n        double expected_angle = 0.0;  // 360 degrees is equivalent to 0 degrees\n        REQUIRE(quaternion_to_angle(quaternion) == Approx(expected_angle));\n    }\n\n    SECTION(\"Test a non-unit quaternion (should still give correct angle)\") {\n        std::vector<double> quaternion = {0.5, 0.5, 0.5, 0.5};  // This is not normalized\n        // Normalize the quaternion first\n        double norm = std::sqrt(std::accumulate(quaternion.begin(), quaternion.end(), 0.0,\n                                                [](double sum, double value) { return sum + value * value; }));\n        std::vector<double> normalized_quaternion;\n        for (double x : quaternion) {\n            normalized_quaternion.push_back(x / norm);\n        }\n        double expected_angle = 2 * std::acos(normalized_quaternion[0]);  // Should be same angle\n        REQUIRE(quaternion_to_angle(normalized_quaternion) == Approx(expected_angle));\n    }\n\n    SECTION(\"Test that an invalid quaternion raises a std::invalid_argument\") {\n        REQUIRE_THROWS_AS(quaternion_to_angle({1.0, 0.0, 0.0}), std::invalid_argument);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * Converts a quaternion to a rotation angle in radians.\n *\n * @param quaternion A vector containing the quaternion components (w, x, y, z)\n * @return The rotation angle in radians\n */\ndouble quaternion_to_angle(const std::vector<double>& quaternion) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts a quaternion to a rotation angle in radians.\n *\n * @param quaternion An array containing the quaternion components (w, x, y, z)\n * @return The rotation angle in radians\n */\npublic static double quaternionToAngle(double[] quaternion) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\npublic class Tester {\n\n    private static final double DELTA = 1e-15;\n\n    @Test\n    public void testIdentityQuaternion() {\n        double[] quaternion = {1.0, 0.0, 0.0, 0.0};\n        double expectedAngle = 0.0;\n        assertEquals(expectedAngle, quaternionToAngle(quaternion), DELTA);\n    }\n\n    @Test\n    public void test180DegreesRotation() {\n        double[] quaternion = {0.0, 0.0, 1.0, 0.0};  // 180 degrees around Z axis\n        double expectedAngle = Math.PI;  // 180 degrees in radians\n        assertEquals(expectedAngle, quaternionToAngle(quaternion), DELTA);\n    }\n\n    @Test\n    public void test360DegreesRotation() {\n        double[] quaternion = {1.0, 0.0, 0.0, 0.0};  // Full rotation\n        double expectedAngle = 0.0;  // 360 degrees is equivalent to 0 degrees\n        assertEquals(expectedAngle, quaternionToAngle(quaternion), DELTA);\n    }\n\n    @Test\n    public void testNonUnitQuaternion() {\n        double[] quaternion = {0.5, 0.5, 0.5, 0.5};  // This is not normalized\n        // Normalize the quaternion first\n        double norm = Math.sqrt(Arrays.stream(quaternion).map(x -> x * x).sum());\n        double[] normalizedQuaternion = Arrays.stream(quaternion).map(x -> x / norm).toArray();\n        double expectedAngle = 2 * Math.acos(normalizedQuaternion[0]);  // Should be same angle\n        assertEquals(expectedAngle, quaternionToAngle(normalizedQuaternion), DELTA);\n    }\n\n    @Test\n    public void testInvalidQuaternion() {\n        assertThrows(IllegalArgumentException.class, () -> {\n            quaternionToAngle(new double[]{1.0, 0.0, 0.0});  // Only 3 components\n        });\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts a quaternion to a rotation angle in radians.\n *\n * @param quaternion An array containing the quaternion components (w, x, y, z)\n * @return The rotation angle in radians\n */\npublic static double quaternionToAngle(double[] quaternion) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 557, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "Convert an angle from radians to degrees", "language_version_list": {"python": {"code_signature": "def radians_to_degrees(radians: float) -> int:\n    \"\"\"\n    Convert an angle from radians to degrees.\n\n    Args:\n        radians (float): The angle in radians to convert.\n\n    Returns:\n        int: The angle in degrees.\n    \"\"\"\n", "test_code": "import math\nimport unittest\n\n\nclass TestRadiansToDegrees(unittest.TestCase):\n    def test_zero_radians(self):\n        \"\"\"Test conversion of 0 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(0), 0, places=5)\n\n    def test_pi_over_two_radians(self):\n        \"\"\"Test conversion of \u03c0/2 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(math.pi / 2), 90, places=5)\n\n    def test_pi_radians(self):\n        \"\"\"Test conversion of \u03c0 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(math.pi), 180, places=5)\n\n    def test_three_pi_over_two_radians(self):\n        \"\"\"Test conversion of 3\u03c0/2 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(3 * math.pi / 2), 270, places=5)\n\n    def test_two_pi_radians(self):\n        \"\"\"Test conversion of 2\u03c0 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(2 * math.pi), 360, places=5)\n\n    def test_negative_pi_over_two_radians(self):\n        \"\"\"Test conversion of -\u03c0/2 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(-math.pi / 2), -90, places=5)\n\n    def test_large_radians(self):\n        \"\"\"Test conversion of a large angle (4\u03c0 radians)\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(4 * math.pi), 720, places=5)", "prompt": "please write a python function , the function signature as below def radians_to_degrees(radians: float) -> int:\n    \"\"\"\n    Convert an angle from radians to degrees.\n\n    Args:\n        radians (float): The angle in radians to convert.\n\n    Returns:\n        int: The angle in degrees.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Convert an angle from radians to degrees.\n * \n * @param {number} radians - The angle in radians to convert.\n * @return {number} The angle in degrees.\n */\nfunction radiansToDegrees(radians) {}", "test_code": "describe('TestRadiansToDegrees', () => {\n    it('test conversion of 0 radians', () => {\n        expect(radiansToDegrees(0)).toBeCloseTo(0, 5);\n    });\n\n    it('test conversion of \u03c0/2 radians', () => {\n        expect(radiansToDegrees(Math.PI / 2)).toBeCloseTo(90, 5);\n    });\n\n    it('test conversion of \u03c0 radians', () => {\n        expect(radiansToDegrees(Math.PI)).toBeCloseTo(180, 5);\n    });\n\n    it('test conversion of 3\u03c0/2 radians', () => {\n        expect(radiansToDegrees(3 * Math.PI / 2)).toBeCloseTo(270, 5);\n    });\n\n    it('test conversion of 2\u03c0 radians', () => {\n        expect(radiansToDegrees(2 * Math.PI)).toBeCloseTo(360, 5);\n    });\n\n    it('test conversion of -\u03c0/2 radians', () => {\n        expect(radiansToDegrees(-Math.PI / 2)).toBeCloseTo(-90, 5);\n    });\n\n    it('test conversion of a large angle (4\u03c0 radians)', () => {\n        expect(radiansToDegrees(4 * Math.PI)).toBeCloseTo(720, 5);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Convert an angle from radians to degrees.\n * \n * @param {number} radians - The angle in radians to convert.\n * @return {number} The angle in degrees.\n */\nfunction radiansToDegrees(radians) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Convert an angle from radians to degrees.\n *\n * @param radians - The angle in radians to convert.\n * @returns The angle in degrees.\n */\nfunction radiansToDegrees(radians: number): number {}", "test_code": "describe('radiansToDegrees', () => {\n    it('should convert 0 radians to 0 degrees', () => {\n        expect(radiansToDegrees(0)).toBeCloseTo(0, 5);\n    });\n\n    it('should convert \u03c0/2 radians to 90 degrees', () => {\n        expect(radiansToDegrees(PI / 2)).toBeCloseTo(90, 5);\n    });\n\n    it('should convert \u03c0 radians to 180 degrees', () => {\n        expect(radiansToDegrees(PI)).toBeCloseTo(180, 5);\n    });\n\n    it('should convert 3\u03c0/2 radians to 270 degrees', () => {\n        expect(radiansToDegrees(3 * PI / 2)).toBeCloseTo(270, 5);\n    });\n\n    it('should convert 2\u03c0 radians to 360 degrees', () => {\n        expect(radiansToDegrees(2 * PI)).toBeCloseTo(360, 5);\n    });\n\n    it('should convert -\u03c0/2 radians to -90 degrees', () => {\n        expect(radiansToDegrees(-PI / 2)).toBeCloseTo(-90, 5);\n    });\n\n    it('should convert 4\u03c0 radians to 720 degrees', () => {\n        expect(radiansToDegrees(4 * PI)).toBeCloseTo(720, 5);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Convert an angle from radians to degrees.\n *\n * @param radians - The angle in radians to convert.\n * @returns The angle in degrees.\n */\nfunction radiansToDegrees(radians: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert an angle from radians to degrees.\n *\n * @param radians The angle in radians to convert.\n * @return The angle in degrees as an integer.\n */\nint radians_to_degrees(double radians) {}", "test_code": "TEST_CASE(\"Test conversion of various angles\", \"[RadiansToDegrees]\") {\n    SECTION(\"Test conversion of 0 radians\") {\n        REQUIRE(radians_to_degrees(0) == 0);\n    }\n\n    SECTION(\"Test conversion of \u03c0/2 radians\") {\n        REQUIRE_THAT(radians_to_degrees(M_PI / 2), Catch::Matchers::WithinAbs(90, 0.00001));\n    }\n\n    SECTION(\"Test conversion of \u03c0 radians\") {\n        REQUIRE_THAT(radians_to_degrees(M_PI), Catch::Matchers::WithinAbs(180, 0.00001));\n    }\n\n    SECTION(\"Test conversion of 3\u03c0/2 radians\") {\n        REQUIRE_THAT(radians_to_degrees(3 * M_PI / 2), Catch::Matchers::WithinAbs(270, 0.00001));\n    }\n\n    SECTION(\"Test conversion of 2\u03c0 radians\") {\n        REQUIRE_THAT(radians_to_degrees(2 * M_PI), Catch::Matchers::WithinAbs(360, 0.00001));\n    }\n\n    SECTION(\"Test conversion of -\u03c0/2 radians\") {\n        REQUIRE_THAT(radians_to_degrees(-M_PI / 2), Catch::Matchers::WithinAbs(-90, 0.00001));\n    }\n\n    SECTION(\"Test conversion of a large angle (4\u03c0 radians)\") {\n        REQUIRE_THAT(radians_to_degrees(4 * M_PI), Catch::Matchers::WithinAbs(720, 0.00001));\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert an angle from radians to degrees.\n *\n * @param radians The angle in radians to convert.\n * @return The angle in degrees as an integer.\n */\nint radians_to_degrees(double radians) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts an angle from radians to degrees.\n *\n * @param radians The angle in radians to convert.\n * @return The angle in degrees as an integer.\n */\npublic static int radiansToDegrees(double radians) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\n/**\n * Test class for converting radians to degrees.\n */\npublic class Tester {\n\n    /**\n     * Test conversion of 0 radians.\n     */\n    @Test\n    public void testZeroRadians() {\n        assertEquals(\"Conversion of 0 radians\", 0, radiansToDegrees(0), 0.00001);\n    }\n\n    /**\n     * Test conversion of \u03c0/2 radians.\n     */\n    @Test\n    public void testPiOverTwoRadians() {\n        assertEquals(\"Conversion of \u03c0/2 radians\", 90, radiansToDegrees(Math.PI / 2), 0.00001);\n    }\n\n    /**\n     * Test conversion of \u03c0 radians.\n     */\n    @Test\n    public void testPiRadians() {\n        assertEquals(\"Conversion of \u03c0 radians\", 180, radiansToDegrees(Math.PI), 0.00001);\n    }\n\n    /**\n     * Test conversion of 3\u03c0/2 radians.\n     */\n    @Test\n    public void testThreePiOverTwoRadians() {\n        assertEquals(\"Conversion of 3\u03c0/2 radians\", 270, radiansToDegrees(3 * Math.PI / 2), 0.00001);\n    }\n\n    /**\n     * Test conversion of 2\u03c0 radians.\n     */\n    @Test\n    public void testTwoPiRadians() {\n        assertEquals(\"Conversion of 2\u03c0 radians\", 360, radiansToDegrees(2 * Math.PI), 0.00001);\n    }\n\n    /**\n     * Test conversion of -\u03c0/2 radians.\n     */\n    @Test\n    public void testNegativePiOverTwoRadians() {\n        assertEquals(\"Conversion of -\u03c0/2 radians\", -90, radiansToDegrees(-Math.PI / 2), 0.00001);\n    }\n\n    /**\n     * Test conversion of a large angle (4\u03c0 radians).\n     */\n    @Test\n    public void testLargeRadians() {\n        assertEquals(\"Conversion of 4\u03c0 radians\", 720, radiansToDegrees(4 * Math.PI), 0.00001);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts an angle from radians to degrees.\n *\n * @param radians The angle in radians to convert.\n * @return The angle in degrees as an integer.\n */\npublic static int radiansToDegrees(double radians) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
{"task_id": 558, "code_type": "method", "original_language": "python", "question_type": "Scientific computation and numerical analysis", "summary": "Convert an angle from degrees to radians", "language_version_list": {"python": {"code_signature": "import math\n\n\ndef degrees_to_radians(degrees: int) -> float:\n    \"\"\"\n    Convert an angle from degrees to radians.\n\n    Args:\n        degrees (int): The angle in degrees to convert.\n\n    Returns:\n        float: The angle in radians.\n    \"\"\"\n", "test_code": "import math\nimport unittest\n\n\nclass TestDegreesToRadians(unittest.TestCase):\n    def test_zero_degrees(self):\n        \"\"\"Test conversion of 0 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(0), 0, places=5)\n\n    def test_ninety_degrees(self):\n        \"\"\"Test conversion of 90 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(90), math.pi / 2, places=5)\n\n    def test_one_eighty_degrees(self):\n        \"\"\"Test conversion of 180 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(180), math.pi, places=5)\n\n    def test_two_seventy_degrees(self):\n        \"\"\"Test conversion of 270 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(270), 3 * math.pi / 2, places=5)\n\n    def test_three_sixty_degrees(self):\n        \"\"\"Test conversion of 360 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(360), 2 * math.pi, places=5)\n\n    def test_negative_degrees(self):\n        \"\"\"Test conversion of negative degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(-90), -math.pi / 2, places=5)\n\n    def test_large_degrees(self):\n        \"\"\"Test conversion of a large angle (720 degrees)\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(720), 4 * math.pi, places=5)\n", "prompt": "please write a python function , the function signature as below import math\n\n\ndef degrees_to_radians(degrees: int) -> float:\n    \"\"\"\n    Convert an angle from degrees to radians.\n\n    Args:\n        degrees (int): The angle in degrees to convert.\n\n    Returns:\n        float: The angle in radians.\n    \"\"\"\n", "addition_info": ""}, "javascript": {"code_signature": "/**\n * Convert an angle from degrees to radians.\n * \n * @param {number} degrees - The angle in degrees to convert.\n * @returns {number} The angle in radians.\n */\nfunction degreesToRadians(degrees) {}", "test_code": "describe('TestDegreesToRadians', () => {\n    it('test conversion of 0 degrees', () => {\n        expect(degreesToRadians(0)).toBeCloseTo(0, 5);\n    });\n\n    it('test conversion of 90 degrees', () => {\n        expect(degreesToRadians(90)).toBeCloseTo(Math.PI / 2, 5);\n    });\n\n    it('test conversion of 180 degrees', () => {\n        expect(degreesToRadians(180)).toBeCloseTo(Math.PI, 5);\n    });\n\n    it('test conversion of 270 degrees', () => {\n        expect(degreesToRadians(270)).toBeCloseTo(3 * Math.PI / 2, 5);\n    });\n\n    it('test conversion of 360 degrees', () => {\n        expect(degreesToRadians(360)).toBeCloseTo(2 * Math.PI, 5);\n    });\n\n    it('test conversion of negative degrees', () => {\n        expect(degreesToRadians(-90)).toBeCloseTo(-Math.PI / 2, 5);\n    });\n\n    it('test conversion of a large angle (720 degrees)', () => {\n        expect(degreesToRadians(720)).toBeCloseTo(4 * Math.PI, 5);\n    });\n});", "prompt": "please write a javascript function , the function signature as below /**\n * Convert an angle from degrees to radians.\n * \n * @param {number} degrees - The angle in degrees to convert.\n * @returns {number} The angle in radians.\n */\nfunction degreesToRadians(degrees) {}", "addition_info": ""}, "typescript": {"code_signature": "/**\n * Convert an angle from degrees to radians.\n *\n * @param degrees - The angle in degrees to convert.\n * @returns The angle in radians.\n */\nfunction degreesToRadians(degrees: number): number {}", "test_code": "describe('degreesToRadians', () => {\n    it('should convert 0 degrees to 0 radians', () => {\n        expect(degreesToRadians(0)).toBeCloseTo(0, 5);\n    });\n\n    it('should convert 90 degrees to \u03c0/2 radians', () => {\n        expect(degreesToRadians(90)).toBeCloseTo(PI / 2, 5);\n    });\n\n    it('should convert 180 degrees to \u03c0 radians', () => {\n        expect(degreesToRadians(180)).toBeCloseTo(PI, 5);\n    });\n\n    it('should convert 270 degrees to 3\u03c0/2 radians', () => {\n        expect(degreesToRadians(270)).toBeCloseTo(3 * PI / 2, 5);\n    });\n\n    it('should convert 360 degrees to 2\u03c0 radians', () => {\n        expect(degreesToRadians(360)).toBeCloseTo(2 * PI, 5);\n    });\n\n    it('should convert -90 degrees to -\u03c0/2 radians', () => {\n        expect(degreesToRadians(-90)).toBeCloseTo(-PI / 2, 5);\n    });\n\n    it('should convert 720 degrees to 4\u03c0 radians', () => {\n        expect(degreesToRadians(720)).toBeCloseTo(4 * PI, 5);\n    });\n});", "prompt": "please write a typescript function , the function signature as below /**\n * Convert an angle from degrees to radians.\n *\n * @param degrees - The angle in degrees to convert.\n * @returns The angle in radians.\n */\nfunction degreesToRadians(degrees: number): number {}", "addition_info": ""}, "c&cpp": {"code_signature": "/**\n * @brief Convert an angle from degrees to radians.\n *\n * @param degrees The angle in degrees to convert.\n * @return The angle in radians.\n */\ndouble degrees_to_radians(int degrees) {}", "test_code": "TEST_CASE(\"Test conversion of angles\", \"[degrees_to_radians]\") {\n    SECTION(\"Test conversion of 0 degrees\") {\n        REQUIRE(std::abs(degrees_to_radians(0) - 0) < 1e-5);\n    }\n\n    SECTION(\"Test conversion of 90 degrees\") {\n        REQUIRE(std::abs(degrees_to_radians(90) - (M_PI / 2)) < 1e-5);\n    }\n\n    SECTION(\"Test conversion of 180 degrees\") {\n        REQUIRE(std::abs(degrees_to_radians(180) - M_PI) < 1e-5);\n    }\n\n    SECTION(\"Test conversion of 270 degrees\") {\n        REQUIRE(std::abs(degrees_to_radians(270) - (3 * M_PI / 2)) < 1e-5);\n    }\n\n    SECTION(\"Test conversion of 360 degrees\") {\n        REQUIRE(std::abs(degrees_to_radians(360) - (2 * M_PI)) < 1e-5);\n    }\n\n    SECTION(\"Test conversion of negative degrees\") {\n        REQUIRE(std::abs(degrees_to_radians(-90) - (-M_PI / 2)) < 1e-5);\n    }\n\n    SECTION(\"Test conversion of a large angle (720 degrees)\") {\n        REQUIRE(std::abs(degrees_to_radians(720) - (4 * M_PI)) < 1e-5);\n    }\n}", "prompt": "please write a cpp function , the function signature as below /**\n * @brief Convert an angle from degrees to radians.\n *\n * @param degrees The angle in degrees to convert.\n * @return The angle in radians.\n */\ndouble degrees_to_radians(int degrees) {}", "addition_info": ""}, "java": {"code_signature": "/**\n * Converts an angle from degrees to radians.\n *\n * @param degrees The angle in degrees to convert.\n * @return The angle in radians.\n */\npublic static double degreesToRadians(int degrees) {}", "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Tester {\n    @Test\n    public void testZeroDegrees() {\n        // Test conversion of 0 degrees\n        assertEquals(0, degreesToRadians(0), 1e-5);\n    }\n\n    @Test\n    public void testNinetyDegrees() {\n        // Test conversion of 90 degrees\n        assertEquals(Math.PI / 2, degreesToRadians(90), 1e-5);\n    }\n\n    @Test\n    public void testOneEightyDegrees() {\n        // Test conversion of 180 degrees\n        assertEquals(Math.PI, degreesToRadians(180), 1e-5);\n    }\n\n    @Test\n    public void testTwoSeventyDegrees() {\n        // Test conversion of 270 degrees\n        assertEquals(3 * Math.PI / 2, degreesToRadians(270), 1e-5);\n    }\n\n    @Test\n    public void testThreeSixtyDegrees() {\n        // Test conversion of 360 degrees\n        assertEquals(2 * Math.PI, degreesToRadians(360), 1e-5);\n    }\n\n    @Test\n    public void testNegativeDegrees() {\n        // Test conversion of negative degrees\n        assertEquals(-Math.PI / 2, degreesToRadians(-90), 1e-5);\n    }\n\n    @Test\n    public void testLargeDegrees() {\n        // Test conversion of a large angle (720 degrees)\n        assertEquals(4 * Math.PI, degreesToRadians(720), 1e-5);\n    }\n}", "prompt": "please write a java function , the function signature as below /**\n * Converts an angle from degrees to radians.\n *\n * @param degrees The angle in degrees to convert.\n * @return The angle in radians.\n */\npublic static double degreesToRadians(int degrees) {},package is org.real.temp, class is Answer", "addition_info": ""}}}
